{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module is a 4-to-1 multiplexer with a specified BUS_WIDTH parameter. It takes four input buses (IN1, IN2, IN3, IN4) and a 2-bit SELECT signal, and outputs the selected input through the OUT bus. The selection of the input is based on the value of the SELECT signal. Inside the module, there is a reg out_reg to store the selected input, and an always block that uses a case statement to assign the selected input to out_reg based on the value of SELECT. Finally, the OUT bus is assigned the value of out_reg to produce the selected output.\n\n Module header:\n\nmodule MULTIPLEXER_4_TO_1 #(parameter BUS_WIDTH = 32) (input [BUS_WIDTH - 1 : 0] IN1 ,input [BUS_WIDTH - 1 : 0] IN2 ,input [BUS_WIDTH - 1 : 0] IN3 ,input [BUS_WIDTH - 1 : 0] IN4 ,input [1 : 0] SELECT ,output [BUS_WIDTH - 1 : 0] OUT);\n [/INST]\n", "output": "reg [BUS_WIDTH - 1 : 0] out_reg; \n  always@(*) \n  begin \n  case(SELECT) \n  2'b00: \n  begin \n  out_reg = IN1; \n  end \n  2'b01: \n  begin \n  out_reg = IN2; \n  end \n  2'b10: \n  begin \n  out_reg = IN3; \n  end \n  2'b11: \n  begin \n  out_reg = IN4; \n  end \n  endcase \n  end \n  assign OUT = out_reg; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a state machine for a video processor, generating horizontal and vertical sync pulses, detecting color bursts, and assigning RGB color values based on input signals. It also includes a font creation block, and it operates on a 50MHz clock. The module includes state transitions based on various conditions, such as counting variables for sync pulses and color bursts. It also handles the assignment of data values based on specific conditions and resets the counting variables accordingly.\n\n Module header:\n\nmodule rk_video(input clk50mhz,output hr,output vr,output cce,output [3:0] r,output [3:0] g,output [3:0] b,input[3:0] line,input[6:0] ichar,input vsp,input lten,input rvv,input videomode);\n [/INST]\n", "output": "reg[1:0] state; \n reg[9:0] h_cnt; \n reg[9:0] v_cnt; \n reg[2:0] d_cnt; \n reg[5:0] data; \n wire[7:0] fdata; \n assign hr = h_cnt >= 10'd478 && h_cnt < 10'd530 ? 1'b0 : 1'b1; \n assign vr = v_cnt >= 10'd608 && v_cnt < 10'd614 ? 1'b0 : 1'b1; \n assign cce = d_cnt==3'b000 && state==2'b01; \n assign r = data[5] ? (videomode ? 4'b0011 : 4'b1000): 4'b0; \n assign g = data[5] ? (videomode ? 4'b1000 : 4'b1000): 4'b0; \n assign b = data[5] ? (videomode ? 4'b0011 : 4'b1000): 4'b0; \n font from(.addra({ichar[6:0],line[2:0]}), .clka(clk50mhz), .douta(fdata)); \n always @(posedge clk50mhz) \n begin \n  casex (state) \n  2'b00: state <= 2'b01; \n  2'b01: state <= 2'b10; \n  2'b1x: state <= 2'b00; \n  endcase \n  if (state==2'b00) begin \n  if (d_cnt==3'b101) begin \n  data <= lten ? 6'h3F : vsp ? 6'b0 : fdata[5:0]^{6{rvv}}; \n  end else \n  data <= {data[4:0],1'b0}; \n  if (h_cnt+1'b1 == 10'd533) begin \n  h_cnt <= 0; d_cnt <= 0; \n  if (v_cnt+1'b1 == 10'd625 ) begin \n  v_cnt <= 0; \n  end else begin \n  v_cnt <= v_cnt+1'b1; \n  end \n  end else begin \n  h_cnt <= h_cnt+1'b1; \n  if (d_cnt+1'b1 == 3'b110) begin \n  d_cnt <= 0; \n  end else \n  d_cnt <= d_cnt+1'b1; \n  end \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a Linear Feedback Shift Register (LFSR) with configurable parameters such as polynomial, width, initial value, and PRBS (Pseudo-Random Binary Sequence) width. The LFSR state is updated based on the clock signal, reset signal, stall signal, and clear signal. The module produces two outputs, lfsr_state and prbs, which represent the current state of the LFSR and the generated PRBS, respectively. The LFSR state is updated serially based on the polynomial and the PRBS is generated based on the updated LFSR state. The module also handles the reset and clear operations to maintain the LFSR's state.\n\n Module header:\n\nmodule zl_lfsr # (parameter LFSR_poly = 0,parameter LFSR_width = 0,parameter LFSR_init_value = 0,parameter PRBS_width = 0) (input clk,input rst_n,input stall,input clear,output [LFSR_width-1:0] lfsr_state,output [PRBS_width-1:0] prbs);\n [/INST]\n", "output": "reg [LFSR_width-1:0] state_reg; \n reg [LFSR_width-1:0] state_next; \n reg [PRBS_width-1:0] prbs_internal; \n integer i; \n function [LFSR_width-1:0] lfsr_state_next_serial; \n  input [LFSR_width-1:0] cur_state; \n  begin \n  lfsr_state_next_serial = {cur_state[LFSR_width-2:0], \n  ^(cur_state & LFSR_poly[LFSR_width:1])}; \n  end \n endfunction \n always @(*) begin \n  state_next = state_reg; \n  for(i=0;i<PRBS_width;i=i+1) begin \n  state_next = lfsr_state_next_serial(state_next); \n  prbs_internal[PRBS_width-i-1] = state_next[0]; \n  end \n end \n always @(posedge clk or negedge rst_n) begin \n  if(!rst_n) begin \n  state_reg <= LFSR_init_value; \n  end \n  else if (clear && !stall) begin \n  state_reg <= LFSR_init_value; \n  end \n  else if (!stall) begin \n  state_reg <= state_next; \n  end \n end \n assign lfsr_state = state_reg; \n assign prbs = prbs_internal; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, c_padder, takes an input data_in of width 32 and pads it on the left and right with specified values. It calculates a new width based on the padding and input width. It uses a generate block to iterate through each bit and assign the padding values or the original data_in values to the output data_out based on the padding configurations.\n\n Module header:\n\nmodule c_padder (data_in, data_out);\n [/INST]\n", "output": "parameter width = 32; \n  parameter pad_left = 0; \n  parameter pad_left_value = 0; \n  parameter pad_right = 0; \n  parameter pad_right_value = 0; \n  localparam new_width = pad_left + width + pad_right; \n  input [0:width-1] data_in; \n  output [0:new_width-1] data_out; \n  wire [0:new_width-1] data_out; \n  genvar i; \n  generate \n  for(i = 0; i < new_width; i = i + 1) \n  begin:bits \n  if(i < pad_left) \n  assign data_out[i] = pad_left_value; \n  else if(i >= (new_width - pad_right)) \n  assign data_out[i] = pad_right_value; \n  else \n  assign data_out[i] = data_in[i - pad_left]; \n  end \n  endgenerate \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a velocity control unit using Space Vector Modulation. It takes three input voltage signals and generates three output phase voltage signals. The module comprises several sub-modules for range conversion, min/max calculation, addition, and gain computation. The output phase voltages are computed based on the input voltage signals using these sub-modules.\n\n Module header:\n\nmodule velocityControlHdl_Space_Vector_Modulation (Vabc_Raw_0,Vabc_Raw_1,Vabc_Raw_2,phase_voltages_0,phase_voltages_1,phase_voltages_2);\n [/INST]\n", "output": "input signed [17:0] Vabc_Raw_0; \n  input signed [17:0] Vabc_Raw_1; \n  input signed [17:0] Vabc_Raw_2; \n  output signed [19:0] phase_voltages_0; \n  output signed [19:0] phase_voltages_1; \n  output signed [19:0] phase_voltages_2; \n  wire signed [17:0] Double_Range_out1_0; \n  wire signed [17:0] Double_Range_out1_1; \n  wire signed [17:0] Double_Range_out1_2; \n  wire signed [17:0] MinMax1_out1; \n  wire signed [17:0] MinMax_out1; \n  wire signed [18:0] Add_add_cast; \n  wire signed [18:0] Add_add_cast_1; \n  wire signed [18:0] Add_out1; \n  wire signed [37:0] Gain_cast; \n  wire signed [18:0] Gain_out1; \n  wire signed [19:0] Add1_sub_cast; \n  wire signed [19:0] Add1_sub_cast_1; \n  wire signed [19:0] Add1_out1; \n  wire signed [19:0] Add2_sub_cast; \n  wire signed [19:0] Add2_sub_cast_1; \n  wire signed [19:0] Add2_out1; \n  wire signed [19:0] Add3_sub_cast; \n  wire signed [19:0] Add3_sub_cast_1; \n  wire signed [19:0] Add3_out1; \n velocityControlHdl_Double_Range u_Double_Range (.In1_0(Vabc_Raw_0),.In1_1(Vabc_Raw_1),.In1_2(Vabc_Raw_2),.Out1_0(Double_Range_out1_0),.Out1_1(Double_Range_out1_1),.Out1_2(Double_Range_out1_2)); \n velocityControlHdl_MinMax1 u_MinMax1 (.in0(Double_Range_out1_0),.in1(Double_Range_out1_1),.in2(Double_Range_out1_2),.out0(MinMax1_out1)); \n velocityControlHdl_MinMax u_MinMax (.in0(Double_Range_out1_0),.in1(Double_Range_out1_1),.in2(Double_Range_out1_2),.out0(MinMax_out1)); \n  assign Add_add_cast = MinMax1_out1; \n  assign Add_add_cast_1 = MinMax_out1; \n  assign Add_out1 = Add_add_cast + Add_add_cast_1; \n  assign Gain_cast = {{2{Add_out1[18]}}, {Add_out1, 17'b00000000000000000}}; \n  assign Gain_out1 = Gain_cast[36:18]; \n  assign Add1_sub_cast = Double_Range_out1_0; \n  assign Add1_sub_cast_1 = Gain_out1; \n  assign Add1_out1 = Add1_sub_cast - Add1_sub_cast_1; \n  assign phase_voltages_0 = Add1_out1; \n  assign Add2_sub_cast = Double_Range_out1_1; \n  assign Add2_sub_cast_1 = Gain_out1; \n  assign Add2_out1 = Add2_sub_cast - Add2_sub_cast_1; \n  assign phase_voltages_1 = Add2_out1; \n  assign Add3_sub_cast = Double_Range_out1_2; \n  assign Add3_sub_cast_1 = Gain_out1; \n  assign Add3_out1 = Add3_sub_cast - Add3_sub_cast_1; \n  assign phase_voltages_2 = Add3_out1; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a Serial Peripheral Interface (SPI) controller following the Mode 0 protocol. It has inputs for the clock signal, reset, send/receive control, data input, and outputs for data output, master output/slave input (MOSI), serial clock (SCLK), busy signal, and data output. The module includes a state machine that manages the transmission of data based on the clock signal and the state of the SPI interface. The data transmission is synchronized with the clock and follows the specified protocol for SPI communication.\n\n Module header:\n\nmodule spiMode0(CLK,RST,sndRec,DIN,MISO,MOSI,SCLK,BUSY,DOUT);\n [/INST]\n", "output": "input CLK; \n  input RST; \n  input sndRec; \n  input [7:0] DIN; \n  input MISO; \n  output MOSI; \n  output SCLK; \n  output BUSY; \n  output [7:0] DOUT; \n  wire MOSI; \n  wire SCLK; \n  wire [7:0] DOUT; \n  reg BUSY; \n  parameter [1:0] Idle = 2'd0, \n  Init = 2'd1, \n  RxTx = 2'd2, \n  Done = 2'd3; \n  reg [4:0] bitCount; \n  reg [7:0] rSR = 8'h00; \n  reg [7:0] wSR = 8'h00; \n  reg [1:0] pState = Idle; \n  reg CE = 0; \n  assign SCLK = (CE == 1'b1) ? CLK : 1'b0; \n  assign MOSI = wSR[7]; \n  assign DOUT = rSR; \n  always @(negedge CLK) begin \n  if(RST == 1'b1) begin \n  wSR <= 8'h00; \n  end \n  else begin \n  case(pState) \n  Idle : begin \n  wSR <= DIN; \n  end \n  Init : begin \n  wSR <= wSR; \n  end \n  RxTx : begin \n  if(CE == 1'b1) begin \n  wSR <= {wSR[6:0], 1'b0}; \n  end \n  end \n  Done : begin \n  wSR <= wSR; \n  end \n  endcase \n  end \n  end \n  always @(posedge CLK) begin \n  if(RST == 1'b1) begin \n  rSR <= 8'h00; \n  end \n  else begin \n  case(pState) \n  Idle : begin \n  rSR <= rSR; \n  end \n  Init : begin \n  rSR <= rSR; \n  end \n  RxTx : begin \n  if(CE == 1'b1) begin \n  rSR <= {rSR[6:0], MISO}; \n  end \n  end \n  Done : begin \n  rSR <= rSR; \n  end \n  endcase \n  end \n  end \n  always @(negedge CLK) begin \n  if(RST == 1'b1) begin \n  CE <= 1'b0; \n  BUSY <= 1'b0; \n  bitCount <= 4'h0; \n  pState <= Idle; \n  end \n  else begin \n  case (pState) \n  Idle : begin \n  CE <= 1'b0; \n  BUSY <= 1'b0; \n  bitCount <= 4'd0; \n  if(sndRec == 1'b1) begin \n  pState <= Init; \n  end \n  else begin \n  pState <= Idle; \n  end \n  end \n  Init : begin \n  BUSY <= 1'b1; \n  bitCount <= 4'h0; \n  CE <= 1'b0; \n  pState <= RxTx; \n  end \n  RxTx : begin \n  BUSY <= 1'b1; \n  bitCount <= bitCount + 1'b1; \n  if(bitCount >= 4'd8) begin \n  CE <= 1'b0; \n  end \n  else begin \n  CE <= 1'b1; \n  end \n  if(bitCount == 4'd8) begin \n  pState <= Done; \n  end \n  else begin \n  pState <= RxTx; \n  end \n  end \n  Done : begin \n  CE <= 1'b0; \n  BUSY <= 1'b1; \n  bitCount <= 4'd0; \n  pState <= Idle; \n  end \n  default : pState <= Idle; \n  endcase \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module `tracking_camera_system_sysid_qsys_0` takes an address input and outputs readdata. If the address is non-zero, the readdata is set to a specific value; otherwise, it is set to zero. The module is clocked and has a reset signal to control its operation.\n\n Module header:\n\nmodule tracking_camera_system_sysid_qsys_0 (address,clock,reset_n,readdata);\n [/INST]\n", "output": "output [ 31: 0] readdata; \n  input address; \n  input clock; \n  input reset_n; \n  wire [ 31: 0] readdata; \n  assign readdata = address ? 1425077675 : 0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"Comparador\" compares the input write_value with the stored read_value_reg. If they match, led_success is set, otherwise led_fail is set. The read_value_reg is updated based on the read_value when read_value_reg_en is asserted, or reset to 0 when the reset signal is asserted. The module is sensitive to the clock and reset signals and includes the necessary logic for updating the read_value_reg.\n\n Module header:\n\nmodule Comparador(clock, reset, write_value, read_value,read_value_reg_en, led_success, led_fail);\n [/INST]\n", "output": "input clock, reset, read_value_reg_en; \n  input [3:0] write_value, read_value; \n  output led_success, led_fail; \n  reg [3:0] read_value_reg; \n  assign led_success = (write_value == read_value_reg); \n  assign led_fail = ~led_success; \n  always @( posedge clock or posedge reset) \n  begin \n  if(reset) \n  begin \n  read_value_reg <= 4'b0; \n  end \n  else if (read_value_reg_en) \n  begin \n  read_value_reg <= read_value; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module performs flag domain crossing between two clock domains, CLK_A and CLK_B. It synchronizes the FLAG_IN_CLK_A input from CLK_A domain to the FLAG_OUT_CLK_B output in CLK_B domain using three flip-flops. The FLAG_TOGGLE_CLK_A signal toggles whenever FLAG_IN_CLK_A is high. The flag_out_d_ff_1, flag_out_d_ff_2, and flag_out_d_ff_3 registers store the synchronized signal. The output FLAG_OUT_CLK_B is the XOR of flag_out_d_ff_3 and flag_out_d_ff_2. This module ensures proper synchronization and handling of signals between different clock domains.\n\n Module header:\n\nmodule flag_domain_crossing(input wire CLK_A,input wire CLK_B,input wire FLAG_IN_CLK_A,output wire FLAG_OUT_CLK_B);\n [/INST]\n", "output": "reg FLAG_TOGGLE_CLK_A; \n initial FLAG_TOGGLE_CLK_A = 0; \n always @(posedge CLK_A) \n begin \n  if (FLAG_IN_CLK_A) \n  begin \n  FLAG_TOGGLE_CLK_A <= ~FLAG_TOGGLE_CLK_A; \n  end \n end \n (* ASYNC_REG = \"TRUE\" *) reg flag_out_d_ff_1; \n (* ASYNC_REG = \"TRUE\" *) reg flag_out_d_ff_2; \n reg flag_out_d_ff_3; \n always @(posedge CLK_B) \n begin \n  flag_out_d_ff_1 <= FLAG_TOGGLE_CLK_A; \n end \n always @(posedge CLK_B) \n begin \n  flag_out_d_ff_2 <= flag_out_d_ff_1; \n end \n always @(posedge CLK_B) \n begin \n  flag_out_d_ff_3 <= flag_out_d_ff_2; \n end \n assign FLAG_OUT_CLK_B = (flag_out_d_ff_3 ^ flag_out_d_ff_2); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements the Park transform. It takes in multiple input signals and performs various calculations on them based on the value of the INVERSE parameter. The module includes multiplexers, multiplication operations, and registers to generate the output signals out_0, out_1, and out_dv based on the input signals and the state of the pipe_cnt signal. The pipe_cnt signal is incremented and controls the flow of operations within the module. The output out_dv is set based on the value of pipe_cnt.\n\n Module header:\n\nmodule park #(parameter INVERSE=0) (input c,input in_dv,input signed [15:0] in_0,input signed [15:0] in_1,input signed [15:0] sin,input signed [15:0] cos,output signed [15:0] out_0,output signed [15:0] out_1,output out_dv);\n [/INST]\n", "output": "wire [2:0] pipe_cnt; \n r #(3) pipe_cnt_r \n (.c(c), .en(|pipe_cnt | in_dv), .rst(1'b0),.d(pipe_cnt + 1'b1), .q(pipe_cnt)); \n wire signed [15:0] input_z; \n gmux #(.DWIDTH(16), .SELWIDTH(1)) input_mux \n (.sel(pipe_cnt[0]), .z(input_z), .d({ in_1, in_0 })); \n wire [31:0] x_z_mux_d = INVERSE ? { sin, cos } : { -sin, cos }; \n wire signed [15:0] mult_x_z; \n gmux #(.DWIDTH(16), .SELWIDTH(1)) mult_x_z_mux \n (.sel(pipe_cnt[0]), .z(mult_x_z), .d(x_z_mux_d)); \n wire [31:0] y_z_mux_d = INVERSE ? { cos, -sin } : { cos, sin }; \n wire signed [15:0] mult_y_z; \n gmux #(.DWIDTH(16), .SELWIDTH(1)) mult_y_z_mux \n (.sel(pipe_cnt[0]), .z(mult_y_z), .d(y_z_mux_d)); \n wire signed [31:0] out_0_prod; \n lpm_mult #(.lpm_widtha(16), .lpm_widthb(16), .lpm_widthp(32),.lpm_representation(\"SIGNED\"),.lpm_pipeline(2)) out_x_mult \n (.clock(c), .clken(1'b1), .aclr(1'b0), .sum(1'b0),.dataa(input_z), .datab(mult_x_z), .result(out_0_prod)); \n r #(16) out_0_prod_r \n (.c(c), .en(pipe_cnt == 3'h2 || pipe_cnt == 3'h3),.rst(pipe_cnt == 3'h1), .d(out_0 + out_0_prod[30:15]), .q(out_0)); \n wire signed [31:0] out_1_prod; \n lpm_mult #(.lpm_widtha(16), .lpm_widthb(16), .lpm_widthp(32),.lpm_representation(\"SIGNED\"),.lpm_pipeline(2)) out_1_mult \n (.clock(c), .clken(1'b1), .aclr(1'b0), .sum(1'b0),.dataa(input_z), .datab(mult_y_z), .result(out_1_prod)); \n r #(16) out_1_prod_r \n (.c(c), .en(pipe_cnt == 3'h2 || pipe_cnt == 3'h3),.rst(pipe_cnt == 3'h1), .d(out_1 + out_1_prod[30:15]), .q(out_1)); \n assign out_dv = pipe_cnt == 3'h4; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a memory for writing data. It has input signals for the write data, write address, clock, enable, and reset, as well as an output signal for the memory contents. The memory is initialized with zeros on reset and can be written to when the write enable signal is asserted. Additionally, it remaps the memory contents to the output when the full signal or reset is asserted.\n\n Module header:\n\nmodule wr_memory ( wr_data, wr_clk, wr_en, wr_addr,remapping_memory,full,reset );\n [/INST]\n", "output": "parameter WR_DATA_WIDTH = 1; \n  parameter WR_ADDR_WIDTH = 3; \n  parameter MEM_DEPTH = 8; \n  input wire [WR_DATA_WIDTH - 1 : 0] wr_data; \n  input wire [WR_ADDR_WIDTH - 1 : 0] wr_addr; \n  input wire wr_clk, wr_en; \n  input wire full; \n  output reg [MEM_DEPTH - 1 : 0] remapping_memory; \n  input wire reset; \n  reg [WR_DATA_WIDTH - 1 : 0] memory [MEM_DEPTH - 1 : 0]; \n  integer i; \n  always @(posedge wr_clk or posedge reset) begin \n  if(reset) \n  for(i = 0; i < MEM_DEPTH; i = i + 1) \n  memory[i] <= 0; \n  else \n  if(wr_en) \n  memory[wr_addr] <= wr_data; \n  end \n  always @(posedge full or posedge reset) begin \n  if(reset) \n  remapping_memory <= 0; \n  else \n  for(i = 0; i < MEM_DEPTH; i = i + 1) \n  remapping_memory[i] <= memory[i]; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a data processing pipeline that takes input data, applies a set of coefficients and filters, performs multiplication and accumulation operations, and then outputs the processed data at a specified rate. It includes components for data storage, multiplication, accumulation, rounding, clipping, and output rate selection.\n\nThe input data is stored in a series of registers, and then processed using coefficients and filters. The processed data is then multiplied, accumulated, rounded, and clipped. The final output is selected based on a specified output rate or saved for later use.\n\nThe module also provides the ability to bypass the processing and output the input data directly. The selection of the output rate determines which processed data is outputted. The module also includes storage elements for holding the processed data and control signals for triggering specific actions at clock edges.\n\n Module header:\n\nmodule med_hb_int #(parameter WIDTH=18) (input clk,input rst,input bypass,input stb_in,input [WIDTH-1:0] data_in,input [7:0] output_rate,input stb_out,output reg [WIDTH-1:0] data_out);\n [/INST]\n", "output": "localparam coeff_a = -597; \n  localparam coeff_b = 4283; \n  localparam coeff_c = -17516; \n  localparam coeff_d = 79365; \n  reg phase; \n  reg [WIDTH-1:0] d1, d2, d3, d4, d5, d6, d7, d8; \n  localparam MWIDTH = 36; \n  wire [MWIDTH-1:0] prod; \n  reg [6:0] stbin_d; \n  always @(posedge clk) \n  stbin_d <= {stbin_d[5:0],stb_in}; \n  always @(posedge clk) \n  if(stb_in) \n  begin \n  d1 <= data_in; \n  d2 <= d1; \n  d3 <= d2; \n  d4 <= d3; \n  d5 <= d4; \n  d6 <= d5; \n  d7 <= d6; \n  d8 <= d7; \n  end \n  wire [WIDTH-1:0] sum_a, sum_b, sum_c, sum_d; \n  add2_and_round_reg #(.WIDTH(WIDTH)) add_a (.clk(clk),.in1(d1),.in2(d8),.sum(sum_a)); \n  add2_and_round_reg #(.WIDTH(WIDTH)) add_b (.clk(clk),.in1(d2),.in2(d7),.sum(sum_b)); \n  add2_and_round_reg #(.WIDTH(WIDTH)) add_c (.clk(clk),.in1(d3),.in2(d6),.sum(sum_c)); \n  add2_and_round_reg #(.WIDTH(WIDTH)) add_d (.clk(clk),.in1(d4),.in2(d5),.sum(sum_d)); \n MULT18X18S mult1(.C(clk), .CE(1), .R(rst), .P(prod1), .A(stbin_d[1] ? coeff_a : coeff_b),.B(stbin_d[1] ? sum_a : sum_b) ); \n MULT18X18S mult2(.C(clk), .CE(1), .R(rst), .P(prod2), .A(stbin_d[1] ? coeff_c : coeff_d),.B(stbin_d[1] ? sum_c : sum_d) ); \n  wire [MWIDTH:0] accum; \n  acc #(.IWIDTH(MWIDTH),.OWIDTH(MWIDTH+1)) \n  acc (.clk(clk),.clear(stbin_d[2]),.acc(|stbin_d[3:2]),.in(prod),.out(accum)); \n  wire [WIDTH+2:0] accum_rnd; \n  round_reg #(.bits_in(MWIDTH+1),.bits_out(WIDTH+3)) \n  final_round (.clk(clk),.in(accum),.out(accum_rnd)); \n  wire [WIDTH-1:0] clipped; \n  clip_reg #(.bits_in(WIDTH+3),.bits_out(WIDTH)) \n  final_clip (.clk(clk),.in(accum_rnd),.out(clipped)); \n  reg [WIDTH-1:0] saved, saved_d3; \n  always @(posedge clk) \n  if(stbin_d[6]) \n  saved <= clipped; \n  always @(posedge clk) \n  if(stbin_d[3]) \n  saved_d3 <= d3; \n  always @(posedge clk) \n  if(bypass) \n  data_out <= data_in; \n  else if(stb_in & stb_out) \n  case(output_rate) \n  1 : data_out <= d6; \n  2 : data_out <= d4; \n  3, 4, 5, 6, 7 : data_out <= d3; \n  default : data_out <= d2; \n  endcase \n  else if(stb_out) \n  data_out <= saved; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module sext12 extends a 12-bit input to a 16-bit output by sign-extending the most significant bit of the input to fill the additional bits.\n\n Module header:\n\nmodule sext12(in,out);\n [/INST]\n", "output": "input [11:0] in; \n output[15:0] out; \n assign out= {{4{in[11]}},in[11:0]}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a state machine with a register and two outputs. It transitions between two states based on the tex_push_en input and sets ram_wen_lo and ram_wen_hi based on the current state (cs) and ram_sel. When tex_push_en is high, it sets cs to 1 if it was 0, and to 0 if it was 1. ram_wen_lo and ram_wen_hi are set based on tex_push_en and the current state and ram_sel values.\n\n Module header:\n\nmodule de3d_tc_mc_we (input mclock,input rstn,input tex_push_en,input ram_sel,output reg ram_wen_lo,output reg ram_wen_hi);\n [/INST]\n", "output": "reg cs; \n always @(posedge mclock, negedge rstn) begin \n  if(!rstn) cs <= 1'b0; \n  else begin \n  case(cs) \n  1'b0: if(tex_push_en) cs <= 1'b1; \n  else cs = 1'b0; \n  1'b1: if(tex_push_en) cs <= 1'b0; \n  else cs = 1'b1; \n  endcase \n  end \n end \n always @* ram_wen_lo = tex_push_en & ((~cs & ~ram_sel) | ( cs & ram_sel)); \n always @* ram_wen_hi = tex_push_en & (( cs & ~ram_sel) | (~cs & ram_sel)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a cycle counter with input and output ports. It generates an output signal called \"ready\" based on the \"ready_downstream\" signal and the count reaching a specific value. It counts the cycles based on the input clock and the \"reset\" signal. The \"process_output\" is updated based on the logic and the cycle count. The module also utilizes registers for output count and cycle count. The module is designed to be parameterized and is capable of counting up to a specified count value.\n\n Module header:\n\nmodule CycleCounter_Auint8_4_1__2_1__count153600(input CLK, input ready_downstream, output ready, input reset, input [64:0] process_input, output [64:0] process_output);\n [/INST]\n", "output": "parameter INSTANCE_NAME=\"INST\"; \n parameter OUTPUT_COUNT=0; \n parameter INPUT_COUNT=0; \n  wire [31:0] outputCount_GET_OUTPUT; \n  wire unnamedbinop8630USEDMULTIPLEbinop;assign unnamedbinop8630USEDMULTIPLEbinop = {((outputCount_GET_OUTPUT)>=((32'd153600)))}; \n  wire unnamedunary8653USEDMULTIPLEunary;assign unnamedunary8653USEDMULTIPLEunary = {(~unnamedbinop8630USEDMULTIPLEbinop)}; \n  assign ready = {(ready_downstream&&unnamedunary8653USEDMULTIPLEunary)}; \n  wire unnamedbinop8631USEDMULTIPLEbinop;assign unnamedbinop8631USEDMULTIPLEbinop = {(ready_downstream||reset)}; \n  wire [31:0] cycleCount_GET_OUTPUT; \n  wire unnamedcast8624USEDMULTIPLEcast;assign unnamedcast8624USEDMULTIPLEcast = (process_input[64]); \n  wire unnamedunary8646USEDMULTIPLEunary;assign unnamedunary8646USEDMULTIPLEunary = {(~reset)}; \n  wire [31:0] outputCount_SETBY_OUTPUT; \n  wire [31:0] cycleCount_SETBY_OUTPUT; \n  assign process_output = {{({(unnamedbinop8630USEDMULTIPLEbinop||unnamedcast8624USEDMULTIPLEcast)}&&unnamedunary8646USEDMULTIPLEunary)},((unnamedbinop8630USEDMULTIPLEbinop)?({cycleCount_GET_OUTPUT,cycleCount_GET_OUTPUT}):((process_input[63:0])))}; \n  RegBy_incif_wrapuint32_153615_inc1_CEtrue_initnil #(.INSTANCE_NAME({INSTANCE_NAME,\"_outputCount\"})) outputCount(.CLK(CLK), .set_valid(reset), .CE(unnamedbinop8631USEDMULTIPLEbinop), .set_inp((32'd0)), .setby_valid(unnamedunary8646USEDMULTIPLEunary), .setby_inp({(ready_downstream&&{(unnamedcast8624USEDMULTIPLEcast||unnamedbinop8630USEDMULTIPLEbinop)})}), .SETBY_OUTPUT(outputCount_SETBY_OUTPUT), .GET_OUTPUT(outputCount_GET_OUTPUT)); \n  RegBy_incif_1uint32_CEnil_CEfalse_initnil #(.INSTANCE_NAME({INSTANCE_NAME,\"_cycleCount\"})) cycleCount(.CLK(CLK), .set_valid(reset), .set_inp((32'd0)), .setby_valid(unnamedunary8646USEDMULTIPLEunary), .setby_inp(unnamedunary8653USEDMULTIPLEunary), .SETBY_OUTPUT(cycleCount_SETBY_OUTPUT), .GET_OUTPUT(cycleCount_GET_OUTPUT)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a page selection and control logic. It has inputs for the clock signal, reset, address lines, data input, read/write signal, and chip select. It also has outputs for data output, page, rampage lock, sysboot lock, BRAM disable, and BROM disable.\n\nUpon reset, it initializes the page, rampage lock, sysboot lock, BRAM disable, and BROM disable signals to specific values.\n\nDuring normal operation, when the chip select signal is active, it performs different operations based on the read/write signal and the address lines. When writing to the device, it sets the BRAM/BROM disable, sysboot lock, and rampage lock signals based on the data input. When reading from the device, it outputs the page information or the BRAM/BROM disable, sysboot lock, and rampage lock signals based on the address lines and read/write signal.\n\n Module header:\n\nmodule pagesel (input wire clk,input wire rst,input wire AD,input wire [7:0] DI,output reg [7:0] DO,input wire rw,input wire cs,output reg [3:0] page,output reg rampage_lock,output reg sysboot_lock,output reg bram_disable,output reg brom_disable);\n [/INST]\n", "output": "always @ (posedge clk) begin \n  if (rst) begin \n  page <= 4'b0000; \n  rampage_lock <= 0; \n  sysboot_lock <= 0; \n  bram_disable <= 1; \n  brom_disable <= 0; \n  end else begin \n  if (cs) begin \n  if (rw) begin \n  if (AD) DO[3:0] <= {brom_disable, bram_disable, sysboot_lock, rampage_lock}; \n  else DO[3:0] <= page; \n  end else begin \n  if (AD) begin \n  rampage_lock <= DI[0]; \n  sysboot_lock <= DI[1]; \n  bram_disable <= DI[2]; \n  brom_disable <= DI[3]; \n  end else page <= DI[3:0]; \n  end \n  end \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module BitshiftTest instantiates a shift_reg module and drives the input signals rx, finished_rx, rst, and baud_clk. It initializes rx and rst, and toggles the value of rx and baud_clk according to specific time intervals. Once the specified time elapses, the simulation stops. The shift_reg module likely performs some kind of bit shifting operation on the input signal rx and outputs the result to shifted_bus.\n\n Module header:\n\nmodule BitshiftTest;\n [/INST]\n", "output": "reg rx; \n  reg rst; \n  reg baud_clk; \n  wire [149:0] shifted_bus; \n shift_reg uut (.rx(rx),.shifted_bus(shifted_bus),.finished_rx(finished_rx),.rst(rst),.baud_clk(baud_clk)); \n  initial begin \n  rx = 1'b1; \n  rst = 1; \n  baud_clk = 0; \n  #10 rst = 1'b0; \n  #1000 rx = 1'b0; \n  #12000 rx = 1'b1; \n  #2000 rx = 1'b0; \n  #2000 rx = 1'b1; \n  #2000 rx = 1'b0; \n  #10000 rx = 1'b1; \n  #4100 rx = 1'b0; \n  #10000 rx = 1'b1; \n  #2000 rx = 1'b0; \n  #10000 rx = 1'b1; \n  #2000 rx = 1'b0; \n  #10000 rx = 1'b1; \n  #2000 rx = 1'b0; \n  #10000 rx = 1'b1; \n  #2000 rx = 1'b0; \n  #10000 rx = 1'b1; \n  #2000 rx = 1'b0; \n  #10000 rx = 1'b1; \n  #2000 rx = 1'b0; \n  #10000 rx = 1'b1; \n  #2000 rx = 1'b0; \n  #10000 rx = 1'b1; \n  #2000 rx = 1'b0; \n  #10000 rx = 1'b1; \n  #2000 rx = 1'b0; \n  #2000 rx = 1'b1; \n  #2000 rx = 1'b0; \n  #2000 rx = 1'b1; \n  #2000 rx = 1'b0; \n  #10000 rx = 1'b1; \n  #6000 rx = 1'b0; \n  #2000 rx = 1'b1; \n  #10000 rx = 1'b0; \n  #6000 rx = 1'b1; \n  #70000; $stop; \n  end \n  always #1000 baud_clk=~baud_clk; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a status flag generator with various input and output ports. The outputs of the module are driven by specific inputs and attributes, and are connected to various internal logic elements and flip-flops. The module generates status flags based on the input signals and produces the appropriate output signals based on the given conditions and connections.\n\n Module header:\n\nmodule decalper_eb_ot_sdeen_pot_pi_dehcac_xnilix_wr_status_flags_ss (out,full,almost_full,E,ram_full_comb,clk,\\grstd1.grst_full.grst_f.rst_d2_reg ,p_2_out,wr_en);\n [/INST]\n", "output": "output out; \n  output full; \n  output almost_full; \n  output [0:0]E; \n  input ram_full_comb; \n  input clk; \n  input \\grstd1.grst_full.grst_f.rst_d2_reg ; \n  input p_2_out; \n  input wr_en; \n  wire [0:0]E; \n  wire clk; \n  wire \\grstd1.grst_full.grst_f.rst_d2_reg ; \n  (* DONT_TOUCH *) wire p_15_out; \n  wire p_2_out; \n  (* DONT_TOUCH *) wire ram_afull_i; \n  wire ram_full_comb; \n  (* DONT_TOUCH *) wire ram_full_fb_i; \n  (* DONT_TOUCH *) wire ram_full_i; \n  wire wr_en; \n  assign almost_full = ram_afull_i; \n  assign full = ram_full_i; \n  assign out = ram_full_fb_i; \n  (* DONT_TOUCH *) \n  (* KEEP = \"yes\" *) \n  (* equivalent_register_removal = \"no\" *) \n FDPE #(.INIT(1'b1)) \n  \\gaf.gaf0.ram_afull_i_reg \n (.C(clk),.CE(1'b1),.D(p_2_out),.PRE(\\grstd1.grst_full.grst_f.rst_d2_reg ),.Q(ram_afull_i)); \n LUT2 #(.INIT(4'h2)) \n  \\gcc0.gc1.gsym.count_d1[3]_i_1 \n (.I0(wr_en),.I1(ram_full_fb_i),.O(E)); \n LUT1 #(.INIT(2'h2)) \n  i_0 \n (.I0(1'b0),.O(p_15_out)); \n  (* DONT_TOUCH *) \n  (* KEEP = \"yes\" *) \n  (* equivalent_register_removal = \"no\" *) \n FDPE #(.INIT(1'b1)) \n  ram_full_fb_i_reg \n (.C(clk),.CE(1'b1),.D(ram_full_comb),.PRE(\\grstd1.grst_full.grst_f.rst_d2_reg ),.Q(ram_full_fb_i)); \n  (* DONT_TOUCH *) \n  (* KEEP = \"yes\" *) \n  (* equivalent_register_removal = \"no\" *) \n FDPE #(.INIT(1'b1)) \n  ram_full_i_reg \n (.C(clk),.CE(1'b1),.D(ram_full_comb),.PRE(\\grstd1.grst_full.grst_f.rst_d2_reg ),.Q(ram_full_i)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is designed to facilitate the integration of an HDMI interface into a larger design. It includes input and output ports for the HDMI signals, clock signals, and various control signals. The module also features assign statements that drive some of the signals with a constant value. The purpose of this module is to connect the HDMI interface with other components in the larger system.\n\n Module header:\n\nmodule hdmi_design(clk100, sw, hdmi_rx_scl, hdmi_rx_clk_n, hdmi_rx_clk_p, hdmi_rx_n, hdmi_rx_p, hdmi_tx_hpd, led, debug_pmod, hdmi_rx_cec, hdmi_rx_hpa, hdmi_rx_sda, hdmi_rx_txen, hdmi_tx_cec, hdmi_tx_clk_n, hdmi_tx_clk_p, hdmi_tx_rscl, hdmi_tx_rsda, hdmi_tx_p, hdmi_tx_n, rs232_tx);\n [/INST]\n", "output": "input clk100; \n  output [7:0] debug_pmod; \n  inout hdmi_rx_cec; \n  input hdmi_rx_clk_n; \n  input hdmi_rx_clk_p; \n  output hdmi_rx_hpa; \n  input [2:0] hdmi_rx_n; \n  input [2:0] hdmi_rx_p; \n  input hdmi_rx_scl; \n  inout hdmi_rx_sda; \n  output hdmi_rx_txen; \n  inout hdmi_tx_cec; \n  output hdmi_tx_clk_n; \n  output hdmi_tx_clk_p; \n  input hdmi_tx_hpd; \n  output [2:0] hdmi_tx_n; \n  output [2:0] hdmi_tx_p; \n  inout hdmi_tx_rscl; \n  inout hdmi_tx_rsda; \n  output [7:0] led; \n  output rs232_tx; \n  input [7:0] sw; \n  assign hdmi_rx_cec = 1'hz; \n  assign hdmi_rx_sda = 1'hz; \n  assign hdmi_tx_cec = 1'hz; \n  assign hdmi_tx_rscl = 1'hz; \n  assign hdmi_tx_rsda = 1'hz; \n  assign led = 8'hzz; \n  assign debug_pmod = 8'hzz; \n  assign hdmi_rx_hpa = 1'hz; \n  assign hdmi_rx_txen = 1'hz; \n  assign hdmi_tx_clk_n = 1'hz; \n  assign hdmi_tx_clk_p = 1'hz; \n  assign hdmi_tx_p = 3'hz; \n  assign hdmi_tx_n = 3'hz; \n  assign rs232_tx = 1'hz; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module is a control memory that generates a write enable signal and an enable signal based on the input signals. It also maintains a counter that increments based on the transaction size and other conditions. The write enable signal is set or reset based on the counter, the input valid signal, and the transaction size. The module updates the counter value based on the transaction size and also updates the enable signal. It also features a reset functionality for various registers and signals based on the reset input.\n\n Module header:\n\nmodule ctrl_transmemory(clk,rst,i_valid,i_transize,wen,enable,counter);\n [/INST]\n", "output": "input clk; \n input rst; \n input i_valid; \n input [1:0] i_transize; \n output reg wen; \n output enable; \n output reg [4:0] counter; \n wire enable_0; \n wire enable_1; \n reg wen_0; \n reg wen_1; \n reg i_valid_0; \n assign enable_0=i_valid; \n assign enable_1=wen||wen_0||wen_1; \n assign enable= enable_0||enable_1; \n always@(posedge clk or negedge rst) \n if(!rst) \n  wen_0<=1'b0; \n else \n  wen_0<=wen; \n always@(posedge clk or negedge rst) \n if(!rst) \n  wen_1<=1'b0; \n else \n  wen_1<=wen_0; \n always@(posedge clk or negedge rst) \n if(!rst) \n  i_valid_0<=1'b0; \n else \n  i_valid_0<=i_valid; \n always@(posedge clk or negedge rst) \n if(!rst) \n  counter<=0; \n else if((!wen_0)&&wen_1) \n  counter<=5'd0; \n else if(enable) \n  case(i_transize) \n  2'b00: \n  counter<=5'd0; \n  2'b01: \n  if(counter==5'd1) \n  counter<=5'd0; \n  else \n  counter<=counter+1; \n  2'b10: \n  if(counter==5'd7) \n  counter<=5'd0; \n  else \n  counter<=counter+1; \n  2'b11: \n  if(counter==5'd31) \n  counter<=5'd0; \n  else \n  counter<=counter+1; \n  endcase \n always@(posedge clk or negedge rst) \n if(!rst) \n  wen<=0; \n  else \n  case(i_transize) \n  2'b00: \n  wen<=1'b0; \n  2'b01: \n  if((counter==5'd1)&&i_valid) \n  wen<=1; \n  else \n  if((counter==5'd1)&&(!i_valid)) \n  wen<=1'b0; \n  2'b10: \n  if((counter==5'd7)&&i_valid) \n  wen<=1; \n  else \n  if((counter==5'd7)&&(!i_valid)) \n  wen<=1'b0; \n  2'b11: \n  if((counter==5'd31)&&i_valid) \n  wen<=1; \n  else \n  if((counter==5'd31)&&(!i_valid)) \n  wen<=1'b0; \n  endcase \n  endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module represents a sequential element, specifically a D flip-flop with asynchronous reset and preset functionality. It takes in clock signal (CLK_N) and data input (D) and has an asynchronous reset input (RESET_B). The module uses an internal clock signal (intclk) and a notifier to manage the reset and preset functions. The data input (D) is passed through a multiplexer with the SCD and SCE inputs to determine the input to the D flip-flop. The output (Q) is buffered by a simple buffer (buf0).\n\nAdditionally, the module includes various signal delays and conditional expressions to handle the reset and preset functionality. The \"awake\" signal indicates a valid power supply, and various conditional signals (cond0, cond1, cond2, cond3, cond4) are used to control the behavior of the module based on the input signals.\n\nOverall, this module implements a D flip-flop with asynchronous reset and preset functionality, along with power and conditional control features.\n\n Module header:\n\nmodule sky130_fd_sc_lp__sdfrtn (Q ,CLK_N ,D ,SCD ,SCE ,RESET_B);\n [/INST]\n", "output": "output Q ; \n  input CLK_N ; \n  input D ; \n  input SCD ; \n  input SCE ; \n  input RESET_B; \n  supply1 VPWR; \n  supply0 VGND; \n  supply1 VPB ; \n  supply0 VNB ; \n  wire buf_Q ; \n  wire RESET ; \n  wire intclk ; \n  wire mux_out ; \n  reg notifier ; \n  wire D_delayed ; \n  wire SCD_delayed ; \n  wire SCE_delayed ; \n  wire RESET_B_delayed; \n  wire CLK_N_delayed ; \n  wire awake ; \n  wire cond0 ; \n  wire cond1 ; \n  wire cond2 ; \n  wire cond3 ; \n  wire cond4 ; \n  not not0 (RESET , RESET_B_delayed ); \n  not not1 (intclk , CLK_N_delayed ); \n  sky130_fd_sc_lp__udp_mux_2to1 mux_2to10 (mux_out, D_delayed, SCD_delayed, SCE_delayed ); \n  sky130_fd_sc_lp__udp_dff$PR_pp$PG$N dff0 (buf_Q , mux_out, intclk, RESET, notifier, VPWR, VGND); \n  assign awake = ( VPWR === 1'b1 ); \n  assign cond0 = ( awake && ( RESET_B_delayed === 1'b1 ) ); \n  assign cond1 = ( ( SCE_delayed === 1'b0 ) && cond0 ); \n  assign cond2 = ( ( SCE_delayed === 1'b1 ) && cond0 ); \n  assign cond3 = ( ( D_delayed !== SCD_delayed ) && cond0 ); \n  assign cond4 = ( awake && ( RESET_B === 1'b1 ) ); \n  buf buf0 (Q , buf_Q ); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a D flip-flop with asynchronous reset and set. It has inputs VPWR, VGND, CLK, and D, and outputs Q and Q_N. The data input D is delayed and then fed into a D flip-flop with no pull-down. The output Q is connected to a buffer, while the inverse output Q_N is connected to an inverter. The module also includes an awake signal based on the VPWR input.\n\n Module header:\n\nmodule sky130_fd_sc_hs__dfxbp (VPWR,VGND,Q ,Q_N ,CLK ,D);\n [/INST]\n", "output": "input VPWR; \n  input VGND; \n  output Q ; \n  output Q_N ; \n  input CLK ; \n  input D ; \n  wire buf_Q ; \n  reg notifier ; \n  wire D_delayed ; \n  wire CLK_delayed; \n  wire awake ; \n  sky130_fd_sc_hs__u_df_p_no_pg u_df_p_no_pg0 (buf_Q , D_delayed, CLK_delayed, notifier, VPWR, VGND); \n  assign awake = ( VPWR === 1'b1 ); \n  buf buf0 (Q , buf_Q ); \n  not not0 (Q_N , buf_Q ); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a peripheral UART (Universal Asynchronous Receiver/Transmitter) interface. It contains inputs for clock, reset, data, chip select, address, read, and write signals, as well as outputs for data out, UART transmit, and LED output.\n\nThe module includes a state machine using a 3-bit register 's'. It decodes the address and control signals to determine the state of the UART interface. When the chip select and read/write signals are asserted, it transitions to the appropriate state.\n\nThe module also has internal logic to handle UART input data, such as extracting the least significant byte of the input data and determining the LED output based on the state. The UART output data is driven based on the state, setting the least significant bit to the UART busy signal.\n\nAdditionally, the module instantiates a separate UART module, passing the UART busy signal, UART transmit signal, UART write enable, input data for UART, clock, and reset signals.\n\nOverall, this Verilog module provides an interface for a UART peripheral, controlling the data flow and state transitions according to the input signals and address decoding.\n\n Module header:\n\nmodule peripheral_uart(clk , rst , d_in , cs , addr , rd , wr, d_out, uart_tx, ledout );\n [/INST]\n", "output": "input clk; \n  input rst; \n  input [15:0]d_in; \n  input cs; \n  input [3:0]addr; \n  input rd; \n  input wr; \n  output reg [15:0]d_out; \n  output uart_tx; \n  output reg ledout=0; \n reg [2:0] s; \n reg [7:0] d_in_uart; \n wire uart_busy; \n always @(*) begin \n case (addr) \n 4'h0:begin s = (cs && rd) ? 3'b001 : 3'b000 ;end \n 4'h2:begin s = (cs && wr) ? 3'b010 : 3'b000 ;end \n 4'h4:begin s = (cs && wr) ? 3'b100 : 3'b000 ;end \n default:begin s=3'b000 ; end \n endcase \n end \n always @(negedge clk) begin \n d_in_uart= (s[1]) ? d_in[7:0] : d_in_uart; \n ledout = (s[2]) ? d_in[0] : ledout; \n end \n always @(negedge clk) begin \n case (s) \n 3'b001: d_out[0]= uart_busy; \n default: d_out=0; \n endcase \n end \n uart uart(.uart_busy(uart_busy), .uart_tx(uart_tx), .uart_wr_i(cs && wr && (addr != 4'h4) ), .uart_dat_i(d_in_uart), .sys_clk_i(clk), .sys_rst_i(rst)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes a 4-bit input and converts it to the corresponding 7-segment display code. It uses a case statement to assign the output Salida7seg based on the input Ver. Each input pattern corresponds to a specific 7-segment display code. If the input does not match any of the defined patterns, it defaults to a specific display code. The output Salida7seg is updated based on the input Ver.\n\n Module header:\n\nmodule Convierte(input [3:0]Ver,output reg [6:0]Salida7seg);\n [/INST]\n", "output": "always @(Ver)begin \n  case(Ver) \n  7'b0000000: Salida7seg=7'b000_0001; \n  7'b0000001: Salida7seg=7'b100_1111; \n  7'b0000010: Salida7seg=7'b001_0010; \n  7'b0000011: Salida7seg=7'b000_0110; \n  7'b0000100: Salida7seg=7'b100_1100; \n  7'b0000101: Salida7seg=7'b010_0100; \n  7'b0000110: Salida7seg=7'b010_0000; \n  7'b0000111: Salida7seg=7'b000_1111; \n  7'b0001000: Salida7seg=7'b000_0000; \n  7'b0001001: Salida7seg=7'b000_0100; \n  7'b0001010: Salida7seg=7'b000_1000; \n  7'b0001011: Salida7seg=7'b110_0000; \n  7'b0001100: Salida7seg=7'b011_0001; \n  7'b0001101: Salida7seg=7'b100_0010; \n  7'b0001110: Salida7seg=7'b011_0000; \n  7'b0001111: Salida7seg=7'b011_1000; \n  default : Salida7seg=7'b000_0001; \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module extends the input signal to a wider output signal by padding the input with its most significant bit to match the desired output width.\n\n Module header:\n\nmodule signal_extend #(parameter OUT_DATA_WIDTH = 32,parameter IN_DATA_WIDTH = 16)(input [IN_DATA_WIDTH-1:0] signal_in,output [OUT_DATA_WIDTH-1:0] signal_out);\n [/INST]\n", "output": "assign signal_out = {{(OUT_DATA_WIDTH-IN_DATA_WIDTH){signal_in[IN_DATA_WIDTH-1]}},signal_in}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a pixel copy functionality. It uses the input clock (clk) and read clock (rdclk) to control the timing of operations. The module takes in pixel data (data) and a control signal (acapture), and outputs write control (write), modified data (wrdata), and horizontal count (horiz_count). The logic within the always block manages the loading and manipulation of pixel data, as well as the control signals, based on the input clock signals and data availability.\n\n Module header:\n\nmodule pixcopy (input clk,input rdclk,input [7:0] data,input acapture,output reg write,output reg [15:0] wrdata,output reg [9:0] horiz_count);\n [/INST]\n", "output": "reg uphalf; \n reg [7:0] upbyte; \n reg loaded; \n always @(posedge clk) \n begin \n  if (write) begin \n  write <= 1'b0; \n  end \n  if (!acapture) begin \n  uphalf <= 1'b1; \n  loaded <= 1'b0; \n  write <= 1'b0; \n  horiz_count<= 0; \n  end else begin \n  if (rdclk) begin \n  if (!loaded) begin \n  if (uphalf) begin \n  upbyte <= data; \n  uphalf <= 1'b0; \n  loaded <= 1'b1; \n  end else begin \n  horiz_count <= horiz_count + 1'b1; \n  wrdata <= {upbyte, data}; \n  uphalf <= 1'b1; \n  write <= 1'b1; \n  loaded <= 1'b1; \n  end \n  end \n  end else begin \n  loaded <= 1'b0; \n  end \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a delay circuit with a delay of 5 clock cycles. The input 'in' triggers the delay, and the output 'p' becomes high when the delay count reaches 75. The output 'l' reflects the state of the delay circuit. The circuit is reset when the 'reset' signal is asserted.\n\n Module header:\n\nmodule ldly1_5us(input clk, input reset, input in, output p, output reg l);\n [/INST]\n", "output": "reg [7-1:0] r; \n  always @(posedge clk or posedge reset) begin \n  if(reset) begin \n  r <= 0; \n  l <= 0; \n  end else begin \n  if(r) \n  r <= r + 7'b1; \n  if(in) begin \n  r <= 1; \n  l <= 1; \n  end \n  if(p) begin \n  r <= 0; \n  l <= 0; \n  end \n  end \n  end \n  assign p = r == 75; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a delay circuit that takes an input signal and produces an output signal after a specific delay. The delay is controlled by a 17-bit register that increments by 1 on each clock cycle. When the input signal is high, the register is immediately set to 1. The output signal is asserted when the register value reaches 105,000. The delay introduced by the circuit is 1 millisecond based on the clock frequency.\n\n Module header:\n\nmodule dly2_1ms(input clk, input reset, input in, output p);\n [/INST]\n", "output": "reg [17-1:0] r; \n  always @(posedge clk or posedge reset) begin \n  if(reset) \n  r <= 0; \n  else begin \n  if(r) \n  r <= r + 17'b1; \n  if(in) \n  r <= 1; \n  end \n  end \n  assign p = r == 105000; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"gen_sync\" is designed to generate a synchronized signal based on the input clock, reset, enable, and rate. It uses an 8-bit counter to generate the synchronized signal. The counter is updated on the rising edge of the clock. When the module is reset or the enable signal is inactive, the counter is set to 0. Otherwise, the counter is incremented by 1 until it reaches the specified rate, at which point it is reset to 0. The synchronized output signal is generated by performing a bitwise OR operation between the right-shifted rate and the counter.\n\n Module header:\n\nmodule gen_sync ( input clock,input reset,input enable,input [7:0] rate,output wire sync );\n [/INST]\n", "output": "reg [7:0] counter; \n  assign sync = |(((rate+1)>>1)& counter); \n  always @(posedge clock) \n  if(reset || ~enable) \n  counter <= #1 0; \n  else if(counter == rate) \n  counter <= #1 0; \n  else \n  counter <= #1 counter + 8'd1; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `ps2clock` implements a clock generator that generates a new clock signal `o_clock` based on the input clock `i_clock` and a specific timing pattern. The module uses a delay timer `delay_timer` and a control signal `run_delay_timer` to manage the generation of the new clock signal. When `i_clock` is negative, `run_delay_timer` is set, and the `delay_timer` is incremented. When the `delay_timer` reaches 1000, the new clock `o_clock` is set to 0, and when the `delay_timer` is 0, the new clock is set to 1.\n\n Module header:\n\nmodule ps2clock (input clk,input i_clock,output o_clock);\n [/INST]\n", "output": "reg [10:0] delay_timer = 0; \n  reg run_delay_timer = 0; \n  reg r_clk = 0; \n  assign o_clock = r_clk; \n  always @(i_clock) begin \n  if (!i_clock) begin \n  run_delay_timer <= 1; \n  end else begin \n  run_delay_timer <= 0; \n  end \n  end \n  always @(posedge clk) begin \n  if (run_delay_timer) begin \n  delay_timer <= delay_timer + 11'b1; \n  end else begin \n  delay_timer <= 0; \n  end \n  end \n  always @(posedge clk) begin \n  if (delay_timer == 11'd1000) begin \n  r_clk <= 0; \n  end else if (delay_timer == 11'd0) begin \n  r_clk <= 1; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `udi_udi_inst_pow` implements a digital signal processing (DSP) component. It has inputs for clock, scan enable, data from input registers, control signals, and threshold. It also has output registers and a comparison result. The module performs multiplication, addition, and comparison operations based on the control signals and outputs the result. The module utilizes various submodules for specific functions such as multiplication, threshold registration, and output registration.\n\n Module header:\n\nmodule udi_udi_inst_pow (input gclk ,input gscanenable ,input [31:0] in_rs ,input [15:0] in_rt ,output [31:0] out_rd ,input udi_ctl_thr_wr ,input [1:0] udi_ctl_sum_mode ,input udi_ctl_res_sel);\n [/INST]\n", "output": "wire [31:0] mult_i_out ; \n  wire [31:0] mult_q_out ; \n  wire [31:0] mult_i_out_d ; \n  wire [31:0] mult_q_out_d ; \n  wire [31:0] threshold ; \n  wire [32:0] sum ; \n  wire [31:0] sum_out ; \n  wire [31:0] sum_out_d ; \n  wire comp_res ; \n  localparam CTL_SUM_MODE_NONE = 2'b00 ; \n  localparam CTL_SUM_MODE_SUM = 2'b01 ; \n  localparam CTL_SUM_MODE_SUMSHIFT = 2'b10 ; \n  localparam CTL_SUM_MODE_BYPASS = 2'b11 ; \n  assign sum = mult_i_out_d + mult_q_out_d ; \n  assign comp_res = (sum_out_d > threshold) ? 1'b1 : 1'b0 ; \n  assign out_rd = (udi_ctl_res_sel) ? {30'd0,comp_res} : sum_out_d ; \n  assign sum_out = (udi_ctl_sum_mode == CTL_SUM_MODE_SUM) ? sum[31:0] : \n  (udi_ctl_sum_mode == CTL_SUM_MODE_SUMSHIFT) ? sum[32:1] : \n  (udi_ctl_sum_mode == CTL_SUM_MODE_BYPASS) ? mult_i_out : 32'd0 ; \n  mvp_cregister_wide #(32) _udi_thr_31_0_(threshold, gscanenable, udi_ctl_thr_wr, gclk, in_rs); \n  mvp_register #(32) _udi_mul_1_31_0_(mult_i_out_d, gclk, mult_i_out); \n  mvp_register #(32) _udi_mul_2_31_0_(mult_q_out_d, gclk, mult_q_out); \n  mvp_register #(32) _udi_sum_out_31_0_(sum_out_d, gclk, sum_out); \n mult_16_x_16_res_32 mult_16_x_16_res_32_u1(.clk ( gclk ),.a ( in_rs[31:16] ),.b ( in_rs[31:16] ),.p ( mult_i_out )); \n mult_16_x_16_res_32 mult_16_x_16_res_32_u2(.clk ( gclk ),.a ( in_rt ),.b ( in_rt ),.p ( mult_q_out )); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a constant generator that produces an 8-bit output signal \"op\" with a constant value of 11111111. The output signal remains constant regardless of the input signals \"clk,\" \"ce,\" and \"clr.\"\n\n Module header:\n\nmodule sysgen_constant_39c35f37c7 (output [(8 - 1):0] op,input clk,input ce,input clr);\n [/INST]\n", "output": "assign op = 8'b11111111; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a binary-coded decimal (BCD) counter. It has inputs for the clock signal, asynchronous reset, and enable, and outputs for three BCD digits (dig1, dig2, and dig3). It uses carry logic to increment the digits from dig1 to dig3 based on the clock signal, reset, and enable conditions. The dig1, dig2, and dig3 digits increment based on the carry logic and the enable signal.\n\n Module header:\n\nmodule bcd_ctr(clk, en, ar, dig1, dig2, dig3);\n [/INST]\n", "output": "input clk, ar, en; \n  output reg [3:0] dig1, dig2, dig3; \n  wire dig1_carry, dig2_carry, dig3_carry; \n  assign dig1_carry = (dig1 == 4'd9); \n  assign dig2_carry = dig1_carry&(dig2 == 4'd9); \n  assign dig3_carry = dig2_carry&(dig3 == 4'd9); \n  always @ (posedge clk or negedge ar) \n  begin \n  if(~ar) \n  begin \n  dig1 <= 4'd0; \n  dig2 <= 4'd0; \n  dig3 <= 4'd0; \n  end else if(~dig3_carry&en) \n  begin \n  if(dig2_carry) \n  begin \n  dig3 <= dig3 + 1; \n  dig2 <= 0; \n  dig1 <= 0; \n  end else if(dig1_carry) \n  begin \n  dig2 <= dig2 + 1; \n  dig1 <= 0; \n  end else \n  begin \n  dig1 <= dig1 + 1; \n  end \n  end \n  end \n  endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module implements a synchronizer for two clock domains, clk1 and clk2, along with their respective reset signals. It uses flip-flops to synchronize the set and clear signals between the two clock domains. The synchronization output, sync_out, is set based on the synchronized set signal from clk1 and its reset signal. This ensures that the sync_out signal is synchronized to clk2. The module also includes a wire assignment for z, which is used to calculate the synchronization logic. The synchronization of the set and clear signals is handled using multiple always blocks, with appropriate edge-triggering for the clocks and reset signals.\n\n Module header:\n\nmodule dbg_sync_clk1_clk2 (clk1, clk2, reset1, reset2, set2, sync_out);\n [/INST]\n", "output": "parameter Tp = 1; \n input clk1; \n input clk2; \n input reset1; \n input reset2; \n input set2; \n output sync_out; \n reg set2_q; \n reg set2_q2; \n reg set1_q; \n reg set1_q2; \n reg clear2_q; \n reg clear2_q2; \n reg sync_out; \n wire z; \n assign z = set2 | set2_q & ~clear2_q2; \n always @ (posedge clk2 or posedge reset2) \n begin \n  if(reset2) \n  set2_q <=#Tp 1'b0; \n  else \n  set2_q <=#Tp z; \n end \n always @ (posedge clk2 or posedge reset2) \n begin \n  if(reset2) \n  set2_q2 <=#Tp 1'b0; \n  else \n  set2_q2 <=#Tp set2_q; \n end \n always @ (posedge clk1 or posedge reset1) \n begin \n  if(reset1) \n  set1_q <=#Tp 1'b0; \n  else \n  set1_q <=#Tp set2_q2; \n end \n always @ (posedge clk1 or posedge reset1) \n begin \n  if(reset1) \n  set1_q2 <=#Tp 1'b0; \n  else \n  set1_q2 <=#Tp set1_q; \n end \n always @ (posedge clk2 or posedge reset2) \n begin \n  if(reset2) \n  clear2_q <=#Tp 1'b0; \n  else \n  clear2_q <=#Tp set1_q2; \n end \n always @ (posedge clk2 or posedge reset2) \n begin \n  if(reset2) \n  clear2_q2 <=#Tp 1'b0; \n  else \n  clear2_q2 <=#Tp clear2_q; \n end \n always @ (posedge clk1 or posedge reset1) \n begin \n  if(reset1) \n  sync_out <=#Tp 1'b0; \n  else \n  sync_out <=#Tp set1_q2; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module `BufferCC_1_` is a simple register-based buffer that stores the input `io_dataIn` and outputs it as `io_dataOut` on the rising edge of the clock signal `io_mainClk`. The `resetCtrl_mainClkReset` input is used to asynchronously reset the internal registers.\n\n Module header:\n\nmodule BufferCC_1_ (input io_dataIn,output io_dataOut,input io_mainClk,input resetCtrl_mainClkReset);\n [/INST]\n", "output": "reg buffers_0; \n  reg buffers_1; \n  assign io_dataOut = buffers_1; \n  always @ (posedge io_mainClk) begin \n  buffers_0 <= io_dataIn; \n  buffers_1 <= buffers_0; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a finite state machine to convert a 64-bit double-precision floating-point number to a 32-bit single-precision floating-point number. It utilizes a state machine with different states for handling various tasks like unpacking, denormalizing, and forming the output. The module also keeps track of signal acknowledgements and handles the reset signal. The input_a_ack and output_z_stb signals are updated based on the state machine, and the output_z signal holds the final 32-bit floating-point number.\n\n Module header:\n\nmodule double_to_float(input_a,input_a_stb,output_z_ack,clk,rst,output_z,output_z_stb,input_a_ack);\n [/INST]\n", "output": "input clk; \n  input rst; \n  input [63:0] input_a; \n  input input_a_stb; \n  output input_a_ack; \n  output [31:0] output_z; \n  output output_z_stb; \n  input output_z_ack; \n  reg s_output_z_stb; \n  reg [31:0] s_output_z; \n  reg s_input_a_ack; \n  reg [1:0] state; \n  parameter get_a = 3'd0, \n  unpack = 3'd1, \n  denormalise = 3'd2, \n  put_z = 3'd3; \n  reg [63:0] a; \n  reg [31:0] z; \n  reg [10:0] z_e; \n  reg [23:0] z_m; \n  reg guard; \n  reg round; \n  reg sticky; \n  always @(posedge clk) \n  begin \n  case(state) \n  get_a: \n  begin \n  s_input_a_ack <= 1; \n  if (s_input_a_ack && input_a_stb) begin \n  a <= input_a; \n  s_input_a_ack <= 0; \n  state <= unpack; \n  end \n  end \n  unpack: \n  begin \n  z[31] <= a[63]; \n  state <= put_z; \n  if (a[62:52] == 0) begin \n  z[30:23] <= 0; \n  z[22:0] <= 0; \n  end else if (a[62:52] < 897) begin \n  z[30:23] <= 0; \n  z_m <= {1'd1, a[51:29]}; \n  z_e <= a[62:52]; \n  guard <= a[28]; \n  round <= a[27]; \n  sticky <= a[26:0] != 0; \n  state <= denormalise; \n  end else if (a[62:52] == 2047) begin \n  z[30:23] <= 255; \n  z[22:0] <= 0; \n  if (a[51:0]) begin \n  z[22] <= 1; \n  end \n  end else if (a[62:52] > 1150) begin \n  z[30:23] <= 255; \n  z[22:0] <= 0; \n  end else begin \n  z[30:23] <= (a[62:52] - 1023) + 127; \n  if (a[28] && (a[27] || a[26:0])) begin \n  z[22:0] <= a[51:29] + 1; \n  end else begin \n  z[22:0] <= a[51:29]; \n  end \n  end \n  end \n  denormalise: \n  begin \n  if (z_e == 897 || (z_m == 0 && guard == 0)) begin \n  state <= put_z; \n  z[22:0] <= z_m; \n  if (guard && (round || sticky)) begin \n  z[22:0] <= z_m + 1; \n  end \n  end else begin \n  z_e <= z_e + 1; \n  z_m <= {1'd0, z_m[23:1]}; \n  guard <= z_m[0]; \n  round <= guard; \n  sticky <= sticky | round; \n  end \n  end \n  put_z: \n  begin \n  s_output_z_stb <= 1; \n  s_output_z <= z; \n  if (s_output_z_stb && output_z_ack) begin \n  s_output_z_stb <= 0; \n  state <= get_a; \n  end \n  end \n  endcase \n  if (rst == 1) begin \n  state <= get_a; \n  s_input_a_ack <= 0; \n  s_output_z_stb <= 0; \n  end \n  end \n  assign input_a_ack = s_input_a_ack; \n  assign output_z_stb = s_output_z_stb; \n  assign output_z = s_output_z; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"decoder4to16\" is a 4-to-16 decoder, which has 4 input bits and 16 output bits. The module computes the complement of the input bits and then calculates the output values based on the input and its complement using logical AND operations. Each output bit is computed based on a specific combination of the input and its complement. The module uses combinational logic to perform these computations and assigns the computed values to the output bits.\n\n Module header:\n\nmodule decoder4to16 (in,out);\n [/INST]\n", "output": "output reg [15:1] out; \n  input [3:0] in; \n  reg [3:0] in_bar; \n  always @(*) \n  begin \n  in_bar=~in; \n  out[1]=in[0] & in_bar[1] & in_bar[2] & in_bar[3]; \n  out[2]=in_bar[0] & in[1] & in_bar[2] & in_bar[3]; \n  out[3]=in[0] & in[1] & in_bar[2] & in_bar[3]; \n  out[4]=in_bar[0] & in_bar[1] & in[2] & in_bar[3]; \n  out[5]=in[0] & in_bar[1] & in[2] & in_bar[3]; \n  out[6]=in_bar[0] & in[1] & in[2] & in_bar[3]; \n  out[7]=in[0] & in[1] & in[2] & in_bar[3]; \n  out[8]=in_bar[0] & in_bar[1] & in_bar[2] & in[3]; \n  out[9]=in[0] & in_bar[1] & in_bar[2] & in[3]; \n  out[10]=in_bar[0] & in[1] & in_bar[2] & in[3]; \n  out[11]=in[0] & in[1] & in_bar[2] & in[3]; \n  out[12]=in_bar[0] & in_bar[1] & in[2] & in[3]; \n  out[13]=in[0] & in_bar[1] & in[2] & in[3]; \n  out[14]=in_bar[0] & in[1] & in[2] & in[3]; \n  out[15]=in[0] & in[1] & in[2] & in[3]; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes a 32-bit input and assigns the output by concatenating the 30 least significant bits of the input with two zero bits.\n\n Module header:\n\nmodule sl2(input [31:0] a,output [31:0] y);\n [/INST]\n", "output": "assign y = {a[29:0], 2'b00}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module MX4 takes four data inputs (D0, D1, D2, D3) and two select inputs (S0, S1) and outputs Y based on the following logic: if S1 is true, Y is D3 if S0 is true, otherwise it is D2. If S1 is false, Y is D1 if S0 is true, otherwise it is D0.\n\n Module header:\n\nmodule MX4 (input D0, D1, D2, D3, S0, S1,output Y);\n [/INST]\n", "output": "assign Y = S1 ? (S0 ? D3 : D2) : (S0 ? D1 : D0); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a D flip-flop, which stores the value of the input dataIn on the rising edge of the clock signal and outputs it as dataOut. This is achieved through a clocked always block that updates dataOut on the rising edge of the clk signal.\n\n Module header:\n\nmodule DflipFlop(dataIn, clk, dataOut);\n [/INST]\n", "output": "input [31:0] dataIn; \n  input clk; \n  output [31:0] dataOut; \n  reg [31:0] dataOut; \n  always @(posedge clk) begin \n  dataOut = dataIn; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"testbench_RKOA\" is a testbench for a module called \"RecursiveKOA\". It instantiates \"RecursiveKOA\" and provides stimulus to its inputs by generating clock signals, random data for \"Data_A_i\" and \"Data_B_i\", and asserting \"load_b_i\" and \"rst\" signals. It monitors the output \"sgf_result_o\" by comparing it with the expected result of \"Data_B_i\" * \"Data_A_i\" when \"load_b_i\" is high and \"rst\" is low. The testbench also includes a simulation start message and error handling for unexpected output values.\n\n Module header:\n\nmodule testbench_RKOA();\n [/INST]\n", "output": "parameter PERIOD = 10; \n  parameter SW=26; \n  reg clk; \n  reg rst; \n  reg load_b_i; \n  reg [SW-1:0] Data_A_i; \n  reg [SW-1:0] Data_B_i; \n  wire [2*SW-1:0] sgf_result_o; \n RecursiveKOA #(.SW(SW), .Opt_FPGA_ASIC(1)) uut (.clk(clk),.rst(rst),.load_b_i(load_b_i),.Data_A_i(Data_A_i[SW-1:0]),.Data_B_i(Data_B_i[SW-1:0]),.sgf_result_o(sgf_result_o[2*SW-1:0])); \n  parameter cycles = 2**SW; \n  always begin \n  load_b_i = 1'b0; \n  #(3*PERIOD) load_b_i = 1'b1; \n  #(9*PERIOD/2); \n  end \n  always begin \n  rst = 1'b0; \n  #(50*PERIOD) rst = 1'b1; \n  #(50*PERIOD/2); \n  end \n  initial begin \n  clk = 1'b0; \n  #(PERIOD/2); \n  forever \n  #(PERIOD/2) clk = ~clk; \n  end \n  always begin \n  Data_A_i[SW-1:0] = $random; \n  #77; \n  end \n  always begin \n  Data_B_i[SW-1:0] = $random; \n  #105; \n  end \n  always begin \n  load_b_i = 1'b0; \n  #(3*PERIOD) load_b_i = 1'b1; \n  #(9*PERIOD/2); \n  end \n  always begin \n  rst = 1'b0; \n  #(50*PERIOD) rst = 1'b1; \n  #(50*PERIOD/2); \n  end \n  always @ (sgf_result_o ) \n  if ((sgf_result_o == Data_B_i * Data_A_i)&load_b_i&(~rst)) begin \n  $monitor($time,\"-> %h * %h = %h\",Data_A_i,Data_B_i,sgf_result_o); \n  end else begin \n  $display($time,\"-> ERROR: Data A = %h, Data B = %h, Result = %h\", Data_A_i,Data_B_i,sgf_result_o); \n  end \n  initial \n  begin \n  rst = 1; \n  #90; \n  rst = 0; \n  $display($time, \"<< Starting the Simulation>>\"); \n  load_b_i = 1; \n  Data_A_i = 1; \n  Data_B_i = 1; \n  #100 rst = 0; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module `acl_fp_log_altpriority_encoder_tv8` takes a 32-bit input `data` and outputs a 5-bit vector `q`. Inside the module, it instantiates two priority encoders, `altpriority_encoder8` and `altpriority_encoder9`, to process the lower and upper halves of the input data respectively. It then combines the outputs of these two encoders using bitwise operations to generate the final output `q`.\n\n Module header:\n\nmodule acl_fp_log_altpriority_encoder_tv8 (data,q) ;\n [/INST]\n", "output": "input [31:0] data; \n  output [4:0] q; \n  wire [3:0] wire_altpriority_encoder8_q; \n  wire [3:0] wire_altpriority_encoder9_q; \n  wire wire_altpriority_encoder9_zero; \n  acl_fp_log_altpriority_encoder_r08 altpriority_encoder8 \n (.data(data[15:0]),.q(wire_altpriority_encoder8_q)); \n  acl_fp_log_altpriority_encoder_rf8 altpriority_encoder9 \n (.data(data[31:16]),.q(wire_altpriority_encoder9_q),.zero(wire_altpriority_encoder9_zero)); \n  assign \n  q = {(~ wire_altpriority_encoder9_zero), (({4{wire_altpriority_encoder9_zero}} & wire_altpriority_encoder8_q) | ({4{(~ wire_altpriority_encoder9_zero)}} & wire_altpriority_encoder9_q))}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module defines a parameterized module with an input and an output. It declares and assigns several wires, including a 24-bit wire and a couple of single-bit wires. The output v4642b6 is assigned the value of w0, and w5 is assigned the value of the input v6dda25. It also instantiates two other modules, vef98b5 and vd84ae0, and connects their input and output wires. The parameter va04f5d is defined and utilized in the module.\n\n Module header:\n\nmodule vbce541 #(parameter va04f5d = 16777216) (input v6dda25,output v4642b6);\n [/INST]\n", "output": "localparam p1 = va04f5d; \n  wire w0; \n  wire [0:23] w2; \n  wire [0:23] w3; \n  wire w4; \n  wire w5; \n  assign v4642b6 = w0; \n  assign w5 = v6dda25; \n  assign w4 = w0; \n vef98b5 #(.vc5c8ea(p1)) v4016e8 (.ve70c2d(w3)); \n vd84ae0 v45b714 (.v4642b6(w0),.va89056(w2),.v06bdfb(w3)); \n v97d607 v2299cf (.v9e1c43(w2),.ve556f1(w4),.v6dda25(w5)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a half adder that performs multiplication. The inputs a and b are XORed to produce the sum output and are also ANDed to produce the carry output.\n\n Module header:\n\nmodule mul_ha ( cout, sum, a, b );\n [/INST]\n", "output": "output cout, sum; \n input a, b; \n assign sum = a ^ b; \n assign cout = a & b ; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe given Verilog module is a simple multiplier-accumulator (MAC) unit. It multiplies the inputs A and B and adds the result to the accumulator register acc. The output Z is the sum of the accumulator and the product of A and B. On every positive edge of the clock signal, the accumulator is assigned the value of Z.\n\n Module header:\n\nmodule macc_simple_preacc (input wire clk,input wire [ 7:0] A,input wire [ 7:0] B,output wire [15:0] Z);\n [/INST]\n", "output": "reg [15:0] acc; \n  assign Z = acc + (A * B); \n  always @(posedge clk) \n  acc <= Z; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a parameterized Look-Up Table (LUT) with shift functionality. It takes a 5-bit address input ADRS and generates an output O_D based on the value of ADRS when the enable signal EN_ROM1 is high. The module uses a case statement to assign the output O_D based on the value of ADRS. When ADRS matches a specific pattern, the corresponding value is assigned to O_D. If ADRS does not match any of the specified patterns, the default value of 5'b00000 is assigned to O_D. The output O_D is a parameterized width, determined by the value of P.\n\n Module header:\n\nmodule LUT_SHIFT #(parameter P = 5) (input wire CLK,input wire EN_ROM1,input wire [4:0] ADRS,output reg [P-1:0] O_D);\n [/INST]\n", "output": "always @(posedge CLK) \n  if (EN_ROM1) \n  case (ADRS) \n  5'b00000: O_D <= 5'b00001; \n  5'b00001: O_D <= 5'b00010; \n  5'b00010: O_D <= 5'b00011; \n  5'b00011: O_D <= 5'b00100; \n  5'b00100: O_D <= 5'b00100; \n  5'b00101: O_D <= 5'b00101; \n  5'b00110: O_D <= 5'b00110; \n  5'b00111: O_D <= 5'b00111; \n  5'b01000: O_D <= 5'b01000; \n  5'b01001: O_D <= 5'b01001; \n  5'b01010: O_D <= 5'b01010; \n  5'b01011: O_D <= 5'b01011; \n  5'b01100: O_D <= 5'b01100; \n  5'b01101: O_D <= 5'b01101; \n  5'b01110: O_D <= 5'b01101; \n  5'b01111: O_D <= 5'b01110; \n  5'b10000: O_D <= 5'b01111; \n  5'b10001: O_D <= 5'b10000; \n  5'b10010: O_D <= 5'b10001; \n  5'b10011: O_D <= 5'b10010; \n  5'b10100: O_D <= 5'b10011; \n  5'b10101: O_D <= 5'b10100; \n  5'b10110: O_D <= 5'b10101; \n  5'b10111: O_D <= 5'b10110; \n  5'b11000: O_D <= 5'b10111; \n  5'b11001: O_D <= 5'b11000; \n  5'b11010: O_D <= 5'b11001; \n  5'b11011: O_D <= 5'b11010; \n  5'b11100: O_D <= 5'b11011; \n  5'b11101: O_D <= 5'b11100; \n  5'b11110: O_D <= 5'b11101; \n  5'b11111: O_D <= 5'b11110; \n  default: O_D <= 5'b00000; \n  endcase \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module implements a finite state machine for a vending machine. It has inputs for start signal, clock, and reset, and outputs for displaying Q, D, N, P, and done signals. It includes a state transition logic for the vending machine operation. The initial block initializes the money and price values and starts the simulation. It then updates the money and price values, and resets the machine multiple times to simulate various vending scenarios. Finally, it prints a message to indicate the end of the simulation.\n\n Module header:\n\nmodule tbfsm();\n [/INST]\n", "output": "wire disp_Q,disp_D,disp_N,disp_P,done; \n  reg [6:0] money,price; \n  reg start,clk,reset; \n fsmVendingMachine fsm (disp_Q,disp_D,disp_N,disp_P,done,money,price,start,clk,reset); \n  always begin \n  #5 clk <= 0; \n  #5 clk <= 1; \n  end \n  initial \n  begin \n  $display($time, \" << Starting the simulation >>\"); \n  money = 7'd75; \n  price = 7'd64; \n  reset = 1'b0; \n  start = 1'b1; \n  #50 \n  money = 7'd100; \n  price = 7'd54; \n  reset = 1'b0; \n  start = 1'b1; \n  #50 \n  money = 7'd50; \n  price = 7'd27; \n  reset = 1'b0; \n  start = 1'b1; \n  #50 \n  money = 7'd50; \n  price = 7'd27; \n  reset = 1'b0; \n  start = 1'b1; \n  $display($time, \" << Finishing the simulation >>\"); \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module represents an instruction memory. It takes a 32-bit input Address and outputs a 32-bit instruction. It uses a case statement to match the 8 most significant bits of the Address and assigns the corresponding instruction to the output. If no match is found, it assigns a default value of 32'h00000000 to the output. This module essentially acts as a lookup table for instructions based on the provided address.\n\n Module header:\n\nmodule InstructionMemory(Address, Instruction);\n [/INST]\n", "output": "input [31:0] Address; \n  output reg [31:0] Instruction; \n  always @(*) \n  case (Address[9:2]) \n  8'd0 : Instruction <= {6'h08, 5'd0, 5'd4, 16'd3}; \n  8'd1 : Instruction <= {6'h03, 26'd3}; \n  8'd2 : Instruction <= {6'h04, 5'd0, 5'd0, -16'd1}; \n  8'd3 : Instruction <= {6'h08, 5'd29, 5'd29, -16'd8}; \n  8'd4 : Instruction <= {6'h2b, 5'd29, 5'd31, 16'd4}; \n  8'd5 : Instruction <= {6'h2b, 5'd29, 5'd4, 16'd0}; \n  8'd6 : Instruction <= {6'h0a, 5'd4, 5'd8, 16'd1}; \n  8'd7 : Instruction <= {6'h04, 5'd8, 5'd0, 16'd3}; \n  8'd8 : Instruction <= {6'h00, 5'd0, 5'd0, 5'd2, 5'd0, 6'h26}; \n  8'd9 : Instruction <= {6'h08, 5'd29, 5'd29, 16'd8}; \n  8'd10: Instruction <= {6'h00, 5'd31, 15'd0, 6'h08}; \n  8'd11: Instruction <= {6'h08, 5'd4, 5'd4, -16'd1}; \n  8'd12: Instruction <= {6'h03, 26'd3}; \n  8'd13: Instruction <= {6'h23, 5'd29, 5'd4, 16'd0}; \n  8'd14: Instruction <= {6'h23, 5'd29, 5'd31, 16'd4}; \n  8'd15: Instruction <= {6'h08, 5'd29, 5'd29, 16'd8}; \n  8'd16: Instruction <= {6'h00, 5'd4, 5'd2, 5'd2, 5'd0, 6'h20}; \n  8'd17: Instruction <= {6'h00, 5'd31, 15'd0, 6'h08}; \n  default: Instruction <= 32'h00000000; \n  endcase \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a wavepool controller that manages wavefronts. It takes various inputs such as buffer write ID, buffer first, buffer acknowledge, reserve slot ID, reserve valid, halt wavefront ID, branch wavefront ID, branch enable, branch taken, input feed wavefront ID, feed valid, clock, and reset. The module provides outputs such as queue write, queue tail increment, queue reset, queue read, valid wavefront, decode wavefront ID, and decode instruction valid.\n\nInternally, the module uses decoder modules to convert the input wavefront IDs into control signals for the queue operations. It also computes the next valid wavefront based on the buffer acknowledge, buffer first, and the current valid wavefront. Additionally, it determines the queue operations based on the input control signals and the current state of the wavefronts.\n\nOverall, this module orchestrates the management of wavefronts in the wavepool based on the inputs and internal logic, and provides the necessary outputs to control the wavefront processing.\n\n Module header:\n\nmodule wavepool_controller (buff_wfid,buff_first,buff_ack,q_wr,reserve_slotid,reserve_valid,q_vtail_incr,halt_wfid,wf_halt,branch_wfid,branch_en,branch_taken,q_reset,feed_wfid,feed_valid,q_rd,valid_wf,decode_wfid,decode_instr_valid,clk,rst);\n [/INST]\n", "output": "input [5:0] buff_wfid; \n input buff_first; \n input buff_ack; \n output [39:0] q_wr; \n input [5:0] reserve_slotid; \n input reserve_valid; \n output [39:0] q_vtail_incr; \n input [5:0] halt_wfid; \n input wf_halt; \n input [5:0] branch_wfid; \n input branch_en; \n input branch_taken; \n output [39:0] q_reset; \n input [5:0] feed_wfid; \n input feed_valid; \n output [39:0] q_rd; \n output [39:0] valid_wf; \n output [5:0] decode_wfid; \n output decode_instr_valid; \n input clk; \n input rst; \n wire [39:0] next_valid_wf; \n wire [39:0] valid_wf; \n wire [39:0] temp_q_wr; \n wire [39:0] temp_q_vtail_incr; \n wire [39:0] halt_temp_q_reset; \n wire [39:0] branch_temp_q_reset; \n wire [39:0] temp_q_rd; \n wire branch_taken_en; \n reg_40b valid_wavefront(.out(valid_wf), .in(next_valid_wf), .wr_en(1'b1), .clk(clk), .rst(rst)); \n assign next_valid_wf = (valid_wf | ((temp_q_wr & {40{buff_ack}}) & {40{buff_first}})) & (~q_reset); \n decoder_6_to_40 dec_q_wr(.out(temp_q_wr), .in(buff_wfid)); \n assign q_wr = (temp_q_wr & {40{buff_ack}}) & ({40{buff_first}} | valid_wf); \n decoder_6_to_40 dec_q_vtail_incr(.out(temp_q_vtail_incr), .in(reserve_slotid)); \n assign q_vtail_incr = temp_q_vtail_incr & {40{reserve_valid}}; \n decoder_6_to_40 dec_q_reset_halt(.out(halt_temp_q_reset), .in(halt_wfid)); \n decoder_6_to_40 dec_q_reset_branch(.out(branch_temp_q_reset), .in(branch_wfid)); \n assign branch_taken_en = branch_taken & branch_en; \n assign q_reset = (halt_temp_q_reset & {40{wf_halt}}) | (branch_temp_q_reset & {40{branch_taken_en}}); \n decoder_6_to_40 dec_q_rd(.out(temp_q_rd), .in(feed_wfid)); \n assign q_rd = temp_q_rd & {40{feed_valid}}; \n assign decode_wfid = feed_wfid; \n assign decode_instr_valid = feed_valid; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, `oc54_exp`, implements a computation based on the input signals `ena`, `sel_acc`, `a`, `b`, `bp_ar`, `bp_br`, `bp_a`, and `bp_b`, and generates the output signal `result`. The computation is synchronized with the clock signal `clk`. The internal register `acc` holds the value of either `bp_ar`, `bp_br`, `a`, or `b` based on the control signals `sel_acc`, `bp_a`, and `bp_b`. The value of `result` is determined based on the value of `acc` and the `ena` signal. If `acc` is non-zero, `result` is assigned the value 1F in hexadecimal, otherwise, it is assigned the value 1E in hexadecimal when `ena` is high.\n\n Module header:\n\nmodule oc54_exp (clk, ena,sel_acc,a, b,bp_ar, bp_br,bp_a, bp_b,result);\n [/INST]\n", "output": "input clk; \n input ena; \n input sel_acc; \n input [39:0] a, b; \n input [39:0] bp_ar, bp_br; \n input bp_a, bp_b; \n output [ 5:0] result; \n reg [5:0] result; \n reg [39:0] acc; \n always@(posedge clk) \n  if (ena) \n  if (sel_acc) \n  acc <= bp_b ? bp_br : b; \n  else \n  acc <= bp_a ? bp_ar : a; \n always@(posedge clk) \n  if (ena) \n  if (acc) \n  result <= 6'h1f; \n  else \n  result <= 6'h1e; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a 32-bit memory with input and output interfaces. It has a register R0 and RAM T2 to store data. It also has wires T3, T4, T5, T6, T7, T8, and T9 for signal propagation. The module provides interfaces for input and output data, and a control interface for handling requests. It uses combinational logic and a clocked always block to handle read and write operations based on the input signals, and updates the memory accordingly. The module also sets the io_in_ready and io_out_valid signals to 1, indicating that it is ready to receive input and provide output.\n\n Module header:\n\nmodule spMem32(input clk, input reset,output io_in_ready,input io_in_valid,input [9:0] io_in_bits_address,input io_in_bits_rw,input [1023:0] io_in_bits_wData,input [9:0] io_in_tag,input io_out_ready,output io_out_valid,output[1023:0] io_out_bits_rData,output[9:0] io_out_tag,input io_pcIn_valid,input io_pcIn_bits_request,input [15:0] io_pcIn_bits_moduleId,input [7:0] io_pcIn_bits_portId,input [19:0] io_pcIn_bits_pcValue,input [3:0] io_pcIn_bits_pcType,output io_pcOut_valid,output io_pcOut_bits_request,output[15:0] io_pcOut_bits_moduleId,output[7:0] io_pcOut_bits_portId,output[19:0] io_pcOut_bits_pcValue,output[3:0] io_pcOut_bits_pcType);\n [/INST]\n", "output": "reg[1023:0] R0; \n  wire[1023:0] T1; \n  reg [1023:0] T2 [1023:0]; \n  wire[9:0] T3; \n  wire T4; \n  wire T5; \n  wire[1023:0] T6; \n  wire[1023:0] T7; \n  wire T8; \n  wire T9; \n  assign io_in_ready = 1'h1; \n  assign io_out_valid = 1'h1; \n  assign io_out_bits_rData = R0; \n  assign T4 = io_in_valid && T5; \n  assign T5 = io_in_bits_rw == 1'h0; \n  assign T7 = io_in_bits_wData; \n  assign T8 = io_in_valid && T9; \n  assign T9 = io_in_bits_rw == 1'h1; \n  always @(posedge clk) begin \n  if(T4) \n  R0 <= T2[io_in_bits_address]; \n  if (T8) \n  T2[io_in_bits_address] <= T7; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a synchronous output register with set/reset functionality. The output Q is triggered by the positive edge of the clock signal C and the synchronous input S. If S is high, Q is set to 1; otherwise, Q is assigned the value of input D. Additionally, the module includes setup timing constraints based on the targeted hardware (ICE40_HX, ICE40_LP, or ICE40_U). This allows the designer to specify the timing requirements for the design. The module is designed to work with different constraints based on the target hardware.\n\n Module header:\n\nmodule SB_DFFS (output reg Q,input C, S, D);\n [/INST]\n", "output": "`SB_DFF_INIT \n  always @(posedge C, posedge S) \n  if (S) \n  Q <= 1; \n  else \n  Q <= D; \n `ifdef ICE40_HX \n  specify \n  $setup(D, posedge C, 470 - 449); \n  $setup(negedge S, posedge C, 160); \n `ifndef YOSYS \n  (posedge S => (Q : 1'b1)) = 599; \n `else \n  if (S) (S => Q) = 599; \n `endif \n  if (!S) (posedge C => (Q : D)) = 540; \n  endspecify \n `endif \n `ifdef ICE40_LP \n  specify \n  $setup(D, posedge C, 693 - 662); \n  $setup(negedge S, posedge C, 235); \n `ifndef YOSYS \n  (posedge S => (Q : 1'b1)) = 883; \n `else \n  if (S) (S => Q) = 883; \n `endif \n  if (!S) (posedge C => (Q : D)) = 796; \n  endspecify \n `endif \n `ifdef ICE40_U \n  specify \n  $setup(D, posedge C, 0); \n  $setup(negedge S, posedge C, 424); \n `ifndef YOSYS \n  (posedge S => (Q : 1'b1)) = 1589; \n `else \n  if (S) (S => Q) = 1589; \n `endif \n  if (!S) (posedge C => (Q : D)) = 1391; \n  endspecify \n `endif \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an encoder for floating-point addition and subtraction operations. It takes a 4-bit input and generates a 2-bit output. The module instantiates two submodules, altpriority_encoder17 and altpriority_encoder18, to process parts of the input data. The output q is computed using the outputs of the submodules and a zero signal.\n\n Module header:\n\nmodule float_add_sub_altpriority_encoder_6v7 (data,q) ;\n [/INST]\n", "output": "input [3:0] data; \n  output [1:0] q; \n  wire [0:0] wire_altpriority_encoder17_q; \n  wire [0:0] wire_altpriority_encoder18_q; \n  wire wire_altpriority_encoder18_zero; \n  float_add_sub_altpriority_encoder_3v7 altpriority_encoder17 \n (.data(data[1:0]),.q(wire_altpriority_encoder17_q)); \n  float_add_sub_altpriority_encoder_3e8 altpriority_encoder18 \n (.data(data[3:2]),.q(wire_altpriority_encoder18_q),.zero(wire_altpriority_encoder18_zero)); \n  assign \n  q = {(~ wire_altpriority_encoder18_zero), ((wire_altpriority_encoder18_zero & wire_altpriority_encoder17_q) | ((~ wire_altpriority_encoder18_zero) & wire_altpriority_encoder18_q))}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a simple inverter that takes an input signal A and produces the logical negation of that signal as output Y.\n\n Module header:\n\nmodule INVD (input A,output Y);\n [/INST]\n", "output": "assign Y = !A; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module interfaces with a LED module. It takes in a clock signal, reset signal, and data, and outputs processed data for the LED module. The LED counter, clock, reset, input, and output are all defined within the module. The LED clock and reset signals are assigned to the input clock and reset signals, and the LED input and output are assigned to the module's input and processed output, respectively. The LED output is also combined and assigned to specific bits of the output data. The LED module is instantiated within this module.\n\n Module header:\n\nmodule sys_aux_module(aux_clk ,aux_rst_n ,aux_data_i ,aux_data_o);\n [/INST]\n", "output": "input aux_clk ; \n  input aux_rst_n ; \n  input [07:00] aux_data_i ; \n  output [15:00] aux_data_o ; \n  reg [09:00] led_cnt ; \n  wire led_clk ; \n  wire led_rst_n ; \n  wire [07:00] led_in ; \n  wire [07:00] led_out ; \n  assign led_clk = aux_clk ; \n  assign led_rst_n = aux_rst_n ; \n  assign led_in[07:00] = aux_data_i ; \n  assign aux_data_o[07:00] = led_out ; \n  assign aux_data_o[15:08] = led_out & led_out ; \n sys_led_module sys_led_inst_l2(.led_clk (led_clk ),.led_rst_n (led_rst_n ),.led_in (led_in ),.led_out (led_out )); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module implements a data synchronization block with parameters PS and DELAY. It checks the CFG_ASIC flag and instantiates an ASIC module or declares a synchronizer pipeline. When nreset is asserted, the synchronizer pipeline is set to 'b0'. Otherwise, it combines the input value with the pipeline and assigns the output dout based on the combined value and the DELAY parameter. If DELAY is 0, the output is the inverted value of the second-to-last bit in the pipeline; otherwise, it's the last bit.\n\n Module header:\n\nmodule oh_dsync #(parameter PS = 2,parameter DELAY = 0) (input clk,input nreset,input din,output dout);\n [/INST]\n", "output": "`ifdef CFG_ASIC \n asic_dsync asic_dsync (.clk(clk),.nreset(nreset),.din(din),.dout(dout)); \n `else \n  reg [PS:0] sync_pipe; \n  always @ (posedge clk or negedge nreset) \n  if(!nreset) \n  sync_pipe[PS:0] <= 'b0; \n  else \n  sync_pipe[PS:0] <= {sync_pipe[PS-1:0],din}; \n  assign dout = (DELAY & sync_pipe[PS]) | \n  (~DELAY & sync_pipe[PS-1]); \n `endif \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module instantiates a Digital Clock Manager (DCM) for clock domain crossing. It generates output clocks based on the input clock and phase selection signals. The module includes input and output clocks, phase select, feedback clock, reset, increment, enable, and clock signals. It also outputs a done signal, status signals, and a locked signal. The module uses a DCM and buffers to create the required clock signals and manage clock domain crossings. The done signal is synchronized to the clock and reset signals.\n\n Module header:\n\nmodule dcm333#(parameter IOSTANDARD_SDRAM_DIFF = \"DIFF_SSTL2_I\",parameter SLEW_SDRAM_DIFF = \"SLOW\")(sclk,SDCLK,SDNCLK,sdcl_fb,xclk,phsel,dcm_rst,dcm_incdec,dcm_en,dcm_clk,dcm_done,locked,status);\n [/INST]\n", "output": "input sclk; \n  output xclk; \n  output SDCLK, SDNCLK; \n  input [1:0] phsel; \n  input sdcl_fb; \n  input dcm_rst, dcm_incdec, dcm_en, dcm_clk; \n  output dcm_done; \n  output [7:0] status; \n  output locked; \n  wire isdclk0, isdclk90, isdclk180, isdclk270; \n  wire ixclk; \n  wire isdclk; \n  reg dcm_done; \n  wire dcm_done_dcm; \n  assign isdclk=phsel[1]? (phsel[0]?isdclk270:isdclk180):(phsel[0]?isdclk90:isdclk0); \n  FD i_ixclk (.C(sclk), .D(!ixclk), .Q(ixclk)); \n  BUFG i_xclk (.I(ixclk), .O(xclk)); \n DCM #(.CLKIN_DIVIDE_BY_2 (\"FALSE\"),.CLKIN_PERIOD (8.33333),.CLK_FEEDBACK (\"1X\"),.DESKEW_ADJUST (\"SYSTEM_SYNCHRONOUS\"),.DLL_FREQUENCY_MODE (\"LOW\"),.DUTY_CYCLE_CORRECTION (\"TRUE\"),.PHASE_SHIFT (0),.CLKOUT_PHASE_SHIFT (\"VARIABLE\")) i_dcm2(.CLKIN (sclk),.CLKFB (isdclk90),.RST (dcm_rst),.PSEN (dcm_en),.PSINCDEC (dcm_incdec),.PSCLK (dcm_clk),.DSSEN (1'b0),.CLK0 (isdclk90),.CLK90 (isdclk180),.CLK180 (isdclk270),.CLK270 (isdclk0),.CLKDV (),.CLK2X (),.CLK2X180 (),.CLKFX (),.CLKFX180 (),.STATUS (status[7:0]),.LOCKED (locked),.PSDONE (dcm_done_dcm)); \n OBUFDS #(.IOSTANDARD(IOSTANDARD_SDRAM_DIFF),.SLEW(SLEW_SDRAM_DIFF)) \n  i_SDCLK (.O(SDCLK),.OB(SDNCLK),.I(isdclk)); \n  always @ (posedge dcm_clk or posedge dcm_rst) \n  if (dcm_rst) dcm_done <= 1'b1; \n  else if (dcm_en) dcm_done <=1'b0; \n  else if (dcm_done_dcm) dcm_done <=1'b1; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a parallel right arithmetic rotation (RAR) on an n-bit input vector r. The module generates an n-bit output vector g that results from rotating the input vector to the right by one bit. The rotation is performed using an internal wire c, initialized with a value of 1 and updated recursively using the previous value of c and the input vector r. The output g is calculated by performing a bitwise AND operation between the input vector r and the wire c.\n\n Module header:\n\nmodule RARb #(parameter n = 8) (r, g);\n [/INST]\n", "output": "input [n - 1 : 0] r; \n  output [n - 1 : 0] g; \n  wire [ n - 1 : 0 ] c = {1'b1, (~r[n-1:1] & c[n-1:1])}; \n  assign g = r & c; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an AC97 interface that communicates with an audio codec. It synchronizes the AC97 bit clock and handles the transmission and reception of command and data signals. The module includes registers for the bit count, command address, command data, left and right data, and their respective valid signals. It also controls the generation of the ready signal for data transfer.\n\nThe module generates the AC97_sdata_out signal based on the bit count and input signals. It handles the serialization of command and data signals based on the bit count and transmits them in the proper AC97 format. Additionally, it updates the left_in_data and right_in_data registers based on the falling edge of the AC97 bit clock to receive incoming data.\n\n Module header:\n\nmodule ac97 (output reg ready,input wire [7:0] command_address,input wire [15:0] command_data,input wire command_valid,input wire [19:0] left_data,input wire left_valid,input wire [19:0] right_data,input wire right_valid,output reg [19:0] left_in_data, right_in_data,output reg ac97_sdata_out,input wire ac97_sdata_in,output reg ac97_synch,input wire ac97_bit_clock);\n [/INST]\n", "output": "reg [7:0] bit_count; \n  reg [19:0] l_cmd_addr; \n  reg [19:0] l_cmd_data; \n  reg [19:0] l_left_data, l_right_data; \n  reg l_cmd_v, l_left_v, l_right_v; \n  initial begin \n  ready <= 1'b0; \n  ac97_sdata_out <= 1'b0; \n  ac97_synch <= 1'b0; \n  bit_count <= 8'h00; \n  l_cmd_v <= 1'b0; \n  l_left_v <= 1'b0; \n  l_right_v <= 1'b0; \n  left_in_data <= 20'h00000; \n  right_in_data <= 20'h00000; \n  end \n  always @(posedge ac97_bit_clock) begin \n  if (bit_count == 255) \n  ac97_synch <= 1'b1; \n  if (bit_count == 15) \n  ac97_synch <= 1'b0; \n  if (bit_count == 128) \n  ready <= 1'b1; \n  if (bit_count == 2) \n  ready <= 1'b0; \n  if (bit_count == 255) begin \n  l_cmd_addr <= {command_address, 12'h000}; \n  l_cmd_data <= {command_data, 4'h0}; \n  l_cmd_v <= command_valid; \n  l_left_data <= left_data; \n  l_left_v <= left_valid; \n  l_right_data <= right_data; \n  l_right_v <= right_valid; \n  end \n  if ((bit_count >= 0) && (bit_count <= 15)) \n  case (bit_count[3:0]) \n  4'h0: ac97_sdata_out <= 1'b1; \n  4'h1: ac97_sdata_out <= l_cmd_v; \n  4'h2: ac97_sdata_out <= l_cmd_v; \n  4'h3: ac97_sdata_out <= l_left_v; \n  4'h4: ac97_sdata_out <= l_right_v; \n  default: ac97_sdata_out <= 1'b0; \n  endcase \n  else if ((bit_count >= 16) && (bit_count <= 35)) \n  ac97_sdata_out <= l_cmd_v ? l_cmd_addr[35-bit_count] : 1'b0; \n  else if ((bit_count >= 36) && (bit_count <= 55)) \n  ac97_sdata_out <= l_cmd_v ? l_cmd_data[55-bit_count] : 1'b0; \n  else if ((bit_count >= 56) && (bit_count <= 75)) begin \n  ac97_sdata_out <= l_left_v ? l_left_data[19] : 1'b0; \n  l_left_data <= { l_left_data[18:0], l_left_data[19] }; \n  end \n  else if ((bit_count >= 76) && (bit_count <= 95)) \n  ac97_sdata_out <= l_right_v ? l_right_data[95-bit_count] : 1'b0; \n  else \n  ac97_sdata_out <= 1'b0; \n  bit_count <= bit_count+1; \n  end \n  always @(negedge ac97_bit_clock) begin \n  if ((bit_count >= 57) && (bit_count <= 76)) \n  left_in_data <= { left_in_data[18:0], ac97_sdata_in }; \n  else if ((bit_count >= 77) && (bit_count <= 96)) \n  right_in_data <= { right_in_data[18:0], ac97_sdata_in }; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes an address input and generates a readdata output based on the address value. If the address is non-zero, the readdata output is set to 1411627075; otherwise, it is set to 0. The module operates synchronously with a clock signal and includes a reset_n input for asynchronous reset.\n\n Module header:\n\nmodule usb_system_sysid_qsys_0 (address,clock,reset_n,readdata);\n [/INST]\n", "output": "output [ 31: 0] readdata; \n  input address; \n  input clock; \n  input reset_n; \n  wire [ 31: 0] readdata; \n  assign readdata = address ? 1411627075 : 0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe \"ad_iqcor\" module is designed to perform IQ correction on input data signals \"data_i\" and \"data_q\" using IQCOR coefficients \"iqcor_coeff_1\" and \"iqcor_coeff_2\". It uses two \"ad_mul\" instances to calculate the corrected IQ signals. The module then assigns the corrected signals to \"data_out\" based on the \"iqcor_enable\" and \"IQSEL\" inputs. The \"valid_out\" signal is also generated based on the \"p1_valid\" signal. The module utilizes registers and wires to store intermediate values and performs these computations on the rising edge of the clock signal.\n\n Module header:\n\nmodule ad_iqcor (clk,valid,data_i,data_q,valid_out,data_out,iqcor_enable,iqcor_coeff_1,iqcor_coeff_2);\n [/INST]\n", "output": "parameter IQSEL = 0; \n  input clk; \n  input valid; \n  input [15:0] data_i; \n  input [15:0] data_q; \n  output valid_out; \n  output [15:0] data_out; \n  input iqcor_enable; \n  input [15:0] iqcor_coeff_1; \n  input [15:0] iqcor_coeff_2; \n  reg p1_valid = 'd0; \n  reg [15:0] p1_data_i = 'd0; \n  reg [15:0] p1_data_q = 'd0; \n  reg [33:0] p1_data_p = 'd0; \n  reg valid_out = 'd0; \n  reg [15:0] data_out = 'd0; \n  wire [33:0] p1_data_p_i_s; \n  wire p1_valid_s; \n  wire [15:0] p1_data_i_s; \n  wire [33:0] p1_data_p_q_s; \n  wire [15:0] p1_data_q_s; \n ad_mul #(.DELAY_DATA_WIDTH(17)) i_mul_i (.clk (clk),.data_a ({data_i[15], data_i}),.data_b ({iqcor_coeff_1[15], iqcor_coeff_1}),.data_p (p1_data_p_i_s),.ddata_in ({valid, data_i}),.ddata_out ({p1_valid_s, p1_data_i_s})); \n ad_mul #(.DELAY_DATA_WIDTH(16)) i_mul_q (.clk (clk),.data_a ({data_q[15], data_q}),.data_b ({iqcor_coeff_2[15], iqcor_coeff_2}),.data_p (p1_data_p_q_s),.ddata_in (data_q),.ddata_out (p1_data_q_s)); \n  always @(posedge clk) begin \n  p1_valid <= p1_valid_s; \n  p1_data_i <= p1_data_i_s; \n  p1_data_q <= p1_data_q_s; \n  p1_data_p <= p1_data_p_i_s + p1_data_p_q_s; \n  end \n  always @(posedge clk) begin \n  valid_out <= p1_valid; \n  if (iqcor_enable == 1'b1) begin \n  data_out <= p1_data_p[29:14]; \n  end else if (IQSEL == 1) begin \n  data_out <= p1_data_q; \n  end else begin \n  data_out <= p1_data_i; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `wasca_nios2_gen2_0_cpu_nios2_oci_im` is designed to control the trace memory in a NIOS II processor. It has several input and output ports including `clk`, `jrst_n`, `trc_ctrl`, `tw`, `tracemem_on`, `tracemem_trcdata`, `tracemem_tw`, `trc_im_addr`, `trc_wrap`, and `xbrk_wrap_traceoff`.\n\nThe module updates the trace memory based on the control signals and the jump reset. It sets the trace memory address and wrap based on the state of the processor. It also calculates the trace memory enable on-chip and the validity of the trace memory data. Additionally, it sets the signal for trace memory wrap and traceoff.\n\nThe `tracemem_trcdata` output is assigned a constant value of 0, indicating that there is no active trace memory data being produced by this module.\n\n Module header:\n\nmodule wasca_nios2_gen2_0_cpu_nios2_oci_im (clk,jrst_n,trc_ctrl,tw,tracemem_on,tracemem_trcdata,tracemem_tw,trc_im_addr,trc_wrap,xbrk_wrap_traceoff);\n [/INST]\n", "output": "output tracemem_on; \n  output [ 35: 0] tracemem_trcdata; \n  output tracemem_tw; \n  output [ 6: 0] trc_im_addr; \n  output trc_wrap; \n  output xbrk_wrap_traceoff; \n  input clk; \n  input jrst_n; \n  input [ 15: 0] trc_ctrl; \n  input [ 35: 0] tw; \n  wire tracemem_on; \n  wire [ 35: 0] tracemem_trcdata; \n  wire tracemem_tw; \n  reg [ 6: 0] trc_im_addr ; \n  wire [ 35: 0] trc_im_data; \n  wire trc_on_chip; \n  reg trc_wrap ; \n  wire tw_valid; \n  wire xbrk_wrap_traceoff; \n  assign trc_im_data = tw; \n  always @(posedge clk or negedge jrst_n) \n  begin \n  if (jrst_n == 0) \n  begin \n  trc_im_addr <= 0; \n  trc_wrap <= 0; \n  end \n  else \n  begin \n  trc_im_addr <= 0; \n  trc_wrap <= 0; \n  end \n  end \n  assign trc_on_chip = ~trc_ctrl[8]; \n  assign tw_valid = |trc_im_data[35 : 32]; \n  assign xbrk_wrap_traceoff = trc_ctrl[10] & trc_wrap; \n  assign tracemem_trcdata = 0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module `wb_master` is a Wishbone bus master interface. It communicates with a device using the Wishbone protocol. The module controls the read and write operations on the bus based on input signals such as `cpu_byte_o`, `cpu_memop`, and `cpu_m_io`. It also manipulates and processes data for input and output. The module includes state machines, registers, and combinational logic for address and data manipulation. The output signals `cpu_block`, `wb_adr_o`, `wb_sel_o`, `wb_stb_o`, and `wb_dat_o` are manipulated based on the conditions of the state machines and input signals.\n\n Module header:\n\nmodule wb_master (input cpu_byte_o,input cpu_memop,input cpu_m_io,input [19:0] cpu_adr_o,output reg cpu_block,output reg [15:0] cpu_dat_i,input [15:0] cpu_dat_o,input cpu_we_o,input wb_clk_i,input wb_rst_i,input [15:0] wb_dat_i,output reg [15:0] wb_dat_o,output reg [19:1] wb_adr_o,output wb_we_o,output wb_tga_o,output reg [ 1:0] wb_sel_o,output reg wb_stb_o,output wb_cyc_o,input wb_ack_i);\n [/INST]\n", "output": "reg [ 1:0] cs; \n  reg [ 1:0] ns; \n  reg [19:1] adr1; \n  wire op; \n  wire odd_word; \n  wire a0; \n  wire [15:0] blw; \n  wire [15:0] bhw; \n  wire [ 1:0] sel_o; \n  localparam [1:0] \n  IDLE = 2'd0, \n  stb1_hi = 2'd1, \n  stb2_hi = 2'd2, \n  bloc_lo = 2'd3; \n  assign op = (cpu_memop | cpu_m_io); \n  assign odd_word = (cpu_adr_o[0] & !cpu_byte_o); \n  assign a0 = cpu_adr_o[0]; \n  assign blw = { {8{wb_dat_i[7]}}, wb_dat_i[7:0] }; \n  assign bhw = { {8{wb_dat_i[15]}}, wb_dat_i[15:8] }; \n  assign wb_we_o = cpu_we_o; \n  assign wb_tga_o = cpu_m_io; \n  assign sel_o = a0 ? 2'b10 : (cpu_byte_o ? 2'b01 : 2'b11); \n  assign wb_cyc_o = wb_stb_o; \n  always @(posedge wb_clk_i) \n cpu_dat_i <= (cs == stb1_hi) ? (wb_ack_i ? (a0 ? bhw : (cpu_byte_o ? blw : wb_dat_i)): cpu_dat_i) : ((cs == stb2_hi && wb_ack_i) ? { wb_dat_i[7:0], cpu_dat_i[7:0] } : cpu_dat_i); \n  always @(posedge wb_clk_i) adr1 <= cpu_adr_o[19:1] + 1'b1; \n  always @(posedge wb_clk_i) wb_adr_o <= (ns==stb2_hi) ? adr1 : cpu_adr_o[19:1]; \n  always @(posedge wb_clk_i) wb_sel_o <= (ns==stb1_hi) ? sel_o : 2'b01; \n  always @(posedge wb_clk_i) wb_stb_o <= (ns==stb1_hi || ns==stb2_hi); \n  always @(posedge wb_clk_i) wb_dat_o <= a0 ? { cpu_dat_o[7:0], cpu_dat_o[15:8] } : cpu_dat_o; \n  always @(*) \n  case (cs) \n  IDLE: cpu_block <= op; \n  default: cpu_block <= 1'b1; \n  bloc_lo: cpu_block <= wb_ack_i; \n  endcase \n  always @(posedge wb_clk_i) cs <= wb_rst_i ? IDLE : ns; \n  always @(*) \n  case (cs) \n  default: ns <= wb_ack_i ? IDLE : (op ? stb1_hi : IDLE); \n  stb1_hi: ns <= wb_ack_i ? (odd_word ? stb2_hi : bloc_lo) : stb1_hi; \n  stb2_hi: ns <= wb_ack_i ? bloc_lo : stb2_hi; \n  bloc_lo: ns <= wb_ack_i ? bloc_lo : IDLE; \n  endcase \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a simple 32-bit multiplier. It takes two 32-bit inputs, opA and opB_mux_out, and produces a 32-bit result. The result is updated on the rising edge of the clock signal. When the resetn input is asserted, the result is set to all zeros. Otherwise, the result is the product of opA and opB_mux_out.\n\n Module header:\n\nmodule dummy_mult (opA,opB_mux_out, clk, resetn, result);\n [/INST]\n", "output": "input [31:0] opA; \n input [31:0] opB_mux_out; \n input clk; \n input resetn; \n output[31:0] result; \n reg [31:0] result; \n always @ (posedge clk) \n begin \n  if (resetn) \n  result <= 32'b00000000000000000000000000000000; \n  else \n  result <= opA * opB_mux_out; \n end \n  endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a single-cycle processor that controls LEDs based on input signals. The module includes a counter that increments on every clock cycle, and a single-cycle processor that modifies the number based on the start, stop, enable, and reset signals. The LED1 output is assigned to the inverted number, LED2 and LED3 are assigned to inverted debug1 and debug2 respectively, and debug1 and debug2 are derived from the single-cycle processor. The start and stop signals control the operation of the single-cycle processor.\n\n Module header:\n\nmodule single_cycle(input clk,input enable,output LED1,output reg LED2,LED3);\n [/INST]\n", "output": "reg [32:0] cnt = 0; \n reg number=0; \n reg start=0; \n reg stop=0; \n reg reset=0; \n wire debug1,debug2; \n single_cycle_top sc(number,reset,debug1,debug2); \n always @(negedge enable,posedge stop)begin \n  if(stop) \n  start=0; \n  else begin \n  if(!enable) \n  start=1; \n  else \n  start=0; \n  end \n end \n always @(posedge clk)begin \n  cnt <= cnt + 1'b1; \n end \n always @(posedge cnt[4]) begin \n  if(!start) begin \n  number=0; \n  stop=0; \n  reset=1; \n  end else begin \n  reset=0; \n  number = ~number; \n  if(debug1&&debug2) \n  stop=1; \n  end \n end \n always @(debug1, debug2,start) begin \n  if(start) begin \n  LED2=~debug1; \n  LED3=~debug2; \n  end \n end \n assign LED1 = !number; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a Pulse Width Modulation (PWM) generator with a configurable MAX_WAVE parameter. It uses a counter to generate the PWM signal by comparing the counter value to the period and compare inputs. If the counter exceeds the period, it resets, and if it's less than the compare value, the PWM output is set high. The counter and PWM are updated based on the clock signal, and they are reset if the reset input is asserted. The PWM output is driven by the pwm_q register.\n\n Module header:\n\nmodule pwm #(parameter MAX_WAVE = 24) (input clk,input rst,input [MAX_WAVE-1:0] period,input [MAX_WAVE-1:0] compare,output pwm);\n [/INST]\n", "output": "reg pwm_d, pwm_q; \n reg [MAX_WAVE-1:0] ctr_d, ctr_q; \n assign pwm = pwm_q; \n always@(ctr_q) begin \n  if (ctr_q > period) begin \n  ctr_d = 1'b0; \n  end else begin \n  ctr_d = ctr_q + 1'b1; \n  end \n  if (compare > ctr_d) begin \n  pwm_d = 1'b0; \n  end else begin \n  pwm_d = 1'b1; \n  end \n end \n always@(posedge clk) begin \n  if (rst) begin \n  ctr_q <= 1'b0; \n  pwm_q <= 1'b0; \n  end else begin \n  ctr_q <= ctr_d; \n  pwm_q <= pwm_d; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is designed for UART transmission. It instantiates two sub-modules, `uart_light_tx_ctrl` and `uart_light_tx_dp`, which handle control logic and data processing, respectively. The module interfaces with the FIFO to manage the transmission of data. The control signals `transmit`, `clear`, and FIFO read/write signals are connected between the main module and the sub-modules to coordinate the transmission process. The `frame_done` signal indicates the completion of the transmission frame. Additionally, the `fifo_tx_read` output is assigned to `fifo_read_enable`. The UART module supports parameterized inputs for the word size and FIFO address bits, offering flexibility in configuration. The `tx` output represents the transmitted data.\n\n Module header:\n\nmodule uart_light_tx #(parameter WORD_SIZE = 8,parameter FIFO_ADDR_BITS = 5)(input wire reset,input wire clk_peri,input wire clk_tx,input wire word_ready,input wire [WORD_SIZE-1:0] word_tx,output wire tx,output wire fifo_tx_full,output wire fifo_tx_empty,output wire fifo_tx_read);\n [/INST]\n", "output": "wire frame_done,transmit,clear,fifo_read_enable,fifo_full,fifo_empty,fifo_write_enable; \n  assign fifo_tx_read = fifo_read_enable; \n  uart_light_tx_ctrl \n  tx_ctrl0 \n (.reset(reset),.clk_tx(clk_tx),.word_ready(word_ready),.fifo_tx_full(fifo_tx_full),.fifo_tx_empty(fifo_tx_empty),.frame_done(frame_done),.transmit(transmit),.clear(clear),.fifo_read_enable(fifo_read_enable),.fifo_full(fifo_full),.fifo_empty(fifo_empty),.fifo_write_enable(fifo_write_enable)); \n  uart_light_tx_dp \n #(.FIFO_ADDR_BITS(FIFO_ADDR_BITS)) \n  tx_dp0 \n (.reset(reset),.clk_peri(clk_peri),.clk_tx(clk_tx),.tx(tx),.word_tx(word_tx),.transmit(transmit),.clear(clear),.fifo_read_enable(fifo_read_enable),.frame_done(frame_done),.fifo_full(fifo_full),.fifo_empty(fifo_empty),.fifo_write_enable(fifo_write_enable)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module is a barrel shifter that can perform left and right shifts, as well as rotation operations on a 16-bit input. It contains multiple stages of barrel shifting, each with their own specific logic for shifting and rotating the input bits. The module also has a reverse operation that reorders the output bits based on the direction of the barrel shift. The final output is a 16-bit vector representing the result of the barrel shifting operation.\n\n Module header:\n\nmodule barrel_shifter (output [15:0] yout,input [15:0] ain,input [4:0] bin,input rotate,input sra);\n [/INST]\n", "output": "wire [3:0] b; \n  wire [15:0] a; \n  wire [15:0] y; \n  wire s; \n  wire [7:0]rb3; \n  wire [15:0]b3; \n  wire [3:0]rb2; \n  wire [15:0]b2; \n  wire [1:0]rb1; \n  wire [15:0]b1; \n  wire rb0; \n  wire left; \n  assign left = (bin[4])?(1'b1):(1'b0); \n  assign b = (left)?(~bin[3:0]):(bin[3:0]); \n  genvar m; \n  generate \n  for (m=0; m < 15; m=m+1) begin : REVERSE_INPUT \n  assign a[m] = (left)?(ain[14-m]):(ain[m]); \n  end \n  endgenerate \n  assign a[15] = (left)?((rotate)?(ain[15]):(1'b0)):(ain[15]); \n  assign s = (sra)?(a[15]):(1'b0); \n  genvar c, d, e, f, g, h, i, j; \n  generate \n  for (d=0; d < 8; d=d+1) begin : ROTATE_B3 \n  assign rb3[d] = (rotate)?(a[d]):(s); \n  end \n  endgenerate \n  generate \n  for (c=0; c < 16; c=c+1) begin : B3 \n  if(c < 8) \n  assign b3[c] = (b[3])?(a[c+8]):(a[c]); \n  else \n  assign b3[c] = (b[3])?(rb3[c-8]):(a[c]); \n  end \n  endgenerate \n  generate \n  for (e=0; e < 4; e=e+1) begin : ROTATE_B2 \n  assign rb2[e] = (rotate)?(b3[e]):(s); \n  end \n  endgenerate \n  generate \n  for (f=0; f < 16; f=f+1) begin : B2 \n  if(f < 12) \n  assign b2[f] = (b[2])?(b3[f+4]):(b3[f]); \n  else \n  assign b2[f] = (b[2])?(rb2[f-12]):(b3[f]); \n  end \n  endgenerate \n  generate \n  for (g=0; g < 2; g=g+1) begin : ROTATE_B1 \n  assign rb1[g] = (rotate)?(b2[g]):(s); \n  end \n  endgenerate \n  generate \n  for (h=0; h < 16; h=h+1) begin : B1 \n  if(h < 14) \n  assign b1[h] = (b[1])?(b2[h+2]):(b2[h]); \n  else \n  assign b1[h] = (b[1])?(rb1[h-14]):(b2[h]); \n  end \n  endgenerate \n  assign rb0 = (rotate)?(b1[0]):(s); \n  generate \n  for (j=0; j < 16; j=j+1) begin : B0 \n  if(j < 15) \n  assign y[j] = (b[0])?(b1[j+1]):(b1[j]); \n  else \n  assign y[j] = (b[0])?(rb0):(b1[j]); \n  end \n  endgenerate \n  genvar n; \n  generate \n  for (n=0; n < 16; n=n+1) begin : REVERSE_OUTPUT \n  assign yout[n] = (left)?(y[15-n]):(y[n]); \n  end \n  endgenerate \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an implementation of a register file (RF) controller. It has inputs for reset, data in (DIN), load, and outputs the data out (DOUT). The RF_DEPTH parameter sets the number of registers in the file, and LC_RF_DATA_WIDTH sets the width of the data in each register. Inside the module, there is an array of registers 'rf_array' and a loop to assign and pack the output data. The module also contains another loop to handle the write operation for each register in a synchronous manner. The reset signal is used to reset all registers to 0, and the data in (DIN) is assigned to the corresponding register when the load signal is asserted.\n\n Module header:\n\nmodule rf_ctrl( RESETn, DIN, LOAD, DOUT);\n [/INST]\n", "output": "parameter RF_DEPTH = 64; \n parameter LC_RF_DATA_WIDTH =24; \n input RESETn; \n input [LC_RF_DATA_WIDTH-1:0] DIN; \n input [RF_DEPTH-1:0] LOAD; \n output [LC_RF_DATA_WIDTH*RF_DEPTH-1:0] DOUT; \n reg [LC_RF_DATA_WIDTH-1:0] rf_array [0:RF_DEPTH-1]; \n genvar idx; \n generate \n  for (idx=0; idx<(RF_DEPTH); idx=idx+1) \n  begin: PACK \n  assign DOUT[LC_RF_DATA_WIDTH*(idx+1)-1:LC_RF_DATA_WIDTH*idx] = rf_array[idx]; \n  end \n  for (idx=0; idx<RF_DEPTH; idx = idx+1) \n  begin: RF_WRITE \n  always @ (posedge LOAD[idx] or negedge RESETn) \n  begin \n  if (~RESETn) \n  rf_array[idx] <= 0; \n  else \n  rf_array[idx] <= DIN; \n  end \n  end \n endgenerate \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a command control logic with a state machine. It processes input signals such as new_command, cmd_argument, cmd_index, ack_in, strobe_in, cmd_in, clk_host, and reset_host to generate output signals including response, cmd_complete, cmd_index_error, strobe_out, ack_out, idle_out, and cmd_out. The state machine transitions through the states RESET, IDLE, SETTING_OUTPUTS, and PROCESSING based on the input conditions. The module initializes the response and control signals in the RESET state, and then proceeds to the IDLE state to wait for a new command. Upon receiving a new command, it enters the SETTING_OUTPUTS state to prepare the command output and transitions to the PROCESSING state to process the command and generate the response. Finally, it goes back to the IDLE state to wait for the next command.\n\n Module header:\n\nmodule cmd_control (clk_host,reset_host, new_command, cmd_argument, cmd_index, ack_in, strobe_in, cmd_in, response, cmd_complete, cmd_index_error, strobe_out, ack_out, idle_out, cmd_out);\n [/INST]\n", "output": "input wire clk_host; \n  input wire reset_host; \n  input wire new_command; \n  input wire [31:0]cmd_argument; \n  input wire [5:0]cmd_index; \n  input wire ack_in; \n  input wire strobe_in; \n  input wire [135:0]cmd_in; \n  output reg [127:0]response; \n  output reg cmd_complete; \n  output reg cmd_index_error; \n  output reg strobe_out; \n  output reg ack_out; \n  output reg idle_out; \n  output reg [39:0]cmd_out; \n  parameter RESET = 0; \n  parameter IDLE = 1; \n  parameter SETTING_OUTPUTS = 2; \n  parameter PROCESSING = 3; \n  reg [1:0]estado = 0; \n  always @ ( * ) begin \n  case (estado) \n  RESET: begin \n  response = 0; \n  cmd_complete = 0; \n  cmd_index_error = 0; \n  strobe_out = 0; \n  ack_out = 0; \n  idle_out = 0; \n  cmd_out = 0; \n  estado = IDLE; \n  end \n  IDLE: begin \n  if (reset_host == 1) begin \n  estado = RESET; \n  end else begin \n  if (new_command == 1) begin \n  estado = SETTING_OUTPUTS; \n  end else begin \n  idle_out = 1; \n  estado = IDLE; \n  end \n  end \n  end \n  SETTING_OUTPUTS: begin \n  if (reset_host == 1) begin \n  estado = RESET; \n  end else begin \n  strobe_out = 1; \n  cmd_out [39] = 0; \n  cmd_out [38] = 1; \n  cmd_out [37:32] = cmd_index; \n  cmd_out [31:0] = cmd_argument; \n  estado = PROCESSING; \n  end \n  end \n  PROCESSING: begin \n  if (reset_host == 1) begin \n  estado = RESET; \n  end else begin \n  if (strobe_in == 1) begin \n  cmd_complete = 1; \n  ack_out = 1; \n  if ((cmd_out[0] != 1) || (cmd_in[134] != 0)) begin \n  cmd_index_error = 1; \n  end else begin \n  cmd_index_error = 0; \n  end \n  response = cmd_in[135:8]; \n  if (ack_in == 1) begin \n  estado = IDLE; \n  end else begin \n  estado = PROCESSING; \n  end \n  end else begin \n  estado = PROCESSING; \n  end \n  end \n  end \n  default: begin \n  estado = IDLE; \n  end \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a RAM (Random Access Memory) with a data width of 32 bits and an address width of 10 bits. The memory size is set to 1024. It has inputs for address, chip enable (ce0), data input (d0), write enable (we0), and a clock signal. The module includes a register to store the output. The RAM is initialized as a block RAM. The module performs read and write operations based on the chip enable and write enable signals, and updates the output accordingly. The RAM array is accessed using the address input, and the data is stored or retrieved based on the write enable signal.\n\n Module header:\n\nmodule HLS_accel_b_ram (addr0, ce0, d0, we0, q0, clk);\n [/INST]\n", "output": "parameter DWIDTH = 32; \n parameter AWIDTH = 10; \n parameter MEM_SIZE = 1024; \n input[AWIDTH-1:0] addr0; \n input ce0; \n input[DWIDTH-1:0] d0; \n input we0; \n output reg[DWIDTH-1:0] q0; \n input clk; \n (* ram_style = \"block\" *)reg [DWIDTH-1:0] ram[MEM_SIZE-1:0]; \n always @(posedge clk) \n begin \n  if (ce0) \n  begin \n  if (we0) \n  begin \n  ram[addr0] <= d0; \n  q0 <= d0; \n  end \n  else \n  q0 <= ram[addr0]; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a D flip-flop with asynchronous preset functionality. The output Q is initialized to 1, and it is updated on the rising edge of the clock signal when the preset input is not asserted. When the preset input is asserted, Q is set to 1. When the clock enable input is asserted, Q is updated with the value of the input D.\n\n Module header:\n\nmodule myDFFPE (output reg Q, input D, CLK, CE, PRESET);\n [/INST]\n", "output": "parameter [0:0] INIT = 1'b1; \n  initial Q = INIT; \n  always @(posedge CLK or posedge PRESET) begin \n  if(PRESET) \n  Q <= 1'b1; \n  else if (CE) \n  Q <= D; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `omsp_clock_mux` is a clock multiplexer that selects one of two input clock signals `clk_in0` and `clk_in1` based on control signals `select_in` and `scan_mode`. It also incorporates a reset functionality. The selected clock output `clk_out` is generated based on the selected input clock and the scan mode. The module also handles the inversion and gating of the input clock signals.\n\n Module header:\n\nmodule omsp_clock_mux (clk_out,clk_in0,clk_in1,reset,scan_mode,select_in);\n [/INST]\n", "output": "output clk_out; \n input clk_in0; \n input clk_in1; \n input reset; \n input scan_mode; \n input select_in; \n wire in0_select; \n reg in0_select_s; \n reg in0_select_ss; \n wire in0_enable; \n wire in1_select; \n reg in1_select_s; \n reg in1_select_ss; \n wire in1_enable; \n wire clk_in0_inv; \n wire clk_in1_inv; \n wire clk_in0_scan_fix_inv; \n wire clk_in1_scan_fix_inv; \n wire gated_clk_in0; \n wire gated_clk_in1; \n `ifdef SCAN_REPAIR_INV_CLOCKS \n  omsp_scan_mux scan_mux_repair_clk_in0_inv (.scan_mode(scan_mode), .data_in_scan(clk_in0), .data_in_func(~clk_in0), .data_out(clk_in0_scan_fix_inv)); \n  omsp_scan_mux scan_mux_repair_clk_in1_inv (.scan_mode(scan_mode), .data_in_scan(clk_in1), .data_in_func(~clk_in1), .data_out(clk_in1_scan_fix_inv)); \n `else \n  assign clk_in0_scan_fix_inv = ~clk_in0; \n  assign clk_in1_scan_fix_inv = ~clk_in1; \n `endif \n assign in0_select = ~select_in & ~in1_select_ss; \n always @ (posedge clk_in0_scan_fix_inv or posedge reset) \n  if (reset) in0_select_s <= 1'b1; \n  else in0_select_s <= in0_select; \n always @ (posedge clk_in0 or posedge reset) \n  if (reset) in0_select_ss <= 1'b1; \n  else in0_select_ss <= in0_select_s; \n assign in0_enable = in0_select_ss | scan_mode; \n assign in1_select = select_in & ~in0_select_ss; \n always @ (posedge clk_in1_scan_fix_inv or posedge reset) \n  if (reset) in1_select_s <= 1'b0; \n  else in1_select_s <= in1_select; \n always @ (posedge clk_in1 or posedge reset) \n  if (reset) in1_select_ss <= 1'b0; \n  else in1_select_ss <= in1_select_s; \n assign in1_enable = in1_select_ss & ~scan_mode; \n assign clk_in0_inv = ~clk_in0; \n assign clk_in1_inv = ~clk_in1; \n assign gated_clk_in0 = ~(clk_in0_inv & in0_enable); \n assign gated_clk_in1 = ~(clk_in1_inv & in1_enable); \n assign clk_out = (gated_clk_in0 & gated_clk_in1); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module named \"WF\" takes inputs i_op, i_wf_in, and i_wk, and produces an output o_wf_out. The output is derived from the input data based on specific operations. The input i_wf_in is split into different parts, and some parts are combined with i_wk using addition or subtraction, based on the value of i_op. Additionally, certain parts of i_wf_in and i_wk are subject to bitwise XOR operations. The resulting parts are then concatenated to form the output o_wf_out.\n\n Module header:\n\nmodule WF(i_op ,i_wf_in ,i_wk ,o_wf_out);\n [/INST]\n", "output": "input i_op ; \n input[63:0] i_wf_in ; \n input[31:0] i_wk ; \n output[63:0] o_wf_out ; \n wire[63:0] w_wf_out ; \n wire[7:0] w_wf_out7 ; \n wire[7:0] w_wf_out6 ; \n wire[7:0] w_wf_out5 ; \n wire[7:0] w_wf_out4 ; \n wire[7:0] w_wf_out3 ; \n wire[7:0] w_wf_out2 ; \n wire[7:0] w_wf_out1 ; \n wire[7:0] w_wf_out0 ; \n assign w_wf_out7 = i_wf_in[63:56]; \n assign w_wf_out6 = i_wf_in[55:48] ^ i_wk[31:24]; \n assign w_wf_out5 = i_wf_in[47:40]; \n assign w_wf_out4 = (i_op == 0) ? (i_wf_in[39:32] + i_wk[23:16]) : \n  (i_wf_in[39:32] - i_wk[23:16]) ; \n assign w_wf_out3 = i_wf_in[31:24]; \n assign w_wf_out2 = i_wf_in[23:16] ^ i_wk[15:8]; \n assign w_wf_out1 = i_wf_in[15:8]; \n assign w_wf_out0 = (i_op == 0) ? (i_wf_in[7:0] + i_wk[7:0]) : \n  (i_wf_in[7:0] - i_wk[7:0]) ; \n assign w_wf_out = {w_wf_out7, w_wf_out6, w_wf_out5, w_wf_out4, w_wf_out3, w_wf_out2, w_wf_out1, w_wf_out0}; \n assign o_wf_out = w_wf_out; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a tri-state ROM that takes in control signals cs_ and oe_, as well as data_in, and outputs data_out. The output data_out is driven by data_in when both cs_ and oe_ are low, and is high-impedance (z) otherwise.\n\n Module header:\n\nmodule rom_tristate(cs_, oe_, data_in, data_out);\n [/INST]\n", "output": "input cs_; \n  input oe_; \n  input [7:0] data_in; \n  output [7:0] data_out; \n assign data_out = (~cs_ & ~oe_) ? data_in : 8'bzzzzzzzz; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a signal breakout module that takes input data and breaks it out into various output signals based on the specific bits of the input data. It includes functionality to handle different data widths and generates the appropriate output signals accordingly. The module also has logic to assign values to the output signals based on the input data. The module supports features such as address generation, length extraction, IRQ mask assignment, burst count handling, stride generation, sequence number assignment, and handling of stop and reset signals.\n\n Module header:\n\nmodule write_signal_breakout (write_command_data_in,write_command_data_out,write_address,write_length,write_park,write_end_on_eop,write_transfer_complete_IRQ_mask,write_early_termination_IRQ_mask,write_error_IRQ_mask,write_burst_count,write_stride,write_sequence_number,write_stop,write_sw_reset);\n [/INST]\n", "output": "parameter DATA_WIDTH = 256; \n  input [DATA_WIDTH-1:0] write_command_data_in; \n  output wire [255:0] write_command_data_out; \n  output wire [63:0] write_address; \n  output wire [31:0] write_length; \n  output wire write_park; \n  output wire write_end_on_eop; \n  output wire write_transfer_complete_IRQ_mask; \n  output wire write_early_termination_IRQ_mask; \n  output wire [7:0] write_error_IRQ_mask; \n  output wire [7:0] write_burst_count; \n  output wire [15:0] write_stride; \n  output wire [15:0] write_sequence_number; \n  input write_stop; \n  input write_sw_reset; \n  assign write_address[31:0] = write_command_data_in[63:32]; \n  assign write_length = write_command_data_in[95:64]; \n  generate \n  if (DATA_WIDTH == 256) \n  begin \n  assign write_park = write_command_data_in[235]; \n  assign write_end_on_eop = write_command_data_in[236]; \n  assign write_transfer_complete_IRQ_mask = write_command_data_in[238]; \n  assign write_early_termination_IRQ_mask = write_command_data_in[239]; \n  assign write_error_IRQ_mask = write_command_data_in[247:240]; \n  assign write_burst_count = write_command_data_in[127:120]; \n  assign write_stride = write_command_data_in[159:144]; \n  assign write_sequence_number = write_command_data_in[111:96]; \n  assign write_address[63:32] = write_command_data_in[223:192]; \n  end \n  else \n  begin \n  assign write_park = write_command_data_in[107]; \n  assign write_end_on_eop = write_command_data_in[108]; \n  assign write_transfer_complete_IRQ_mask = write_command_data_in[110]; \n  assign write_early_termination_IRQ_mask = write_command_data_in[111]; \n  assign write_error_IRQ_mask = write_command_data_in[119:112]; \n  assign write_burst_count = 8'h00; \n  assign write_stride = 16'h0000; \n  assign write_sequence_number = 16'h0000; \n  assign write_address[63:32] = 32'h00000000; \n  end \n  endgenerate \n  assign write_command_data_out = {{132{1'b0}}, \n  write_address[63:32], \n  write_stride, \n  write_burst_count, \n  write_sw_reset, \n  write_stop, \n  1'b0, \n  write_end_on_eop, \n  write_length, \n  write_address[31:0]}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a VGA controller with input vclock and outputs hcount, vcount, vsync, hsync, and blank. It includes parameters for horizontal and vertical timing, and signals for horizontal and vertical synchronization. The module updates the horizontal and vertical counts, and the synchronization and blank signals based on the input clock and timing parameters. The module generates the necessary signals for driving a VGA display based on the input clock and timing parameters.\n\n Module header:\n\nmodule vga(input vclock,output reg [9:0] hcount,output reg [9:0] vcount,output reg vsync,hsync,blank);\n [/INST]\n", "output": "parameter VGA_HBLANKON = 10'd639; \n parameter VGA_HSYNCON = 10'd655; \n parameter VGA_HSYNCOFF = 10'd751; \n parameter VGA_HRESET = 10'd799; \n parameter VGA_VBLANKON = 10'd479; \n parameter VGA_VSYNCON = 10'd490; \n parameter VGA_VSYNCOFF = 10'd492; \n parameter VGA_VRESET = 10'd523; \n reg hblank,vblank; \n wire hsyncon,hsyncoff,hreset,hblankon; \n assign hblankon = (hcount == VGA_HBLANKON); \n assign hsyncon = (hcount == VGA_HSYNCON); \n assign hsyncoff = (hcount == VGA_HSYNCOFF); \n assign hreset = (hcount == VGA_HRESET); \n wire vsyncon,vsyncoff,vreset,vblankon; \n assign vblankon = hreset & (vcount == VGA_VBLANKON); \n assign vsyncon = hreset & (vcount == VGA_VSYNCON); \n assign vsyncoff = hreset & (vcount == VGA_VSYNCOFF); \n assign vreset = hreset & (vcount == VGA_VRESET); \n wire next_hblank,next_vblank; \n assign next_hblank = hreset ? 0 : hblankon ? 1 : hblank; \n assign next_vblank = vreset ? 0 : vblankon ? 1 : vblank; \n always @(posedge vclock) begin \n  hcount <= hreset ? 0 : hcount + 1; \n  hblank <= next_hblank; \n  hsync <= hsyncon ? 0 : hsyncoff ? 1 : hsync; \n  vcount <= hreset ? (vreset ? 0 : vcount + 1) : vcount; \n  vblank <= next_vblank; \n  vsync <= vsyncon ? 0 : vsyncoff ? 1 : vsync; \n  blank <= next_vblank | (next_hblank & ~hreset); \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is designed for YUV422 to YUV444 conversion. It takes in YUV422 data and outputs YUV444 data. The module includes registers for every_other, mY, mCb, mCr, and mValid. It operates based on the input clock signal (iCLK) and the active-low asynchronous reset signal (iRST_N). \n\nDuring operation, it utilizes the every_other register to alternate between processing Y and Cr, and Y and Cb components of the input YUV422 data, and stores the processed values in mY, mCb, and mCr registers. The mValid register is used to indicate the validity of the output data. \n\nThe module has an asynchronous reset which initializes all registers to 0 when iRST_N is inactive. When iRST_N is active, it updates the registers based on the every_other signal and the input YUV422 data. The outputs oY, oCb, oCr, and oYCbCr_valid are driven from the mY, mCb, mCr, and mValid registers respectively.\n\n Module header:\n\nmodule yuv422_to_yuv444 (input wire iCLK,input wire iRST_N,input wire [15:0] iYCbCr,input wire iYCbCr_valid,output wire [7:0] oY,output wire [7:0] oCb,output wire [7:0] oCr,output wire oYCbCr_valid);\n [/INST]\n", "output": "reg every_other; \n reg [7:0] mY; \n reg [7:0] mCb; \n reg [7:0] mCr; \n reg mValid; \n assign oY = mY; \n assign oCb = mCb; \n assign oCr = mCr; \n assign oYCbCr_valid = mValid; \n always@(posedge iCLK or negedge iRST_N) \n begin \n  if(!iRST_N) \n  begin \n  every_other <= 0; \n  mY <= 0; \n  mCb <= 0; \n  mCr <= 0; \n  mValid <= 0; \n  end \n  else \n  begin \n  every_other <= ~every_other; \n  mValid <= iYCbCr_valid; \n  if(every_other) \n  {mY,mCr} <= iYCbCr; \n  else \n  {mY,mCb} <= iYCbCr; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a 32-to-1 multiplexer with a configurable bit width. The module selects one of the 32 input signals (coeff00 to coeff31) based on the 5-bit select signal SEL and assigns the selected input to the output signal outMUX. This allows for the flexible routing of input signals to the output based on the value of SEL.\n\n Module header:\n\nmodule multiplexor32a1 #(parameter Width = 3) (coeff00,coeff01,coeff02,coeff03,coeff04,coeff05,coeff06,coeff07,coeff08,coeff09,coeff10,coeff11,coeff12,coeff13,coeff14,coeff15,coeff16,coeff17,coeff18,coeff19,coeff20,coeff21,coeff22,coeff23,coeff24,coeff25,coeff26,coeff27,coeff28,coeff29,coeff30,coeff31,SEL,outMUX);\n [/INST]\n", "output": "input [4:0] SEL; \n  input signed [Width-1:0] coeff00,coeff01,coeff02,coeff03,coeff04,coeff05,coeff06,coeff07,coeff08,coeff09, \n  coeff10,coeff11,coeff12,coeff13,coeff14,coeff15,coeff16,coeff17,coeff18,coeff19, \n  coeff20,coeff21,coeff22,coeff23,coeff24,coeff25,coeff26,coeff27,coeff28,coeff29, \n  coeff30,coeff31; \n  output reg signed [Width-1:0] outMUX; \n  always @*begin \n  case (SEL) \n  5'd00: outMUX <= coeff00; \n  5'd01: outMUX <= coeff01; \n  5'd02: outMUX <= coeff02; \n  5'd03: outMUX <= coeff03; \n  5'd04: outMUX <= coeff04; \n  5'd05: outMUX <= coeff05; \n  5'd06: outMUX <= coeff06; \n  5'd07: outMUX <= coeff07; \n  5'd08: outMUX <= coeff08; \n  5'd09: outMUX <= coeff09; \n  5'd10: outMUX <= coeff10; \n  5'd11: outMUX <= coeff11; \n  5'd12: outMUX <= coeff12; \n  5'd13: outMUX <= coeff13; \n  5'd14: outMUX <= coeff14; \n  5'd15: outMUX <= coeff15; \n  5'd16: outMUX <= coeff16; \n  5'd17: outMUX <= coeff17; \n  5'd18: outMUX <= coeff18; \n  5'd19: outMUX <= coeff19; \n  5'd20: outMUX <= coeff20; \n  5'd21: outMUX <= coeff21; \n  5'd22: outMUX <= coeff22; \n  5'd23: outMUX <= coeff23; \n  5'd24: outMUX <= coeff24; \n  5'd25: outMUX <= coeff25; \n  5'd26: outMUX <= coeff26; \n  5'd27: outMUX <= coeff27; \n  5'd28: outMUX <= coeff28; \n  5'd29: outMUX <= coeff29; \n  5'd30: outMUX <= coeff30; \n  5'd31: outMUX <= coeff31; \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a termination logic for a specific application. It handles various inputs related to scan chain, termination control, and user interactions. It includes internal state registers and logic to control the termination process based on user signals and internal clock enable. The module also has flags for termination done, termination clock output, and termination select output, which are assigned based on the internal state of the module. Overall, it provides the necessary functionality to manage the termination process within the larger system.\n\n Module header:\n\nmodule arriaii_termination(rdn,rup,scanclock,scanin,scaninmux,scanshiftmux,terminationuserclear,terminationuserclock,comparatorprobe,scanout,terminationclockout,terminationcontrolprobe,terminationdataout,terminationdone,terminationselectout);\n [/INST]\n", "output": "input rdn; \n input rup; \n input scanclock; \n input scanin; \n input scaninmux; \n input scanshiftmux; \n input terminationuserclear; \n input terminationuserclock; \n output comparatorprobe; \n output scanout; \n output terminationclockout; \n output terminationcontrolprobe; \n output terminationdataout; \n output terminationdone; \n output terminationselectout; \n parameter lpm_type = \"arriaii_termination\"; \n parameter runtime_control = \"false\"; \n integer cal_shift_cycles; \n reg reset_oct_reg; \n reg terminationdone_tmp; \n reg internal_enable_read; \n reg internal_clk_enable; \n reg terminationclockout_tmp; \n reg terminationselectout_tmp ; \n reg terminationuserclear_prev; \n initial \n begin \n  terminationclockout_tmp = 1'b0; \n  terminationselectout_tmp = 1'b0; \n  terminationdone_tmp = 1'b0; \n  cal_shift_cycles = 0; \n end \n always @(terminationuserclock or terminationuserclear) \n begin \n  if(terminationuserclear == 1'b1 && terminationuserclear_prev == 1'b0) \n  begin \n  reset_oct_reg = 1'b1; \n  terminationdone_tmp = 1'b1; \n  cal_shift_cycles = 0; \n  terminationselectout_tmp = 1'b0; \n  terminationclockout_tmp = 1'b0; \n  end \n  if(terminationuserclear == 1'b0 && reset_oct_reg == 1'b1) \n  begin \n  reset_oct_reg = 1'b0; \n  internal_enable_read = 1'b1; \n  end \n  if(internal_enable_read == 1'b1 && terminationuserclock == 1'b0) \n  begin \n  internal_clk_enable = 1'b1; \n  internal_enable_read = 1'b0; \n  end \n  if(terminationselectout_tmp == 1'b1) \n  terminationclockout_tmp = terminationuserclock; \n  if(internal_clk_enable == 1'b1 && terminationuserclock == 1'b1) \n  begin \n  if(cal_shift_cycles == 27) \n  terminationdone_tmp = 1'b0; \n  else \n  begin \n  if(cal_shift_cycles == 10) \n  terminationselectout_tmp = 1'b1; \n  cal_shift_cycles = cal_shift_cycles +1; \n  end \n  end \n  if(cal_shift_cycles == 27 && terminationuserclock == 1'b0) \n  terminationselectout_tmp = 1'b0; \n  if(terminationdone_tmp == 1'b0) \n  begin \n  cal_shift_cycles = 0; \n  internal_clk_enable = 1'b0; \n  end \n  terminationuserclear_prev = terminationuserclear; \n end \n assign terminationdone = terminationdone_tmp; \n assign terminationclockout = terminationclockout_tmp; \n assign terminationselectout = terminationselectout_tmp; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module generates four outputs based on the inputs `shiftnld`, `captnupdt`, and `clk`. It uses a case statement to control the behavior of the outputs. The `mainclk`, `updateclk`, `capture`, and `update` outputs are driven by temporary registers `mainclk_tmp`, `updateclk_tmp`, `capture_tmp`, and `update_tmp` respectively. The logic within the case statement sets these temporary registers based on the input conditions. The `mainclk` output is set to 1 when `mainclk_tmp` is true, and similarly for the other outputs. This module essentially performs control logic based on the input conditions to generate the required outputs.\n\n Module header:\n\nmodule stratixv_bias_logic (clk,shiftnld,captnupdt,mainclk,updateclk,capture,update);\n [/INST]\n", "output": "input clk; \n input shiftnld; \n input captnupdt; \n output mainclk; \n output updateclk; \n output capture; \n output update; \n reg mainclk_tmp; \n reg updateclk_tmp; \n reg capture_tmp; \n reg update_tmp; \n initial \n begin \n  mainclk_tmp <= 'b0; \n  updateclk_tmp <= 'b0; \n  capture_tmp <= 'b0; \n  update_tmp <= 'b0; \n end \n  always @(captnupdt or shiftnld or clk) \n  begin \n  case ({captnupdt, shiftnld}) \n  2'b10, 2'b11 : \n  begin \n  mainclk_tmp <= 'b0; \n  updateclk_tmp <= clk; \n  capture_tmp <= 'b1; \n  update_tmp <= 'b0; \n  end \n  2'b01 : \n  begin \n  mainclk_tmp <= 'b0; \n  updateclk_tmp <= clk; \n  capture_tmp <= 'b0; \n  update_tmp <= 'b0; \n  end \n  2'b00 : \n  begin \n  mainclk_tmp <= clk; \n  updateclk_tmp <= 'b0; \n  capture_tmp <= 'b0; \n  update_tmp <= 'b1; \n  end \n  default : \n  begin \n  mainclk_tmp <= 'b0; \n  updateclk_tmp <= 'b0; \n  capture_tmp <= 'b0; \n  update_tmp <= 'b0; \n  end \n  endcase \n  end \n and (mainclk, mainclk_tmp, 1'b1); \n and (updateclk, updateclk_tmp, 1'b1); \n and (capture, capture_tmp, 1'b1); \n and (update, update_tmp, 1'b1); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, named s1, takes a 32-bit input x and produces a 32-bit output y. It performs two bitwise XOR operations to generate the output. The first XOR operation involves bits 16 to 7 of x and bits 18 to 9 of x, and stores the result in bits 31 to 22 of y. The second XOR operation involves concatenations and individual bits of x, and stores the result in bits 21 to 0 of y.\n\n Module header:\n\nmodule s1 (x, y);\n [/INST]\n", "output": "input [31:0] x; \n  output [31:0] y; \n  assign y[31:22] = x[16:7] ^ x[18:9]; \n  assign y[21:0] = {x[6:0],x[31:17]} ^ {x[8:0],x[31:19]} ^ x[31:10]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a basic vending machine that takes input from a keypad and operates in different modes. It initializes the credit and coins values and then processes inputs based on the mode selected. The module updates the credit based on the keypad input, and based on the credit value, it sets the output coins. The vending machine also has a reset functionality that sets the credit and coins to initial values.\n\n Module header:\n\nmodule BasicVendingMachine(input [2:0] KeyPad,input [1:0] Mode,input CLK,input RESET,output reg [7:0] Credit,output reg [5:0] Coins);\n [/INST]\n", "output": "initial begin \n  Credit = 8'd0; \n  Coins = 6'b000000; \n  end \n  always @(posedge CLK or posedge RESET) \n  begin \n  if (RESET) \n  begin \n  Credit = 8'd0; \n  Coins = 6'b000000; \n  end \n  else \n  begin \n  case (Mode) \n  2'b00: ; \n  2'b01: \n  begin \n  case (KeyPad) \n  3'b000: if ((Credit + 1) <= 255) \n  Credit = Credit+1; \n  3'b001: if((Credit + 2) <= 255) \n  Credit = Credit+2; \n  3'b010: if((Credit+5) <= 255) \n  Credit = Credit+5; \n  3'b011: if((Credit + 10) <= 255) \n  Credit = Credit+10; \n  3'b100: if((Credit + 20) <= 255) \n  Credit = Credit+20; \n  3'b101: if((Credit + 50) <= 255) \n  Credit = Credit+50; \n  3'b110: if((Credit + 100) <= 255) \n  Credit = Credit+100; \n  3'b111: if((Credit + 200) <= 255) \n  Credit = Credit+200; \n  endcase \n  end \n  2'b10: \n  begin \n  case (KeyPad) \n  3'b000: if (Credit >= 220) \n  Credit = Credit-220; \n  3'b001: if(Credit >= 120) \n  Credit = Credit-120; \n  3'b010: if(Credit >= 180) \n  Credit = Credit-180; \n  3'b011: if(Credit >= 55) \n  Credit = Credit-55; \n  3'b100: if(Credit >= 13) \n  Credit = Credit-13; \n  3'b101: if(Credit >= 25) \n  Credit = Credit-25; \n  3'b110: if(Credit >= 85) \n  Credit = Credit-85; \n  3'b111: if(Credit >= 75) \n  Credit = Credit-75; \n  endcase \n  end \n  2'b11: \n  begin \n  if ( Credit >= 50) \n  begin \n  Credit = Credit - 50; \n  Coins = 6'b100000; \n  end \n  else if ( Credit >= 20) \n  begin \n  Credit = Credit - 20; \n  Coins = 6'b010000; \n  end \n  else if ( Credit >= 10) \n  begin \n  Credit = Credit - 10; \n  Coins = 6'b001000; \n  end \n  else if ( Credit >= 5) \n  begin \n  Credit = Credit - 5; \n  Coins = 6'b000100; \n  end \n  else if ( Credit >= 2) \n  begin \n  Credit = Credit - 2; \n  Coins = 6'b000010; \n  end \n  else if ( Credit >= 1) \n  begin \n  Credit = Credit - 1; \n  Coins = 6'b000001; \n  end \n  else if ( Credit == 0) \n  Coins = 6'b000000; \n  end \n  endcase \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, named GeneratorSigned2, generates signed outputs. It has a single output wire called 'out' which is a 2-bit signed value. The module assigns a constant value of 2 to the output wire.\n\n Module header:\n\nmodule GeneratorSigned2(out);\n [/INST]\n", "output": "output wire signed [1:0] out; \n  assign out = 2; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a DQS enable control logic, which generates an output signal `dqsenableout` based on the input signals `dqsenablein`, `clk`, `devclrn`, and `devpor`. The module includes registers and tri-state buffers to synchronize and control the DQS enable signal. The parameter `delay_dqs_enable_by_half_cycle` is used to determine the delay in generating the output signal. The output signal is derived from `dqsenablein` based on the specified delay configuration and is provided at `dqsenableout`.\n\n Module header:\n\nmodule arriaii_dqs_enable_ctrl(clk,dqsenablein,devclrn,devpor,dqsenableout);\n [/INST]\n", "output": "parameter lpm_type = \"arriaii_dqs_enable_ctrl\"; \n parameter delay_dqs_enable_by_half_cycle = \"false\"; \n input clk; \n input dqsenablein; \n input devclrn; \n input devpor; \n output dqsenableout; \n tri1 devclrn; \n tri1 devpor; \n wire dqsenablein_regp; \n wire dqsenablein_regn; \n wire dqsenableout_tmp; \n dffeas regp (.d(dqsenablein),.clk(clk),.clrn(1'b1),.aload(1'b0),.sclr(1'b0),.sload(1'b0),.asdata(1'b0),.ena(1'b1),.prn(1'b1),.q(dqsenablein_regp),.devpor(devpor),.devclrn(devclrn)); \n dffeas regn (.d(dqsenablein_regp),.clk(!clk),.clrn(1'b1),.aload(1'b0),.sclr(1'b0),.sload(1'b0),.asdata(1'b0),.ena(1'b1),.prn(1'b1),.q(dqsenablein_regn),.devpor(devpor),.devclrn(devclrn)); \n assign dqsenableout_tmp = (delay_dqs_enable_by_half_cycle == \"false\") ? dqsenablein_regp : (dqsenablein_regn & dqsenablein_regp); \n assign dqsenableout = dqsenableout_tmp; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a digital computation for a Discrete Cosine Transform (DCT) multiplication-accumulate operation. It takes inputs for clock signal, enable, data clear, input data, coefficient, and outputs the result. The module performs the DCT MAC operation by multiplying the input data and coefficient, and accumulating the result. It consists of registers, wires for signal extension, and uses a combinational logic to extend the input and coefficient. The result is calculated on the positive edge of the clock based on the enable signal, and the accumulation is based on the data clear signal.\n\n Module header:\n\nmodule dct_mac(clk, ena, dclr, din, coef, result);\n [/INST]\n", "output": "parameter dwidth = 8; \n  parameter cwidth = 16; \n  parameter mwidth = dwidth + cwidth; \n  parameter rwidth = mwidth +3; \n  input clk; \n  input ena; \n  input dclr; \n  input [dwidth-1:0] din; \n  input [cwidth-1:0] coef; \n  output [rwidth-1:0] result; \n  reg [rwidth -1:0] result; \n  wire [mwidth-1:0] idin; \n  wire [mwidth-1:0] icoef; \n  reg [mwidth -1:0] mult_res ; \n  wire [rwidth -1:0] ext_mult_res; \n  assign icoef = { {(mwidth-cwidth){coef[cwidth-1]}}, coef}; \n  assign idin = { {(mwidth-dwidth){din[dwidth-1]}}, din}; \n  always @(posedge clk) \n  if(ena) \n  mult_res <= #1 icoef * idin; \n  assign ext_mult_res = { {3{mult_res[mwidth-1]}}, mult_res}; \n  always @(posedge clk) \n  if(ena) \n  if(dclr) \n  result <= #1 ext_mult_res; \n  else \n  result <= #1 ext_mult_res + result; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a simple buffer with tri-state output, controlled by the OE input. When OE is high, the output Z1 is driven by input A, and when OE is low, the output is in high impedance state.\n\n Module header:\n\nmodule Test1(input OE, input A, inout Z1);\n [/INST]\n", "output": "assign Z1 = (OE) ? A : 1'bz; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a 4-bit binary multiplier. It has an input for starting the multiplication process and a clock input. It also takes two 4-bit inputs for the multiplier and multiplicand addresses. The module produces an 8-bit output for the product, and a \"done\" output signal.\n\nThe module contains a ROM to store the data, as well as various wires and output assignments to control the multiplication process. It includes a binary multiplier control unit and multiple shift registers for processing the multiplier, multiplicand, and product. Additionally, it has a full adder and a down counter.\n\nThe functionality of this module is to carry out the multiplication of the given multiplier and multiplicand, and produce the product as the output. It uses shift registers, adders, and control units to perform the necessary operations for binary multiplication.\n\n Module header:\n\nmodule _4bit_binary_multiplier #(parameter WIDTH = 4) (input start,input clk,input [WIDTH:0] multiplier_address,input [WIDTH:0] multiplicand_address,output [((WIDTH*2)-1):0] p,output done);\n [/INST]\n", "output": "reg [(WIDTH-1):0] ROM [0: (2*(2**WIDTH)-1)]; \n  wire cnt_done, start_process, add, shift, count_up; \n  wire clk_process; \n  wire [(WIDTH-1):0] b, s; \n  wire cout; \n  wire P_IN_out, P_H_shift_out, P_L_shift_out; \n  wire [(WIDTH-1):0] P_H_parallel_out, P_L_parallel_out, MUL_parallel_out; \n  wire [(WIDTH-1):0] multiplier, multiplicand; \n  assign b = MUL_parallel_out & {(WIDTH){P_L_parallel_out[0]}}; \n  assign p = {P_H_parallel_out, P_L_parallel_out}; \n  assign #7 clk_process = clk; \n  assign multiplier = ROM[multiplier_address]; \n  assign multiplicand = ROM[multiplicand_address]; \n  initial begin \n  $readmemb(\"/home/sabertazimi/gitrepo/hust-lab/verilog/lab5/ASM_4bit_binary_multiplier/ASM_4bit_binary_multiplier.srcs/sources_1/new/_4bit_binary_multiplier.dat\", ROM, 0, 2*(2**WIDTH)-1); \n  end \n  binary_multiplier_control_unit UNIT (start, clk, cnt_done, P_L_parallel_out[0], start_process, add, shift, count_up, done); \n  shift_out_register #(1) P_IN (.start({1'b0, start_process}), .clk(clk_process), .load(~shift), .shift(shift), .D(cout), .shift_in(1'b0), .Q(), .shift_out(P_IN_out)); \n  shift_out_register #(WIDTH) P_H (.start({{(WIDTH){1'b0}},start_process}), .clk(clk_process), .load(add), .shift(shift), .D(s), .shift_in(P_IN_out), .Q(P_H_parallel_out), .shift_out(P_H_shift_out)); \n  shift_out_register #(WIDTH) P_L (.start({multiplier, start_process}), .clk(clk_process), .load(1'b0), .shift(shift), .D(multiplier), .shift_in(P_H_shift_out), .Q(P_L_parallel_out), .shift_out(P_L_shift_out)); \n  parallel_out_register #(WIDTH) MUL (.start({multiplicand, start_process}), .clk(clk_process), .load(1'b0), .D(multiplicand), .Q(MUL_parallel_out)); \n  full_adder #(WIDTH) ADDER (.start(start_process), .add(add), .a(P_H_parallel_out), .b(b), .s(s), .cout(cout)); \n  down_counter #(WIDTH) COUNTER (.start(start), .clk(count_up), .cnt_done(cnt_done)); \n  endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module simulates a washing machine testbench. It generates clock signals and controls various button inputs such as power, pause, mode, and stage. The module includes LEDs for power, pause, wash, stage, time, and warning indicators. The initial block sets the initial values for the clock and button inputs, and then sequences through various button presses at different intervals. The testbench is instantiated with the washing machine module and the clock signal is driven to simulate button presses and LED changes over time.\n\n Module header:\n\nmodule washing_machine_test;\n [/INST]\n", "output": "reg clk; \n  reg power_button; \n  reg pause_button; \n  reg mode_button; \n  reg stage_button; \n  wire power_led; \n  wire pause_led; \n  wire [2:0] wash_led; \n  wire [3:0] stage_led; \n  wire [4:0] time_led; \n  wire warning_led; \n  parameter PERIOD = 10; \n washing_machine uut (.clk(clk),.power_button(power_button),.pause_button(pause_button),.mode_button(mode_button),.stage_button(stage_button),.power_led(power_led),.pause_led(pause_led),.wash_led(wash_led),.stage_led(stage_led),.time_led(time_led),.warning_led(warning_led)); \n  always begin \n  clk = 1; \n  #(PERIOD/2); \n  clk = 0; \n  #(PERIOD/2); \n  end \n  initial begin \n  clk = 0; \n  power_button = 0; \n  pause_button = 0; \n  mode_button = 0; \n  stage_button = 0; \n  #20; \n  power_button = 1; \n  #3; \n  power_button = 0; \n  #10; \n  pause_button = 1; \n  #3; \n  pause_button = 0; \n  #40; \n  pause_button = 1; \n  #3; \n  pause_button = 0; \n  #30; \n  pause_button = 1; \n  #3; \n  pause_button = 0; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module 'clock_n210' implements a DCM_SP (Digital Clock Manager - Spartan) and several additional logic elements to control clock signals. The DCM_SP module manipulates the input clock signal 'clkIn' and generates output clock signals 'clk0_buf' and 'clkdv_buf'. The 'locked' output represents the locked status of the DCM_SP module. The 'locked' signal is latched by the 'lock_flop' module. The signals 'unlock1', 'unlock2', and 'unlock3' are generated based on 'locked' and clock edge conditions. These signals are then combined to produce 'unlockRst'. The 'forceReset' signal is used to control the reset operation.\n\nThe 'clk0_rstn' and 'clkdv_rstn' outputs are generated by using the 'FDR' modules to synchronize and control the reset signals. Finally, the 'rstIn' input is synchronized and stored as 'rstInD'. The 'rstInD' and 'unlockRst' signals are combined to produce the 'rstDCM' signal using the 'rst_or' module.\n\n Module header:\n\nmodule clock_n210 (input clkIn,input rstIn,output locked,output clk0_buf,output clkdv_buf,output clk0_rstn,output clkdv_rstn);\n [/INST]\n", "output": "wire [7:0] dcmStatus; \n  wire unlock1, unlock2, unlock3, unlockRst, locked_d, rstInD, forceReset; \n  assign forceReset = ~rstInD; \n DCM_SP # (.CLK_FEEDBACK (\"1X\"),.CLKDV_DIVIDE (2.0),.CLKFX_DIVIDE (4),.CLKFX_MULTIPLY (5),.CLKIN_DIVIDE_BY_2 (\"FALSE\"),.CLKIN_PERIOD (10.000),.CLKOUT_PHASE_SHIFT (\"NONE\"),.DESKEW_ADJUST (\"SYSTEM_SYNCHRONOUS\"),.DFS_FREQUENCY_MODE (\"LOW\"),.DLL_FREQUENCY_MODE (\"LOW\"),.DUTY_CYCLE_CORRECTION (\"TRUE\"),.FACTORY_JF (16'hC080),.PHASE_SHIFT (0),.STARTUP_WAIT (\"FALSE\")) \n dcm (.CLKFB (clk0_buf),.CLKIN (clkIn),.DSSEN (0),.PSCLK (0),.PSEN (0),.PSINCDEC (0),.RST (rstDCM),.CLKDV (clkdv_unbuf),.CLKFX (),.CLKFX180 (),.CLK0 (clk0_unbuf),.CLK2X (),.CLK2X180 (),.CLK90 (),.CLK180 (),.CLK270 (),.LOCKED (locked),.PSDONE (),.STATUS (dcmStatus)); \n  BUFG clk0_bufg (.I(clk0_unbuf), .O(clk0_buf)); \n  BUFG clkdv_bufg (.I(clkdv_unbuf), .O(clkdv_buf)); \n  FDR clk0_rst (.D(locked), .R(forceReset), .Q(clk0_rstn), .C(clk0_buf) ); \n  FDR clkdv_rst (.D(locked), .R(forceReset), .Q(clkdv_rstn), .C(clkdv_buf) ); \n  FD lock_flop (.C(clkIn), .D(locked), .Q(locked_d)); \n  AND2 edge_cap (.I0(~locked), .I1(locked_d), .O(unlock1)); \n  FD lock_flop2 (.C(clkIn), .D(unlock1), .Q(unlock2)); \n  FD lock_flop3 (.C(clkIn), .D(unlock2), .Q(unlock3)); \n  OR3 lock_or (.I0(unlock1), .I1(unlock2), .I2(unlock3), .O(unlockRst)); \n  FD rst_fd (.C(clkIn), .D(rstIn), .Q(rstInD)); \n  OR2 rst_or (.I0(forceReset), .I1(unlockRst), .O(rstDCM)); \n  endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a simple memory test circuit. It uses a counter to generate memory addresses and checks the memory content at specific addresses. It also checks if the memory content matches the expected value and stops the simulation if it doesn't. The module triggers on both positive and negative clock edges to handle different tasks such as incrementing the counter, setting the address and enable registers, and checking the memory content.\n\n Module header:\n\nmodule FooRd(input i_clk,output o_wen,output [7:0] o_addr,output [7:0] o_wdata,input [7:0] i_rdata);\n [/INST]\n", "output": "reg [7:0] cnt = 0; \n  reg [7:0] addr_r; \n  reg en_r; \n  always @( posedge i_clk ) \n  if ( cnt < 8'd200 ) \n  cnt <= cnt + 8'd1; \n  assign o_wen = 0; \n  assign o_addr = cnt - 8'd100; \n  always @( posedge i_clk ) \n  begin \n  addr_r <= o_addr; \n  en_r <= ( cnt > 8'd110 ) && ( cnt < 8'd130 ) && ( cnt[0] == 1'b0 ); \n  end \n  always @( negedge i_clk ) \n  if ( en_r ) begin \n `ifdef TEST_VERBOSE \n  $display( \"MEM[%x] == %x\", addr_r, i_rdata ); \n `endif \n  if (addr_r != i_rdata) $stop; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module interfaces with the MERA400F module and contains various input and output signals for communication. It initializes parameters and wires for handling communication with the MERA400F module. It also performs assignments for BUZZER_, F_CS_, F_OE_, F_WE_, SRAM_LB_, SRAM_UB_, SRAM_CE_, SRAM_OE_, and SRAM_WE_ based on the derived signals sram_ce, sram_oe, and sram_we. Additionally, it instantiates a display module called DISPLAY.\n\n Module header:\n\nmodule platform(input CLK_EXT,output BUZZER_,input RXD,output TXD,output [7:0] DIG,output [7:0] SEG,output SRAM_CE_, SRAM_OE_, SRAM_WE_, SRAM_UB_, SRAM_LB_,output [17:0] SRAM_A,inout [15:0] SRAM_D,output F_CS_, F_OE_, F_WE_);\n [/INST]\n", "output": "localparam CLK_EXT_HZ = 50_000_000; \n  wire sram_ce, sram_oe, sram_we; \n  wire [0:15] w; \n  wire [10:0] rotary_bus; \n  wire [0:9] indicators; \n mera400f #(.CLK_EXT_HZ(CLK_EXT_HZ)) MERA400F (.clk_ext(CLK_EXT),.rxd(RXD),.txd(TXD),.ram_ce(sram_ce),.ram_oe(sram_oe),.ram_we(sram_we),.ram_a(SRAM_A),.ram_d(SRAM_D),.w(w),.rotary_bus(rotary_bus),.indicators(indicators)); \n  assign BUZZER_ = 1'b1; \n  assign F_CS_ = 1'b1; \n  assign F_OE_ = 1'b1; \n  assign F_WE_ = 1'b1; \n  assign SRAM_LB_ = 1'b0; \n  assign SRAM_UB_ = 1'b0; \n  assign SRAM_CE_ = ~sram_ce; \n  assign SRAM_OE_ = ~sram_oe; \n  assign SRAM_WE_ = ~sram_we; \n display DISPLAY(.clk_sys(CLK_EXT),.w(w),.rotary_bus(rotary_bus),.indicators(indicators),.seg(SEG),.dig(DIG)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes a 4-bit input `cond` and an 8-bit input `ccr` to produce a 1-bit output `condition`. It evaluates the condition based on the input `cond` and the individual bits of `ccr` (C, V, Z, N). The output `condition` is determined by the logic defined for each possible input condition `cond`. The module effectively creates a condition code evaluator for a processor based on the provided inputs.\n\n Module header:\n\nmodule condition(input [3:0] cond,input [7:0] ccr,output condition);\n [/INST]\n", "output": "wire C,V,Z,N; \n assign C = ccr[0]; \n assign V = ccr[1]; \n assign Z = ccr[2]; \n assign N = ccr[3]; \n assign condition = (cond == 4'b0000) ? 1'b1 : \n  (cond == 4'b0001) ? 1'b0 : \n  (cond == 4'b0010) ? ~C & ~Z : \n  (cond == 4'b0011) ? C | Z : \n  (cond == 4'b0100) ? ~C : \n  (cond == 4'b0101) ? C : \n  (cond == 4'b0110) ? ~Z : \n  (cond == 4'b0111) ? Z : \n  (cond == 4'b1000) ? ~V : \n  (cond == 4'b1001) ? V : \n  (cond == 4'b1010) ? ~N : \n  (cond == 4'b1011) ? N : \n  (cond == 4'b1100) ? (N & V) | (~N & ~V) : \n  (cond == 4'b1101) ? (N & ~V) | (~N & V) : \n  (cond == 4'b1110) ? (N & V & ~Z) | (~N & ~V & ~Z) : \n  (cond == 4'b1111) ? (Z) | (N & ~V) | (~N & V) : \n  1'b0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a seven-segment display driver with inputs for clock, reset, GPIO write enable, test selector, and data inputs, and an output for the display data. It uses an always block triggered on the negative edge of the clock or the positive edge of the reset signal. Inside the always block, there is a case statement that selects the output data based on the value of the test selector input. When Test is 0, the display data is updated with disp_cpudata if GPIO write enable is asserted. If Test is 1 through 6, the display data is updated with the corresponding test data input. When Test is 7, the display data is updated with Test_data6. If the reset signal is asserted, the display data is reset to 0.\n\n Module header:\n\nmodule seven_seg_Dev_IO(input wire clk,input wire rst,input wire GPIOe0000000_we,input wire [2:0] Test,input wire [31:0] disp_cpudata,input wire [31:0] Test_data0,input wire [31:0] Test_data1,input wire [31:0] Test_data2,input wire [31:0] Test_data3,input wire [31:0] Test_data4,input wire [31:0] Test_data5,input wire [31:0] Test_data6,output reg [31:0] disp_num);\n [/INST]\n", "output": "always @(negedge clk or posedge rst) begin \n  if (rst) disp_num <= 32'h0000; \n  else begin \n  case (Test) \n  0: begin \n  if(GPIOe0000000_we) disp_num <= disp_cpudata; \n  else disp_num <= disp_num; \n  end \n  1: disp_num <= Test_data0; \n  2: disp_num <= Test_data1; \n  3: disp_num <= Test_data2; \n  4: disp_num <= Test_data3; \n  5: disp_num <= Test_data4; \n  6: disp_num <= Test_data5; \n  7: disp_num <= Test_data6; \n  endcase \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module `memtest02` implements a memory system with two 4x8-bit memories `mem1` and `mem2`. It has inputs `clk`, `setA`, `setB`, `addr`, and `bit`, and outputs `y1`, `y2`, `y3`, and `y4`. When `setA` is asserted, `mem1` is loaded with values 10, 20, and 30, and `mem2` is loaded with values 17, 27, and 37. When `setB` is asserted, `mem1` is loaded with values 1, 2, and 3, and `mem2` is loaded with values 71, 72, and 73. The output values `y1` and `y2` are driven by the memory values based on the input `addr` and `bit`. Finally, `y3` and `y4` are directly assigned the values of `mem1` and `mem2` based on the input `addr` and `bit`.\n\n Module header:\n\nmodule memtest02(clk, setA, setB, addr, bit, y1, y2, y3, y4);\n [/INST]\n", "output": "input clk, setA, setB; \n input [1:0] addr; \n input [2:0] bit; \n output reg y1, y2; \n output y3, y4; \n reg [7:0] mem1 [3:0]; \n (* mem2reg *) \n reg [7:0] mem2 [3:0]; \n always @(posedge clk) begin \n  if (setA) begin \n  mem1[0] <= 10; \n  mem1[1] <= 20; \n  mem1[2] <= 30; \n  mem2[0] <= 17; \n  mem2[1] <= 27; \n  mem2[2] <= 37; \n  end \n  if (setB) begin \n  mem1[0] <= 1; \n  mem1[1] <= 2; \n  mem1[2] <= 3; \n  mem2[0] <= 71; \n  mem2[1] <= 72; \n  mem2[2] <= 73; \n  end \n  y1 <= mem1[addr][bit]; \n  y2 <= mem2[addr][bit]; \n end \n assign y3 = mem1[addr][bit]; \n assign y4 = mem2[addr][bit]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a pulse-per-second (PPS) counter with configurable data and counter widths. The module detects rising edges on the PPS input and increments a counter on each detected edge. The counter can be reset and enabled, and its current value is output on m_axis_tdata when valid.\n\n Module header:\n\nmodule axis_pps_counter # (parameter integer AXIS_TDATA_WIDTH = 32,parameter integer CNTR_WIDTH = 32) (input wire aclk,input wire aresetn,input wire pps_data,output wire [AXIS_TDATA_WIDTH-1:0] m_axis_tdata,output wire m_axis_tvalid);\n [/INST]\n", "output": "reg [CNTR_WIDTH-1:0] int_cntr_reg, int_cntr_next; \n  reg int_enbl_reg, int_enbl_next; \n  reg [2:0] int_data_reg; \n  wire int_edge_wire; \n  always @(posedge aclk) \n  begin \n  if(~aresetn) \n  begin \n  int_cntr_reg <= {(CNTR_WIDTH){1'b0}}; \n  int_enbl_reg <= 1'b0; \n  int_data_reg <= 3'd0; \n  end \n  else \n  begin \n  int_cntr_reg <= int_cntr_next; \n  int_enbl_reg <= int_enbl_next; \n  int_data_reg <= {int_data_reg[1:0], pps_data}; \n  end \n  end \n  assign int_edge_wire = ~int_data_reg[2] & int_data_reg[1]; \n  always @* \n  begin \n  int_cntr_next = int_cntr_reg + 1'b1; \n  int_enbl_next = int_enbl_reg; \n  if(~int_enbl_reg & int_edge_wire) \n  begin \n  int_enbl_next = 1'b1; \n  end \n  if(int_edge_wire) \n  begin \n  int_cntr_next = {(CNTR_WIDTH){1'b0}}; \n  end \n  end \n  assign m_axis_tdata = {{(AXIS_TDATA_WIDTH-CNTR_WIDTH){1'b0}}, int_cntr_reg}; \n  assign m_axis_tvalid = int_enbl_reg & int_edge_wire; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a distributed RAM with a specified data width and address width. It has a memory size of 16. The module takes in an address, write enable, data input, and clock signals, and outputs the data stored at the specified address. The RAM is implemented using a distributed RAM style. The module updates the memory content and output based on the control signals and input data on the positive edge of the clock signal.\n\n Module header:\n\nmodule nfa_accept_samples_generic_hw_start_indices_ram (addr0, ce0, d0, we0, q0, clk);\n [/INST]\n", "output": "parameter DWIDTH = 32; \n parameter AWIDTH = 4; \n parameter MEM_SIZE = 16; \n input[AWIDTH-1:0] addr0; \n input ce0; \n input[DWIDTH-1:0] d0; \n input we0; \n output reg[DWIDTH-1:0] q0; \n input clk; \n (* ram_style = \"distributed\" *)reg [DWIDTH-1:0] ram[MEM_SIZE-1:0]; \n always @(posedge clk) \n begin \n  if (ce0) \n  begin \n  if (we0) \n  begin \n  ram[addr0] <= d0; \n  q0 <= d0; \n  end \n  else \n  q0 <= ram[addr0]; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a synchronous register with an input data vector, data_in, and a write enable signal, we. It also has clock and reset synchronization inputs, clk and rst_sync, and an output data vector, data_out. The module uses an always block sensitive to the positive edge of the clock signal to handle the write enable and reset synchronization. If the reset synchronization signal is asserted, the output data, data_out, is assigned the reset value, RESET_VALUE. If the write enable signal, we, is asserted, the output data is assigned the input data, data_in.\n\n Module header:\n\nmodule can_register_syn ( data_in,data_out,we,clk,rst_sync);\n [/INST]\n", "output": "parameter WIDTH = 8; \n parameter RESET_VALUE = 0; \n input [WIDTH-1:0] data_in; \n input we; \n input clk; \n input rst_sync; \n output [WIDTH-1:0] data_out; \n reg [WIDTH-1:0] data_out; \n always @ (posedge clk) \n begin \n  if (rst_sync) \n  data_out<=#1 RESET_VALUE; \n  else if (we) \n  data_out<=#1 data_in; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a ROM (Read-Only Memory) that outputs instructions based on the value of the program counter (PC). It contains a case statement that decodes specific values of the program counter to output corresponding instructions. The module is sensitive to the positive edge of the clock signal and updates the instruction output accordingly. There's also a default case to output 0 when the program counter does not match any specific values.\n\n Module header:\n\nmodule rom(PC,inst,clk);\n [/INST]\n", "output": "parameter DATA_WIDTH= 32; \n `ifdef PROGRAM_1 \n  parameter PROG_LENGTH= 16; \n `endif \n input [DATA_WIDTH-1:0] PC; \n input clk; \n output [DATA_WIDTH-1:0] inst; \n reg [DATA_WIDTH-1:0] inst; \n always @(posedge clk) \n begin \n case(PC) \n `ifdef PROGRAM_1 \n  32'h0000_0000 : inst<= 32'b111001_00000_00000_1111111111111111; \n  32'h0000_0004: inst<= 32'b111010_00000_00000_1111111111111111; \n  32'h0000_0008: inst<= 32'b111001_00001_00000_0000000000000000; \n  32'h0000_000c: inst<= 32'b111010_00001_00000_0000000000000000; \n  32'h0000_0010: inst<= 32'b111001_00010_00000_0000000000000010; \n  32'h0000_0014: inst<= 32'b111010_00010_00000_0000000000000000; \n  32'h0000_0018: inst<= 32'b010010_00011_00000_00010_00000000000; \n  32'h0000_001c: inst<= 32'b111100_00011_00000_0000000000000101; \n  32'h0000_0020: inst<= 32'b111011_00001_00000_0000000000000101; \n  32'h0000_0024: inst<= 32'b110010_00000_00000_0000000000000001; \n  32'h0000_0028: inst<= 32'b010111_11111_00000_00001_00000000000; \n  32'h0000_002c: inst<= 32'b100001_11111_00000_1111111111111101; \n  32'h0000_0030: inst<= 32'b000001_00000000000000000000001111; \n  32'h0000_0034: inst<= 32'b111001_00000_00000_1111111111111111; \n  32'h0000_0038: inst<= 32'b111010_00000_00000_1111111111111111; \n  32'h0000_003c: inst<= 32'b110011_00000_00000_0000000000000001; \n `endif \n  default: inst<= 0; \n endcase \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes a 4-bit input data and processes it using ACLFP add double altpriority encoders to produce a 2-bit output q. The module uses the outputs of the altpriority encoders and a combination of logical operations to generate the final output q.\n\n Module header:\n\nmodule acl_fp_add_double_altpriority_encoder_6v7 (data,q) ;\n [/INST]\n", "output": "input [3:0] data; \n  output [1:0] q; \n  wire [0:0] wire_altpriority_encoder21_q; \n  wire [0:0] wire_altpriority_encoder22_q; \n  wire wire_altpriority_encoder22_zero; \n  acl_fp_add_double_altpriority_encoder_3v7 altpriority_encoder21 \n (.data(data[1:0]),.q(wire_altpriority_encoder21_q)); \n  acl_fp_add_double_altpriority_encoder_3e8 altpriority_encoder22 \n (.data(data[3:2]),.q(wire_altpriority_encoder22_q),.zero(wire_altpriority_encoder22_zero)); \n  assign \n  q = {(~ wire_altpriority_encoder22_zero), ((wire_altpriority_encoder22_zero & wire_altpriority_encoder21_q) | ((~ wire_altpriority_encoder22_zero) & wire_altpriority_encoder22_q))}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is designed for resynchronizing data between different clock domains. It includes features for handling write and read pulses, toggling, and resetting. The module also implements a reset synchronizer. It utilizes conditional statements and data manipulation to ensure safe clock domain crossing for the write pulse. The functionality involves detecting early write pulses and halting the simulation if necessary. The module is also responsible for synchronizing the reset signal and resetting metadata and data accordingly.\n\n Module header:\n\nmodule resync #(parameter DATA_SIZE = 32,parameter ALLOW_FAST_WRITE_PULSE = 0)(input rst,input wr_clk,input wr_pulse,input [DATA_SIZE-1:0] wr_data,input rd_clk,output reg rd_pulse,output reg [DATA_SIZE-1:0] rd_data);\n [/INST]\n", "output": "reg [DATA_SIZE-1:0] data_wrclk; \n reg toggle_wr; \n reg toggle_return_wr_meta; \n reg toggle_return_wr0; \n reg toggle_rd_meta; \n reg toggle_rd0; \n reg toggle_rd1; \n reg stop_once; \n initial begin \n  stop_once = 0; \n end \n always @(posedge wr_clk or posedge rst) begin \n  if (rst) begin \n  toggle_wr <= 1'b0; \n  toggle_return_wr_meta <= 1'b0; \n  toggle_return_wr0 <= 1'b0; \n  data_wrclk[DATA_SIZE-1:0] <= 'h0; \n  end else begin \n  toggle_wr <= ALLOW_FAST_WRITE_PULSE ? toggle_wr ^ (wr_pulse & (toggle_wr ^ ~toggle_return_wr0)) : toggle_wr ^ wr_pulse; \n  toggle_return_wr_meta <= toggle_rd0; \n  toggle_return_wr0 <= toggle_return_wr_meta; \n  if (wr_pulse) begin \n  data_wrclk[DATA_SIZE-1:0] <= wr_data[DATA_SIZE-1:0]; \n  end \n  if(wr_pulse & (ALLOW_FAST_WRITE_PULSE ? (toggle_wr ^ ~toggle_return_wr0) : 1'b1) & (toggle_wr ^ toggle_rd1)) begin \n  $display(\"%t: %m: ERROR: wr_pulse too early to guarantee safe clock domain crossing!\", $realtime); \n  if(!stop_once) begin \n  stop_once = 1; \n  $stop; \n  end \n  end \n  end \n end \n wire rd_rst; \n reset_resync i_reset_resync (.rst_in (rst),.clk_in (wr_clk),.clk_out (rd_clk),.rst_out (rd_rst)); \n always @(posedge rd_clk or posedge rd_rst) begin \n  if (rd_rst) begin \n  toggle_rd_meta <= 1'b0; \n  toggle_rd0 <= 1'b0; \n  toggle_rd1 <= 1'b0; \n  rd_pulse <= 1'b0; \n  rd_data <= {DATA_SIZE{1'b0}}; \n  end else begin \n  toggle_rd_meta <= toggle_wr; \n  toggle_rd0 <= toggle_rd_meta; \n  toggle_rd1 <= toggle_rd0; \n  rd_pulse <= toggle_rd0 ^ toggle_rd1; \n  if (toggle_rd0 ^ toggle_rd1) begin \n  rd_data[DATA_SIZE-1:0] <= data_wrclk[DATA_SIZE-1:0]; \n  end \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a circuit for controlling an LED display. It uses the input data_in to update the LED_out and LED_ctrl signals based on a timer and the input data_in. The timer is used to cycle through the different portions of the data_in to control the LED display. The module also contains logic to reset the timer when necessary. The LED_out_rev and LED_ctrl_rev outputs are assigned to the complement of the LED_out and LED_ctrl signals respectively.\n\n Module header:\n\nmodule Anvyl_DISP(output [7 : 0] LED_out_rev,output [5 : 0] LED_ctrl_rev,input clk,input rst,input [23 : 0] data_in);\n [/INST]\n", "output": "reg [7 : 0] LED_out; \n  reg [5 : 0] LED_ctrl; \n  reg [3 : 0] LED_content; \n  reg [19 : 0] timer; \n  assign LED_out_rev = ~LED_out; \n  assign LED_ctrl_rev = ~LED_ctrl; \n  always @(posedge clk or negedge rst) \n  begin \n  if (rst == 0) \n  begin \n  timer = 0; \n  end \n  else \n  begin \n  timer = timer+1; \n  if (timer >= 75000) \n  begin \n  timer = 0; \n  end \n  if (timer < 12500) \n  begin \n  LED_ctrl = 6'b011111; \n  LED_content = data_in[23 : 20]; \n  end \n  else if (timer < 25000) \n  begin \n  LED_ctrl = 6'b101111; \n  LED_content = data_in[19 : 16]; \n  end \n  else if (timer < 37500) \n  begin \n  LED_ctrl = 6'b110111; \n  LED_content = data_in[15 : 12]; \n  end \n  else if (timer < 50000) \n  begin \n  LED_ctrl = 6'b111011; \n  LED_content = data_in[11 : 8]; \n  end \n  else if (timer < 62500) \n  begin \n  LED_ctrl = 6'b111101; \n  LED_content = data_in[7 : 4]; \n  end \n  else \n  begin \n  LED_ctrl = 6'b111110; \n  LED_content = data_in[3 : 0]; \n  end \n  case (LED_content) \n  4'b0000: LED_out = 8'b00000011; \n  4'b0001: LED_out = 8'b10011111; \n  4'b0010: LED_out = 8'b00100101; \n  4'b0011: LED_out = 8'b00001101; \n  4'b0100: LED_out = 8'b10011001; \n  4'b0101: LED_out = 8'b01001001; \n  4'b0110: LED_out = 8'b01000001; \n  4'b0111: LED_out = 8'b00011111; \n  4'b1000: LED_out = 8'b00000001; \n  4'b1001: LED_out = 8'b00001001; \n  4'b1010: LED_out = 8'b00010001; \n  4'b1011: LED_out = 8'b11000001; \n  4'b1100: LED_out = 8'b01100011; \n  4'b1101: LED_out = 8'b10000101; \n  4'b1110: LED_out = 8'b01100001; \n  4'b1111: LED_out = 8'b01110001; \n  endcase \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a register bus with various control and data assignments. The module takes several inputs including reset, csel, cpuclock, ASTB, nOE, nWE, abus, and handles them to produce outputs rbusCtrl and rbusData. The module includes specific control assignments for each bit of the dmaCtrl register based on input conditions and also assigns the input dbus to dmaData.\n\n Module header:\n\nmodule WcaRegisterBus (input reset,input csel,input cpuclock,input ASTB,input nOE,input nWE,input wire [5:0] abus,inout wire [15:0] dbus,output wire [12:0] rbusCtrl,inout wire [15:0] rbusData);\n [/INST]\n", "output": "assign dmaData = dbus; \n  assign dmaCtrl[13:10] = 4'd0; \n  assign dmaCtrl[9:4] = abus[5:0]; \n  assign dmaCtrl[3] = ASTB | csel; \n  assign dmaCtrl[2] = nOE; \n  assign dmaCtrl[1] = nWE; \n  assign dmaCtrl[0] = cpuclock; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a CRC-5 calculation for USB. It uses a 5-bit register to calculate the CRC-5 value. The module has inputs for reset, clock, enable, and data, and an output for validity. The validity of the CRC-5 value is checked against a specific pattern. The CRC-5 calculation is done in the combinatorial block based on the input data and the top bit of the current CRC-5 value. The module also includes a synchronous block for reset and updating the CRC-5 value based on the clock and enable signals.\n\n Module header:\n\nmodule usb_crc5(input rst_n,input clk,input clken,input d,output valid);\n [/INST]\n", "output": "reg[4:0] r; \n reg[4:0] next; \n wire top = r[4]; \n assign valid = (next == 5'b01100); \n always @(*) begin \n  if (top == d) \n  next = { r[3], r[2], r[1], r[0], 1'b0 }; \n  else \n  next = { r[3], r[2], !r[1], r[0], 1'b1 }; \n end \n always @(posedge clk or negedge rst_n) begin \n  if (!rst_n) begin \n  r <= 5'b11111; \n  end else if (clken) begin \n  r <= next; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a 4-bit seven-segment decoder. It takes a 4-bit input value 'val' and generates control signals 'a' through 'g' to drive a seven-segment display. Each case in the always block corresponds to a different hexadecimal input value and sets the control signals accordingly to display the corresponding digit on the seven-segment display.\n\n Module header:\n\nmodule sevseg_decoder(val, a, b, c, d, e, f, g);\n [/INST]\n", "output": "input [3:0] val; \n  output reg a, b, c, d, e, f, g; \n  parameter led_on = 1'b0; \n  parameter led_off = 1'b1; \n  always @(val) \n  case (val) \n  4'h0: begin \n  a = led_on; \n  b = led_on; \n  c = led_on; \n  d = led_on; \n  e = led_on; \n  f = led_on; \n  g = led_off; \n  end \n  4'h1: begin \n  a = led_off; \n  b = led_on; \n  c = led_on; \n  d = led_off; \n  e = led_off; \n  f = led_off; \n  g = led_off; \n  end \n  4'h2: begin \n  a = led_on; \n  b = led_on; \n  c = led_off; \n  d = led_on; \n  e = led_on; \n  f = led_off; \n  g = led_on; \n  end \n  4'h3: begin \n  a = led_on; \n  b = led_on; \n  c = led_on; \n  d = led_on; \n  e = led_off; \n  f = led_off; \n  g = led_on; \n  end \n  4'h4: begin \n  a = led_off; \n  b = led_on; \n  c = led_on; \n  d = led_off; \n  e = led_off; \n  f = led_on; \n  g = led_on; \n  end \n  4'h5: begin \n  a = led_on; \n  b = led_off; \n  c = led_on; \n  d = led_on; \n  e = led_off; \n  f = led_on; \n  g = led_on; \n  end \n  4'h6: begin \n  a = led_on; \n  b = led_off; \n  c = led_on; \n  d = led_on; \n  e = led_on; \n  f = led_on; \n  g = led_on; \n  end \n  4'h7: begin \n  a = led_on; \n  b = led_on; \n  c = led_on; \n  d = led_off; \n  e = led_off; \n  f = led_off; \n  g = led_off; \n  end \n  4'h8: begin \n  a = led_on; \n  b = led_on; \n  c = led_on; \n  d = led_on; \n  e = led_on; \n  f = led_on; \n  g = led_on; \n  end \n  4'h9: begin \n  a = led_on; \n  b = led_on; \n  c = led_on; \n  d = led_off; \n  e = led_off; \n  f = led_on; \n  g = led_on; \n  end \n  4'hA: begin \n  a = led_on; \n  b = led_on; \n  c = led_on; \n  d = led_off; \n  e = led_on; \n  f = led_on; \n  g = led_on; \n  end \n  4'hB: begin \n  a = led_off; \n  b = led_off; \n  c = led_on; \n  d = led_on; \n  e = led_on; \n  f = led_on; \n  g = led_on; \n  end \n  4'hC: begin \n  a = led_on; \n  b = led_off; \n  c = led_off; \n  d = led_on; \n  e = led_on; \n  f = led_on; \n  g = led_off; \n  end \n  4'hD: begin \n  a = led_off; \n  b = led_on; \n  c = led_on; \n  d = led_on; \n  e = led_on; \n  f = led_off; \n  g = led_on; \n  end \n  4'hE: begin \n  a = led_on; \n  b = led_off; \n  c = led_off; \n  d = led_on; \n  e = led_on; \n  f = led_on; \n  g = led_on; \n  end \n  default: begin \n  a = led_on; \n  b = led_off; \n  c = led_off; \n  d = led_off; \n  e = led_on; \n  f = led_on; \n  g = led_on; \n  end \n  endcase \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a data broadcast manager that takes input data from dq_data_in and dm_data_in and distributes it to dq_data_out and dm_data_out respectively. The module contains parameters and local parameters that configure the number of DQS groups, the number of DQ bits per DQS group, and other properties. Inside the module, it generates logic for each word and group to handle the distribution of data. The module also includes a check for a defined macro ADD_UNIPHY_SIM_SVA, asserting a property related to the equality of NUMBER_OF_DQS_GROUPS and MEM_DM_WIDTH. If the property is not satisfied, an error message is issued.\n\n Module header:\n\nmodule rw_manager_data_broadcast(dq_data_in,dm_data_in,dq_data_out,dm_data_out);\n [/INST]\n", "output": "parameter NUMBER_OF_DQS_GROUPS = \"\"; \n  parameter NUMBER_OF_DQ_PER_DQS = \"\"; \n  parameter AFI_RATIO = \"\"; \n  parameter MEM_DM_WIDTH = \"\"; \n  localparam NUMBER_OF_DQ_BITS = NUMBER_OF_DQS_GROUPS * NUMBER_OF_DQ_PER_DQS; \n  localparam NUMBER_OF_WORDS = 2 * AFI_RATIO; \n  input [NUMBER_OF_DQ_PER_DQS * NUMBER_OF_WORDS - 1 : 0] dq_data_in; \n  input [NUMBER_OF_WORDS - 1 : 0] dm_data_in; \n  output [NUMBER_OF_DQ_BITS * NUMBER_OF_WORDS - 1 : 0] dq_data_out; \n  output [MEM_DM_WIDTH * 2 * AFI_RATIO - 1 : 0] dm_data_out; \n  genvar gr, wr, dmbit; \n  generate \n  for(wr = 0; wr < NUMBER_OF_WORDS; wr = wr + 1) \n  begin : word \n  for(gr = 0; gr < NUMBER_OF_DQS_GROUPS; gr = gr + 1) \n  begin : group \n  assign dq_data_out[wr * NUMBER_OF_DQ_BITS + (gr + 1) * NUMBER_OF_DQ_PER_DQS - 1 : wr * NUMBER_OF_DQ_BITS + gr * NUMBER_OF_DQ_PER_DQS] = \n  dq_data_in[(wr + 1) * NUMBER_OF_DQ_PER_DQS - 1 : wr * NUMBER_OF_DQ_PER_DQS]; \n  end \n  for(dmbit = 0; dmbit < MEM_DM_WIDTH; dmbit = dmbit + 1) \n  begin : data_mask_bit \n  assign dm_data_out[wr * MEM_DM_WIDTH + dmbit] = dm_data_in[wr]; \n  end \n  end \n  endgenerate \n `ifdef ADD_UNIPHY_SIM_SVA \n  assert property (@dm_data_in NUMBER_OF_DQS_GROUPS == MEM_DM_WIDTH) else \n  $error(\"%t, [DATA BROADCAST ASSERT] NUMBER_OF_DQS_GROUPS and MEM_DM_WIDTH mismatch, NUMBER_OF_DQS_GROUPS = %d, MEM_DM_WIDTH = %d\", $time, NUMBER_OF_DQS_GROUPS, MEM_DM_WIDTH); \n `endif \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a 2-to-1 multiplexer with a customizable data width. It selects between two input data streams based on the value of the select signal 's' and assigns the selected input to the output 'y'.\n\n Module header:\n\nmodule mux2 #(parameter WIDTH = 8) (input [WIDTH-1:0] d0, d1,input s,output [WIDTH-1:0] y);\n [/INST]\n", "output": "assign y = s ? d1 : d0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module simulates a keyed permutation operation. It includes input registers for data and key, and output registers for permuted and unpermuted data. The module instantiates two instances of the `keyed_permutation` module to perform the permutation and its inverse. The initial block generates random keys and data to test the permutation operation. The error wire is used to check for any discrepancies between the permuted and unpermuted data. The clock signal is toggled every 10 cycles to simulate the clock behavior.\n\n Module header:\n\nmodule keyed_permutation_tb();\n [/INST]\n", "output": "localparam UNIT_WIDTH = 1; \n localparam NUNITS = 32; \n localparam INDEX_WIDTH = 5; \n reg i_clk; \n reg [NUNITS*UNIT_WIDTH-1:0] i_dat; \n reg [NUNITS*UNIT_WIDTH-1:0] i_dat_d1; \n reg [NUNITS*UNIT_WIDTH-1:0] i_dat_d2; \n reg [NUNITS*INDEX_WIDTH-1:0] i_key; \n reg [NUNITS*INDEX_WIDTH-1:0] i_key_d1; \n wire [NUNITS*UNIT_WIDTH-1:0] o_dat; \n wire [NUNITS*UNIT_WIDTH-1:0] unpermuted; \n always @(posedge i_clk) {i_key_d1,i_dat_d2,i_dat_d1} <= {i_key,i_dat_d1,i_dat}; \n keyed_permutation dut(.i_clk(i_clk),.i_dat(i_dat),.i_key(i_key),.i_inverse(1'b0),.o_dat(o_dat)); \n keyed_permutation checker(.i_clk(i_clk),.i_dat(o_dat),.i_key(i_key_d1),.i_inverse(1'b1),.o_dat(unpermuted)); \n integer i,j; \n integer cnt; \n wire error = cnt>3 ? unpermuted !== i_dat_d2 : 0; \n initial begin \n  cnt=0; \n  for(i=0;i<10;i=i+1) begin \n  i_key = {$random,$random,$random,$random,$random,$random,$random,$random,$random,$random,$random,$random,$random,$random,$random,$random}; \n  for(j=0;j<10;j=j+1) begin \n  i_dat = $random; \n  @(negedge i_clk); \n  cnt=cnt+1; \n  end \n  end \n  @(negedge i_clk); \n  @(negedge i_clk); \n  @(negedge i_clk); \n end \n initial begin \n  i_clk = 0; \n  forever i_clk = #10 ~i_clk; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module v60f5a9 consists of a set of wires and a 5-bit wire w5. The module has five outputs v3f8943, v64d863, vda577d, v4f1fd3, and v53baa6. The module assigns the values of the wires w0, w1, w2, w3, and w4 to these outputs. The value of wire w5 is assigned to the input v427dd1. Additionally, the module instantiates another module v60f5a9_v9a2a06 and connects the wires accordingly.\n\n Module header:\n\nmodule v60f5a9 (input [4:0] v427dd1,output v53baa6,output v4f1fd3,output vda577d,output v3f8943,output v64d863);\n [/INST]\n", "output": "wire w0; \n  wire w1; \n  wire w2; \n  wire w3; \n  wire w4; \n  wire [0:4] w5; \n  assign v3f8943 = w0; \n  assign v64d863 = w1; \n  assign vda577d = w2; \n  assign v4f1fd3 = w3; \n  assign v53baa6 = w4; \n  assign w5 = v427dd1; \n v60f5a9_v9a2a06 v9a2a06 (.o1(w0),.o0(w1),.o2(w2),.o3(w3),.o4(w4),.i(w5)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a state machine with two state variables, some_state and some_other_state, and uses the input clock signal to control state transitions. It uses a case statement to handle different state transitions based on the current state. Additionally, it uses if statements to make decisions based on the clock signal and the value of some_other_state. The module also includes display, write, and finish statements for output and termination control. The logic of the module is driven by the clock signal and the state variables, allowing for state transitions and output control based on the input conditions.\n\n Module header:\n\nmodule some_module (input [3:0] i_clks);\n [/INST]\n", "output": "logic [ 1 : 0 ] some_state; \n  logic [1:0] some_other_state; \n  logic the_clk; \n  assign the_clk = i_clks[3]; \n  always @(posedge the_clk) begin \n  case (some_state) \n  2'b11: \n  if (some_other_state == 0) \n  some_state <= 2'b00; \n  default: \n  $display (\"This is a display statement\"); \n  endcase \n  if (the_clk) \n  some_other_state <= 0; \n  $write(\"*-* All Finished *-*\\n\"); \n  $finish; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module defines an 8-bit output wire reg_0x04 and assigns the hexadecimal value 00 to it.\n\n Module header:\n\nmodule r_DEVICE_ID_LOW(output wire [7:0] reg_0x04);\n [/INST]\n", "output": "assign reg_0x04=8'h00; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module implements a flip-flop with asynchronous reset functionality. It has inputs for the clock signal (p_clk), reset signal (rst_in), and a register request signal (reg_req_t), with an output (out). It uses a two-bit register (wr_req_pipe) and checks for an asynchronous reset condition to either clear the register or update it with the input request. The output is then assigned based on the second bit of the register.\n\n Module header:\n\nmodule weird_ff(p_clk, rst_in, reg_req_t, out);\n [/INST]\n", "output": "input p_clk; \n  input rst_in; \n  input reg_req_t; \n  output out; \n  reg [1:0] wr_req_pipe; \n  parameter G_ASYNC_RESET = 0; \n  wire a_rst = (G_ASYNC_RESET != 0) ? rst_in : 1'b0; \n  wire s_rst = (G_ASYNC_RESET == 0) ? rst_in : 1'b0; \n  always @(posedge p_clk or posedge a_rst) \n  if (a_rst | s_rst) \n  wr_req_pipe <= 'b0; \n  else \n  wr_req_pipe <= {wr_req_pipe, reg_req_t}; \n  assign out = wr_req_pipe[1]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a UART transmit module that takes in various inputs and generates the serial transmit output 'tx'. It includes a shift register for transmitting data, a counter for the number of bits transmitted, and frame done detection. The transmission is triggered by the 'transmit' input or when the 'fifo_read_enable' input is asserted. The module interfaces with a YAF module for the transmitter to read from the FIFO and control the FIFO's full and empty signals. The module also includes logic to handle reset and clear signals.\n\n Module header:\n\nmodule uart_light_tx_dp #(parameter WORD_SIZE = 8,parameter BC_SIZE = 3,parameter FIFO_ADDR_BITS = 5)(input wire reset,input wire clk_peri,input wire clk_tx,output wire tx,input wire [WORD_SIZE-1:0] word_tx,input wire transmit,input wire clear,input wire fifo_read_enable,output wire frame_done,input wire fifo_write_enable,output wire fifo_full,output wire fifo_empty);\n [/INST]\n", "output": "wire[WORD_SIZE-1:0] fifo_out; \n  reg [WORD_SIZE:0] shfreg_tx; \n  reg [BC_SIZE:0] bit_count; \n  assign tx = shfreg_tx[0]; \n  assign frame_done = (bit_count == WORD_SIZE); \n  always @(posedge clk_tx, posedge reset) begin \n  if(reset) begin \n  shfreg_tx <= {(WORD_SIZE+1){1'b1}}; \n  bit_count <= {(BC_SIZE+1){1'b0}}; \n  end \n  else begin \n  if(fifo_read_enable) \n  shfreg_tx <= {fifo_out,1'b0}; \n  else if(transmit) begin \n  shfreg_tx <= {1'b1, shfreg_tx[WORD_SIZE:1]}; \n  bit_count <= bit_count + 1'b1; \n  end \n  else if(clear) begin \n  shfreg_tx <= {(WORD_SIZE+1){1'b1}}; \n  bit_count <= {(BC_SIZE+1){1'b0}}; \n  end \n  end \n  end \n  yaf # \n (.DSIZE (WORD_SIZE),.ASIZE (FIFO_ADDR_BITS)) \n  yaf_tx0 \n (.rdata( fifo_out ),.wfull( ),.rfull( ),.rwfull( fifo_full ),.wempty( ),.rempty( ),.rwempty( fifo_empty ),.fill( ),.wdata( word_tx ),.winc( fifo_write_enable ),.wclk( clk_peri ),.wrst_n( ~reset ),.rinc( fifo_read_enable ),.rclk( clk_tx ),.rrst_n ( ~reset ),.rptr_upd( 1'b0 ),.rptr_rest( 1'b0 ),.wptr_upd( 1'b0 ),.wptr_rest( 1'b0 )); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements an encoder with a parameterized number of inputs. The input g_input is connected to the first half of the input bus, and e_input is connected to the second half. The output o is of size logS. The module instantiates an encoder module with the specified parameters, connects the input and output signals, and concludes the module definition.\n\n Module header:\n\nmodule encoder #(parameter logS=4) (g_input,e_input,o);\n [/INST]\n", "output": "localparam S = 2**logS; \n  input [S/2-1:0] g_input; \n  input [S/2-1:0] e_input; \n  output [logS-1:0] o; \n  wire [S-1:0] in; \n  assign in[S/2-1:0] = g_input; \n  assign in[S-1:S/2] = e_input; \n  encoder_ \n #(.logS(logS)) \n  encoder0 \n (.in(in),.o(o)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, named GP_DCMPMUX, takes in two 8-bit inputs, SEL and four 8-bit IN inputs, and provides two 8-bit outputs, OUTA and OUTB. It uses a case statement based on the value of SEL to select which IN input to assign to OUTA and OUTB. When SEL is 00, OUTA is assigned IN0 and OUTB is assigned IN3. When SEL is 01, OUTA is assigned IN1 and OUTB is assigned IN2. When SEL is 02, OUTA is assigned IN2 and OUTB is assigned IN1. When SEL is 03, OUTA is assigned IN3 and OUTB is assigned IN0.\n\n Module header:\n\nmodule GP_DCMPMUX(input[1:0] SEL, input[7:0] IN0, input[7:0] IN1, input[7:0] IN2, input[7:0] IN3, output reg[7:0] OUTA, output reg[7:0] OUTB);\n [/INST]\n", "output": "always @(*) begin \n  case(SEL) \n  2'd00: begin \n  OUTA <= IN0; \n  OUTB <= IN3; \n  end \n  2'd01: begin \n  OUTA <= IN1; \n  OUTB <= IN2; \n  end \n  2'd02: begin \n  OUTA <= IN2; \n  OUTB <= IN1; \n  end \n  2'd03: begin \n  OUTA <= IN3; \n  OUTB <= IN0; \n  end \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements an extended memory management unit (EMMU) with several input and output ports. It includes memory interfaces, clock signals, and control signals for memory access. The EMMU controls memory access and addresses through the memory interface. It also manipulates and routes data packets to various destinations based on control signals and lookup data. The module uses registers and wires to manage the internal state and perform the necessary data manipulation and routing. The module also includes an embedded memory block for data storage and retrieval.\n\n Module header:\n\nmodule emmu (mi_dout, emesh_access_out, emesh_packet_out, emesh_packet_hi_out,reset, rd_clk, wr_clk, mmu_en, mmu_bp, mi_en, mi_we, mi_addr,mi_din, emesh_access_in, emesh_packet_in, emesh_rd_wait,emesh_wr_wait);\n [/INST]\n", "output": "parameter DW = 32; \n  parameter AW = 32; \n  parameter PW = 104; \n  parameter EPW = 136; \n  parameter MW = 48; \n  parameter MAW = 12; \n  parameter GROUP = 0; \n  input reset; \n  input rd_clk; \n  input wr_clk; \n  input mmu_en; \n  input mmu_bp; \n  input mi_en; \n  input mi_we; \n  input [14:0] mi_addr; \n  input [DW-1:0] mi_din; \n  output [DW-1:0] mi_dout; \n  input emesh_access_in; \n  input [PW-1:0] emesh_packet_in; \n  input emesh_rd_wait; \n  input emesh_wr_wait; \n  output emesh_access_out; \n  output [PW-1:0] emesh_packet_out; \n  output [31:0] emesh_packet_hi_out; \n  reg emesh_access_out; \n  reg [PW-1:0] emesh_packet_reg; \n  wire [63:0] emesh_dstaddr_out; \n  wire [MW-1:0] emmu_lookup_data; \n  wire [63:0] mi_wr_data; \n  wire [5:0] mi_wr_vec; \n  wire mi_match; \n  wire [MW-1:0] emmu_rd_addr; \n  wire write_in; \n  assign mi_wr_vec[5:0] = (mi_en & mi_we & ~mi_addr[2]) ? 6'b001111 : \n  (mi_en & mi_we & mi_addr[2]) ? 6'b110000 : \n  6'b000000 ; \n  assign mi_wr_data[63:0] = {mi_din[31:0], mi_din[31:0]}; \n  assign mi_dout[DW-1:0] = 'b0; \n  assign write_in = emesh_packet_in[1]; \n  assign emmu_rd_addr[MAW-1:0] = emesh_packet_in[39:28]; \n memory_dp #(.DW(MW),.AW(MAW)) memory_dp (.rd_data (emmu_lookup_data[MW-1:0]),.wr_clk (wr_clk),.wr_en (mi_wr_vec[5:0]),.wr_addr (mi_addr[14:3]),.wr_data (mi_wr_data[MW-1:0]),.rd_clk (rd_clk),.rd_en (emesh_access_in),.rd_addr (emmu_rd_addr[MAW-1:0])); \n  always @ (posedge rd_clk) \n  if (reset) \n  begin \n  emesh_access_out <= 1'b0; \n  end \n  else if((write_in & ~emesh_wr_wait) | (~write_in & ~emesh_rd_wait)) \n  begin \n  emesh_access_out <= emesh_access_in; \n  emesh_packet_reg[PW-1:0] <= emesh_packet_in[PW-1:0]; \n  end \n  assign emesh_dstaddr_out[63:0] = (mmu_en & ~mmu_bp) ? {emmu_lookup_data[43:0], emesh_packet_reg[27:8]} : \n  {32'b0,emesh_packet_reg[39:8]}; \n  assign emesh_packet_out[PW-1:0] = {emesh_packet_reg[PW-1:40], \n  emesh_dstaddr_out[31:0], \n  emesh_packet_reg[7:0] \n  }; \n  assign emesh_packet_hi_out[31:0] = emesh_dstaddr_out[63:32]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, named FreqCounter, is a frequency counter circuit with a synchronous reset. It takes several input signals, such as rst_n, clk, refer, sck, and cs, and generates the miso and ready output signals. Internally, it uses a modulus-3 counter, a D-type flip-flop with a synchronous reset, and a SPI slave device. The ready signal is assigned the value of the refer signal. When implemented in hardware, this module will function as a frequency counter with SPI communication capabilities.\n\n Module header:\n\nmodule FreqCounter(rst_n, clk, refer, ready, sck, cs, miso);\n [/INST]\n", "output": "input rst_n, clk, refer, sck, cs; \n output miso; \n output ready; \n wire [31:0] sum; \n wire [31:0] latchedSum; \n Counter counter(rst_n, clk, refer, sum); \n D_FF dff(rst_n, refer, cs, sum, latchedSum); \n SpiSlave spi(rst_n, latchedSum, sck, cs, miso); \n assign ready = refer; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module interfaces with a DM9000A network chip, providing communication between the chip and the surrounding system. It handles data, command, and control signals. It also manages the interrupt and reset signals for the network chip. The module assigns and manages the communication signals based on the input and output requirements of the DM9000A chip. The `avs_s1_writedata_iDATA` input is assigned to the `avs_s1_export_ENET_DATA` output when the write signal is inactive, and the read data is assigned to the export data when the read signal is inactive. The reset, interrupt, command, chip select, read, write, and clock signals are also assigned to the corresponding export signals for the DM9000A chip.\n\n Module header:\n\nmodule DM9000A_IF(avs_s1_writedata_iDATA,avs_s1_readdata_oDATA,avs_s1_address_iCMD,avs_s1_read_n_iRD_N,avs_s1_write_n_iWR_N,avs_s1_chipselect_n_iCS_N,avs_s1_reset_n_iRST_N,avs_s1_clk_iCLK,avs_s1_irq_oINT,avs_s1_export_ENET_DATA,avs_s1_export_ENET_CMD,avs_s1_export_ENET_RD_N,avs_s1_export_ENET_WR_N,avs_s1_export_ENET_CS_N,avs_s1_export_ENET_RST_N,avs_s1_export_ENET_INT,avs_s1_export_ENET_CLK);\n [/INST]\n", "output": "input [15:0] avs_s1_writedata_iDATA; \n input avs_s1_address_iCMD; \n input avs_s1_read_n_iRD_N; \n input avs_s1_write_n_iWR_N; \n input avs_s1_chipselect_n_iCS_N; \n input avs_s1_reset_n_iRST_N; \n input avs_s1_clk_iCLK; \n output [15:0] avs_s1_readdata_oDATA; \n output avs_s1_irq_oINT; \n inout [15:0] avs_s1_export_ENET_DATA; \n output avs_s1_export_ENET_CMD; \n output avs_s1_export_ENET_RD_N; \n output avs_s1_export_ENET_WR_N; \n output avs_s1_export_ENET_CS_N; \n output avs_s1_export_ENET_RST_N; \n output avs_s1_export_ENET_CLK; \n input avs_s1_export_ENET_INT; \n assign avs_s1_export_ENET_DATA = avs_s1_write_n_iWR_N ? 16'hzzzz : avs_s1_writedata_iDATA; \n assign avs_s1_readdata_oDATA = avs_s1_read_n_iRD_N ? 16'hzzzz : avs_s1_export_ENET_DATA; \n assign avs_s1_export_ENET_RST_N = avs_s1_reset_n_iRST_N; \n assign avs_s1_irq_oINT = avs_s1_export_ENET_INT; \n assign avs_s1_export_ENET_CMD = avs_s1_address_iCMD; \n assign avs_s1_export_ENET_CS_N = avs_s1_chipselect_n_iCS_N; \n assign avs_s1_export_ENET_RD_N = avs_s1_read_n_iRD_N; \n assign avs_s1_export_ENET_WR_N = avs_s1_write_n_iWR_N; \n assign avs_s1_export_ENET_CLK = avs_s1_clk_iCLK; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a butterfly computation for four input signals. It adds and subtracts the input signals in a specific pattern and outputs the results in registers. The module is synchronous, using a clock signal, and includes a reset signal to initialize the output registers.\n\n Module header:\n\nmodule butterfly_4(clk,rst,i_0,i_1,i_2,i_3,o_0,o_1,o_2,o_3);\n [/INST]\n", "output": "input clk; \n input rst; \n input signed [23:0] i_0; \n input signed [23:0] i_1; \n input signed [23:0] i_2; \n input signed [23:0] i_3; \n output reg signed [24:0] o_0; \n output reg signed [24:0] o_1; \n output reg signed [24:0] o_2; \n output reg signed [24:0] o_3; \n wire signed [24:0] b_0; \n wire signed [24:0] b_1; \n wire signed [24:0] b_2; \n wire signed [24:0] b_3; \n assign b_0=i_0+i_3; \n assign b_1=i_1+i_2; \n assign b_2=i_1-i_2; \n assign b_3=i_0-i_3; \n always@(posedge clk or negedge rst) \n if(!rst) \n  begin \n  o_0<=25'b0; \n  o_1<=25'b0; \n  o_2<=25'b0; \n  o_3<=25'b0; \n  end \n else \n  begin \n  o_0<=b_0; \n  o_1<=b_1; \n  o_2<=b_2; \n  o_3<=b_3; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a state machine that controls the loading and transmission of data. It receives a clock signal, a reset signal, a write signal, and an 8-bit input data_in, and outputs a serial_out signal and a ready signal. The state machine goes through four states: 00, 01, 10, and 11, with transitions based on the write signal and the empty signal from the LogicProbe_xmt module. When the reset signal is high, the state is reset to 00 and ready is set to 1. In state 00, if the write signal is high, the state transitions to 01, the data_hold is loaded with the data_in, and ready is set to 0. In state 01, the state transitions to 10, and ready is set back to 1. In state 10, based on the empty and write signals, the state transitions back to 00, or to 01, or to 11. In state 11, if the empty signal is high, the state transitions to 01, and ready is set to 0. The load signal is controlled based on these transitions.\n\n Module header:\n\nmodule LogicProbe_xmtbuf(clock, reset, write, ready, data_in, serial_out);\n [/INST]\n", "output": "input clock; \n  input reset; \n  input write; \n  output reg ready; \n  input [7:0] data_in; \n  output serial_out; \n  reg [1:0] state; \n  reg [7:0] data_hold; \n  reg load; \n  wire empty; \n  LogicProbe_xmt xmt(clock, reset, load, empty, data_hold, serial_out); \n  always @(posedge clock) begin \n  if (reset == 1) begin \n  state <= 2'b00; \n  ready <= 1; \n  load <= 0; \n  end else begin \n  case (state) \n  2'b00: \n  begin \n  if (write == 1) begin \n  state <= 2'b01; \n  data_hold <= data_in; \n  ready <= 0; \n  load <= 1; \n  end \n  end \n  2'b01: \n  begin \n  state <= 2'b10; \n  ready <= 1; \n  load <= 0; \n  end \n  2'b10: \n  begin \n  if (empty == 1 && write == 0) begin \n  state <= 2'b00; \n  ready <= 1; \n  load <= 0; \n  end else \n  if (empty == 1 && write == 1) begin \n  state <= 2'b01; \n  data_hold <= data_in; \n  ready <= 0; \n  load <= 1; \n  end else \n  if (empty == 0 && write == 1) begin \n  state <= 2'b11; \n  data_hold <= data_in; \n  ready <= 0; \n  load <= 0; \n  end \n  end \n  2'b11: \n  begin \n  if (empty == 1) begin \n  state <= 2'b01; \n  ready <= 0; \n  load <= 1; \n  end \n  end \n  endcase \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a basic SR latch. The output Q is set to 1 when input S is high and is reset to 0 when input R is high. The output Q follows the value of the internal register 'out'. The always block triggers on the negative edge of the clock input and updates the 'out' based on the inputs S and R.\n\n Module header:\n\nmodule SR(input clock_i,input S,input R,output Q);\n [/INST]\n", "output": "reg out; \n  assign Q = out; \n  always @(negedge clock_i) \n  begin \n  if( S ) \n  out <= 1'b1; \n  else \n  if( R ) \n  out <= 1'b0; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, named negedge_sync, implements a negative edge-triggered flip-flop. It has an input clock signal, an asynchronous input signal, and an output synchronous signal. It uses a sampling signal to capture the input asynchronous signal at the negative edge of the clock and then outputs this sampled value as the synchronous signal.\n\n Module header:\n\nmodule negedge_sync (i_clk, i_async, o_sync);\n [/INST]\n", "output": "input i_clk; \n  input i_async; \n  output o_sync; \n  reg samp_rising; \n  reg o_sync; \n  initial begin \n  samp_rising <= 1'b0; \n  o_sync <= 1'b0; \n  end \n  always @( posedge i_clk ) \n  samp_rising <= i_async; \n  always @( negedge i_clk ) \n  o_sync <= samp_rising; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a keyed permutation logic, where the input data is rearranged based on a key. The module contains functions to compute the mapping of the data elements based on the key, to permute the input data according to the map, and to unpermute the input data based on the map. The key and data are processed based on the clock signal, and the output is either the permuted or unpermuted data, depending on the state of the 'i_inverse' input.\n\n Module header:\n\nmodule keyed_permutation #(parameter UNIT_WIDTH = 1,parameter NUNITS = 32,parameter INDEX_WIDTH = 5)(input wire i_clk,input wire [NUNITS*UNIT_WIDTH-1:0] i_dat,input wire [NUNITS*INDEX_WIDTH-1:0] i_key,input wire i_inverse,output reg [NUNITS*UNIT_WIDTH-1:0] o_dat);\n [/INST]\n", "output": "function [INDEX_WIDTH-1:0] get_nth_zero_index; \n  input [NUNITS-1:0] in; \n  input [INDEX_WIDTH-1:0] index; \n  integer i; \n  reg [INDEX_WIDTH-1:0] zero_index; \n  reg [INDEX_WIDTH-1:0] out; \n  begin \n  out = {INDEX_WIDTH{1'bx}}; \n  zero_index = 0; \n  for(i=0;i<NUNITS;i=i+1) begin \n  if(~in[i]) begin \n  if(index==zero_index) begin \n  out = i; \n  end \n  zero_index = zero_index + 1; \n  end \n  end \n  get_nth_zero_index = out; \n  end \n endfunction \n function [NUNITS*INDEX_WIDTH-1:0] compute_map; \n  input [NUNITS*INDEX_WIDTH-1:0] key; \n  reg [NUNITS*INDEX_WIDTH-1:0] map; \n  reg [NUNITS-1:0] done; \n  reg [INDEX_WIDTH-1:0] outPos; \n  reg [NUNITS-1:0] outDone;reg [8:0] pos; \n  reg [INDEX_WIDTH:0] remaining; \n  integer i; \n  reg [INDEX_WIDTH-1:0] index; \n  integer indexWidth; \n  begin \n  indexWidth = INDEX_WIDTH; \n  outDone = {NUNITS{1'b0}}; \n  pos = 0; \n  outPos = 0; \n  remaining = NUNITS; \n  for(i=0;i<NUNITS;i=i+1) begin \n  index = {INDEX_WIDTH{1'b0}}; \n  if(i!=31) begin \n  index = key[pos+:INDEX_WIDTH] % remaining; \n  remaining = remaining - 1; \n  pos = pos + indexWidth; \n  end \n  outPos = get_nth_zero_index(outDone,index); \n  outDone[outPos]=1'b1; \n  map[outPos*INDEX_WIDTH+:INDEX_WIDTH]=i; \n  end \n  compute_map = map; \n  end \n endfunction \n function [NUNITS*UNIT_WIDTH-1:0] permute; \n  input [NUNITS*UNIT_WIDTH-1:0] in; \n  input [NUNITS*INDEX_WIDTH-1:0] map; \n  reg [NUNITS*UNIT_WIDTH-1:0] out; \n  integer i; \n  reg [INDEX_WIDTH-1:0] index; \n  begin \n  for(i=0;i<NUNITS;i=i+1) begin \n  index = map[i*INDEX_WIDTH+:INDEX_WIDTH]; \n  out[i*UNIT_WIDTH+:UNIT_WIDTH] = in[index*UNIT_WIDTH+:UNIT_WIDTH]; \n  end \n  permute = out; \n  end \n endfunction \n function [NUNITS*UNIT_WIDTH-1:0] unpermute; \n  input [NUNITS*UNIT_WIDTH-1:0] in; \n  input [NUNITS*INDEX_WIDTH-1:0] map; \n  reg [NUNITS*UNIT_WIDTH-1:0] out; \n  integer i; \n  reg [INDEX_WIDTH-1:0] index; \n  begin \n  for(i=0;i<NUNITS;i=i+1) begin \n  index = map[i*INDEX_WIDTH+:INDEX_WIDTH]; \n  out[index*UNIT_WIDTH+:UNIT_WIDTH] = in[i*UNIT_WIDTH+:UNIT_WIDTH]; \n  end \n  unpermute = out; \n  end \n endfunction \n reg [NUNITS*INDEX_WIDTH-1:0] map; \n always @(posedge i_clk) begin \n  map <= compute_map(i_key); \n  o_dat <= i_inverse ? unpermute(i_dat,map) : permute(i_dat,map); \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module v89d234 instantiates another module v89d234_v9148cb with some parameter and connects its inputs and outputs to the local signals and ports. The parameter v422d28 is used to initialize the instantiated module. The input ports v41eb95, v39f831, vf892a0, and the output port vb1c024 are connected to wires w4, w2, w3, and w1 respectively. The instantiated module v89d234_v9148cb has the input ports q, d, load, and clk, which are connected to wires w1, w2, w3, and w4 respectively.\n\n Module header:\n\nmodule v89d234 #(parameter v422d28 = 0) (input v41eb95,input [7:0] v39f831,input vf892a0,output [7:0] vb1c024);\n [/INST]\n", "output": "localparam p0 = v422d28; \n  wire [0:7] w1; \n  wire [0:7] w2; \n  wire w3; \n  wire w4; \n  assign vb1c024 = w1; \n  assign w2 = v39f831; \n  assign w3 = vf892a0; \n  assign w4 = v41eb95; \n v89d234_v9148cb #(.INI(p0)) v9148cb (.q(w1),.d(w2),.load(w3),.clk(w4)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an AXI traffic generator that includes an address RAM. It is designed for a specific FPGA family and data width. The module processes clock signals, reset signals, addresses, and data for read and write operations. It generates internal signals for address RAM read and write operations based on various input conditions. The module contains logic to handle different data widths and generates specific conditions for 32-bit and 64-bit data handling. Additionally, it includes a sub-module called \"axi_traffic_gen_v2_0_7_slvram_v7\" for address RAM read and write operations.\n\n Module header:\n\nmodule axi_traffic_gen_v2_0_7_addrram_wrap # (parameter C_FAMILY = \"virtex7\",parameter C_RAMINIT_ADDRRAM0_F = \"NONE\" ,parameter C_S_AXI_DATA_WIDTH = 32,parameter C_M_AXI_DATA_WIDTH = 32,parameter C_M_AXI_ADDR_WIDTH = 32,parameter C_ATG_BASIC_AXI4 = 0) (input Clk ,input rst_l ,input [15:0] aw_agen_addr ,input aw_agen_valid ,input [15:0] ar_agen_addr ,input ar_agen_valid ,input wfifo_valid ,input [C_S_AXI_DATA_WIDTH*9/8+1-1:0] wfifo_out ,output [31:0] mr_ext_addr ,output [31:0] mw_ext_addr ,output [31:0] rd_ext_addr ,input [9:0] mar_ptr_new_ff ,input [9:0] maw_ptr_new_ff);\n [/INST]\n", "output": "generate if(C_M_AXI_ADDR_WIDTH > 32 ) begin : EXT_ADDR_ON \n  wire [31:0] addrram_rd_data_a; \n  wire [3:0] addrram_we_b = 4'b0 ; \n  wire [8:0] addrram_addr_b = {1'b1,maw_ptr_new_ff[7:0]}; \n  wire [31:0] addrram_wr_data_b = 32'h00000000; \n  wire [31:0] addrram_rd_data_b; \n  wire addr_ram_we = aw_agen_valid && (aw_agen_addr[15:11] == 5'b00100); \n  reg addr_ram_we_ff; \n  wire [8:0] addr_ram_addr_ff; \n  assign addr_ram_addr_ff = (rst_l) ? ((addr_ram_we) ? aw_agen_addr[10:2] : addr_ram_addr_ff) : 9'h0 ; \n  wire [3:0] addrram_we_a = (wfifo_valid && addr_ram_we) ? 4'hf : 4'h0 ; \n  wire [8:0] addrram_addr_a = (wfifo_valid && addr_ram_we) ? addr_ram_addr_ff : (ar_agen_valid && ar_agen_addr[15:11] == 5'b00100) ? ar_agen_addr[10:2] : {1'b0,mar_ptr_new_ff[7:0]}; \n  wire [31:0] addrram_wr_data_a; \n  assign rd_ext_addr = addrram_rd_data_a; \n  assign mr_ext_addr = addrram_rd_data_a; \n  assign mw_ext_addr = addrram_rd_data_b; \n  always @(posedge Clk) begin \n  addr_ram_we_ff <= (rst_l) ? ((addr_ram_we) ? 1'h1 : ((wfifo_valid) ? 1'h0 : addr_ram_we_ff)) : 1'h0 ; \n  end \n  if(C_S_AXI_DATA_WIDTH == 64) begin: EXT_ADDR_64_GEN \n  assign addrram_wr_data_a = (addr_ram_addr_ff[0]) ? wfifo_out[63:32]: wfifo_out[31:0]; \n  end \n  if(C_S_AXI_DATA_WIDTH == 32) begin: EXT_ADDR_32_GEN \n  assign addrram_wr_data_a = wfifo_out[31:0]; \n  end \n axi_traffic_gen_v2_0_7_slvram_v7 #(.C_FAMILY (C_FAMILY ),.C_DATAWIDTH (32 ),.C_SIZE (512 ),.C_ADDR_WIDTH(9 ),.C_INITRAM_F (C_RAMINIT_ADDRRAM0_F )) addrram (.clk_a (Clk ),.we_a (addrram_we_a ),.addr_a (addrram_addr_a ),.wr_data_a(addrram_wr_data_a),.rd_data_a(addrram_rd_data_a),.clk_b (Clk ),.we_b (addrram_we_b ),.addr_b (addrram_addr_b ),.wr_data_b(addrram_wr_data_b),.rd_data_b(addrram_rd_data_b)); \n end \n endgenerate \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a forwarding unit that determines the forwarding values for two multiplexers based on specific conditions. It checks various conditions involving the control signals and input registers to set the values for forward_a_sel and forward_b_sel. The conditions involve comparisons and the status of specific control signals to determine the appropriate forwarding values.\n\n Module header:\n\nmodule FORWARDING_UNIT(input [4:0] rs,input [4:0] rt,input [4:0] five_bit_mux_out,input [1:0] ex_mem_wb,input [4:0] mem_Write_reg,input [1:0] mem_wb_wb,output reg [1:0] forward_a_sel,output reg [1:0] forward_b_sel);\n [/INST]\n", "output": "always @ * begin \n  forward_a_sel <= 2'b00; \n  forward_b_sel <= 2'b00; \n if (ex_mem_wb[1] &&(five_bit_mux_out != 0) && (five_bit_mux_out == rs)) \n  begin \n  forward_a_sel <= 2'b10; \n  end \n if (ex_mem_wb[1] &&(five_bit_mux_out != 0) && (five_bit_mux_out == rt)) \n  begin \n  forward_b_sel <= 2'b10; \n  end \n if (mem_wb_wb[1] && (mem_Write_reg != 0) &&!(ex_mem_wb[1] && (five_bit_mux_out != 0) && (five_bit_mux_out != rs)) &&(mem_Write_reg == rs)) \n  begin \n  forward_a_sel <= 2'b01; \n  end \n if (mem_wb_wb[1] && (mem_Write_reg != 0) &&!(ex_mem_wb[1] && (five_bit_mux_out != 0) && (five_bit_mux_out != rt)) &&(mem_Write_reg == rt)) \n  begin \n  forward_b_sel <= 2'b01; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a dual-port RAM with write and read functionality. It has two clock inputs aclk_i and bclk_i for separate write operations. The module has input and output ports for data, addresses, and write control signals. The RAM array is defined with a size determined by the parameter SIZE and data width determined by the parameter WIDTH. The module uses two always blocks for synchronous write operations to the RAM based on the write enable signals awr_i and bwr_i. The read addresses are stored in queues rd_addr_a_q and rd_addr_b_q and used to output data adat_o and bdat_o using assign statements. Additionally, there is an ifdef clause to clear the RAM when ALTOR32_CLEAR_RAM is defined.\n\n Module header:\n\nmodule altor32_ram_dp #(parameter WIDTH = 8,parameter SIZE = 14) (input aclk_i ,output [(WIDTH - 1):0] adat_o ,input [(WIDTH - 1):0] adat_i ,input [(SIZE - 1):0] aadr_i ,input awr_i ,input bclk_i ,output [(WIDTH - 1):0] bdat_o ,input [(WIDTH - 1):0] bdat_i ,input [(SIZE - 1):0] badr_i ,input bwr_i);\n [/INST]\n", "output": "reg [(WIDTH - 1):0] ram [((2<< (SIZE-1)) - 1):0] ; \n reg [(SIZE - 1):0] rd_addr_a_q; \n reg [(SIZE - 1):0] rd_addr_b_q; \n always @ (posedge aclk_i) \n begin \n  if (awr_i == 1'b1) \n  ram[aadr_i] <= adat_i; \n  rd_addr_a_q <= aadr_i; \n end \n always @ (posedge bclk_i) \n begin \n  if (bwr_i == 1'b1) \n  ram[badr_i] <= bdat_i; \n  rd_addr_b_q <= badr_i; \n end \n assign adat_o = ram[rd_addr_a_q]; \n assign bdat_o = ram[rd_addr_b_q]; \n `ifdef ALTOR32_CLEAR_RAM \n  integer i; \n  initial \n  begin \n  for (i=0;i<((2<< (SIZE-1)) - 1);i=i+1) \n  begin \n  ram[i] = 0; \n  end \n  end \n `endif \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe `altpcie_phasefifo` Verilog module implements a Phase-Locked Loop (PLL) FIFO, with features such as data writing and reading, error checking, and control signal generation. It utilizes synchronous RAM to store and retrieve data. The module also includes logic to handle read and write enable signals and address generation. The error checking logic detects frequency mismatches and triggers an error message if necessary.\n\n Module header:\n\nmodule altpcie_phasefifo (npor,wclk,wdata,rclk,rdata);\n [/INST]\n", "output": "parameter DATA_SIZE = 20; \n  parameter DDR_MODE = 0; \n  input npor; \n  input wclk; \n  input[DATA_SIZE - 1:0] wdata; \n  input rclk; \n  output [DATA_SIZE - 1:0] rdata; \n  wire [DATA_SIZE - 1:0] rdata; \n  reg rerror; \n  reg[3-DDR_MODE:0] waddr; \n  reg[3:0] raddr; \n  reg strobe_r; \n  reg strobe_rr; \n  reg npor_rd_r ; \n  reg npor_rd_rr ; \n  reg npor_wr_r ; \n  reg npor_wr_rr ; \n altsyncram #(.intended_device_family ( \"Stratix GX\"),.operation_mode ( \"DUAL_PORT\"),.width_a (DATA_SIZE),.widthad_a (4-DDR_MODE),.numwords_a (2**(4-DDR_MODE)),.width_b (DATA_SIZE / (DDR_MODE + 1)),.widthad_b (4),.numwords_b (16),.lpm_type ( \"altsyncram\"),.width_byteena_a ( 1),.outdata_reg_b ( \"CLOCK1\"),.indata_aclr_a ( \"NONE\"),.wrcontrol_aclr_a ( \"NONE\"),.address_aclr_a ( \"NONE\"),.address_reg_b ( \"CLOCK1\"),.address_aclr_b ( \"NONE\"),.outdata_aclr_b ( \"NONE\"),.ram_block_type ( \"AUTO\")) altsyncram_component(.wren_a(1'b1),.wren_b(1'b0),.rden_b(1'b1),.data_a(wdata),.data_b({(DATA_SIZE / (DDR_MODE + 1)){1'b1}}),.address_a(waddr),.address_b(raddr),.clock0(wclk),.clock1(rclk),.clocken0(1'b1),.clocken1(1'b1),.aclr0(1'b0),.aclr1(1'b0),.addressstall_a(1'b0),.addressstall_b(1'b0),.byteena_a({{1'b1}}),.byteena_b({{1'b1}}),.q_a(),.q_b(rdata[(DATA_SIZE / (DDR_MODE + 1))-1:0])); \n  always @(negedge npor or posedge rclk) \n  begin \n  if (npor == 1'b0) \n  begin \n  npor_rd_r <= 0; \n  npor_rd_rr <= 0; \n  end \n  else \n  begin \n  npor_rd_r <= 1; \n  npor_rd_rr <= npor_rd_r; \n  end \n  end \n  always @(negedge npor or posedge wclk) \n  begin \n  if (npor == 1'b0) \n  begin \n  npor_wr_r <= 0; \n  npor_wr_rr <= 0; \n  end \n  else \n  begin \n  npor_wr_r <= 1; \n  npor_wr_rr <= npor_wr_r; \n  end \n  end \n  always @(negedge npor_rd_rr or posedge rclk) \n  begin \n  if (npor_rd_rr == 1'b0) \n  begin \n  raddr <= 4'h0 ; \n  strobe_r <= 1'b0 ; \n  strobe_rr <= 1'b0 ; \n  rerror <= 1'b0 ; \n  end \n  else \n  begin \n  strobe_r <= DDR_MODE ? waddr[2] : waddr[3] ; \n  strobe_rr <= strobe_r ; \n  raddr <= raddr + 1'b1 ; \n  if (strobe_r == 1'b1 & strobe_rr == 1'b0 & (raddr > 4'h9)) \n  begin \n  rerror <= 1'b1 ; \n  end \n  if (rerror == 1'b1) \n  begin \n  $display(\"PhaseFIFO Frequency mismatch Error!\\n\"); \n  $stop; \n  end \n  end \n  end \n  always @(negedge npor_wr_rr or posedge wclk) \n  begin \n  if (npor_wr_rr == 1'b0) \n  begin \n  waddr <= DDR_MODE ? 3'h2 : 4'h4 ; \n  end \n  else \n  begin \n  waddr <= waddr + 1'b1; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a D-type flip-flop with 64-bit input and output. It uses a RetimeWrapper instance to handle the clocking and data transfer. The module also has reset and enable inputs, and initializes the output based on the reset and input enable signals. The module's output is based on the re-timed input data.\n\n Module header:\n\nmodule FFType_24(input clock,input reset,input [63:0] io_in,input [63:0] io_init,output [63:0] io_out,input io_enable);\n [/INST]\n", "output": "wire [63:0] d; \n  wire RetimeWrapper_clock; \n  wire RetimeWrapper_reset; \n  wire [63:0] RetimeWrapper_io_in; \n  wire [63:0] RetimeWrapper_io_out; \n  wire [63:0] _T_10; \n  wire [63:0] _GEN_0; \n  wire [63:0] _GEN_1; \n RetimeWrapper_58 RetimeWrapper (.clock(RetimeWrapper_clock),.reset(RetimeWrapper_reset),.io_in(RetimeWrapper_io_in),.io_out(RetimeWrapper_io_out)); \n  assign _GEN_0 = reset ? io_init : _T_10; \n  assign _GEN_1 = io_enable ? io_in : _GEN_0; \n  assign io_out = _T_10; \n  assign d = _GEN_1; \n  assign RetimeWrapper_io_in = d; \n  assign RetimeWrapper_clock = clock; \n  assign RetimeWrapper_reset = reset; \n  assign _T_10 = RetimeWrapper_io_out; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module takes a 32-bit input x and performs a bitwise XOR operation on specific bit slices of x. It then assigns the result to the 32-bit output y, which represents the result of the XOR operations.\n\n Module header:\n\nmodule e0 (x, y);\n [/INST]\n", "output": "input [31:0] x; \n  output [31:0] y; \n  assign y = {x[1:0],x[31:2]} ^ {x[12:0],x[31:13]} ^ {x[21:0],x[31:22]}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an instantiation of a flip-flop component (FFType_44) that has inputs for clock, reset, and io_in. The module assigns the input signals to the corresponding signals of the flip-flop component and includes a wire declaration for internal signals. It connects the clock and reset inputs to the flip-flop component and passes the io_in input to it as well. This effectively creates a hierarchical module that utilizes the FFType_44 flip-flop component with the specified inputs.\n\n Module header:\n\nmodule FF_55(input clock,input reset,input [3:0] io_in);\n [/INST]\n", "output": "wire ff_clock; \n  wire ff_reset; \n  wire [3:0] ff_io_in; \n FFType_44 ff (.clock(ff_clock),.reset(ff_reset),.io_in(ff_io_in)); \n  assign ff_io_in = io_in; \n  assign ff_clock = clock; \n  assign ff_reset = reset; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a FIFO (First-In-First-Out) converter with specific configurations. It takes input data, a clock, and reset signals from the fifo, and clock and reset signals from the gpif. The module has an internal logic to determine if it has data available for conversion. It uses two other instantiated modules, fifo_2clock_cascade and fifo36_to_fifo19, to process and convert the input data. The output data is then processed through another instantiated fifo_cascade module. The module then assigns the output data and end of file signal based on the processed input data.\n\n Module header:\n\nmodule fifo36_to_gpmc16 #(parameter FIFO_SIZE = 9,parameter MIN_OCC16 = 2) (input fifo_clk, input fifo_rst,input [35:0] in_data,input in_src_rdy,output in_dst_rdy,input gpif_clk, input gpif_rst,output [15:0] out_data,output valid,input enable,output eof,output reg has_data);\n [/INST]\n", "output": "wire [15:0] fifo_occ; \n  always @(posedge gpif_clk) \n  has_data <= (fifo_occ >= MIN_OCC16); \n  wire [35:0] data_int; \n  wire src_rdy_int, dst_rdy_int; \n  fifo_2clock_cascade #(.WIDTH(36), .SIZE(6)) fifo_2clk \n (.wclk(fifo_clk), .datain(in_data), .src_rdy_i(in_src_rdy), .dst_rdy_o(in_dst_rdy), .space(),.rclk(gpif_clk), .dataout(data_int), .src_rdy_o(src_rdy_int), .dst_rdy_i(dst_rdy_int), .occupied(),.arst(fifo_rst | gpif_rst)); \n  wire [18:0] data19_int; \n  wire data19_src_rdy_int, data19_dst_rdy_int; \n  fifo36_to_fifo19 #(.LE(1)) f36_to_f19 \n (.clk(gpif_clk), .reset(gpif_rst), .clear(1'b0),.f36_datain(data_int), .f36_src_rdy_i(src_rdy_int), .f36_dst_rdy_o(dst_rdy_int),.f19_dataout(data19_int), .f19_src_rdy_o(data19_src_rdy_int), .f19_dst_rdy_i(data19_dst_rdy_int) ); \n  wire [17:0] data18_int; \n  fifo_cascade #(.WIDTH(18), .SIZE(FIFO_SIZE+1)) occ_ctrl_fifo \n (.clk(gpif_clk), .reset(gpif_rst), .clear(1'b0),.datain(data19_int[17:0]), .src_rdy_i(data19_src_rdy_int), .dst_rdy_o(data19_dst_rdy_int), .space(),.dataout(data18_int), .src_rdy_o(valid), .dst_rdy_i(enable), .occupied(fifo_occ)); \n  assign out_data = data18_int[15:0]; \n  assign eof = data18_int[17]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a rising edge detector. It uses a 2-bit state register to track the current and next state, and it sets the next state based on the input and the current state. The module is triggered by a positive edge of the clock or the reset signal, and it resets the state to zero when the reset is asserted. The output is assigned based on the current state, specifically when the state is 'Edge'.\n\n Module header:\n\nmodule risingdge(input clk,input rst,input in,output out);\n [/INST]\n", "output": "reg [1:0] state, nextstate; \n  parameter [1:0] Zero = 2'b00, Edge = 2'b01, One=2'b10 ; \n  always @ (*) \n  case (state) \n  Zero: if(in) nextstate = Edge; \n  else nextstate = Zero; \n  Edge: if (in) nextstate = One; \n  else nextstate = Zero; \n  One: if(in) nextstate= One; \n  else nextstate= Zero; \n  default: \n  nextstate = 2'bx; \n  endcase \n  always @ (posedge clk or posedge rst) \n  begin \n  if (rst) state <=Zero; \n  else state <= nextstate; \n  end \n  assign out = (state == Edge); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a microcontroller that interfaces with a KCPSM6 processor, a ROM, and a ROM programmer. It includes inputs for clock, reset, interrupt, and an 8-bit input port. It also has outputs for write and read strobes, interrupt acknowledgment, and an 8-bit output port.\n\nThe microcontroller sets the reset and sleep mode signals for the KCPSM6 processor. It instantiates the KCPSM6 processor, the ROM, and the ROM programmer modules, passing specific parameters to each.\n\nThe KCPSM6 processor, ROM, and ROM programmer modules are responsible for processing instructions, memory access, and programming the ROM, respectively. The module coordinates their interactions based on the input signals and parameters.\n\nUltimately, the module serves as a control unit for these hardware components, facilitating the operation of the microcontroller.\n\n Module header:\n\nmodule microcontrolador (input wire clk, reset,input wire interrupt,input wire [7:0] in_port,output wire write_strobe, k_write_strobe, read_strobe,output wire interrupt_ack,output wire [7:0] port_id,output wire [7:0] out_port);\n [/INST]\n", "output": "wire [11:0] address; \n wire [17:0] instruction; \n wire bram_enable; \n wire kcpsm6_sleep; \n wire kcpsm6_reset; \n wire rdl; \n assign kcpsm6_reset = reset | rdl; \n assign kcpsm6_sleep = 1'b0; \n kcpsm6 #(.interrupt_vector (12'h3FF),.scratch_pad_memory_size(64),.hwbuild (8'h00)) \n instancia_processor(.address (address),.instruction (instruction),.bram_enable (bram_enable),.port_id (port_id),.write_strobe (write_strobe),.k_write_strobe (k_write_strobe),.out_port (out_port),.read_strobe (read_strobe),.in_port (in_port),.interrupt (interrupt),.interrupt_ack (interrupt_ack),.reset (kcpsm6_reset),.sleep (kcpsm6_sleep),.clk (clk)); \n ROM_programa #(.C_FAMILY (\"S6\"),.C_RAM_SIZE_KWORDS (2),.C_JTAG_LOADER_ENABLE (0)) \n instancia_ROM_programa (.rdl (rdl),.enable (bram_enable),.address (address),.instruction (instruction),.clk (clk)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes a clock input, a tick_8x input, and a reset input, and produces a go output. It has a 3-bit register clk_div that is incremented on every rising edge of the clock when tick_8x is high. The value of clk_div is reset based on the RESET_TYPE parameter and reset signal. The go output is asserted when the reset is deasserted, tick_8x is high, and clk_div reaches the value 7.\n\n Module header:\n\nmodule clk_div(input clk,input tick_8x,input rst,output go);\n [/INST]\n", "output": "parameter RESET_TYPE = 0; \n  reg [2:0] clk_div = 0; \n  always @ (posedge clk) begin \n  if (rst) begin \n  if (RESET_TYPE == 0) begin \n  clk_div <= 0; \n  end else begin \n  clk_div <= 4; \n  end \n  end else if (tick_8x) begin \n  clk_div <= clk_div + 1; \n  end \n  end \n  assign go = !rst & tick_8x & clk_div == 3'b111; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a sequence detector finite state machine (FSM) that searches for a specific pattern in the input data stream. The FSM has seven states labeled S0 to S6 and transitions based on the input data_in. When the sequence is detected, the output data_out is set to 1, otherwise it is set to 0. The FSM transitions through the states based on the current state and the input data_in, and it resets to the initial state S0 on a reset signal.\n\n Module header:\n\nmodule sequence_detector_fsm(data_out, state, reset, data_in, clk);\n [/INST]\n", "output": "output data_out; \n output reg [2:0] state; \n input reset, data_in, clk; \n parameter FOUND = 1'b1, \n  NOT_FOUND = 1'b0; \n parameter S0 = 3'd0, \n  S1 = 3'd1, \n  S2 = 3'd2, \n  S3 = 3'd3, \n  S4 = 3'd4, \n  S5 = 3'd5, \n  S6 = 3'd6; \n reg this_data_in; \n reg [2:0] next_state; \n always @(posedge clk or posedge reset) begin \n  if (reset) begin \n  state <= S0; \n  this_data_in <= 1'b0; \n  end else begin \n  state <= next_state; \n  this_data_in <= data_in; \n  end \n end \n assign data_out = (state == S6 ? FOUND : NOT_FOUND); \n always @(state, this_data_in) begin \n  case (state) \n  S0: next_state = (this_data_in ? S1 : S0); \n  S1: next_state = (this_data_in ? S1 : S2); \n  S2: next_state = (this_data_in ? S3 : S0); \n  S3: next_state = (this_data_in ? S1 : S4); \n  S4: next_state = (this_data_in ? S5 : S0); \n  S5: next_state = (this_data_in ? S6 : S4); \n  S6: next_state = (this_data_in ? S1 : S2); \n  default: next_state = S0; \n  endcase \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a memory register that takes inputs rm, mod, and sovr_pr and provides outputs base, index, and seg. It uses a case statement to determine the values of base, index, and s based on the value of rm and mod. The value of seg is determined based on the value of sovr_pr. The module implements the logic for selecting the memory register based on the input values and sets the appropriate outputs accordingly.\n\n Module header:\n\nmodule memory_regs (input [2:0] rm,input [1:0] mod,input [2:0] sovr_pr,output reg [3:0] base,output reg [3:0] index,output [1:0] seg);\n [/INST]\n", "output": "reg [1:0] s; \n  assign seg = sovr_pr[2] ? sovr_pr[1:0] : s; \n  always @(rm or mod) \n  case (rm) \n  3'b000: begin base <= 4'b0011; index <= 4'b0110; s <= 2'b11; end \n  3'b001: begin base <= 4'b0011; index <= 4'b0111; s <= 2'b11; end \n  3'b010: begin base <= 4'b0101; index <= 4'b0110; s <= 2'b10; end \n  3'b011: begin base <= 4'b0101; index <= 4'b0111; s <= 2'b10; end \n  3'b100: begin base <= 4'b1100; index <= 4'b0110; s <= 2'b11; end \n  3'b101: begin base <= 4'b1100; index <= 4'b0111; s <= 2'b11; end \n  3'b110: begin base <= mod ? 4'b0101 : 4'b1100; index <= 4'b1100; \n  s <= mod ? 2'b10 : 2'b11; end \n  3'b111: begin base <= 4'b0011; index <= 4'b1100; s <= 2'b11; end \n  endcase \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a 36-bit FIFO with enqueue and dequeue functionality. The module interfaces with input and output signals for enqueuing and dequeuing, and includes control signals for ready, valid, and full/empty status. The module instantiates a FIFO component with specific configuration parameters, such as ALMOST_FULL_OFFSET and ALMOST_EMPTY_OFFSET, to manage the FIFO behavior. The module also includes a synchronous reset functionality for initialization.\n\n Module header:\n\nmodule Fifo36E1TestSuite_UserTop_1(input deqClk, input enqClk, input reset,output io_enq_ready,input io_enq_valid,input [71:0] io_enq_bits,input io_deq_ready,output io_deq_valid,output[71:0] io_deq_bits,output[8:0] io_count);\n [/INST]\n", "output": "wire[7:0] T0; \n  wire[63:0] T1; \n  wire[71:0] T2; \n  wire T3; \n  wire T4; \n  wire[63:0] testFifo_io_dout; \n  wire[7:0] testFifo_io_dop; \n  wire testFifo_io_full; \n  wire testFifo_io_empty; \n `ifndef SYNTHESIS \n `endif \n  assign T0 = io_enq_bits[7:0]; \n  assign T1 = io_enq_bits[71:8]; \n  assign io_deq_bits = T2; \n  assign T2 = {testFifo_io_dout, testFifo_io_dop}; \n  assign io_deq_valid = T3; \n  assign T3 = testFifo_io_empty ^ 1'h1; \n  assign io_enq_ready = T4; \n  assign T4 = testFifo_io_full ^ 1'h1; \n Fifo36E1 # (.ALMOST_FULL_OFFSET(500),.ALMOST_EMPTY_OFFSET(100),.FIRST_WORD_FALL_THROUGH(TRUE),.DO_REG(1),.DATA_WIDTH(72),.FIFO_MODE(\"FIFO36\"),.EN_SYN(FALSE),.SRVAL(0),.INIT(0)) testFifo(.deqClk(deqClk), .enqClk(enqClk), .RST(reset),.io_din( T1 ),.io_dip( T0 ),.io_wren( io_enq_valid ),.io_rden( io_deq_ready ),.io_dout( testFifo_io_dout ),.io_dop( testFifo_io_dop ),.io_full( testFifo_io_full ),.io_empty( testFifo_io_empty )); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"integrator\" is a digital circuit that performs integration on an input signal. It takes in clock, reset, enable, rate, strobe_in, and signal_in, and outputs strobe_out and the integrated signal in signal_out.\n\nThe module has a bitwidth parameter \"bw\" and a maximum bit gain parameter \"maxbitgain\". It contains an accumulator, a dump register, and a shifter to perform the integration. It also extends the input signal using sign extension and delays the output by one clock cycle.\n\nThe integration process is controlled by the clock and enable signals, and is triggered by the strobe_in signal. When the strobe_out signal is low, it accumulates the extended input signal, and when strobe_out is high, it dumps the accumulator and sets it to the input signal.\n\nOverall, the module integrates the input signal based on the specified parameters and outputs the integrated signal after a one-clock cycle delay.\n\n Module header:\n\nmodule integrator ( clock,reset,enable,rate,strobe_in,strobe_out,signal_in,signal_out);\n [/INST]\n", "output": "parameter bw = 16; \n  parameter maxbitgain = 8; \n  input clock; \n  input reset; \n  input enable; \n  input [7:0] rate; \n  input strobe_in; \n  input strobe_out; \n  input [bw-1:0] signal_in; \n  wire [bw-1:0] signal_out_unreg; \n  output [bw-1:0] signal_out; \n  reg [bw-1:0] signal_out; \n  wire [bw+maxbitgain-1:0] signal_in_ext; \n  reg [bw+maxbitgain-1:0] accum; \n  reg [bw+maxbitgain-1:0] dump; \n  sign_extend #(bw,bw+maxbitgain) \n  ext_input (.in(signal_in),.out(signal_in_ext)); \n  always @(posedge clock) \n  if (reset | ~enable) \n  begin \n  accum <= 0; \n  dump <= 0; \n  end \n  else if (enable && strobe_in) \n  if (~strobe_out) \n  accum <= accum + signal_in_ext; \n  else \n  begin \n  dump <= accum; \n  accum <= signal_in_ext; \n  end \n  integ_shifter #(bw) \n  shifter(rate,dump,signal_out_unreg); \n  always @(posedge clock) \n  signal_out <= #1 signal_out_unreg; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a RAM (Random Access Memory) with configurable parameters such as elementWidth, elementCount, depth, and addrWidth. It consists of a 2D array of registers to store data, and it updates the RAM on the positive edge of the clock signal. The module allows for simultaneous reading and writing of data to the RAM and has separate write and read addresses. The module also contains an output q which returns the data stored at the read address.\n\n Module header:\n\nmodule ram #(parameter elementWidth = 32, parameter elementCount = 8, parameter depth = 256, parameter addrWidth = log2(depth)) (input clk, input [(elementWidth-1):0] data[0:(elementCount-1)], input [(addrWidth-1):0] write_addr, input [(addrWidth-1):0] read_addr, input we, output [(elementWidth-1):0] q[0:(elementCount-1)]);\n [/INST]\n", "output": "reg [(elementWidth-1):0] ram[0:(depth-1)][0:(elementCount-1)]; \n  always @ (posedge clk) begin \n  if (we) \n  ram[write_addr] = data; \n  q <= ram[read_addr]; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `rs_fe1_pre_dec` has three inputs: `addr_i`, `pre_dec_o`, and `pre_dec_err_o`. The `addr_i` input is used to determine the `pre_dec_o` and `pre_dec_err_o` outputs. The `pre_dec` and `pre_dec_err` are registers that are used to hold the values of `pre_dec_o` and `pre_dec_err_o`, respectively. The `pre_dec_o` output is assigned the value of the `pre_dec` register, and the `pre_dec_err_o` output is assigned the value of the `pre_dec_err` register.\n\nThe main functionality of this module is the pre-decoder logic which operates based on the value of `addr_i`. It contains a case statement which sets the value of `pre_dec` and `pre_dec_err` based on specific patterns of `addr_i[5:2]`. If `addr_i[5:2]` matches certain values, the `pre_dec` and `pre_dec_err` are updated accordingly.\n\nFor specific combinations of `addr_i[5:2]`, `pre_dec` is set to either 0 or 1. If `addr_i[5:2]` does not match any of the specific combinations, then `pre_dec` is set to 0 and `pre_dec_err` is set to 1.\n\nIn summary, this module essentially implements a pre-decoder logic based on specific patterns of the `addr_i` input to set the `pre_dec_o` and `pre_dec_err_o` outputs.\n\n Module header:\n\nmodule rs_fe1_pre_dec (input wire [13:0] addr_i,output wire pre_dec_o,output wire pre_dec_err_o);\n [/INST]\n", "output": "parameter N_DOMAINS = 2; \n  reg pre_dec; \n  reg pre_dec_err; \n  assign pre_dec_o = pre_dec; \n  assign pre_dec_err_o = pre_dec_err; \n  always @(addr_i) begin \n  pre_dec = 0; \n  pre_dec_err = 0; \n  case (addr_i[5:2]) \n  'h0, 'h8, 'ha: pre_dec = 0; \n  'h1, 'h2, 'h3, 'h4, 'h5, 'h6, 'h7: pre_dec = 1; \n  default: begin \n  pre_dec = 0; \n  pre_dec_err = 1; \n  end \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, \"arriaii_termination_logic,\" implements a shift register that is updated on the positive edge of the termination clock when the termination select input is high. The 16-bit termination control output is driven by the shift register. The shift register is initialized to 0 and shifts in the termination data when the termination select is high.\n\n Module header:\n\nmodule arriaii_termination_logic(terminationclock,terminationdata,terminationselect,terminationcontrol);\n [/INST]\n", "output": "parameter lpm_type = \"arriaii_termination_logic\"; \n  input terminationclock; \n  input terminationselect; \n  input terminationdata; \n  output [15:0] terminationcontrol; \n  reg [15:0] shift_reg; \n  assign terminationcontrol = shift_reg; \n  initial \n  shift_reg = 16'b0; \n  always @(posedge terminationclock) \n  if (terminationselect == 1'b1) \n  shift_reg <= {shift_reg[14:0], terminationdata}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module COUNTER implements a counter with a specified number of bits. It has a clock input, a reset input, and an output for the counter value. When the reset is active, the counter value is set to zero, and it increments by 1 on each clock cycle when the reset is not active.\n\n Module header:\n\nmodule COUNTER(CLOCK_I, nARST_I, COUNT_O);\n [/INST]\n", "output": "parameter CBITS = 3; \n input CLOCK_I; \n input nARST_I; \n output[CBITS-1:0] COUNT_O; \n reg[CBITS-1:0] COUNT_O; \n always @(posedge CLOCK_I or negedge nARST_I) \n  if(nARST_I==1'b0) \n  COUNT_O <= {CBITS{1'b0}}; \n  else \n  COUNT_O <= COUNT_O + 1; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe module `InstrucMemoryHardcoded` is an instruction memory that stores specific 32-bit data based on the address input. The memory has a width of 8 bits and a depth of 256. It includes read and write enable signals, a clock input, address input, data input, and data output. \n\nThe module uses a case statement to map each address to a specific 32-bit data output. When the address input matches a specified value, the corresponding 32-bit data is assigned to the output. If the address input does not match any specified value, a default value is assigned to the output.\n\nThe output data is synchronized with the clock signal, and the data output is assigned to the variable `Data`.\n\n Module header:\n\nmodule InstrucMemoryHardcoded (Clk, rdEn, wrEn, addr, wrData, Data);\n [/INST]\n", "output": "parameter WIDTH = 8; \n  parameter DEPTH = 256; \n  input Clk; \n  input rdEn, wrEn; \n  input [WIDTH-1:0] wrData; \n  input [7:0] addr; \n  output [WIDTH-1:0] Data; \n  reg [WIDTH-1:0] data_out; \n  always @ (posedge Clk) \n  begin : INST_MEMORY \n  case (addr) \n  8'h0: data_out <= 32'h0c_00_09_xx; \n  8'h1: data_out <= 32'h0c_01_04_xx; \n  8'h2: data_out <= 32'h0c_02_00_xx; \n  8'h3: data_out <= 32'h0c_c0_00_xx; \n  8'h4: data_out <= 32'h0c_c1_01_xx; \n  8'h5: data_out <= 32'h0c_c4_04_xx; \n  8'h6: data_out <= 32'h08_10_xx_xx; \n  8'h10: data_out <= 32'h01_00_00_01; \n  8'h11: data_out <= 32'h0b_14_00_xx; \n  8'h12: data_out <= 32'h00_02_02_c1; \n  8'h13: data_out <= 32'h08_10_xx_xx; \n  8'h14: data_out <= 32'h00_03_00_01; \n  8'h15: data_out <= 32'h0d_fa_03_xx; \n  8'h16: data_out <= 32'h02_fb_03_c4; \n  8'h17: data_out <= 32'h0d_fc_02_xx; \n  8'h18: data_out <= 32'h02_fd_02_c4; \n  8'h19: data_out <= 32'h0f_xx_xx_xx; \n  8'h20: data_out <= 32'h09_22_e4_xx; \n  8'h21: data_out <= 32'h0d_00_e0_xx; \n  8'h22: data_out <= 32'h09_24_e1_xx; \n  8'h23: data_out <= 32'h0d_01_e0_xx; \n  8'h24: data_out <= 32'h0d_fa_01_xx; \n  8'h25: data_out <= 32'h02_fb_01_c4; \n  8'h26: data_out <= 32'h0d_fc_00_xx; \n  8'h27: data_out <= 32'h02_fd_00_c4; \n  8'h28: data_out <= 32'h0a_10_e3_xx; \n  8'h29: data_out <= 32'h08_20_xx_xx; \n  default: data_out <= 32'hxx_xx_xx_xx; \n  endcase \n  end \n  assign Data = data_out; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an altpriority encoder, which takes a 64-bit input data and produces a 6-bit output q. The module instantiates two sub-modules, altpriority_encoder10 and altpriority_encoder9, for encoding the upper and lower halves of the input data, respectively. The outputs from these two sub-modules are combined based on priority logic, and the result is assigned to the output q.\n\n Module header:\n\nmodule acl_fp_uitofp_altpriority_encoder_0c6 (data,q) ;\n [/INST]\n", "output": "input [63:0] data; \n  output [5:0] q; \n  wire [4:0] wire_altpriority_encoder10_q; \n  wire wire_altpriority_encoder10_zero; \n  wire [4:0] wire_altpriority_encoder9_q; \n  acl_fp_uitofp_altpriority_encoder_qf8 altpriority_encoder10 \n (.data(data[63:32]),.q(wire_altpriority_encoder10_q),.zero(wire_altpriority_encoder10_zero)); \n  acl_fp_uitofp_altpriority_encoder_q08 altpriority_encoder9 \n (.data(data[31:0]),.q(wire_altpriority_encoder9_q)); \n  assign \n  q = {(~ wire_altpriority_encoder10_zero), (({5{wire_altpriority_encoder10_zero}} & wire_altpriority_encoder9_q) | ({5{(~ wire_altpriority_encoder10_zero)}} & wire_altpriority_encoder10_q))}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is designed to control an LCD display. It interfaces with various input and output signals to manage commands, data, and display features. The module includes submodules for handling LCD commands and writing data to the display. It also features assignments for controlling the backlight, display on/off, reset, chip select, and data direction. The module connects these features to the IO pins and effectively manages the flow of data and commands to the LCD display.\n\n Module header:\n\nmodule nh_lcd #(parameter BUFFER_SIZE = 12)(input rst,input clk,output [31:0] debug,input i_enable,input i_reset_display,input i_data_command_mode,input i_enable_tearing,input i_cmd_parameter,input i_cmd_write_stb,input i_cmd_read_stb,input [7:0] i_cmd_data,output [7:0] o_cmd_data,output o_cmd_finished,input i_backlight_enable,input i_write_override,input i_chip_select,input [31:0] i_num_pixels,output [1:0] o_fifo_rdy,input [1:0] i_fifo_act,input i_fifo_stb,output [23:0] o_fifo_size,input [31:0] i_fifo_data,output o_backlight_enable,output o_register_data_sel,output o_write_n,output o_read_n,inout [7:0] io_data,output o_cs_n,output o_reset_n,input i_tearing_effect,output o_display_on);\n [/INST]\n", "output": "wire [7:0] w_data_out; \n wire [7:0] w_data_in; \n wire w_cmd_write; \n wire w_cmd_read; \n wire [7:0] w_cmd_data; \n wire w_cmd_cmd_mode; \n wire w_cmd_data_out_en; \n wire w_data_dir; \n wire w_data_cmd_mode; \n wire [7:0] w_data_data; \n wire w_data_write; \n wire w_data_read; \n wire w_data_data_out_en; \n nh_lcd_command lcd_commander (.rst (rst ),.clk (clk ),.i_enable (i_enable ),.i_cmd_parameter (i_cmd_parameter ),.i_cmd_write_stb (i_cmd_write_stb ),.i_cmd_read_stb (i_cmd_read_stb ),.i_cmd_data (i_cmd_data ),.o_cmd_data (o_cmd_data ),.o_data_out_en (w_cmd_data_out_en ),.o_cmd_finished (o_cmd_finished ),.o_cmd_mode (w_cmd_cmd_mode ),.o_write (w_cmd_write ),.o_read (w_cmd_read ),.o_data_out (w_cmd_data ),.i_data_in (w_data_in )); \n nh_lcd_data_writer #(.BUFFER_SIZE (BUFFER_SIZE ))lcd_data_writer(.rst (rst ),.clk (clk ),.debug (debug ),.i_enable (i_enable ),.i_enable_tearing (i_enable_tearing ),.i_num_pixels (i_num_pixels ),.o_fifo_rdy (o_fifo_rdy ),.i_fifo_act (i_fifo_act ),.i_fifo_stb (i_fifo_stb ),.o_fifo_size (o_fifo_size ),.i_fifo_data (i_fifo_data ),.o_cmd_mode (w_data_cmd_mode ),.o_data_out (w_data_data ),.i_data_in (w_data_in ),.o_write (w_data_write ),.o_read (w_data_read ),.o_data_out_en (w_data_data_out_en ),.i_tearing_effect (i_tearing_effect )); \n assign o_backlight_enable = i_backlight_enable; \n assign o_display_on = i_enable; \n assign o_reset_n = ~i_reset_display; \n assign o_cs_n = ~i_chip_select; \n assign w_data_in = io_data; \n assign o_register_data_sel = (i_data_command_mode) ? w_data_cmd_mode : w_cmd_cmd_mode; \n assign o_write_n = (i_data_command_mode) ? ~w_data_write : ~w_cmd_write; \n assign o_read_n = (i_data_command_mode) ? ~w_data_read : ~w_cmd_read; \n assign w_data_dir = (i_data_command_mode) ? w_data_data_out_en : w_cmd_data_out_en; \n assign io_data = (w_data_dir) ? (i_data_command_mode) ? \n  w_data_data : w_cmd_data : \n  8'hZZ; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes six input signals A, B, C, D, E, and F, and uses them to compute two complex logic expressions X and Y. The output X is calculated using a combination of AND and OR operations on the input signals, while the output Y is the logical negation of the expression used for X.\n\n Module header:\n\nmodule Problem2(input A,input B,input C,input D,input E,input F,output X,output Y);\n [/INST]\n", "output": "assign X = (A & B & C & D) | (A & B & C & E) | (A & B & D & E) | (C & D & A & E) | (C & D & B & E) | (A & B & C & F) | (A & B & D & F) | (C & D & A & F) | (C & D & B & F) | (C & D & E & F) | (A & B & E & F) | (B & D & E & F) | (A & D & E & F) | (B & C & E & F) | (A & C & E & F); \n  assign Y = ~((A & B & C & D) | (A & B & C & E) | (A & B & D & E) | (C & D & A & E) | (C & D & B & E) | (A & B & C & F) | (A & B & D & F) | (C & D & A & F) | (C & D & B & F) | (C & D & E & F) | (A & B & E & F) | (B & D & E & F) | (A & D & E & F) | (B & C & E & F) | (A & C & E & F)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `i2c_slave_reduced` is designed to implement the functionality of an I2C slave device. It takes input signals for reset, SCL clock, and a clock signal, as well as an inout SDA line and outputs a signal for an LED. The module includes logic for handling the SDA line, a clock counter, and the clock signal. The clock and reset logic is implemented using an always block, which updates the clock counter and toggles the clock signal based on the input clock and reset signals. The module also instantiates the `i2c_slave_op_reduced` module, passing the necessary input and output signals to handle the I2C slave operations.\n\n Module header:\n\nmodule i2c_slave_reduced(reset_n,sda,scl,clock,led);\n [/INST]\n", "output": "input reset_n; \n input scl; \n inout sda; \n input clock; \n output led; \n wire sda_en; \n wire sda_in; \n wire sda_out; \n assign sda_in = (!sda_en) ? sda : 1'bz; \n assign sda = sda_en ? ((sda_out == 1'b1)? 1'bz:1'b0) : 1'bz; \n reg [3:0] clk_count; \n reg clk; \n always @(posedge clock or negedge reset_n) begin \n  if(!reset_n) begin \n  clk_count <= 8'h0; \n  clk <= 1'b0; \n  end \n  else begin \n  if(clk_count < 8'd10) \n  clk_count <= clk_count + 1'b1; \n  else begin \n  clk_count <= 8'h0; \n  clk <= ~clk; \n  end \n  end \n end \n i2c_slave_op_reduced i2c_slave_op_reduced_inst(.reset_n(reset_n),.clock(clk),.sda_out(sda_out),.sda_in(sda_in),.sda_en(sda_en),.scl(scl),.led(led)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module performs a bidirectional arithmetic shift operation on the data input based on the distance and direction inputs. The shift is either right (>>>) or left (<<) depending on the direction input and the distance specified. The result is assigned to the output.\n\n Module header:\n\nmodule arithshiftbidir(distance,data,direction,result);\n [/INST]\n", "output": "parameter lpm_type = \"LPM_CLSHIFT\"; \n  parameter lpm_shifttype = \"ARITHMETIC\"; \n  parameter lpm_width = 32; \n  parameter lpm_widthdist = 5; \n  input wire [lpm_widthdist-1:0] distance; \n  input wire [lpm_width-1 :0] data; \n  input wire direction; \n  output wire [lpm_width-1 :0] result; \n  assign result = direction ? data >>> distance : data << distance; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes input clock signals and data and processes them. It assigns the input clock signals to the internal signal the_clks and processes the data signal based on the positive edge of the i_clk0 input. It also instantiates another module t1 with specified inputs.\n\n Module header:\n\nmodule t2(input [2:0] i_clks,input i_clk0,input i_clk1,input i_clk2,input i_data);\n [/INST]\n", "output": "logic [3:0] the_clks; \n  logic data_q; \n  assign the_clks[3] = i_clk1; \n  assign the_clks[2] = i_clk2; \n  assign the_clks[1] = i_clk1; \n  assign the_clks[0] = i_clk0; \n  always @(posedge i_clk0) begin \n  data_q <= i_data; \n  end \n  t1 t1 \n (.i_clks (the_clks),.i_clk0 (i_clk0),.i_clk1 (i_clk1)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a 3D fog effect. It takes inputs like clock signals, control signals, addresses, data, and fog parameters. It processes these inputs and produces fog factors and other outputs to create the fog effect. It utilizes various internal signals and registers to perform the necessary computations and data manipulations to generate the fog effect. The module includes logic for updating fog factors and Z values based on different conditions and signals. The fog factors and other outputs are then used in the fog table and further calculations to create the desired fog effect.\n\n Module header:\n\nmodule de3d_tfog (input de_clk,input hb_csn,input hb_tfog_en,input hb_wstrb,input [6:2] hb_addr,input [7:0] hb_ben,input [31:0] hb_din,input [13:0] zvalue,input pc_busy,output [31:0] hb_dout,output [7:0] fog_factor);\n [/INST]\n", "output": "reg [8:0] z_diff_d; \n reg [7:0] low_factor_d, low_factor_dd; \n reg [7:0] fog_factor; \n reg [7:0] zvalue_d; \n reg [8:0] z_add_d; \n wire [5:0] z_low, z_hi; \n wire [8:0] z_diff; \n wire [18:0] z_add; \n wire [8:0] fog_factor_s; \n wire [7:0] low_factor, \n  high_factor; \n wire [7:0] fog64; \n wire [7:0] high_factor_add; \n always @(posedge de_clk) begin \n  if (!busy3) fog_factor = fog_factor_s[7:0]; \n  if (!busy2) begin \n  z_add_d = z_add[18:10]; \n  low_factor_dd = low_factor_d; \n  end \n  if (!pc_busy) begin \n  z_diff_d = z_diff; \n  low_factor_d = low_factor; \n  zvalue_d = zvalue[7:0]; \n  end \n end \n assign z_low = zvalue[13:8]; \n assign z_hi = z_low + 1; \n assign high_factor_add = (&z_low) ? fog64 : high_factor; \n DED_FOG_TABLE FOG_TABLE \n ((~hb_csn && hb_tfog_en),hb_wstrb,hb_addr,hb_ben,hb_din,z_low,z_hi,hb_dout,low_factor,high_factor,fog64); \n assign z_diff = high_factor_add - low_factor; \n MULT9SX10U MULT9sx10u (z_add, z_diff_d, {zvalue_d,2'b0}); \n assign fog_factor_s = {1'b0,low_factor_dd} + z_add_d; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, NPM_Toggle_POR, is a finite state machine that generates signals oReady, oLastStep, and oPO_Reset based on the inputs iSystemClock, iReset, and iStart. It includes a 4-bit state machine and uses a timer to control the state transitions. The module also has logic to handle the transition of the state machine based on the input signals. Additionally, it has registers to hold the current and next state values and a timer to control the state transitions. The output signals are assigned based on the current state and the completion of a specific operation.\n\n Module header:\n\nmodule NPM_Toggle_POR (iSystemClock ,iReset ,oReady ,oLastStep ,iStart ,oPO_Reset);\n [/INST]\n", "output": "input iSystemClock ; \n  input iReset ; \n  output oReady ; \n  output oLastStep ; \n  input iStart ; \n  output oPO_Reset ; \n  parameter POR_FSM_BIT = 4; \n  parameter POR_RESET = 4'b0001; \n  parameter POR_READY = 4'b0010; \n  parameter POR_RFRST = 4'b0100; \n  parameter POR_RLOOP = 4'b1000; \n  reg [POR_FSM_BIT-1:0] rPOR_cur_state ; \n  reg [POR_FSM_BIT-1:0] rPOR_nxt_state ; \n  reg rReady ; \n  reg [3:0] rTimer ; \n  wire wJOBDone ; \n  reg rPO_Reset ; \n  assign wJOBDone = (4'b1001 == rTimer[3:0]); \n  always @ (posedge iSystemClock, posedge iReset) begin \n  if (iReset) begin \n  rPOR_cur_state <= POR_RESET; \n  end else begin \n  rPOR_cur_state <= rPOR_nxt_state; \n  end \n  end \n  always @ ( * ) begin \n  case (rPOR_cur_state) \n  POR_RESET: begin \n  rPOR_nxt_state <= POR_READY; \n  end \n  POR_READY: begin \n  rPOR_nxt_state <= (iStart)? POR_RFRST:POR_READY; \n  end \n  POR_RFRST: begin \n  rPOR_nxt_state <= POR_RLOOP; \n  end \n  POR_RLOOP: begin \n  rPOR_nxt_state <= (wJOBDone)? ((iStart)? POR_RFRST:POR_READY):POR_RLOOP; \n  end \n  default: \n  rPOR_nxt_state <= POR_READY; \n  endcase \n  end \n  always @ (posedge iSystemClock, posedge iReset) begin \n  if (iReset) begin \n  rReady <= 0; \n  rTimer[3:0] <= 0; \n  rPO_Reset <= 0; \n  end else begin \n  case (rPOR_nxt_state) \n  POR_RESET: begin \n  rReady <= 0; \n  rTimer[3:0] <= 0; \n  rPO_Reset <= 0; \n  end \n  POR_READY: begin \n  rReady <= 1; \n  rTimer[3:0] <= 0; \n  rPO_Reset <= 0; \n  end \n  POR_RFRST: begin \n  rReady <= 0; \n  rTimer[3:0] <= 4'b0000; \n  rPO_Reset <= 1; \n  end \n  POR_RLOOP: begin \n  rReady <= 0; \n  rTimer[3:0] <= rTimer[3:0] + 1'b1; \n  rPO_Reset <= 1; \n  end \n  endcase \n  end \n  end \n  assign oReady = rReady | wJOBDone ; \n  assign oLastStep = wJOBDone ; \n  assign oPO_Reset = rPO_Reset ; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a Booth multiplier. It consists of registers for the multiplicand, multiplier, product, and control signals, as well as an ALU for addition and subtraction. The module uses a clock and reset signal for synchronization. The product is computed using shifts, additions, and subtractions based on the multiplier and multiplicand, and the result is stored in the product output. The module operates on each clock cycle and resets when the reset signal is asserted.\n\n Module header:\n\nmodule boothMultiplier(input [3:0] multiplicand,input [3:0] multiplier,output [7:0] product,input clock,input reset);\n [/INST]\n", "output": "reg [3:0] A, Q, M; \n  reg Q_1; \n  reg [3:0] count; \n  wire [3:0] sum, difference; \n  always @(posedge clock) \n  begin \n  if (reset) begin \n  A <= 4'b0; \n  M <= multiplicand; \n  Q <= multiplier; \n  Q_1 <= 1'b0; \n  count <= 3'b0; \n  end \n  else begin \n  case ({Q[0], Q_1}) \n  2'b01 : {A, Q, Q_1} <= {sum[3], sum, Q}; \n  2'b10 : {A, Q, Q_1} <= {difference[3], difference, Q}; \n  default: {A, Q, Q_1} <= {A[3], A, Q}; \n  endcase \n  count <= count + 1; \n  end \n  end \n  alu adder (A, M, 0,sum); \n  alu subtracter (A, ~M, 1,difference); \n  assign product = {A, Q}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, fmrv32im_axi_gpio_ctrl, implements a GPIO controller with AXI interface. It has input and output signals for reset, clock, chip select, read and write operations, address, byte enables, write data, read data, input from GPIO, and output to GPIO.\n\nThe module uses control signals to enable write and read operations, and sets the output acknowledge signal accordingly. It maintains internal registers to store GPIO output and read data.\n\nDuring a write operation, it updates the GPIO output based on the write address and data. During a read operation, it selects the read data based on the read address and sets the read acknowledge signal. It also passes the read data to the output.\n\nThe module effectively interfaces with an AXI bus to control GPIO input and output operations based on the provided control signals and addresses.\n\n Module header:\n\nmodule fmrv32im_axi_gpio_ctrl (input RST_N,input CLK,input LOCAL_CS,input LOCAL_RNW,output LOCAL_ACK,input [31:0] LOCAL_ADDR,input [3:0] LOCAL_BE,input [31:0] LOCAL_WDATA,output [31:0] LOCAL_RDATA,input [31:0] GPIO_I,output [31:0] GPIO_OT);\n [/INST]\n", "output": "localparam A_OUT = 8'h00; \n  localparam A_IN = 8'h04; \n  wire wr_ena, rd_ena, wr_ack; \n  reg rd_ack; \n  reg [31:0] reg_gpio_o; \n  reg [31:0] reg_rdata; \n  assign wr_ena = (LOCAL_CS & ~LOCAL_RNW)?1'b1:1'b0; \n  assign rd_ena = (LOCAL_CS & LOCAL_RNW)?1'b1:1'b0; \n  assign wr_ack = wr_ena; \n  always @(posedge CLK) begin \n  if(!RST_N) begin \n  reg_gpio_o <= 32'd0; \n  end else begin \n  if(wr_ena) begin \n  case(LOCAL_ADDR[7:0] & 8'hFC) \n  A_OUT: begin \n  reg_gpio_o <= LOCAL_WDATA; \n  end \n  default: begin \n  end \n  endcase \n  end \n  end \n  end \n  always @(posedge CLK) begin \n  if(!RST_N) begin \n  reg_rdata[31:0] <= 32'd0; \n  rd_ack <= 1'b0; \n  end else begin \n  rd_ack <= rd_ena; \n  if(rd_ena) begin \n  case(LOCAL_ADDR[7:0] & 8'hFC) \n  A_OUT: begin \n  reg_rdata[31:0] <= reg_gpio_o[31:0]; \n  end \n  A_IN: begin \n  reg_rdata[31:0] <= GPIO_I; \n  end \n  default: begin \n  reg_rdata[31:0] <= 32'd0; \n  end \n  endcase \n  end else begin \n  reg_rdata[31:0] <= 32'd0; \n  end \n  end \n  end \n  assign LOCAL_ACK = (wr_ack | rd_ack); \n  assign LOCAL_RDATA[31:0] = reg_rdata[31:0]; \n  assign GPIO_OT = reg_gpio_o; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes four input signals A, B, C, and D, and based on their values, assigns specific values to output signals F, G, and H. The value assigned to each output depends on the value of the 4-bit signal select, which is derived from the input signals A, B, C, and D. The module uses a case statement to determine the values of F, G, and H based on the value of select, which is determined by the input signals.\n\n Module header:\n\nmodule Problem4(input A,input B,input C,input D,output reg F,output reg G,output reg H);\n [/INST]\n", "output": "reg [3:0] select; \n  always @ (A or B or C or D) \n  begin \n  select = {A, B, C, D}; \n  case(select) \n  4'b0000: begin \n  F = 1; \n  G = 0; \n  H = 1; \n  end \n  4'b0001: begin \n  F = 0; \n  G = 1; \n  H = 0; \n  end \n  4'b0010: begin \n  F = 1; \n  G = 0; \n  H = 0; \n  end \n  4'b0011: begin \n  F = 0; \n  G = 0; \n  H = 1; \n  end \n  4'b0100: begin \n  F = 0; \n  G = 1; \n  H = 1; \n  end \n  4'b0101: begin \n  F = 1; \n  G = 1; \n  H = 0; \n  end \n  4'b0110: begin \n  F = 0; \n  G = 0; \n  H = 0; \n  end \n  4'b0111: begin \n  F = 1; \n  G = 0; \n  H = 1; \n  end \n  4'b1000: begin \n  F = 1; \n  G = 1; \n  H = 0; \n  end \n  4'b1001: begin \n  F = 0; \n  G = 0; \n  H = 1; \n  end \n  4'b1010: begin \n  F = 1; \n  G = 0; \n  H = 0; \n  end \n  4'b1011: begin \n  F = 1; \n  G = 1; \n  H = 1; \n  end \n  4'b1100: begin \n  F = 0; \n  G = 0; \n  H = 0; \n  end \n  4'b1101: begin \n  F = 0; \n  G = 1; \n  H = 1; \n  end \n  4'b1110: begin \n  F = 1; \n  G = 1; \n  H = 1; \n  end \n  4'b1111: begin \n  F = 0; \n  G = 1; \n  H = 0; \n  end \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module is a serial data receiver with a 4-phase clock. It receives a single bit of data on each clock cycle and outputs the received byte when the data is valid. The receiver goes through a state machine to detect the start and end of the data, and it shifts in the bits of the data as the clock phases change. It also handles error detection and generates valid and error signals based on the received data.\n\n Module header:\n\nmodule SerialReceiver(clk_x4,rst_x,i_rx,o_data,o_valid,o_error);\n [/INST]\n", "output": "input clk_x4; \n  input rst_x; \n  input i_rx; \n  output [7:0] o_data; \n  output o_valid; \n  output o_error; \n  reg [1:0] r_phase; \n  reg [3:0] r_state; \n  reg [7:0] r_data; \n  wire w_phase_latch; \n  wire w_phase_shift; \n  wire w_phase_next; \n  wire w_valid; \n  wire w_stop; \n  localparam S_IDLE = 4'b0000; \n  localparam S_START = 4'b0001; \n  localparam S_BIT0 = 4'b0011; \n  localparam S_BIT1 = 4'b0010; \n  localparam S_BIT2 = 4'b0110; \n  localparam S_BIT3 = 4'b0111; \n  localparam S_BIT4 = 4'b0101; \n  localparam S_BIT5 = 4'b0100; \n  localparam S_BIT6 = 4'b1100; \n  localparam S_BIT7 = 4'b1101; \n  localparam S_STOP = 4'b1111; \n  assign w_phase_latch = r_phase == 2'b01; \n  assign w_phase_next = r_phase == 2'b10; \n  assign w_phase_shift = r_phase == 2'b11; \n  assign w_valid = (r_state == S_STOP) && w_phase_latch; \n  assign w_stop = i_rx == 1'b1; \n  assign o_data = r_data; \n  assign o_valid = w_valid & w_stop; \n  assign o_error = w_valid & !w_stop; \n  always @ (posedge clk_x4) begin \n  if (w_phase_latch) begin \n  r_data <= { i_rx, r_data[7:1] }; \n  end \n  end \n  always @ (posedge clk_x4 or negedge rst_x) begin \n  if (!rst_x) begin \n  r_phase <= 2'b00; \n  end else begin \n  if (r_state == S_IDLE) begin \n  r_phase <= 2'b00; \n  end else begin \n  r_phase <= r_phase + 2'b01; \n  end \n  end \n  end \n  always @ (posedge clk_x4 or negedge rst_x) begin \n  if (!rst_x) begin \n  r_state <= S_IDLE; \n  end else begin \n  case (r_state) \n  S_IDLE: begin \n  if (i_rx == 1'b0) begin \n  r_state <= S_START; \n  end \n  end \n  S_START: begin \n  if (w_phase_shift) begin \n  r_state <= S_BIT0; \n  end \n  end \n  S_BIT0: begin \n  if (w_phase_shift) begin \n  r_state <= S_BIT1; \n  end \n  end \n  S_BIT1: begin \n  if (w_phase_shift) begin \n  r_state <= S_BIT2; \n  end \n  end \n  S_BIT2: begin \n  if (w_phase_shift) begin \n  r_state <= S_BIT3; \n  end \n  end \n  S_BIT3: begin \n  if (w_phase_shift) begin \n  r_state <= S_BIT4; \n  end \n  end \n  S_BIT4: begin \n  if (w_phase_shift) begin \n  r_state <= S_BIT5; \n  end \n  end \n  S_BIT5: begin \n  if (w_phase_shift) begin \n  r_state <= S_BIT6; \n  end \n  end \n  S_BIT6: begin \n  if (w_phase_shift) begin \n  r_state <= S_BIT7; \n  end \n  end \n  S_BIT7: begin \n  if (w_phase_shift) begin \n  r_state <= S_STOP; \n  end \n  end \n  S_STOP: begin \n  if (w_phase_next) begin \n  r_state <= S_IDLE; \n  end \n  end \n  endcase \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a button debounce logic to stabilize the button input. It utilizes a state machine to transition between waiting, firing, and counting states, and resets the count and button output based on the clock and reset signals. The button output is set to 1 during the firing state, and the count is incremented during the counting state until it reaches the maximum count, at which point the module goes back to the waiting state. The module effectively debounces the button input and ensures a stable button output.\n\n Module header:\n\nmodule button_debounce #(parameter CLK_FREQ = 10_000_000,parameter DEBOUNCE_HZ = 2) (input wire clk,input wire rst_n,input wire btn_in,output reg btn_out);\n [/INST]\n", "output": "localparam COUNT_MAX = CLK_FREQ / DEBOUNCE_HZ; \n localparam S_WAIT = 0; \n localparam S_FIRE = 1; \n localparam S_COUNT = 2; \n reg [$clog2(COUNT_MAX):0] count; \n reg [1:0] state, next_state; \n always @(posedge clk or negedge rst_n) \n  state <= (~rst_n) ? S_WAIT : next_state; \n always @(posedge clk or negedge rst_n) begin \n  if(~rst_n) begin \n  btn_out <= 0; \n  count <= 0; \n  end \n  else begin \n  btn_out <= 0; \n  count <= 0; \n  case(state) \n  S_WAIT : begin \n  end \n  S_FIRE : begin \n  btn_out <= 1; \n  end \n  S_COUNT : begin \n  count <= count + 1; \n  end \n  endcase \n  end \n end \n always @(*) begin \n  case(state) \n  S_WAIT : next_state <= (btn_in) ? S_FIRE : state; \n  S_FIRE : next_state <= S_COUNT; \n  S_COUNT : next_state <= (count > COUNT_MAX - 1) ? S_WAIT : state; \n  default : next_state <= S_WAIT; \n  endcase \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements the Decimal Adjust Accumulator (DAA) operation for a microprocessor. It takes input flags and val, and provides outputs adjust, cdaa, and hdaa. The module contains combinational logic to compute the adjust output based on the values of flags and aa. The module also includes an always block that uses case statements to determine the values of aa, cdaa, and hdaa based on specific combinations of input signals and intermediate wire values. This module essentially carries out the DAA operation and sets the appropriate outputs based on the input flags and val.\n\n Module header:\n\nmodule daa (input [7:0]flags,input [7:0]val,output wire [7:0]adjust,output reg cdaa,output reg hdaa);\n [/INST]\n", "output": "wire h08 = val[7:4] < 9; \n  wire h09 = val[7:4] < 10; \n  wire l05 = val[3:0] < 6; \n  wire l09 = val[3:0] < 10; \n  reg [1:0]aa; \n  assign adjust = ({1'b0, aa[1], aa[1], 2'b0, aa[0], aa[0], 1'b0} ^ {8{flags[1]}}) + flags[1]; \n  always @* begin \n  case({flags[0], h08, h09, flags[4], l09}) \n  5'b00101, 5'b01101: aa = 0; \n  5'b00111, 5'b01111, 5'b01000, 5'b01010, 5'b01100, 5'b01110: aa = 1; \n  5'b00001, 5'b01001, 5'b10001, 5'b10101, 5'b11001, 5'b11101: aa = 2; \n  default: aa = 3; \n  endcase \n  case({flags[0], h08, h09, l09}) \n  4'b0011, 4'b0111, 4'b0100, 4'b0110: cdaa = 0; \n  default: cdaa = 1; \n  endcase \n  case({flags[1], flags[4], l05, l09}) \n  4'b0000, 4'b0010, 4'b0100, 4'b0110, 4'b1110, 4'b1111: hdaa = 1; \n  default: hdaa = 0; \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"vfabric_fpextend\" extends the input data by adding 32 zeros at the end and 3 zeros at the beginning, effectively increasing its width from 32 bits to 64 bits. It also passes the input valid signal as the output valid signal and sets the output stall signal based on the input stall signal.\n\n Module header:\n\nmodule vfabric_fpextend(clock, resetn,i_datain, i_datain_valid, o_datain_stall,o_dataout, i_dataout_stall, o_dataout_valid);\n [/INST]\n", "output": "parameter DATAIN_WIDTH = 32; \n parameter DATAOUT_WIDTH = 64; \n  input clock, resetn; \n  input [DATAIN_WIDTH-1:0] i_datain; \n  input i_datain_valid; \n  output o_datain_stall; \n  output [DATAOUT_WIDTH-1:0] o_dataout; \n  input i_dataout_stall; \n  output o_dataout_valid; \n  assign o_dataout = {i_datain[DATAIN_WIDTH-1], 3'b0, i_datain[30:23], 29'b0, i_datain[22:0]}; \n  assign o_datain_stall = i_dataout_stall; \n  assign o_dataout_valid = i_datain_valid; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"ColorGray2Channels\" takes a gray input and generates three channels as output, with each channel having 8 bits. It uses a generate block to assign the gray input to each channel, splitting it based on the number of channels and the width of each channel. The module uses parameters to specify the width of the color and the number of color channels. It includes a genvar for the loop iteration and uses `define to define high and low indices for the channel assignment within the generate block. Finally, it uses `undef to undefine the indices after the generate block.\n\n Module header:\n\nmodule ColorGray2Channels(gray,channels);\n [/INST]\n", "output": "parameter color_width = 8; \n  parameter color_channels = 3; \n  input[color_width - 1 : 0] gray; \n  output[color_channels * color_width - 1 : 0] channels; \n  genvar i; \n  generate \n  `define h (i + 1) * color_width - 1 \n  `define l i * color_width \n  for (i = 0; i < color_channels; i = i + 1) begin: channel \n  assign channels[`h : `l] = gray; \n  end \n  `undef h \n  `undef l \n  endgenerate \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a round-robin arbiter that selects between two input interfaces and forwards the data to the output interface. It uses a last_grant register to track the last selected input and chooses the next input based on the priority and availability of the inputs. The input and output interfaces have ready and valid signals, as well as data bits. The module operates on the rising edge of the clock signal and has a reset input to initialize the last_grant register. The arbitration logic includes determining the next grant based on input availability and previous grants.\n\n Module header:\n\nmodule RRArbiter(input clk, input reset,output io_in_0_ready,input io_in_0_valid,input [31:0] io_in_0_bits,output io_in_1_ready,input io_in_1_valid,input [31:0] io_in_1_bits,input io_out_ready,output io_out_valid,output[31:0] io_out_bits,output io_chosen);\n [/INST]\n", "output": "wire T0; \n  wire T1; \n  wire T2; \n  wire T3; \n  wire T4; \n  wire T5; \n  wire T6; \n  wire T7; \n  wire T8; \n  wire T9; \n  reg[0:0] last_grant; \n  wire T10; \n  wire T11; \n  wire T12; \n  wire choose; \n  wire T13; \n  wire T14; \n  wire T15; \n  wire T16; \n  wire T17; \n  wire T18; \n  wire T19; \n  wire T20; \n  wire T21; \n  wire T22; \n  wire[31:0] T23; \n  wire[31:0] T24; \n  wire[31:0] T25; \n  wire T26; \n  wire[1:0] T27; \n  wire[2:0] T28; \n  wire[31:0] dvec_1; \n  wire[31:0] T29; \n  wire[31:0] T30; \n  wire T31; \n  wire[31:0] dvec_0; \n  assign io_in_1_ready = T0; \n  assign T0 = T1 && io_out_ready; \n  assign T1 = T20 || T2; \n  assign T2 = ! T3; \n  assign T3 = T19 || io_in_0_valid; \n  assign io_in_0_ready = T4; \n  assign T4 = T5 && io_out_ready; \n  assign T5 = T18 || T6; \n  assign T6 = ! T7; \n  assign T7 = T16 || T8; \n  assign T8 = io_in_1_valid && T9; \n  assign T9 = 1'h1 > last_grant; \n  assign T10 = io_out_valid && io_out_ready; \n  assign io_out_valid = T11; \n  assign T11 = io_in_0_valid || io_in_1_valid; \n  assign T12 = T10 ? choose : last_grant; \n  assign choose = T14 ? 1'h1 : T13; \n  assign T13 = io_in_0_valid ? 1'h0 : 1'h1; \n  assign T14 = io_in_1_valid && T15; \n  assign T15 = 1'h1 > last_grant; \n  assign T16 = io_in_0_valid && T17; \n  assign T17 = 1'h0 > last_grant; \n  assign T18 = 1'h0 > last_grant; \n  assign T19 = T16 || T8; \n  assign T20 = T22 && T21; \n  assign T21 = 1'h1 > last_grant; \n  assign T22 = ! T16; \n  assign io_out_bits = T23; \n  assign T23 = T29 | T24; \n  assign T24 = dvec_1 & T25; \n  assign T25 = {6'h20{T26}}; \n  assign T26 = T27[1'h1]; \n  assign T27 = T28[1'h1:1'h0]; \n  assign T28 = 2'h1 << choose; \n  assign dvec_1 = io_in_1_bits; \n  assign T29 = dvec_0 & T30; \n  assign T30 = {6'h20{T31}}; \n  assign T31 = T27[1'h0]; \n  assign dvec_0 = io_in_0_bits; \n  always @(posedge clk) begin \n  if(reset) begin \n  last_grant <= 1'h0; \n  end else if(T10) begin \n  last_grant <= T12; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module defines a set of general-purpose registers using a RegisterFile instance. It has inputs for data, address selection, file selection, read/write control, and clock signal. The module uses a 4-bit selector to choose one of the RegisterFile instances based on the file_sel input. The output registers out_a and out_b are assigned values from the corresponding RegisterFile instance. The module initializes the general-purpose register file select signal to 1111 and updates it based on the file_sel input using a case statement.\n\n Module header:\n\nmodule General_Purpose_Regs(input[31:0] d_in,output[31:0] out_a,output[31:0] out_b,input[4:0] addr_a,input[4:0] addr_b,input[1:0] file_sel,input rw,input clk);\n [/INST]\n", "output": "reg [3:0] gp_sel; \n  wire [31:0] w_out_a; \n  wire [31:0] w_out_b; \n RegisterFile GPRF0(.in_reg(d_in),.out_a(w_out_a),.out_b(w_out_b),.addr_a(addr_a),.addr_b(addr_b),.rw(rw),.clk(clk),.sel(gp_sel[0])); \n RegisterFile GPRF1(.in_reg(d_in),.out_a(w_out_a),.out_b(w_out_b),.addr_a(addr_a),.addr_b(addr_b),.rw(rw),.clk(clk),.sel(gp_sel[1])); \n RegisterFile GPRF2(.in_reg(d_in),.out_a(w_out_a),.out_b(w_out_b),.addr_a(addr_a),.addr_b(addr_b),.rw(rw),.clk(clk),.sel(gp_sel[2])); \n RegisterFile GPRF3(.in_reg(d_in),.out_a(w_out_a),.out_b(w_out_b),.addr_a(addr_a),.addr_b(addr_b),.rw(rw),.clk(clk),.sel(gp_sel[3])); \n initial \n  begin \n  gp_sel <= 4'b1111; \n  end \n always@(*) \n begin \n  case(file_sel) \n  2'b00: gp_sel <= 4'b1110; \n  2'b01: gp_sel <= 4'b1101; \n  2'b10: gp_sel <= 4'b1011; \n  2'b11: gp_sel <= 4'b0111; \n  endcase \n end \n assign out_a = w_out_a; \n assign out_b = w_out_b; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module 'half_type_clz' takes a 10-bit input 'mantissa' and produces a 4-bit output 'count' that represents the count of leading zeros. The 'count[3]' output is set based on whether there are any zeros in the higher bits of 'mantissa'. 'count[2]' is set based on specific patterns of zeros in 'mantissa[9:2]'. 'count[1]' is determined by a complex logic expression involving 'count[3]' and 'mantissa[1:0]'. Lastly, 'count[0]' is set based on logical OR of multiple conditions on specific bit patterns within 'mantissa'.\n\n Module header:\n\n module half_type_clz(mantissa, count);\n [/INST]\n", "output": "input [9:0] mantissa; \n  output [3:0] count; \n  assign count[3] = ~|mantissa[9:2]; \n  assign count[2] = |mantissa[9:2] & ~|mantissa[9:6]; \n  assign count[1] = count[3] & ~|mantissa[1:0] | ~count[3] & (~count[2] & ~|mantissa[9:8] | count[2] & ~|mantissa[5:4]); \n  assign count[0] = (mantissa[9:8] == 2'b01) | \n  (mantissa[9:6] == 4'b0001) | \n  (mantissa[9:4] == 6'b000001) | \n  (mantissa[9:2] == 8'b00000001) | \n  (mantissa == 10'b0000000001); \n  endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a test for a register file. It includes various registers such as clock, flush, read_adr_1, read_adr_2, write_data, write_adr, and write_en. The module also instantiates a register file (uut) with the given inputs and outputs. The initial block initializes the various signals and then toggles the write enable, sets write addresses and data, sets read addresses, and toggles the flush enable. Finally, there's a clock signal generator that toggles the clock signal every half period.\n\n Module header:\n\nmodule test_register_file;\n [/INST]\n", "output": "reg clock; \n  reg flush; \n  reg [2:0] read_adr_1; \n  reg [2:0] read_adr_2; \n  reg [15:0] write_data; \n  reg [2:0] write_adr; \n  reg write_en; \n  wire [15:0] data_out_1; \n  wire [15:0] data_out_2; \n register_file uut (.clock(clock),.flush(flush),.read_adr_1(read_adr_1),.read_adr_2(read_adr_2),.write_data(write_data),.write_adr(write_adr),.write_en(write_en),.data_out_1(data_out_1),.data_out_2(data_out_2)); \n  initial begin \n  clock = 0; \n  flush = 0; \n  read_adr_1 = 0; \n  read_adr_2 = 0; \n  write_data = 0; \n  write_adr = 0; \n  write_en = 0; \n  #1; \n  write_en = 1; \n  write_adr = 0; \n  write_data = 16'h3131; \n  read_adr_1 = 0; \n  #2; \n  write_en = 1; \n  write_adr = 3; \n  write_data = 16'h6969; \n  #2; \n  write_en = 1; \n  write_adr = 5; \n  write_data = 16'h0ff0; \n  #2; \n  write_en = 0; \n  read_adr_1 = 2; \n  read_adr_2 = 3; \n  #2; \n  flush = 1; \n  #2; \n  flush = 0; \n  end \n  always #10 clock = !clock; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a 3-stage synchronous pipeline. On each rising edge of the clock signal, the input 'i' is latched into the first stage, and the data from each stage is shifted to the next stage. The output 'o' is driven by the data from the third stage.\n\n Module header:\n\nmodule synch_3 #(parameter WIDTH = 1) (input wire [WIDTH-1:0] i,output reg [WIDTH-1:0] o,input wire clk);\n [/INST]\n", "output": "reg [WIDTH-1:0] stage_1; \n reg [WIDTH-1:0] stage_2; \n reg [WIDTH-1:0] stage_3; \n always @(posedge clk) \n  {stage_3, o, stage_2, stage_1} <= {o, stage_2, stage_1, i}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a FIFO control module with separate write and read clocks. It includes a FIFO of size 5 and width 10. It uses write and read pointers, and signals for write and read busy, full, and empty flags. It instantiates another module called fifoctrl_dualclk, passing in the parameters and signals. The module includes an initialization block to set the write and read pointers to 0, and it has clock edge triggers to handle incrementing the write and read pointers based on the full and empty conditions and the write and read enable signals.\n\n Module header:\n\nmodule fifoctrl_sim_pp(input wclk, input rclk);\n [/INST]\n", "output": "localparam fifosize = 5; \n  localparam width = 10; \n  reg [width:0] w_ptr; \n  wire [width:0] w_ptr_next; \n  wire r_busy; \n  reg [width:0] r_ptr; \n  wire [width:0] r_ptr_next; \n  wire w_busy; \n  wire full; \n  wire empty; \n fifoctrl_dualclk #(.width(width)) f0(.size_i(fifosize),.w_ptr_i(w_ptr), .r_ptr_i(r_ptr),.w_clk_i(wclk), .r_clk_i(rclk),.full_o(full), .empty_o(empty),.w_ptr_next_o(w_ptr_next), .r_ptr_next_o(r_ptr_next),.w_busy_o(w_busy), .r_busy_o(r_busy)); \n  integer i = 0; \n  integer we = 0; \n  integer re = 0; \n  initial begin \n  w_ptr = 0; \n  r_ptr = 0; \n  end \n  always @(posedge wclk) \n  i <= i + 1; \n  always @(posedge wclk) \n  if (!full && !w_busy && i < 18) begin \n  w_ptr <= w_ptr + 1; \n  we <= we + 1; \n  end \n  always @(posedge rclk) \n  if (!empty && !r_busy) begin \n  r_ptr <= r_ptr + 1; \n  re <= re + 1; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an interface for a Peripheral Input/Output (PIO) device. It includes logic for handling resets and communication with an external device. The module interfaces with PIO_EP and PIO_TO_CTRL instances, connecting various signals and handling data transfer between the PIO and the control logic. It uses the user_clk and user_reset signals for synchronization and includes logic to manage the reset signal for the PIO. The module utilizes specific parameters such as C_DATA_WIDTH, KEEP_WIDTH, and TCQ to customize the behavior and interface of the PIO. The module also includes input and output ports for data and control signals, and manages the communication between the PIO and an external control logic.\n\n Module header:\n\nmodule PIO #(parameter C_DATA_WIDTH = 64,parameter KEEP_WIDTH = C_DATA_WIDTH / 8,parameter TCQ = 1)(input user_clk,input user_reset,input user_lnk_up,input s_axis_tx_tready,output [C_DATA_WIDTH-1:0] s_axis_tx_tdata,output [KEEP_WIDTH-1:0] s_axis_tx_tkeep,output s_axis_tx_tlast,output s_axis_tx_tvalid,output tx_src_dsc,input [C_DATA_WIDTH-1:0] m_axis_rx_tdata,input [KEEP_WIDTH-1:0] m_axis_rx_tkeep,input m_axis_rx_tlast,input m_axis_rx_tvalid,output m_axis_rx_tready,input [21:0] m_axis_rx_tuser,input cfg_to_turnoff,output cfg_turnoff_ok,input [15:0] cfg_completer_id);\n [/INST]\n", "output": "wire req_compl; \n  wire compl_done; \n  reg pio_reset_n; \n  always @(posedge user_clk) begin \n  if (user_reset) \n  pio_reset_n <= #TCQ 1'b0; \n  else \n  pio_reset_n <= #TCQ user_lnk_up; \n  end \n PIO_EP #(.C_DATA_WIDTH( C_DATA_WIDTH ),.KEEP_WIDTH( KEEP_WIDTH ),.TCQ( TCQ )) PIO_EP_inst (.clk( user_clk ),.rst_n( pio_reset_n ),.s_axis_tx_tready( s_axis_tx_tready ),.s_axis_tx_tdata( s_axis_tx_tdata ),.s_axis_tx_tkeep( s_axis_tx_tkeep ),.s_axis_tx_tlast( s_axis_tx_tlast ),.s_axis_tx_tvalid( s_axis_tx_tvalid ),.tx_src_dsc( tx_src_dsc ),.m_axis_rx_tdata( m_axis_rx_tdata ),.m_axis_rx_tkeep( m_axis_rx_tkeep ),.m_axis_rx_tlast( m_axis_rx_tlast ),.m_axis_rx_tvalid( m_axis_rx_tvalid ),.m_axis_rx_tready( m_axis_rx_tready ),.m_axis_rx_tuser ( m_axis_rx_tuser ),.req_compl(req_compl),.compl_done(compl_done),.cfg_completer_id ( cfg_completer_id )); \n PIO_TO_CTRL #(.TCQ( TCQ )) PIO_TO_inst (.clk( user_clk ),.rst_n( pio_reset_n ),.req_compl( req_compl ),.compl_done( compl_done ),.cfg_to_turnoff( cfg_to_turnoff ),.cfg_turnoff_ok( cfg_turnoff_ok )); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a RAM controller with read and write functionality. It includes inputs for data, read and write addresses, clock signals, and write enable signals. The module contains a memory array to store data and uses a read address to access the memory. It updates the memory array when the write enable signal is asserted and the clock signal rises. The output q provides the contents of the RAM based on the read address.\n\n Module header:\n\nmodule ram_controller_full_mem_model_ram_module (data,rdaddress,rdclken,wraddress,wrclock,wren,q);\n [/INST]\n", "output": "output [ 31: 0] q; \n  input [ 31: 0] data; \n  input [ 24: 0] rdaddress; \n  input rdclken; \n  input [ 24: 0] wraddress; \n  input wrclock; \n  input wren; \n  reg [ 31: 0] mem_array [33554431: 0]; \n  wire [ 31: 0] q; \n  reg [ 24: 0] read_address; \n  always @(rdaddress) \n  begin \n  read_address = rdaddress; \n  end \n  assign q = mem_array[read_address]; \n  always @(posedge wrclock) \n  begin \n  if (wren) \n  mem_array[wraddress] <= data; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an output buffer with power and ground inputs, as well as a clock input and a data input. It also has a data enable input. It includes a D flip-flop and a 2-to-1 multiplexer to handle the data input. The output buffer also has signals for power-up, condition, and a notifier. It ensures that the output buffer works correctly and safely, taking into account the power and ground inputs.\n\n Module header:\n\nmodule sky130_fd_sc_hd__edfxtp (Q ,CLK ,D ,DE ,VPWR,VGND,VPB ,VNB);\n [/INST]\n", "output": "output Q ; \n  input CLK ; \n  input D ; \n  input DE ; \n  input VPWR; \n  input VGND; \n  input VPB ; \n  input VNB ; \n  wire buf_Q ; \n  reg notifier ; \n  wire D_delayed ; \n  wire DE_delayed ; \n  wire CLK_delayed; \n  wire mux_out ; \n  wire awake ; \n  wire cond0 ; \n  sky130_fd_sc_hd__udp_mux_2to1 mux_2to10 (mux_out, buf_Q, D_delayed, DE_delayed ); \n  sky130_fd_sc_hd__udp_dff$P_pp$PG$N dff0 (buf_Q , mux_out, CLK_delayed, notifier, VPWR, VGND); \n  assign awake = ( VPWR === 1'b1 ); \n  assign cond0 = ( awake && ( DE_delayed === 1'b1 ) ); \n  buf buf0 (Q , buf_Q ); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements the MixColumns transformation in the context of the Advanced Encryption Standard (AES) algorithm. It operates on a 128-bit input x and produces a 128-bit output z. The module utilizes a generate for loop to perform the transformation for each set of 32 bits within the input. Inside the loop, it performs various bitwise operations and assignments to derive the output z based on the input x. The xtime modules are utilized to perform multiplication in the finite field. Overall, the module is responsible for performing the MixColumns transformation on the input data.\n\n Module header:\n\nmodule MixColumns(x,z);\n [/INST]\n", "output": "input [127:0] x; \n  output [127:0] z; \n  generate \n  genvar i; \n  for (i = 0; i < 4; i = i + 1) begin: gen_loop_enc \n  wire[7:0] a0, a1, a2, a3, temp; \n  wire[7:0] b0, b1, b2, b3; \n  wire[7:0] c0, c1, c2, c3; \n  assign a0 = x[8*(4*i+1)-1:8*(4*i+0)]; \n  assign a1 = x[8*(4*i+2)-1:8*(4*i+1)]; \n  assign a2 = x[8*(4*i+3)-1:8*(4*i+2)]; \n  assign a3 = x[8*(4*i+4)-1:8*(4*i+3)]; \n  assign temp = a0 ^ a1 ^ a2 ^ a3; \n  xtime xtime_0(c0, a0 ^ a1); \n  xtime xtime_1(c1, a1 ^ a2); \n  xtime xtime_2(c2, a2 ^ a3); \n  xtime xtime_3(c3, a3 ^ a0); \n  assign b0 = a0 ^ temp ^ c0; \n  assign b1 = a1 ^ temp ^ c1; \n  assign b2 = a2 ^ temp ^ c2; \n  assign b3 = a3 ^ temp ^ c3; \n  assign z[8*(4*i+1)-1:8*(4*i+0)] = b0; \n  assign z[8*(4*i+2)-1:8*(4*i+1)] = b1; \n  assign z[8*(4*i+3)-1:8*(4*i+2)] = b2; \n  assign z[8*(4*i+4)-1:8*(4*i+3)] = b3; \n  end \n  endgenerate \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements an instruction memory with a 32-bit address input and data output. It consists of an array MEM with 129 elements, each being 32 bits wide. During initialization, specific values are assigned to the first three elements of the memory array. The module continuously updates the output data based on the input address, retrieving the corresponding data from the memory array.\n\n Module header:\n\nmodule INSTR_MEM(input clk, input [31:0] addr, output reg [31:0] data);\n [/INST]\n", "output": "reg [31:0] MEM [128:0]; \n  initial begin \n  MEM[0] <= 32'b1000_0000_0000_0000_0000_0000_0000_0000; \n  MEM[1] <= 32'b001000_00001_00001_0000000000000001; \n  MEM[2] <= 32'b001000_00010_00010_0000000000000010; \n  end \n  always @ * \n  begin \n  data <= MEM[addr]; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a temperature monitor that interfaces with a SYSMON module. It has inputs for the digital address, clock, enable signal, data in, write enable, and voltage inputs. The module has outputs for the data out and ready signals. Inside the module, there are additional wires and instantiations for internal components. The module integrates with the SYSMON module to monitor temperature and voltage levels.\n\n Module header:\n\nmodule TemperatureMonitor_exdes(DADDR_IN,DCLK_IN,DEN_IN,DI_IN,DWE_IN,DO_OUT,DRDY_OUT,VP_IN,VN_IN);\n [/INST]\n", "output": "input VP_IN; \n  input VN_IN; \n  input [6:0] DADDR_IN; \n  input DCLK_IN; \n  input DEN_IN; \n  input [15:0] DI_IN; \n  input DWE_IN; \n  output [15:0] DO_OUT; \n  output DRDY_OUT; \n  wire GND_BIT; \n  wire [2:0] GND_BUS3; \n  wire FLOAT_VCCAUX; \n  wire FLOAT_VCCINT; \n  wire FLOAT_USER_TEMP_ALARM; \n  assign GND_BIT = 0; \n TemperatureMonitor \n sysmon_wiz_inst (.DADDR_IN(DADDR_IN[6:0]),.DCLK_IN(DCLK_IN),.DEN_IN(DEN_IN),.DI_IN(DI_IN[15:0]),.DWE_IN(DWE_IN),.DO_OUT(DO_OUT[15:0]),.DRDY_OUT(DRDY_OUT),.VP_IN(VP_IN),.VN_IN(VN_IN)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a lookup table with three inputs and three outputs. It uses a shift register and mix logic to manipulate the input values based on the round counter. The round counter is updated on each clock cycle when enabled, and the input length is used to calculate the length value. Based on the value of the round counter, the module performs specific operations such as addition, shifting, and assignment to the output registers x, y, and z. The done flag is assigned based on the value of the round counter to indicate the completion of the lookup process.\n\n Module header:\n\nmodule lookup3(x, y, z, done,k0, k1, k2, clk, en, rst, length);\n [/INST]\n", "output": "output [31:0] x, y, z; \n  output done; \n  input [31:0] k0, k1, k2; \n  input clk; \n  input en; \n  input rst; \n  reg [31:0] x, y, z; \n  reg [4:0] shift; \n  wire [31:0] OA, OB, OC; \n  reg [31:0] a, b, c; \n mix M0(.OA (OA[31:0]),.OB (OB[31:0]),.OC (OC[31:0]),.a (a[31:0]),.b (b[31:0]),.c (c[31:0]),.clk (clk),.shift (shift[4:0])); \n  reg [2:0] round; \n  always @(posedge clk) \n  if (rst) \n  round <= #1 0; \n  else if (en) \n  round <= #1 round + 1; \n  input [31:0] length; \n  wire [31:0] length_val = (length << 2) + 32'hdeadbeef; \n  always @(posedge clk) \n  if (en) \n  case (round) \n  0: begin \n  a <= #1 k0 + length_val; \n  b <= #1 k1 + length_val; \n  c <= #1 k2 + length_val; \n  shift <= #1 4; \n  end \n  1: begin \n  a <= #1 OB ; \n  b <= #1 OC ; \n  c <= #1 OA ; \n  shift <= #1 6; \n  end \n  2: begin \n  a <= #1 OB ; \n  b <= #1 OC ; \n  c <= #1 OA ; \n  shift <= #1 8; \n  end \n  3: begin \n  a <= #1 OB; \n  b <= #1 OC; \n  c <= #1 OA; \n  shift <= #1 16; \n  end \n  4: begin \n  a <= #1 OB; \n  b <= #1 OC; \n  c <= #1 OA; \n  shift <= #1 19; \n  end \n  5: begin \n  a <= #1 OB; \n  b <= #1 OC; \n  c <= #1 OA; \n  shift <= #1 4; \n  end \n  endcase \n  always @(posedge clk) \n  if (round == 6) begin \n  x <= #1 OA; \n  y <= #1 OB; \n  z <= #1 OC; \n  end \n  assign done = round == 7; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements an initialization RAM circuit. It contains memory for storing data and has logic to transfer data based on the clock signal and reset condition. The module reads data from a file and sets a key value to \"PASS\". It also has an \"finished\" flag to indicate when the data transfer process is complete. The module supports writing data to two different addresses and outputs the corresponding data. When a specific condition is met, it sets the finished flag and clears the output data. The address, write enable, and output data are all reset when a reset signal is asserted.\n\n Module header:\n\nmodule TestInitRam #(parameter ADDR_WIDTH = 4,parameter DATA_WIDTH = 8,parameter MEM_DEPTH = 64)(input clk,input rst,output reg[DATA_WIDTH-1:0] key,output reg finished,output reg [ADDR_WIDTH-1:0] addrA,output reg [ADDR_WIDTH-1:0] addrB,output reg wr_enaA,output reg wr_enaB,output reg[DATA_WIDTH-1:0] data_outA,output reg[DATA_WIDTH-1:0] data_outB);\n [/INST]\n", "output": "reg [DATA_WIDTH-1:0] tempMem [0:MEM_DEPTH-1]; \n  reg [ADDR_WIDTH-1:0] addr; \n  always@(posedge clk) \n  begin:TransferData \n  if(tempMem[addr][DATA_WIDTH-1]==1'b1 || tempMem[addr][DATA_WIDTH-1]==1'b0)begin \n  wr_enaA <= 1'b1; \n  wr_enaB <= 1'b1; \n  addrA <= addr; \n  addrB <= addr+1; \n  data_outA <= tempMem[addr]; \n  data_outB <= tempMem[addr+1]; \n  addr <= addr+2; \n  end else begin \n  finished <= 1'b1; \n  wr_enaA <= 1'b0; \n  wr_enaB <= 1'b0; \n  addrA <= 0; \n  addrB <= 0; \n  wr_enaA<=0; \n  wr_enaB<=0; \n  data_outA<=0; \n  data_outB<=0; \n  end \n  end \n  always@(posedge clk) \n  begin:Reset \n  if(rst) \n  begin \n  addr <= 0; \n  addrA <= 0; \n  addrB <= 0; \n  wr_enaA<=0; \n  wr_enaB<=0; \n  finished<=0; \n  data_outA<=0; \n  data_outB<=0; \n  end \n  end \n  integer r1,c1; \n  initial \n  begin \n  r1 = $fopen(\"Input\",\"rb\"); \n  c1 = $fread(tempMem,r1); \n  $fclose(r1); \n  end \n  initial \n  begin \n  key = \"PASS\"; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a synchronous design with an input clock signal, a data input din, a data output dout, and a reset signal reset_n. Inside the module, there is a D flip-flop instance named dffpipe3, which handles clock domain crossing for the din input. The output dout is then assigned the value of wire_dffpipe3_q. This module essentially synchronizes the input data din to the clock signal and forwards it to the output dout while handling reset events.\n\n Module header:\n\nmodule usb_system_sdram_clk_stdsync_sv6 (clk,din,dout,reset_n) ;\n [/INST]\n", "output": "input clk; \n  input din; \n  output dout; \n  input reset_n; \n  wire [0:0] wire_dffpipe3_q; \n  usb_system_sdram_clk_dffpipe_l2c dffpipe3 \n (.clock(clk),.clrn(reset_n),.d(din),.q(wire_dffpipe3_q)); \n  assign \n  dout = wire_dffpipe3_q; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a sequential read-only memory (ROM) with a specified address width and data width. The ROM is implemented using an array of registers, and the output q is assigned the value stored at the address specified by the input addr. Upon initialization, the module reads data from the specified file and initializes the ROM.\n\n Module header:\n\nmodule seq_rom (input [`SEQ_ADDR_WIDTH-1:0] addr,output [`SEQ_DATA_WIDTH-1:0] q);\n [/INST]\n", "output": "reg [`SEQ_DATA_WIDTH-1:0] rom[0:2**`SEQ_ADDR_WIDTH-1]; \n  assign q = rom[addr]; \n  initial $readmemb(\"/home/zeus/zet/rtl-model/seq_rom.dat\", rom); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes a Gray code input and converts it to binary output. It uses a register for the binary output and a wire for the Gray code input. Inside an always block, it iterates through each bit of the Gray code, performing a bitwise XOR operation to convert it to binary and stores the result in the output register. The module contains a parameter DW which sets the data width of the input and output.\n\n Module header:\n\nmodule oh_gray2bin #(parameter DW = 32) (input [DW-1:0] in,output [DW-1:0] out);\n [/INST]\n", "output": "reg [DW-1:0] bin; \n  wire [DW-1:0] gray; \n  integer i,j; \n  assign gray[DW-1:0] = in[DW-1:0]; \n  assign out[DW-1:0] = bin[DW-1:0]; \n  always @* \n  begin \n  bin[DW-1] = gray[DW-1]; \n  for (i=0; i<(DW-1); i=i+1) \n  begin \n  bin[i] = 1'b0; \n  for (j=i; j<DW; j=j+1) \n  bin[i] = bin[i] ^ gray [j]; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is named INSTRUCTION_FETCH_STAGE and has parameters ADDRESS_WIDTH, HIGH, and LOW. It takes inputs CLK, STALL_INSTRUCTION_FETCH_STAGE, CLEAR_INSTRUCTION_FETCH_STAGE, PC_IN, and PC_VALID_IN, and has outputs PC_OUT and PC_VALID_OUT. Inside the module, it has two registers pc_reg and pc_valid_reg. \n\nThe module uses an always block triggered by the positive edge of the CLK signal. It checks if CLEAR_INSTRUCTION_FETCH_STAGE is low and updates the PC register based on the STALL_INSTRUCTION_FETCH_STAGE and PC_VALID_IN signals. If CLEAR_INSTRUCTION_FETCH_STAGE is high, it sets the PC register to 0 and the PC valid register to LOW.\n\nFinally, it assigns the PC_OUT to pc_reg and PC_VALID_OUT to pc_valid_reg. The module essentially updates the PC and PC valid registers based on the input signals and provides them as outputs.\n\n Module header:\n\nmodule INSTRUCTION_FETCH_STAGE #(parameter ADDRESS_WIDTH = 32 ,parameter HIGH = 1'b1 ,parameter LOW = 1'b0) (input CLK ,input STALL_INSTRUCTION_FETCH_STAGE ,input CLEAR_INSTRUCTION_FETCH_STAGE ,input [ADDRESS_WIDTH - 1 : 0] PC_IN ,input PC_VALID_IN ,output [ADDRESS_WIDTH - 1 : 0] PC_OUT ,output PC_VALID_OUT);\n [/INST]\n", "output": "reg [ADDRESS_WIDTH - 1 : 0] pc_reg ; \n  reg pc_valid_reg ; \n  always@(posedge CLK) \n  begin \n  if(CLEAR_INSTRUCTION_FETCH_STAGE == LOW) \n  begin \n  if(STALL_INSTRUCTION_FETCH_STAGE == LOW) \n  begin \n  pc_reg <= PC_IN ; \n  pc_valid_reg <= PC_VALID_IN ; \n  end \n  end \n  else \n  begin \n  pc_reg <= 32'b0; \n  pc_valid_reg <= LOW ; \n  end \n  end \n  assign PC_OUT = pc_reg ; \n  assign PC_VALID_OUT = pc_valid_reg ; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a state machine that splits a 36-bit input into two 18-bit outputs. It has logic to control the state transitions and output valid signals based on the input data and readiness of the output channels. The state machine transitions between copying both, copying zero, and copying one based on the availability and readiness of the output channels. The module also handles reset and clear conditions to ensure proper initialization of the state and data registers.\n\n Module header:\n\nmodule splitter36 (input clk, input rst, input clr,input [35:0] inp_data, input inp_valid, output inp_ready,output [35:0] out0_data, output out0_valid, input out0_ready,output [35:0] out1_data, output out1_valid, input out1_ready);\n [/INST]\n", "output": "localparam STATE_COPY_BOTH = 0; \n  localparam STATE_COPY_ZERO = 1; \n  localparam STATE_COPY_ONE = 2; \n  reg [1:0] state; \n  reg [35:0] data_reg; \n  assign out0_data = (state == STATE_COPY_BOTH)? inp_data : data_reg; \n  assign out1_data = (state == STATE_COPY_BOTH)? inp_data : data_reg; \n  assign out0_valid = \n (state == STATE_COPY_BOTH)? inp_valid : ((state == STATE_COPY_ZERO)? 1'b1 : (1'b0)); \n  assign out1_valid = \n (state == STATE_COPY_BOTH)? inp_valid : ((state == STATE_COPY_ONE)? 1'b1 : (1'b0)); \n  assign inp_ready = (state == STATE_COPY_BOTH)? (out0_ready | out1_ready) : 1'b0; \n  always @(posedge clk) \n  if (rst | clr) begin \n  state <= STATE_COPY_BOTH; \n  end \n  else begin \n  case (state) \n  STATE_COPY_BOTH: begin \n  if ((out0_valid & out0_ready) & ~(out1_valid & out1_ready)) begin \n  state <= STATE_COPY_ONE; \n  end \n  else if (~(out0_valid & out0_ready) & (out1_valid & out1_ready)) begin \n  state <= STATE_COPY_ZERO; \n  end \n  data_reg <= inp_data; \n  end \n  STATE_COPY_ZERO: begin \n  if (out0_valid & out0_ready) begin \n  state <= STATE_COPY_BOTH; \n  end \n  end \n  STATE_COPY_ONE: begin \n  if (out1_valid & out1_ready) begin \n  state <= STATE_COPY_BOTH; \n  end \n  end \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a bidirectional buffer, where the output Z2 is driven by the input A when the output enable (OE) is asserted, and is in a high-impedance state (z) otherwise.\n\n Module header:\n\nmodule Test2(input OE, input A, inout Z2);\n [/INST]\n", "output": "assign Z2 = (OE) ? A : 1'bz; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a state machine that processes input data and triggers PUF operations. It includes registers for managing states and data, and logic to control PUF operations based on the input triggers and timing constraints. The module has specific states like IDLE and COMPUTE, and transitions between these states based on the trigger and timing conditions. The PUF operations are initiated when the trigger signal is received, and the module produces a response after a specific number of clock cycles. The output data and the status of the module are updated based on these state transitions and trigger events.\n\n Module header:\n\nmodule mapping #(parameter IN_WIDTH = 128,parameter OUT_WIDTH = 16)(input wire clk,input wire reset,input wire trigger,input wire [IN_WIDTH-1:0] dataIn,output reg done,output reg [OUT_WIDTH-1:0] dataOut,output reg xorOut);\n [/INST]\n", "output": "wire [15:0] response; \n  reg startPUF; \n  reg PUFreset; \n  reg [4:0] countWait; \n  integer ind; \n  reg [15:0] sum; \n  localparam IDLE = 0; \n  localparam COMPUTE = 1; \n  reg mp_state; \n  reg [IN_WIDTH-1:0] buffer; \n  always @ (posedge clk) begin \n  if (reset) begin \n  done <= 0; \n  dataOut <= 0; \n  mp_state <= IDLE; \n  startPUF <= 0; \n  countWait <= 0; \n  PUFreset <=1; \n  end \n  else begin \n  case(mp_state) \n  IDLE: begin \n  done <= 0; \n  sum <= 0; \n  PUFreset <= 0; \n  countWait <=0; \n  startPUF <=0; \n  if(trigger == 1) \n  mp_state <= COMPUTE; \n  buffer <= dataIn; \n  end \n  COMPUTE: begin \n  startPUF <=1; \n  countWait <= countWait + 1; \n  if (countWait == 15) begin \n  startPUF<=0; \n  dataOut <= response; \n  done <= 1; \n  mp_state <= IDLE; \n  PUFreset <=1; \n  end \n  end \n  endcase \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, named vndecorrelator, implements a control logic for data and synchronization signals. It features a control register to manage the state transitions and write enables for the input data, output data, and synchronization signals. The module also includes an always block to handle the state transitions based on the control register value and the synchronization input. The control logic is set to transition between an IDLE state and a BITS state based on the synchronization input. The module also includes reset handling to initialize the registers and control signals.\n\n Module header:\n\nmodule vndecorrelator(input wire clk,input wire reset_n,input wire data_in,input wire syn_in,output wire data_out,output wire syn_out);\n [/INST]\n", "output": "parameter CTRL_IDLE = 1'b0; \n  parameter CTRL_BITS = 1'b1; \n  reg data_in_reg; \n  reg data_in_we; \n  reg data_out_reg; \n  reg data_out_we; \n  reg syn_out_reg; \n  reg syn_out_new; \n  reg vndecorr_ctrl_reg; \n  reg vndecorr_ctrl_new; \n  reg vndecorr_ctrl_we; \n  assign data_out = data_out_reg; \n  assign syn_out = syn_out_reg; \n  always @ (posedge clk or negedge reset_n) \n  begin \n  if (!reset_n) \n  begin \n  data_in_reg <= 1'b0; \n  data_out_reg <= 1'b0; \n  syn_out_reg <= 1'b0; \n  vndecorr_ctrl_reg <= CTRL_IDLE; \n  end \n  else \n  begin \n  syn_out_reg <= syn_out_new; \n  if (data_in_we) \n  begin \n  data_in_reg <= data_in; \n  end \n  if (data_out_we) \n  begin \n  data_out_reg <= data_in; \n  end \n  if (vndecorr_ctrl_we) \n  begin \n  vndecorr_ctrl_reg <= vndecorr_ctrl_new; \n  end \n  end \n  end \n  always @* \n  begin : vndecorr_logic \n  data_in_we = 1'b0; \n  data_out_we = 1'b0; \n  syn_out_new = 1'b0; \n  vndecorr_ctrl_new = CTRL_IDLE; \n  vndecorr_ctrl_we = 1'b0; \n  case (vndecorr_ctrl_reg) \n  CTRL_IDLE: \n  begin \n  if (syn_in) \n  begin \n  data_in_we = 1'b1; \n  vndecorr_ctrl_new = CTRL_BITS; \n  vndecorr_ctrl_we = 1'b1; \n  end \n  end \n  CTRL_BITS: \n  begin \n  if (syn_in) \n  begin \n  if (data_in != data_in_reg) \n  begin \n  data_out_we = 1'b1; \n  syn_out_new = 1'b1; \n  end \n  vndecorr_ctrl_new = CTRL_IDLE; \n  vndecorr_ctrl_we = 1'b1; \n  end \n  end \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe \"RAM2x256C\" module is a Verilog module representing a memory block with two sets of 256 bits. The module has inputs for clock (CLK), write enable (WE), even/odd selection (ED), write data (DI), read address (ADDRW for write and ADDRR for read), and read data (DR). It has outputs for read data (DOR) and data out (DOI).\n\nThe module includes two main implementations based on the presence or absence of the \"`FFT256bufferports1`\" directive. When the directive is present, it instantiates four instances of the \"RAM256\" module with 256-bit memory, and assigns the output based on the even/odd selection.\n\nIn the absence of the \"`FFT256bufferports1`\" directive, the module uses a simple RAM design with a 512-word memory. It performs read and write operations based on the even/odd selection and utilizes a single read address for all operations.\n\nThe module effectively functions as a configurable memory unit with different implementations based on the presence of the `FFT256bufferports1` directive.\n\n Module header:\n\nmodule RAM2x256C ( CLK ,ED ,WE ,ODD ,ADDRW ,ADDRR ,DR ,DI ,DOR ,DOI );\n [/INST]\n", "output": "`FFT256paramnb \n  output [nb-1:0] DOR ; \n  wire [nb-1:0] DOR ; \n  output [nb-1:0] DOI ; \n  wire [nb-1:0] DOI ; \n  input CLK ; \n  wire CLK ; \n  input ED ; \n  wire ED ; \n  input WE ; \n  wire WE ; \n  input ODD ; \n  wire ODD ; \n  input [7:0] ADDRW ; \n  wire [7:0] ADDRW ; \n  input [7:0] ADDRR ; \n  wire [7:0] ADDRR ; \n  input [nb-1:0] DR ; \n  wire [nb-1:0] DR ; \n  input [nb-1:0] DI ; \n  wire [nb-1:0] DI ; \n  reg oddd,odd2; \n  always @( posedge CLK) begin \n  if (ED) begin \n  oddd<=ODD; \n  odd2<=oddd; \n  end \n  end \n  `ifdef FFT256bufferports1 \n  wire we0,we1; \n  wire [nb-1:0] dor0,dor1,doi0,doi1; \n  wire [7:0] addr0,addr1; \n  assign addr0 =ODD? ADDRW: ADDRR; \n  assign addr1 = ~ODD? ADDRW:ADDRR; \n  assign we0 =ODD? WE: 0; \n  assign we1 =~ODD? WE: 0; \n  RAM256 #(nb) URAM0(.CLK(CLK),.ED(ED),.WE(we0), .ADDR(addr0),.DI(DR),.DO(dor0)); \n  RAM256 #(nb) URAM1(.CLK(CLK),.ED(ED),.WE(we0), .ADDR(addr0),.DI(DI),.DO(doi0)); \n  RAM256 #(nb) URAM2(.CLK(CLK),.ED(ED),.WE(we1), .ADDR(addr1),.DI(DR),.DO(dor1)); \n  RAM256 #(nb) URAM3(.CLK(CLK),.ED(ED),.WE(we1), .ADDR(addr1),.DI(DI),.DO(doi1)); \n  assign DOR=~odd2? dor0 : dor1; \n  assign DOI=~odd2? doi0 : doi1; \n  `else \n  wire [8:0] addrr2 = {ODD,ADDRR}; \n  wire [8:0] addrw2 = {~ODD,ADDRW}; \n  wire [2*nb-1:0] di= {DR,DI} ; \n  reg [2*nb-1:0] doi; \n  reg [2*nb-1:0] ram [511:0]; \n  reg [8:0] read_addra; \n  always @(posedge CLK) begin \n  if (ED) \n  begin \n  if (WE) \n  ram[addrw2] <= di; \n  read_addra <= addrr2; \n  doi = ram[read_addra]; \n  end \n  end \n  assign DOR=doi[2*nb-1:nb]; \n  assign DOI=doi[nb-1:0]; \n  `endif \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a memory array with read and write functionality. It has inputs for data_in, fifo_we, wptr, rptr, clk, and clear. The data_out output holds the data stored in the memory array. The module uses a 16-element data_out_i register to store data. The INITIALIZE_DATA_OUT_I block initializes the data_out_i register to zeros. The MEMORY_ARRAY_UPTAKE block writes data_in to the memory array when fifo_we is asserted. The data_out is assigned the value of the memory array at the rptr index. The MEMORY_ARRAY_CLEARMEM block resets all elements of the memory array to 0 when clear signal is asserted.\n\n Module header:\n\nmodule memory_array (data_in,fifo_we,wptr,rptr,data_out,clk,clear);\n [/INST]\n", "output": "input [7:0] data_in; \n input fifo_we; \n input [4:0] wptr; \n input [4:0] rptr; \n output [7:0] data_out; \n wire [7:0] data_out; \n input clk; \n input clear; \n reg [7:0] data_out_i [0:16-1]; \n initial begin: INITIALIZE_DATA_OUT_I \n  integer i; \n  for(i=0; i<16; i=i+1) begin \n  data_out_i[i] = 0; \n  end \n end \n always @(posedge clk) begin: MEMORY_ARRAY_UPTAKE \n  if (fifo_we) begin \n  data_out_i[wptr[4-1:0]] <= data_in; \n  end \n end \n assign data_out = data_out_i[rptr[4-1:0]]; \n always @(negedge clear) begin: MEMORY_ARRAY_CLEARMEM \n  integer i; \n  for (i=0; i<16; i=i+1) begin \n  data_out_i[i] <= 0; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a memory unit with a hub RAM and hub ROM. It selects the RAM or ROM based on the address and the enable signal. It contains logic to divide the address range and control the write and read operations for each memory type. The output q is the data read from either the RAM or ROM based on the selected memory.\n\n Module header:\n\nmodule hub_mem (input clk_cog,input ena_bus,input nres,input w,input [3:0] wb,input [13:0] a,input [31:0] d,output [31:0] q);\n [/INST]\n", "output": "parameter HUB_RAM_SIZE_BYTES = 32768; \n parameter HUB_ROM_SIZE_BYTES = 32768; \n wire in_ram = (a < HUB_RAM_SIZE_BYTES >> 2); \n wire in_rom = (a >= 16384 - (HUB_ROM_SIZE_BYTES >> 2)); \n reg [31:0] ram_q; \n genvar i; \n generate \n  for (i = 0; i < 4; i = i + 1) \n  begin : ramgen \n  hub_ram \n #(.SIZE_BYTES (HUB_RAM_SIZE_BYTES >> 2)) \n ram_(.clk (clk_cog),.enable (ena_bus && in_ram),.w (w),.wb (wb[i]),.a (a),.d8 (d[(i+1)*8-1:i*8]),.q8 (ram_q[(i+1)*8-1:i*8])); \n  end \n endgenerate \n reg [31:0] rom_q; \n hub_rom \n #(.SIZE_LONGS (HUB_ROM_SIZE_BYTES >> 2)) \n rom_(.clk (clk_cog),.enable (ena_bus && in_rom),.a (a),.d (d),.q (rom_q)); \n reg mem; \n always @(posedge clk_cog) \n if (ena_bus) \n  mem <= in_ram; \n assign q = mem ? ram_q : rom_q; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module represents an input gate with specific power and ground connections. It takes input data, a control signal, and various power supply and voltage inputs. The gate operation is controlled based on specific conditional signals, and includes a mux, delay latch, and buffer instances for signal manipulation. The module also includes power gating control for efficient power usage.\n\n Module header:\n\nmodule sky130_fd_sc_hvl__sdlxtp (Q ,D ,SCD ,SCE ,GATE,VPWR,VGND,VPB ,VNB);\n [/INST]\n", "output": "output Q ; \n  input D ; \n  input SCD ; \n  input SCE ; \n  input GATE; \n  input VPWR; \n  input VGND; \n  input VPB ; \n  input VNB ; \n  wire buf_Q ; \n  wire GATE_delayed; \n  wire D_delayed ; \n  wire SCD_delayed ; \n  wire SCE_delayed ; \n  wire cond0 ; \n  wire cond1 ; \n  wire cond2 ; \n  reg notifier ; \n  wire mux_out ; \n  wire buf0_out_Q ; \n  assign cond0 = ( SCE_delayed === 1'b0 ); \n  assign cond1 = ( SCE_delayed === 1'b1 ); \n  sky130_fd_sc_hvl__udp_mux_2to1 mux_2to10 (mux_out , D_delayed, SCD_delayed, SCE_delayed ); \n  sky130_fd_sc_hvl__udp_dlatch$P_pp$PG$N dlatch0 (buf_Q , mux_out, GATE_delayed, notifier, VPWR, VGND); \n  buf buf0 (buf0_out_Q, buf_Q ); \n  sky130_fd_sc_hvl__udp_pwrgood_pp$PG pwrgood_pp0 (Q , buf0_out_Q, VPWR, VGND ); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a state machine with 7 states: TIDLE, TCN1, TCN2, TCN3, TCN4, TCN5, IOCLR, and TUNU1. It has inputs foocr_we, ioclrinst, and tstate, and an output ntstate that represents the next state. The module sets ioclrtmout to 0 or 1 based on the current state and inputs, and it handles reset and simulation conditions. The state transitions are based on the inputs and the current state, and specific states trigger error messages in simulation mode.\n\n Module header:\n\nmodule dummy;\n [/INST]\n", "output": "parameter [TSTBITS-1:0] \n  TIDLE = 3'b000, \n  TCN1 = 3'b001, \n  TCN2 = TCN1+1, \n  TCN3 = TCN2+1, \n  TCN4 = TCN3+1, \n  TCN5 = TCN4+1, \n  IOCLR = TCN5+1, \n  TUNU1 = 3'b111; \n always @ (`ifdef SIMFSMireset or`endiffooc2_qual or foocr_we or ioclrinst or tstate) begin \n  ioclrtmout = 1'b0; \n  case (tstate) \n  TIDLE: begin \n  if (foocr_we) \n  ntstate = TCN1; \n  else \n  ntstate = TIDLE; \n  end \n  TCN1,TCN2,TCN3,TCN4,TCN5: begin \n  if (ioclrinst | fooc2_qual) \n  ntstate = TIDLE; \n  else \n  ntstate = tstate + 1; \n  end \n  IOCLR: begin \n  ntstate = TIDLE; \n  ioclrtmout = 1'b1; \n  end \n  TUNU1: begin \n  ntstate = TIDLE; \n `ifdef SIMFSM \n  if (~ireset) \n  $display(\"ERROR: entered unused state at %t\",$time); \n `endif \n  end \n  default: begin \n  ntstate = 'bx; \n  ioclrtmout = 1'bx; \n `ifdef SIMFSM \n  if (~ireset) \n  $display(\"ERROR: entered unknown state at %t\",$time); \n `endif \n  end \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a parameterized n x n UDM (Universal Decision Module) that can handle various input widths. The module splits the input signals into two halves and then generates a decision tree for a 2-bit input. If the input width is 2, it instantiates a 2-bit UDM and assigns the output signal to a 1-bit signal. Otherwise, it splits the input signals further and instantiates four UDM_nxnB modules for different linear blocks. Finally, it combines the outputs of the linear blocks to produce the final result.\n\n Module header:\n\nmodule UDM_nxnA #(parameter W=2) (input wire [W-1:0] in1,input wire [W-1:0] in2,output wire [2*W-1:0] res);\n [/INST]\n", "output": "wire [W/2-1:0] L_in1; \n wire [W/2-1:0] R_in1; \n wire [W/2-1:0] L_in2; \n wire [W/2-1:0] R_in2; \n  generate \n  if (W==2) begin : SmallBLOCK \n  wire [2:0] temp_res; \n  UDM_2x2 UDM_2x2 (.in1(in1), .in2(in2), .res(temp_res)); \n  assign res = {1'b0, temp_res}; \n  end else begin : BIGBLOCK \n  assign L_in1 = in1[W-1:(W>>1)]; \n  assign R_in1 = in1[(W>>1)-1:0]; \n  assign L_in2 = in2[W-1:(W>>1)]; \n  assign R_in2 = in2[(W>>1)-1:0]; \n  wire [W-1:0] res_Lin1Lin2; \n  wire [W-1:0] res_Hin1Lin2; \n  wire [W-1:0] res_Lin1Hin2; \n  wire [W-1:0] res_Hin1Hin2; \n  UDM_nxnB #(.W((W>>1))) A_LxB_L1 (.in1(R_in1), .in2(R_in2), .res(res_Lin1Lin2)); \n  UDM_nxnB #(.W((W>>1))) A_HxB_L2 (.in1(L_in1), .in2(R_in2), .res(res_Hin1Lin2)); \n  UDM_nxnB #(.W((W>>1))) A_LxB_H3 (.in1(R_in1), .in2(L_in2), .res(res_Lin1Hin2)); \n  UDM_nxnB #(.W((W>>1))) A_HxB_H4 (.in1(L_in1), .in2(L_in2), .res(res_Hin1Hin2)); \n  assign res = {res_Hin1Hin2, {W{1'b0}}} + {res_Hin1Lin2, {((W>>1)){1'b0}}} + {res_Lin1Hin2, {(W>>1){1'b0}}} + {{W{1'b0}}, res_Lin1Lin2}; \n  end \n  endgenerate \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module implements an FPGA core with UART functionality. It has inputs for clock, reset, buttons, switches, and UART signals, as well as outputs for LEDs and UART signals. Inside the module, it instantiates a UART module and assigns the UART transmit data to the LED outputs. The core contains logic that handles the UART transmit and receive signals, including setting the transmit data and transmit valid signals, and toggling the receive ready signal based on the receive data. Additionally, it handles the reset condition for the UART functionality.\n\n Module header:\n\nmodule fpga_core (input wire clk,input wire rst,input wire btnu,input wire btnl,input wire btnd,input wire btnr,input wire btnc,input wire [7:0] sw,output wire [7:0] led,input wire uart_rxd,output wire uart_txd,output wire uart_rts,input wire uart_cts);\n [/INST]\n", "output": "reg [7:0] uart_tx_axis_tdata; \n reg uart_tx_axis_tvalid; \n wire uart_tx_axis_tready; \n wire [7:0] uart_rx_axis_tdata; \n wire uart_rx_axis_tvalid; \n reg uart_rx_axis_tready; \n assign uart_rts = 1'b1; \n uart \n uart_inst (.clk(clk),.rst(rst),.s_axis_tdata(uart_tx_axis_tdata),.s_axis_tvalid(uart_tx_axis_tvalid),.s_axis_tready(uart_tx_axis_tready),.m_axis_tdata(uart_rx_axis_tdata),.m_axis_tvalid(uart_rx_axis_tvalid),.m_axis_tready(uart_rx_axis_tready),.rxd(uart_rxd),.txd(uart_txd),.tx_busy(),.rx_busy(),.rx_overrun_error(),.rx_frame_error(),.prescale(125000000/(9600*8))); \n assign led = uart_tx_axis_tdata; \n always @(posedge clk or posedge rst) begin \n  if (rst) begin \n  uart_tx_axis_tdata <= 0; \n  uart_tx_axis_tvalid <= 0; \n  uart_rx_axis_tready <= 0; \n  end else begin \n  if (uart_tx_axis_tvalid) begin \n  uart_rx_axis_tready <= 0; \n  if (uart_tx_axis_tready) begin \n  uart_tx_axis_tvalid <= 0; \n  end \n  end else begin \n  uart_rx_axis_tready <= 1; \n  if (uart_rx_axis_tvalid) begin \n  uart_rx_axis_tready <= ~uart_rx_axis_tready; \n  uart_tx_axis_tdata <= uart_rx_axis_tdata; \n  uart_tx_axis_tvalid <= 1; \n  end \n  end \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a SPI Master (Serial Peripheral Interface Master) controller. It generates the clock signal and controls the serial data output (MOSI) and slave select (SSbar) signals based on the state machine. The module also manages the shifting of data and the division of the clock signal. The state machine transitions through different states based on the clock and control signals to manage the SPI communication protocol.\n\n Module header:\n\nmodule spim(input clk,input rst,input[7:0] din,input wen,input wdiv,output rdy,output reg SCLK,output MOSI,output reg SSbar);\n [/INST]\n", "output": "wire tick; \n  reg[7:0] clk_div_count; \n  reg[1:0] state,n_state; \n  reg shift; \n  reg[7:0] div,data; \n  reg nSSr,SCLKr; \n  reg[3:0] bit_count; \n  reg bit_count_rst,bit_count_en; \n  always @(posedge clk or posedge rst) begin \n  if(rst) clk_div_count <= 0; \n  else \n  if(tick) clk_div_count <= 0; \n  else clk_div_count <= clk_div_count + 1; \n  end \n  assign tick = (clk_div_count == div); \n  assign rdy = (state == 0); \n  always @(posedge clk or posedge rst) begin \n  if(rst) begin \n  data <= 0; \n  div <= 0; \n  end \n  else begin \n  if(wen & rdy) data <= din; \n  else if(shift & tick) data <= { data[6:0] , 1'b0 }; \n  if(wdiv) div <= din; \n  end \n  end \n  assign MOSI = data[7]; \n  always @(posedge clk or posedge rst) begin \n  if(rst) begin \n  SSbar <= 1; \n  SCLK <= 0; \n  end \n  else begin \n  if(tick) begin \n  SSbar <= nSSr; \n  SCLK <= SCLKr; \n  end \n  end \n  end \n  always @(posedge clk or posedge rst) begin \n  if(rst) bit_count <= 0; \n  else \n  if(bit_count_rst) bit_count <= 0; \n  else if(tick & bit_count_en) bit_count <= bit_count + 1; \n  end \n  always @(posedge clk or posedge rst) begin \n  if(rst) state <= 0; \n  else state <= n_state; \n  end \n  always @(*) begin \n  n_state <= state; \n  nSSr <= 0; \n  bit_count_rst <= 0; \n  SCLKr <= 0; \n  shift <= 0; \n  bit_count_en <= 0; \n  case(state) \n  0: begin \n  nSSr <= 1; \n  if(wen) n_state <= 1; \n  end \n  1: begin \n  bit_count_rst <= 1; \n  if(tick) n_state <= 2; \n  end \n  2: begin \n  SCLKr <= 1; \n  if(tick) n_state <= 3; \n  end \n  3: begin \n  shift <= 1; \n  bit_count_en <= 1; \n  if(tick) \n  if(bit_count < 7) n_state <= 2; \n  else n_state <= 0; \n  end \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module represents a state machine that processes Ethernet receive statistics. It includes input signals such as clock and reset, and outputs the current state of the state machine. The module contains registers for each state and wires to determine the start of each state transition based on various input conditions.\n\nThe state transitions are determined by the start conditions and the clock signal. When the reset signal is asserted, the module initializes the states to their default values. Based on the start conditions, the states are updated accordingly to progress the state machine.\n\nThe module also assigns the output state data based on the current state of the state machine. The state transitions and updates are performed based on the specified conditions, as well as the clock and reset signals.\n\n Module header:\n\nmodule eth_rxstatem (MRxClk, Reset, MRxDV, ByteCntEq0, ByteCntGreat2, Transmitting, MRxDEq5, MRxDEqD,IFGCounterEq24, ByteCntMaxFrame, StateData, StateIdle, StatePreamble, StateSFD,StateDrop);\n [/INST]\n", "output": "parameter Tp = 1; \n input MRxClk; \n input Reset; \n input MRxDV; \n input ByteCntEq0; \n input ByteCntGreat2; \n input MRxDEq5; \n input Transmitting; \n input MRxDEqD; \n input IFGCounterEq24; \n input ByteCntMaxFrame; \n output [1:0] StateData; \n output StateIdle; \n output StateDrop; \n output StatePreamble; \n output StateSFD; \n reg StateData0; \n reg StateData1; \n reg StateIdle; \n reg StateDrop; \n reg StatePreamble; \n reg StateSFD; \n wire StartIdle; \n wire StartDrop; \n wire StartData0; \n wire StartData1; \n wire StartPreamble; \n wire StartSFD; \n assign StartIdle = ~MRxDV & (StateDrop | StatePreamble | StateSFD | (|StateData)); \n assign StartPreamble = MRxDV & ~MRxDEq5 & (StateIdle & ~Transmitting); \n assign StartSFD = MRxDV & MRxDEq5 & (StateIdle & ~Transmitting | StatePreamble); \n assign StartData0 = MRxDV & (StateSFD & MRxDEqD & IFGCounterEq24 | StateData1); \n assign StartData1 = MRxDV & StateData0 & (~ByteCntMaxFrame); \n assign StartDrop = MRxDV & (StateIdle & Transmitting | StateSFD & ~IFGCounterEq24 & MRxDEqD| StateData0 & ByteCntMaxFrame); \n always @ (posedge MRxClk or posedge Reset) \n begin \n  if(Reset) \n  begin \n  StateIdle <= #Tp 1'b0; \n  StateDrop <= #Tp 1'b1; \n  StatePreamble <= #Tp 1'b0; \n  StateSFD <= #Tp 1'b0; \n  StateData0 <= #Tp 1'b0; \n  StateData1 <= #Tp 1'b0; \n  end \n  else \n  begin \n  if(StartPreamble | StartSFD | StartDrop) \n  StateIdle <= #Tp 1'b0; \n  else \n  if(StartIdle) \n  StateIdle <= #Tp 1'b1; \n  if(StartIdle) \n  StateDrop <= #Tp 1'b0; \n  else \n  if(StartDrop) \n  StateDrop <= #Tp 1'b1; \n  if(StartSFD | StartIdle | StartDrop) \n  StatePreamble <= #Tp 1'b0; \n  else \n  if(StartPreamble) \n  StatePreamble <= #Tp 1'b1; \n  if(StartPreamble | StartIdle | StartData0 | StartDrop) \n  StateSFD <= #Tp 1'b0; \n  else \n  if(StartSFD) \n  StateSFD <= #Tp 1'b1; \n  if(StartIdle | StartData1 | StartDrop) \n  StateData0 <= #Tp 1'b0; \n  else \n  if(StartData0) \n  StateData0 <= #Tp 1'b1; \n  if(StartIdle | StartData0 | StartDrop) \n  StateData1 <= #Tp 1'b0; \n  else \n  if(StartData1) \n  StateData1 <= #Tp 1'b1; \n  end \n end \n assign StateData[1:0] = {StateData1, StateData0}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements early expiration and normalization for a floating-point multiplication circuit. It checks if the exponent is zero and sets the expiration flag accordingly. Additionally, it normalizes the mantissa based on early or late conditions, updating the normalized mantissa accordingly. The module is sensitive to the clock signal and the input mantissas.\n\n Module header:\n\nmodule hrfp_mult_normalize (output reg expdiff,output reg [53:0] normalized_mantissa,input wire clk,input wire [53:0] mantissa4, mantissa5);\n [/INST]\n", "output": "parameter EARLY_EXPDIFF = 1; \n  parameter EARLY_NORMALIZE = 0; \n  generate \n  if(EARLY_EXPDIFF) begin : CHECK_EXPDIFF_EARLY \n  always @(posedge clk) begin \n  expdiff <= 1; \n  if(!mantissa4[53:50]) begin \n  expdiff <= 0; \n  end \n  end \n  end else begin : CHECK_EXPDIFF_LATE \n  always @* begin \n  expdiff = 1; \n  if(!mantissa5[53:50]) begin \n  expdiff = 0; \n  end \n  end \n  end \n  endgenerate \n  generate \n  if(EARLY_NORMALIZE) begin : CHECK_NORMALIZATION_EARLY \n  always @(posedge clk) begin \n  normalized_mantissa <= mantissa4[53:0]; \n  if(!mantissa4[53:50]) begin \n  normalized_mantissa <= {mantissa4[49:0], 4'b0000}; \n  end \n  end \n  end else begin : CHECK_NORMALIZATION_LATE \n  always @* begin \n  normalized_mantissa = mantissa5[53:0]; \n  if(!expdiff) begin \n  normalized_mantissa = {mantissa5[49:0], 4'b0000}; \n  end \n  end \n  end \n  endgenerate \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module represents a level-sensitive gated D-latch with an asynchronous set. It takes in the D (data input), GATE (enable input), and SLEEP_B (asynchronous clear) signals and outputs Q (latch output). When SLEEP_B is high, the latch is asynchronously cleared. The GATE input is delayed, and the notifier register is used to control the delay. The awake signal is high when SLEEP_B is 1. The latch is implemented using a D flip-flop (dlatch0), and the output is buffered (bufif10) with the power supply connections KAPWR, VPWR, VGND, VPB, and VNB.\n\n Module header:\n\nmodule sky130_fd_sc_lp__srdlxtp (Q ,D ,GATE ,SLEEP_B);\n [/INST]\n", "output": "output Q ; \n  input D ; \n  input GATE ; \n  input SLEEP_B; \n  supply1 KAPWR; \n  supply1 VPWR ; \n  supply0 VGND ; \n  supply1 VPB ; \n  supply0 VNB ; \n  wire buf_Q ; \n  wire GATE_delayed; \n  wire D_delayed ; \n  reg notifier ; \n  wire awake ; \n  sky130_fd_sc_lp__udp_dlatch$P_pp$PKG$sN dlatch0 (buf_Q , D_delayed, GATE_delayed, SLEEP_B, notifier, KAPWR, VGND, VPWR); \n  assign awake = ( SLEEP_B === 1'b1 ); \n  bufif1 bufif10 (Q , buf_Q, VPWR ); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a state machine that controls the transmission of data through a UART. It transitions between different states based on the input signals and controls the output of uart_data and uart_send accordingly. The state machine is triggered by the trig input and progresses through states such as LOAD, A1, A2H, A2L, A3H, and A3L based on the values of the input commands. It also waits for the uart_ready signal before transitioning to the next state. Upon completion, it returns to the IDLE state to await the next trigger. The module effectively manages the UART transmission process based on the input signals and commands.\n\n Module header:\n\nmodule msg_tx(input clk_sys,output [0:7] uart_data,output uart_send,input uart_ready,input [0:2] trig,output [0:2] ena,input [0:7] cmd,input [0:7] a1,input [0:15] a2,input [0:15] a3);\n [/INST]\n", "output": "localparam IDLE = 3'd0; \n  localparam LOAD = 3'd1; \n  localparam A1 = 3'd2; \n  localparam A2H = 3'd3; \n  localparam A2L = 3'd4; \n  localparam A3H = 3'd5; \n  localparam A3L = 3'd6; \n  localparam WAIT = 3'd7; \n  reg [0:2] state = IDLE; \n  reg [1:3] a; \n  reg [0:7] ia1; \n  reg [0:15] ia2; \n  reg [0:15] ia3; \n  always @ (posedge clk_sys) begin \n  uart_send <= 0; \n  case (state) \n  IDLE: begin \n  if (trig != 3'b0) begin \n  ena[0] <= trig[0]; \n  ena[1] <= trig[1] & ~trig[0]; \n  ena[2] <= trig[2] & ~trig[1] & ~trig[0]; \n  state <= LOAD; \n  end \n  end \n  LOAD: begin \n  a <= cmd[5:7]; \n  ia1 <= a1; \n  ia2 <= a2; \n  ia3 <= a3; \n  uart_data <= cmd; \n  uart_send <= 1; \n  if (cmd[5]) state <= A1; \n  else if (cmd[6]) state <= A2H; \n  else if (cmd[7]) state <= A3H; \n  else state <= WAIT; \n  end \n  A1: begin \n  if (uart_ready) begin \n  uart_data <= ia1; \n  uart_send <= 1; \n  if (a[2]) state <= A2H; \n  else if (a[3]) state <= A3H; \n  else state <= WAIT; \n  end \n  end \n  A2H: begin \n  if (uart_ready) begin \n  uart_data <= ia2[0:7]; \n  uart_send <= 1; \n  state <= A2L; \n  end \n  end \n  A2L: begin \n  if (uart_ready) begin \n  uart_data <= ia2[8:15]; \n  uart_send <= 1; \n  if (a[3]) state <= A3H; \n  else state <= WAIT; \n  end \n  end \n  A3H: begin \n  if (uart_ready) begin \n  uart_data <= ia3[0:7]; \n  uart_send <= 1; \n  state <= A3L; \n  end \n  end \n  A3L: begin \n  if (uart_ready) begin \n  uart_data <= ia3[8:15]; \n  uart_send <= 1; \n  state <= WAIT; \n  end \n  end \n  WAIT: begin \n  if (uart_ready) begin \n  ena <= 3'd0; \n  state <= IDLE; \n  end \n  end \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a finite precision rounding module with configurable input and output sizes. It rounds the input datain to the specified precision and outputs the rounded result as dataout. The rounding process is controlled by clock signals, reset signals, and rounding flags. The module also handles sign extension and clip increment based on the rounding result and validity flags. The rounding output is determined based on the rounding result, sign bit, and specified output size.\n\n Module header:\n\nmodule FinitePrecRndNrst #(parameter C_IN_SZ=37,C_OUT_SZ=16,C_FRAC_SZ=15) ( input wire CLK,input wire RST,input wire signed [C_IN_SZ-1:0] datain,input wire dataval,output wire signed [C_OUT_SZ-1:0] dataout,output reg clip_inc,output reg dval_out);\n [/INST]\n", "output": "wire sign; \n  wire signed [C_IN_SZ-1:0] rc_val; \n  reg signed [C_IN_SZ-1:0] data_round_f; \n  wire signed [C_IN_SZ-C_FRAC_SZ-1:0] data_round; \n  reg signed [C_OUT_SZ-1:0] data_rs; \n  reg dataval_d1; \n  reg sign_d1; \n  assign sign = datain[C_IN_SZ-1]; \n  assign rc_val = { {(C_IN_SZ-C_FRAC_SZ){1'b0}}, 1'b1, {(C_FRAC_SZ-1){1'b0}} }; \n  always @(posedge CLK or posedge RST) \n  if(RST) \n  begin \n  data_round_f <= 'b0; \n  dataval_d1 <= 1'b0; \n  sign_d1 <= 1'b0; \n  dval_out <= 1'b0; \n  end \n  else \n  begin \n  data_round_f <= datain + rc_val; \n  dataval_d1 <= dataval; \n  dval_out <= dataval_d1; \n  sign_d1 <= sign; \n  end \n  assign data_round = data_round_f[C_IN_SZ-1:C_FRAC_SZ]; \n  always @(posedge CLK or posedge RST) \n  if(RST) \n  begin \n  data_rs <= 'b0; \n  clip_inc <= 1'b0; \n  end \n  else \n  begin \n  clip_inc <= 1'b0; \n if(((C_IN_SZ-C_FRAC_SZ != C_OUT_SZ) &&(~(&data_round[C_IN_SZ-C_FRAC_SZ-1 : C_OUT_SZ-1])) ==(|(data_round[C_IN_SZ-C_FRAC_SZ-1 : C_OUT_SZ-1])))||((C_IN_SZ-C_FRAC_SZ == C_OUT_SZ) &&(data_round[C_IN_SZ-C_FRAC_SZ-1] != sign_d1) &&data_round != {C_OUT_SZ{1'b0}})) \n  begin \n  if(dataval_d1) \n  clip_inc <= 1'b1; \n  if(sign_d1) \n  data_rs <= -(2**(C_OUT_SZ)/2)+1; \n  else \n  data_rs <= (2**(C_OUT_SZ)/2)-1; \n  end \n  else \n  data_rs <= data_round[C_OUT_SZ-1:0]; \n  end \n  assign dataout = data_rs; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `eth_crc_104` takes a 104-bit data input and a 32-bit CRC state as input, and outputs a 32-bit CRC next value. It uses a CRC iteration function `crc_iteration` to update the CRC state based on the data input. The `crc_iteration` function appends 24 bits of zeros to the data input and performs the CRC calculation on the concatenated value to compute the next CRC state.\n\n Module header:\n\nmodule eth_crc_104 (input wire [103:0] data_in,input wire [31:0] crc_state,output wire [31:0] crc_next);\n [/INST]\n", "output": "assign crc_next = crc_iteration( 104, crc_state, { 24'h0, data_in} ); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module is a channel tester that operates with a configurable data width. It consists of a state machine that controls the reception and transmission of data. When reset, the module initializes various internal registers. The reception and transmission of data are controlled based on the current state of the state machine. The received data is stored in a register, and its validity is checked before transitioning to the transmission state. When transmitting data, the module updates the data and the state machine based on the received data validity and length. The module operates based on the clock signal and reset input to control its internal state transitions and data flow.\n\n Module header:\n\nmodule chnl_tester #(parameter C_PCI_DATA_WIDTH = 9'd32) (input CLK,input RST,output CHNL_RX_CLK,input CHNL_RX,output CHNL_RX_ACK,input CHNL_RX_LAST,input [31:0] CHNL_RX_LEN,input [30:0] CHNL_RX_OFF,input [C_PCI_DATA_WIDTH-1:0] CHNL_RX_DATA,input CHNL_RX_DATA_VALID,output CHNL_RX_DATA_REN,output CHNL_TX_CLK,output CHNL_TX,input CHNL_TX_ACK,output CHNL_TX_LAST,output [31:0] CHNL_TX_LEN,output [30:0] CHNL_TX_OFF,output [C_PCI_DATA_WIDTH-1:0] CHNL_TX_DATA,output CHNL_TX_DATA_VALID,input CHNL_TX_DATA_REN);\n [/INST]\n", "output": "reg [C_PCI_DATA_WIDTH-1:0] rData={C_PCI_DATA_WIDTH{1'b0}}; \n reg [31:0] rLen=0; \n reg [31:0] rCount=0; \n reg [1:0] rState=0; \n assign CHNL_RX_CLK = CLK; \n assign CHNL_RX_ACK = (rState == 2'd1); \n assign CHNL_RX_DATA_REN = (rState == 2'd1); \n assign CHNL_TX_CLK = CLK; \n assign CHNL_TX = (rState == 2'd3); \n assign CHNL_TX_LAST = 1'd1; \n assign CHNL_TX_LEN = rLen; \n assign CHNL_TX_OFF = 0; \n assign CHNL_TX_DATA = rData; \n assign CHNL_TX_DATA_VALID = (rState == 2'd3); \n always @(posedge CLK or posedge RST) begin \n  if (RST) begin \n  rLen <= #1 0; \n  rCount <= #1 0; \n  rState <= #1 0; \n  rData <= #1 0; \n  end \n  else begin \n  case (rState) \n  2'd0: begin \n  if (CHNL_RX) begin \n  rLen <= #1 CHNL_RX_LEN; \n  rCount <= #1 0; \n  rState <= #1 2'd1; \n  end \n  end \n  2'd1: begin \n  if (CHNL_RX_DATA_VALID) begin \n  rData <= #1 CHNL_RX_DATA; \n  rCount <= #1 rCount + (C_PCI_DATA_WIDTH/32); \n  end \n  if (rCount >= rLen) \n  rState <= #1 2'd2; \n  end \n  2'd2: begin \n  rCount <= #1 (C_PCI_DATA_WIDTH/32); \n  rState <= #1 2'd3; \n  end \n  2'd3: begin \n  if (CHNL_TX_DATA_REN & CHNL_TX_DATA_VALID) begin \n  rData <= #1 {rCount + 4, rCount + 3, rCount + 2, rCount + 1}; \n  rCount <= #1 rCount + (C_PCI_DATA_WIDTH/32); \n  if (rCount >= rLen) \n  rState <= #1 2'd0; \n  end \n  end \n  endcase \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is designed to read data from a hardware device. It includes logic for error checking and data validation. The module utilizes a clock signal and a reset signal, along with an enable signal and data inputs from the hardware device. It also features a test data register to compare and validate incoming data. The error flag is set if there is a data mismatch, and the test data is incremented for comparison. This module implements the functionality to synchronize and validate incoming data from the hardware device.\n\n Module header:\n\nmodule hd_data_reader (input clk,input rst,input enable,output reg error,input hd_read_from_host,input [31:0] hd_data_from_host);\n [/INST]\n", "output": "reg prev_enable; \n wire posedge_enable; \n reg [31:0] test_data; \n assign posedge_enable = (!prev_enable && enable); \n always @ (posedge clk) begin \n  if (rst) begin \n  prev_enable <= 0; \n  error <= 0; \n  test_data <= 0; \n  end \n  else begin \n  prev_enable <= enable; \n  if (posedge_enable) begin \n  error <= 0; \n  test_data <= 0; \n  end \n  else begin \n  if (hd_read_from_host) begin \n  if (hd_data_from_host != test_data) begin \n  error <= 1; \n  end \n  test_data <= test_data + 1; \n  end \n  end \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is designed to generate VGA synchronization signals and process incoming RGB data for display. It utilizes parameters and local parameters to define timing and polarity settings for the VGA output. The horizontal and vertical positions are calculated based on the input clock signal, and synchronization signals are generated accordingly.\n\nThe module includes logic to handle active high or active low synchronization based on the specified polarity. It resets the horizontal and vertical positions on the negative edge of the asynchronous reset signal and increments the positions based on the input clock. It also generates horizontal and vertical synchronization signals.\n\nFor the RGB data output, it checks for blanking intervals and updates the output accordingly. The module also provides a ready signal based on the current position, and it handles blanking and synchronization signals based on the calculated positions.\n\nThe module effectively processes the incoming RGB data and generates the necessary synchronization signals for VGA display.\n\n Module header:\n\nmodule vga_sync #(parameter H_TOTAL_WIDTH = 11,parameter V_TOTAL_WIDTH = 11,parameter POLARITY = 1'b1,parameter H_FRONT = 56,parameter H_SYNC = 120,parameter H_BACK = 64,parameter H_ACT = 800,parameter V_FRONT = 37,parameter V_SYNC = 6,parameter V_BACK = 23,parameter V_ACT = 600)(input wire clock,input wire aresetn,input wire [9:0] R_in,input wire [9:0] G_in,input wire [9:0] B_in,output wire [(H_TOTAL_WIDTH-1):0] current_x,output wire [(V_TOTAL_WIDTH-1):0] current_y,output wire ready,output wire vga_clk,output reg [7:0] R_out,output reg [7:0] G_out,output reg [7:0] B_out,output reg h_sync,output reg v_sync,output wire blank_n,output wire sync_n);\n [/INST]\n", "output": "localparam H_BLANK = H_FRONT+H_SYNC+H_BACK; \n localparam H_TOTAL = H_FRONT+H_SYNC+H_BACK+H_ACT; \n localparam V_BLANK = V_FRONT+V_SYNC+V_BACK; \n localparam V_TOTAL = V_FRONT+V_SYNC+V_BACK+V_ACT; \n reg [(H_TOTAL_WIDTH-1):0] hor_pos; \n reg [(V_TOTAL_WIDTH-1):0] ver_pos; \n reg is_active_high; \n always @(posedge clock) begin \n  is_active_high = POLARITY; \n end \n assign vga_clk = ~clock; \n assign current_x = (hor_pos >= H_BLANK) ? hor_pos - H_BLANK : 'd0; \n assign current_y = (ver_pos >= V_BLANK) ? ver_pos - V_BLANK : 'd0; \n always @(posedge clock or negedge aresetn) begin \n  if (~aresetn) \n  begin \n  hor_pos <= 'd0; \n  h_sync <= is_active_high ? 1'b0 : 1'b1; \n  end \n  else \n  begin \n  if (hor_pos < H_TOTAL) hor_pos <= hor_pos + 1; \n  else hor_pos <= 0; \n  if (hor_pos == H_FRONT-1) h_sync <= is_active_high ? 1'b1 : 1'b0; \n  if (hor_pos == H_FRONT+H_SYNC-1) h_sync <= is_active_high ? 1'b0 : 1'b1; \n  end \n end \n always @(posedge h_sync or negedge aresetn) begin \n  if (~aresetn) \n  begin \n  ver_pos <= 'd0; \n  v_sync <= is_active_high ? 1'b0 : 1'b1; \n  end \n  else \n  begin \n  if (ver_pos < V_TOTAL) ver_pos <= ver_pos + 1; \n  else ver_pos <= 0; \n  if (ver_pos == V_FRONT-1) v_sync <= is_active_high ? 1'b1 : 1'b0; \n  if (ver_pos == V_FRONT+V_SYNC-1) v_sync <= is_active_high ? 1'b0 : 1'b1; \n  end \n end \n always @(posedge clock or negedge aresetn) begin \n  if (~aresetn) \n  begin \n  R_out <= 8'd0; \n  B_out <= 8'd0; \n  G_out <= 8'd0; \n  end \n  else if ((hor_pos < H_BLANK) | (ver_pos < V_BLANK)) \n  begin \n  R_out <= 8'd0; \n  B_out <= 8'd0; \n  G_out <= 8'd0; \n  end \n  else \n  begin \n  R_out <= R_in[9:2]; \n  B_out <= B_in[9:2]; \n  G_out <= G_in[9:2]; \n  end \n end \n assign blank_n = ~((hor_pos < H_BLANK) | (ver_pos < V_BLANK)); \n assign sync_n = 1'b1; \n assign ready = ((hor_pos >= H_BLANK & hor_pos < H_TOTAL) & (ver_pos >= V_BLANK & ver_pos < V_TOTAL)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a First-In-First-Out (FIFO) buffer with a configurable data width, address width, and depth. It has input and output signals for data, read and write enables, clock signals, and a clear signal. The module contains memory for storing the data, logic for controlling read and write operations, and status signals indicating whether the FIFO is full or empty. The addresses for read and write operations are managed using Gray counters, and the module includes logic to handle full and empty conditions and to manage the status of the FIFO.\n\n Module header:\n\nmodule vgafb_asfifo #(parameter DATA_WIDTH = 8,ADDRESS_WIDTH = 4,FIFO_DEPTH = (1 << ADDRESS_WIDTH)) (output wire [DATA_WIDTH-1:0] Data_out,output reg Empty_out,input wire ReadEn_in,input wire RClk,input wire [DATA_WIDTH-1:0] Data_in,output reg Full_out,input wire WriteEn_in,input wire WClk,input wire Clear_in);\n [/INST]\n", "output": "reg [DATA_WIDTH-1:0] Mem [FIFO_DEPTH-1:0]; \n  wire [ADDRESS_WIDTH-1:0] pNextWordToWrite, pNextWordToRead; \n  wire EqualAddresses; \n  wire NextWriteAddressEn, NextReadAddressEn; \n  wire Set_Status, Rst_Status; \n  reg Status; \n  wire PresetFull, PresetEmpty; \n  assign Data_out = Mem[pNextWordToRead]; \n  always @ (posedge WClk) \n  if (WriteEn_in & !Full_out) \n  Mem[pNextWordToWrite] <= Data_in; \n  assign NextWriteAddressEn = WriteEn_in & ~Full_out; \n  assign NextReadAddressEn = ReadEn_in & ~Empty_out; \n vgafb_graycounter #(.COUNTER_WIDTH( ADDRESS_WIDTH )) GrayCounter_pWr (.GrayCount_out(pNextWordToWrite),.Enable_in(NextWriteAddressEn),.Clear_in(Clear_in),.Clk(WClk)); \n vgafb_graycounter #(.COUNTER_WIDTH( ADDRESS_WIDTH )) GrayCounter_pRd (.GrayCount_out(pNextWordToRead),.Enable_in(NextReadAddressEn),.Clear_in(Clear_in),.Clk(RClk)); \n  assign EqualAddresses = (pNextWordToWrite == pNextWordToRead); \n  assign Set_Status = (pNextWordToWrite[ADDRESS_WIDTH-2] ~^ pNextWordToRead[ADDRESS_WIDTH-1]) & \n  (pNextWordToWrite[ADDRESS_WIDTH-1] ^ pNextWordToRead[ADDRESS_WIDTH-2]); \n  assign Rst_Status = (pNextWordToWrite[ADDRESS_WIDTH-2] ^ pNextWordToRead[ADDRESS_WIDTH-1]) & \n  (pNextWordToWrite[ADDRESS_WIDTH-1] ~^ pNextWordToRead[ADDRESS_WIDTH-2]); \n  always @ (Set_Status, Rst_Status, Clear_in) \n  if (Rst_Status | Clear_in) \n  Status = 0; \n  else if (Set_Status) \n  Status = 1; \n  assign PresetFull = Status & EqualAddresses; \n  always @ (posedge WClk, posedge PresetFull) \n  if (PresetFull) \n  Full_out <= 1; \n  else \n  Full_out <= 0; \n  assign PresetEmpty = ~Status & EqualAddresses; \n  always @ (posedge RClk, posedge PresetEmpty) \n  if (PresetEmpty) \n  Empty_out <= 1; \n  else \n  Empty_out <= 0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements an instruction memory for a computer control unit. It takes a 16-bit counter input and decodes it to output a corresponding 16-bit instruction word. The module uses a case statement to map specific counter values to predefined instruction words, which are then assigned to the output based on the counter input. If the counter input does not match any defined case, the output is set to all zeros.\n\n Module header:\n\nmodule Computer_ControlUnit_InstructionMemory(output reg [WORD_WIDTH-1:0] INSTR_out,input [WORD_WIDTH-1:0] COUNTER_in);\n [/INST]\n", "output": "parameter WORD_WIDTH = 16; \n parameter DR_WIDTH = 3; \n parameter SB_WIDTH = DR_WIDTH; \n parameter SA_WIDTH = DR_WIDTH; \n parameter OPCODE_WIDTH = 7; \n parameter CNTRL_WIDTH = DR_WIDTH+SB_WIDTH+SA_WIDTH+11; \n parameter COUNTER_WIDTH = 4; \n always@(COUNTER_in) \n  begin \n  case(COUNTER_in) \n  16'h0000: INSTR_out = 16'b100_1100_000_000_011; \n  16'h0001: INSTR_out = 16'b100_1100_001_000_111; \n  16'h0002: INSTR_out = 16'b000_0000_010_000_XXX; \n  16'h0003: INSTR_out = 16'b000_1100_011_XXX_001; \n  16'h0004: INSTR_out = 16'b000_0010_100_000_001; \n  16'h0005: INSTR_out = 16'b000_0101_101_011_100; \n  16'h0006: INSTR_out = 16'b110_0000_000_101_011; \n  16'h0007: INSTR_out = 16'b110_0001_000_101_011; \n  16'h000A: INSTR_out = 16'b111_0000_110_000_001; \n  default: INSTR_out = 16'b0; \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module AluControl decodes the ALU operation based on the input aluOp and the instruction codes. It uses nested case statements to determine the ALU operation based on various combinations of instruction code low bits and high bits, and assigns the corresponding ALU operation to the output reg aluOperation.\n\n Module header:\n\nmodule AluControl(input [1:0] aluOp,input [5:0] instructionCodeLowBits,input [5:0] instructionCodeHighBits,output reg [3:0] aluOperation);\n [/INST]\n", "output": "always @(*)begin \n  case(aluOp) \n  0: aluOperation<=3; \n  1: aluOperation<=4; \n  2: begin \n  case(instructionCodeLowBits) \n  6'b000000: aluOperation<=0; \n  6'b000010: aluOperation<=1; \n  6'b000011: aluOperation<=2; \n  6'b000110: aluOperation<=1; \n  6'b000111: aluOperation<=2; \n  6'b000100: aluOperation<=0; \n  6'b100000: aluOperation<=3; \n  6'b100010: aluOperation<=4; \n  6'b100100: aluOperation<=5; \n  6'b100101: aluOperation<=6; \n  6'b100110: aluOperation<=7; \n  6'b100111: aluOperation<=8; \n  6'b101010: aluOperation<=9; \n  default: aluOperation<='hF; \n  endcase \n  end \n  3: begin \n  case(instructionCodeHighBits) \n  6'b001000: aluOperation<=3; \n  6'b001100: aluOperation<=5; \n  6'b001101: aluOperation<=6; \n  6'b001110: aluOperation<=7; \n  6'b001010: aluOperation<=9; \n  default: aluOperation<='hF; \n  endcase \n  end \n  default:aluOperation<='hF; \n  endcase \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a shift register FIFO (First-In-First-Out) with a specified depth and width. It has an input X, an output Y, and a clock input. The module uses a memory array to store the input data and shifts the data on each clock cycle. The output Y is assigned the data at the end of the shift register. The input X is loaded into the first position of the memory array.\n\n Module header:\n\nmodule shiftRegFIFO(X, Y, clk);\n [/INST]\n", "output": "parameter depth=1, width=1; \n  output [width-1:0] Y; \n  input [width-1:0] X; \n  input clk; \n  reg [width-1:0] mem [depth-1:0]; \n  integer index; \n  assign Y = mem[depth-1]; \n  always @ (posedge clk) begin \n  for(index=1;index<depth;index=index+1) begin \n  mem[index] <= mem[index-1]; \n  end \n  mem[0]<=X; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module serves as a top-level design for an FPGA system. The module connects input switches, keys, clock signals, and system reset signals to various internal functional blocks, such as the system reset controller, key synchronizer bank, switch synchronizer bank, key command controller, calculator module, absolute value calculation module, BCD binary encoder, BCD segment decoder, and 7-segment display decoders. It configures the connections and interactions between these functional blocks to implement the desired system behavior. The output LED displays are connected to the result of various calculations and are updated based on the input key and switch signals. This design effectively acts as the main controller and interconnection point for the entire system.\n\n Module header:\n\nmodule EECS301_Lab4_TopLevel #(parameter KEY_LOCK_DELAY = 500000000,parameter SW_DEBOUNCE_TIME = 10000000) (input CLOCK_50,output [9:0] LEDR,output [6:0] HEX0,output [6:0] HEX1,output [6:0] HEX2,output [6:0] HEX3,output [6:0] HEX4,output [6:0] HEX5,input [3:0] KEY,input [9:0] SW);\n [/INST]\n", "output": "localparam CLOCK_50_RATE = 50000000; \n  assign LEDR = SW; \n  wire sys_reset; \n  System_Reset_Module \n #(.REF_CLK_RATE_HZ( CLOCK_50_RATE ),.POWER_ON_DELAY( 500 )) \n  sys_reset_ctrl \n (.PLL_LOCKED( 1'b1 ),.REF_CLK( CLOCK_50 ),.RESET( sys_reset )); \n  wire key_add; \n  wire key_sub; \n  wire key_clr; \n  Key_Synchronizer_Bank \n #(.KEY_SYNC_CHANNELS( 3 ),.CLK_RATE_HZ( CLOCK_50_RATE ),.KEY_LOCK_DELAY( KEY_LOCK_DELAY )) \n  key_sync_bank \n (.KEY( { ~KEY[3], ~KEY[1:0] } ),.KEY_EVENT( { key_clr, key_sub, key_add } ),.CLK( CLOCK_50 )); \n  wire [9:0] calc_operand; \n  Switch_Synchronizer_Bank \n #(.SWITCH_SYNC_CHANNELS( 10 ),.CLK_RATE_HZ( CLOCK_50_RATE ),.DEBOUNCE_TIME( SW_DEBOUNCE_TIME ),.SIG_OUT_INIT( 1'b0 )) \n  switch_sync_bank \n (.SIG_IN( SW ),.SIG_OUT( calc_operand ),.CLK( CLOCK_50 )); \n  wire cmd_clear; \n  wire cmd_compute; \n  wire cmd_operation; \n  wire cmd_done; \n  Key_Command_Controller key_commander \n (.KEY_CLEAR( key_clr ),.KEY_ADD( key_add ),.KEY_SUB( key_sub ),.CMD_DONE( cmd_done ),.CMD_CLEAR( cmd_clear ),.CMD_COMPUTE( cmd_compute ),.CMD_OPERATION( cmd_operation ),.CLK( CLOCK_50 ),.RESET( sys_reset )); \n  localparam CALC_DATA_WIDTH = 10; \n  localparam CALC_RESULT_WIDTH = 18; \n  wire calc_result_ready; \n  wire [CALC_RESULT_WIDTH-1:0] calc_result_data; \n  Calculator_Module \n #(.DATA_WIDTH( CALC_DATA_WIDTH ),.RESULT_WIDTH( CALC_RESULT_WIDTH )) \n  calculator \n (.DONE( cmd_done ),.CLEAR( cmd_clear ),.COMPUTE( cmd_compute ),.OPERATION( cmd_operation ),.CALC_DATA( calc_operand ),.RESULT_READY( calc_result_ready ),.RESULT_DATA( calc_result_data ),.CLK( CLOCK_50 ),.RESET( sys_reset )); \n  wire [CALC_RESULT_WIDTH-1:0] abs_result_data; \n  FxP_ABS_Function \n #(.DATA_WIDTH( CALC_RESULT_WIDTH )) \n  calc_result_abs \n (.DATA_IN( calc_result_data ),.DATA_ABS( abs_result_data )); \n  localparam BCD_DIGITS = 5; \n  wire [BCD_DIGITS*4-1:0] bcd_result; \n  wire bcd_overflow; \n  BCD_Binary_Encoder \n #(.BIN_WIDTH( CALC_RESULT_WIDTH ),.BDC_DIGITS( BCD_DIGITS )) \n  result_to_bcd_converter \n (.CONVERT( calc_result_ready ),.DONE( ),.BIN_IN( abs_result_data ),.BCD_OUT( bcd_result ),.BCD_OVERFLOW( bcd_overflow ),.CLK( CLOCK_50 ),.RESET( sys_reset )); \n  wire [BCD_DIGITS*7-1:0] seg_out; \n  BCD_Segment_Decoder \n #(.BCD_DIGITS( BCD_DIGITS )) \n  bcd_to_7seg_decoders \n (.BCD_IN( bcd_result ),.SEG_OUT( seg_out ),.CLK( CLOCK_50 )); \n  assign HEX0 = ~seg_out[0*7+:7]; \n  assign HEX1 = ~seg_out[1*7+:7]; \n  assign HEX2 = ~seg_out[2*7+:7]; \n  assign HEX3 = ~seg_out[3*7+:7]; \n  assign HEX4 = ~seg_out[4*7+:7]; \n  assign HEX5[0] = 1'b1; \n  assign HEX5[2:1] = bcd_overflow ? 2'h0 : 2'h3; \n  assign HEX5[5:3] = 3'h7; \n  assign HEX5[6] = ~calc_result_data[17]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module `lc_mbc_iso` contains multiple inputs and outputs for signal isolation and processing in a larger system. It utilizes the MBC_ISOLATE signal to control the isolation of various data and control signals. The module provides outputs such as ADDROUT, DATAOUT, PENDOUT, REQOUT, PRIORITYOUT, ACKOUT, RESPOUT, LRC_SLEEP, LRC_RESET, LRC_ISOLATE, and SLEEP_REQ based on the input signals and their isolation status. The assignments within the module determine the output signals based on the isolation status and input signals.\n\n Module header:\n\nmodule lc_mbc_iso (MBC_ISOLATE,ADDROUT_uniso,DATAOUT_uniso,PENDOUT_uniso,REQOUT_uniso,PRIORITYOUT_uniso,ACKOUT_uniso,RESPOUT_uniso,ADDROUT,DATAOUT,PENDOUT,REQOUT,PRIORITYOUT,ACKOUT,RESPOUT,LRC_SLEEP_uniso,LRC_RESET_uniso,LRC_ISOLATE_uniso,LRC_SLEEP,LRC_RESET,LRC_ISOLATE,SLEEP_REQ_uniso,SLEEP_REQ);\n [/INST]\n", "output": "input MBC_ISOLATE; \n  input [31:0] ADDROUT_uniso; \n  input [31:0] DATAOUT_uniso; \n  input PENDOUT_uniso; \n  input REQOUT_uniso; \n  input PRIORITYOUT_uniso; \n  input ACKOUT_uniso; \n  input RESPOUT_uniso; \n  output [31:0] ADDROUT; \n  output [31:0] DATAOUT; \n  output PENDOUT; \n  output REQOUT; \n  output PRIORITYOUT; \n  output ACKOUT; \n  output RESPOUT; \n  input LRC_SLEEP_uniso; \n  input LRC_RESET_uniso; \n  input LRC_ISOLATE_uniso; \n  output LRC_SLEEP; \n  output LRC_RESET; \n  output LRC_ISOLATE; \n  input SLEEP_REQ_uniso; \n  output SLEEP_REQ; \n  assign ADDROUT = ~LRC_ISOLATE & ADDROUT_uniso; \n  assign DATAOUT = ~LRC_ISOLATE & DATAOUT_uniso; \n  assign PENDOUT = ~LRC_ISOLATE & PENDOUT_uniso; \n  assign REQOUT = ~LRC_ISOLATE & REQOUT_uniso; \n  assign PRIORITYOUT = ~LRC_ISOLATE & PRIORITYOUT_uniso; \n  assign ACKOUT = ~LRC_ISOLATE & ACKOUT_uniso; \n  assign RESPOUT = ~LRC_ISOLATE & RESPOUT_uniso; \n  assign LRC_SLEEP = MBC_ISOLATE | LRC_SLEEP_uniso; \n  assign LRC_RESET = MBC_ISOLATE | LRC_RESET_uniso; \n  assign LRC_ISOLATE = MBC_ISOLATE | LRC_ISOLATE_uniso; \n  assign SLEEP_REQ = ~MBC_ISOLATE & SLEEP_REQ_uniso; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `base_forwarding_unit` implements forwarding control logic for a processor. It has inputs for control signals and register values, and outputs the appropriate forwarding signals to handle data hazards. The module uses a combination of register comparisons and control signal evaluations to determine the appropriate forwarding control output based on the input conditions. The forwarding control output is updated based on the state of various control and register signals, which helps in preventing hazards in the processor's pipeline.\n\n Module header:\n\nmodule base_forwarding_unit ( input ex_mem_reg_write,input mem_wb_reg_write,input [4:0] ex_mem_dst_reg,input [4:0] mem_wb_dst_reg,input [4:0] rs,input [4:0] rt,output reg [3:0] forward_control);\n [/INST]\n", "output": "reg ex_mem_dst_reg_is_not_zero; \n  reg mem_wb_dst_reg_is_not_zero; \n  always @* begin \n  ex_mem_dst_reg_is_not_zero = |ex_mem_dst_reg; \n  mem_wb_dst_reg_is_not_zero = |mem_wb_dst_reg; \n  forward_control = 4'h0; \n  if (ex_mem_reg_write & ex_mem_dst_reg_is_not_zero) begin \n  if (ex_mem_dst_reg == rs) \n  forward_control[0] = 1'b1; \n  else \n  forward_control[0] = 1'b0; \n  if (ex_mem_dst_reg == rt) \n  forward_control[1] = 1'b1; \n  else \n  forward_control[1] = 1'b0; \n  end \n  else \n  forward_control[1:0] = 2'b00; \n  if (mem_wb_reg_write & mem_wb_dst_reg_is_not_zero) begin \n  if ((mem_wb_dst_reg == rs) & (ex_mem_dst_reg != rs)) \n  forward_control[2] = 1'b1; \n  else \n  forward_control[2] = 1'b0; \n  if ((mem_wb_dst_reg == rt) & (ex_mem_dst_reg != rt)) \n  forward_control[3] = 1'b1; \n  else \n  forward_control[3] = 1'b0; \n  end \n  else \n  forward_control[3:2] = 2'b00; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module is a UART receiver that receives data from an RS232 interface. It includes logic to detect the start bit of the received data, and then captures the subsequent 8 data bits and 1 stop bit. The received data is then output along with an interrupt signal to indicate when new data has been received. The module also synchronizes the received data with the clock and handles reset conditions to ensure proper operation.\n\n Module header:\n\nmodule UART_rx(clk,rst_n,bps_start,clk_bps,RS232_rx,rx_data,rx_int,data_out);\n [/INST]\n", "output": "input clk; \n  input rst_n; \n  input RS232_rx; \n  input clk_bps; \n  output bps_start; \n  output [7:0] rx_data; \n  output rx_int; \n  output reg [7:0]data_out; \n  reg RS232_rx0,RS232_rx1,RS232_rx2,RS232_rx3; \n  wire neg_RS232_rx; \n  always @(posedge clk or negedge rst_n) begin \n  if(!rst_n) begin \n  RS232_rx0 <= 1'b0; \n  RS232_rx1 <= 1'b0; \n  RS232_rx2 <= 1'b0; \n  RS232_rx3 <= 1'b0; \n  end \n  else begin \n  RS232_rx0 <= RS232_rx; \n  RS232_rx1 <= RS232_rx0; \n  RS232_rx2 <= RS232_rx1; \n  RS232_rx3 <= RS232_rx2; \n  end \n  end \n  assign neg_RS232_rx = RS232_rx3 & RS232_rx2 & ~RS232_rx1 & ~RS232_rx0; \n  reg bps_start_r; \n  reg [3:0] num; \n  reg rx_int; \n  always @(posedge clk or negedge rst_n) \n  if(!rst_n) begin \n  bps_start_r <=1'bz; \n  rx_int <= 1'b0; \n  end \n  else if(neg_RS232_rx) begin \n  bps_start_r <= 1'b1; \n  rx_int <= 1'b1; \n  end \n  else if(num==4'd12) begin \n  bps_start_r <=1'b0; \n  rx_int <= 1'b0; \n  end \n  assign bps_start = bps_start_r; \n  reg [7:0] rx_data_r; \n  reg [7:0] rx_temp_data; \n  always @(posedge clk or negedge rst_n) \n  if(!rst_n) begin \n  rx_temp_data <= 8'd0; \n  num <= 4'd0; \n  rx_data_r <= 8'd0; \n  end \n  else if(rx_int) begin \n  if(clk_bps) begin \n  num <= num+1'b1; \n  case(num) \n  4'd1: rx_temp_data[0] <= RS232_rx; \n  4'd2: rx_temp_data[1] <= RS232_rx; \n  4'd3: rx_temp_data[2] <= RS232_rx; \n  4'd4: rx_temp_data[3] <= RS232_rx; \n  4'd5: rx_temp_data[4] <= RS232_rx; \n  4'd6: rx_temp_data[5] <= RS232_rx; \n  4'd7: rx_temp_data[6] <= RS232_rx; \n  4'd8: rx_temp_data[7] <= RS232_rx; \n  default: ; \n  endcase \n  data_out <= rx_temp_data; \n  end \n  else if(num==4'd12) begin \n  num <= 4'd0; \n  rx_data_r <= rx_temp_data; \n  end \n  end \n  assign rx_data = rx_data_r; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a hardware entropy generator. It includes logic for generating random numbers, mixing and concatenating them, and handling read and write operations. The module also features a delay counter and debug logic. The module takes input signals such as clock, reset, chip select (CS), write enable (WE), address (ADDR), and data write (DWRITE), and produces output signals including read data (DREAD) and debug information (DEBUG). It utilizes registers to store random number generator (RNG) values, delay counters, and debug registers, and uses always blocks to handle various functionalities like updating RNGs, mixing and concatenating data, and managing the delay counter. Additionally, the module uses a generate block to create multiple instances of a carry-chain adder circuit.\n\n Module header:\n\nmodule entropy(input wire clk,input wire nreset,input wire cs,input wire we,input wire [7:0] addr,input wire [15:0] dwrite,output wire [31:0] dread,output wire [7 : 0] debug);\n [/INST]\n", "output": "parameter DELAY_MAX = 32'h004c4b40; \n  parameter ADDR_ENT_WR_RNG1 = 8'h00; \n  parameter ADDR_ENT_WR_RNG2 = 8'h01; \n  parameter ADDR_ENT_RD_RNG1_RNG2 = 8'h10; \n  parameter ADDR_ENT_RD_P = 8'h11; \n  parameter ADDR_ENT_RD_N = 8'h12; \n  parameter ADDR_ENT_MIX = 8'h20; \n  parameter ADDR_ENT_CONCAT = 8'h21; \n  reg [7:0] rng1, rng2; \n  reg [31 : 0] delay_ctr_reg; \n  reg [31 : 0] delay_ctr_new; \n  reg [7 : 0] debug_reg; \n  reg [31 : 0] mix_reg; \n  reg [31 : 0] concat_reg; \n  wire [31 : 0] p, n; \n  reg [31 : 0] tmp_dread; \n  genvar i; \n  generate \n  for(i=0; i<32; i=i+1) begin: tworoscs \n  rosc px(clk, nreset, rng1, rng2, p[i]); \n  rosc nx(clk, nreset, rng1, rng2, n[i]); \n  end \n  endgenerate \n  assign dread = tmp_dread; \n  assign debug = debug_reg; \n  always @(posedge clk or negedge nreset) \n  begin \n  if(!nreset) \n  begin \n  rng1 <= 8'h55; \n  rng2 <= 8'haa; \n  delay_ctr_reg <= 32'h00000000; \n  mix_reg <= 32'h00000000; \n  concat_reg <= 32'h00000000; \n  debug_reg <= 8'h00; \n  end \n  else \n  begin \n  delay_ctr_reg <= delay_ctr_new; \n  mix_reg <= n ^ p; \n  concat_reg <= {n[31 : 16] ^ n[15 : 0], p[31 : 16] ^ p[15 : 0]}; \n  if (delay_ctr_reg == 32'h00000000) \n  begin \n  debug_reg <= n[7 : 0]; \n  end \n  if(cs & we) \n  begin \n  case(addr) \n  ADDR_ENT_WR_RNG1: rng1 <= dwrite[15:8]; \n  ADDR_ENT_WR_RNG2: rng2 <= dwrite[7:0]; \n  default:; \n  endcase \n  end \n  end \n  end \n  always @* \n  begin : read_data \n  tmp_dread = 16'h0000; \n  if(cs & ~we) \n  case(addr) \n  ADDR_ENT_RD_RNG1_RNG2: tmp_dread = {16'h0000, rng1, rng2}; \n  ADDR_ENT_RD_P: tmp_dread = p; \n  ADDR_ENT_RD_N: tmp_dread = n; \n  ADDR_ENT_MIX: tmp_dread = mix_reg; \n  ADDR_ENT_CONCAT: tmp_dread = concat_reg; \n  default:; \n  endcase \n  end \n  always @* \n  begin : delay_ctr \n  if (delay_ctr_reg == DELAY_MAX) \n  begin \n  delay_ctr_new = 32'h00000000; \n  end \n  else \n  begin \n  delay_ctr_new = delay_ctr_reg + 1'b1; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an implementation of a VGA interface. It synchronizes the horizontal and vertical sync signals with the incoming clock and generates the appropriate color output signals based on the timing parameters. It also includes pixel counters for both horizontal and vertical axes, and assigns the color input to the color output based on the specified display time intervals. Additionally, it uses a down counter to control the timing of the VGA signals and pixel generation.\n\n Module header:\n\nmodule VGAInterface(input CLK,output REFRESH,input [7:0] COLOUR_IN,output reg [7:0] COLOUR_OUT,output [9:0] ADDRH,output [8:0] ADDRV,output reg HS,output reg VS,input DOWNCOUNTER);\n [/INST]\n", "output": "wire [9:0] VertCounter; \n  wire [9:0] HorzCounter; \n  wire EndHorzTrigger; \n  initial begin \n  HS = 0; \n  VS = 0; \n  COLOUR_OUT = 8'b0; \n  end \n  parameter HorzTimeToPulseWidthEnd = 10'd96; \n  parameter HorzTimeToBackPorchEnd = 10'd144; \n  parameter HorzTimeToDisplayTimeEnd = 10'd784; \n  parameter HorzTimeToFrontPorchEnd = 10'd800; \n  parameter VertTimeToPulseWidthEnd = 10'd2; \n  parameter VertTimeToBackPorchEnd = 10'd31; \n  parameter VertTimeToDisplayTimeEnd = 10'd511; \n  parameter VertTimeToFrontPorchEnd = 10'd521; \n Counter # (.MaxValue(HorzTimeToFrontPorchEnd-1),.Size(10)) \n TimeCounterHorizontal(.CLK(CLK),.ENABLE(DOWNCOUNTER),.TRIGGER_OUT(EndHorzTrigger),.TIME_COUNT(HorzCounter)); \n Counter # (.MaxValue(VertTimeToFrontPorchEnd-1),.Size(10)) \n TimeCounterVertical(.CLK(CLK),.ENABLE(EndHorzTrigger),.TRIGGER_OUT(REFRESH),.TIME_COUNT(VertCounter)); \n  always @(posedge CLK) begin \n  if ((HorzCounter < HorzTimeToPulseWidthEnd-1) || (HorzCounter == HorzTimeToFrontPorchEnd-1)) \n  HS <= 1'b0; \n  else \n  HS <= 1'b1; \n  end \n  always @(posedge CLK) begin \n  if (EndHorzTrigger)begin \n  if ((VertCounter < VertTimeToPulseWidthEnd-1) || (VertCounter == VertTimeToFrontPorchEnd-1)) \n  VS <= 1'b0; \n  else \n  VS <= 1'b1; \n  end \n  end \n  always @(posedge CLK) begin \n  if (DOWNCOUNTER) begin \n if ( (HorzCounter > HorzTimeToBackPorchEnd-2)&& (HorzCounter <= HorzTimeToDisplayTimeEnd-2)&& (VertCounter > VertTimeToBackPorchEnd-1)&& (VertCounter <= VertTimeToDisplayTimeEnd-1) ) \n  COLOUR_OUT <= COLOUR_IN; \n  else \n  COLOUR_OUT <= 8'b0; \n  end \n  end \n PixCounter # (.AddressSize(10),.TimeToBackPorchEnd (HorzTimeToBackPorchEnd-1),.TimeToDisplayTimeEnd (HorzTimeToDisplayTimeEnd-1)) \n HorzPix(.CLK(CLK),.SYNCH_TIME(HorzCounter),.ENABLE(DOWNCOUNTER),.PIXCOUNT(ADDRH)); \n PixCounter # (.AddressSize(9),.TimeToBackPorchEnd (VertTimeToBackPorchEnd-1),.TimeToDisplayTimeEnd (VertTimeToDisplayTimeEnd-1)) \n VertPix(.CLK(CLK),.SYNCH_TIME(VertCounter),.ENABLE(EndHorzTrigger),.PIXCOUNT(ADDRV)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module converts floating-point data into an internal format. It includes parameters for configuring capacity, latency, flush denorms, and finite math. The inputs are clock, reset, data, enable, valid_in, and stall_in, and the outputs are mantissa, exponent, sign, valid_out, and stall_out. The module features registers for recognizing auto-shift registers and high latency. It also sets the mantissa, exponent, and sign based on various conditions such as the input data, parameters, and flags. The outputs are determined by the conditions and input signals.\n\n Module header:\n\nmodule acl_fp_convert_to_internal(clock, resetn, data, mantissa, exponent, sign, valid_in, valid_out, stall_in, stall_out, enable);\n [/INST]\n", "output": "parameter HIGH_CAPACITY = 1; \n  parameter HIGH_LATENCY = 1; \n  parameter FLUSH_DENORMS = 0; \n  parameter FINITE_MATH_ONLY = 1; \n  input clock, resetn; \n  input [31:0] data; \n  output [26:0] mantissa; \n  output [8:0] exponent; \n  output sign; \n  input enable, valid_in, stall_in; \n  output valid_out, stall_out; \n  (* altera_attribute = \"-name auto_shift_register_recognition OFF\" *) reg c1_valid; \n  wire c1_enable; \n  wire c1_stall; \n  assign c1_enable = (HIGH_CAPACITY ? (~c1_stall | ~c1_valid) : enable); \n  assign stall_out = c1_stall & c1_valid; \n  (* altera_attribute = \"-name auto_shift_register_recognition OFF\" *) reg [26:0] c1_mantissa; \n  (* altera_attribute = \"-name auto_shift_register_recognition OFF\" *) reg [8:0] c1_exponent; \n  (* altera_attribute = \"-name auto_shift_register_recognition OFF\" *) reg c1_sign; \n  generate \n  if (HIGH_LATENCY == 1) \n  begin \n  always @(posedge clock or negedge resetn) \n  begin \n  if (~resetn) \n  begin \n  c1_mantissa <= 27'dx; \n  c1_exponent <= 9'dx; \n  c1_sign <= 1'bx; \n  c1_valid <= 1'b0; \n  end \n  else if (c1_enable) \n  begin \n  c1_valid <= valid_in; \n  if ((FLUSH_DENORMS) && (data[30:23] == 8'd0)) \n  c1_mantissa <= 27'd0; \n  else \n  c1_mantissa <= {|data[30:23],data[22:0],3'd0}; \n  if (FINITE_MATH_ONLY == 0) \n  c1_exponent <= {&data[30:23], data[30:23]}; \n  else \n  c1_exponent <= {1'b0, data[30:23]}; \n  c1_sign <= data[31]; \n  end \n  end \n  end \n  else \n  begin \n  always @(*) \n  begin \n  c1_valid <= valid_in; \n  if ((FLUSH_DENORMS) && (data[30:23] == 8'd0)) \n  c1_mantissa <= 27'd0; \n  else \n  c1_mantissa <= {|data[30:23],data[22:0],3'd0}; \n  if (FINITE_MATH_ONLY == 0) \n  c1_exponent <= {&data[30:23], data[30:23]}; \n  else \n  c1_exponent <= {1'b0, data[30:23]}; \n  c1_sign <= data[31]; \n  end \n  end \n  endgenerate \n  assign c1_stall = stall_in; \n  assign valid_out = c1_valid; \n  assign mantissa = c1_mantissa; \n  assign exponent = c1_exponent; \n  assign sign = c1_sign; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a phase ramp generator. It has inputs for the adc_clk, aclk, aresetn, and phase_increment, and outputs phase_tdata and phase_tvalid. The phase counter is updated on the rising edge of aclk and adc_clk. The phase counter is reset when the reset signal is asserted and then incremented by phase_increment. The phase_tvalid output is determined by the values of r2 and r3, and phase_tdata is derived from the phase_counter.\n\n Module header:\n\nmodule phase_ramp # (parameter integer PHASE_WIDTH = 16,parameter integer FRACTIONAL_WIDTH = 13) (input wire adc_clk,input wire aclk,input wire aresetn,input wire [FRACTIONAL_WIDTH-1:0] phase_increment,output wire [PHASE_WIDTH-1:0] phase_tdata,input wire phase_tready,output wire phase_tvalid);\n [/INST]\n", "output": "reg [FRACTIONAL_WIDTH:0] phase_counter; \n reg [FRACTIONAL_WIDTH:0] phase_counter_next; \n reg r1, r2, r3; \n reg reset; \n always @(posedge aclk) begin \n  if (~aresetn) begin \n  reset <= 1'b1; \n  r1 <= 1; \n  r2 <= 1; \n  r3 <= 1; \n  end else begin \n  r1 <= adc_clk; \n  r2 <= r1; \n  r3 <= r2; \n  end \n end \n always @(posedge adc_clk) begin \n  if (reset) begin \n  phase_counter <= {(FRACTIONAL_WIDTH){1'b0}}; \n  phase_counter_next <= phase_increment; \n  reset <= 1'b0; \n  end else begin \n  phase_counter <= phase_counter_next; \n  phase_counter_next <= phase_counter_next + phase_increment; \n  end \n end \n assign phase_tvalid = r2 && !r3; \n assign phase_tdata = {{(PHASE_WIDTH - FRACTIONAL_WIDTH - 1){phase_counter[FRACTIONAL_WIDTH]}}, phase_counter}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is designed to handle PCIe interrupt functionalities. It takes in various inputs such as clock signals, reset signals, and specific PCIe interrupt-related signals. It also has multiple outputs to handle interrupt requests, interrupt types, interrupt vectors, and other PCIe-specific functionalities.\n\nThe module instantiates an internal instance called \"cmm_intr\" to handle the interrupt processing. It sets various signals based on the incoming inputs and the internal logic of the module. It also calculates and assigns values to signals such as MSI request, interrupt vector, MSI enable, and legacy interrupt request based on specific configurations and control registers.\n\nOverall, this module acts as a bridge between the PCIe interface and the internal logic required for handling PCIe interrupts, providing necessary control and signaling for PCIe interrupt operations.\n\n Module header:\n\nmodule pcie_soft_cf_int (input wire clk,input wire rst_n,input wire cs_is_intr,input wire grant,input wire [31:0] cfg_msguaddr,input wire msi_enable,output [3:0] msi_request,output wire legacy_int_request,input wire cfg_interrupt_n,output wire cfg_interrupt_rdy_n,input wire msi_8bit_en,input wire cfg_interrupt_assert_n,input wire [7:0] cfg_interrupt_di,output [2:0] cfg_interrupt_mmenable,output [7:0] cfg_interrupt_do,output cfg_interrupt_msienable,input wire [31:0] msi_laddr,input wire [31:0] msi_haddr,input wire [15:0] cfg_command,input wire [15:0] cfg_msgctrl,input wire [15:0] cfg_msgdata,output wire signaledint,output wire intr_req_valid,output wire [1:0] intr_req_type,output wire [7:0] intr_vector);\n [/INST]\n", "output": "wire intr_rdy; \n assign cfg_interrupt_rdy_n = ~intr_rdy; \n assign cfg_interrupt_msienable = cfg_msgctrl[0]; \n assign legacy_int_request = 0; \n assign msi_request = 4'd0; \n assign cfg_interrupt_mmenable = cfg_msgctrl[6:4]; \n assign cfg_interrupt_do = cfg_msgdata[7:0]; \n cmm_intr u_cmm_intr (.clk (clk),.rst (~rst_n),.signaledint (signaledint),.intr_req_valid (intr_req_valid),.intr_req_type (intr_req_type),.intr_rdy (intr_rdy),.cfg_interrupt_n (cfg_interrupt_n),.cfg_interrupt_assert_n (cfg_interrupt_assert_n),.cfg_interrupt_di (cfg_interrupt_di),.cfg_interrupt_mmenable (cfg_interrupt_mmenable),.msi_data (cfg_msgdata),.intr_vector (intr_vector),.cfg ( {556'd0, msi_8bit_en ,467'd0} ),.command (cfg_command),.msi_control (cfg_msgctrl),.msi_laddr (msi_laddr),.msi_haddr (msi_haddr),.intr_grant (grant & cs_is_intr)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module ad_ss_444to422 performs 4:4:4 to 4:2:2 conversion. It takes the 4:4:4 video data and control signals as input and generates 4:2:2 video data and control signals as output. The input data is synchronized and delayed to ensure correct timing, and then based on the control signal, it selects the appropriate data to output as 4:2:2 video data. The control bit selector switches between two sources based on the control bit. The module also toggles the control bit selector and performs data initialization based on the input control and data signals. The output is generated based on the selected data and control bit.\n\n Module header:\n\nmodule ad_ss_444to422 (clk,s444_de,s444_sync,s444_data,s422_sync,s422_data);\n [/INST]\n", "output": "parameter CR_CB_N = 0; \n  parameter DELAY_DATA_WIDTH = 16; \n  localparam DW = DELAY_DATA_WIDTH - 1; \n  input clk; \n  input s444_de; \n  input [DW:0] s444_sync; \n  input [23:0] s444_data; \n  output [DW:0] s422_sync; \n  output [15:0] s422_data; \n  reg s444_de_d = 'd0; \n  reg [DW:0] s444_sync_d = 'd0; \n  reg [23:0] s444_data_d = 'd0; \n  reg s444_de_2d = 'd0; \n  reg [DW:0] s444_sync_2d = 'd0; \n  reg [23:0] s444_data_2d = 'd0; \n  reg s444_de_3d = 'd0; \n  reg [DW:0] s444_sync_3d = 'd0; \n  reg [23:0] s444_data_3d = 'd0; \n  reg [ 7:0] cr = 'd0; \n  reg [ 7:0] cb = 'd0; \n  reg cr_cb_sel = 'd0; \n  reg [DW:0] s422_sync = 'd0; \n  reg [15:0] s422_data = 'd0; \n  wire [ 9:0] cr_s; \n  wire [ 9:0] cb_s; \n  always @(posedge clk) begin \n  s444_de_d <= s444_de; \n  s444_sync_d <= s444_sync; \n  if (s444_de == 1'b1) begin \n  s444_data_d <= s444_data; \n  end \n  s444_de_2d <= s444_de_d; \n  s444_sync_2d <= s444_sync_d; \n  if (s444_de_d == 1'b1) begin \n  s444_data_2d <= s444_data_d; \n  end \n  s444_de_3d <= s444_de_2d; \n  s444_sync_3d <= s444_sync_2d; \n  if (s444_de_2d == 1'b1) begin \n  s444_data_3d <= s444_data_2d; \n  end \n  end \n  assign cr_s = {2'd0, s444_data_d[23:16]} + \n  {2'd0, s444_data_3d[23:16]} + \n  {1'd0, s444_data_2d[23:16], 1'd0}; \n  assign cb_s = {2'd0, s444_data_d[7:0]} + \n  {2'd0, s444_data_3d[7:0]} + \n  {1'd0, s444_data_2d[7:0], 1'd0}; \n  always @(posedge clk) begin \n  cr <= cr_s[9:2]; \n  cb <= cb_s[9:2]; \n  if (s444_de_3d == 1'b1) begin \n  cr_cb_sel <= ~cr_cb_sel; \n  end else begin \n  cr_cb_sel <= CR_CB_N; \n  end \n  end \n  always @(posedge clk) begin \n  s422_sync <= s444_sync_3d; \n  if (s444_de_3d == 1'b0) begin \n  s422_data <= 'd0; \n  end else if (cr_cb_sel == 1'b1) begin \n  s422_data <= {cr, s444_data_3d[15:8]}; \n  end else begin \n  s422_data <= {cb, s444_data_3d[15:8]}; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a full adder circuit with two 1-bit inputs (a0, b0) and a carry-in (c0), and two 1-bit outputs (s_out, c_out). It also has additional outputs s2 and s3. The module instantiates two half adder modules to calculate the sum and carry-out for the first two inputs, and uses additional logic to calculate the final sum and carry-out. The outputs s_out and carry_out are then assigned to the respective outputs of the module.\n\n Module header:\n\nmodule full_adder (a0, b0, c0, a1, b1, c_out, s_out, s2, s3);\n [/INST]\n", "output": "input a0; \n  input b0; \n  input c0; \n  input a1; \n  input b1; \n  output c_out; \n  output s_out; \n  output s2; \n  output d1; \n  output s3; \n  wire c1; \n  wire c2; \n  wire s1; \n  wire d1; \n  wire c3; \n  assign carry_out = c1 | c2; \n  assign s_out = s1; \n half_adder u1_half_adder (.in_x(a0),.in_y(b0),.out_sum(s0),.out_carry(c1)); \n half_adder u2_half_adder (.in_x(s0),.in_y(c0),.out_sum(s1),.out_carry(c2)); \n test1 test1 (.in_1(s1),.in_2(s0),.in_3(a1),.in_4(b1),.out_1(s2),.out_2(d1),.out_3(c3)); \n test2 test2 (.in_1(d1),.in_2(c3),.in_3(b1),.out_1(s3)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a state machine with two states: state_waitForRequest and state_sendPacket. The module uses a clock signal and a reset signal to transition between states. When in the state_waitForRequest, the module checks the readData signal and the wordCounter to determine if it should transition to the state_sendPacket. In the state_sendPacket, it checks the wordCounter to determine whether to transition back to state_waitForRequest. The module also updates the wordCounter based on the current state. The fx3isReading output is set high when in the state_sendPacket.\n\n Module header:\n\nmodule fx3StateMachine (input nReset,input fx3_clock,input readData,output fx3isReading);\n [/INST]\n", "output": "reg [3:0]sm_currentState; \n reg [3:0]sm_nextState; \n parameter [3:0] state_waitForRequest = 4'd01; \n parameter [3:0] state_sendPacket = 4'd02; \n always @(posedge fx3_clock, negedge nReset) begin \n  if(!nReset) begin \n  sm_currentState <= state_waitForRequest; \n  end else begin \n  sm_currentState <= sm_nextState; \n  end \n end \n reg readData_flag; \n always @(posedge fx3_clock, negedge nReset) begin \n  if(!nReset) begin \n  readData_flag <= 1'b0; \n  end else begin \n  readData_flag <= readData; \n  end \n end \n reg [15:0] wordCounter; \n always @(posedge fx3_clock, negedge nReset) begin \n  if (!nReset) begin \n  wordCounter = 16'd0; \n  end else begin \n  if (sm_currentState == state_sendPacket) begin \n  wordCounter = wordCounter + 16'd1; \n  end else begin \n  wordCounter = 16'd0; \n  end \n  end \n end \n assign fx3isReading = (sm_currentState == state_sendPacket) ? 1'b1 : 1'b0; \n always @(*)begin \n  sm_nextState = sm_currentState; \n  case(sm_currentState) \n  state_waitForRequest:begin \n  if (readData_flag == 1'b1 && wordCounter == 16'd0) begin \n  sm_nextState = state_sendPacket; \n  end else begin \n  sm_nextState = state_waitForRequest; \n  end \n  end \n  state_sendPacket:begin \n  if (wordCounter == 16'd8191) begin \n  sm_nextState = state_waitForRequest; \n  end else begin \n  sm_nextState = state_sendPacket; \n  end \n  end \n  endcase \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module detects positive and negative edges in a signal rx_int. It includes registers to store past values of rx_int and uses them to detect the edges. The outputs pos_rx_int and neg_rx_int indicate the positive and negative edges of the signal respectively, while doub_rx_int indicates the toggling of the signal. The module operates on the rising edge of the clock and the negation of the reset signal.\n\n Module header:\n\nmodule edge_detect(input clk,input rst_n,input rx_int,output pos_rx_int,output neg_rx_int,output doub_rx_int);\n [/INST]\n", "output": "reg rx_int0,rx_int1,rx_int2; \n always @(posedge clk or negedge rst_n) \n  begin \n  if(!rst_n) \n  begin \n  rx_int0 <= 1'b0; \n  rx_int1 <= 1'b0; \n  rx_int2 <= 1'b0; \n  end \n  else \n  begin \n  rx_int0 <= rx_int; \n  rx_int1 <= rx_int0; \n  rx_int2 <= rx_int1; \n  end \n  end \n assign pos_rx_int = rx_int1 & ~rx_int2; \n assign neg_rx_int = ~rx_int1 & rx_int2; \n assign doub_rx_int = rx_int1 ^ rx_int2; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, named REGBANK_banco, implements a register bank with a configurable number of address bits and data width. It has inputs for clock, regWrite control, read and write register addresses, and write data. It also has outputs for the data read from two different registers. The module uses an array of registers called banco to store data. On the rising edge of the clock, if regWrite is asserted, the writeData is written to the specified writeReg. The readData1 and readData2 outputs are assigned the data from the specified readReg1 and readReg2, respectively. This module essentially provides a register file with read and write capabilities.\n\n Module header:\n\nmodule REGBANK_banco #(parameter addr_bits=5, word_wide=32)(input clock,input regWrite,input [addr_bits-1:0] readReg1,input [addr_bits-1:0] readReg2,input [addr_bits-1:0] writeReg,input [word_wide-1:0] writeData,output [word_wide-1:0] readData1,output [word_wide-1:0] readData2);\n [/INST]\n", "output": "localparam bank_depth = 1 << addr_bits; \n  reg [word_wide-1:0] banco [bank_depth-1:0]; \n  assign readData1 = banco[readReg1]; \n  assign readData2 = banco[readReg2]; \n  always@(posedge clock) begin \n  if (regWrite) begin \n  banco[writeReg] = writeData; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module takes a 4-bit input nybble and outputs an 8-bit hexadecimal digit. The output digit corresponds to the hexadecimal representation of the nybble input, following a case statement that maps each nybble value to its corresponding hexadecimal digit. If the input is invalid, the output is undefined.\n\n Module header:\n\nmodule nybbletohexdigit(nybble, digit);\n [/INST]\n", "output": "input [3:0] nybble; \n  output reg [7:0] digit; \n  always @(*) begin \n  case(nybble) \n  0: \n  digit <= 8'h30; \n  1: \n  digit <= 8'h31; \n  2: \n  digit <= 8'h32; \n  3: \n  digit <= 8'h33; \n  4: \n  digit <= 8'h34; \n  5: \n  digit <= 8'h35; \n  6: \n  digit <= 8'h36; \n  7: \n  digit <= 8'h37; \n  8: \n  digit <= 8'h38; \n  9: \n  digit <= 8'h39; \n  10: \n  digit <= 8'h41; \n  11: \n  digit <= 8'h42; \n  12: \n  digit <= 8'h43; \n  13: \n  digit <= 8'h44; \n  14: \n  digit <= 8'h45; \n  15: \n  digit <= 8'h46; \n  default: \n  digit <= 8'bxxxxxxxx; \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a UART receiver control that uses a parameterized state machine. It has states for IDLE, STARTING, and RECEIVING. The module also includes error recovery mechanisms. It features control signals to manage the receiving process, such as sc_inc, sc_clr, bc_inc, shift, and fifo_write_enable. The module transitions between states based on various input conditions including bit_eq_0, sc_halb, sc_full, and frame_done. It also has reset and clock inputs for synchronous operation.\n\n Module header:\n\nmodule uart_light_rx_ctrl #(parameter STATE_COUNT = 3,parameter IDLE = 3'b001,parameter STARTING = 3'b010,parameter RECEIVING = 3'b100)(input wire reset,input wire clk_rx,input wire read_ready,output wire fifo_rx_full,output wire fifo_rx_empty,input wire bit_eq_0,input wire sc_halb,input wire sc_full,input wire frame_done,output reg sc_inc,output reg sc_clr,output reg bc_inc,output reg bc_clr,output reg shift,output reg fifo_write_enable,input wire fifo_full,input wire fifo_empty,output wire fifo_read_enable);\n [/INST]\n", "output": "reg [STATE_COUNT-1:0] state_cur, state_next; \n  reg err_recover, err_recover_next; \n  assign fifo_rx_full = fifo_full; \n  assign fifo_rx_empty = fifo_empty; \n  assign fifo_read_enable = read_ready & (~fifo_empty); \n  always @(state_cur, bit_eq_0, sc_halb, sc_full, frame_done) begin \n  sc_inc = 1'b0; \n  sc_clr = 1'b0; \n  bc_inc = 1'b0; \n  bc_clr = 1'b0; \n  shift = 1'b0; \n  fifo_write_enable = 1'b0; \n  state_next = IDLE; \n  err_recover_next = err_recover; \n  case(state_cur) \n  IDLE: \n  if(bit_eq_0 == 1'b1) begin \n  state_next = STARTING; \n  end \n  STARTING: \n  if(bit_eq_0 == 1'b0) begin \n  sc_clr = 1'b1; \n  state_next = IDLE; \n  end \n  else if(sc_halb == 1'b1) begin \n  sc_clr = 1'b1; \n  state_next = RECEIVING; \n  end \n  else begin \n  sc_inc = 1'b1; \n  state_next = STARTING; \n  end \n  RECEIVING: \n  if (err_recover) begin \n  state_next = IDLE; \n  err_recover_next = 1'b0; \n  end else begin \n  if(sc_full == 1'b1) begin \n  sc_clr = 1'b1; \n  if(frame_done) begin \n  bc_clr = 1'b1; \n  state_next = IDLE; \n  if (!bit_eq_0) begin \n  fifo_write_enable = 1'b1; \n  end else begin \n  err_recover_next = 1'b1; \n  end \n  end \n  else begin \n  shift = 1'b1; \n  bc_inc = 1'b1; \n  state_next = RECEIVING; \n  end \n  end \n  else begin \n  sc_inc = 1'b1; \n  state_next = RECEIVING; \n  end \n  end \n  default: state_next = IDLE; \n  endcase \n  end \n  always @(posedge clk_rx, posedge reset) begin \n  if(reset) begin \n  state_cur <= IDLE; \n  err_recover <= 1'b0; \n  end \n  else begin \n  state_cur <= state_next; \n  err_recover <= err_recover_next; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a test module for an IO memory. It has input and output signals for clock, IO write, IO address, IO data in, and processor input, as well as output signals for IO data out and processor output. The initial block sets the initial values for the input signals. It then waits for specific clock cycles and sets different values for the IO address and IO data inputs at different points in time. It sets the IO write signal to 1 at specific instances and then back to 0 after waiting for some clock cycles. Finally, it toggles the clock signal in an always block. This test module aims to verify the functionality of the IO memory module by providing a sequence of input stimuli and monitoring the corresponding outputs.\n\n Module header:\n\nmodule test_IO_memory;\n [/INST]\n", "output": "reg clock; \n  reg IO_write; \n  reg [11:0] IO_address; \n  reg [15:0] IO_data_in; \n  reg [15:0] processor_input; \n  wire [15:0] IO_data_out; \n  wire [15:0] processor_output; \n IO_memory uut (.clock(clock),.IO_write(IO_write),.IO_address(IO_address),.IO_data_in(IO_data_in),.IO_data_out(IO_data_out),.processor_input(processor_input),.processor_output(processor_output)); \n  initial begin \n  clock = 0; \n  IO_write = 0; \n  IO_address = 0; \n  IO_data_in = 0; \n  processor_input = 16'h3131; \n  #30; \n  IO_address = 12'h000; \n  #20; \n  IO_address = 12'h00f; \n  #20; \n  IO_address = 12'h000; \n  #20; \n  IO_address = 12'hff0; \n  #40; \n  IO_address = 12'h001; \n  #20; \n  IO_address = 12'h000; \n  #20; \n  IO_address = 12'h00a; \n  IO_data_in = 16'h3169; \n  IO_write = 1; \n  #20; \n  IO_address = 12'h002; \n  IO_data_in = 0; \n  IO_write = 0; \n  #20; \n  IO_address = 12'h003; \n  #20; \n  IO_address = 12'h00a; \n  #20; \n  IO_address = 12'h004; \n  #20; \n  IO_address = 12'hff0; \n  IO_data_in = 16'h3170; \n  IO_write = 1; \n  #20; \n  IO_address = 12'h002; \n  IO_data_in = 0; \n  IO_write = 0; \n  #20; \n  IO_address = 12'hff0; \n  #20; \n  IO_address = 12'h004; \n  #20; \n  IO_address = 12'hff1; \n  IO_data_in = 16'h3170; \n  IO_write = 1; \n  #20; \n  IO_address = 12'h002; \n  IO_data_in = 0; \n  IO_write = 0; \n  #20; \n  IO_address = 12'hff1; \n  #20; \n  IO_address = 12'h004; \n  end \n  always #10 clock = !clock; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is designed to generate VGA noise and output audio signals. It utilizes several registers and a noise generator component. The module processes the input signals and the internal clock to control the generation of noise and the audio output. The output color is determined by the latch, and the audio signals audio_l and audio_r are derived from the audio_data. The noise generation is controlled by the style and test inputs and is synchronized with the vsync and hsync signals.\n\n Module header:\n\nmodule vga_noise(clk, color, pause, vsync, hsync, style, test, audio_l, audio_r);\n [/INST]\n", "output": "input clk; \n  output [7:0] color; \n  input pause; \n  input vsync, hsync; \n  input style; \n  input test; \n  output audio_l, audio_r; \n  reg [1:0] audio_data; \n  reg [7:0] latch; \n  reg [7:0] sr; \n  reg [12:0] divider; \n  wire noise_bit; \n noise_generator gen (.clk(clk),.reset(pause&vsync),.random_bit(noise_bit)); \n  always @(negedge clk) \n  begin \n  if(hsync) \n  divider <= 0; \n  else \n  divider <= divider + 1; \n  end \n  always @(posedge divider[2]) \n  begin \n  latch <= sr; \n  end \n  always @(posedge divider[12]) \n  begin \n  if(!test && !pause) \n  begin \n  audio_data <= sr[1:0]; \n  end \n  end \n  always @(posedge clk) \n  begin \n  if(style) \n  begin \n  if(test) \n  begin \n  sr <= {divider[9],divider[9],divider[9],divider[8],divider[8],divider[8],divider[7],divider[7]}; \n  end \n  else \n  begin \n  sr[7:1] <= sr[6:0]; \n  sr[0] <= noise_bit; \n  end \n  end \n  else \n  begin \n  if(test) \n  begin \n  sr <= {divider[5],divider[5],divider[5],divider[5],divider[5],divider[5],divider[5],divider[5]}; \n  end \n  else \n  begin \n  sr <= {noise_bit,noise_bit,noise_bit,noise_bit,noise_bit,noise_bit,noise_bit,noise_bit}; \n  end \n  end \n  end \n  assign color = latch; \n  assign audio_l = audio_data[0]; \n  assign audio_r = audio_data[1]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is designed for driving 7-segment LED displays with 4 digits and takes BCD input along with decimal point control signals. It includes a counter for digit selection, a clock divider, and logic for segment and anode selection.\n\nThe module selects one digit at a time based on the counter value and assigns the corresponding BCD input and decimal point to the digit. It also maps the BCD input to the appropriate segments for display.\n\nThe anode signals for each digit are set based on the counter and BCD input values to enable the specific digit to display the correct information.\n\nAdditionally, the clock divider increments to control the multiplexing of the digits.\n\nOverall, this module efficiently controls the 7-segment display to showcase the BCD input data across 4 digits along with the decimal points.\n\n Module header:\n\nmodule seven_segment_leds_x_4_no_leading_zeros(input [15:0] bcd_in,input [3:0] decimal_points,input clk,output reg [6:0] a_to_g,output reg decimal_point,output reg [3:0] anode);\n [/INST]\n", "output": "wire [1:0] counter; \n reg [3:0] digit; \n reg [19:0] clkdiv; \n assign counter = clkdiv[19:18]; \n always @(*) \n  case(counter) \n  0: {digit, decimal_point} = {bcd_in[3:0], decimal_points[0]}; \n  1: {digit, decimal_point} = {bcd_in[7:4], decimal_points[1]}; \n  2: {digit, decimal_point} = {bcd_in[11:8], decimal_points[2]}; \n  3: {digit, decimal_point} = {bcd_in[15:12], decimal_points[3]}; \n  endcase \n always @(*) \n  case(digit) \n  0: a_to_g = 7'b0000001; \n  1: a_to_g = 7'b1001111; \n  2: a_to_g = 7'b0010010; \n  3: a_to_g = 7'b0000110; \n  4: a_to_g = 7'b1001100; \n  5: a_to_g = 7'b0100100; \n  6: a_to_g = 7'b0100000; \n  7: a_to_g = 7'b0001111; \n  8: a_to_g = 7'b0000000; \n  9: a_to_g = 7'b0000100; \n  default: a_to_g = 7'b0000001; \n  endcase \n always @(*) \n  case(counter) \n  0: anode = 4'b1110; \n  1: anode = {2'b11,!(| bcd_in[15:4]),1'b1}; \n  2: anode = {1'b1,!(| bcd_in[15:8]),2'b11}; \n  3: anode = {!(| bcd_in[15:12]),3'b111}; \n  default: anode = 4'b1111; \n  endcase \n always @ (posedge clk) \n  begin \n  clkdiv <= clkdiv + 20'b1; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"probe_async\" is designed to handle asynchronous signal probing. It uses a clock signal \"csi_clock_clk\", a reset signal \"csi_clock_reset\", and an AVS control write signal \"avs_ctrl_write\" along with corresponding data \"avs_ctrl_writedata\". The module selects specific bits from the input signal \"sig_in\" based on the AVS control data and the clock signal.\n\nThe module contains a 5-bit register \"sel\" to store the AVS control write data. It instantiates 8 instances of the \"probe_mux4_async\" module, which is a 4-to-1 multiplexer with asynchronous input. Each instance selects specific bits from the \"sig_in\" signal based on the values stored in \"sel\" and stores the results in the \"d\" bus.\n\nThe \"sig_out\" output is assigned the value of one of the elements from the \"d\" bus based on the value of \"sel\". This assignment happens within an always block sensitive to the clock signal \"clk\" and the reset signal \"reset\".\n\nIn summary, the \"probe_async\" module enables asynchronous probing of specific bits from the input signal based on AVS control data, and it provides a selected output signal based on the probed data.\n\n Module header:\n\nmodule probe_async (input csi_clock_clk,input csi_clock_reset,input avs_ctrl_write,input [7:0]avs_ctrl_writedata,input clk,input [30:0]sig_in,output reg sig_out);\n [/INST]\n", "output": "wire reset = csi_clock_reset; \n  reg [4:0]sel; \n  always @(posedge csi_clock_clk or posedge reset) \n  begin \n  if (reset) sel <= 0; \n  else if (avs_ctrl_write) sel <= avs_ctrl_writedata[4:0]; \n  end \n  wire [7:0]d; \n  probe_mux4_async mux0(clk, reset, sel[1:0], {sig_in[2:0], 1'b0}, d[0]); \n  probe_mux4_async mux1(clk, reset, sel[1:0], sig_in[6:3], d[1]); \n  probe_mux4_async mux2(clk, reset, sel[1:0], sig_in[10:7], d[2]); \n  probe_mux4_async mux3(clk, reset, sel[1:0], sig_in[14:11], d[3]); \n  probe_mux4_async mux4(clk, reset, sel[1:0], sig_in[18:15], d[4]); \n  probe_mux4_async mux5(clk, reset, sel[1:0], sig_in[22:19], d[5]); \n  probe_mux4_async mux6(clk, reset, sel[1:0], sig_in[26:23], d[6]); \n  probe_mux4_async mux7(clk, reset, sel[1:0], sig_in[30:27], d[7]); \n  always @(posedge clk or posedge reset) \n  begin \n  if (reset) sig_out <= 0; \n  else \n  case (sel[4:2]) \n  0: sig_out <= d[0]; \n  1: sig_out <= d[1]; \n  2: sig_out <= d[2]; \n  3: sig_out <= d[3]; \n  4: sig_out <= d[4]; \n  5: sig_out <= d[5]; \n  6: sig_out <= d[6]; \n  7: sig_out <= d[7]; \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module `f8_inc` increments the 8-bit counter on the rising edge of the `clock` input signal. The incremented value is stored in the `counter` output register.\n\n Module header:\n\nmodule f8_inc(clock, counter);\n [/INST]\n", "output": "input clock; \n output reg [7:0] counter; \n always @(posedge clock) \n  counter <= counter + 1; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module `acl_fp_sub_double_altpriority_encoder_0c6` takes a 64-bit input array `data` and produces a 6-bit output array `q`. It uses two instances of the `acl_fp_sub_double_altpriority_encoder_q08` and `acl_fp_sub_double_altpriority_encoder_qf8` modules to process the lower and upper 32 bits of the input data. The `q` output is determined by logical operations on the outputs of these two instances.\n\n Module header:\n\nmodule acl_fp_sub_double_altpriority_encoder_0c6 (data,q) ;\n [/INST]\n", "output": "input [63:0] data; \n  output [5:0] q; \n  wire [4:0] wire_altpriority_encoder7_q; \n  wire [4:0] wire_altpriority_encoder8_q; \n  wire wire_altpriority_encoder8_zero; \n  acl_fp_sub_double_altpriority_encoder_q08 altpriority_encoder7 \n (.data(data[31:0]),.q(wire_altpriority_encoder7_q)); \n  acl_fp_sub_double_altpriority_encoder_qf8 altpriority_encoder8 \n (.data(data[63:32]),.q(wire_altpriority_encoder8_q),.zero(wire_altpriority_encoder8_zero)); \n  assign \n  q = {(~ wire_altpriority_encoder8_zero), (({5{wire_altpriority_encoder8_zero}} & wire_altpriority_encoder7_q) | ({5{(~ wire_altpriority_encoder8_zero)}} & wire_altpriority_encoder8_q))}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a 3-bit state machine with input ports ain, clk, reset, and an output port yout. The module's state transitions and output values are defined based on the input ain and the current state. The module's behavior is influenced by clock edges and reset signals to control the state transitions and output values.\n\n Module header:\n\nmodule lab5_2_1(input [1:0] ain,input clk,reset,output reg yout);\n [/INST]\n", "output": "reg [2:0] state,nextstate; \n  parameter S0 = 0,S1 = 1,S2 = 2,S3 = 3,S4 = 4,S5 = 5,S6 = 6; \n  always @(posedge clk or posedge reset) \n  if(reset) \n  begin \n  state <= S0; \n  yout <= 0; \n  end \n  else \n  state <= nextstate; \n  always @(state) \n  begin \n  case(state) \n  S0:yout = yout; \n  S1:yout = yout; \n  S2:yout = yout; \n  S3:yout = yout; \n  S4:yout = 0; \n  S5:yout = 1; \n  S6:yout = ~yout; \n  endcase \n  end \n  always @(state or ain) \n  begin \n  case(state) \n  S0: \n  begin \n  if(ain == 0) \n  nextstate = S0; \n  else if(ain == 1) \n  nextstate = S1; \n  else if(ain == 3) \n  nextstate = S2; \n  else \n  nextstate = S3; \n  end \n  S1: \n  begin \n  if(ain == 0) \n  nextstate = S4; \n  else if(ain == 1) \n  nextstate = S1; \n  else if(ain == 3) \n  nextstate = S2; \n  else \n  nextstate = S3; \n  end \n  S2: \n  begin \n  if(ain == 0) \n  nextstate = S5; \n  else if(ain == 1) \n  nextstate = S1; \n  else if(ain == 3) \n  nextstate = S2; \n  else \n  nextstate = S3; \n  end \n  S3: \n  begin \n  if(ain == 0) \n  nextstate = S6; \n  else if(ain == 1) \n  nextstate = S1; \n  else if(ain == 3) \n  nextstate = S2; \n  else \n  nextstate = S3; \n  end \n  S4: \n  begin \n  if(ain == 0) \n  nextstate = S0; \n  else if(ain == 1) \n  nextstate = S1; \n  else if(ain == 3) \n  nextstate = S2; \n  else \n  nextstate = S3; \n  end \n  S5: \n  begin \n  if(ain == 0) \n  nextstate = S0; \n  else if(ain == 1) \n  nextstate = S1; \n  else if(ain == 3) \n  nextstate = S2; \n  else \n  nextstate = S3; \n  end \n  S6: \n  begin \n  if(ain == 0) \n  nextstate = S0; \n  else if(ain == 1) \n  nextstate = S1; \n  else if(ain == 3) \n  nextstate = S2; \n  else \n  nextstate = S3; \n  end \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a decoder for the LUI (Load Upper Immediate) instruction. It takes a 20-bit immediate value and decodes it into separate fields such as opcode, rs, rt, and rd. It then converts these fields into symbolic representations and creates a string representation of the instruction in hexadecimal format.\n\n Module header:\n\nmodule lui_decoder (output [55:0] str,input [19:0] imm);\n [/INST]\n", "output": "wire [3:0] d0 = imm[3:0]; \n  wire [3:0] d1 = imm[7:4]; \n  wire [3:0] d2 = imm[11:8]; \n  wire [3:0] d3 = imm[15:12]; \n  wire [3:0] d4 = imm[19:16]; \n  wire [7:0] d0_s = d0 <= 9 ? \"0\" + d0 : \"A\" + d0 - 10; \n  wire [7:0] d1_s = d1 <= 9 ? \"0\" + d1 : \"A\" + d1 - 10; \n  wire [7:0] d2_s = d2 <= 9 ? \"0\" + d2 : \"A\" + d2 - 10; \n  wire [7:0] d3_s = d3 <= 9 ? \"0\" + d3 : \"A\" + d3 - 10; \n  wire [7:0] d4_s = d4 <= 9 ? \"0\" + d4 : \"A\" + d4 - 10; \n  assign str = {\"0x\", d4_s, d3_s, d2_s, d1_s, d0_s}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a shift register FIFO buffer with parameters depth and width. It has inputs clk, reset, next_in, X0_in, X1_in, X2_in, and X3_in, and outputs next_out, Y0, Y1, Y2, and Y3. It performs addition and subtraction operations using fixed-point arithmetic on the input data. The inputs X0_in, X1_in, X2_in, and X3_in are loaded into registers X0, X1, X2, and X3, respectively, and the next_in signal is stored in the register next. The calculated results are stored in Y0, Y1, Y2, and Y3. The module includes conditional logic for reset handling.\n\n Module header:\n\nmodule codeBlock46016(clk, reset, next_in, next_out,X0_in, Y0,X1_in, Y1,X2_in, Y2,X3_in, Y3);\n [/INST]\n", "output": "output next_out; \n  input clk, reset, next_in; \n  reg next; \n  input [11:0] X0_in, \n  X1_in, \n  X2_in, \n  X3_in; \n  reg [11:0] X0, \n  X1, \n  X2, \n  X3; \n  output [11:0] Y0, \n  Y1, \n  Y2, \n  Y3; \n  shiftRegFIFO #(1, 1) shiftFIFO_46359(.X(next), .Y(next_out), .clk(clk)); \n  wire signed [11:0] a9; \n  wire signed [11:0] a10; \n  wire signed [11:0] a11; \n  wire signed [11:0] a12; \n  wire signed [12:0] tm11; \n  wire signed [12:0] tm12; \n  wire signed [12:0] tm13; \n  wire signed [12:0] tm14; \n  wire signed [11:0] Y0; \n  wire signed [11:0] Y1; \n  wire signed [11:0] Y2; \n  wire signed [11:0] Y3; \n  wire signed [11:0] t21; \n  wire signed [11:0] t22; \n  wire signed [11:0] t23; \n  wire signed [11:0] t24; \n  assign a9 = X0; \n  assign a10 = X2; \n  assign a11 = X1; \n  assign a12 = X3; \n  assign Y0 = t21; \n  assign Y1 = t22; \n  assign Y2 = t23; \n  assign Y3 = t24; \n  assign t21 = tm11[12:1]; \n  assign t22 = tm12[12:1]; \n  assign t23 = tm13[12:1]; \n  assign t24 = tm14[12:1]; \n  addfxp #(13, 1) add46028(.a({{1{a9[11]}}, a9}), .b({{1{a10[11]}}, a10}), .clk(clk), .q(tm11)); \n  addfxp #(13, 1) add46043(.a({{1{a11[11]}}, a11}), .b({{1{a12[11]}}, a12}), .clk(clk), .q(tm12)); \n  subfxp #(13, 1) sub46058(.a({{1{a9[11]}}, a9}), .b({{1{a10[11]}}, a10}), .clk(clk), .q(tm13)); \n  subfxp #(13, 1) sub46073(.a({{1{a11[11]}}, a11}), .b({{1{a12[11]}}, a12}), .clk(clk), .q(tm14)); \n  always @(posedge clk) begin \n  if (reset == 1) begin \n  end \n  else begin \n  X0 <= X0_in; \n  X1 <= X1_in; \n  X2 <= X2_in; \n  X3 <= X3_in; \n  next <= next_in; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module acts as an AXI protocol converter and command translator. It takes in various AXI signals like s_arid, s_araddr, s_arlen, s_arsize, s_arburst, and s_arvalid, and converts them to corresponding signals like m_arvalid, m_araddr, r_arid, r_push, and r_rlast. It also incorporates a command translator to handle the translation of AXI commands. The module uses registers, wires, and instantiated sub-modules to manage the conversion and translation processes, and it operates based on the rising edge of the clk signal.\n\n Module header:\n\nmodule axi_protocol_converter_v2_1_b2s_ar_channel # (parameter integer C_ID_WIDTH = 4,parameter integer C_AXI_ADDR_WIDTH = 32) (input wire clk ,input wire reset ,input wire [C_ID_WIDTH-1:0] s_arid ,input wire [C_AXI_ADDR_WIDTH-1:0] s_araddr ,input wire [7:0] s_arlen ,input wire [2:0] s_arsize ,input wire [1:0] s_arburst ,input wire s_arvalid ,output wire s_arready ,output wire m_arvalid ,output wire [C_AXI_ADDR_WIDTH-1:0] m_araddr ,input wire m_arready ,output wire [C_ID_WIDTH-1:0] r_arid ,output wire r_push ,output wire r_rlast ,input wire r_full);\n [/INST]\n", "output": "wire next ; \n wire next_pending ; \n wire a_push; \n wire incr_burst; \n reg [C_ID_WIDTH-1:0] s_arid_r; \n axi_protocol_converter_v2_1_b2s_cmd_translator # \n (.C_AXI_ADDR_WIDTH ( C_AXI_ADDR_WIDTH )) \n cmd_translator_0 \n (.clk ( clk ) ,.reset ( reset ) ,.s_axaddr ( s_araddr ) ,.s_axlen ( s_arlen ) ,.s_axsize ( s_arsize ) ,.s_axburst ( s_arburst ) ,.s_axhandshake ( s_arvalid & a_push ) ,.incr_burst ( incr_burst ) ,.m_axaddr ( m_araddr ) ,.next ( next ) ,.next_pending ( next_pending )); \n axi_protocol_converter_v2_1_b2s_rd_cmd_fsm ar_cmd_fsm_0 \n (.clk ( clk ) ,.reset ( reset ) ,.s_arready ( s_arready ) ,.s_arvalid ( s_arvalid ) ,.s_arlen ( s_arlen ) ,.m_arvalid ( m_arvalid ) ,.m_arready ( m_arready ) ,.next ( next ) ,.next_pending ( next_pending ) ,.data_ready ( ~r_full ) ,.a_push ( a_push ) ,.r_push ( r_push )); \n assign r_arid = s_arid_r; \n assign r_rlast = ~next_pending; \n always @(posedge clk) begin \n  s_arid_r <= s_arid ; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a parameterized register file with configurable data and address sizes. It uses a decoder to select the registers based on the read and write addresses and a set of registers to store and update the data. The module also includes multiplexers to select the output data from the registers based on the read addresses. The size and number of registers can be set using the BITSIZE and ADDSIZE parameters, providing flexibility and reusability. The design aims to efficiently store and retrieve data based on the specified addresses and data sizes.\n\n Module header:\n\nmodule regfileparam #(parameter BITSIZE = 16,parameter ADDSIZE = 4) (output [BITSIZE-1:0] adat,output [BITSIZE-1:0] bdat,input [ADDSIZE-1:0] ra,input [ADDSIZE-1:0] rb,input [ADDSIZE-1:0] rw,input [BITSIZE-1:0] wdat,input wren,input clk, rst);\n [/INST]\n", "output": "localparam NUM_REGS = 2**ADDSIZE; \n  wire [NUM_REGS-1:0] decodout; \n  wire [BITSIZE-1:0] regouts [NUM_REGS-1:0]; \n  wire [BITSIZE*NUM_REGS-1:0] regouts2; \n decoderparam #(.WIDTH(ADDSIZE)) inputdecoder (.code(decodout),.a(rw),.clken(wren)); \n  genvar c; \n  generate \n  for (c=0; c < NUM_REGS; c=c+1) begin : GEN_REGS \n  regparam \n  # (.SIZE(BITSIZE)) regs \n (.Q(regouts[c]),.D(wdat),.clk(clk),.rst(rst),.clken(decodout[c])); \n  end \n  endgenerate \n  genvar d; \n  generate \n  for (d=0; d < NUM_REGS; d=d+1) begin : FLATTEN_REGOUTS \n  assign regouts2[d*BITSIZE +: BITSIZE] = regouts[d]; \n  end \n  endgenerate \n muxparam #(.WIDTH(NUM_REGS), .BITSIZE(BITSIZE)) read1 (.y(adat),.a(regouts2),.sel(ra)); \n muxparam #(.WIDTH(NUM_REGS), .BITSIZE(BITSIZE)) read2 (.y(bdat),.a(regouts2),.sel(rb)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a 16-register file with various read and write functionality. It uses specific addressing schemes to read from and write to registers based on input signals. The module also handles resets and clock transitions to ensure proper operation of the register file. The flags output is updated based on the wrfl input. Additionally, specific registers are updated based on the wr, wrfl, wrhi, and wr_ip0 inputs.\n\n Module header:\n\nmodule zet_regfile (output [15:0] a,output [15:0] b,output [15:0] c,output [15:0] cs,output [15:0] ip,input [31:0] d,output [15:0] s,output reg [8:0] flags,input wr,input wrfl,input wrhi,input clk,input rst,input [ 3:0] addr_a,input [ 3:0] addr_b,input [ 3:0] addr_c,input [ 3:0] addr_d,input [ 1:0] addr_s,input [ 8:0] iflags,input word_op,input a_byte,input b_byte,input c_byte,output cx_zero,input wr_ip0);\n [/INST]\n", "output": "reg [15:0] r[15:0]; \n  wire [7:0] a8, b8, c8; \n  wire [3:0] addr_a_8; \n  wire [3:0] addr_b_8; \n  wire [3:0] addr_c_8; \n  assign addr_a_8 = { 2'b00, addr_a[1:0] }; \n  assign addr_b_8 = { 2'b00, addr_b[1:0] }; \n  assign addr_c_8 = { 2'b00, addr_c[1:0] }; \n  assign a = (a_byte & ~addr_a[3]) ? { {8{a8[7]}}, a8} : r[addr_a]; \n  assign a8 = addr_a[2] ? r[addr_a_8][15:8] : r[addr_a][7:0]; \n  assign b = (b_byte & ~addr_b[3]) ? { {8{b8[7]}}, b8} : r[addr_b]; \n  assign b8 = addr_b[2] ? r[addr_b_8][15:8] : r[addr_b][7:0]; \n  assign c = (c_byte & ~addr_c[3]) ? { {8{c8[7]}}, c8} : r[addr_c]; \n  assign c8 = addr_c[2] ? r[addr_c_8][15:8] : r[addr_c][7:0]; \n  assign s = r[{2'b10,addr_s}]; \n  assign cs = r[9]; \n  assign cx_zero = (addr_d==4'd1) ? (d==16'd0) : (r[1]==16'd0); \n  assign ip = r[15]; \n  always @(posedge clk) \n  if (rst) begin \n  r[0] <= 16'd0; r[1] <= 16'd0; \n  r[2] <= 16'd0; r[3] <= 16'd0; \n  r[4] <= 16'd0; r[5] <= 16'd0; \n  r[6] <= 16'd0; r[7] <= 16'd0; \n  r[8] <= 16'd0; r[9] <= 16'hf000; \n  r[10] <= 16'd0; r[11] <= 16'd0; \n  r[12] <= 16'd0; r[13] <= 16'd0; \n  r[14] <= 16'd0; r[15] <= 16'hfff0; \n  flags <= 9'd0; \n  end else \n  begin \n  if (wr) begin \n  if (word_op | addr_d[3:2]==2'b10) \n  r[addr_d] <= word_op ? d[15:0] : {{8{d[7]}},d[7:0]}; \n  else if (addr_d[3]~^addr_d[2]) r[addr_d][7:0] <= d[7:0]; \n  else r[{2'b0,addr_d[1:0]}][15:8] <= d[7:0]; \n  end \n  if (wrfl) flags <= iflags; \n  if (wrhi) r[4'd2] <= d[31:16]; \n  if (wr_ip0) r[14] <= ip; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an interface between an AHB-Lite to Avalon Memory-Mapped (AVM) bridge. It maps signals from the AHB-Lite interface to the corresponding signals of the AVM interface. It assigns the read, write, write data, burst count, address, byte enable, stall, data valid, read data, and write acknowledge signals based on the input AHB-Lite signals and AVM signals. The module essentially acts as a translator between the two different memory interfaces.\n\n Module header:\n\nmodule acl_ic_to_avm #(parameter integer DATA_W = 256,parameter integer BURSTCOUNT_W = 6,parameter integer ADDRESS_W = 32,parameter integer BYTEENA_W = DATA_W / 8,parameter integer ID_W = 1) (output logic avm_enable,output logic avm_read,output logic avm_write,output logic [DATA_W-1:0] avm_writedata,output logic [BURSTCOUNT_W-1:0] avm_burstcount,output logic [ADDRESS_W-1:0] avm_address,output logic [BYTEENA_W-1:0] avm_byteenable,input logic avm_waitrequest,input logic avm_readdatavalid,input logic [DATA_W-1:0] avm_readdata,input logic avm_writeack,input logic ic_arb_request,input logic ic_arb_enable,input logic ic_arb_read,input logic ic_arb_write,input logic [DATA_W-1:0] ic_arb_writedata,input logic [BURSTCOUNT_W-1:0] ic_arb_burstcount,input logic [ADDRESS_W-$clog2(DATA_W / 8)-1:0] ic_arb_address,input logic [BYTEENA_W-1:0] ic_arb_byteenable,input logic [ID_W-1:0] ic_arb_id,output logic ic_arb_stall,output logic ic_wrp_ack,output logic ic_rrp_datavalid,output logic [DATA_W-1:0] ic_rrp_data);\n [/INST]\n", "output": "assign avm_read = ic_arb_read; \n  assign avm_write = ic_arb_write; \n  assign avm_writedata = ic_arb_writedata; \n  assign avm_burstcount = ic_arb_burstcount; \n  assign avm_address = {ic_arb_address, {$clog2(DATA_W / 8){1'b0}}}; \n  assign avm_byteenable = ic_arb_byteenable; \n  assign ic_arb_stall = avm_waitrequest; \n  assign ic_rrp_datavalid = avm_readdatavalid; \n  assign ic_rrp_data = avm_readdata; \n  assign ic_wrp_ack = avm_write & ~avm_waitrequest; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module represents a power-gated D flip-flop with synchronous reset. It takes clock (CLK), data (D), set/clear (SCD), set enable (SCE), and sleep control (SLEEP_B) inputs and provides the Q output. The D input is passed through a 2-to-1 multiplexer controlled by the delayed versions of D, SCD, and SCE. The multiplexer output is then fed into a power-gated D flip-flop to produce the Q output. The sleep control signal is used to gate the power supply to the flip-flop. Additionally, conditional expressions are used to generate the awake signal, which is then used to conditionally trigger the power good signal.\n\n Module header:\n\nmodule sky130_fd_sc_lp__srsdfxtp (Q ,CLK ,D ,SCD ,SCE ,SLEEP_B);\n [/INST]\n", "output": "output Q ; \n  input CLK ; \n  input D ; \n  input SCD ; \n  input SCE ; \n  input SLEEP_B; \n  supply1 KAPWR; \n  supply1 VPWR ; \n  supply0 VGND ; \n  supply1 VPB ; \n  supply0 VNB ; \n  wire buf_Q ; \n  wire mux_out ; \n  reg notifier ; \n  wire D_delayed ; \n  wire SCD_delayed ; \n  wire SCE_delayed ; \n  wire CLK_delayed ; \n  wire awake ; \n  wire cond1 ; \n  wire cond2 ; \n  wire cond3 ; \n  wire pwrgood_pp0_out_Q; \n  sky130_fd_sc_lp__udp_mux_2to1 mux_2to10 (mux_out , D_delayed, SCD_delayed, SCE_delayed ); \n  sky130_fd_sc_lp__udp_dff$P_pp$PKG$sN dff0 (buf_Q , mux_out, CLK_delayed, SLEEP_B, notifier, KAPWR, VGND, VPWR); \n  assign awake = ( SLEEP_B === 1'b0 ); \n  assign cond1 = ( ( SCE_delayed === 1'b0 ) && awake ); \n  assign cond2 = ( ( SCE_delayed === 1'b1 ) && awake ); \n  assign cond3 = ( ( D_delayed !== SCD_delayed ) && awake ); \n  sky130_fd_sc_lp__udp_pwrgood_pp$PG pwrgood_pp0 (pwrgood_pp0_out_Q, buf_Q, VPWR, VGND ); \n  buf buf0 (Q , pwrgood_pp0_out_Q ); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a scan rate timer that generates a tick signal based on the input clock and a rate select signal. It calculates different tick values based on the clock frequency and the selected scan rate. The module uses a counter to generate the tick signal and selects the tick value based on the rate select input. The generated tick signal is used to control the scanning rate in a system.\n\n Module header:\n\nmodule CLS_Scan_Rate_Timer #(parameter CLK_RATE_HZ = 50000000) (input [1:0] RATE_SELECT,output reg SRT_TICK,input CLK);\n [/INST]\n", "output": "localparam SCAN_RATE_FASTER = 32; \n  localparam SCAN_RATE_FAST = 16; \n  localparam SCAN_RATE_SLOW = 8; \n  localparam SCAN_RATE_SLOWER = 2; \n  localparam SRT_TICKS_MAX = CLK_RATE_HZ / SCAN_RATE_SLOWER; \n  localparam SRT_REG_WIDTH = bit_index(SRT_TICKS_MAX); \n  localparam [SRT_REG_WIDTH:0] SRT_TICKS_FASTER = 1.0 * CLK_RATE_HZ / SCAN_RATE_FASTER; \n  localparam [SRT_REG_WIDTH:0] SRT_TICKS_FAST = 1.0 * CLK_RATE_HZ / SCAN_RATE_FAST; \n  localparam [SRT_REG_WIDTH:0] SRT_TICKS_SLOW = 1.0 * CLK_RATE_HZ / SCAN_RATE_SLOW; \n  localparam [SRT_REG_WIDTH:0] SRT_TICKS_SLOWER = 1.0 * CLK_RATE_HZ / SCAN_RATE_SLOWER; \n  localparam [SRT_REG_WIDTH:0] SRT_FASTER_LOADVAL = {1'b1, {(SRT_REG_WIDTH){1'b0}}} - SRT_TICKS_FASTER + 1'b1; \n  localparam [SRT_REG_WIDTH:0] SRT_FAST_LOADVAL = {1'b1, {(SRT_REG_WIDTH){1'b0}}} - SRT_TICKS_FAST + 1'b1; \n  localparam [SRT_REG_WIDTH:0] SRT_SLOW_LOADVAL = {1'b1, {(SRT_REG_WIDTH){1'b0}}} - SRT_TICKS_SLOW + 1'b1; \n  localparam [SRT_REG_WIDTH:0] SRT_SLOWER_LOADVAL = {1'b1, {(SRT_REG_WIDTH){1'b0}}} - SRT_TICKS_SLOWER + 1'b1; \n  reg [SRT_REG_WIDTH:0] srt_cnt_loadval; \n  reg [SRT_REG_WIDTH:0] srt_cnt_reg; \n  wire srt_cnt_tick; \n  initial \n  begin \n  SRT_TICK = 1'b0; \n  srt_cnt_loadval = SRT_FASTER_LOADVAL; \n  srt_cnt_reg = SRT_FASTER_LOADVAL; \n  end \n  always @* \n  begin \n  case (RATE_SELECT) \n  2'h0 : srt_cnt_loadval <= SRT_SLOWER_LOADVAL; \n  2'h1 : srt_cnt_loadval <= SRT_SLOW_LOADVAL; \n  2'h2 : srt_cnt_loadval <= SRT_FAST_LOADVAL; \n  2'h3 : srt_cnt_loadval <= SRT_FASTER_LOADVAL; \n  endcase \n  end \n  always @(posedge CLK) \n  begin \n  if (srt_cnt_reg[SRT_REG_WIDTH]) \n  srt_cnt_reg <= srt_cnt_loadval; \n  else \n  srt_cnt_reg <= srt_cnt_reg + 1'b1; \n  end \n  assign srt_cnt_tick = srt_cnt_reg[SRT_REG_WIDTH]; \n  always @(posedge CLK) \n  begin \n  SRT_TICK <= srt_cnt_tick; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a parameterized PCIe single queue command FIFO. It utilizes a depth-width parameter and calculates the fullness and emptiness of the FIFO based on read and write addresses. The module features logic for read and write enable, and it resets the front and rear addresses when the reset signal is asserted. Additionally, it instantiates a BRAM_SDP_MACRO for implementing the FIFO memory.\n\n Module header:\n\nmodule pcie_sq_cmd_fifo # (parameter P_FIFO_DATA_WIDTH = 11,parameter P_FIFO_DEPTH_WIDTH = 2) (input clk,input rst_n,input wr_en,input [P_FIFO_DATA_WIDTH-1:0] wr_data,output full_n,input rd_en,output [P_FIFO_DATA_WIDTH-1:0] rd_data,output empty_n);\n [/INST]\n", "output": "localparam P_FIFO_ALLOC_WIDTH = 0; \n reg [P_FIFO_DEPTH_WIDTH:0] r_front_addr; \n reg [P_FIFO_DEPTH_WIDTH:0] r_front_addr_p1; \n wire [P_FIFO_DEPTH_WIDTH-1:0] w_front_addr; \n reg [P_FIFO_DEPTH_WIDTH:0] r_rear_addr; \n assign full_n = ~((r_rear_addr[P_FIFO_DEPTH_WIDTH] ^ r_front_addr[P_FIFO_DEPTH_WIDTH])& (r_rear_addr[P_FIFO_DEPTH_WIDTH-1:P_FIFO_ALLOC_WIDTH]== r_front_addr[P_FIFO_DEPTH_WIDTH-1:P_FIFO_ALLOC_WIDTH])); \n assign empty_n = ~(r_front_addr[P_FIFO_DEPTH_WIDTH:P_FIFO_ALLOC_WIDTH]== r_rear_addr[P_FIFO_DEPTH_WIDTH:P_FIFO_ALLOC_WIDTH]); \n always @(posedge clk or negedge rst_n) \n begin \n  if (rst_n == 0) begin \n  r_front_addr <= 0; \n  r_front_addr_p1 <= 1; \n  r_rear_addr <= 0; \n  end \n  else begin \n  if (rd_en == 1) begin \n  r_front_addr <= r_front_addr_p1; \n  r_front_addr_p1 <= r_front_addr_p1 + 1; \n  end \n  if (wr_en == 1) begin \n  r_rear_addr <= r_rear_addr + 1; \n  end \n  end \n end \n assign w_front_addr = (rd_en == 1) ? r_front_addr_p1[P_FIFO_DEPTH_WIDTH-1:0] \n  : r_front_addr[P_FIFO_DEPTH_WIDTH-1:0]; \n localparam LP_DEVICE = \"7SERIES\"; \n localparam LP_BRAM_SIZE = \"18Kb\"; \n localparam LP_DOB_REG = 0; \n localparam LP_READ_WIDTH = P_FIFO_DATA_WIDTH; \n localparam LP_WRITE_WIDTH = P_FIFO_DATA_WIDTH; \n localparam LP_WRITE_MODE = \"READ_FIRST\"; \n localparam LP_WE_WIDTH = 2; \n localparam LP_ADDR_TOTAL_WITDH = 10; \n localparam LP_ADDR_ZERO_PAD_WITDH = LP_ADDR_TOTAL_WITDH - P_FIFO_DEPTH_WIDTH; \n generate \n  wire [LP_ADDR_TOTAL_WITDH-1:0] rdaddr; \n  wire [LP_ADDR_TOTAL_WITDH-1:0] wraddr; \n  wire [LP_ADDR_ZERO_PAD_WITDH-1:0] zero_padding = 0; \n  if(LP_ADDR_ZERO_PAD_WITDH == 0) begin : calc_addr \n  assign rdaddr = w_front_addr[P_FIFO_DEPTH_WIDTH-1:0]; \n  assign wraddr = r_rear_addr[P_FIFO_DEPTH_WIDTH-1:0]; \n  end \n  else begin \n  assign rdaddr = {zero_padding[LP_ADDR_ZERO_PAD_WITDH-1:0], w_front_addr[P_FIFO_DEPTH_WIDTH-1:0]}; \n  assign wraddr = {zero_padding[LP_ADDR_ZERO_PAD_WITDH-1:0], r_rear_addr[P_FIFO_DEPTH_WIDTH-1:0]}; \n  end \n endgenerate \n BRAM_SDP_MACRO #(.DEVICE (LP_DEVICE),.BRAM_SIZE (LP_BRAM_SIZE),.DO_REG (LP_DOB_REG),.READ_WIDTH (LP_READ_WIDTH),.WRITE_WIDTH (LP_WRITE_WIDTH),.WRITE_MODE (LP_WRITE_MODE)) \n ramb18sdp_0(.DO (rd_data[LP_READ_WIDTH-1:0]),.DI (wr_data[LP_WRITE_WIDTH-1:0]),.RDADDR (rdaddr),.RDCLK (clk),.RDEN (1'b1),.REGCE (1'b1),.RST (1'b0),.WE ({LP_WE_WIDTH{1'b1}}),.WRADDR (wraddr),.WRCLK (clk),.WREN (wr_en)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a single-port RAM with a 21-bit address and 4-bit data. The module takes in a write enable (we), data input (datain), clock (clk), and outputs the data read from the RAM (dataout). The address is generated internally from the write enable signal by shifting it through a chain of flip-flops triggered by the positive edge of the clock. The address generated is then used to access the single-port RAM.\n\n Module header:\n\n module spram21x4 (we, dataout, datain, clk);\n [/INST]\n", "output": "input we; \n  output[21 - 1:0] dataout; \n  wire[21 - 1:0] dataout; \n  input[21 - 1:0] datain; \n  input clk; \n  reg [7:0] addr; \n  always @ (posedge clk) \n  begin \n  addr[0] <= we; \n  addr [1] <= addr[0]; \n  addr [2] <= addr[1]; \n  addr [3] <= addr[2]; \n  addr [4] <= addr[3]; \n  addr [5] <= addr[4]; \n  addr [6] <= addr[5]; \n  addr [7] <= addr[6]; \n  end \n single_port_ram new_ram(.clk (clk),.we(we),.data(datain),.out(dataout),.addr(addr)); \n  endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, named credit_producer, generates symbol and packet credits based on input signals and parameters. It tracks the beats and end of packets, and updates the credits accordingly. The symbol_credits and packet_credits outputs are incremented based on the configured SYMBOLS_PER_CREDIT, SYMBOLS_PER_BEAT, USE_SYMBOL_CREDITS, USE_PACKET_CREDITS, and USE_PACKETS parameters, along with the input signals. The module contains logic for rollover conditions and reset behavior to handle credit generation.\n\n Module header:\n\nmodule credit_producer (clk,reset_n,in_valid,in_ready,in_endofpacket,symbol_credits,packet_credits);\n [/INST]\n", "output": "parameter SYMBOLS_PER_CREDIT = 1; \n  parameter SYMBOLS_PER_BEAT = 1; \n  parameter USE_SYMBOL_CREDITS = 1; \n  parameter USE_PACKET_CREDITS = 1; \n  parameter USE_PACKETS = 1; \n  input clk; \n  input reset_n; \n  input in_valid; \n  input in_ready; \n  input in_endofpacket; \n  output reg [15 : 0] symbol_credits; \n  output reg [15 : 0] packet_credits; \n  reg beat; \n  reg eop_beat; \n  reg [15 : 0] sym_count; \n  reg [15 : 0] next_sym_count; \n  reg rollover; \n  always @* begin \n  beat = in_valid && in_ready; \n  if (USE_PACKETS) \n  eop_beat = beat && in_endofpacket; \n  else \n  eop_beat = 0; \n  end \n generate \n  if (SYMBOLS_PER_BEAT % SYMBOLS_PER_CREDIT == 0) begin \n  always @(posedge clk or negedge reset_n) begin \n  if (!reset_n) \n  symbol_credits <= 0; \n  else if (beat) \n  symbol_credits <= symbol_credits + SYMBOLS_PER_BEAT/SYMBOLS_PER_CREDIT; \n  end \n  end \n  else if (SYMBOLS_PER_CREDIT % SYMBOLS_PER_BEAT == 0) begin \n  always @* begin \n  next_sym_count = sym_count; \n  if (beat) \n  next_sym_count = sym_count + SYMBOLS_PER_BEAT; \n  end \n  always @* begin \n  rollover = (next_sym_count == SYMBOLS_PER_CREDIT) || eop_beat; \n  end \n  always @(posedge clk or negedge reset_n) begin \n  if (!reset_n) \n  sym_count <= 0; \n  else if (rollover) \n  sym_count <= 0; \n  else \n  sym_count <= next_sym_count; \n  end \n  always @(posedge clk or negedge reset_n) begin \n  if (!reset_n) \n  symbol_credits <= 0; \n  else if (rollover) \n  symbol_credits <= symbol_credits + 1; \n  end \n  end \n endgenerate \n  always @(posedge clk or negedge reset_n) begin \n  if (!reset_n) \n  packet_credits <= 0; \n  else if (eop_beat) \n  packet_credits <= packet_credits + 1; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a CIC (Cascaded Integrator-Comb) Decimator. It takes in input data and, after processing, provides output data. The module contains registers, combinational logic, and delay registers. It uses clock and reset signals to control the processing of input data. The processing involves integrators and delay registers to create the output data based on the input data. The cycle register, clock, and rate are used to control the decimation of the input data to produce the output data.\n\n Module header:\n\nmodule cic_decimator #(parameter WIDTH = 16,parameter RMAX = 2,parameter M = 1,parameter N = 2,parameter REG_WIDTH = WIDTH+$clog2((RMAX*M)**N)) (input wire clk,input wire rst,input wire [WIDTH-1:0] input_tdata,input wire input_tvalid,output wire input_tready,output wire [REG_WIDTH-1:0] output_tdata,output wire output_tvalid,input wire output_tready,input wire [$clog2(RMAX+1)-1:0] rate);\n [/INST]\n", "output": "reg [$clog2(RMAX+1)-1:0] cycle_reg = 0; \n reg [REG_WIDTH-1:0] int_reg[N-1:0]; \n wire [REG_WIDTH-1:0] int_reg_0 = int_reg[0]; \n wire [REG_WIDTH-1:0] int_reg_1 = int_reg[1]; \n reg [REG_WIDTH-1:0] comb_reg[N-1:0]; \n wire [REG_WIDTH-1:0] comb_reg_0 = comb_reg[0]; \n wire [REG_WIDTH-1:0] comb_reg_1 = comb_reg[1]; \n assign input_tready = output_tready | (cycle_reg != 0); \n assign output_tdata = comb_reg[N-1]; \n assign output_tvalid = input_tvalid & cycle_reg == 0; \n genvar k; \n integer i; \n integer j; \n integer l; \n integer v; \n initial begin \n  for (i = 0; i < N; i = i + 1) begin \n  int_reg[i] <= 0; \n  comb_reg[i] <= 0; \n  end \n end \n generate \n for (k = 0; k < N; k = k + 1) begin : integrator \n  always @(posedge clk) begin \n  if (rst) begin \n  int_reg[k] <= 0; \n  end else begin \n  if (input_tready & input_tvalid) begin \n  if (k == 0) begin \n  int_reg[k] <= $signed(int_reg[k]) + $signed(input_tdata); \n  end else begin \n  int_reg[k] <= $signed(int_reg[k]) + $signed(int_reg[k-1]); \n  end \n  end \n  end \n  end \n end \n endgenerate \n generate \n for (k = 0; k < N; k = k + 1) begin : comb \n  reg [REG_WIDTH-1:0] delay_reg[M-1:0]; \n  initial begin \n  for (j = 0; j < M; j = j + 1) begin \n  delay_reg[j] <= 0; \n  end \n  end \n  always @(posedge clk) begin \n  if (rst) begin \n  for (l = 0; l < M; l = l + 1) begin \n  delay_reg[l] <= 0; \n  end \n  comb_reg[k] <= 0; \n  end else begin \n  if (output_tready & output_tvalid) begin \n  if (k == 0) begin \n  delay_reg[0] <= $signed(int_reg[N-1]); \n  comb_reg[k] <= $signed(int_reg[N-1]) - $signed(delay_reg[M-1]); \n  end else begin \n  delay_reg[0] <= $signed(comb_reg[k-1]); \n  comb_reg[k] <= $signed(comb_reg[k-1]) - $signed(delay_reg[M-1]); \n  end \n  for (v = 0; v < M-1; v = v + 1) begin \n  delay_reg[i+1] <= delay_reg[i]; \n  end \n  end \n  end \n  end \n end \n endgenerate \n always @(posedge clk) begin \n  if (rst) begin \n  cycle_reg <= 0; \n  end else begin \n  if (input_tready & input_tvalid) begin \n  if (cycle_reg < RMAX - 1 && cycle_reg < rate - 1) begin \n  cycle_reg <= cycle_reg + 1; \n  end else begin \n  cycle_reg <= 0; \n  end \n  end \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a series of shift registers and logical operations to generate various control signals. It processes input signals, foo, bar, and baz, to determine the output signals w_rdat_ena, w_rdat_mrk, w_wdat_ena_set, w_wdat_ena_clr, w_wdat_mrk_set, w_wdat_mrk_clr, w_wdat_ena, w_wdat_mrk, w_dat15_ena, w_dat15_mrk, and w_timeout_mrk. The output signals are dependent on specific patterns and combinations of the input signals, as well as intermediate signals generated by the shift registers and logical operations.\n\n Module header:\n\nmodule hangcase ();\n [/INST]\n", "output": "assign w_rdat_ena = ({16{foo[ 0]}} & bar ) | \n  ({16{foo[ 1]}} & bar ) | \n  ({16{foo[ 2]}} & bar ) | \n  ({16{foo[ 3]}} & bar ) | \n  ({16{foo[ 4]}} & bar ) | \n  ({16{foo[ 5]}} & bar ) | \n  ({16{foo[ 6]}} & bar ) | \n  ({16{foo[ 7]}} & bar ) | \n  ({16{foo[ 8]}} & bar ) | \n  ({16{foo[ 9]}} & bar ) | \n  ({16{foo[10]}} & bar ) | \n  ({16{foo[11]}} & bar ) | \n  ({16{foo[12]}} & bar ) | \n  ({16{foo[13]}} & bar ) | \n  ({16{foo[14]}} & bar ) | \n  ({16{foo[15]}} & bar ) ; \n  assign w_rdat_mrk = ({16{foo[ 0]}} & bar & baz ) | \n  ({16{foo[ 1]}} & bar & baz ) | \n  ({16{foo[ 2]}} & bar & baz ) | \n  ({16{foo[ 3]}} & bar & baz ) | \n  ({16{foo[ 4]}} & bar & baz ) | \n  ({16{foo[ 5]}} & bar & baz ) | \n  ({16{foo[ 6]}} & bar & baz ) | \n  ({16{foo[ 7]}} & bar & baz ) | \n  ({16{foo[ 8]}} & bar & baz ) | \n  ({16{foo[ 9]}} & bar & baz ) | \n  ({16{foo[10]}} & bar & baz ) | \n  ({16{foo[11]}} & bar & baz ) | \n  ({16{foo[12]}} & bar & baz ) | \n  ({16{foo[13]}} & bar & baz ) | \n  ({16{foo[14]}} & bar & baz ) | \n  ({16{foo[15]}} & bar & baz ) ; \n  assign w_wdat_ena_set = ({16{ena_set}} & col_dec ); \n  assign w_wdat_ena_clr = ({16{ena_clr}} & col_dec ); \n  assign w_wdat_mrk_set = ({16{mrk_set}} & w_rdat_ena ); \n  assign w_wdat_mrk_clr = ({16{mrk_clr}} & col_dec ); \n  assign w_wdat_ena = (w_rdat_ena & ~w_wdat_ena_clr) | w_wdat_ena_set; \n  assign w_wdat_mrk = (w_rdat_mrk & ~w_wdat_mrk_clr) | w_wdat_mrk_set; \n  assign w_dat15_ena = foo[15] ? w_wdat_ena : bar; \n  assign w_dat15_mrk = foo[15] ? w_wdat_mrk : baz; \n  assign w_timeout_mrk = row_check ? w_wdat_mrk : r_timeout_mrk; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a floating-point divider. It takes clock, dividend, divisor, and control inputs, and provides the quotient, remainder, sign, and divide-zero status as outputs. The module includes state and count registers, and a state machine to control the division process. It also handles edge cases such as division by zero and performs the division computation using clock-sensitive processes. The design incorporates ready, busy, and waiting states to manage the division operation.\n\n Module header:\n\nmodule or1200_fpu_div (clk_i,dvdnd_i,dvsor_i,sign_dvd_i,sign_div_i,start_i,ready_o,qutnt_o,rmndr_o,sign_o,div_zero_o);\n [/INST]\n", "output": "parameter FP_WIDTH = 32; \n  parameter MUL_SERIAL = 0; \n  parameter MUL_COUNT = 11; \n  parameter FRAC_WIDTH = 23; \n  parameter EXP_WIDTH = 8; \n  parameter ZERO_VECTOR = 31'd0; \n  parameter INF = 31'b1111111100000000000000000000000; \n  parameter QNAN = 31'b1111111110000000000000000000000; \n  parameter SNAN = 31'b1111111100000000000000000000001; \n  input clk_i; \n  input [2*(FRAC_WIDTH+2)-1:0] dvdnd_i; \n  input [FRAC_WIDTH+3:0] dvsor_i; \n  input sign_dvd_i; \n  input sign_div_i; \n  input start_i; \n  output ready_o; \n  output [FRAC_WIDTH+3:0] qutnt_o; \n  output [FRAC_WIDTH+3:0] rmndr_o; \n  output sign_o; \n  output div_zero_o; \n  parameter t_state_waiting = 1'b0, \n  t_state_busy = 1'b1; \n  reg [FRAC_WIDTH+3:0] s_qutnt_o; \n  reg [FRAC_WIDTH+3:0] s_rmndr_o; \n  reg [2*(FRAC_WIDTH+2)-1:0] s_dvdnd_i; \n  reg [FRAC_WIDTH+3:0] s_dvsor_i; \n  reg s_sign_dvd_i, s_sign_div_i; \n  wire s_sign_o; \n  wire s_div_zero_o; \n  reg s_start_i; \n  reg s_ready_o; \n  reg s_state; \n  reg [4:0] s_count; \n  reg [FRAC_WIDTH+3:0] s_dvd; \n  always @(posedge clk_i) \n  begin \n  s_dvdnd_i <= dvdnd_i; \n  s_dvsor_i <= dvsor_i; \n  s_sign_dvd_i<= sign_dvd_i; \n  s_sign_div_i<= sign_div_i; \n  s_start_i <= start_i; \n  end \n  assign qutnt_o = s_qutnt_o; \n  assign rmndr_o = s_rmndr_o; \n  assign sign_o = s_sign_o; \n  assign ready_o = s_ready_o; \n  assign div_zero_o = s_div_zero_o; \n  assign s_sign_o = sign_dvd_i ^ sign_div_i; \n  assign s_div_zero_o = !(|s_dvsor_i) & (|s_dvdnd_i); \n  always @(posedge clk_i) \n  if (s_start_i) \n  begin \n  s_state <= t_state_busy; \n  s_count <= 26; \n  end \n  else if (!(|s_count) & s_state==t_state_busy) \n  begin \n  s_state <= t_state_waiting; \n  s_ready_o <= 1; \n  s_count <=26; \n  end \n  else if (s_state==t_state_busy) \n  s_count <= s_count - 1; \n  else \n  begin \n  s_state <= t_state_waiting; \n  s_ready_o <= 0; \n  end \n  wire [26:0] v_div; \n  assign v_div = (s_count==26) ? {3'd0,s_dvdnd_i[49:26]} : s_dvd; \n  wire [26:0] v_div_minus_s_dvsor_i; \n  assign v_div_minus_s_dvsor_i = v_div - s_dvsor_i; \n  always @(posedge clk_i) \n  begin \n  if (s_start_i) \n  begin \n  s_qutnt_o <= 0; \n  s_rmndr_o <= 0; \n  end \n  else if (s_state==t_state_busy) \n  begin \n  if (v_div < s_dvsor_i) \n  begin \n  s_qutnt_o[s_count] <= 1'b0; \n  s_dvd <= {v_div[25:0],1'b0}; \n  end \n  else \n  begin \n  s_qutnt_o[s_count] <= 1'b1; \n  s_dvd <= {v_div_minus_s_dvsor_i[25:0],1'b0}; \n  end \n  s_rmndr_o <= v_div; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a single-port RAM with the parameters PIPELINED, ADDR_WIDTH, DATA_WIDTH, and MEMSIZE. The RAM is initialized with preset values and can be accessed for read and write operations using the CLK, EN, WE, ADDR, DI, and DO signals. The output DO is determined based on the PIPELINED parameter and the RAM contents at the specified address. The RAM is synchronous and is updated on the positive edge of the clock signal.\n\n Module header:\n\nmodule BRAM1(CLK,EN,WE,ADDR,DI,DO);\n [/INST]\n", "output": "parameter PIPELINED = 0; \n  parameter ADDR_WIDTH = 1; \n  parameter DATA_WIDTH = 1; \n  parameter MEMSIZE = 1; \n  input CLK; \n  input EN; \n  input WE; \n  input [ADDR_WIDTH-1:0] ADDR; \n  input [DATA_WIDTH-1:0] DI; \n  output [DATA_WIDTH-1:0] DO; \n  reg [DATA_WIDTH-1:0] RAM[0:MEMSIZE-1]; \n  reg [ADDR_WIDTH-1:0] ADDR_R; \n  reg [DATA_WIDTH-1:0] DO_R; \n `ifdef BSV_NO_INITIAL_BLOCKS \n `else \n  integer i; \n  initial \n  begin : init_block \n  for (i = 0; i < MEMSIZE; i = i + 1) begin \n  RAM[i] = { ((DATA_WIDTH+1)/2) { 2'b10 } }; \n  end \n  ADDR_R = { ((ADDR_WIDTH+1)/2) { 2'b10 } }; \n  DO_R = { ((DATA_WIDTH+1)/2) { 2'b10 } }; \n  end \n `endif \n  always @(posedge CLK) begin \n  if (EN) begin \n  if (WE) \n  RAM[ADDR] <= `BSV_ASSIGNMENT_DELAY DI; \n  ADDR_R <= `BSV_ASSIGNMENT_DELAY ADDR; \n  end \n  DO_R <= `BSV_ASSIGNMENT_DELAY RAM[ADDR_R]; \n  end \n  assign DO = (PIPELINED) ? DO_R : RAM[ADDR_R]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an Analog-to-Digital Converter (ADC) controller for the MCP300x series of ADCs. It interfaces with a Wishbone bus and a Serial Peripheral Interface (SPI) to read analog inputs and provide digital outputs. The module includes a configurable clock divider, start signal generation, channel selection, and SPI interface control. Additionally, it supports an internal clock and an enable signal for the ADC and SPI interface. The module instantiates an MCP300x module to communicate with the ADC.\n\n Module header:\n\nmodule AD_Conv #(parameter DIVIDER=12,parameter INTERNAL_CLK=1,parameter ENABLE=1) (input wb_clk_i,input wb_rst_i,input [0:0] wb_adr_i,output [7:0] wb_dat_o,input [7:0] wb_dat_i,input wb_we_i,input wb_stb_i,output wb_ack_o,input spi_ena_i,output ad_ncs_o,output ad_clk_o,output ad_din_o,input ad_dout_i);\n [/INST]\n", "output": "localparam integer CNT_BITS=$clog2(DIVIDER); \n reg [CNT_BITS-1:0] cnt_div_spi=0; \n wire spi_ena; \n reg start_r; \n wire busy_ad; \n wire busy; \n reg [2:0] chn_r; \n wire [9:0] cur_val; \n wire [7:0] wb_dat; \n wire ad_ncs; \n wire ad_clk; \n wire ad_din; \n assign wb_dat=wb_adr_i[0] ? {busy,{5{1'b0}},cur_val[9:8]} : cur_val[7:0]; \n assign wb_dat_o=ENABLE ? wb_dat : 0; \n assign wb_ack_o=wb_stb_i; \n always @(posedge wb_clk_i) \n begin : do_start \n  if (wb_rst_i) \n  start_r <= 0; \n  else \n  if (wb_stb_i && wb_we_i) \n  start_r <= 1; \n  else \n  if (busy_ad) \n  start_r <= 0; \n end \n assign busy=busy_ad | start_r; \n always @(posedge wb_clk_i) \n begin : do_chn_write \n  if (wb_stb_i && wb_we_i) \n  chn_r <= wb_dat_i[2:0]; \n end \n generate \n if (INTERNAL_CLK) \n  begin \n  always @(posedge wb_clk_i) \n  begin : do_spi_div \n  if (cnt_div_spi==DIVIDER-1) \n  cnt_div_spi <= 0; \n  else \n  cnt_div_spi <= cnt_div_spi+1; \n  end \n  assign spi_ena=cnt_div_spi==DIVIDER-1; \n  end \n else \n  begin \n  assign spi_ena=spi_ena_i; \n  end \n endgenerate \n MCP300x the_AD \n (.clk_i(wb_clk_i), .rst_i(1'b0),.start_i(start_r), .busy_o(busy_ad), .chn_i(chn_r), .single_i(1'b1),.ena_i(spi_ena), .eoc_o(), .data_o(cur_val),.ad_ncs_o(ad_ncs), .ad_clk_o(ad_clk), .ad_din_o(ad_din),.ad_dout_i(ad_dout_i)); \n assign ad_ncs_o=ENABLE ? ad_ncs : 0; \n assign ad_clk_o=ENABLE ? ad_clk : 0; \n assign ad_din_o=ENABLE ? ad_din : 0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a combinational logic that selects an output o based on the input x and additional inputs a, b, c, d, and e. When x is 0 or 2, o is assigned the value of b. When x is 1, o is assigned the value of c. When x is 3, 4, or 5, o is assigned the values of d or e respectively. If x does not match any of these cases, o is assigned 0.\n\n Module header:\n\nmodule case_nonoverlap (input wire [2:0] x,input wire a, b, c, d, e,output reg o);\n [/INST]\n", "output": "always @* begin \n  case (x) \n  0, 2: o = b; \n  1: o = c; \n  default: \n  case (x) \n  3: o = d; 4: o = d; \n  5: o = e; \n  default: o = 1'b0; \n  endcase \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module dec_3x8 implements a 3-to-8 decoder, where the input In selects one of the eight output lines in Out based on the binary value of In. The output lines are set according to the binary value of the input In using a case statement. For example, when In is 3'b000, Out is set to 8'b00000001. Similarly, when In is 3'b111, Out is set to 8'b10000000.\n\n Module header:\n\nmodule dec_3x8(Out, In);\n [/INST]\n", "output": "output [7:0]Out; \n  reg [7:0]Out; \n  input [2:0] In; \n  always @ (In) \n  case (In) \n  3'b000: Out=8'b00000001; \n  3'b001: Out=8'b00000010; \n  3'b010: Out=8'b00000100; \n  3'b011: Out=8'b00001000; \n  3'b100: Out=8'b00010000; \n  3'b101: Out=8'b00100000; \n  3'b110: Out=8'b01000000; \n  3'b111: Out=8'b10000000; \n  endcase \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module defines an output signal of 36 bits, named tr_data, and sets it to zero. It is a simple module that drives a 36-bit output signal to a constant value of zero.\n\n Module header:\n\nmodule system1_nios2_gen2_0_cpu_nios2_oci_pib (tr_data);\n [/INST]\n", "output": "output [ 35: 0] tr_data; \n wire [ 35: 0] tr_data; \n  assign tr_data = 0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a counter with a configurable bit width. It increments or decrements the counter based on the input signals Cambio and got_data. When Cambio is 8'h7A and got_data is high, the counter is reset to 0 if it equals X, otherwise it is incremented by 1. If Cambio is 8'h69 and got_data is high, the counter is set to X if it is currently 0, otherwise it is decremented by 1. The counter is also reset to 0 on the rising edge of the rst signal.\n\n Module header:\n\nmodule Contador_ID(input rst,input [7:0] Cambio,input got_data,input clk,output reg [(N-1):0] Cuenta);\n [/INST]\n", "output": "parameter N = 2; \n  parameter X = 2; \n  always @(posedge clk) \n  if (rst) \n  Cuenta <= 0; \n  else if (Cambio == 8'h7A && got_data) \n  begin \n  if (Cuenta == X) \n  Cuenta <= 0; \n  else \n  Cuenta <= Cuenta + 1'd1; \n  end \n  else if (Cambio == 8'h69 && got_data) \n  begin \n  if (Cuenta == 0) \n  Cuenta <= X; \n  else \n  Cuenta <= Cuenta - 1'd1; \n  end \n  else \n  Cuenta <= Cuenta; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module instantiates four submodules and assigns their inputs and outputs using wires. The submodules are connected in a way that the output of one submodule is connected to the input of another submodule. The module also uses direct assignments to connect certain inputs to outputs. The behavior of the submodules and the connections between them will determine the overall functionality of the module.\n\n Module header:\n\nmodule ve77f7c (input v444878,input v6a82dd,output vd4e5d7);\n [/INST]\n", "output": "wire w0; \n  wire w1; \n  wire w2; \n  wire w3; \n  wire w4; \n  wire w5; \n  wire w6; \n  wire w7; \n  wire w8; \n  assign w3 = v444878; \n  assign w4 = v444878; \n  assign w5 = v444878; \n  assign vd4e5d7 = w6; \n  assign w7 = v6a82dd; \n  assign w8 = v6a82dd; \n  assign w4 = w3; \n  assign w5 = w3; \n  assign w5 = w4; \n  assign w8 = w7; \n v93adf6 ve5d8ab (.v9afc1f(w0),.va4102a(w3),.ve8318d(w6),.vf54559(w7)); \n v8d4ef5 v25f434 (.v712cd1(w0),.v7c533e(w1),.ve61673(w2),.vdd729a(w4)); \n vbd4c1c v584300 (.v3487af(w2),.ved8395(w5),.ve78ab8(w8)); \n vfebcfe vfd2d50 (.v9fb85f(w1)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a hardware test module that contains clock signal generation, population count, acknowledgement signals, data signals, clock domain crossing, and a DAC driver module. The module uses the input signals to control the generation and manipulation of various signals, including data and acknowledgement signals. It also handles clock domain crossing and population count logic. The module is designed to interface with a DAC driver module and provides the necessary control signals for data output.\n\n Module header:\n\nmodule hw_test(input wire clk50000,input wire rst,input wire [6:0] sw,output sck_o,output bck_o,output data_o,output lrck_o);\n [/INST]\n", "output": "reg clk24576; \n always @(posedge clk50000) \n  clk24576 <= ~clk24576; \n reg [1:0] pop_s; \n wire [1:0] ack; \n wire [23:0] data [1:0]; \n synth l(.clk(clk24576), .rst(rst),.pop_i(pop_s[0]), .ack_o(ack[0]), .data_o(data[0])); \n synth r(.clk(clk24576), .rst(rst),.pop_i(pop_s[1]), .ack_o(ack[1]), .data_o(data[1])); \n wire [23:0] data_d = (sw[0] ? (data[0] | data[1]) : 0) | (sw[1] ? 24'h800000 : 0) | (sw[2] ? 24'h7fffff : 0); \n wire ack_d = |ack; \n reg lrck_d; \n wire pop_d; \n dac_drv d(.clk(clk24576), .rst(rst),.sck_o(sck_o), .bck_o(bck_o), .data_o(data_o), .lrck_o(lrck_o),.data_i(data_d), .lrck_i(lrck_d), .ack_i(ack_d), .pop_o(pop_d)); \n always @(posedge clk24576) begin \n  if(rst) begin \n  pop_s <= 2'b00; \n  lrck_d <= 0; \n  end else if(pop_d) begin \n  pop_s <= 2'b01; \n  lrck_d <= 0; \n  end else if(pop_s[0]) begin \n  pop_s <= 2'b10; \n  lrck_d <= 0; \n  end else begin \n  pop_s <= 2'b00; \n  lrck_d <= 1; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module SB_GB_IO defines a general purpose I/O interface with inputs and outputs for various signals such as package pin, global buffer output, latch input value, clock enables, input and output clocks, output enable, and data input/output. It instantiates the SB_IO module with specified parameters such as pin type, pullup, negative trigger, and I/O standard, and assigns the global buffer output to the package pin. The module essentially provides a configurable interface for connecting and controlling I/O signals in the design.\n\n Module header:\n\nmodule SB_GB_IO (inout PACKAGE_PIN,output GLOBAL_BUFFER_OUTPUT,input LATCH_INPUT_VALUE,input CLOCK_ENABLE,input INPUT_CLK,input OUTPUT_CLK,input OUTPUT_ENABLE,input D_OUT_0,input D_OUT_1,output D_IN_0,output D_IN_1);\n [/INST]\n", "output": "parameter [5:0] PIN_TYPE = 6'b000000; \n  parameter [0:0] PULLUP = 1'b0; \n  parameter [0:0] NEG_TRIGGER = 1'b0; \n  parameter IO_STANDARD = \"SB_LVCMOS\"; \n  assign GLOBAL_BUFFER_OUTPUT = PACKAGE_PIN; \n SB_IO #(.PIN_TYPE(PIN_TYPE),.PULLUP(PULLUP),.NEG_TRIGGER(NEG_TRIGGER),.IO_STANDARD(IO_STANDARD)) IO (.PACKAGE_PIN(PACKAGE_PIN),.LATCH_INPUT_VALUE(LATCH_INPUT_VALUE),.CLOCK_ENABLE(CLOCK_ENABLE),.INPUT_CLK(INPUT_CLK),.OUTPUT_CLK(OUTPUT_CLK),.OUTPUT_ENABLE(OUTPUT_ENABLE),.D_OUT_0(D_OUT_0),.D_OUT_1(D_OUT_1),.D_IN_0(D_IN_0),.D_IN_1(D_IN_1)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a lookup table for musical note durations. It takes a 4-bit input 'lookup' and outputs a 16-bit 'duration' based on the input. The module uses a parameter statement to define specific durations for musical notes. It then uses an assign statement with conditional operators to map the input to the corresponding musical note duration. If the input does not match any defined note duration, it assigns a default value UNDEF to the output.\n\n Module header:\n\nmodule duration_lut (input [3:0] lookup, output [15:0] duration);\n [/INST]\n", "output": "parameter \n  BREVE = 16'd48000, \n  SEMIBREVE = 16'd24000, \n  DOTTED_MINIM = 16'd18000, \n  MINIM = 16'd12000, \n  DOTTED_CROTCHET = 16'd9000, \n  CROTCHET = 16'd6000, \n  DOTTED_QUAVER = 16'd4500, \n  QUAVER = 16'd3000, \n  TUPLET = 16'd2000, \n  SEMIQUAVER = 16'd1500, \n  UNDEF = 16'd1000; \n  assign duration = (lookup == 4'd1) ? SEMIQUAVER : \n  (lookup == 4'd2) ? TUPLET : \n  (lookup == 4'd3) ? QUAVER : \n  (lookup == 4'd4) ? DOTTED_QUAVER : \n  (lookup == 4'd5) ? CROTCHET : \n  (lookup == 4'd6) ? DOTTED_CROTCHET : \n  (lookup == 4'd7) ? MINIM : \n  (lookup == 4'd8) ? DOTTED_MINIM : \n  (lookup == 4'd9) ? SEMIBREVE : \n  (lookup == 4'd10) ? BREVE : \n  UNDEF ; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `system_clk_wiz_1_0_clk_wiz` includes a clock generator implemented using the PLLE2_ADV primitive. The module has an input clock, `clk_in1`, and an output clock, `clk_out1`. The clock generator instantiates a PLL (Phase-Locked Loop) and configures its settings to provide a stable output clock signal. The `locked` output signal indicates when the PLL has achieved lock with the input clock. The module also includes several unused signals and buffers for internal clock connections.\n\n Module header:\n\nmodule system_clk_wiz_1_0_clk_wiz (output clk_out1,output locked,input clk_in1);\n [/INST]\n", "output": "wire clk_in1_system_clk_wiz_1_0; \n wire clk_in2_system_clk_wiz_1_0; \n  IBUF clkin1_ibufg \n (.O (clk_in1_system_clk_wiz_1_0),.I (clk_in1)); \n  wire clk_out1_system_clk_wiz_1_0; \n  wire clk_out2_system_clk_wiz_1_0; \n  wire clk_out3_system_clk_wiz_1_0; \n  wire clk_out4_system_clk_wiz_1_0; \n  wire clk_out5_system_clk_wiz_1_0; \n  wire clk_out6_system_clk_wiz_1_0; \n  wire clk_out7_system_clk_wiz_1_0; \n  wire [15:0] do_unused; \n  wire drdy_unused; \n  wire psdone_unused; \n  wire locked_int; \n  wire clkfbout_system_clk_wiz_1_0; \n  wire clkfbout_buf_system_clk_wiz_1_0; \n  wire clkfboutb_unused; \n  wire clkout1_unused; \n  wire clkout2_unused; \n  wire clkout3_unused; \n  wire clkout4_unused; \n  wire clkout5_unused; \n  wire clkout6_unused; \n  wire clkfbstopped_unused; \n  wire clkinstopped_unused; \n  PLLE2_ADV \n #(.BANDWIDTH (\"OPTIMIZED\"),.COMPENSATION (\"ZHOLD\"),.DIVCLK_DIVIDE (1),.CLKFBOUT_MULT (10),.CLKFBOUT_PHASE (0.000),.CLKOUT0_DIVIDE (5),.CLKOUT0_PHASE (0.000),.CLKOUT0_DUTY_CYCLE (0.500),.CLKIN1_PERIOD (10.0)) \n  plle2_adv_inst \n (.CLKFBOUT (clkfbout_system_clk_wiz_1_0),.CLKOUT0 (clk_out1_system_clk_wiz_1_0),.CLKOUT1 (clkout1_unused),.CLKOUT2 (clkout2_unused),.CLKOUT3 (clkout3_unused),.CLKOUT4 (clkout4_unused),.CLKOUT5 (clkout5_unused),.CLKFBIN (clkfbout_buf_system_clk_wiz_1_0),.CLKIN1 (clk_in1_system_clk_wiz_1_0),.CLKIN2 (1'b0),.CLKINSEL (1'b1),.DADDR (7'h0),.DCLK (1'b0),.DEN (1'b0),.DI (16'h0),.DO (do_unused),.DRDY (drdy_unused),.DWE (1'b0),.LOCKED (locked_int),.PWRDWN (1'b0),.RST (1'b0)); \n  assign locked = locked_int; \n  BUFG clkf_buf \n (.O (clkfbout_buf_system_clk_wiz_1_0),.I (clkfbout_system_clk_wiz_1_0)); \n  BUFG clkout1_buf \n (.O (clk_out1),.I (clk_out1_system_clk_wiz_1_0)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements an output state machine that controls the operation of a FIFO interface. The state machine has six states: IDLE, PROCESS_PACKET, PROCESS_LAST, END_OF_PACKET_1, END_OF_PACKET_2, and END_OF_PACKET_3. The module includes logic for transitioning between these states based on input signals and generating the appropriate outputs. It also manages the ready signal, FIFO read signal, and end-of-packet signal. Additionally, it utilizes hold-off logic to control the timing of the ready signal.\n\n Module header:\n\nmodule output_sm (input wire clk,input wire reset_b,input wire fifo_empty,output wire fifo_read,input wire [8:0] fifo_data,output wire ready,input wire read,output reg [7:0] port);\n [/INST]\n", "output": "parameter IDLE = 3'b000, \n  PROCESS_PACKET = 3'b001, \n  PROCESS_LAST = 3'b010, \n  END_OF_PACKET_1 = 3'b011, \n  END_OF_PACKET_2 = 3'b100, \n  END_OF_PACKET_3 = 3'b101; \n  reg [02:00] state, next_state; \n  reg [08:00] last_fifo_data; \n  reg [07:00] next_port; \n  reg hold_off_ready; \n  wire end_of_packet; \n  assign ready = (~fifo_empty && ~hold_off_ready) || (state == PROCESS_LAST); \n  assign fifo_read = (~fifo_empty & read & ((next_state == PROCESS_PACKET) | (next_state == PROCESS_LAST))); \n  assign end_of_packet = fifo_data[8]; \n  always @(posedge clk or negedge reset_b) \n  if (~reset_b) begin \n  state <= IDLE; \n  port <= 8'h0; \n  end \n  else begin \n  state <= next_state; \n  port <= next_port; \n  last_fifo_data <= fifo_data; \n  end \n  always @* \n  case(state) \n  IDLE: begin \n  hold_off_ready = 1'b0; \n  if (read && ~fifo_empty) begin \n  next_state = PROCESS_PACKET; \n  next_port = fifo_data[7:0]; \n  end \n  else begin \n  next_state = IDLE; \n  next_port = 8'h00; \n  end \n  end \n  PROCESS_PACKET: begin \n  hold_off_ready = 1'b0; \n  if (end_of_packet | fifo_empty) begin \n  next_state = PROCESS_LAST; \n  next_port = fifo_data[7:0]; \n  end \n  else begin \n  next_state = PROCESS_PACKET; \n  next_port = fifo_data[7:0]; \n  end \n  end \n  PROCESS_LAST: begin \n  hold_off_ready = 1'b1; \n  next_state = END_OF_PACKET_1; \n  next_port = 8'h00; \n  end \n  END_OF_PACKET_1: begin \n  hold_off_ready = 1'b1; \n  next_state = END_OF_PACKET_2; \n  next_port = 8'h00; \n  end \n  END_OF_PACKET_2: begin \n  hold_off_ready = 1'b1; \n  next_state = END_OF_PACKET_3; \n  next_port = 8'h00; \n  end \n  END_OF_PACKET_3: begin \n  hold_off_ready = 1'b1; \n  next_state = IDLE; \n  next_port = 8'h00; \n  end \n  default: begin \n  hold_off_ready = 1'b0; \n  next_state = IDLE; \n  next_port = 8'h00; \n  end \n  endcase \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a 32-bit sparse matrix multiplication. It takes input A and B, and on the positive clock edge, multiplies A and B, storing the result in a buffer. The result is then assigned to the output when the ce input is asserted.\n\n Module header:\n\nmodule sparse_mm_mul_31ns_32s_32_3_Mul3S_1(clk, ce, a, b, p);\n [/INST]\n", "output": "input clk; \n input ce; \n input[31 - 1 : 0] a; \n input[32 - 1 : 0] b; \n output[32 - 1 : 0] p; \n reg [31 - 1 : 0] a_reg0; \n reg signed [32 - 1 : 0] b_reg0; \n wire signed [32 - 1 : 0] tmp_product; \n reg signed [32 - 1 : 0] buff0; \n assign p = buff0; \n assign tmp_product = $signed({1'b0, a_reg0}) * b_reg0; \n always @ (posedge clk) begin \n  if (ce) begin \n  a_reg0 <= a; \n  b_reg0 <= b; \n  buff0 <= tmp_product; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, named ACA_II_N16_Q4, takes two 16-bit inputs in1 and in2, and produces a 17-bit output res. It splits the input bits into 4-bit groups, adds corresponding groups together, and then concatenates the resulting 4-bit sums in reverse order to form the output.\n\n Module header:\n\nmodule ACA_II_N16_Q4(input [15:0] in1,input [15:0] in2,output [16:0] res);\n [/INST]\n", "output": "wire [4:0] temp1,temp2,temp3,temp4,temp5,temp6,temp7; \n assign temp1[4:0] = in1[ 3: 0] + in2[ 3: 0]; \n assign temp2[4:0] = in1[ 5: 2] + in2[ 5: 2]; \n assign temp3[4:0] = in1[ 7: 4] + in2[ 7: 4]; \n assign temp4[4:0] = in1[ 9: 6] + in2[ 9: 6]; \n assign temp5[4:0] = in1[11: 8] + in2[11: 8]; \n assign temp6[4:0] = in1[13:10] + in2[13:10]; \n assign temp7[4:0] = in1[15:12] + in2[15:12]; \n assign res[16:0] = {temp7[4:2],temp6[3:2],temp5[3:2],temp4[3:2],temp3[3:2],temp2[3:2],temp1[3:0]}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an asynchronous RAM 1-port with request retry logic. It contains combinational logic for request retry and uses a flip-flop module for data storage. The RAM has input and output ports for clock, reset, request validity, request retry, write enable, request position, request data, acknowledge validity, acknowledge retry, and acknowledge data. The module instantiates an asynchronous RAM 1-port and a flip-flop module for data storage. The request retry logic is implemented in the always_comb block to set the req_retry output. The module operates with a specified data width, RAM size, and forward flag.\n\n Module header:\n\nmodule ram_1port_fast #(parameter Width = 64, Size=128, Forward=0)(input clk,input reset,input req_valid,output req_retry,input req_we,input [`log2(Size)-1:0] req_pos,input [Width-1:0] req_data,output ack_valid,input ack_retry,output [Width-1:0] ack_data);\n [/INST]\n", "output": "logic [Width-1:0] ack_data_next; \n  async_ram_1port \n  #(.Width(Width), .Size(Size)) \n ram (.p0_pos (req_pos),.p0_enable (req_valid & req_we),.p0_in_data (req_data),.p0_out_data (ack_data_next)); \n  logic req_retry_next; \n  always_comb begin \n  req_retry = req_retry_next & !req_we; \n  end \n fflop #(.Size(Width)) f1 (.clk (clk),.reset (reset),.din (ack_data_next),.dinValid (req_valid & ~req_we),.dinRetry (req_retry_next),.q (ack_data),.qValid (ack_valid),.qRetry (ack_retry)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a debounced button press. When the button is pressed, it sets an internal flag and starts a delay counter. Once the delay counter reaches a certain value, the LED is turned on. The flag is then reset, and the LED is turned off. The delay ensures that the button press is stable and not a transient glitch.\n\n Module header:\n\nmodule move(clk, rst, button, LED);\n [/INST]\n", "output": "input clk, rst, button; \n output LED; \n reg flagButton; \n reg LED; \n reg [24:0]delayButton; \n always@(posedge clk) \n begin \n  if(!rst) \n  begin \n  LED = 1'b0; \n  flagButton = 1'b0; \n  delayButton = 25'd0; \n  end \n  else \n  begin \n  if((!button)&&(!flagButton)) flagButton = 1'b1; \n  else if(flagButton) \n  begin \n  delayButton = delayButton + 1'b1; \n  if(delayButton == 25'b1000000000000000000000000) \n  begin \n  flagButton = 1'b0; \n  delayButton = 25'd0; \n  LED = 1'b1; \n  end \n  end \n  else LED = 1'b0; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a 5-bit D flip-flop. On the positive edge of the clock signal, the input d is assigned to the output q. The output q is a 5-bit register. If the RANDOM_INIT macro is defined, the q register is initialized with a random value.\n\n Module header:\n\nmodule dff_5 ( clk, d, q );\n [/INST]\n", "output": "input clk; \n  input [4:0] d; \n  output [4:0] q; \n  reg [4:0] q; \n `ifdef RANDOM_INIT \n  initial \n  $random_init(\"q\"); \n `endif \n  always @(posedge clk) begin \n  q <= d; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a 7-bit multiplexer, with 7 input signals (in0 through in6) and 7 select signals (sel0 through sel6). The module selects one of the inputs based on the select signals and assigns the selected input to the output signal 'out'. The design includes error handling for arbitration failure, which triggers an error message if more than one select signal is asserted at the same time after the initial time.\n\n Module header:\n\nmodule e16_mux7(out,in0, in1, in2, in3, in4, in5, in6, sel0, sel1, sel2, sel3, sel4,sel5, sel6);\n [/INST]\n", "output": "parameter DW=99; \n  input [DW-1:0] in0; \n  input [DW-1:0] in1; \n  input [DW-1:0] in2; \n  input [DW-1:0] in3; \n  input [DW-1:0] in4; \n  input [DW-1:0] in5; \n  input [DW-1:0] in6; \n  input sel0; \n  input sel1; \n  input sel2; \n  input sel3; \n  input sel4; \n  input sel5; \n  input sel6; \n  output [DW-1:0] out; \n assign out[DW-1:0] = ({(DW){sel0}} & in0[DW-1:0] |{(DW){sel1}} & in1[DW-1:0] |{(DW){sel2}} & in2[DW-1:0] |{(DW){sel3}} & in3[DW-1:0] |{(DW){sel4}} & in4[DW-1:0] |{(DW){sel5}} & in5[DW-1:0] |{(DW){sel6}} & in6[DW-1:0]); \n  always @* \n  if((sel0+sel1+sel2+sel3+sel4+sel5+sel6>1) & $time>0) \n  $display(\"ERROR>>Arbitration failure in cell %m\"); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `WPref_rev_Matrix` implements a memory lookup structure for a matrix of size MxKw, where each element is W bits wide. It calculates the logarithm of various parameters using a localparam, and performs bit manipulation operations to organize the input data `wPref_rev` into a matrix `wPref_rev_Matrix`. The module then performs memory lookups using the input addresses `raddr1` and `raddr2` to retrieve the corresponding data and assigns the values to the output `rdata1` and `rdata2` respectively.\n\n Module header:\n\nmodule WPref_rev_Matrix #(parameter Kw =8,parameter Km =8,parameter M =8,parameter W =8) (wPref_rev,raddr1,rdata1,raddr2,rdata2);\n [/INST]\n", "output": "function integer log2; \n  input [31:0] value; \n  reg [31:0] temp; \n  begin \n  temp = value - 1; \n  for (log2=0; temp>0; log2=log2+1) \n  temp = temp>>1; \n  end \n  endfunction \n  localparam logM = log2(M); \n  localparam logW = log2(W); \n  localparam logKm = log2(Km); \n  localparam logKw = log2(Kw); \n  input [M*logKw-1:0] wPref_rev; \n  input [logM-1:0] raddr1; \n  output [logKw-1:0] rdata1; \n  input [logM-1:0] raddr2; \n  output [logKw-1:0] rdata2; \n  wire [logKw-1:0] wPref_rev_Matrix [M-1:0]; \n  genvar j; \n  generate \n  for (j=0;j<Kw;j=j+1) begin : wPref_rev_asgn2 \n  assign wPref_rev_Matrix [j] = wPref_rev [logM*(j+1)-1:logM*j]; \n  end \n  endgenerate \n  assign rdata1 = wPref_rev_Matrix[raddr1]; \n  assign rdata2 = wPref_rev_Matrix[raddr2]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `v438230` has 4-bit inputs `v693354` and `v5369cd`, and a 4-bit output `v4642b6`. It consists of combinational logic blocks and simple combinational logic blocks to process the inputs and produce the output. The combinational logic involves wiring and logical operations between the inputs and internal wires. The module also utilizes instances of other modules like `v23b15b`, `vc4f23a`, and `veffd42` to perform these operations. The final output `v4642b6` is assigned to `w0` wire.\n\n Module header:\n\nmodule v438230 (input [3:0] v693354,input [3:0] v5369cd,output v4642b6);\n [/INST]\n", "output": "wire w0; \n  wire [0:3] w1; \n  wire [0:3] w2; \n  wire w3; \n  wire w4; \n  wire w5; \n  wire w6; \n  wire w7; \n  wire w8; \n  wire w9; \n  wire w10; \n  wire w11; \n  wire w12; \n  wire w13; \n  wire w14; \n  assign v4642b6 = w0; \n  assign w1 = v693354; \n  assign w2 = v5369cd; \n v23b15b v09a5a5 (.v4642b6(w3),.v27dec4(w12),.v6848e9(w14)); \n v23b15b vc1b29d (.v4642b6(w4),.v27dec4(w11),.v6848e9(w13)); \n v23b15b vcd27ce (.v4642b6(w5),.v27dec4(w9),.v6848e9(w10)); \n vc4f23a vea9c80 (.v985fcb(w1),.v4f1fd3(w7),.vda577d(w9),.v3f8943(w11),.v64d863(w12)); \n vc4f23a va7dcdc (.v985fcb(w2),.v4f1fd3(w8),.vda577d(w10),.v3f8943(w13),.v64d863(w14)); \n v23b15b va0849c (.v4642b6(w6),.v27dec4(w7),.v6848e9(w8)); \n veffd42 v6e3e65 (.vcbab45(w0),.v3ca442(w3),.v0e28cb(w4),.v033bf6(w5),.v9eb652(w6)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module `perspective_params_test` instantiates another module called `perspective_params`, connecting its inputs and outputs to registers and wires in the top module. The `clock` signal is toggled periodically, and the values of the output wires `o1` through `o9` are displayed whenever there is a positive edge of the clock signal. The initial values for the input registers `x1` through `x4` and `y1` through `y4` are also set in the initial block.\n\n Module header:\n\nmodule perspective_params_test;\n [/INST]\n", "output": "reg[9:0] x1; \n reg[9:0] x2; \n reg[9:0] x3; \n reg[9:0] x4; \n reg[8:0] y1; \n reg[8:0] y2; \n reg[8:0] y3; \n reg[8:0] y4; \n wire signed[67:0] o1; \n wire signed[68:0] o2; \n wire signed[78:0] o3; \n wire signed[67:0] o4; \n wire signed[68:0] o5; \n wire signed[78:0] o6; \n wire signed[58:0] o7; \n wire signed[59:0] o8; \n wire signed[70:0] o9; \n initial begin \n x1[9:0] = 10'd382; \n x2[9:0] = 10'd163; \n x3[9:0] = 10'd57; \n x4[9:0] = 10'd296; \n y1[8:0] = 9'd380; \n y2[8:0] = 9'd401; \n y3[8:0] = 9'd335; \n y4[8:0] = 9'd127; \n end \n reg clock = 0; \n perspective_params perspective_params(clock, x1, y1, x2, y2, x3, y3, x4, y4, o1, o2, o3, o4, o5, o6, o7, o8, o9); \n always #1 clock <= !clock; \n always @(posedge clock) begin \n  $display(\"%d, %d, %d, %d, %d, %d, %d, %d, %d\", o1, o2, o3, o4, o5, o6, o7, o8, o9); \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes an input signal 'a' and outputs its inverted value 'q' using the logical negation operator '~'.\n\n Module header:\n\nmodule v3676a0_vd54ca1 (input a,output q);\n [/INST]\n", "output": "assign q = ~a; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module serves as an output coupler for video data. It interfaces with a FIFO and performs clock domain crossing between the video output clock and the system clock. It includes logic for generating end-of-line (eol), start-of-frame (sof), and frame ID (fid) signals based on the video data. The module also handles the write enable signal, reset signal, and ready signal for the video data. It uses hysteresis to ensure stability during clock domain crossing and implements logic to calculate the remaining data bits for the video data. Additionally, the module resets various signals based on the system reset (rst) and asynchronous reset (aresetn), and incorporates an asynchronous FIFO bridge to facilitate the data transfer.\n\n Module header:\n\nmodule v_axi4s_vid_out_v3_0_out_coupler #(parameter DATA_WIDTH = 24,parameter RAM_ADDR_BITS = 10,parameter FILL_GUARDBAND = 2) (input wire video_out_clk,input wire rst ,input wire vid_ce,input wire fifo_rst,input aclk,input aclken,input aresetn,input wire [DATA_WIDTH +2:0] wr_data ,input valid ,output reg ready,output wire [DATA_WIDTH -1:0] rd_data,output wire eol,output wire sof,output wire fid,input wire rd_en,output wire [RAM_ADDR_BITS -1:0] level_wr,output wire [RAM_ADDR_BITS -1:0] level_rd,output wire wr_error,output wire rd_error ,output wire empty,input wire locked);\n [/INST]\n", "output": "reg [DATA_WIDTH +2:0] fifo_wr_data; \n  wire [DATA_WIDTH +2:0] fifo_dout; \n  reg locked_1; \n  reg locked_2; \n  wire hysteresis_met; \n  wire full; \n  reg wr_en; \n  wire reset; \n  wire [RAM_ADDR_BITS-1:0] remaining; \n  wire ready_comb; \n  assign reset = rst || !aresetn || fifo_rst; \n  v_axi4s_vid_out_v3_0_bridge_async_fifo_2 \n #(.RAM_WIDTH (DATA_WIDTH + 3),.RAM_ADDR_BITS (RAM_ADDR_BITS)) \n  bridge_async_fifo_2_i \n (.wr_clk (aclk),.rd_clk (video_out_clk),.rst (reset),.wr_ce (aclken ),.rd_ce (vid_ce ),.wr_en (wr_en ),.rd_en (rd_en ),.din (fifo_wr_data ),.dout (fifo_dout ),.empty (empty),.rd_error (rd_error),.full (full ),.wr_error (wr_error),.level_rd (level_rd),.level_wr (level_wr)); \n assign rd_data = fifo_dout[DATA_WIDTH-1:0]; \n assign eol = fifo_dout[DATA_WIDTH]; \n assign sof = fifo_dout[DATA_WIDTH+1]; \n assign fid = fifo_dout[DATA_WIDTH+2]; \n assign remaining = ~level_wr; \n assign ready_comb = !(full || (remaining <= FILL_GUARDBAND)); \n  always @ (posedge aclk ) begin \n  if (rst) begin \n  ready <= 0; \n  wr_en <= 0; \n  fifo_wr_data <= 0; \n  end \n  else begin \n  ready <= ready_comb; \n  if (aclken) begin \n  wr_en <= valid && ready; \n  fifo_wr_data<= wr_data; \n  end \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a dual-port RAM with synchronous write and asynchronous read functionality. It consists of two write enable signals, two input data signals, two output data signals, and a clock signal. It has two address counters for the two ports, and on every positive clock edge, the module either resets the address counters or increments and decrements them accordingly. When reset is active, the address counter is set to 0 for the first port and 15 for the second port. The write enable signals control the writing of the input data into the memory at the specified addresses, while the output data is asynchronously read from the memory based on the current address counters.\n\n Module header:\n\nmodule dpram(clock,wren1,wren2,reset_n,value_out,value_out2,value_in,value_in2);\n [/INST]\n", "output": "input clock; \n input reset_n; \n input wren1; \n input wren2; \n input [`WIDTH-1:0] value_in; \n input [`WIDTH-1:0] value_in2; \n output [`WIDTH-1:0] value_out; \n output [`WIDTH-1:0] value_out2; \n wire [`WIDTH-1:0] value_out; \n wire [`WIDTH-1:0] value_out2; \n reg [`DEPTH-1:0] address_counter; \n reg [`DEPTH-1:0] address_counter2; \n reg [`WIDTH-1:0] temp; \n reg [`WIDTH-1:0] temp2; \n dual_port_ram inst1(.we1(wren1),.we2(wren2),.clk(clock),.data1(value_in),.data2(value_in2),.out1(value_out),.out2(value_out2),.addr1(address_counter),.addr2(address_counter2)); \n always @(posedge clock) \n begin \n  if (reset_n == 1'b1) begin \n  address_counter <= 4'b0000; \n  address_counter2 <= 4'b1111; \n  end \n  else \n  begin \n  address_counter <= address_counter + 1; \n  address_counter2 <= address_counter2 - 1; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module initializes and manages two timers, A and B, based on the provided parameters. It triggers an interrupt signal, nIRQ, when an overflow occurs on either timer. The module utilizes the ym_timer module for each timer, setting the clock, tick, reset, load value, configuration, and control signals. The timers operate with different widths, mult_width for timer A and cnt_width for timer B, to accommodate various timing requirements.\n\n Module header:\n\nmodule ym_timers(input CLK,input TICK_144,input nRESET,input [9:0] YMTIMER_TA_LOAD,input [7:0] YMTIMER_TB_LOAD,input [5:0] YMTIMER_CONFIG,input clr_run_A, set_run_A, clr_run_B, set_run_B,output FLAG_A, FLAG_B,output nIRQ);\n [/INST]\n", "output": "assign nIRQ = ~((FLAG_A & YMTIMER_CONFIG[2]) | (FLAG_B & YMTIMER_CONFIG[3])); \n ym_timer #(.mult_width(1), .cnt_width(10)) timer_A (.CLK ( CLK ),.TICK_144 ( TICK_144 ),.nRESET ( nRESET ),.LOAD_VALUE ( YMTIMER_TA_LOAD ),.LOAD ( YMTIMER_CONFIG[0] ),.CLR_FLAG ( YMTIMER_CONFIG[4] ),.SET_RUN ( set_run_A ),.CLR_RUN ( clr_run_A ),.OVF_FLAG ( FLAG_A ),.OVF ( )); \n ym_timer #(.mult_width(4), .cnt_width(8)) timer_B (.CLK ( CLK ),.TICK_144 ( TICK_144 ),.nRESET ( nRESET ),.LOAD_VALUE ( YMTIMER_TB_LOAD ),.LOAD ( YMTIMER_CONFIG[1] ),.CLR_FLAG ( YMTIMER_CONFIG[5] ),.SET_RUN ( set_run_B ),.CLR_RUN ( clr_run_B ),.OVF_FLAG ( FLAG_B ),.OVF ( )); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a finite state machine to handle the execution flow of an instruction set. It transitions between states based on various input signals such as prefixes, the need for modrm, offset, immediate values, and the end of the instruction sequence. The module also considers interrupt and IFL signals, and outputs the next state based on the current state and the inputs.\n\n Module header:\n\nmodule nstate (input [2:0] state,input prefix,input need_modrm,input need_off,input need_imm,input end_seq,input [5:0] ftype,input of,input next_in_opco,input next_in_exec,input block,input div_exc,input intr,input ifl,output [2:0] next_state);\n [/INST]\n", "output": "parameter opcod_st = 3'h0; \n  parameter modrm_st = 3'h1; \n  parameter offse_st = 3'h2; \n  parameter immed_st = 3'h3; \n  parameter execu_st = 3'h4; \n  wire into, end_instr, end_into; \n  wire [2:0] n_state; \n  wire intr_ifl; \n  assign into = (ftype==6'b111_010); \n  assign end_into = into ? ~of : end_seq; \n  assign end_instr = !div_exc && !intr_ifl && end_into && !next_in_exec; \n  assign intr_ifl = intr & ifl; \n assign n_state = (state == opcod_st) ? (prefix ? opcod_st: (next_in_opco ? opcod_st: (need_modrm ? modrm_st: (need_off ? offse_st: (need_imm ? immed_st : execu_st))))) \n : (state == modrm_st) ? (need_off ? offse_st: (need_imm ? immed_st : execu_st)) \n  : (state == offse_st) ? (need_imm ? immed_st : execu_st) \n  : (state == immed_st) ? (execu_st) \n  : (end_instr ? opcod_st : execu_st); \n  assign next_state = block ? state : n_state; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module has two 32-bit input signals, a and b, and two 32-bit output signals, x and y. It also has an internal signal e. The module operates on the rising edge of the sysclock. Depending on the condition (y > x), x and y are updated differently. If the condition is true, x is incremented by 1, y is incremented by 2, a is updated based on the result of (x - y) with additional bit manipulation, and b is updated to the value of (y - x). If the condition is false, x is incremented by 1, y is updated by adding 4, a is updated to the result of (y - x), and b is updated to the result of (x - y).\n\n Module header:\n\nmodule Module1(input wire sysclock,output reg [31:0] x,output reg [31:0] y);\n [/INST]\n", "output": "reg [31:0] a; \n reg [31:0] b; \n wire e; \n IOB __IOB (sysclock, x, y[0], e); \n initial begin \n  a <= 32'd0; \n  b <= 32'd0; \n  x <= 32'd0; \n  y <= 32'd0; \n end \n always @ (posedge sysclock) begin \n  if (y > x) begin \n  x <= (x + 32'h1); \n  y <= (y + 32'h2); \n  a <= {16'd0,((((x - y))>>0)&16'hffff)}; \n  b <= (y - x); \n  end \n  else begin \n  x <= (x + 32'h1); \n  y <= (y + 32'h4); \n  a <= (y - x); \n  b <= (x - y); \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a CSR bridge with a state machine. It interfaces with the system clock and reset signals, handles CSR address and data, and manages read and write operations. The state machine transitions through IDLE, DELAYACK1, DELAYACK2, and ACK states to control the acknowledgement and write enable signals. The module also updates the wb_dat_o with csr_di and sets the next_csr_we based on the state transitions.\n\n Module header:\n\nmodule csrbrg(input sys_clk,input sys_rst,input [31:0] wb_adr_i,input [31:0] wb_dat_i,output reg [31:0] wb_dat_o,input wb_cyc_i,input wb_stb_i,input wb_we_i,output reg wb_ack_o,output reg [13:0] csr_a,output reg csr_we,output reg [31:0] csr_do,input [31:0] csr_di);\n [/INST]\n", "output": "always @(posedge sys_clk) begin \n  wb_dat_o <= csr_di; \n end \n reg next_csr_we; \n always @(posedge sys_clk) begin \n  csr_a <= wb_adr_i[15:2]; \n  csr_we <= next_csr_we; \n  csr_do <= wb_dat_i; \n end \n reg [1:0] state; \n reg [1:0] next_state; \n parameter IDLE = 2'd0; \n parameter DELAYACK1 = 2'd1; \n parameter DELAYACK2 = 2'd2; \n parameter ACK = 2'd3; \n always @(posedge sys_clk) begin \n  if(sys_rst) \n  state <= IDLE; \n  else \n  state <= next_state; \n end \n always @(*) begin \n  next_state = state; \n  wb_ack_o = 1'b0; \n  next_csr_we = 1'b0; \n  case(state) \n  IDLE: begin \n  if(wb_cyc_i & wb_stb_i) begin \n  next_csr_we = wb_we_i; \n  if(wb_we_i) \n  next_state = ACK; \n  else \n  next_state = DELAYACK1; \n  end \n  end \n  DELAYACK1: next_state = DELAYACK2; \n  DELAYACK2: next_state = ACK; \n  ACK: begin \n  wb_ack_o = 1'b1; \n  next_state = IDLE; \n  end \n  endcase \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a DCM (Digital Clock Manager) panel pair with multiple inputs and outputs. It has two instances of a sub-module called dcm_panel, each with its own set of inputs and outputs. The dcm_panel instances receive input signals from the module and produce output signals that are combined to generate the final outputs bank_hit, rd_data0, and rd_data1. The module also includes logic for resetting and updating internal registers based on the input clock signal. The dcm_panel instances interact with the inputs and the clock signal to perform specific operations, and the outputs are combined to produce the final results.\n\n Module header:\n\nmodule dcm_panel_pair(so, bank_hit, rd_data0, rd_data1,cam_en, inv_mask0, inv_mask1, rclk, rd_en, rst_l, rst_tri_en,rst_warm, rw_addr0, rw_addr1, sehold, wr_data0, wr_data1, wr_en,si, se);\n [/INST]\n", "output": "input [1:0] cam_en; \n input [7:0] inv_mask0; \n input [7:0] inv_mask1; \n input rclk; \n input [1:0] rd_en; \n input rst_l; \n input rst_tri_en; \n input rst_warm; \n input [5:0] rw_addr0; \n input [5:0] rw_addr1; \n input sehold; \n input [32:0] wr_data0; \n input [32:0] wr_data1; \n input [1:0] wr_en; \n input si,se ; \n output so; \n output [31:0] bank_hit; \n output [31:0] rd_data0; \n output [31:0] rd_data1; \n wire [31:0] lkup_hit0, lkup_hit1; \n reg rst_warm_d; \n always @(posedge rclk) \n begin \n  rst_warm_d <= ( sehold)? rst_warm_d : rst_warm; \n end \n dcm_panel panel0(.si(),.so(),.se(se),.lkup_hit(lkup_hit0[31:0]),.rd_data (rd_data0[31:0]),.rd_en (rd_en[0]),.wr_en (wr_en[0]),.cam_en (cam_en[0]),.wr_data (wr_data0[32:0]),.rw_addr (rw_addr0[5:0]),.inv_mask(inv_mask0[7:0]),.rst_l (rst_l),.rclk (rclk),.rst_warm(rst_warm_d),.rst_tri_en(rst_tri_en),.sehold (sehold)); \n  assign bank_hit = lkup_hit0 | lkup_hit1 ; \n dcm_panel panel1(.si(),.so(),.se(se),.lkup_hit(lkup_hit1[31:0]),.rd_data (rd_data1[31:0]),.rd_en (rd_en[1]),.wr_en (wr_en[1]),.cam_en (cam_en[1]),.wr_data (wr_data1[32:0]),.rw_addr (rw_addr1[5:0]),.inv_mask(inv_mask1[7:0]),.rst_l (rst_l),.rclk (rclk),.rst_warm(rst_warm_d),.rst_tri_en(rst_tri_en),.sehold (sehold)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a 4-bit jumper input module. It selects a 16-bit output based on the 2-bit input `rot`. The 16-bit outputs, j0, j1, j2, and j3 are assigned based on the value of `rot` using a case statement. If the value of `rot` does not match any of the specified cases, the output `block` defaults to j0.\n\n Module header:\n\nmodule J_sel(input[1:0] rot, output reg[0:15] block);\n [/INST]\n", "output": "wire[0:15] j0 = 16'b0100010011000000; \n wire[0:15] j1 = 16'b1000111000000000; \n wire[0:15] j2 = 16'b0110010001000000; \n wire[0:15] j3 = 16'b0000111000100000; \n always @* \n begin \n  case(rot) \n  0: block = j0; \n  1: block = j1; \n  2: block = j2; \n  3: block = j3; \n  default: block = j0; \n  endcase \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, `mbus_member_ctrl_testbench`, implements a control logic for multiple signals based on input and output ports. It includes logic for MBC isolating, resetting, and sleeping, as well as handling external interrupts and dynamic address updates. The module uses a combination of synchronous and combinatorial logic to control the signals based on specific conditions such as resets, sleep requests, bus activity, and address updates. The module also includes local signals and wires to handle various operations such as external interrupts and address updates.\n\n Module header:\n\nmodule mbus_member_ctrl_testbench (input RESETn,input CIN,input DIN,input COUT_FROM_BUS,input DOUT_FROM_BUS,output reg COUT,output reg DOUT,input SLEEP_REQ,input WAKEUP_REQ,output reg MBC_ISOLATE,output MBC_ISOLATE_B,output reg MBC_RESET,output MBC_RESET_B,output reg MBC_SLEEP,output MBC_SLEEP_B,input CLR_EXT_INT,output reg EXTERNAL_INT,input ADDR_WR_EN,input ADDR_CLR_B,input [`MBUSTB_DYNA_WIDTH-1:0] ADDR_IN,output reg [`MBUSTB_DYNA_WIDTH-1:0] ADDR_OUT,output reg ADDR_VALID,input LRC_SLEEP,input MBUS_BUSY);\n [/INST]\n", "output": "wire next_mbc_isolate; \n  wire sleep_req_isol; \n  reg goingsleep; \n  assign MBC_SLEEP_B = ~MBC_SLEEP; \n  assign MBC_ISOLATE_B = ~MBC_ISOLATE; \n  assign MBC_RESET_B = ~MBC_RESET; \n  assign next_mbc_isolate = goingsleep | sleep_req_isol | MBC_SLEEP; \n  assign sleep_req_isol = SLEEP_REQ & MBC_ISOLATE_B; \n  always @ (posedge CIN or negedge RESETn) begin \n  if (~RESETn) begin \n  goingsleep <= `MBUSTB_SD 1'b0; \n  MBC_SLEEP <= `MBUSTB_SD 1'b1; \n  MBC_ISOLATE <= `MBUSTB_SD 1'b1; \n  end \n  else begin \n  goingsleep <= `SD sleep_req_isol; \n  MBC_SLEEP <= `MBUSTB_SD goingsleep; \n  MBC_ISOLATE <= `MBUSTB_SD next_mbc_isolate; \n  end \n  end \n  always @ (negedge CIN or negedge RESETn) begin \n  if (~RESETn) MBC_RESET <= `MBUSTB_SD 1'b1; \n  else MBC_RESET <= `MBUSTB_SD MBC_ISOLATE; \n  end \n  wire clr_ext_int_b = ~(MBC_ISOLATE_B & CLR_EXT_INT); \n  wire RESETn_local = RESETn & CIN; \n  wire RESETn_local2 = RESETn & clr_ext_int_b; \n  wire mbus_busy_b_isol = ~(MBUS_BUSY & MBC_RESET_B); \n  wire int_busy = (WAKEUP_REQ & mbus_busy_b_isol & LRC_SLEEP); \n  reg ext_int_dout; \n  always @ (posedge int_busy or negedge RESETn_local) begin \n  if (~RESETn_local) ext_int_dout <= `MBUSTB_SD 0; \n  else ext_int_dout <= `MBUSTB_SD 1; \n  end \n  always @ (posedge int_busy or negedge RESETn_local2) begin \n  if (~RESETn_local2) EXTERNAL_INT <= `MBUSTB_SD 0; \n  else EXTERNAL_INT <= `MBUSTB_SD 1; \n  end \n always @* begin \n  if (~RESETn) COUT <= `MBUSTB_SD 1'b1; \n  else if (MBC_ISOLATE) COUT <= `MBUSTB_SD CIN; \n  else COUT <= `MBUSTB_SD COUT_FROM_BUS; \n  if (~RESETn) DOUT <= `MBUSTB_SD 1'b1; \n  else if (ext_int_dout) DOUT <= `MBUSTB_SD 0; \n  else if (MBC_ISOLATE) DOUT <= `MBUSTB_SD DIN; \n  else DOUT <= `MBUSTB_SD DOUT_FROM_BUS; \n end \n wire RESETn_local3 = (RESETn & ADDR_CLR_B); \n wire addr_update = (ADDR_WR_EN & (~MBC_ISOLATE)); \n always @ (posedge addr_update or negedge RESETn_local3) begin \n  if (~RESETn_local3) begin \n  ADDR_OUT <= `MBUSTB_SD {`MBUSTB_DYNA_WIDTH{1'b1}}; \n  ADDR_VALID <= `MBUSTB_SD 0; \n  end \n  else begin \n  ADDR_OUT <= `MBUSTB_SD ADDR_IN; \n  ADDR_VALID <= `MBUSTB_SD 1; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, named \"inputconditioner\", takes in a clock signal (clk) and a noisy input signal (noisysignal). It includes outputs for the conditioned signal (conditioned), positive edge detection (positiveedge), and negative edge detection (negativeedge). The module employs a counter to condition the input signal, based on certain criteria.\n\nThe module uses a counter to delay the conditioning of the signal. When the counter reaches a specified wait time, the module switches the conditioned signal to the value of the sync1 signal. If sync1 is equal to 1, it sets the positiveedge signal, and if sync1 is equal to 0, it sets the negativeedge signal. The sync1 signal is set to the previous value of the sync0 signal, which in turn is set to the current value of the noisy input signal.\n\nIn summary, the module conditions the input signal based on the previous and current values of the noisy input signal, using a counter to determine when the conditioning should occur, and detecting positive and negative edges based on the conditioned signal.\n\n Module header:\n\nmodule inputconditioner(clk, noisysignal, conditioned, positiveedge, negativeedge);\n [/INST]\n", "output": "output reg conditioned = 0; \n output reg positiveedge = 0; \n output reg negativeedge = 0; \n input clk, noisysignal; \n parameter counterwidth = 5; \n parameter waittime = 10; \n reg[counterwidth-1:0] counter = 0; \n reg sync0 = 0; \n reg sync1 = 0; \n always @(posedge clk) begin \n  if (conditioned == sync1) begin \n  counter <= 0; \n  positiveedge <= 0; \n  negativeedge <= 0; \n  end else begin \n  if (counter == waittime) begin \n  counter <= 0; \n  conditioned <= sync1; \n  if (sync1 == 1) begin \n  positiveedge <= 1; \n  end else begin \n  negativeedge <= 1; \n  end \n  end else begin \n  counter <= counter + 1; \n  end \n  end \n  sync1 = sync0; \n  sync0 = noisysignal; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a delay circuit that waits for 550ns before setting the output signal p. It uses a 5-bit register r to count the number of clock cycles, and it resets r to 0 when the reset signal is asserted. When the input signal in is high, it resets r to 1. The output p is set high when the value of r equals 27.\n\n Module header:\n\nmodule dly550ns(input clk, input reset, input in, output p);\n [/INST]\n", "output": "reg [5-1:0] r; \n  always @(posedge clk or posedge reset) begin \n  if(reset) \n  r <= 0; \n  else begin \n  if(r) \n  r <= r + 5'b1; \n  if(in) \n  r <= 1; \n  end \n  end \n  assign p = r == 27; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a NAND8 reducer, which reduces the eight input signals to a single output using a combination of NAND gates. The module consists of several synthesized wires that represent intermediate logic signals. The input signals are combined using logical OR and AND operations, and the output is the result of the final NAND operation on the synthesized wires.\n\n Module header:\n\nmodule NAND8_reducer(InY,Reduced_NAND);\n [/INST]\n", "output": "input wire [7:0] InY; \n output wire Reduced_NAND; \n wire SYNTHESIZED_WIRE_0; \n wire SYNTHESIZED_WIRE_1; \n wire SYNTHESIZED_WIRE_2; \n wire SYNTHESIZED_WIRE_3; \n wire SYNTHESIZED_WIRE_4; \n wire SYNTHESIZED_WIRE_5; \n wire SYNTHESIZED_WIRE_6; \n assign SYNTHESIZED_WIRE_5 = ~(InY[4] | InY[5]); \n assign SYNTHESIZED_WIRE_4 = ~(InY[2] | InY[3]); \n assign SYNTHESIZED_WIRE_2 = ~InY[7]; \n assign SYNTHESIZED_WIRE_3 = ~(InY[0] | InY[1]); \n assign Reduced_NAND = ~(SYNTHESIZED_WIRE_0 | SYNTHESIZED_WIRE_1); \n assign SYNTHESIZED_WIRE_6 = ~(InY[6] | SYNTHESIZED_WIRE_2); \n assign SYNTHESIZED_WIRE_0 = ~(SYNTHESIZED_WIRE_3 & SYNTHESIZED_WIRE_4); \n assign SYNTHESIZED_WIRE_1 = ~(SYNTHESIZED_WIRE_5 & SYNTHESIZED_WIRE_6); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a 2-to-1 multiplexer that selects between two 32-bit input signals (in0 and in1) based on the value of the sel input. When sel is 0, the module outputs in0, and when sel is 1, the module outputs in1. The output is stored in a 32-bit register named out.\n\n Module header:\n\nmodule mux32_2to1(out, in0, in1, sel);\n [/INST]\n", "output": "output reg [31:0] out; \n  input [31:0] in0; \n  input [31:0] in1; \n  input sel; \n  always @(sel) \n  begin \n  case (sel) \n  1'b0: out = in0; \n  1'b1: out = in1; \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements an AXI stream GPIO interface. It includes state machines to manage control signals like ap_done, ap_idle, and ap_ready. The module also has logic to handle state transitions and assignments based on input signals and the current state of the state machine. The module assigns the output ap_return to a constant value and utilizes a process to handle the reset signal. Additionally, the module assigns outputData_TREADY to a constant logic 0.\n\n Module header:\n\nmodule axi_stream_gpio (ap_clk,ap_rst_n,ap_start,ap_done,ap_idle,ap_ready,inputData_V,inputData_V_ap_vld,outputData_TDATA,outputData_TVALID,outputData_TREADY,ap_return);\n [/INST]\n", "output": "parameter ap_const_logic_1 = 1'b1; \n parameter ap_const_logic_0 = 1'b0; \n parameter ap_ST_st1_fsm_0 = 1'b1; \n parameter ap_const_lv32_0 = 32'b00000000000000000000000000000000; \n parameter ap_const_lv1_1 = 1'b1; \n parameter ap_true = 1'b1; \n input ap_clk; \n input ap_rst_n; \n input ap_start; \n output ap_done; \n output ap_idle; \n output ap_ready; \n input [0:0] inputData_V; \n input inputData_V_ap_vld; \n input [31:0] outputData_TDATA; \n input outputData_TVALID; \n output outputData_TREADY; \n output [31:0] ap_return; \n reg ap_done; \n reg ap_idle; \n reg ap_ready; \n reg ap_rst_n_inv; \n (* fsm_encoding = \"none\" *) reg [0:0] ap_CS_fsm = 1'b1; \n reg ap_sig_cseq_ST_st1_fsm_0; \n reg ap_sig_bdd_19; \n reg [0:0] ap_NS_fsm; \n always @ (posedge ap_clk) \n begin : ap_ret_ap_CS_fsm \n  if (ap_rst_n_inv == 1'b1) begin \n  ap_CS_fsm <= ap_ST_st1_fsm_0; \n  end else begin \n  ap_CS_fsm <= ap_NS_fsm; \n  end \n end \n always @ (ap_start or ap_sig_cseq_ST_st1_fsm_0) \n begin \n  if (((ap_const_logic_1 == ap_sig_cseq_ST_st1_fsm_0) & ~(ap_start == ap_const_logic_0))) begin \n  ap_done = ap_const_logic_1; \n  end else begin \n  ap_done = ap_const_logic_0; \n  end \n end \n always @ (ap_start or ap_sig_cseq_ST_st1_fsm_0) \n begin \n  if ((~(ap_const_logic_1 == ap_start) & (ap_const_logic_1 == ap_sig_cseq_ST_st1_fsm_0))) begin \n  ap_idle = ap_const_logic_1; \n  end else begin \n  ap_idle = ap_const_logic_0; \n  end \n end \n always @ (ap_start or ap_sig_cseq_ST_st1_fsm_0) \n begin \n  if (((ap_const_logic_1 == ap_sig_cseq_ST_st1_fsm_0) & ~(ap_start == ap_const_logic_0))) begin \n  ap_ready = ap_const_logic_1; \n  end else begin \n  ap_ready = ap_const_logic_0; \n  end \n end \n always @ (ap_sig_bdd_19) \n begin \n  if (ap_sig_bdd_19) begin \n  ap_sig_cseq_ST_st1_fsm_0 = ap_const_logic_1; \n  end else begin \n  ap_sig_cseq_ST_st1_fsm_0 = ap_const_logic_0; \n  end \n end \n always @ (ap_start or ap_CS_fsm) \n begin \n  case (ap_CS_fsm) \n  ap_ST_st1_fsm_0 : \n  begin \n  ap_NS_fsm = ap_ST_st1_fsm_0; \n  end \n  default : \n  begin \n  ap_NS_fsm = 'bx; \n  end \n  endcase \n end \n assign ap_return = ap_const_lv32_0; \n always @ (ap_rst_n) \n begin \n  ap_rst_n_inv = ~ap_rst_n; \n end \n always @ (ap_CS_fsm) \n begin \n  ap_sig_bdd_19 = (ap_CS_fsm[ap_const_lv32_0] == ap_const_lv1_1); \n end \n assign outputData_TREADY = ap_const_logic_0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes in five 16-bit input signals and produces various outputs based on the arrangement of the input bits. It assigns specific bits of the input signals to different output ports, effectively breaking down the input signals into smaller components and routing them to different destinations. For instance, it assigns specific bits of OS2 to literalV, op1, aSel2, bSel2, and cSel2, and similarly for the other input signals. Overall, the module performs bit manipulation and routing based on the input signals.\n\n Module header:\n\nmodule pipeBreakU(OS1,OS2,OS3,OS4,OS5,op1,op2,op3,op4,op5,aSel2,aSel3,aSel4,bSel2,bSel3,bSel4,cSel2,cSel3,cSel4,literalV);\n [/INST]\n", "output": "input [15:0] OS1; \n input [15:0] OS2; \n input [15:0] OS3; \n input [15:0] OS4; \n input [15:0] OS5; \n output [6:0] op1; \n output [6:0] op2; \n output [6:0] op3; \n output [6:0] op4; \n output [6:0] op5; \n output [2:0] aSel2; \n output [2:0] aSel3; \n output [2:0] aSel4; \n output [2:0] bSel2; \n output [2:0] bSel3; \n output [2:0] bSel4; \n output [2:0] cSel2; \n output [2:0] cSel3; \n output [2:0] cSel4; \n output [14:0] literalV; \n assign literalV=OS2[14:0]; \n assign op1=OS1[15:9]; \n assign op2=OS2[15:9]; \n assign op3=OS3[15:9]; \n assign op4=OS4[15:9]; \n assign op5=OS5[15:9]; \n assign aSel2=OS2[8:6]; \n assign aSel3=OS3[8:6]; \n assign aSel4=OS4[8:6]; \n assign bSel2=OS2[5:3]; \n assign bSel3=OS3[5:3]; \n assign bSel4=OS4[5:3]; \n assign cSel2=OS2[2:0]; \n assign cSel3=OS3[2:0]; \n assign cSel4=OS4[2:0]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module extracts the lower 9 bits from a 18-bit input vector and assigns them to an output vector. It uses a MATLAB function to perform the bit extraction. The module declares an input vector In1 and an output vector Out1. Inside the module, it defines a wire for the output of the MATLAB function and then calls the MATLAB function to extract the lower 8 bits of the input vector. Finally, it assigns the output of the MATLAB function to the output vector Out1.\n\n Module header:\n\nmodule velocityControlHdl_Mark_Extract_Bits1 (In1,Out1);\n [/INST]\n", "output": "input [17:0] In1; \n  output [8:0] Out1; \n  wire [8:0] MATLAB_Function_out1; \n velocityControlHdl_MATLAB_Function_block u_MATLAB_Function (.u(In1),.y(MATLAB_Function_out1)); \n  assign Out1 = MATLAB_Function_out1; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module consists of input registers en and clk, a 4-bit data register data, and output wires rout and lout. It utilizes a D flip-flop and a D latch to store data and uses clock signals to increment the data and update the outputs. The module initializes the flip-flop with a reset and then toggles the clock and enable signals to control the behavior of the registers and update the output.\n\n Module header:\n\nmodule RegLatchTest;\n [/INST]\n", "output": "reg en, clk; \n  reg [3:0] data; \n  wire [3:0] rout; \n  wire [3:0] lout; \n  CC_DFlipFlop #(4) register(clk, en, data, rout); \n  CC_DLatch #(4) latch(en, data, lout); \n  initial begin \n  en = 0; \n  data = 'b0; \n  clk = 0; \n  end \n  always \n  #1 clk = ~clk; \n  always \n  #4 en = ~en; \n  always \n  #2 data = data + 1; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a 5-bit non-registered asynchronous register with inputs clk_i, hold_i, rst_i, and a 5-bit input in, and an output out. It has an initialization block that sets out to 0, and an always block that triggers on the positive edge of clk_i. When rst_i is asserted, out is set to 0. If hold_i is asserted, out remains unchanged. Otherwise, out is set to the value of the input in.\n\n Module header:\n\nmodule nr_reg_n(input clk_i,input hold_i,input rst_i,input wire [4:0] in,output reg [4:0] out);\n [/INST]\n", "output": "initial begin \n  out <= 5'h0; \n  end \n  always @(posedge clk_i) begin \n  if (rst_i) \n  out <= #1 5'h0; \n  else if (hold_i) \n  out <= #1 out; \n  else \n  out <= #1 in; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a word selector for the RIPEMD160 algorithm. It takes a 7-bit input rx_round and generates two 4-bit outputs tx_s0 and tx_s1. The module uses two predefined 320-bit sequences, first_sequence and second_sequence. On each rising edge of the clock, the module shifts the first_sequence and second_sequence to the right by the value of rx_round concatenated with 2'b00 and assigns the results to tx_s0 and tx_s1 respectively.\n\n Module header:\n\nmodule ripemd160_word_sel (input clk,input [6:0] rx_round,output reg [3:0] tx_s0,output reg [3:0] tx_s1);\n [/INST]\n", "output": "localparam [319:0] first_sequence = {4'd13,4'd15,4'd6,4'd11,4'd8,4'd3,4'd1,4'd14,4'd10,4'd2,4'd12,4'd7,4'd9,4'd5,4'd0,4'd4,4'd2,4'd6,4'd5,4'd14,4'd15,4'd7,4'd3,4'd13,4'd4,4'd12,4'd8,4'd0,4'd10,4'd11,4'd9,4'd1,4'd12,4'd5,4'd11,4'd13,4'd6,4'd0,4'd7,4'd2,4'd1,4'd8,4'd15,4'd9,4'd4,4'd14,4'd10,4'd3,4'd8,4'd11,4'd14,4'd2,4'd5,4'd9,4'd0,4'd12,4'd3,4'd15,4'd6,4'd10,4'd1,4'd13,4'd4,4'd7,4'd15,4'd14,4'd13,4'd12,4'd11,4'd10,4'd9,4'd8,4'd7,4'd6,4'd5,4'd4,4'd3,4'd2,4'd1,4'd0}; \n  localparam [319:0] second_sequence = {4'd11,4'd9,4'd3,4'd0,4'd14,4'd13,4'd2,4'd6,4'd7,4'd8,4'd5,4'd1,4'd4,4'd10,4'd15,4'd12,4'd14,4'd10,4'd7,4'd9,4'd13,4'd2,4'd12,4'd5,4'd0,4'd15,4'd11,4'd3,4'd1,4'd4,4'd6,4'd8,4'd13,4'd4,4'd0,4'd10,4'd2,4'd12,4'd8,4'd11,4'd9,4'd6,4'd14,4'd7,4'd3,4'd1,4'd5,4'd15,4'd2,4'd1,4'd9,4'd4,4'd12,4'd8,4'd15,4'd14,4'd10,4'd5,4'd13,4'd0,4'd7,4'd3,4'd11,4'd6,4'd12,4'd3,4'd10,4'd1,4'd8,4'd15,4'd6,4'd13,4'd4,4'd11,4'd2,4'd9,4'd0,4'd7,4'd14,4'd5}; \n  always @ (posedge clk) \n  begin \n  tx_s0 <= first_sequence >> {rx_round, 2'b00}; \n  tx_s1 <= second_sequence >> {rx_round, 2'b00}; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `ramcard` simulates the functionality of a RAM card. It takes clock input `mclk28`, reset input `reset_in`, address input `addr`, write enable input `we`, and provides outputs for RAM address `ram_addr`, write control `card_ram_we`, read control `card_ram_rd`, and bank signal `bank1`. The module contains logic to handle different memory operations based on the input address and control signals, and it updates internal states and signals accordingly on the rising edge of the clock signal. The module also includes the necessary logic to derive the RAM address based on the input signals.\n\n Module header:\n\nmodule ramcard(mclk28,reset_in,addr,ram_addr, we, card_ram_we,card_ram_rd, bank1);\n [/INST]\n", "output": "input mclk28; \n  input reset_in; \n  input [15:0] addr; \n  output [17:0] ram_addr; \n  input we; \n  output card_ram_we; \n  output card_ram_rd; \n  output bank1; \n  reg bank1, read_en, write_en, pre_wr_en, bankB, sat_read_en, sat_write_en, sat_pre_wr_en, sat_en; \n  reg [2:0] bank16k; \n  reg [15:0] addr2; \n  wire Dxxx,DEF; \n  always @(posedge mclk28) begin \n  addr2 <= addr; \n  if(reset_in) begin \n  bank1 <= 0; \n  read_en <= 0; \n  write_en <= 1; \n  pre_wr_en <= 0; \n  bankB <= 0; \n  sat_read_en <= 0; \n  sat_write_en <= 0; \n  sat_pre_wr_en <= 0; \n  end \n  else \n  begin \n  if((addr[15:4] == 'hC08) & (addr2 != addr)) begin \n  bank1 <= addr[3]; \n  pre_wr_en <= addr[0] & ~we; \n  write_en <= addr[0] & pre_wr_en & ~we; \n  read_en <= ~(addr[0] ^ addr[1]); \n  end \n  if((addr[15:4] == 'hC0D) & (addr2 != addr)) begin \n  if(addr[2] == 0) begin \n  bankB <= addr[3]; \n  sat_pre_wr_en <= addr[0]; \n  sat_write_en <= addr[0] & sat_pre_wr_en; \n  sat_read_en <= ~(addr[0] ^ addr[1]); \n  end \n  else \n  begin \n  bank16k <= {addr[3], addr[1], addr[0]}; \n  end \n  end \n  end \n  end \n  assign Dxxx = (addr[15:12] == 4'b1101); \n  assign DEF = ((addr[15:14] == 2'b11) & (addr[13:12] != 2'b00)); \n  assign ram_addr = ((sat_write_en || sat_read_en) && DEF)?{1'b1, bank16k, addr[13], addr[12] & ~(bankB & Dxxx), addr[11:0]}:{2'b0,addr[15:13], addr[12] & ~(bank1 & Dxxx), addr[11:0]}; \n  assign card_ram_we = (write_en | sat_write_en); \n  assign card_ram_rd = (read_en | sat_read_en); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a 51-bit delay by storing the input datain in a register triggered by the positive edge of the clk input. The stored data is then assigned to the dataout, effectively delaying the input by one clock cycle.\n\n Module header:\n\nmodule delay51x1 (datain, dataout, clk);\n [/INST]\n", "output": "input[51 - 1:0] datain; \n  output[51 - 1:0] dataout; \n  wire[51 - 1:0] dataout; \n  input clk; \n  reg[51 - 1:0] buff0; \n  assign dataout = buff0 ; \n  always @(posedge clk) \n  begin \n  buff0 <= datain ; \n  end \n  endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a read-only memory (ROM) with 256 locations, each storing a 32-bit word. The ROM is initialized with data from the file \"test2.asm.hex\" using the $readmemh task. On the positive edge of the clock signal, the module outputs the data stored at the specified address. If the write enable signal (we) is asserted, the module writes the input data (wdata) to the specified address in the ROM.\n\n Module header:\n\nmodule rom(input clk,input re,input we,input [29:0] addr,output reg [31:0] rdata,input [31:0] wdata);\n [/INST]\n", "output": "reg [31:0] rom [0:255]; \n initial begin \n  $readmemh(\"../test2.asm.hex\", rom); \n end \n always @(posedge clk) begin \n  rdata <= rom[addr]; \n  if (we) \n  rom[addr] <= wdata; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"HeaderRam\" is a synchronous RAM that supports read and write operations. It includes input ports for data (d), write address (waddr), read address (raddr), write enable (we), and clock (clk), as well as an output port for the data read from the RAM (q).\n\nThe module initializes the memory contents using the \"header.hex\" file and assigns the output q to the memory contents at the read address. On the positive edge of the clock, it checks for the write enable signal and updates the memory address and read address accordingly. This enables the module to perform read and write operations based on the specified addresses and control signals.\n\n Module header:\n\nmodule HeaderRam(d, waddr, raddr, we, clk, q);\n [/INST]\n", "output": "output [7:0] q; \n input [7:0] d; \n input[9:0] raddr; \n input[9:0] waddr; \n input clk, we; \n reg [9:0] read_addr; \n reg[7:0] mem [1023:0] ; \n initial $readmemh(\"header.hex\", mem); \n assign q = mem[read_addr]; \n always @(posedge clk) begin \n if (we) \n mem[waddr] <= d; \n read_addr <= raddr; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a VGA controller that generates video signals based on the input clock and data. It includes a palette, color mode selection, and state machine for video signal generation. The module also handles data requests, interrupts, and data storage. The VGA controller outputs horizontal and vertical sync signals, video output, and RGB values based on the input data and color mode. Additionally, it includes counters for horizontal and vertical synchronization and updates the palette based on the input data. The state machine transitions between different states to control the video signal generation process and data handling.\n\n Module header:\n\nmodule b2m_video(input clk50,output reg hr,output reg vr,output reg vid_irq,output reg[3:0] r,output reg[3:0] g,output reg[3:0] b,output reg drq,output reg[13:0] addr,input[15:0] idata,input[1:0] pal_idx,input[7:0] pal_data,input pal_we_n,input color_mode,input mode);\n [/INST]\n", "output": "reg[7:0] palette[0:3]; \n reg[7:0] pclr; \n reg vout; \n always @(*) \n  casex ({vout,color_mode}) \n  2'b0x: {r,g,b} = {4'b0000,4'b0000,4'b0000}; \n  2'b10: {r,g,b} = {{2{pclr[1:0]}},{2{pclr[1:0]}},{2{pclr[1:0]}}}; \n  2'b11: {r,g,b} = {{2{pclr[3:2]}},{2{pclr[5:4]}},{2{pclr[7:6]}}}; \n  endcase \n always @(*) begin \n  pclr = ~palette[{data0[8],data0[0]}]; \n  hr = h_cnt0 >= 10'd420 && h_cnt0 < 10'd480 ? 1'b0 : 1'b1; \n  vr = v_cnt0 >= 10'd565 && v_cnt0 < 10'd571 ? 1'b0 : 1'b1; \n  vout = h_cnt0 >= 10'd5 && h_cnt0 < 10'd389 && v_cnt0 < 10'd512; \n  addr = {h_cnt0[8:3], v_cnt0[8:1]}; \n  drq = h_cnt0[8:7] < 2'b11 && v_cnt0[9]==0 && h_cnt0[2]==0 && state!=0; \n  vid_irq = ~v_cnt0[9]; \n  end \n reg[1:0] state; \n reg[9:0] h_cnt0; \n reg[9:0] v_cnt0; \n reg[15:0] data0; \n reg[9:0] h_cnt1; \n reg[9:0] v_cnt1; \n reg[15:0] data1; \n reg[13:0] addr1; \n reg drq1; \n reg irq1; \n always @(posedge clk50) \n begin \n  casex (state) \n  2'b00: state <= 2'b01; \n  2'b01: state <= 2'b10; \n  2'b1x: state <= 2'b00; \n  endcase \n  if (state==2'b00) begin \n  if (h_cnt0[2:0]==3'b100 && h_cnt0[8:3]<6'h30) data0 <= idata; else data0 <= {1'b0,data0[15:1]}; \n  if (h_cnt0+1'b1 == 10'd532) begin \n  h_cnt0 <= 0; \n  if (v_cnt0+1'b1 == 10'd624 ) \n  v_cnt0 <= 0; \n  else \n  v_cnt0 <= v_cnt0+1'b1; \n  end else \n  h_cnt0 <= h_cnt0+1'b1; \n  end \n  if (!pal_we_n) palette[pal_idx] <= pal_data; \n  addr1 <= {h_cnt1[8:3], v_cnt1[8:1]}; \n  drq1 <= h_cnt1[8:7] < 2'b11 && v_cnt1[9]==0 && h_cnt1[2]==0; \n  irq1 <= ~v_cnt1[9]; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a serializer that takes in a data_in signal of width DWIDTH and outputs a single bit at a time in a sequential manner on the data_out signal. It has a curr_bit register that increments on the positive edge of the fast_clk signal. When curr_bit reaches DWIDTH-1, it is reset to 0, and the next bit from the data_in signal is output on data_out. The module also has a res_n signal for reset, and it resets curr_bit to 0 when res_n is low.\n\n Module header:\n\nmodule serializer #(parameter DWIDTH=64) (input wire clk,input wire fast_clk,input wire res_n,input wire [DWIDTH-1:0] data_in,output wire data_out);\n [/INST]\n", "output": "reg [7:0] curr_bit = 'h0; \n always @ (posedge fast_clk) \n begin \n  if(!res_n) begin \n  curr_bit <= 0; \n  end else begin \n  if(curr_bit == DWIDTH-1) \n  curr_bit <= 0; \n  else \n  curr_bit <= curr_bit + 1; \n  end \n end \n assign data_out = data_in[curr_bit]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, `cf_fir_24_16_16_22`, implements a Finite Impulse Response (FIR) filter. It has multiple inputs and outputs, and contains internal registers and wires to process the input data. The module performs multiplication and addition operations to implement the FIR filter. It instantiates another module `cf_fir_24_16_16_23` to perform the filter operation. The outputs `o1` to `o8` provide the filtered results of the input data. The module operates on a clock signal `clock_c` and uses internal logic to manipulate the input data and produce the filtered output.\n\n Module header:\n\nmodule cf_fir_24_16_16_22 (clock_c, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16, i17, i18, o1, o2, o3, o4, o5, o6, o7, o8);\n [/INST]\n", "output": "input clock_c; \n input i1; \n input i2; \n input [15:0] i3; \n input [15:0] i4; \n input [15:0] i5; \n input [15:0] i6; \n input [15:0] i7; \n input [15:0] i8; \n input [15:0] i9; \n input [15:0] i10; \n input [15:0] i11; \n input [15:0] i12; \n input [15:0] i13; \n input [15:0] i14; \n input [15:0] i15; \n input [15:0] i16; \n input [15:0] i17; \n input [15:0] i18; \n output [31:0] o1; \n output [31:0] o2; \n output [31:0] o3; \n output [31:0] o4; \n output [31:0] o5; \n output [31:0] o6; \n output [31:0] o7; \n output [31:0] o8; \n wire [31:0] n1; \n reg [31:0] n2; \n wire [31:0] n3; \n reg [31:0] n4; \n wire [31:0] n5; \n reg [31:0] n6; \n wire [31:0] n7; \n reg [31:0] n8; \n wire [31:0] s9_1; \n wire [31:0] s9_2; \n wire [31:0] s9_3; \n wire [31:0] s9_4; \n assign n1 = {16'b0000000000000000, i3} * {16'b0000000000000000, i11}; \n always @ (posedge clock_c) \n begin \n  if (i2 == 1'b1) \n  n2 <= 32'b00000000000000000000000000000000; \n  else if (i1 == 1'b1) \n  n2 <= n1; \n  if (i2 == 1'b1) \n  n4 <= 32'b00000000000000000000000000000000; \n  else if (i1 == 1'b1) \n  n4 <= n3; \n  if (i2 == 1'b1) \n  n6 <= 32'b00000000000000000000000000000000; \n  else if (i1 == 1'b1) \n  n6 <= n5; \n  if (i2 == 1'b1) \n  n8 <= 32'b00000000000000000000000000000000; \n  else if (i1 == 1'b1) \n  n8 <= n7; \n end \n assign n3 = {16'b0000000000000000, i4} * {16'b0000000000000000, i12}; \n assign n5 = {16'b0000000000000000, i5} * {16'b0000000000000000, i13}; \n assign n7 = {16'b0000000000000000, i6} * {16'b0000000000000000, i14}; \n cf_fir_24_16_16_23 s9 (clock_c, i1, i2, i7, i8, i9, i10, i15, i16, i17, i18, s9_1, s9_2, s9_3, s9_4); \n assign o8 = s9_4; \n assign o7 = s9_3; \n assign o6 = s9_2; \n assign o5 = s9_1; \n assign o4 = n8; \n assign o3 = n6; \n assign o2 = n4; \n assign o1 = n2; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, named ALU_CONTROL, is an implementation of a control logic for an Arithmetic Logic Unit (ALU). It takes inputs `funct` and `alu_op` and provides the output `select` based on the values of these inputs.\n\nThe `alu_op` input is used in a case statement to determine the value of `select`. If `alu_op` is 2'b00, `select` is assigned the value 3'b010. If `alu_op` is 2'b01, `select` is assigned 3'b110. If `alu_op` is 2'b10, a nested case statement based on the `funct` input determines the value of `select`. Finally, if `alu_op` is 2'b11, `select` is assigned 3'b011.\n\n Module header:\n\nmodule ALU_CONTROL(input [5:0] funct, input [1:0] alu_op, output reg [2:0] select);\n [/INST]\n", "output": "always @ * \n  begin \n  case (alu_op) \n  2'b00: \n  begin \n  select <= 3'b010; \n  end \n  2'b01: \n  begin \n  select <= 3'b110; \n  end \n  2'b10: \n  begin \n  case (funct) \n  6'b100000: \n  begin \n  select <= 3'b010; \n  end \n  6'b100010: \n  begin \n  select <= 3'b110; \n  end \n  6'b100100: \n  begin \n  select <= 3'b000; \n  end \n  6'b100101: \n  begin \n  select <= 3'b001; \n  end \n  6'b101010: \n  begin \n  select <= 3'b111; \n  end \n  endcase \n  end \n  2'b11: \n  begin \n  select <= 3'b011; \n  end \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module implements a top-level entity with various input and output ports. It interfaces with a PLL for clock generation and an SDRAM controller for memory access. The module includes a button debouncer and a recon_2 block for specific functionality. It also features a generate block for assigning values to the port_0_io and port_0_in signals, and utilizes a for loop to iterate over the PORT_0_WIDTH parameter.\n\n Module header:\n\nmodule recon_2_top #(parameter PORT_0_WIDTH = 32) (input sys_clk,input sys_rstn,inout [ PORT_0_WIDTH-1:0] port_0_io,output uart_0_txd,input uart_0_rxd,output sdram_0_clk,output [11:0] sdram_0_addr,output [1:0] sdram_0_ba,output sdram_0_cas_n,output sdram_0_cke,output sdram_0_cs_n,inout [15:0] sdram_0_dq,output [1:0] sdram_0_dqm,output sdram_0_ras_n,output sdram_0_we_n);\n [/INST]\n", "output": "wire [PORT_0_WIDTH-1:0] port_0_out; \n  wire [PORT_0_WIDTH-1:0] port_0_in; \n  wire [PORT_0_WIDTH-1:0] port_0_oe; \n  wire [PORT_0_WIDTH-1:0] port_0_opdrn; \n  wire cpu_clk, locked; \n  wire sdram_clk; \n  reg sdram_clk_reg; \n alt_pll pll(.areset (~sys_rstn),.inclk0 (sys_clk),.c0 (cpu_clk),.c1 (sdram_clk),.locked (locked)); \n alt_ddr sdram_clk_io(.outclock (sdram_clk) ,.din (2'b01) ,.pad_out (sdram_0_clk)); \n  buttonDebouncer \n #(.pDEBOUNCE_PERIOD (100_000_000),.pCLKIN_PERIOD (20 ),.pARRAY_SIZE (1 ),.pPOLARITY (0)) resetDebounce \n (.clk (sys_clk),.buttons (sys_rstn),.buttonState (sys_rstn_db),.buttonUpTick (),.buttonDwTick ()); \n recon_2 (.clk_clk (cpu_clk),.recon_io_0_io_port_io_out (port_0_out),.recon_io_0_io_port_io_opdrn (port_0_opdrn),.recon_io_0_io_port_io_in (port_0_in),.recon_io_0_io_port_io_oe (port_0_oe),.recon_timer_0_clock_tick_second (),.recon_timer_0_clock_tick_millisecond (),.recon_timer_0_clock_tick_microsec (),.reset_reset_n (sys_rstn_db),.uart_0_rxd (uart_0_rxd),.uart_0_txd (uart_0_txd),.sdram_0_addr (sdram_0_addr ),.sdram_0_ba (sdram_0_ba ),.sdram_0_cas_n (sdram_0_cas_n),.sdram_0_cke (sdram_0_cke ),.sdram_0_cs_n (sdram_0_cs_n ),.sdram_0_dq (sdram_0_dq ),.sdram_0_dqm (sdram_0_dqm ),.sdram_0_ras_n (sdram_0_ras_n),.sdram_0_we_n (sdram_0_we_n )); \n  genvar IO; \n  generate \n  for (IO = 0; IO<PORT_0_WIDTH;IO=IO+1) \n  begin : assign_io \n  assign port_0_io[IO] = (port_0_oe[IO]==1'b0||(port_0_out[IO]==1'b1&&port_0_opdrn[IO]==1'b1))?1'bz:port_0_out[IO]; \n  assign port_0_in[IO] = port_0_io[IO]; \n  end \n  endgenerate \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module `fir_mul_32s_32s_3bkb_MulnS_0` implements a 32-bit signed multiplier with a clock input, enable input, two 32-bit signed inputs `a` and `b`, and a 32-bit signed output `p`. The module uses a register to hold the output and a temporary wire `tmp_product` to store the result of the multiplication. The multiplication operation occurs when the enable signal `ce` is asserted and the output `p` is updated with the result.\n\n Module header:\n\nmodule fir_mul_32s_32s_3bkb_MulnS_0(clk, ce, a, b, p);\n [/INST]\n", "output": "input clk; \n input ce; \n input signed [32 - 1 : 0] a; \n input signed [32 - 1 : 0] b; \n output[32 - 1 : 0] p; \n reg signed [32 - 1 : 0] p; \n wire signed [32 - 1 : 0] tmp_product; \n assign tmp_product = $signed(a) * $signed(b); \n always @ (posedge clk) begin \n  if (ce) begin \n  p <= tmp_product; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module serves as the main control for a system and interfaces with a joystick module. It controls the LEDs, generates sound data, sets RGB colors based on button presses, and processes joystick movements. It also handles data communication and assigns X and Y position data. The module interacts with the PmodJSTK, RGB_color_set, ClkDiv_20Hz, and LED_joystick modules to facilitate these functionalities.\n\n Module header:\n\nmodule Main_Control(clk,rst,LED,JSTK_SS,JSTK_MOSI,JSTK_MISO,JSTK_SCK);\n [/INST]\n", "output": "input clk; \n  input rst; \n  output [4:0] LED; \n  input JSTK_MISO; \n  output JSTK_SS; \n  output JSTK_MOSI; \n  output JSTK_SCK; \n  wire sndRec; \n  wire [39:0] jstkData; \n  wire [9:0] XposData; \n  wire [9:0] YposData; \n  wire [39:0] sndData; \n  wire [23:0] RGBcolor; \n PmodJSTK PmodJSTK_Int(.CLK(clk),.RST(rst),.sndRec(sndRec),.DIN(sndData),.MISO(JSTK_MISO),.SS(JSTK_SS),.SCLK(JSTK_SCK),.MOSI(JSTK_MOSI),.DOUT(jstkData)); \n RGB_color_set Select_Color(.clk(clk),.button(jstkData[1:0]),.RGBcolor(RGBcolor)); \n ClkDiv_20Hz genSndRec(.CLK(clk),.RST(rst),.CLKOUT(sndRec)); \n LED_joystick boardLEDcontroller(.clk(clk),.xpos(XposData),.ypos(YposData),.button(jstkData[1:0]),.LED(LED)); \n  assign YposData = {jstkData[25:24], jstkData[39:32]}; \n  assign XposData = {jstkData[9:8], jstkData[23:16]}; \n  assign sndData = {8'b10000100, RGBcolor, 8'b00000000}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module implements a floating-point addition and subtraction with an alternate priority encoder. It takes a 2-bit input 'data' and produces a 1-bit output 'q' based on the bitwise complement of the least significant bit of 'data'.\n\n Module header:\n\nmodule float_add_sub_altpriority_encoder_n28 (data,q) ;\n [/INST]\n", "output": "input [1:0] data; \n  output [0:0] q; \n  assign \n  q = {(~ data[0])}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, named Graying, processes input color data using a configurable work mode. It features a set of color components represented by red, green, and blue. The module involves the multiplication of the color components by certain constants, summing them, and producing the output data. It also includes a configurable enable signal and a delay. The output data is produced when the output ready signal is asserted. The module operates based on the clock and reset signals, as well as the input enable signal. The overall functionality aims to perform color space transformation for images.\n\n Module header:\n\nmodule Graying(clk,rst_n,in_enable,in_data,out_ready,out_data);\n [/INST]\n", "output": "parameter work_mode = 0; \n  parameter color_width = 8; \n  parameter mul_delay = 3; \n  input clk; \n  input rst_n; \n  input in_enable; \n  input [3 * color_width - 1 : 0] in_data; \n  output out_ready; \n  output[color_width - 1 : 0] out_data; \n  reg[color_width - 1 : 0] reg_out_data; \n  reg[color_width - 1 : 0] r, g, b; \n  wire[10 : 0] mul_r; \n  wire[11 : 0] mul_g; \n  wire[8 : 0] mul_b; \n  reg[2 : 0] con_enable; \n  genvar i; \n  generate \n  if(work_mode == 0) begin \n  always @(*) begin \n  r = in_data[3 * color_width - 1 : 2 * color_width]; \n  g = in_data[2 * color_width - 1 : 1 * color_width]; \n  b = in_data[1 * color_width - 1 : 0 * color_width]; \n  end \n  end else begin \n  always @(posedge in_enable) begin \n  r = in_data[3 * color_width - 1 : 2 * color_width]; \n  g = in_data[2 * color_width - 1 : 1 * color_width]; \n  b = in_data[1 * color_width - 1 : 0 * color_width]; \n  end \n  end \n  MultiplierRedx0d299 MulRed(.CLK (clk), .A({{12 - color_width{1'b0}} ,r}), .SCLR(~rst_n), .P(mul_r)); \n  MultiplierGreenx0d587 MulGreen(.CLK (clk), .A({{12 - color_width{1'b0}} ,g}), .SCLR(~rst_n), .P(mul_g)); \n  MultiplierBluex0d114 MulBlue(.CLK (clk), .A({{12 - color_width{1'b0}} ,b}), .SCLR(~rst_n), .P(mul_b)); \n  reg[11 : 0] mul_g_buffer; \n  reg[color_width - 1 : 0] sum_tmp; \n  always @(posedge clk) begin \n  mul_g_buffer <= mul_g; \n  sum_tmp <= mul_r + mul_b; \n  end \n  always @(posedge clk or negedge rst_n or negedge in_enable) begin \n  if(~rst_n || ~in_enable) begin \n  reg_out_data <= 0; \n  end else begin \n  reg_out_data <= sum_tmp + mul_g_buffer; \n  end \n  end \n  assign out_data = out_ready ? reg_out_data : 0; \n  always @(posedge clk or negedge rst_n or negedge in_enable) begin \n  if(~rst_n || ~in_enable) \n  con_enable <= 0; \n  else if(con_enable == mul_delay + 2) \n  con_enable <= con_enable; \n  else \n  con_enable <= con_enable + 1; \n  end \n  assign out_ready = con_enable == mul_delay + 2 ? 1 : 0; \n  endgenerate \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"pipe2tb\" defines input and output registers and wires for various data paths. It includes a pipeline register \"pipe2_1\" with 17 inputs and 13 outputs. The module also has an always block that toggles the clock and an initial block that initializes and sets the inputs. Upon simulation, the module will execute the initial block, toggle the clock, and then finish the simulation.\n\n Module header:\n\nmodule pipe2tb;\n [/INST]\n", "output": "reg [0:4] aluop_in; \n  reg [0:2] ppp_in; \n  reg [0:1] ww_in; \n  reg [0:1] memop_in; \n  reg [0:20] memAddr_in; \n  reg [0:15] wbyteen_in; \n  reg regwren_in; \n  reg [0:4] rwraddrd_in; \n  reg reginmuxop_in; \n  reg [0:127] rd1data_in; \n  reg [0:127] rd2data_in; \n  reg clk, reset; \n  wire [0:4] aluop_out; \n  wire [0:2] ppp_out; \n  wire [0:1] ww_out; \n  wire memWrEn_out; \n  wire memEn_out; \n  wire [0:20] memAddr_out; \n  wire [0:15] wbyteen_out; \n  wire regwren_out; \n  wire [0:4] rwraddrd_out; \n  wire reginmuxop_out; \n  wire [0:127] rd1data_out; \n  wire [0:127] rd2data_out; \n pipe2 pipe2_1(aluop_in, aluop_out, ppp_in, ppp_out, ww_in, ww_out,memop_in, memWrEn_out, memEn_out, memAddr_in, memAddr_out,wbyteen_in, wbyteen_out, regwren_in, regwren_out, rwraddrd_in,rwraddrd_out, reginmuxop_in, reginmuxop_out,rd1data_in, rd1data_out, rd2data_in, rd2data_out, clk, reset); \n  always \n  begin \n  #5 clk=0; \n  #5 clk=1; \n  end \n  initial \n  begin \n  #5; \n  reset=1'b1; \n  #10; \n  reset=1'b0; \n  #10; \n  aluop_in<=5'b1; \n  ppp_in<=3'b1; \n  ww_in<=2'b1; \n  memop_in<=2'b11; \n  memAddr_in<=21'b1; \n  wbyteen_in<=16'b1; \n  regwren_in<=1'b1; \n  rwraddrd_in<=5'b1; \n  reginmuxop_in<=1'b1; \n  rd1data_in<=128'b1; \n  rd2data_in<=128'b1; \n  #10; \n  $finish; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a 17-bit 2-to-1 multiplexer. It selects either input A or input B based on the value of the select signal S and assigns the selected input to the output MO.\n\n Module header:\n\nmodule cycloneiv_b17mux21 (MO, A, B, S);\n [/INST]\n", "output": "input [16:0] A, B; \n  input S; \n  output [16:0] MO; \n  assign MO = (S == 1) ? B : A; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements an interrupt sense module that detects different types of signal transitions based on a specified mask. The module has a state machine with four states: S_RESET, S_INIT0, S_INIT1, and S_WORK. The signal transitions are detected based on the input signals and the senceMask input. The output signalOut is determined based on the state and senceMask, and the detected signal transitions are controlled through a set of logic operations.\n\n Module header:\n\nmodule interrupt_sence (input CLK,input RESETn,input [1:0] senceMask,input signalIn,output reg signalOut);\n [/INST]\n", "output": "parameter MASK_LOW = 2'b00, \n  MASK_ANY = 2'b01, \n  MASK_FALL = 2'b10, \n  MASK_RIZE = 2'b11; \n  parameter S_RESET = 0, \n  S_INIT0 = 1, \n  S_INIT1 = 2, \n  S_WORK = 3; \n  reg [ 1 : 0 ] State, Next; \n  reg [ 1 : 0 ] signal; \n  always @ (posedge CLK) \n  if(~RESETn) \n  State <= S_INIT0; \n  else \n  State <= Next; \n  always @ (posedge CLK) \n  case(State) \n  S_RESET : signal <= 2'b0; \n  default : signal <= { signal[0], signalIn }; \n  endcase \n  always @ (*) begin \n  case (State) \n  S_RESET : Next = S_INIT0; \n  S_INIT0 : Next = S_INIT1; \n  default : Next = S_WORK; \n  endcase \n  case( { State, senceMask } ) \n  { S_WORK, MASK_LOW } : signalOut = ~signal[1] & ~signal[0]; \n  { S_WORK, MASK_ANY } : signalOut = signal[1] ^ signal[0]; \n  { S_WORK, MASK_FALL } : signalOut = signal[1] & ~signal[0]; \n  { S_WORK, MASK_RIZE } : signalOut = ~signal[1] & signal[0]; \n  default : signalOut = 1'b0; \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, named BrzLoop, takes an activate signal as input and produces an activated output signal. It also takes an activated output signal as input and produces an activate signal as output. The module includes internal components for inverting and logic operations. The activate_0a output is constantly set to a ground value.\n\n Module header:\n\nmodule BrzLoop (activate_0r, activate_0a,activateOut_0r, activateOut_0a);\n [/INST]\n", "output": "input activate_0r; \n  output activate_0a; \n  output activateOut_0r; \n  input activateOut_0a; \n  wire nReq_0n; \n  wire gnd; \n  GND gnd_cell_instance (gnd); \n  IV I0 (nReq_0n, activate_0r); \n  NR2 I1 (activateOut_0r, nReq_0n, activateOut_0a); \n  assign activate_0a = gnd; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an arbitrating circuit that selects between two input channels to grant access to an output channel. It uses the clock signal and a reset signal to update the last grant value, and determines the chosen input based on various input and output signals. The module ensures that the chosen input has a valid and ready signal to enable data transfer to the output.\n\n Module header:\n\nmodule RRArbiter_1(input clk, input reset,output io_in_0_ready,input io_in_0_valid,input [31:0] io_in_0_bits,output io_in_1_ready,input io_in_1_valid,input [31:0] io_in_1_bits,input io_out_ready,output io_out_valid,output[31:0] io_out_bits,output io_chosen);\n [/INST]\n", "output": "wire T0; \n  wire T1; \n  wire T2; \n  wire T3; \n  wire T4; \n  wire T5; \n  wire T6; \n  reg[0:0] last_grant; \n  wire T7; \n  wire T8; \n  wire choose; \n  wire T9; \n  wire T10; \n  wire T11; \n  wire T12; \n  wire T13; \n  wire T14; \n  wire T15; \n  wire T16; \n  wire T17; \n  wire T18; \n  wire T19; \n  wire T20; \n  wire T21; \n  wire T22; \n  assign io_out_valid = T0; \n  assign T0 = io_in_0_valid || io_in_1_valid; \n  assign io_in_0_ready = T1; \n  assign T1 = T2 && io_out_ready; \n  assign T2 = T14 || T3; \n  assign T3 = ! T4; \n  assign T4 = T12 || T5; \n  assign T5 = io_in_1_valid && T6; \n  assign T6 = 1'h1 > last_grant; \n  assign T7 = io_out_valid && io_out_ready; \n  assign T8 = T7 ? choose : last_grant; \n  assign choose = T10 ? 1'h1 : T9; \n  assign T9 = io_in_0_valid ? 1'h0 : 1'h1; \n  assign T10 = io_in_1_valid && T11; \n  assign T11 = 1'h1 > last_grant; \n  assign T12 = io_in_0_valid && T13; \n  assign T13 = 1'h0 > last_grant; \n  assign T14 = 1'h0 > last_grant; \n  assign io_in_1_ready = T15; \n  assign T15 = T16 && io_out_ready; \n  assign T16 = T20 || T17; \n  assign T17 = ! T18; \n  assign T18 = T19 || io_in_0_valid; \n  assign T19 = T12 || T5; \n  assign T20 = T22 && T21; \n  assign T21 = 1'h1 > last_grant; \n  assign T22 = ! T12; \n  always @(posedge clk) begin \n  if(reset) begin \n  last_grant <= 1'h0; \n  end else if(T7) begin \n  last_grant <= T8; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module simply assigns a constant value of 1 to the output 'a'.\n\n Module header:\n\nmodule logic_1(output a);\n [/INST]\n", "output": "assign a = 1; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a simple cascade module with an input 'in' and an output 'out'. The output 'out' is directly assigned the value of the input 'in'.\n\n Module header:\n\nmodule cascade (in, out);\n [/INST]\n", "output": "input in; \n  output out; \n  assign out = in; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a 4-to-16 decoder. It takes a 4-bit input ADDR and generates a 16-bit output DEC. Each bit of the output DEC is determined by a specific combination of the input ADDR bits, where the output is high if the input matches the specified combination and low otherwise. This is a straightforward implementation of a decoder circuit that is commonly used in digital systems to select one of multiple output lines based on the input signal.\n\n Module header:\n\nmodule dec_4_to_16 (input [3:0] ADDR,output [15:0] DEC);\n [/INST]\n", "output": "assign DEC[0] = ~ADDR[0] & ~ADDR[1] & ~ADDR[2] & ~ADDR[3]; \n  assign DEC[1] = ~ADDR[0] & ~ADDR[1] & ~ADDR[2] & ADDR[3]; \n  assign DEC[2] = ~ADDR[0] & ~ADDR[1] & ADDR[2] & ~ADDR[3]; \n  assign DEC[3] = ~ADDR[0] & ~ADDR[1] & ADDR[2] & ADDR[3]; \n  assign DEC[4] = ~ADDR[0] & ADDR[1] & ~ADDR[2] & ~ADDR[3]; \n  assign DEC[5] = ~ADDR[0] & ADDR[1] & ~ADDR[2] & ADDR[3]; \n  assign DEC[6] = ~ADDR[0] & ADDR[1] & ADDR[2] & ~ADDR[3]; \n  assign DEC[7] = ~ADDR[0] & ADDR[1] & ADDR[2] & ADDR[3]; \n  assign DEC[8] = ADDR[0] & ~ADDR[1] & ~ADDR[2] & ~ADDR[3]; \n  assign DEC[9] = ADDR[0] & ~ADDR[1] & ~ADDR[2] & ADDR[3]; \n  assign DEC[10] = ADDR[0] & ~ADDR[1] & ADDR[2] & ~ADDR[3]; \n  assign DEC[11] = ADDR[0] & ~ADDR[1] & ADDR[2] & ADDR[3]; \n  assign DEC[12] = ADDR[0] & ADDR[1] & ~ADDR[2] & ~ADDR[3]; \n  assign DEC[13] = ADDR[0] & ADDR[1] & ~ADDR[2] & ADDR[3]; \n  assign DEC[14] = ADDR[0] & ADDR[1] & ADDR[2] & ~ADDR[3]; \n  assign DEC[15] = ADDR[0] & ADDR[1] & ADDR[2] & ADDR[3]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a FIFO (First In, First Out) queue. The module has inputs for reset, read control, data selection, and clock signals, along with data input and output ports. It uses a register to store the queue data and updates the output data based on the input signals. Additionally, it incorporates a flag module for controlling the FIFO's behavior. The module includes an always block that handles the queue's reset and updates its data based on the input signals and clock events.\n\n Module header:\n\nmodule ph_byte (input h_rst_b,input h_rd,input h_selectData,input h_phi2,input [7:0] p_data,input p_selectData,input p_phi2,input p_rdnw,output [7:0] h_data,output h_data_available,output p_full);\n [/INST]\n", "output": "reg [7:0] fifo_q_r ; \n  wire [7:0] fifo_d_r ; \n  assign h_data = fifo_q_r; \n  assign fifo_d_r = ( p_selectData & !p_rdnw) ? p_data : fifo_q_r; \n ph_flag_m flag_0 (.rst_b(h_rst_b),.p2_rdnw(h_rd),.p2_select(h_selectData),.p2_clk(h_phi2),.p1_select(p_selectData),.p1_rdnw(p_rdnw),.p1_clk(p_phi2),.p2_data_available(h_data_available),.p1_full(p_full)); \n  always @ ( posedge p_phi2 or negedge h_rst_b ) \n  begin \n  if ( ! h_rst_b) \n  fifo_q_r <= 8'h41; \n  else \n  fifo_q_r <= fifo_d_r ; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a bridge between two buses: the RBCP (Remote Bus Control Protocol) bus and the BUS. It synchronizes the RBCP signals with the BUS signals using clock edge-triggered logic. It has logic to reset the RBCP acknowledgment and to set it based on the RBCP write enable or read enable signals. It also assigns the RBCP address to the BUS address, the RBCP write enable to the BUS write enable, and the RBCP read enable to the BUS read enable. The module also handles the data transfer between the RBCP and the BUS. When writing, it assigns the RBCP write data to the BUS data, and when reading, it assigns the BUS data to the RBCP read data.\n\n Module header:\n\nmodule rbcp_to_bus (input wire BUS_RST,input wire BUS_CLK,input wire RBCP_ACT,input wire [31:0] RBCP_ADDR,input wire [7:0] RBCP_WD,input wire RBCP_WE,input wire RBCP_RE,output reg RBCP_ACK,output wire [7:0] RBCP_RD,output wire BUS_WR,output wire BUS_RD,output wire [31:0] BUS_ADD,inout wire [7:0] BUS_DATA);\n [/INST]\n", "output": "always@(posedge BUS_CLK) begin \n  if(BUS_RST) \n  RBCP_ACK <= 0; \n  else begin \n  if (RBCP_ACK == 1) \n  RBCP_ACK <= 0; \n  else \n  RBCP_ACK <= RBCP_WE | RBCP_RE; \n  end \n end \n assign BUS_ADD = RBCP_ADDR; \n assign BUS_WR = RBCP_WE; \n assign BUS_RD = RBCP_RE; \n assign BUS_DATA = BUS_WR ? RBCP_WD[7:0]: 8'bz; \n assign RBCP_RD[7:0] = BUS_WR ? 8'bz : BUS_DATA; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `show_num` is a 4-digit 7-segment LED display controller. The `led_total` input contains the data for all four digits, and the `clk` and `rst_n` signals control the operation of the module. The module cycles through the four digits using a 2-bit counter `cnt`. The `sel` output selects the active digit, and the `num` output provides the appropriate 7-segment code for the active digit based on the data in `led_total`. The display data is selected based on the current value of the counter `cnt`, and the digits are updated on each rising edge of the clock signal.\n\n Module header:\n\nmodule show_num(led_total,clk,num,sel,rst_n);\n [/INST]\n", "output": "input[27:0]led_total; \n input clk,rst_n; \n output reg[6:0]num; \n output reg[3:0]sel; \n wire[6:0]temp1,temp2,temp3,temp4; \n reg [6:0]temp; \n reg[1:0]cnt; \n always @(posedge clk or negedge rst_n) \n begin \n  if(!rst_n)begin cnt<=0;end \n  else begin \n  if(cnt==2'd3)begin cnt<=0; end \n  else begin cnt<=cnt+1;end \n  end \n end \n assign temp1=led_total[27:21]; \n assign temp2=led_total[20:14]; \n assign temp3=led_total[13:7]; \n assign temp4=led_total[6:0]; \n always@(posedge clk) \n begin \n  case(cnt) \n  2'b00:sel<=4'b1000; \n  2'b01:sel<=4'b0100; \n  2'b10:sel<=4'b0010; \n  2'b11:sel<=4'b0001; \n  endcase \n end \n always@(posedge clk) \n begin \n  if(cnt==2'b00)begin temp=temp1;end \n  else \n  begin \n  if(cnt==2'b01)begin temp=temp2;end \n  else begin \n  if(cnt==2'b10)begin temp=temp3;end \n  else begin temp=temp4;end \n  end \n  end \n  case(temp) \n  7'd0:num<=7'b1111110; \n  7'd1:num<=7'b0110000; \n  7'd2:num<=7'b1101101; \n  7'd3:num<=7'b1111001; \n  7'd4:num<=7'b0110011; \n  7'd5:num<=7'b1011011; \n  7'd6:num<=7'b1011111; \n  7'd7:num<=7'b1110000; \n  7'd8:num<=7'b1111111; \n  7'd9:num<=7'b1111011; \n  endcase \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, \"iram_block,\" interfaces with an instruction RAM (IRAM) in a microprocessor. It receives the PC value and the IRAM data as inputs, and provides two outputs: one for the IRAM data and another for the IF/ID register. The module sets the IRAM address by assigning specific bits. Additionally, it connects to the memory management unit (MMU) input and output modules to manage the IRAM data and the flushing process.\n\n Module header:\n\nmodule iram_block (from_pc,flush,from_iram,to_iram,to_if_id_reg);\n [/INST]\n", "output": "input [31:0] from_pc; \n  input flush; \n  input [31:0] from_iram; \n  output [31:0] to_iram; \n  output [31:0] to_if_id_reg; \n  wire SYNOPSYS_UNCONNECTED__0; \n  wire SYNOPSYS_UNCONNECTED__1; \n  assign to_iram[31] = 1'b0 ; \n  assign to_iram[30] = 1'b0 ; \n mmu_in_iram mmu_in (.from_pc(from_pc),.to_iram({ SYNOPSYS_UNCONNECTED__0,SYNOPSYS_UNCONNECTED__1,to_iram[29],to_iram[28],to_iram[27],to_iram[26],to_iram[25],to_iram[24],to_iram[23],to_iram[22],to_iram[21],to_iram[20],to_iram[19],to_iram[18],to_iram[17],to_iram[16],to_iram[15],to_iram[14],to_iram[13],to_iram[12],to_iram[11],to_iram[10],to_iram[9],to_iram[8],to_iram[7],to_iram[6],to_iram[5],to_iram[4],to_iram[3],to_iram[2],to_iram[1],to_iram[0] })); \n mmu_out_iram mmu_out (.from_iram(from_iram),.flush(flush),.to_if_id_reg(to_if_id_reg)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes in a valid signal and produces a chosen output based on its readiness. If the valid signal is not asserted, the chosen output is set to 1; otherwise, the chosen output is set to 0.\n\n Module header:\n\nmodule RREncode(input io_valid_0,output io_chosen,input io_ready);\n [/INST]\n", "output": "wire choose; \n  assign io_chosen = choose; \n  assign choose = io_valid_0 ? 1'h0 : 1'h1; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe `aurora_64b66b_25p4G_WIDTH_CONVERSION` Verilog module is designed to convert the width of input and output data. It operates on a clock signal and includes logic to handle reset, enable, and data validation signals. The module has registers to latch input and header signals based on the clock edge. It also incorporates state logic to determine the output data based on the enable signal and the state of the module. The header output is determined based on the state of the module, and the data validation output is assigned based on the positive data validation signal.\n\n Module header:\n\n module aurora_64b66b_25p4G_WIDTH_CONVERSION # (parameter INPUT_WIDTH =2,parameter OUTPUT_WIDTH=4) (DATA_OUT,DATA_IN,HEADER_IN,DATAVALID_IN,HEADER_OUT,DATAVALID_OUT,USER_CLK,ENABLE,RESET);\n [/INST]\n", "output": "`define DLY #1 \n  input RESET; \n  input USER_CLK; \n  input ENABLE; \n  input [INPUT_WIDTH*8-1:0] DATA_IN; \n  output [OUTPUT_WIDTH*8-1:0] DATA_OUT; \n  output [1:0] HEADER_OUT; \n  output DATAVALID_OUT; \n  input [1:0] HEADER_IN; \n  input DATAVALID_IN; \n  reg [OUTPUT_WIDTH*8-1:0] DATA_OUT; \n  reg [1:0] HEADER_OUT; \n  reg [INPUT_WIDTH*8-1:0] data_in_r; \n  reg [INPUT_WIDTH*8-1:0] data_in_r2; \n  reg [1:0] header_in_r; \n  reg [1:0] header_in_r2; \n  reg datavalid_r; \n  reg datavalid_r2; \n  reg datavalid_neg_r; \n  reg datavalid_pos_r; \n  reg state; \n  always @(posedge USER_CLK) \n  begin \n  data_in_r <= `DLY DATA_IN; \n  data_in_r2 <= `DLY data_in_r; \n  header_in_r <= `DLY HEADER_IN; \n  header_in_r2 <= `DLY header_in_r; \n  end \n  always @(posedge USER_CLK) \n  begin \n  datavalid_r <= `DLY DATAVALID_IN; \n  datavalid_r2 <= `DLY datavalid_r; \n  end \n  always @(posedge USER_CLK) \n  begin \n  if(RESET) \n  state <= `DLY 1'b1; \n  else if (ENABLE && datavalid_r2 && !datavalid_neg_r) \n  state <= `DLY 1'b0; \n  else if (ENABLE && !datavalid_r2 && !datavalid_neg_r) \n  state <= `DLY 1'b1; \n  end \n  always @(posedge USER_CLK) \n  if(ENABLE) \n  begin \n  datavalid_pos_r <= `DLY datavalid_r; \n  end \n  always @(negedge USER_CLK) \n  begin \n  datavalid_neg_r <= `DLY datavalid_r; \n  end \n  always @(posedge USER_CLK) \n  if(RESET) DATA_OUT <= `DLY 32'b0; \n  else if(ENABLE) \n  begin \n  if(state) \n  DATA_OUT <= `DLY {data_in_r2,data_in_r}; \n  else if(!state) \n  DATA_OUT <= `DLY {data_in_r,DATA_IN}; \n  end \n  always @(posedge USER_CLK) \n  if (RESET) HEADER_OUT <= `DLY 2'b0; \n  else if(ENABLE) \n  begin \n  if(!state) \n  HEADER_OUT <= `DLY header_in_r; \n  else if(state) \n  HEADER_OUT <= `DLY header_in_r2; \n  end \n  assign DATAVALID_OUT = datavalid_pos_r; \n  endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a 4-bit Lookahead Adder. It computes the sum of two 4-bit input numbers along with a carry-in signal and outputs the 4-bit sum and the carry-out signal. The module uses logic to compute the generate and propagate signals for each bit, which are then combined to calculate the carry values for each bit. Finally, the module computes the individual sum bits based on the input signals, generate and propagate signals, and the carry values.\n\n Module header:\n\nmodule LookAheadAdder(a,b,cin,s,cout);\n [/INST]\n", "output": "input wire [3:0]a; \n  input wire [3:0]b; \n  input wire cin; \n  output wire [3:0]s; \n  output wire cout; \n  wire [3:0]c; \n  wire [3:0]G; \n  wire [3:0]P; \n  assign G[3]=a[3]&&b[3]; \n  assign G[2]=a[2]&&b[2]; \n  assign G[1]=a[1]&&b[1]; \n  assign G[0]=a[0]&&b[0]; \n  assign P[3]=a[3]&&~b[3]||~a[3]&&b[3]; \n  assign P[2]=a[2]&&~b[2]||~a[2]&&b[2]; \n  assign P[1]=a[1]&&~b[1]||~a[1]&&b[1]; \n  assign P[0]=a[0]&&~b[0]||~a[0]&&b[0]; \n  wire [3:0]c3; \n  wire [2:0]c2; \n  wire [1:0]c1; \n  and(c3[0],P[3],P[2],P[1],P[0],cin); \n  and(c3[1],P[3],P[2],P[1],G[0]); \n  and(c3[2],P[3],P[2],G[1]); \n  and(c3[3],P[3],G[2]); \n  and(c2[0],P[2],P[1],P[0],cin); \n  and(c2[1],P[2],P[1],G[0]); \n  and(c2[2],P[2],G[1]); \n  and(c1[0],P[1],P[0],cin); \n  and(c1[1],P[1],G[0]); \n  and(c0,P[0],cin); \n  or(cout,c3[0],c3[1],c3[2],c3[3],G[3]); \n  or(c[2],c2[0],c2[1],c2[2],G[2]); \n  or(c[1],c1[0],c1[1],G[1]); \n  or(c[0],c0,G[0]); \n  assign s[0]=~a[0]&&(~b[0]&&cin||b[0]&&~cin)||a[0]&&(b[0]&&cin||~b[0]&&~cin); \n  assign s[1]=~a[1]&&(~b[1]&&c[0]||b[1]&&~c[0])||a[1]&&(b[1]&&c[0]||~b[1]&&~c[0]); \n  assign s[2]=~a[2]&&(~b[2]&&c[1]||b[2]&&~c[1])||a[2]&&(b[2]&&c[1]||~b[2]&&~c[1]); \n  assign s[3]=~a[3]&&(~b[3]&&c[2]||b[3]&&~c[2])||a[3]&&(b[3]&&c[2]||~b[3]&&~c[2]); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a configurable FIFO (First-In-First-Out) design with two clock domains. It includes parameters for the data width and the size of the FIFO. The module has input and output signals for clocks, data, ready signals, and control signals. It uses logic to determine when to read and write data based on the full and empty flags. The module instantiates different FIFO instances based on the size and width parameters to accommodate a range of configurations. It also calculates the occupied and space signals based on the FIFO size and the current data count.\n\n Module header:\n\nmodule fifo_2clock #(parameter WIDTH=36, SIZE=6) (input wclk, input [WIDTH-1:0] datain, input src_rdy_i, output dst_rdy_o, output [15:0] space,input rclk, output [WIDTH-1:0] dataout, output src_rdy_o, input dst_rdy_i, output [15:0] occupied,input arst);\n [/INST]\n", "output": "wire [SIZE:0] level_rclk, level_wclk; \n  wire full, empty, write, read; \n  assign dst_rdy_o = ~full; \n  assign src_rdy_o = ~empty; \n  assign write = src_rdy_i & dst_rdy_o; \n  assign read = src_rdy_o & dst_rdy_i; \n  generate \n  if((WIDTH <= 36) && (WIDTH > 19)) begin \n  wire [35:0] data_in_wide, data_out_wide; \n  assign data_in_wide[WIDTH-1:0] = datain; \n  assign dataout = data_out_wide[WIDTH-1:0]; \n  if(SIZE==9) \n  fifo_xlnx_512x36_2clk fifo_xlnx_512x36_2clk \n (.rst(arst),.wr_clk(wclk),.din(data_in_wide),.full(full),.wr_en(write),.wr_data_count(level_wclk),.rd_clk(rclk),.dout(data_out_wide),.empty(empty),.rd_en(read),.rd_data_count(level_rclk) ); \n  else if(SIZE==11) \n  fifo_xlnx_2Kx36_2clk fifo_xlnx_2Kx36_2clk \n (.rst(arst),.wr_clk(wclk),.din(data_in_wide),.full(full),.wr_en(write),.wr_data_count(level_wclk),.rd_clk(rclk),.dout(data_out_wide),.empty(empty),.rd_en(read),.rd_data_count(level_rclk) ); \n  else if(SIZE==6) \n  fifo_xlnx_64x36_2clk fifo_xlnx_64x36_2clk \n (.rst(arst),.wr_clk(wclk),.din(data_in_wide),.full(full),.wr_en(write),.wr_data_count(level_wclk),.rd_clk(rclk),.dout(data_out_wide),.empty(empty),.rd_en(read),.rd_data_count(level_rclk) ); \n  else \n  fifo_xlnx_512x36_2clk fifo_xlnx_512x36_2clk \n (.rst(arst),.wr_clk(wclk),.din(data_in_wide),.full(full),.wr_en(write),.wr_data_count(level_wclk),.rd_clk(rclk),.dout(data_out_wide),.empty(empty),.rd_en(read),.rd_data_count(level_rclk) ); \n  end \n  else if((WIDTH <= 19) && (SIZE <= 4)) begin \n  wire [18:0] data_in_wide, data_out_wide; \n  assign data_in_wide[WIDTH-1:0] = datain; \n  assign dataout = data_out_wide[WIDTH-1:0]; \n  fifo_xlnx_16x19_2clk fifo_xlnx_16x19_2clk \n (.rst(arst),.wr_clk(wclk),.din(data_in_wide),.full(full),.wr_en(write),.wr_data_count(level_wclk),.rd_clk(rclk),.dout(data_out_wide),.empty(empty),.rd_en(read),.rd_data_count(level_rclk) ); \n  end \n  endgenerate \n  assign occupied = {{(16-SIZE-1){1'b0}},level_rclk}; \n  assign space = ((1<<SIZE)+1)-level_wclk; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a synchronous reset flip-flop. It has one input data, and two control inputs, clk (clock) and reset. The output q is a single bit. When the reset signal is asserted, q is set to 1, otherwise q takes the value of the data input on the rising edge of the clock. The register q is declared with an asynchronous reset.\n\n Module header:\n\nmodule axi_traffic_gen_v2_0_asynch_rst_ff (data ,clk ,reset ,q);\n [/INST]\n", "output": "input data, clk, reset ; \n output q; \n (*ASYNC_REG = \"TRUE\" *) reg q; \n always @ ( posedge clk or posedge reset) begin \n  if (reset) begin \n  q <= 1'b1; \n  end else begin \n  q <= data; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is designed to interface an ADC with a DMA and FIFO. It includes inputs for the ADC reset signal, clock signal, write signal, data input, and write overflow signal, along with outputs for the ADC write overflow, DMA write signal, DMA data output, DMA ready signal, and several FIFO-related signals. \n\nThe module's functionality involves managing the ADC write overflow, generating the write data for the FIFO, handling DMA readiness and data, and controlling the FIFO reset signal. It also includes instantiation of another module named \"ad_axis_inf_rx.\"\n\nOverall, this module serves as a bridge between the ADC, DMA, and FIFO, ensuring proper data transfer and synchronization between these components.\n\n Module header:\n\nmodule util_wfifo (adc_rst,adc_clk,adc_wr,adc_wdata,adc_wovf,dma_clk,dma_wr,dma_wdata,dma_wready,dma_wovf,fifo_rst,fifo_rstn,fifo_wr,fifo_wdata,fifo_wovf,fifo_rd,fifo_rdata,fifo_rempty);\n [/INST]\n", "output": "parameter ADC_DATA_WIDTH = 32; \n  parameter DMA_DATA_WIDTH = 64; \n  parameter DMA_READY_ENABLE = 0; \n  input adc_rst; \n  input adc_clk; \n  input adc_wr; \n  input [ADC_DATA_WIDTH-1:0] adc_wdata; \n  output adc_wovf; \n  input dma_clk; \n  output dma_wr; \n  output [DMA_DATA_WIDTH-1:0] dma_wdata; \n  input dma_wready; \n  input dma_wovf; \n  output fifo_rst; \n  output fifo_rstn; \n  output fifo_wr; \n  output [ADC_DATA_WIDTH-1:0] fifo_wdata; \n  input fifo_wovf; \n  output fifo_rd; \n  input [DMA_DATA_WIDTH-1:0] fifo_rdata; \n  input fifo_rempty; \n  reg [ 1:0] adc_wovf_m = 'd0; \n  reg adc_wovf = 'd0; \n  reg dma_wr_int = 'd0; \n  reg fifo_rst = 'd0; \n  reg fifo_rst_p = 'd0; \n  reg fifo_rstn = 'd0; \n  wire dma_wready_s; \n  wire [DMA_DATA_WIDTH-1:0] dma_wdata_s; \n  always @(posedge adc_clk) begin \n  if (adc_rst == 1'b1) begin \n  adc_wovf_m <= 2'd0; \n  adc_wovf <= 1'b0; \n  end else begin \n  adc_wovf_m[0] <= dma_wovf | fifo_wovf; \n  adc_wovf_m[1] <= adc_wovf_m[0]; \n  adc_wovf <= adc_wovf_m[1]; \n  end \n  end \n  assign fifo_wr = adc_wr; \n  genvar m; \n  generate \n  for (m = 0; m < ADC_DATA_WIDTH; m = m + 1) begin: g_wdata \n  assign fifo_wdata[m] = adc_wdata[(ADC_DATA_WIDTH-1)-m]; \n  end \n  endgenerate \n  assign dma_wready_s = (DMA_READY_ENABLE == 0) ? 1'b1 : dma_wready; \n  assign fifo_rd = ~fifo_rempty & dma_wready_s; \n  always @(posedge dma_clk) begin \n  dma_wr_int <= fifo_rd; \n  end \n  genvar s; \n  generate \n  for (s = 0; s < DMA_DATA_WIDTH; s = s + 1) begin: g_rdata \n  assign dma_wdata_s[s] = fifo_rdata[(DMA_DATA_WIDTH-1)-s]; \n  end \n  endgenerate \n  always @(posedge dma_clk or posedge adc_rst) begin \n  if (adc_rst == 1'b1) begin \n  fifo_rst_p <= 1'd1; \n  fifo_rst <= 1'd1; \n  fifo_rstn <= 1'd0; \n  end else begin \n  fifo_rst_p <= 1'b0; \n  fifo_rst <= fifo_rst_p; \n  fifo_rstn <= ~fifo_rst_p; \n  end \n  end \n ad_axis_inf_rx #(.DATA_WIDTH(DMA_DATA_WIDTH)) i_axis_inf (.clk (dma_clk),.rst (fifo_rst),.valid (dma_wr_int),.last (1'd0),.data (dma_wdata_s),.inf_valid (dma_wr),.inf_last (),.inf_data (dma_wdata),.inf_ready (dma_wready_s)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is designed to interface with a DAC. It takes input signals aclk, ddr_clk, wrt_clk, locked, and s_axis_tvalid, and provides output signals dac_clk, dac_rst, dac_sel, dac_wrt, dac_dat, and s_axis_tready. \n\nThe module contains registers and wires for internal signal manipulation, and uses ODDR instances to control the DAC signals based on the input data and clock signals. The module also includes logic to generate the s_axis_tready signal. Overall, this module acts as an interface between the input signals and the DAC, managing the data and clocking for the DAC based on the input conditions.\n\n Module header:\n\nmodule axis_red_pitaya_dac # (parameter integer DAC_DATA_WIDTH = 14,parameter integer AXIS_TDATA_WIDTH = 32) (input wire aclk,input wire ddr_clk,input wire wrt_clk,input wire locked,output wire dac_clk,output wire dac_rst,output wire dac_sel,output wire dac_wrt,output wire [DAC_DATA_WIDTH-1:0] dac_dat,output wire s_axis_tready,input wire [AXIS_TDATA_WIDTH-1:0] s_axis_tdata,input wire s_axis_tvalid);\n [/INST]\n", "output": "reg [DAC_DATA_WIDTH-1:0] int_dat_a_reg; \n  reg [DAC_DATA_WIDTH-1:0] int_dat_b_reg; \n  reg int_rst_reg; \n  wire [DAC_DATA_WIDTH-1:0] int_dat_a_wire; \n  wire [DAC_DATA_WIDTH-1:0] int_dat_b_wire; \n  assign int_dat_a_wire = s_axis_tdata[DAC_DATA_WIDTH-1:0]; \n  assign int_dat_b_wire = s_axis_tdata[AXIS_TDATA_WIDTH/2+DAC_DATA_WIDTH-1:AXIS_TDATA_WIDTH/2]; \n  genvar j; \n  always @(posedge aclk) \n  begin \n  if(~locked | ~s_axis_tvalid) \n  begin \n  int_dat_a_reg <= {(DAC_DATA_WIDTH){1'b0}}; \n  int_dat_b_reg <= {(DAC_DATA_WIDTH){1'b0}}; \n  end \n  else \n  begin \n  int_dat_a_reg <= {int_dat_a_wire[DAC_DATA_WIDTH-1], ~int_dat_a_wire[DAC_DATA_WIDTH-2:0]}; \n  int_dat_b_reg <= {int_dat_b_wire[DAC_DATA_WIDTH-1], ~int_dat_b_wire[DAC_DATA_WIDTH-2:0]}; \n  end \n  int_rst_reg <= ~locked | ~s_axis_tvalid; \n  end \n ODDR #(.DDR_CLK_EDGE(\"SAME_EDGE\"),.INIT(1'b0)) ODDR_rst (.Q(dac_rst),.D1(int_rst_reg),.D2(int_rst_reg),.C(aclk),.CE(1'b1),.R(1'b0),.S(1'b0)); \n ODDR #(.DDR_CLK_EDGE(\"SAME_EDGE\"),.INIT(1'b0)) ODDR_sel (.Q(dac_sel),.D1(1'b1),.D2(1'b0),.C(aclk),.CE(1'b1),.R(1'b0),.S(1'b0)); \n ODDR #(.DDR_CLK_EDGE(\"SAME_EDGE\"),.INIT(1'b0)) ODDR_wrt (.Q(dac_wrt),.D1(1'b1),.D2(1'b0),.C(wrt_clk),.CE(1'b1),.R(1'b0),.S(1'b0)); \n ODDR #(.DDR_CLK_EDGE(\"SAME_EDGE\"),.INIT(1'b0)) ODDR_clk (.Q(dac_clk),.D1(1'b1),.D2(1'b0),.C(ddr_clk),.CE(1'b1),.R(1'b0),.S(1'b0)); \n  generate \n  for(j = 0; j < DAC_DATA_WIDTH; j = j + 1) \n  begin : DAC_DAT \n ODDR #(.DDR_CLK_EDGE(\"SAME_EDGE\"),.INIT(1'b0)) ODDR_inst (.Q(dac_dat[j]),.D1(int_dat_b_reg[j]),.D2(int_dat_a_reg[j]),.C(aclk),.CE(1'b1),.R(1'b0),.S(1'b0)); \n  end \n  endgenerate \n  assign s_axis_tready = 1'b1; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \\$_SR_PP_ implements a basic SR latch. It has two inputs, S and R, and one output, Q. The Q output is set to 1 when the input R is 1, and it is set to 0 when the input S is 1. This module operates on the positive edge of both S and R.\n\n Module header:\n\nmodule \\$_SR_PP_ (S, R, Q);\n [/INST]\n", "output": "input S, R; \n output reg Q; \n always @(posedge S, posedge R) begin \n  if (R == 1) \n  Q <= 0; \n  else if (S == 1) \n  Q <= 1; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a reset logic for a digital system. It generates various reset signals based on the inputs and clock signals. The `init_in_progress` signal indicates the initialization process, and the `zxbus_rst_n`, `rom_rst_n`, `z80_rst_n`, `z80_busrq_n`, and `z80_busak_n` signals are driven based on the reset conditions. The module includes power-on reset counters, control for the Z80 processor reset, and handles initialization sequences. The reset logic is synchronized with the clock signals and follows specific state transitions based on the reset conditions.\n\n Module header:\n\nmodule reset (input wire clk_fpga,input wire clk_24mhz,input wire init,output reg init_in_progress,output wire zxbus_rst_n,output reg rom_rst_n,output reg z80_rst_n,output reg z80_busrq_n,input wire z80_busak_n);\n [/INST]\n", "output": "parameter RST_CNT_SIZE = 8; \n  reg [RST_CNT_SIZE:0] poweron_rst_cnt; \n  reg [RST_CNT_SIZE:0] rz_rst_cnt; \n  wire poweron_rst_n = poweron_rst_cnt[RST_CNT_SIZE]; \n  wire rz_rst_n = rz_rst_cnt[RST_CNT_SIZE]; \n  reg z80_rst2; \n  reg [1:0] z80_halted; \n  initial \n  poweron_rst_cnt <= 'd0; \n  always @(posedge clk_24mhz) \n  if( !poweron_rst_n ) \n  poweron_rst_cnt <= poweron_rst_cnt + 'd1; \n  assign zxbus_rst_n = poweron_rst_n; \n  always @(posedge clk_24mhz, negedge poweron_rst_n) \n  if( !poweron_rst_n ) \n  rz_rst_cnt <= 'd0; \n  else if( init ) \n  rz_rst_cnt <= 'd0; \n  else if( !rz_rst_n ) \n  rz_rst_cnt <= rz_rst_cnt + 'd1; \n  always @(posedge clk_fpga, negedge rz_rst_n) \n  if( !rz_rst_n ) \n  begin \n  z80_rst_n <= 1'b0; \n  z80_rst2 <= 1'b0; \n  end \n  else \n  begin \n  z80_rst_n <= z80_rst2; \n  z80_rst2 <= 1'b1; \n  end \n  always @(posedge clk_fpga, negedge z80_rst_n) \n  if( !z80_rst_n ) \n  z80_busrq_n <= 1'b1; \n  else \n  z80_busrq_n <= 1'b0; \n  always @(posedge clk_24mhz, negedge rz_rst_n) \n  if( !rz_rst_n ) \n  z80_halted <= 2'b00; \n  else \n  z80_halted[1:0] <= {z80_halted[0], ~z80_busak_n}; \n  always @(posedge clk_24mhz, negedge rz_rst_n) \n  if( !rz_rst_n ) \n  begin \n  rom_rst_n <= 1'b0; \n  init_in_progress <= 1'b1; \n  end \n  else if( z80_halted[1] ) \n  begin \n  rom_rst_n <= 1'b1; \n  init_in_progress <= 1'b0; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module implements a 2-to-1 multiplexer, where the output Y is selected between inputs A and B based on the control signal S. If S is high, the output Y is the value of input B, otherwise the output Y is the value of input A.\n\n Module header:\n\nmodule MX2 (input A, B, S,output Y);\n [/INST]\n", "output": "assign Y = S ? B : A; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, \"slaveSelect,\" generates a slave select signal based on the input signals rst, clk, transmit, and done. The ss output is initially set to 1 and is controlled by a clock-triggered process. When rst is high, ss is set to 1. When transmit is high, ss is set to 0. When done is high, ss is set back to 1.\n\n Module header:\n\nmodule slaveSelect(rst,clk,transmit,done,ss);\n [/INST]\n", "output": "input rst; \n  input clk; \n  input transmit; \n  input done; \n  output ss; \n  reg ss = 1'b1; \n  always @(posedge clk) \n  begin: ssprocess \n  begin \n  if (rst == 1'b1) \n  ss <= 1'b1; \n  else if (transmit == 1'b1) \n  ss <= 1'b0; \n  else if (done == 1'b1) \n  ss <= 1'b1; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is designed to interface with the MPC4922 digital-to-analog converter. It takes input signals for the clock, reset, chip select, clock pin, data pin, output value, axis, and strobe. The module includes parameters for gain, buffer, and shutdown. \n\nThe module utilizes registers for the command and bits, and assigns the ready signal based on the reset and bits value. The chip select pin is assigned based on the ready signal. The data pin is assigned based on the most significant bit of the command.\n\nThe module uses clocked logic to handle the reset, strobe, and clock pin generation. On reset, the bits and clock pin are set to zero. When a strobe signal is received, the module sets the command, bits, and clock pin accordingly. During each clock cycle, the module shifts the command bits and updates the clock pin until all bits are shifted out.\n\nIn summary, this Verilog module provides the necessary logic to control the MPC4922 digital-to-analog converter based on the input signals and parameters.\n\n Module header:\n\nmodule mpc4922(input clk,input reset,output cs_pin,output clk_pin,output data_pin,input [11:0] value,input axis,input strobe,output ready);\n [/INST]\n", "output": "parameter GAIN = 1'b1; \n  parameter BUFFERED = 1'b1; \n  parameter SHUTDOWN = 1'b1; \n  reg [15:0] cmd; \n  reg [4:0] bits; \n  assign ready = !reset && bits == 0; \n  assign cs_pin = ready; \n  assign data_pin = cmd[15]; \n  always @(posedge clk) \n  begin \n  if (reset) begin \n  bits <= 0; \n  clk_pin <= 0; \n  end else \n  if (strobe) begin \n  cmd <= { axis, BUFFERED, GAIN, SHUTDOWN, value }; \n  bits <= 16; \n  clk_pin <= 0; \n  end else \n  if (bits != 0) begin \n  if (clk_pin) begin \n  cmd <= { cmd[14:0], 1'b0 }; \n  clk_pin <= 0; \n  bits <= bits - 1; \n  end else begin \n  clk_pin <= 1; \n  end \n  end else begin \n  clk_pin <= 0; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a D flip-flop with set and reset capability. It has inputs C (clock), S (set), R (reset), E (enable), and D (data), and output Q. The flip-flop is triggered on the positive edge of the clock signal. When the reset signal R is low, the output Q is set to 0. When the set signal S is high, the output Q is set to 1. When the enable signal E is high, the output Q is set to the value of the data input D.\n\n Module header:\n\nmodule \\$_DFFSRE_PPNP_ (C, S, R, E, D, Q);\n [/INST]\n", "output": "input C, S, R, E, D; \n output reg Q; \n always @(posedge C, posedge S, negedge R) begin \n  if (R == 0) \n  Q <= 0; \n  else if (S == 1) \n  Q <= 1; \n  else if (E == 1) \n  Q <= D; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a pipeline with 4 latches. It takes in a clock signal and three 32-bit data inputs. It outputs a 32-bit data, a 2-bit select signal, a 32-bit bus signal, and a 2-bit flag signal. On the rising edge of the clock, the module updates the output values with the input values. The output values are updated with the corresponding input values, creating a pipelined data flow.\n\n Module header:\n\nmodule pipeline_4_latch(clk, dbusWire2, DselectWire3, bbusWire3, lwSwFlag3, dbusWire3, DselectWire4,bbusWire4,lwSwFlag4);\n [/INST]\n", "output": "input clk; \n  input [31:0] dbusWire2, DselectWire3, bbusWire3; \n  input [1:0] lwSwFlag3; \n  output [31:0] dbusWire3, DselectWire4, bbusWire4; \n  output [1:0] lwSwFlag4; \n  reg [31:0] dbusWire3, DselectWire4, bbusWire4; \n  reg [1:0] lwSwFlag4; \n  always @(posedge clk) begin \n  dbusWire3 = dbusWire2; \n  DselectWire4 = DselectWire3; \n  bbusWire4 = bbusWire3; \n  lwSwFlag4 = lwSwFlag3; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a state machine for a control system. It uses various input signals such as door sensor, override sensor, overload sensor, and timer expiration to transition between different states. The module also handles LED outputs to indicate the current state of the system. The behavior is controlled by the clock signal, and it includes a reset functionality. The module uses a flip-flop to generate the clock signal and has initial blocks to set initial values for the input signals. The actual state transitions and LED outputs are determined based on the sequence of input actions and sensor signals.\n\n Module header:\n\nmodule maquina_estados_sim;\n [/INST]\n", "output": "reg clk; \n  reg reset; \n  reg [1:0] accion; \n  reg sensor_puerta; \n  reg sensor_sobrepeso; \n  reg t_expired; \n  wire [3:0] state; \n  wire restart_timer; \n  wire start_timer; \n  wire habilita_verificador; \n  wire inicia_Registro_Solicitudes; \n  wire subiendo_LED; \n  wire bajando_LED; \n  wire freno_act_LED; \n  wire motor_act_LED; \n  wire puerta_abierta_LED; \n  wire puerta_cerrada_LED; \n  wire sensor_puerta_LED; \n  wire sensor_sobrepeso_LED; \n  wire ready; \n MaquinaEstados uut (.clk(clk),.reset(reset),.state(state),.accion(accion),.sensor_puerta(sensor_puerta),.sensor_sobrepeso(sensor_sobrepeso),.t_expired(t_expired),.restart_timer(restart_timer),.start_timer(start_timer),.habilita_verificador(habilita_verificador),.inicia_Registro_Solicitudes(inicia_Registro_Solicitudes),.subiendo_LED(subiendo_LED),.bajando_LED(bajando_LED),.freno_act_LED(freno_act_LED),.motor_act_LED(motor_act_LED),.puerta_abierta_LED(puerta_abierta_LED),.puerta_cerrada_LED(puerta_cerrada_LED),.sensor_puerta_LED(sensor_puerta_LED),.sensor_sobrepeso_LED(sensor_sobrepeso_LED),.ready(ready)); \n  always \n  begin \n  #5 clk = ~clk; \n  end \n  initial begin \n  reset = 1; \n  clk = 1; \n  accion = 0; \n  sensor_puerta = 0; \n  sensor_sobrepeso = 0; \n  t_expired = 0; \n  #10; \n  reset = 0; \n  #10; \n  accion = 2'b10; \n  #10; \n  accion = 2'b10; \n  #10; \n  accion = 2'b01; \n  #10; \n  accion = 2'b00; \n  #10; \n  accion = 2'b00; \n  #10; \n  accion = 2'b10; \n  #10; \n  accion = 2'b01; \n  #10; \n  accion = 2'b11; \n  sensor_puerta = 1'b1; \n  #10; \n  accion = 2'b11; \n  sensor_puerta = 1'b0; \n  sensor_sobrepeso = 1'b1; \n  #10; \n  accion = 2'b11; \n  sensor_sobrepeso = 1'b0; \n  t_expired = 1'b1; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a simple register file with a 2-bit address input, clock input, data input, and reset input. The module has an output register to store the read data. It also contains internal wires for clock enable, data input, and a multiplexer output for reading. The clock enable is always assigned to 1, and the read multiplexer output is calculated based on the address and data input. The read data is updated on the rising edge of the clock or when the reset signal is de-asserted, and the data input is directly assigned from the input port.\n\n Module header:\n\nmodule nios_system_regfile_reg1 (address,clk,in_port,reset_n,readdata);\n [/INST]\n", "output": "output [ 31: 0] readdata; \n  input [ 1: 0] address; \n  input clk; \n  input [ 31: 0] in_port; \n  input reset_n; \n  wire clk_en; \n  wire [ 31: 0] data_in; \n  wire [ 31: 0] read_mux_out; \n  reg [ 31: 0] readdata; \n  assign clk_en = 1; \n  assign read_mux_out = {32 {(address == 0)}} & data_in; \n  always @(posedge clk or negedge reset_n) \n  begin \n  if (reset_n == 0) \n  readdata <= 0; \n  else if (clk_en) \n  readdata <= {32'b0 | read_mux_out}; \n  end \n  assign data_in = in_port; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module core_mem_wb implements a synchronous register that stores various control signals and data related to memory access and write-back operations in a pipelined processor. It utilizes the clock signal to update the outputs based on the input signals. The module also includes a reset functionality to initialize the control signals and data to their default values.\n\n Module header:\n\nmodule core_mem_wb(clk,rst,regwrite,memtoreg,aluresult,read_memdata,valid_read_memdata,dest_reg,wb_regwrite,wb_memtoreg,wb_aluresult,wb_read_memdata,wb_dest_reg);\n [/INST]\n", "output": "input clk; \n input rst; \n input regwrite; \n input memtoreg; \n input [31:0] aluresult; \n input [31:0] read_memdata; \n input valid_read_memdata; \n input [4:0] dest_reg; \n output wb_regwrite; \n output wb_memtoreg; \n output [31:0] wb_aluresult; \n output [31:0] wb_read_memdata; \n output [4:0] wb_dest_reg; \n reg wb_regwrite; \n reg wb_memtoreg; \n reg [31:0] wb_aluresult; \n reg [31:0] wb_read_memdata; \n reg [4:0] wb_dest_reg; \n always@(posedge clk) \n begin \n  if(rst) \n  begin \n  wb_regwrite<=1'b0; \n  wb_memtoreg<=1'b0; \n  wb_aluresult<=32'h0000; \n  wb_read_memdata<=32'h0000; \n  wb_dest_reg<=5'b00000; \n  end \n  else if(valid_read_memdata) \n  begin \n  wb_regwrite<=regwrite; \n  wb_memtoreg<=memtoreg; \n  wb_aluresult<=aluresult; \n  wb_read_memdata<=read_memdata; \n  wb_dest_reg<=dest_reg; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module takes two 5-bit inputs A and B and an enable signal and selects between the inputs based on the enable signal, assigning the selected input to the 5-bit output O.\n\n Module header:\n\nmodule mux_2_to_1_5(input [4:0] A,B,input enable,output reg[4:0] O);\n [/INST]\n", "output": "always @* begin \n  if (enable) O <= B; \n  else O <= A; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a priority-based arbiter that determines which queue entry to service first. It takes inputs representing the valid queue entries for different components and the request signals for the arithmetic logic unit (ALU) and load-store unit (LSU). The module uses these inputs to prioritize and select the next entry to be serviced. The outputs include the serviced queue entries and the select signals for the execution unit's vector/general-purpose register (VGPR/SGPR).\n\nThe priority encoder assigns priorities to the valid entries, and the circular shift ensures that the highest priority entry is selected for service. The module also includes a decoder to convert the priority encoding back into the specific entry to be serviced. Additionally, there are dummy entries and priorities to ensure proper functioning of the priority scheme.\n\n Module header:\n\nmodule rfa(simd0_queue_entry_serviced, simd1_queue_entry_serviced,simd2_queue_entry_serviced, simd3_queue_entry_serviced,simf0_queue_entry_serviced, simf1_queue_entry_serviced,simf2_queue_entry_serviced, simf3_queue_entry_serviced,execvgprsgpr_select_fu,lsu_wait,clk, rst, simd0_queue_entry_valid, simd1_queue_entry_valid,simd2_queue_entry_valid, simd3_queue_entry_valid,simf0_queue_entry_valid, simf1_queue_entry_valid,simf2_queue_entry_valid, simf3_queue_entry_valid, lsu_dest_wr_req,salu_req);\n [/INST]\n", "output": "input clk; \n  input rst; \n  input salu_req; \n  output lsu_wait; \n  input simd0_queue_entry_valid, simd1_queue_entry_valid, simd2_queue_entry_valid, \n  simd3_queue_entry_valid, simf0_queue_entry_valid, simf1_queue_entry_valid, \n  simf2_queue_entry_valid, simf3_queue_entry_valid, lsu_dest_wr_req; \n  output simd0_queue_entry_serviced, simd1_queue_entry_serviced, simd2_queue_entry_serviced, \n  simd3_queue_entry_serviced, simf0_queue_entry_serviced, simf1_queue_entry_serviced, \n  simf2_queue_entry_serviced, simf3_queue_entry_serviced; \n  output [15:0] execvgprsgpr_select_fu; \n  wire [15:0] entry_valid; \n  wire [15:0] entry_serviced; \n  wire [15:0] shifted_valid; \n  wire [3:0] highest_priority, next_highest_priority; \n  wire [3:0] cur_priority; \n  wire [31:0] dummy_entry_serviced; \n  wire [31:0] dummy_next_highest_priority; \n  wire lsu_wait; \n  wire lsu_wr_req_lp; \n  assign entry_valid = salu_req ? {8'd0, simf3_queue_entry_valid, simf2_queue_entry_valid, \n  simf1_queue_entry_valid, simf0_queue_entry_valid, \n  simd3_queue_entry_valid, simd2_queue_entry_valid, \n  simd1_queue_entry_valid, simd0_queue_entry_valid} & \n  {16{~salu_req}}:{8'd0, simf3_queue_entry_valid, simf2_queue_entry_valid, \n  simf1_queue_entry_valid, simf0_queue_entry_valid, \n  simd3_queue_entry_valid, simd2_queue_entry_valid, \n  simd1_queue_entry_valid, simd0_queue_entry_valid} & \n {16{~lsu_dest_wr_req}}; \n  assign lsu_wr_req_lp = salu_req ? 1'b0:lsu_dest_wr_req; \n  assign lsu_wait = salu_req; \n  assign {simf3_queue_entry_serviced, simf2_queue_entry_serviced, \n  simf1_queue_entry_serviced, simf0_queue_entry_serviced, \n  simd3_queue_entry_serviced, simd2_queue_entry_serviced, \n  simd1_queue_entry_serviced, simd0_queue_entry_serviced} \n  = entry_serviced[7:0]; \n  assign execvgprsgpr_select_fu = { {6{1'b0}}, salu_req, lsu_wr_req_lp, entry_serviced[7:0]}; \n  dff_en high_pr_flop[3:0] \n (highest_priority,next_highest_priority,|entry_valid,clk, rst); \n circular_shift circ_shift (.out(shifted_valid),.in(entry_valid),.shift_amount(highest_priority)); \n priority_encoder_16_to_4 priority_encoder (.out(cur_priority),.in(shifted_valid),.enable(1'b1)); \n  assign dummy_entry_serviced = cur_priority + highest_priority; \n  assign dummy_next_highest_priority = dummy_entry_serviced + 1; \n  assign next_highest_priority = dummy_next_highest_priority[3:0]; \n  decoder_param_en \n  #(.BITS(4), .SIZE(16)) \n  entry_serviced_decoder \n (.out(entry_serviced), .in(dummy_entry_serviced[3:0]),.en(|entry_valid)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a status flag generator that generates the empty and out flags based on various inputs. The empty flag is driven by the ram_empty_i signal, and the out flag is driven by the ram_empty_fb_i signal. The module also contains a comparator component that compares the v1_reg and v1_reg_0 inputs and sets the comp1 signal accordingly. The E and p_0_out outputs are driven by logic functions of the inputs. Additionally, the module includes flip-flops to store intermediate values and synchronize them with the rd_clk signal.\n\n Module header:\n\nmodule decalper_eb_ot_sdeen_pot_pi_dehcac_xnilix_rd_status_flags_as (empty,out,E,p_0_out,v1_reg,v1_reg_0,rd_clk,AR,rd_en);\n [/INST]\n", "output": "output empty; \n  output out; \n  output [0:0]E; \n  output p_0_out; \n  input [4:0]v1_reg; \n  input [4:0]v1_reg_0; \n  input rd_clk; \n  input [0:0]AR; \n  input rd_en; \n  wire [0:0]AR; \n  wire [0:0]E; \n  wire c0_n_0; \n  wire comp1; \n  wire p_0_out; \n  (* DONT_TOUCH *) wire ram_empty_fb_i; \n  (* DONT_TOUCH *) wire ram_empty_i; \n  wire rd_clk; \n  wire rd_en; \n  wire [4:0]v1_reg; \n  wire [4:0]v1_reg_0; \n  assign empty = ram_empty_i; \n  assign out = ram_empty_fb_i; \n  decalper_eb_ot_sdeen_pot_pi_dehcac_xnilix_compare_4 c0 \n (.comp1(comp1),.out(ram_empty_fb_i),.ram_empty_fb_i_reg(c0_n_0),.rd_en(rd_en),.v1_reg(v1_reg)); \n  decalper_eb_ot_sdeen_pot_pi_dehcac_xnilix_compare_5 c1 \n (.comp1(comp1),.v1_reg_0(v1_reg_0)); \n LUT2 #(.INIT(4'h2)) \n  \\gc0.count_d1[9]_i_1 \n (.I0(rd_en),.I1(ram_empty_fb_i),.O(E)); \n LUT2 #(.INIT(4'hB)) \n  \\gdiff.diff_pntr_pad[4]_i_2 \n (.I0(ram_empty_fb_i),.I1(rd_en),.O(p_0_out)); \n  (* DONT_TOUCH *) \n  (* KEEP = \"yes\" *) \n  (* equivalent_register_removal = \"no\" *) \n FDPE #(.INIT(1'b1)) \n  ram_empty_fb_i_reg \n (.C(rd_clk),.CE(1'b1),.D(c0_n_0),.PRE(AR),.Q(ram_empty_fb_i)); \n  (* DONT_TOUCH *) \n  (* KEEP = \"yes\" *) \n  (* equivalent_register_removal = \"no\" *) \n FDPE #(.INIT(1'b1)) \n  ram_empty_i_reg \n (.C(rd_clk),.CE(1'b1),.D(c0_n_0),.PRE(AR),.Q(ram_empty_i)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module includes a combinational logic circuit with multiple inputs and outputs. It also contains assignments for the input and output wires. The module instantiates several instances of different combinational logic circuits and connects their inputs and outputs to the module's input and output signals. The combinational logic circuits perform various operations based on the input signals and provide the output signals.\n\n Module header:\n\nmodule vc3c498 (input [7:0] v45c6ee,input [7:0] v20212e,input vb9cfc3,output v4642b6,output [7:0] veeaa8e);\n [/INST]\n", "output": "wire w0; \n  wire w1; \n  wire [0:7] w2; \n  wire [0:7] w3; \n  wire [0:7] w4; \n  wire [0:3] w5; \n  wire [0:3] w6; \n  wire w7; \n  wire [0:3] w8; \n  wire [0:3] w9; \n  wire [0:3] w10; \n  wire [0:3] w11; \n  assign w1 = vb9cfc3; \n  assign w2 = v45c6ee; \n  assign w3 = v20212e; \n  assign veeaa8e = w4; \n  assign v4642b6 = w7; \n v6bdcd9 v8d795a (.vcc8c7c(w3),.v651522(w10),.v2cc41f(w11)); \n v6bdcd9 v23dbc5 (.vcc8c7c(w2),.v651522(w8),.v2cc41f(w9)); \n vafb28f vef3a58 (.va9ac17(w4),.v3c88fc(w5),.v515fe7(w6)); \n va1ce30 v0ff71a (.v4642b6(w0),.vb9cfc3(w1),.v817794(w5),.v0550b6(w9),.v24708e(w11)); \n va1ce30 v12f94f (.vb9cfc3(w0),.v817794(w6),.v4642b6(w7),.v0550b6(w8),.v24708e(w10)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a sequential logic circuit that has a register `qr` with `WIDTH` number of bits. On the positive edge of the clock signal `clk`, the input `d` is loaded into the register. The output `q` is then assigned the value of the register `qr`. This essentially creates a register that stores the value of input `d` when the clock signal transitions from 1 to 0.\n\n Module header:\n\nmodule llq (clk, d, q);\n [/INST]\n", "output": "parameter WIDTH = 32; \n  input clk; \n  input [WIDTH-1:0] d; \n  output [WIDTH-1:0] q; \n  reg [WIDTH-1:0] qr; \n  always @(clk or d) \n  if (clk == 1'b0) \n  qr <= d; \n  assign q = qr; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module simply takes an input signal and directly assigns it to the output signal. It serves as a simple pass-through, where the input is directly transmitted to the output without any modification.\n\n Module header:\n\nmodule lut_input (in, out);\n [/INST]\n", "output": "input in; \n  output out; \n  assign out = in; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a non-resettable positive edge-triggered D flip-flop with a single bit width parameter. When the reset signal is asserted, the output q is set to all ones; otherwise, q is updated with the input din on the positive edge of the clock signal.\n\n Module header:\n\nmodule dffr_ns_r1 (din, clk, rst, q);\n [/INST]\n", "output": "parameter SIZE = 1; \n input [SIZE-1:0] din ; \n input clk ; \n input rst ; \n output [SIZE-1:0] q ; \n reg [SIZE-1:0] q ; \n always @ (posedge clk) \n  q[SIZE-1:0] <= rst ? {SIZE{1'b1}} : din[SIZE-1:0]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module pads the input with 0s based on the value of the byte_num input. If byte_num is 0, the output is set to 32'h1000000. If byte_num is 1, the output is set to {in[31:24], 24'h010000}. If byte_num is 2, the output is set to {in[31:16], 16'h0100}. If byte_num is 3, the output is set to {in[31:8], 8'h01}.\n\n Module header:\n\nmodule padder1(in, byte_num, out);\n [/INST]\n", "output": "input [31:0] in; \n  input [1:0] byte_num; \n  output reg [31:0] out; \n  always @ (*) \n  case (byte_num) \n  0: out = 32'h1000000; \n  1: out = {in[31:24], 24'h010000}; \n  2: out = {in[31:16], 16'h0100}; \n  3: out = {in[31:8], 8'h01}; \n  endcase \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module `axi_hdmi_rx_tpm` is designed to monitor and manage the incoming HDMI data. It utilizes the `hdmi_clk`, `hdmi_sof`, `hdmi_de`, and `hdmi_data` inputs to track the HDMI data stream and detect any out-of-sync (OOS) conditions.\n\nThe `hdmi_tpm_oos` output indicates the OOS condition, which is determined based on the `hdmi_tpm_lr_mismatch_s` and `hdmi_tpm_fr_mismatch_s` signals. These signals are generated by comparing specific portions of the incoming `hdmi_data` with the internal `hdmi_tpm_data`.\n\nThe module maintains an internal state represented by `hdmi_tpm_data`, `hdmi_tpm_lr_mismatch`, and `hdmi_tpm_fr_mismatch`. On each rising edge of the `hdmi_clk`, the module updates these internal state variables based on the values of `hdmi_sof` and `hdmi_de`.\n\nWhen `hdmi_sof` is asserted, the internal state variables are reset, and when `hdmi_de` is asserted, the internal state variables are incremented and updated based on the comparison results.\n\nThis module essentially provides a mechanism for monitoring the incoming HDMI data stream and detecting synchronization issues.\n\n Module header:\n\nmodule axi_hdmi_rx_tpm (hdmi_clk,hdmi_sof,hdmi_de,hdmi_data,hdmi_tpm_oos);\n [/INST]\n", "output": "input hdmi_clk; \n  input hdmi_sof; \n  input hdmi_de; \n  input [15:0] hdmi_data; \n  output hdmi_tpm_oos; \n  wire [15:0] hdmi_tpm_lr_data_s; \n  wire hdmi_tpm_lr_mismatch_s; \n  wire [15:0] hdmi_tpm_fr_data_s; \n  wire hdmi_tpm_fr_mismatch_s; \n  reg [15:0] hdmi_tpm_data = 'd0; \n  reg hdmi_tpm_lr_mismatch = 'd0; \n  reg hdmi_tpm_fr_mismatch = 'd0; \n  reg hdmi_tpm_oos = 'd0; \n  assign hdmi_tpm_lr_data_s[15:8] = (hdmi_tpm_data[15:8] < 8'h10) ? 8'h10 : \n  ((hdmi_tpm_data[15:8] > 8'heb) ? 8'heb : hdmi_tpm_data[15:8]); \n  assign hdmi_tpm_lr_data_s[ 7:0] = (hdmi_tpm_data[ 7:0] < 8'h10) ? 8'h10 : \n  ((hdmi_tpm_data[ 7:0] > 8'heb) ? 8'heb : hdmi_tpm_data[ 7:0]); \n  assign hdmi_tpm_lr_mismatch_s = (hdmi_tpm_lr_data_s == hdmi_data) ? 1'b0 : 1'b1; \n  assign hdmi_tpm_fr_data_s[15:8] = (hdmi_tpm_data[15:8] < 8'h01) ? 8'h01 : \n  ((hdmi_tpm_data[15:8] > 8'hfe) ? 8'hfe : hdmi_tpm_data[15:8]); \n  assign hdmi_tpm_fr_data_s[ 7:0] = (hdmi_tpm_data[ 7:0] < 8'h01) ? 8'h01 : \n  ((hdmi_tpm_data[ 7:0] > 8'hfe) ? 8'hfe : hdmi_tpm_data[ 7:0]); \n  assign hdmi_tpm_fr_mismatch_s = (hdmi_tpm_fr_data_s == hdmi_data) ? 1'b0 : 1'b1; \n  always @(posedge hdmi_clk) begin \n  if (hdmi_sof == 1'b1) begin \n  hdmi_tpm_data <= 16'd0; \n  hdmi_tpm_lr_mismatch <= 1'd0; \n  hdmi_tpm_fr_mismatch <= 1'd0; \n  hdmi_tpm_oos <= hdmi_tpm_lr_mismatch & hdmi_tpm_fr_mismatch; \n  end else if (hdmi_de == 1'b1) begin \n  hdmi_tpm_data <= hdmi_tpm_data + 1'b1; \n  hdmi_tpm_lr_mismatch <= hdmi_tpm_lr_mismatch | hdmi_tpm_lr_mismatch_s; \n  hdmi_tpm_fr_mismatch <= hdmi_tpm_fr_mismatch | hdmi_tpm_fr_mismatch_s; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a synchronizer for input data, ensuring that it is properly synchronized with the clock signal. It includes a parameter for data width, and utilizes registers for storing synchronized and output data. The synchronization is triggered on the positive edge of the clock signal or the reset signal. When the reset is asserted, the synchronized data is initialized to all zeros. Otherwise, the synchronized data is updated with the input and then assigned to the output.\n\n Module header:\n\nmodule synchronizer (out,in, clk, reset);\n [/INST]\n", "output": "parameter DW = 32; \n  input [DW-1:0] in; \n  input clk; \n  input reset; \n  output [DW-1:0] out; \n  reg [DW-1:0] sync_reg0; \n  reg [DW-1:0] out; \n  always @ (posedge clk or posedge reset) \n  if(reset) \n  begin \n  sync_reg0[DW-1:0] <= {(DW){1'b0}}; \n  out[DW-1:0] <= {(DW){1'b0}}; \n  end \n  else \n  begin \n  sync_reg0[DW-1:0] <= in[DW-1:0]; \n  out[DW-1:0] <= sync_reg0[DW-1:0]; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a simple dynamic random-access memory (DRAM) unit. It has clock, address, write enable, read enable, data input, and data output ports. The memory array is defined with a word depth parameter and is updated based on the clock signal. When the read enable is asserted, data is output from the memory at the specified address. Similarly, when the write enable is asserted, data is written into the memory at the specified address.\n\n Module header:\n\nmodule dram (clk,address,we,re,din,dout);\n [/INST]\n", "output": "input clk; \n input [6:0] address; \n input we; \n input re; \n input [7:0] din; \n output [7:0] dout; \n reg [7:0] dout; \n parameter word_depth = 70; \n reg [7:0] mem[0:word_depth-1]; \n always @(posedge clk) \n  if (re) dout <= mem[address]; \n always @(posedge clk) \n  if (we) mem[address] <= din; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes in 64-bit data and outputs the lower 32 bits. It also propagates the input valid signal to the output valid signal and outputs the input stall signal.\n\n Module header:\n\nmodule vfabric_trunc(clock, resetn,i_datain, i_datain_valid, o_datain_stall,o_dataout, i_dataout_stall, o_dataout_valid);\n [/INST]\n", "output": "parameter DATAIN_WIDTH = 64; \n parameter DATAOUT_WIDTH = 32; \n  input clock, resetn; \n  input [DATAIN_WIDTH-1:0] i_datain; \n  input i_datain_valid; \n  output o_datain_stall; \n  output [DATAOUT_WIDTH-1:0] o_dataout; \n  input i_dataout_stall; \n  output o_dataout_valid; \n  assign o_dataout = i_datain[DATAOUT_WIDTH-1:0]; \n  assign o_datain_stall = i_dataout_stall; \n  assign o_dataout_valid = i_datain_valid; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `subroutine_stack` simulates a stack used for subroutine calls and returns. It has an array `stack` to store subroutine return addresses, a `stack_pointer` to point to the top of the stack, and an output `RTS_adr` to provide the return address to the calling routine. The stack is initialized to all zeros. When a subroutine is called, the `stack_pointer` is incremented, and the current PC is stored in the stack. Conversely, when a subroutine returns, the `stack_pointer` is decremented. The `RTS_adr` output provides the return address, which is the top of the stack if the `stack_pointer` is at 0, otherwise it's the value at `stack_pointer - 1`. The module updates its state on the positive edge of the clock signal.\n\n Module header:\n\nmodule subroutine_stack(input clock,input subroutine_call,input subroutine_return,input [11:0] PC,output reg [11:0] RTS_adr);\n [/INST]\n", "output": "reg [11:0] stack [7:0]; \n  reg [2:0] stack_pointer; \n  integer i; \n  initial begin \n  for (i = 0; i < 8 ; i = i + 1) begin \n  stack[i] = 12'h00; \n  end \n  stack_pointer = 3'h0; \n  RTS_adr = 12'h00; \n  end \n  always @(posedge clock) begin \n  if (subroutine_call == 1) begin \n  stack_pointer <= stack_pointer + 1; \n  end \n  else if (subroutine_return == 1) begin \n  stack_pointer <= stack_pointer - 1; \n  end \n  if (subroutine_call == 1) begin \n  stack[stack_pointer] <= PC; \n  end \n  if (stack_pointer == 0) \n  RTS_adr <= stack[7]; \n  else \n  RTS_adr <= stack[stack_pointer - 1]; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a simple asynchronous reset implementation. It takes in a clock signal and a reset signal, and on the rising edge of the clock, it checks if the reset signal is asserted. If it is, no actions are taken. This module essentially provides a mechanism for asynchronous reset of flip-flops.\n\n Module header:\n\nmodule t_clk_twob (fastclk, reset_l);\n [/INST]\n", "output": "input fastclk; \n  input reset_l; \n  always @ (posedge fastclk) begin \n  if (reset_l) ; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a secure state machine with 7 states and 4-bit outputs. The state machine transitions based on the DigitalLDir and DigitalRDir inputs and assigns outputs based on the current state. The state transition and output assignments are determined by the current state, and the reset signal is used to set the state to S0. The module updates the state and outputs on the rising edge of the clock signal, while also considering the negative edge of the reset signal.\n\n Module header:\n\nmodule Sec5_SM(input DigitalLDir,input DigitalRDir,input clk_i,input reset_n,output reg [3:0] outputs);\n [/INST]\n", "output": "reg [2:0] state; \n  reg [2:0] state_next; \n  parameter S0 = 3'b000; \n  parameter S1 = 3'b001; \n  parameter S2 = 3'b010; \n  parameter S3 = 3'b011; \n  parameter S4 = 3'b100; \n  parameter S5 = 3'b101; \n  parameter S6 = 3'b110; \n  always @ (posedge clk_i, negedge reset_n) \n  begin \n  if(!reset_n) \n  state <= S0; \n  else \n  state <= state_next; \n  end \n  always @ (*) \n  begin \n  case(state) \n  S0: \n  begin \n  if( !DigitalLDir ) state_next <= S4; \n  else if( !DigitalRDir ) state_next <= S1; \n  else state_next <= S0; \n  end \n  S1: state_next = S2; \n  S2: state_next = S3; \n  S3: state_next = S0; \n  S4: state_next = S5; \n  S5: state_next = S6; \n  S6: state_next = S0; \n  default: state_next = S0; \n  endcase \n  end \n  always @ (*) \n  begin \n  case (state) \n  S0: \n  begin \n  outputs = 4'b0101; \n  end \n  S1: \n  begin \n  outputs = 4'b0000; \n  end \n  S2: \n  begin \n  outputs = 4'b0000; \n  end \n  S3: \n  begin \n  outputs = 4'b0100; \n  end \n  S4: \n  begin \n  outputs = 4'b0000; \n  end \n  S5: \n  begin \n  outputs = 4'b0000; \n  end \n  S6: \n  begin \n  outputs = 4'b0001; \n  end \n  default: \n  begin \n  outputs = 4'b0101; \n  end \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is designed for testing keyboard codes. It includes components for handling the PS2 keyboard interface, controlling the display, and generating a slow clock signal. The module interfaces with the CPU through the CLK100MHZ and CPU_RESETN signals. The PS2 keyboard data and clock signals are connected to PS2_DATA and PS2_CLK, respectively. The module outputs the LED display signals (LED[7:0]) and the display control signals (AN[7:0], CA, CB, CC, CD, CE, CF, CG, DP). The functionality includes interfacing with the keyboard controller, handling the keyboard driver, generating the slow clock signal, and controlling the display.\n\n Module header:\n\nmodule Prueba_codigos_teclado(input CLK100MHZ,input CPU_RESETN,input PS2_CLK,input PS2_DATA,output [7:0] LED,output [7:0] AN,output CA,CB,CC,CD,CE,CF,CG,DP);\n [/INST]\n", "output": "wire reset; \n  wire reloj_lento; \n  wire [7:0] data; \n  wire [4:0] val; \n  wire [2:0] control; \n  assign reset=~CPU_RESETN; \n teclado tec(.ps2_data(data),.val(val),.control(control),.leds (LED[7:0])); \n kbd_ms driver_tec(.clk(CLK100MHZ),.rst(reset),.kd(PS2_DATA),.kc(PS2_CLK),.new_data(data),.data_type(),.kbs_tot(),.parity_error()); \n clock_divider clock_div(.clk(CLK100MHZ),.rst(reset),.clk_div(reloj_lento)); \n display dis(.clk_display(reloj_lento),.num({24'b0,data}),.puntos(),.anodos(AN[7:0]),.segmentos({CA,CB,CC,CD,CE,CF,CG,DP})); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a JTAG interface for a processor. It includes multiple instances of a module called TYPEA, each configuring a data bit and address bit for JTAG communication. The module also includes signal assignments for clk_enable, captureDr, and REG_UPDATE. The module takes in JTAG signals and controls to configure the JTAG register and output JTAG data.\n\n Module header:\n\nmodule jtag_lm32 (input JTCK,input JTDI,output JTDO2,input JSHIFT,input JUPDATE,input JRSTN,input JCE2,input JTAGREG_ENABLE,input CONTROL_DATAN,output REG_UPDATE,input [7:0] REG_D,input [2:0] REG_ADDR_D,output [7:0] REG_Q,output [2:0] REG_ADDR_Q);\n [/INST]\n", "output": "wire [9:0] tdibus; \n TYPEA DATA_BIT0 (.CLK(JTCK),.RESET_N(JRSTN),.CLKEN(clk_enable),.TDI(JTDI),.TDO(tdibus[0]),.DATA_OUT(REG_Q[0]),.DATA_IN(REG_D[0]),.CAPTURE_DR(captureDr),.UPDATE_DR(JUPDATE)); \n TYPEA DATA_BIT1 (.CLK(JTCK),.RESET_N(JRSTN),.CLKEN(clk_enable),.TDI(tdibus[0]),.TDO(tdibus[1]),.DATA_OUT(REG_Q[1]),.DATA_IN(REG_D[1]),.CAPTURE_DR(captureDr),.UPDATE_DR(JUPDATE)); \n TYPEA DATA_BIT2 (.CLK(JTCK),.RESET_N(JRSTN),.CLKEN(clk_enable),.TDI(tdibus[1]),.TDO(tdibus[2]),.DATA_OUT(REG_Q[2]),.DATA_IN(REG_D[2]),.CAPTURE_DR(captureDr),.UPDATE_DR(JUPDATE)); \n TYPEA DATA_BIT3 (.CLK(JTCK),.RESET_N(JRSTN),.CLKEN(clk_enable),.TDI(tdibus[2]),.TDO(tdibus[3]),.DATA_OUT(REG_Q[3]),.DATA_IN(REG_D[3]),.CAPTURE_DR(captureDr),.UPDATE_DR(JUPDATE)); \n TYPEA DATA_BIT4 (.CLK(JTCK),.RESET_N(JRSTN),.CLKEN(clk_enable),.TDI(tdibus[3]),.TDO(tdibus[4]),.DATA_OUT(REG_Q[4]),.DATA_IN(REG_D[4]),.CAPTURE_DR(captureDr),.UPDATE_DR(JUPDATE)); \n TYPEA DATA_BIT5 (.CLK(JTCK),.RESET_N(JRSTN),.CLKEN(clk_enable),.TDI(tdibus[4]),.TDO(tdibus[5]),.DATA_OUT(REG_Q[5]),.DATA_IN(REG_D[5]),.CAPTURE_DR(captureDr),.UPDATE_DR(JUPDATE)); \n TYPEA DATA_BIT6 (.CLK(JTCK),.RESET_N(JRSTN),.CLKEN(clk_enable),.TDI(tdibus[5]),.TDO(tdibus[6]),.DATA_OUT(REG_Q[6]),.DATA_IN(REG_D[6]),.CAPTURE_DR(captureDr),.UPDATE_DR(JUPDATE)); \n TYPEA DATA_BIT7 (.CLK(JTCK),.RESET_N(JRSTN),.CLKEN(clk_enable),.TDI(tdibus[6]),.TDO(tdibus[7]),.DATA_OUT(REG_Q[7]),.DATA_IN(REG_D[7]),.CAPTURE_DR(captureDr),.UPDATE_DR(JUPDATE)); \n TYPEA ADDR_BIT0 (.CLK(JTCK),.RESET_N(JRSTN),.CLKEN(clk_enable),.TDI(tdibus[7]),.TDO(tdibus[8]),.DATA_OUT(REG_ADDR_Q[0]),.DATA_IN(REG_ADDR_D[0]),.CAPTURE_DR(captureDr),.UPDATE_DR(JUPDATE)); \n TYPEA ADDR_BIT1 (.CLK(JTCK),.RESET_N(JRSTN),.CLKEN(clk_enable),.TDI(tdibus[8]),.TDO(tdibus[9]),.DATA_OUT(REG_ADDR_Q[1]),.DATA_IN(REG_ADDR_D[1]),.CAPTURE_DR(captureDr),.UPDATE_DR(JUPDATE)); \n TYPEA ADDR_BIT2 (.CLK(JTCK),.RESET_N(JRSTN),.CLKEN(clk_enable),.TDI(tdibus[9]),.TDO(JTDO2),.DATA_OUT(REG_ADDR_Q[2]),.DATA_IN(REG_ADDR_D[2]),.CAPTURE_DR(captureDr),.UPDATE_DR(JUPDATE)); \n assign clk_enable = JTAGREG_ENABLE & JCE2; \n assign captureDr = !JSHIFT & JCE2; \n assign REG_UPDATE = JTAGREG_ENABLE & JUPDATE; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module, clkdiv, divides the input clock signal by a specified value div. It uses a register, r_clk_o, to generate the output clock signal, clk_o. The module also includes a counter, count, which increments with every clock cycle. When the count reaches the specified div value, the output clock signal is toggled, and the count is reset to 0. The module also includes a reset logic to set the output clock signal and count to 0 when the rst input is asserted.\n\n Module header:\n\nmodule clkdiv(input rst,input clk_i,input [15:0] div,output clk_o);\n [/INST]\n", "output": "reg r_clk_o = 1'b0; \n  reg [15:0] count = 16'h0; \n  always @(posedge clk_i) begin \n  if(rst) begin \n  r_clk_o = 1'b0; \n  count = 16'h0; \n  end \n  else begin \n  count = count + 1; \n  if(count == div) begin \n  count = 16'h0; \n  r_clk_o = ~r_clk_o; \n  end \n  end \n  end \n  assign clk_o = r_clk_o; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is designed for NaN detection. It takes two 32-bit input data streams and an operation code as input, and outputs a NaN_flag. The operation code specifies the type of comparison to be performed on the input data. The module uses a case statement to check for various NaN conditions based on the operation and the input data. If a NaN condition is detected, the NaN_flag is set to 1; otherwise, it is set to 0.\n\n Module header:\n\nmodule NaN_mod_32 (input wire [1:0] operation,input wire [31:0] data1,input wire [31:0] data2,output reg NaN_flag);\n [/INST]\n", "output": "always @* \n  begin \n  case(operation) \n  2'b00: \n  begin \n  if((data1 == 32'h7f800000) && (data2 == 32'h7f800000)) \n  NaN_flag = 1'b1; \n  else if((data1 == 32'hff800000) && (data2 == 32'hff800000)) \n  NaN_flag = 1'b1; \n  else if((data1 == 32'h7f800000) && (data2 == 32'hff800000)) \n  NaN_flag = 1'b1; \n  else if((data1 == 32'hff800000) && (data2 == 32'h7f800000)) \n  NaN_flag = 1'b1; \n  else \n  NaN_flag = 1'b0; \n  end \n  2'b01: \n  begin \n  if(data1 == 32'h7f800000) \n  NaN_flag = 1'b1; \n  else if(data1 == 32'hff800000) \n  NaN_flag = 1'b1; \n  else \n  NaN_flag = 1'b0; \n  end \n  2'b10: \n  begin \n  if((data1 == 32'h00000000) && (data2 == 32'h7f800000)) \n  NaN_flag = 1'b1; \n  else if((data1 == 32'h00000000) && (data2 == 32'hff800000)) \n  NaN_flag = 1'b1; \n  else if((data1 == 32'hff800000) && (data2 == 32'h00000000)) \n  NaN_flag = 1'b1; \n  else if((data1 == 32'h7f800000) && (data2 == 32'h00000000)) \n  NaN_flag = 1'b1; \n  else \n  NaN_flag = 1'b0; \n  end \n  default: \n  NaN_flag = 1'b0; \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, named reg32, implements a 32-bit memory block with three read ports and one write port. The memory is initialized to zeros during a reset and can be written to when wea (write enable) is asserted. The module assigns the memory outputs to the designated read ports, o_op1, o_op2, and o_op3.\n\n Module header:\n\nmodule reg32(clk,rst,wea,r1,r2,r3,w1,wdata,out1,out2,out3);\n [/INST]\n", "output": "input wire clk,rst,wea; \n  input wire [4:0] r1, r2,r3, w1; \n  input wire [31:0] wdata; \n  output wire [31:0] out1, out2, out3; \n  reg [31:0] mem [31:0]; \n  always @(posedge clk or negedge rst) \n  begin \n  if(!rst) \n  begin \n  mem[0] <=32'b0;mem[1] <=32'b0;mem[2] <=32'b0;mem[3] <=32'b0; \n  mem[4] <=32'b0;mem[5] <=32'b0;mem[6] <=32'b0;mem[7] <=32'b0; \n  mem[8] <=32'b0;mem[9] <=32'b0;mem[10]<=32'b0;mem[11]<=32'b0; \n  mem[12]<=32'b0;mem[13]<=32'b0;mem[14]<=32'b0;mem[15]<=32'b0; \n  mem[16]<=32'b0;mem[17]<=32'b0;mem[18]<=32'b0;mem[19]<=32'b0; \n  mem[20]<=32'b0;mem[21]<=32'b0;mem[22]<=32'b0;mem[23]<=32'b0; \n  mem[24]<=32'b0;mem[25]<=32'b0;mem[26]<=32'b0;mem[27]<=32'b0; \n  mem[28]<=32'b0;mem[29]<=32'b0;mem[30]<=32'b0;mem[31]<=32'b0; \n  end \n  else if(wea) \n  mem[w1]<=wdata; \n  end \n  assign o_op1=mem[r1]; \n  assign o_op2=mem[r2]; \n  assign o_op3=mem[r3]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a D flip-flop with a synchronous reset. The output Q is initialized to 0 and is updated with the input D on the falling edge of the clock. When the reset signal is asserted, Q is set to 0 regardless of the input D.\n\n Module header:\n\nmodule myDFFNR (output reg Q, input D, CLK, RESET);\n [/INST]\n", "output": "parameter [0:0] INIT = 1'b0; \n  initial Q = INIT; \n  always @(negedge CLK) begin \n  if (RESET) \n  Q <= 1'b0; \n  else \n  Q <= D; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a parameterized asynchronous FIFO (First-In-First-Out) memory queue. It has a configurable width, depth, and address width. The FIFO maintains read and write pointers, and a count of items in the queue. It has push and pop interfaces, as well as signals for valid and accept conditions.\n\nDuring a clock cycle, if the reset signal is asserted, the FIFO resets its internal state. Otherwise, if the push signal is asserted and the accept signal is asserted, the module writes the input data into the RAM at the write pointer location and increments the write pointer. If the pop signal is asserted and the valid signal is asserted, the module increments the read pointer. Additionally, the count register is incremented or decremented based on the push, pop, accept, and valid signals.\n\nThe module outputs the valid signal based on whether the count register is non-zero, and the accept signal based on whether the count register is not equal to the depth of the buffer. The data_out_o signal is assigned the data stored in the RAM at the current read pointer location.\n\n Module header:\n\nmodule dcache_if_pmem_fifo #(parameter WIDTH = 8,parameter DEPTH = 4,parameter ADDR_W = 2) (input clk_i,input rst_i,input [WIDTH-1:0] data_in_i,input push_i,input pop_i,output [WIDTH-1:0] data_out_o,output accept_o,output valid_o);\n [/INST]\n", "output": "localparam COUNT_W = ADDR_W + 1; \n reg [WIDTH-1:0] ram_q[DEPTH-1:0]; \n reg [ADDR_W-1:0] rd_ptr_q; \n reg [ADDR_W-1:0] wr_ptr_q; \n reg [COUNT_W-1:0] count_q; \n always @ (posedge clk_i or posedge rst_i) \n if (rst_i) \n begin \n  count_q <= {(COUNT_W) {1'b0}}; \n  rd_ptr_q <= {(ADDR_W) {1'b0}}; \n  wr_ptr_q <= {(ADDR_W) {1'b0}}; \n end \n else \n begin \n  if (push_i & accept_o) \n  begin \n  ram_q[wr_ptr_q] <= data_in_i; \n  wr_ptr_q <= wr_ptr_q + 1; \n  end \n  if (pop_i & valid_o) \n  rd_ptr_q <= rd_ptr_q + 1; \n  if ((push_i & accept_o) & ~(pop_i & valid_o)) \n  count_q <= count_q + 1; \n  else if (~(push_i & accept_o) & (pop_i & valid_o)) \n  count_q <= count_q - 1; \n end \n assign valid_o = (count_q != 0); \n assign accept_o = (count_q != DEPTH); \n assign data_out_o = ram_q[rd_ptr_q]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a programmable floating-point unit. It includes memory operations and a counter. When triggered by the sys_clk, the module processes memory read and write operations. The memory is represented as an array of registers, and the memory address is determined based on the input signals. The module also contains a counter that increments on each clock cycle, and its value is used as the program counter. The input and output signals are assigned specific bit ranges of the memory data for address, opcode, and other operations. The module performs read and write operations based on the control signals c_en and c_w_en, and it connects the memory data to the input and output ports accordingly.\n\n Module header:\n\nmodule pfpu_prog(input sys_clk,input count_rst,output [6:0] a_addr,output [6:0] b_addr,output [3:0] opcode,output [6:0] w_addr,input c_en,input [1:0] c_page,input [8:0] c_offset,output [31:0] c_do,input [31:0] c_di,input c_w_en,output [10:0] pc);\n [/INST]\n", "output": "wire [10:0] mem_a; \n wire [24:0] mem_di; \n reg [24:0] mem_do; \n wire mem_we; \n reg [24:0] mem[0:2047]; \n always @(posedge sys_clk) begin \n  if(mem_we) \n  mem[mem_a] <= mem_di; \n  mem_do <= mem[mem_a]; \n end \n reg [10:0] counter; \n always @(posedge sys_clk) begin \n  if(count_rst) \n  counter <= 10'd0; \n  else \n  counter <= counter + 10'd1; \n end \n assign mem_a = c_en ? {c_page, c_offset} : counter; \n assign c_do = {7'd0, mem_do}; \n assign mem_di = c_di[24:0]; \n assign mem_we = c_en & c_w_en; \n assign a_addr = mem_do[24:18]; \n assign b_addr = mem_do[17:11]; \n assign opcode = mem_do[10:7]; \n assign w_addr = mem_do[6:0]; \n assign pc = counter; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes two 8-bit inputs v715730 and vf191e6 and produces a single 8-bit output v4642b6. It instantiates an adder and two combinational logic circuits to perform operations on the inputs and then assigns the result to the output. The module combines both sequential and combinational logic to process the input and produce the output based on the input wires.\n\n Module header:\n\nmodule vb2762a (input [7:0] v715730,input [7:0] vf191e6,output v4642b6);\n [/INST]\n", "output": "wire w0; \n  wire w1; \n  wire w2; \n  wire [0:7] w3; \n  wire [0:7] w4; \n  wire [0:3] w5; \n  wire [0:3] w6; \n  wire [0:3] w7; \n  wire [0:3] w8; \n  assign v4642b6 = w0; \n  assign w3 = v715730; \n  assign w4 = vf191e6; \n v438230 v577a36 (.v4642b6(w2),.v693354(w6),.v5369cd(w8)); \n vba518e v707c6e (.vcbab45(w0),.v0e28cb(w1),.v3ca442(w2)); \n v6bdcd9 v921a9f (.vcc8c7c(w4),.v651522(w7),.v2cc41f(w8)); \n v6bdcd9 v8cfa4d (.vcc8c7c(w3),.v651522(w5),.v2cc41f(w6)); \n v438230 vfc1765 (.v4642b6(w1),.v693354(w5),.v5369cd(w7)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a PWM (Pulse Width Modulation) demo. It takes in clock, address, data, and a switch input, and outputs PWM and LED signals. It has PWM generators for 8 PWM pins, and a latch to control the LED and PWM period. The LED signal is driven by the address input, and the period array is updated by the data input when the latch is triggered. The PWM signals are generated based on the clock and the corresponding period value.\n\n Module header:\n\nmodule pwm_demo(input CLK_100MHz,input [2:0] ADDRESS,input [7:0] DATA,input SW1,output [7:0] PWM,output reg [7:0] LED);\n [/INST]\n", "output": "wire [2:0] address; \n  wire [7:0] data; \n  wire latch; \n  assign address = ADDRESS; \n  assign data = DATA; \n  assign latch = ~SW1; \n  reg [7:0] period [0:256-1]; \n  pwm_generator pwm0(.clk(CLK_100MHz), .period(period[0]), .pin(PWM[0])); \n  pwm_generator pwm1(.clk(CLK_100MHz), .period(period[1]), .pin(PWM[1])); \n  pwm_generator pwm2(.clk(CLK_100MHz), .period(period[2]), .pin(PWM[2])); \n  pwm_generator pwm3(.clk(CLK_100MHz), .period(period[3]), .pin(PWM[3])); \n  pwm_generator pwm4(.clk(CLK_100MHz), .period(period[4]), .pin(PWM[4])); \n  pwm_generator pwm5(.clk(CLK_100MHz), .period(period[5]), .pin(PWM[5])); \n  pwm_generator pwm6(.clk(CLK_100MHz), .period(period[6]), .pin(PWM[6])); \n  pwm_generator pwm7(.clk(CLK_100MHz), .period(period[7]), .pin(PWM[7])); \n  always @(posedge CLK_100MHz) begin \n  if (latch) begin \n  LED <= address; \n  period[address] <= data; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module represents a seven-segment display decoder. It takes a 4-bit input and decodes it into a 7-bit output to control the segments of a seven-segment display. The module includes a case statement that maps each input value to the corresponding output pattern for displaying the corresponding decimal digit on the seven-segment display.\n\n Module header:\n\nmodule sevenseg(displayout,inputbcd);\n [/INST]\n", "output": "output [6:0] displayout; \n input [3:0] inputbcd; \n reg [6:0] displayout; \n parameter bit0 = 7'b0000001; \n parameter bit1 = 7'b0000010; \n parameter bit2 = 7'b0000100; \n parameter bit3 = 7'b0001000; \n parameter bit4 = 7'b0010000; \n parameter bit5 = 7'b0100000; \n parameter bit6 = 7'b1000000; \n parameter zero = ~(bit0 | bit1 | bit2 | bit3 | bit4 | bit5); \n parameter one = ~(bit1 | bit2); \n parameter two = ~(bit0 | bit1 | bit3 | bit4 | bit6); \n parameter three = ~(bit0 | bit1 | bit2 | bit3 | bit6); \n parameter four = ~(bit1 | bit2 | bit5 | bit6); \n parameter five = ~(bit0 | bit2 | bit3 | bit5 | bit6); \n parameter six = ~(bit0 | bit2 | bit3 | bit4 | bit5 | bit6); \n parameter seven = ~(bit0 | bit1 | bit2); \n parameter eight = ~(bit0 | bit1 | bit2 | bit3 | bit4 | bit5 | bit6); \n parameter nine = ~(bit0 | bit1 | bit2 | bit5 | bit6); \n parameter blank = ~(7'd0); \n always @ (inputbcd) \n case (inputbcd) \n 0: displayout = zero; \n 1: displayout = one; \n 2: displayout = two; \n 3: displayout = three; \n 4: displayout = four; \n 5: displayout = five; \n 6: displayout = six; \n 7: displayout = seven; \n 8: displayout = eight; \n 9: displayout = nine; \n default: displayout = blank; \n endcase \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, desxor1, takes 48-bit inputs e and k, computes the XOR of the two inputs, and then extracts 6-bit segments from the XOR result to produce eight separate outputs b1x through b8x.\n\n Module header:\n\nmodule desxor1(e,b1x,b2x,b3x,b4x,b5x,b6x,b7x,b8x,k);\n [/INST]\n", "output": "input [1:48] e; \n output [1:6] b1x,b2x,b3x,b4x,b5x,b6x,b7x,b8x; \n input [1:48] k; \n wire [1:48] XX; \n assign XX = k ^ e; \n assign b1x = XX[1:6]; \n assign b2x = XX[7:12]; \n assign b3x = XX[13:18]; \n assign b4x = XX[19:24]; \n assign b5x = XX[25:30]; \n assign b6x = XX[31:36]; \n assign b7x = XX[37:42]; \n assign b8x = XX[43:48]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, named `pxor_4w21w`, has inputs for `clk`, `rst`, `clk_ena`, and `pbus_in`, and an output named `busout`. It also includes a parameter for the width of the data. Inside the module, it creates a temporary wire `out_tmp` to perform bitwise XOR operations on segments of the `pbus_in` input. It also has a register `out_tmp_reg` to store the result.\n\nThe logic is clocked and includes a reset capability. During each clock cycle, if the `rst` signal is asserted, the `out_tmp_reg` is reset to 0. Otherwise, if `clk_ena` is active, the value of `out_tmp` is latched into `out_tmp_reg`. Finally, the `busout` output is assigned the value of `out_tmp_reg`. This module essentially performs a parallel XOR operation on segments of the input data and stores the result in the output.\n\n Module header:\n\nmodule pxor_4w21w(clk, rst, clk_ena,pbus_in,busout);\n [/INST]\n", "output": "parameter WIDTH = 8; \n  input clk, rst, clk_ena; \n  input [4*WIDTH-1:0] pbus_in; \n  output [WIDTH-1:0] busout; \n  wire [WIDTH-1:0] out_tmp; \n  reg [WIDTH-1:0] out_tmp_reg; \n assign out_tmp = (pbus_in[WIDTH*1-1:WIDTH*0]^pbus_in[WIDTH*2-1:WIDTH*1])^ \n (pbus_in[WIDTH*3-1:WIDTH*2]^pbus_in[WIDTH*4-1:WIDTH*3]); \n  always @(posedge clk or posedge rst) begin \n  if(rst) \n  out_tmp_reg <= 0; \n  else if(clk_ena) \n  out_tmp_reg <= out_tmp; \n  end \n  assign busout = out_tmp_reg; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a digital-to-analog converter (DAC) with synchronous behavior. It uses a clock input to control the generation of the DAC clock signal and data output. The module continuously processes input datain and generates the appropriate DAC signals dac_clock, dac_leftright, and dac_data. The module also includes internal registers and logic for data manipulation and timing control.\n\n Module header:\n\nmodule sound_dac(clock,dac_clock,dac_leftright,dac_data,load,datain);\n [/INST]\n", "output": "input clock; \n  output dac_clock; \n  output dac_leftright; \n  output dac_data; \n  output reg load; \n  input [15:0] datain; \n  reg [16:0] data; \n  reg [2:0] fifth; \n  reg [6:0] sync; \n  wire load_int; \n  initial \n  begin \n  fifth <= 0; \n  sync <= 0; \n  data <= 0; \n  load <= 0; \n  end \n  always @(posedge clock) \n  begin \n  if( fifth[2] ) \n  fifth <= 3'b000; \n  else \n  fifth <= fifth + 3'd1; \n  end \n  always @(posedge clock) \n  begin \n  if( fifth[2] ) sync <= sync + 7'd1; \n  end \n  assign load_int = fifth[2] & (&sync[5:0]); \n  always @(posedge clock) \n  begin \n  load <= load_int; \n  end \n  always @(posedge clock) \n  begin \n  if( fifth[2] && sync[0] ) \n  begin \n  if( load_int ) \n  data[15:0] <= datain; \n  else \n  data[15:0] <= { data[14:0], 1'b0 }; \n  data[16] <= data[15]; \n  end \n  end \n  assign dac_leftright = sync[6]; \n  assign dac_clock = sync[0]; \n  assign dac_data = data[16]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, soc_design_SystemID, takes in an address and outputs readdata. If the address is non-zero, it assigns readdata to 1500949681, otherwise, it assigns readdata to 255. The module operates synchronously with the clock and is reset by the reset_n signal.\n\n Module header:\n\nmodule soc_design_SystemID (address,clock,reset_n,readdata);\n [/INST]\n", "output": "output [ 31: 0] readdata; \n  input address; \n  input clock; \n  input reset_n; \n  wire [ 31: 0] readdata; \n  assign readdata = address ? 1500949681 : 255; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a Galois Field multiplier. It takes two input vectors, a and b, and produces the product in the output vector out. The multiplication process involves polynomial multiplication and modular reduction. The module defines a function to perform polynomial multiplication and another function to calculate the modular reduction. The result of the polynomial multiplication is then passed through the modular reduction function to obtain the final output.\n\n Module header:\n\nmodule zl_gf_mul # (parameter Gf_width = 0,parameter Gf_poly = 0) (input [Gf_width-1:0] a,input [Gf_width-1:0] b,output [Gf_width-1:0] out);\n [/INST]\n", "output": "function [Gf_width*2-2:0] a_conv_b; \n  input [Gf_width-1:0] a; \n  input [Gf_width-1:0] b; \n  reg [Gf_width*2-2:0] retval; \n  integer i,j; \n  begin \n  retval = 0; \n  for(i=0;i<Gf_width*2-1;i=i+1) begin \n  for(j=0;j<Gf_width;j=j+1) begin \n  if(i>=j && i-j<Gf_width) begin \n  retval[i] = retval[i] ^ (a[j]&b[i-j]); \n  end \n  end \n  end \n  a_conv_b = retval; \n  end \n endfunction \n function [Gf_width-1:0] mod_gf; \n  input [Gf_width*2-2:0] f; \n  reg [Gf_width-1:0] retval; \n  integer i; \n  begin \n  retval = 0; \n  for(i=0;i<Gf_width*2-1;i=i+1) begin \n  retval = \n  {retval[Gf_width-2:0], f[Gf_width*2-2-i]} \n ^ ({Gf_width{retval[Gf_width-1]}}& Gf_poly[Gf_width-1:0]); \n  end \n  mod_gf = retval; \n  end \n endfunction \n assign out = mod_gf(a_conv_b(a,b)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, named \"ball_control,\" implements the control logic for a ball in a simulation. It utilizes various inputs such as clock signals, reset, load, enable, floor, radius, load_x, load_y, s_x, s_y, seed, bd_p, bd_bl, bd_di, and outputs x, y, and dead. The module consists of various counters, random number generation, and state transition logic to control the movement and behavior of the ball in the simulation. The module utilizes the inputs to determine the position and movement of the ball, as well as its state of being dead or alive based on the position of the ball.\n\n Module header:\n\nmodule ball_control(input clock, reset, load, enable, floor,input [5:0] radius,input [9:0] load_x, load_y,input [3:0] s_x, s_y,input [5:0] seed,input bd_p, bd_bl,input [1:0] bd_di,output reg [9:0] x, y,output dead);\n [/INST]\n", "output": "wire rstx, rsty; \n wire [UBIT-1:0] cntx, cnty; \n wire [31:0] rnum; \n reg di_x, di_y; \n reg [5:0] ang_x, ang_y; \n wire [5:0] next_ang_x, next_ang_y; \n assign rstx = reset || cntx*ang_x >= UNIT; \n assign rsty = reset || cnty*ang_y >= UNIT; \n assign bd = bd_p | bd_bl; \n counter #(UBIT) cnt0(clock, rstx, enable, cntx); \n counter #(UBIT) cnt1(clock, rsty, enable, cnty); \n rand rnd(clock, reset, rnum); \n always @(posedge clock) \n begin \n  if (reset) begin \n  x <= LEFT+MAXX; \n  y <= TOP+MAXY; \n  end else if (load) begin \n  x <= load_x; \n  y <= load_y; \n  end else if (enable) begin \n  if (rstx) begin \n  if (di_x) \n  x <= x-1; \n  else \n  x <= x+1; \n  end \n  if (rsty) begin \n  if (di_y) \n  y <= y-1; \n  else \n  y <= y+1; \n  end \n  end \n end \n always @(posedge clock) \n begin \n  if (reset) begin \n  di_x <= 1'b0; \n  di_y <= 1'b0; \n  end else if (enable) begin \n  if (bd) begin \n  case (bd_di) \n  B_UP: di_y <= 1'b1; \n  B_RIGHT: di_x <= 1'b0; \n  B_DOWN: di_y <= 1'b0; \n  B_LEFT: di_x <= 1'b1; \n  endcase \n  end \n  if (LEFT + radius >= x) \n  di_x <= 1'b0; \n  else if (x + radius >= LEFT+MAXX) \n  di_x <= 1'b1; \n  if (TOP + radius > y) \n  di_y <= 1'b0; \n  else if (floor && y + radius >= TOP+MAXY) \n  di_y <= 1'b1; \n  end \n end \n always @(posedge clock) \n begin \n  if (reset) begin \n  ang_x <= rnum[7:4] ? rnum[7:4] : 5; \n  ang_y <= rnum[11:8] ? rnum[11:8] : 6; \n  end else if (load) begin \n  ang_x <= rnum[7:4] + seed ? rnum[7:4] : 5; \n  ang_y <= rnum[11:8] - seed ? rnum[11:8] : 6; \n  end else if (enable && bd) begin \n  if (s_x) ang_x <= next_ang_x ? next_ang_x : ang_x; \n  if (s_y) ang_y <= next_ang_y ? next_ang_y : ang_y; \n  end \n  if (ang_x == 0) ang_x <= 5; \n  if (ang_y == 0) ang_y <= 6; \n end \n assign next_ang_x = rnum[1:0] + s_x; \n assign next_ang_y = rnum[3:2] + s_y; \n assign dead = y >= TOP+MAXY; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a data path controller for a high-performance double data rate (HPDDR) memory interface. It controls the direction of the data transfer, the input and output data signals, and the data mask signals. The input data is latched on the rising edge of the system clock, and the output data is driven to the HPDDR memory.\n\n Module header:\n\nmodule hpdmc_sdrio(input sys_clk,input direction,input direction_r,input [ 1:0] mo,input [15:0] dat_o,output reg [15:0] dat_i,output [ 1:0] sdram_dqm,inout [15:0] sdram_dq);\n [/INST]\n", "output": "wire [15:0] sdram_data_out; \n assign sdram_dq = direction ? sdram_data_out : 16'hzzzz; \n assign sdram_dqm = mo; \n assign sdram_data_out = dat_o; \n always @(posedge sys_clk) dat_i <= sdram_dq; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module dff_2 is a synchronous D flip-flop with two bits of input and output. It updates the output q on the positive edge of the clock signal with the value of the input d. The initial state of q can be randomly initialized if the RANDOM_INIT parameter is enabled.\n\n Module header:\n\nmodule dff_2 ( clk, d, q );\n [/INST]\n", "output": "input clk; \n  input [1:0] d; \n  output [1:0] q; \n  reg [1:0] q; \n `ifdef RANDOM_INIT \n  initial \n  $random_init(\"q\"); \n `endif \n  always @(posedge clk) begin \n  q <= d; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module represents a UART (Universal Asynchronous Receiver/Transmitter) component with various input and output ports. The module includes sub-modules for transmission (Tx), reception (Rx), and configuration (regs). It contains ports for transmitting and receiving data, clock signals, control signals, and status signals such as dataavailable, irq, readdata, and readyfordata. The UART component handles the transmission and reception of asynchronous serial data, and the configuration of UART parameters. The sub-modules handle specific functions such as baud rate generation, status monitoring, and data transmission/reception.\n\n Module header:\n\nmodule TimeHoldOver_Qsys_uart_0 (address,begintransfer,chipselect,clk,read_n,reset_n,rxd,write_n,writedata,dataavailable,irq,readdata,readyfordata,txd);\n [/INST]\n", "output": "output dataavailable; \n  output irq; \n  output [ 15: 0] readdata; \n  output readyfordata; \n  output txd; \n  input [ 2: 0] address; \n  input begintransfer; \n  input chipselect; \n  input clk; \n  input read_n; \n  input reset_n; \n  input rxd; \n  input write_n; \n  input [ 15: 0] writedata; \n  wire [ 9: 0] baud_divisor; \n  wire break_detect; \n  wire clk_en; \n  wire dataavailable; \n  wire do_force_break; \n  wire framing_error; \n  wire irq; \n  wire parity_error; \n  wire [ 15: 0] readdata; \n  wire readyfordata; \n  wire rx_char_ready; \n  wire [ 7: 0] rx_data; \n  wire rx_overrun; \n  wire rx_rd_strobe; \n  wire status_wr_strobe; \n  wire [ 7: 0] tx_data; \n  wire tx_overrun; \n  wire tx_ready; \n  wire tx_shift_empty; \n  wire tx_wr_strobe; \n  wire txd; \n  assign clk_en = 1; \n  TimeHoldOver_Qsys_uart_0_tx the_TimeHoldOver_Qsys_uart_0_tx \n (.baud_divisor (baud_divisor),.begintransfer (begintransfer),.clk (clk),.clk_en (clk_en),.do_force_break (do_force_break),.reset_n (reset_n),.status_wr_strobe (status_wr_strobe),.tx_data (tx_data),.tx_overrun (tx_overrun),.tx_ready (tx_ready),.tx_shift_empty (tx_shift_empty),.tx_wr_strobe (tx_wr_strobe),.txd (txd)); \n  TimeHoldOver_Qsys_uart_0_rx the_TimeHoldOver_Qsys_uart_0_rx \n (.baud_divisor (baud_divisor),.begintransfer (begintransfer),.break_detect (break_detect),.clk (clk),.clk_en (clk_en),.framing_error (framing_error),.parity_error (parity_error),.reset_n (reset_n),.rx_char_ready (rx_char_ready),.rx_data (rx_data),.rx_overrun (rx_overrun),.rx_rd_strobe (rx_rd_strobe),.rxd (rxd),.status_wr_strobe (status_wr_strobe)); \n  TimeHoldOver_Qsys_uart_0_regs the_TimeHoldOver_Qsys_uart_0_regs \n (.address (address),.baud_divisor (baud_divisor),.break_detect (break_detect),.chipselect (chipselect),.clk (clk),.clk_en (clk_en),.dataavailable (dataavailable),.do_force_break (do_force_break),.framing_error (framing_error),.irq (irq),.parity_error (parity_error),.read_n (read_n),.readdata (readdata),.readyfordata (readyfordata),.reset_n (reset_n),.rx_char_ready (rx_char_ready),.rx_data (rx_data),.rx_overrun (rx_overrun),.rx_rd_strobe (rx_rd_strobe),.status_wr_strobe (status_wr_strobe),.tx_data (tx_data),.tx_overrun (tx_overrun),.tx_ready (tx_ready),.tx_shift_empty (tx_shift_empty),.tx_wr_strobe (tx_wr_strobe),.write_n (write_n),.writedata (writedata)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a state machine that controls the acquisition and transfer of data from an ADC. It synchronizes the data ready signal to the FPGA clock, and transitions between states based on the synchronized data ready signal. The module includes states for waiting for the data ready signal to go high, acquiring data, transferring data, and waiting for the data ready signal to go low. It also sets the ADC status output based on the current state. Additionally, the module applies a dec256sinc24b filter to the ADC output.\n\n Module header:\n\nmodule ad7401 (input fpga_clk_i,input adc_clk_i,input reset_i,output reg [15:0] data_o,output reg data_rd_ready_o,output reg adc_status_o,input adc_mdata_i);\n [/INST]\n", "output": "wire data_rdy_s; \n wire [15:0] data_s ; \n reg [3:0] present_state; \n reg [3:0] next_state; \n reg data_rdy_s_d1; \n reg data_rdy_s_d2; \n localparam WAIT_DATA_RDY_HIGH_STATE = 4'b0001; \n localparam ACQUIRE_DATA_STATE = 4'b0010; \n localparam TRANSFER_DATA_STATE = 4'b0100; \n localparam WAIT_DATA_RDY_LOW_STATE = 4'b1000; \n always @(posedge fpga_clk_i) \n begin \n  data_rdy_s_d1 <= data_rdy_s; \n  data_rdy_s_d2 <= data_rdy_s_d1; \n end \n always @(posedge fpga_clk_i) \n begin \n  if(reset_i == 1'b1) \n  begin \n  present_state <= WAIT_DATA_RDY_HIGH_STATE; \n  adc_status_o <= 1'b0; \n  end \n  else \n  begin \n  present_state <= next_state; \n  case (present_state) \n  WAIT_DATA_RDY_HIGH_STATE: \n  begin \n  data_rd_ready_o <= 1'b0; \n  end \n  ACQUIRE_DATA_STATE: \n  begin \n  data_o <= data_s; \n  data_rd_ready_o <= 1'b0; \n  adc_status_o <= 1'b1; \n  end \n  TRANSFER_DATA_STATE: \n  begin \n  data_rd_ready_o <= 1'b1; \n  end \n  WAIT_DATA_RDY_LOW_STATE: \n  begin \n  data_rd_ready_o <= 1'b0; \n  end \n  endcase \n  end \n end \n always @(present_state, data_rdy_s_d2) \n begin \n  next_state <= present_state; \n  case (present_state) \n  WAIT_DATA_RDY_HIGH_STATE: \n  begin \n  if(data_rdy_s_d2 == 1'b1) \n  begin \n  next_state <= ACQUIRE_DATA_STATE; \n  end \n  end \n  ACQUIRE_DATA_STATE: \n  begin \n  next_state <= TRANSFER_DATA_STATE; \n  end \n  TRANSFER_DATA_STATE: \n  begin \n  next_state <= WAIT_DATA_RDY_LOW_STATE; \n  end \n  WAIT_DATA_RDY_LOW_STATE: \n  begin \n  if(data_rdy_s_d2 == 1'b0) \n  begin \n  next_state <= WAIT_DATA_RDY_HIGH_STATE; \n  end \n  end \n  default: \n  begin \n  next_state <= WAIT_DATA_RDY_HIGH_STATE; \n  end \n  endcase \n end \n dec256sinc24b filter(.mclkout_i(adc_clk_i),.reset_i(reset_i),.mdata_i(adc_mdata_i),.data_rdy_o(data_rdy_s),.data_o(data_s)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a testbench for an HDMI interface. It instantiates an HDMI input module and an up-sampling unit for RGB to HSV conversion. It connects the signals from the HDMI input module to the up-sampling unit and assigns the converted signals to the output HDMI signals. The module then instantiates an HDMI output module and connects the converted signals to it for outputting the HDMI signal.\n\n Module header:\n\nmodule tb_hdmi();\n [/INST]\n", "output": "wire rx_pclk; \n wire rx_de; \n wire rx_hsync; \n wire rx_vsync; \n wire [7:0] rx_red; \n wire [7:0] rx_green; \n wire [7:0] rx_blue; \n wire tx_de; \n wire tx_hsync; \n wire tx_vsync; \n wire [7:0] tx_red; \n wire [7:0] tx_green; \n wire [7:0] tx_blue; \n hdmi_in file_input (.hdmi_clk(rx_pclk),.hdmi_de(rx_de),.hdmi_hs(rx_hsync),.hdmi_vs(rx_vsync),.hdmi_r(rx_red),.hdmi_g(rx_green),.hdmi_b(rx_blue)); \n wire [7:0] H; \n wire [7:0] S; \n wire [7:0] V; \n wire conv_vsync; \n wire conv_hsync; \n wire conv_de; \n rgb2hsv uut (.clk(rx_pclk),.ce(1'b1),.R(rx_red),.G(rx_green),.B(rx_blue),.in_hsync(rx_hsync),.in_vsync(rx_vsync),.in_de(rx_de),.H(H),.S(S),.V(V),.out_hsync(conv_hsync),.out_vsync(conv_vsync),.out_de(conv_de)); \n assign tx_de = conv_de; \n assign tx_hsync = conv_hsync; \n assign tx_vsync = conv_vsync; \n assign tx_red = H; \n assign tx_green = S; \n assign tx_blue = V; \n hdmi_out file_output (.hdmi_clk(rx_pclk),.hdmi_vs(tx_vsync),.hdmi_de(tx_de),.hdmi_data({8'b0,tx_red,tx_green,tx_blue})); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `quick_spi_hard_le_lsb_testbench` simulates a quick SPI hardware module. It includes a clock signal `clk`, a reset signal `rst_n`, wires for `end_of_transaction` and `incoming_data`, and an output register `outgoing_data`. The module also includes signals `mosi`, `miso`, `sclk`, `ss_n`, `enable`, `start_transaction`, `operation`, `sclk_toggle_count`, `incoming_data_buffer`, and `spi_clock_phase` to manage the SPI transaction.\n\nThe module initializes the clock and reset signals, sets the outgoing data, and sets up the SPI transaction. It toggles the clock phase, shifts data, and handles the end of the transaction. The quick SPI hard module is instantiated with specific input and output connections for the SPI controller.\n\nThe clock is toggled periodically, and the SPI controller is instantiated to manage the SPI transaction and handle the input and output connections.\n\n Module header:\n\nmodule quick_spi_hard_le_lsb_testbench;\n [/INST]\n", "output": "reg clk; \n reg rst_n; \n wire end_of_transaction; \n wire[7:0] incoming_data; \n reg[15:0] outgoing_data; \n wire mosi; \n reg miso; \n wire sclk; \n wire[1:0] ss_n; \n reg enable; \n reg start_transaction; \n reg operation; \n integer sclk_toggle_count; \n reg[8:0] incoming_data_buffer; \n reg spi_clock_phase; \n initial begin \n  clk <= 1'b0; \n  rst_n <= 1'b0; \n  rst_n <= #50 1'b1; \n  outgoing_data <= {8'b11001100, 8'b10000010}; \n end \n always @ (posedge clk) \n begin \n  if(!rst_n) \n  begin \n  outgoing_data <= {8'b11001100, 8'b10000010}; \n  enable <= 1'b1; \n  start_transaction <= 1'b1; \n  operation <= 1'b0; \n  miso <= 1'b0; \n  sclk_toggle_count <= 0; \n  incoming_data_buffer <= {8'b10010101, 1'b1}; \n  spi_clock_phase <= 1'b1; \n  end \n  else \n  begin \n  if(end_of_transaction) \n  begin \n  operation <= ~operation; \n  sclk_toggle_count <= 0; \n  spi_clock_phase <= 1'b1; \n  incoming_data_buffer <= {8'b10010101, 1'b1}; \n  miso <= 1'b0; \n  end \n  else \n  begin \n  if(sclk_toggle_count > 36) \n  begin \n  if(!spi_clock_phase) \n  begin \n  miso <= incoming_data_buffer[0]; \n  incoming_data_buffer <= incoming_data_buffer >> 1; \n  end \n  end \n  sclk_toggle_count <= sclk_toggle_count + 1; \n  spi_clock_phase <= ~spi_clock_phase; \n  end \n  end \n end \n quick_spi_hard # \n (.BYTES_ORDER(0),.BITS_ORDER(0)) \n spi \n (.clk(clk),.reset_n(rst_n),.enable(enable),.start_transaction(start_transaction),.slave(2'b01),.operation(operation),.end_of_transaction(end_of_transaction),.incoming_data(incoming_data),.outgoing_data(outgoing_data),.mosi(mosi),.miso(miso),.sclk(sclk),.ss_n(ss_n)); \n always #25 clk <= ~clk; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module takes a PCM input and adjusts its gain using a signed 8-bit value and a clock signal. It multiplies the PCM input by the factor and outputs the result after shifting by 8 bits, if a certain condition is met.\n\n Module header:\n\nmodule jt10_adpcmb_gain(input rst_n,input clk,input cen55,input [ 7:0] tl,input signed [15:0] pcm_in,output reg signed [15:0] pcm_out);\n [/INST]\n", "output": "wire signed [15:0] factor = {8'd0, tl}; \n wire signed [31:0] pcm_mul = pcm_in * factor; \n always @(posedge clk) if(cen55) \n  pcm_out <= pcm_mul[23:8]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a 2-to-1 multiplexer. The output O is assigned the value of B when the enable input is high, and the value of A when the enable input is low. The value of O is updated whenever there is a change in A, B, or enable inputs.\n\n Module header:\n\nmodule mux_2_to_1_1(input A,B,input enable,output reg O);\n [/INST]\n", "output": "always @* begin \n  if (enable) O <= B; \n  else O <= A; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a shift register with a configurable number of stages and data width. It has inputs for the reset signal, clock signal, clock enable, and input data, and outputs the shifted data. The shift register is initialized with a specific value on reset and shifts the data based on the clock and clock enable signals. The output drop indicates the dropped bit from each stage of the shift register.\n\n Module header:\n\nmodule jt12_sh_rst #(parameter width=5, stages=32, rstval=1'b0 ) (input rst,input clk,input clk_en ,input [width-1:0] din,output [width-1:0] drop);\n [/INST]\n", "output": "reg [stages-1:0] bits[width-1:0]; \n genvar i; \n integer k; \n generate \n initial \n  for (k=0; k < width; k=k+1) begin \n  bits[k] = { stages{rstval}}; \n  end \n endgenerate \n generate \n  for (i=0; i < width; i=i+1) begin: bit_shifter \n  always @(posedge clk, posedge rst) \n  if( rst ) begin \n  bits[i] <= {stages{rstval}}; \n  end else if(clk_en) begin \n  bits[i] <= {bits[i][stages-2:0], din[i]}; \n  end \n  assign drop[i] = bits[i][stages-1]; \n  end \n endgenerate \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module performs a simple integer division and checks the result against an expected value. If there is a mismatch, it displays an error message and stops the simulation. The module utilizes a combinatorial assignment to perform the division and an always block to compare the result with the expected value. If a mismatch is detected, it prints an error message and stops the simulation.\n\n Module header:\n\nmodule check (input signed [22:0] a, b, c);\n [/INST]\n", "output": "wire signed [22:0] int_AB; \n  assign int_AB = a / b; \n always @(a, b, int_AB, c) begin \n  #1; \n  if (int_AB !== c) begin \n  $display(\"ERROR: mismatch in div for %d and %d\", a , b); \n  $display(\"VHDL = %d, Verilog = %d\", c, int_AB); \n  $finish; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a 32x4 read-only memory (ROM) with a clock input and a 5-bit address input. The output is a 4-bit data. The ROM is initialized with specific values for each address in the initial block. On the negative edge of the clock, the data output is updated based on the value stored in the ROM at the specified address.\n\n Module header:\n\nmodule rom32x4 (input clk,input wire [4:0] addr,output reg [3:0] data);\n [/INST]\n", "output": "reg [3:0] rom [0:31]; \n  always @(negedge clk) begin \n  data <= rom[addr]; \n  end \n  initial begin \n  rom[0] = 4'h0; \n  rom[1] = 4'h1; \n  rom[2] = 4'h2; \n  rom[3] = 4'h3; \n  rom[4] = 4'h4; \n  rom[5] = 4'h5; \n  rom[6] = 4'h6; \n  rom[7] = 4'h7; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a testbench for a seven-segment display controller. It uses signals such as clock, reset, data input, strobe, write enable, and outputs data and acknowledge signals. The test initializes the signals, waits for some clock cycles, sets the data input and strobe signals, and then toggles the clock signal. The \"Seven_seg\" module is instantiated to drive the signals.\n\n Module header:\n\nmodule Seven_seg_test;\n [/INST]\n", "output": "reg clk; \n  reg reset; \n  reg [31: 0] DAT_I; \n  reg STB; \n  reg WE; \n  wire [31:0] DAT_O; \n  wire ACK; \n  wire [7:0] Segment; \n  wire [3:0] AN; \n  wire [15: 0] debug_data_hold; \n Seven_seg uut (.clk(clk),.reset(reset),.DAT_I(DAT_I),.STB(STB),.DAT_O(DAT_O),.ACK(ACK),.WE(WE),.Segment(Segment),.AN(AN),.debug_data_hold(debug_data_hold)); \n  initial begin \n  clk = 0; \n  reset = 1; \n  DAT_I = 0; \n  STB = 0; \n  WE = 0; \n  #100; \n  reset = 0; \n  #50 DAT_I = 32'h00001234; \n  STB = 1; \n  #50 STB = 0; \n  end \n  always begin \n  #25 clk = ~clk; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes in two 10-bit inputs hcount and vcount and calculates a 17-bit address based on the values of the inputs. The address is computed by shifting certain bits of vcount and hcount, and then combining them together. The result is stored in the output addr.\n\n Module header:\n\nmodule addr_map(input[9:0] hcount,input[9:0] vcount,output[16:0] addr);\n [/INST]\n", "output": "assign addr = (vcount[9:1] << 8) + (vcount[9:1] << 6) + (hcount >> 1); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a wrapper for a divider circuit. It includes parameters for input and output widths and control signals. The module uses registers and wires to control the behavior of the underlying divider circuit and manages the state transitions based on the control signals. The module also synchronizes its behavior with the clock signal and the reset signal.\n\n Module header:\n\nmodule my_wrapper_divider(rst, clk, data_in_a, data_in_b, data_out);\n [/INST]\n", "output": "parameter INPUT_WIDTH_A = 5'b10000; \n  parameter INPUT_WIDTH_B = 5'b10001; \n  parameter OUTPUT_WIDTH = 4'b1000; \n  parameter S1 = 2'b00; \n  parameter S2 = 2'b01; \n  parameter S3 = 2'b10; \n  parameter S4 = 2'b11; \n  input rst; \n  input clk; \n  input [INPUT_WIDTH_A-1:0]data_in_a; \n  input [INPUT_WIDTH_B-1:0]data_in_b; \n  output [OUTPUT_WIDTH-1:0]data_out; \n  wire [OUTPUT_WIDTH-1:0]data_out; \n  wire [OUTPUT_WIDTH-1:0]Remainder; \n  reg start, LA, EB; \n  wire Done; \n  reg[1:0] y, Y; \n  my_divider my_divider_inst(clk, rst, start, LA, EB, data_in_a, data_in_b, Remainder, data_out, Done); \n  always @(posedge clk or negedge rst) \n  begin \n  if (rst == 0) \n  y <= S1; \n  else \n  y <= Y; \n  end \n  always @(y) \n  begin \n  case (y) \n  S1 : \n  begin \n  LA = 0; \n  EB = 0; \n  start = 0; \n  Y = S2; \n  end \n  S2 : \n  begin \n  LA = 1; \n  EB = 1; \n  start = 0; \n  Y = S3; \n  end \n  S3 : \n  begin \n  LA = 0; \n  EB = 0; \n  start = 1; \n  Y = S4; \n  end \n  S4 : \n  begin \n  LA = 0; \n  EB = 0; \n  start = 0; \n  if (Done == 1'b1) \n  begin \n  Y = S1; \n  end \n  else \n  begin \n  Y = S4; \n  end \n  end \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a synchronous FIFO (First In First Out) memory. It has read and write ports, and status flags to indicate if the FIFO is full or empty. The module uses gray counters to manage the read and write addresses. It also handles the logic for writing data to and reading data from the memory. The status flags are updated based on the current state of the FIFO. When the preset full flag is set, the module indicates that the FIFO is full, and when the preset empty flag is set, it indicates that the FIFO is empty.\n\n Module header:\n\nmodule asfifo #(parameter data_width = 8,parameter address_width = 4,parameter fifo_depth = (1 << address_width)) (output [data_width-1:0] data_out,output reg empty,input read_en,input clk_read,input [data_width-1:0] data_in,output reg full,input write_en,input clk_write,input rst);\n [/INST]\n", "output": "reg [data_width-1:0] mem[fifo_depth-1:0]; \n wire [address_width-1:0] write_index, read_index; \n wire equal_addresses; \n wire write_en_safe, read_en_safe; \n wire set_status, clear_status; \n reg status; \n wire preset_full, preset_empty; \n assign data_out = mem[read_index]; \n always @(posedge clk_write) begin \n  if(write_en & !full) \n  mem[write_index] <= data_in; \n end \n assign write_en_safe = write_en & ~full; \n assign read_en_safe = read_en & ~empty; \n asfifo_graycounter #(.width(address_width)) counter_write (.gray_count(write_index),.ce(write_en_safe),.rst(rst),.clk(clk_write)); \n asfifo_graycounter #(.width(address_width)) counter_read (.gray_count(read_index),.ce(read_en_safe),.rst(rst),.clk(clk_read)); \n assign equal_addresses = (write_index == read_index); \n assign set_status = (write_index[address_width-2] ~^ read_index[address_width-1]) & \n  (write_index[address_width-1] ^ read_index[address_width-2]); \n assign clear_status = ((write_index[address_width-2] ^ read_index[address_width-1]) &(write_index[address_width-1] ~^ read_index[address_width-2])) \n  | rst; \n always @(posedge clear_status, posedge set_status) begin \n  if(clear_status) \n  status <= 1'b0; \n  else \n  status <= 1'b1; \n end \n assign preset_full = status & equal_addresses; \n always @(posedge clk_write, posedge preset_full) begin \n  if(preset_full) \n  full <= 1'b1; \n  else \n  full <= 1'b0; \n end \n assign preset_empty = ~status & equal_addresses; \n always @(posedge clk_read, posedge preset_empty) begin \n  if(preset_empty) \n  empty <= 1'b1; \n  else \n  empty <= 1'b0; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a priority selection circuit for a specified number of ports and priorities. It uses interleaving and masking techniques to select the highest priority input based on the enable signal and the priorities provided. The circuit selects the highest priority input and outputs the corresponding select signal to indicate the chosen input. The module makes use of parameters, localparams, wires, and generate blocks to manage the multiple inputs and generate the priority selection logic.\n\n Module header:\n\nmodule c_prio_sel (priorities, enable, select);\n [/INST]\n", "output": "parameter num_ports = 32; \n  parameter num_priorities = 16; \n  localparam prio_width = clogb(num_priorities); \n  input [0:num_ports*prio_width-1] priorities; \n  input [0:num_ports-1] enable; \n  output [0:num_ports-1] select; \n  wire [0:num_ports-1] select; \n  wire [0:prio_width*num_ports-1] prio_ports; \n  c_interleave \n #(.width(num_ports*prio_width),.num_blocks(num_ports)) \n  prio_ports_intl \n (.data_in(priorities),.data_out(prio_ports)); \n  wire [0:(prio_width+1)*num_ports-1] mask; \n  assign mask[0:num_ports-1] = enable; \n  generate \n  genvar i; \n  for(i = 0; i < prio_width; i = i + 1) \n  begin:is \n  wire [0:num_ports-1] mask_in; \n  assign mask_in = mask[i*num_ports:(i+1)*num_ports-1]; \n  wire [0:num_ports-1] prio; \n  assign prio = prio_ports[i*num_ports:(i+1)*num_ports-1]; \n  wire [0:num_ports-1] mask_out; \n  assign mask_out = mask_in & (prio | {num_ports{~|(mask_in & prio)}}); \n  assign mask[(i+1)*num_ports:(i+2)*num_ports-1] = mask_out; \n  end \n  endgenerate \n  assign select = mask[prio_width*num_ports:(prio_width+1)*num_ports-1]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an encoder that takes a 16-bit input data and outputs a 4-bit signal q. It internally uses two sub-modules, altpriority_encoder10 and altpriority_encoder11, to encode the lower 8 bits and upper 8 bits of the input data respectively. The output q is derived using logic that combines the outputs of the two sub-encoders.\n\n Module header:\n\nmodule acl_fp_log_altpriority_encoder_r08 (data,q) ;\n [/INST]\n", "output": "input [15:0] data; \n  output [3:0] q; \n  wire [2:0] wire_altpriority_encoder10_q; \n  wire [2:0] wire_altpriority_encoder11_q; \n  wire wire_altpriority_encoder11_zero; \n  acl_fp_log_altpriority_encoder_bv7 altpriority_encoder10 \n (.data(data[7:0]),.q(wire_altpriority_encoder10_q)); \n  acl_fp_log_altpriority_encoder_be8 altpriority_encoder11 \n (.data(data[15:8]),.q(wire_altpriority_encoder11_q),.zero(wire_altpriority_encoder11_zero)); \n  assign \n  q = {(~ wire_altpriority_encoder11_zero), (({3{wire_altpriority_encoder11_zero}} & wire_altpriority_encoder10_q) | ({3{(~ wire_altpriority_encoder11_zero)}} & wire_altpriority_encoder11_q))}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module is a top-level design that integrates several sub-modules for SPI communication, SDRAM memory access, neural network processing, and control logic. The module has inputs for clock signals and various control signals for SPI communication and SDRAM access. It also has outputs for LED control. The module instantiates sub-modules for SPI slave communication, SDRAM access, neural network processing, and master control logic for coordinating the overall functionality of the system. The module also includes the necessary interfacing logic to control the LEDs based on the system status.\n\n Module header:\n\nmodule DeepGATE_top(input clk100MHz,output wire [13:0] led,input RaspberrySPI_SS,input RaspberrySPI_SCLK,input RaspberrySPI_MOSI,output RaspberrySPI_MISO,output sdram_clk,output sdram_cle,output sdram_dqm,output sdram_cs,output sdram_we,output sdram_cas,output sdram_ras,output [1:0] sdram_ba,output [12:0] sdram_a,inout [7:0] sdram_dq);\n [/INST]\n", "output": "wire rst = 0; \n wire clk; \n assign clk = clk100MHz; \n wire newSPIData; \n wire spiBusy; \n wire [7:0] byteRX; \n wire [7:0] byteTX; \n wire newTXSPIData; \n spiSlave spiSlave(.clk (clk),.SS (RaspberrySPI_SS),.SCLK (RaspberrySPI_SCLK),.MOSI (RaspberrySPI_MOSI),.MISO (RaspberrySPI_MISO),.byteTX (byteTX),.byteRX (byteRX),.newSPIData (newSPIData),.busy (spiBusy),.newTXData (newTXSPIData)); \n wire [31:0] sdramDataTX; \n wire [31:0] sdramDataRX; \n wire [22:0] sdramAddr; \n wire sdramBusy; \n wire sdramTXValid; \n wire sdramRXValid; \n wire sdramRW; \n sdram SDRAM (.clk (clk),.rst (rst),.sdram_clk (sdram_clk),.sdram_cle (sdram_cle),.sdram_cs (sdram_cs),.sdram_cas (sdram_cas),.sdram_ras (sdram_ras),.sdram_we (sdram_we),.sdram_dqm (sdram_dqm),.sdram_ba (sdram_ba),.sdram_a (sdram_a),.sdram_dq (sdram_dq),.addr (sdramAddr),.rw (sdramRW),.data_in (sdramDataTX),.data_out (sdramDataRX),.busy (sdramBusy),.in_valid (sdramTXValid),.out_valid (sdramRXValid)); \n wire procBegin; \n wire procComplete; \n wire [7:0] networkDataIn; \n wire [7:0] networkOut; \n wire networkIdle; \n wire networkRead; \n wire inputRead; \n wire [7:0] weightData; \n wire [NUM_TILES - 1'b1 : 0] pipelineLock; \n wire [NUM_TILES - 1'b1 : 0] weightRAMwrEn; \n tile_network ANN(.clk_i (clk),.en_i (procBegin),.data_rd_o (inputRead),.data_rd_i (networkRead),.data_i (networkDataIn),.network_idle_o (networkIdle),.data_o (networkOut),.proc_complete_o (procComplete),.weight_wr_i (weightRAMwrEn),.weight_data_i (weightData),.pipeline_lock_o (pipelineLock)); \n wire [7:0] MCUled; \n masterControl MCU(.clk (clk),.rst (rst),.TXBusy (spiBusy),.newRXData (newSPIData),.RXData (byteRX),.TXDataBuffer (byteTX),.newTXData (newTXSPIData),.inputRead (inputRead),.networkIdle (networkIdle),.procComplete (procComplete),.networkOut (networkOut),.networkDataIn (networkDataIn),.procBegin (procBegin),.networkRead (networkRead),.weightRAMwrEn (weightRAMwrEn),.weightDataOut (weightData),.pipelineLock (pipelineLock),.sdramBusy (sdramBusy),.sdramRXValid (sdramRXValid),.sdramDataRX (sdramDataRX),.sdramDataTX (sdramDataTX),.sdramAddr (sdramAddr),.sdramTXValid (sdramTXValid),.sdramRW (sdramRW),.LED (MCUled)); \n assign led[13:8] = 0; \n assign led[7:0] = MCUled; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module generates the carry signal for a multi-bit arithmetic operation. It takes three inputs gen_grant_carry_c, gen_grant_carry_r, and gen_grant_carry_p, and produces a 2-bit output gen_grant_carry. The output is a result of a logical OR operation between gen_grant_carry_r and the logical OR of gen_grant_carry_c and gen_grant_carry_p, as well as a logical AND operation between the negation of gen_grant_carry_r and the logical OR of gen_grant_carry_c and gen_grant_carry_p.\n\n Module header:\n\nmodule module_gen_grant_carry(gen_grant_carry_c,gen_grant_carry_r,gen_grant_carry_p,gen_grant_carry);\n [/INST]\n", "output": "input gen_grant_carry_c; \n  input gen_grant_carry_r; \n  input gen_grant_carry_p; \n  output [1 : 0] gen_grant_carry; \n  wire [1 : 0] gen_grant_carry; \n  assign gen_grant_carry = \n  { gen_grant_carry_r && (gen_grant_carry_c || gen_grant_carry_p), \n  !gen_grant_carry_r && \n  (gen_grant_carry_c || gen_grant_carry_p) } ; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module consists of logic for two buffers, grant control, and status, implemented with flip-flops. The module takes input signals for the buffers, grant control, and clock, and provides outputs for the buffers, grant control, and status. The output signals for the first buffer are inverted, while the output for the second buffer is a D flip-flop for the grant control. The grant control signal is inverted, and status is implemented with flip-flops.\n\n Module header:\n\nmodule cpx_buf_pt(out0_l, out1_l, cpx_src_grant_cx, so,in0, in1, cpx_src_grant_ca, rclk, si, se);\n [/INST]\n", "output": "output [7:0] out0_l; \n  output out1_l; \n  output [7:0] cpx_src_grant_cx; \n  output so; \n  input [7:0] in0; \n  input in1; \n  input [7:0] cpx_src_grant_ca; \n  input rclk; \n  input si; \n  input se; \n  assign out0_l[7:0] = ~in0[7:0]; \n  assign out1_l = ~in1; \n dff_s #(8) dff_ccx_com_src(.din (cpx_src_grant_ca[7:0]),.q (cpx_src_grant_cx[7:0]),.clk (rclk),.se (1'b0),.si (8'd0),.so ()); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a timer with an 8-bit bidirectional data bus and an 8-bit address bus. It has control signals for chip select (cs_), output enable (oe_), and write enable (we_). The module contains eight 8-bit registers, initialized to zero. The data bus output is connected to the selected register when chip select and output enable are low. The registers are written to when both chip select and write enable are low, or they can be incremented on each clock cycle. The module also has an interrupt output which is set based on the values of two of the registers.\n\n Module header:\n\nmodule timer(clk, rst_, data, addr, cs_, oe_, we_, interrupt);\n [/INST]\n", "output": "input clk; \n  input rst_; \n  inout [7:0] data; \n  input [7:0] addr; \n  input cs_; \n  input oe_; \n  input we_; \n  output interrupt; \n reg [7:0] r[0:7]; \n assign data = (~cs_ & ~oe_) ? r[addr] : 8'bzzzzzzzz; \n `ifndef USE_RST_LOGIC \n initial begin \n  { r[3], r[2], r[1], r[0] } = 32'd0; \n  { r[7], r[6], r[5], r[4] } = 32'd0; \n end \n `endif \n always @(posedge clk) \n `ifdef USE_RST_LOGIC \n  if(~rst_) begin \n  { r[3], r[2], r[1], r[0] } = 32'd0; \n  { r[7], r[6], r[5], r[4] } = 32'd0; \n  end \n  else \n `endif \n  if(~cs_ & ~we_) \n  r[addr] <= data; \n  else \n  { r[3], r[2], r[1], r[0] } <= { r[3], r[2], r[1], r[0] } + 32'd1; \n assign interrupt = ( { r[7], r[6], r[5], r[4] } == 32'd0 ) ? 1'b0 : \n  (( { r[3], r[2], r[1], r[0] } >= { r[7], r[6], r[5], r[4] } ) ? 1'b1 : 1'b0); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a snooping output queue with an input to enqueue and an input to dequeue. It uses a counter to track the number of elements in the queue and assigns a valid signal based on the counter value. The counter is incremented when an element is enqueued and decremented when an element is dequeued, and the valid signal is asserted when the counter is not zero. The module operates on a positive clock edge and includes a reset signal for the counter.\n\n Module header:\n\nmodule jbi_snoop_out_queue (valid,enqueue, dequeue, clk, rst_l);\n [/INST]\n", "output": "input enqueue; \n  output valid; \n  input dequeue; \n  input clk; \n  input rst_l; \n  wire [15:0] next_counter; \n  wire [15:0] counter; \n  dffrle_ns #(JBI_SNOOP_OUT_QUEUE_SIZE) counter_reg (.din(next_counter), .en(counter_en), .q(counter), .rst_l(rst_l), .clk(clk)); \n  assign counter_en = enqueue ^ dequeue; \n  assign next_counter = (enqueue)? counter + 1'b1: \n  counter - 1'b1; \n  assign valid = (counter != 1'b0); \n  endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a filter that takes input data and its 180-degree phase shifted version, processes it based on clock cycles, and outputs the filtered data. The module uses registers to delay the input data, and a clock pulse-triggered always block to update the output data and delayed input data. The updated output data is calculated based on the bitwise OR and AND operations between the current output data, delayed input data, and input data, and then stored in the next output data register.\n\n Module header:\n\nmodule filter (clock, indata, indata180, outdata);\n [/INST]\n", "output": "input clock; \n input [31:0] indata; \n input [31:0] indata180; \n output [31:0] outdata; \n reg [31:0] dly_indata, next_dly_indata; \n reg [31:0] dly_indata180, next_dly_indata180; \n reg [31:0] outdata, next_outdata; \n always @(posedge clock) \n begin \n  outdata = next_outdata; \n  dly_indata = next_dly_indata; \n  dly_indata180 = next_dly_indata180; \n end \n always @* \n begin \n  #1; \n  next_outdata = (outdata | dly_indata | indata) & dly_indata180; \n  next_dly_indata = indata; \n  next_dly_indata180 = indata180; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module is a flow LED controller that generates an alarm light pattern based on the inputs power, sig_ring, and sig_step. The alarm_light output is a register of size (NUM-1) and is updated on the positive edge of the sig_step signal. When power is high and sig_ring is asserted, the controller resets the count to 0, sets the alarm and alarm_light to 1. When sig_ring is not asserted, the count is incremented by 1 and the alarm_light is multiplied by 2, unless it's 0, in which case it's set to 1. When the count reaches the specified LEN, it is reset to 0, and the alarm and alarm_light are reset to 0. If power is low, the count, alarm, and alarm_light are all reset to 0.\n\n Module header:\n\nmodule flow_led #(parameter LEN = 5, NUM = 5) (input power,input sig_ring,input sig_step,output reg [(NUM-1):0] alarm_light);\n [/INST]\n", "output": "reg [31:0] count; \n  reg alarm; \n  initial begin \n  alarm <= 0; \n  count <= 0; \n  alarm_light <= 0; \n  end \n  always @(posedge sig_step) begin \n  if (power) begin \n  if (sig_ring) begin \n  count = 0; \n  alarm = 1; \n  alarm_light = 1; \n  end else begin \n  if (alarm == 1) begin \n  count = count + 1; \n  alarm_light = alarm_light * 2 ? alarm_light * 2 : 1; \n  end \n  if (count == LEN) begin \n  count = 0; \n  alarm = 0; \n  alarm_light = 0; \n  end \n  end \n  end else begin \n  count = 0; \n  alarm = 0; \n  alarm_light = 0; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes multiple inputs including `block_in`, `up_direction`, `direction`, `relative_xpos`, and `relative_ypos`, and produces outputs `block_out`, `write_enable`, and `new_point`. The logic within the always block determines the values of `block_out`, `write_enable`, and `new_point` based on the inputs and specified conditions. Additionally, the module contains localparam declarations to assign specific values to symbolic constants for the inputs and outputs.\n\n Module header:\n\nmodule new_block(input wire [5:0] block_in,input wire up_direction,input wire direction,input wire [9:0] relative_xpos,input wire [8:0] relative_ypos,output reg [5:0] block_out,output reg write_enable,output reg new_point);\n [/INST]\n", "output": "always @* begin \n  if(block_in == GY) begin \n  new_point = 1; \n  block_out = B; \n  write_enable = 1; \n  end \n  else if(((relative_xpos % 40) < 20) && (direction == 0)) begin \n  if(block_in == D) begin \n  if(up_direction) begin \n  new_point = 1; \n  block_out = DY; \n  write_enable = 1; \n  end \n  else begin \n  new_point = 0; \n  block_out = block_in; \n  write_enable = 0; \n  end \n  end \n  else if(block_in == J) begin \n  new_point = 0; \n  if(up_direction) begin \n  block_out = B; \n  write_enable = 1; \n  end \n  else begin \n  block_out = block_in; \n  write_enable = 0; \n  end \n  end \n  else begin \n  new_point = 0; \n  block_out = block_in; \n  write_enable = 0; \n  end \n  end \n  else if(((relative_xpos % 40) >= 20) && (direction == 1)) begin \n  if(block_in == D) begin \n  if(up_direction) begin \n  new_point = 1; \n  block_out = DY; \n  write_enable = 1; \n  end \n  else begin \n  new_point = 0; \n  block_out = block_in; \n  write_enable = 0; \n  end \n  end \n  else if(block_in == J) begin \n  new_point = 0; \n  if(up_direction) begin \n  block_out = B; \n  write_enable = 1; \n  end \n  else begin \n  block_out = block_in; \n  write_enable = 0; \n  end \n  end \n  else begin \n  new_point = 0; \n  block_out = block_in; \n  write_enable = 0; \n  end \n  end \n  else begin \n  new_point = 0; \n  block_out = block_in; \n  write_enable = 0; \n  end \n  end \n  localparam A = 1 ; \n  localparam B = 0 ; \n  localparam C = 2 ; \n  localparam D = 3 ; \n  localparam E = 4 ; \n  localparam F = 5 ; \n  localparam G = 6 ; \n  localparam H = 7 ; \n  localparam I = 8 ; \n  localparam J = 9 ; \n  localparam K = 10 ; \n  localparam L = 11 ; \n  localparam M = 12 ; \n  localparam N = 13 ; \n  localparam O = 14 ; \n  localparam P = 15 ; \n  localparam Q = 16 ; \n  localparam R = 17 ; \n  localparam S = 18 ; \n  localparam T = 19 ; \n  localparam U = 20 ; \n  localparam V = 21 ; \n  localparam W = 22 ; \n  localparam X = 23 ; \n  localparam Y = 24 ; \n  localparam Z = 25 ; \n  localparam AY = 26 ; \n  localparam IY = 27 ; \n  localparam GY = 28 ; \n  localparam KY = 29 ; \n  localparam PY = 30 ; \n  localparam TY = 31 ; \n  localparam UY = 32 ; \n  localparam WY = 33 ; \n  localparam DY = 34 ; \n  localparam BY = 35 ; \n  endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a GPIO (General Purpose Input/Output) interface with configurable parameters. It includes a bus translator and provides read and write access to an I/O port. The module interfaces with an IP (Intellectual Property) using address and data signals. It features a soft reset and provides direction control for the I/O. The module also handles data input and output operations. Additionally, it generates sequential logic for the I/O based on the direction and tri-state signals.\n\n Module header:\n\nmodule gpio #(parameter BASEADDR = 0,parameter HIGHADDR = 0,parameter ABUSWIDTH = 16,parameter IO_WIDTH = 8,parameter IO_DIRECTION = 0,parameter IO_TRI = 0)(BUS_CLK,BUS_RST,BUS_ADD,BUS_DATA,BUS_RD,BUS_WR,IO);\n [/INST]\n", "output": "localparam VERSION = 0; \n input wire BUS_CLK; \n input wire BUS_RST; \n input wire [ABUSWIDTH-1:0] BUS_ADD; \n inout wire [7:0] BUS_DATA; \n input wire BUS_RD; \n input wire BUS_WR; \n inout wire [IO_WIDTH-1:0] IO; \n wire IP_RD, IP_WR; \n wire [ABUSWIDTH-1:0] IP_ADD; \n wire [7:0] IP_DATA_IN; \n reg [7:0] IP_DATA_OUT; \n bus_to_ip #( .BASEADDR(BASEADDR), .HIGHADDR(HIGHADDR), .ABUSWIDTH(ABUSWIDTH) ) i_bus_to_ip \n (.BUS_RD(BUS_RD),.BUS_WR(BUS_WR),.BUS_ADD(BUS_ADD),.BUS_DATA(BUS_DATA),.IP_RD(IP_RD),.IP_WR(IP_WR),.IP_ADD(IP_ADD),.IP_DATA_IN(IP_DATA_IN),.IP_DATA_OUT(IP_DATA_OUT)); \n wire SOFT_RST; \n localparam IO_BYTES = ((IO_WIDTH-1)/8)+1; \n reg [7:0] INPUT_DATA [IO_BYTES-1:0]; \n reg [7:0] OUTPUT_DATA [IO_BYTES-1:0]; \n reg [7:0] DIRECTION_DATA [IO_BYTES-1:0]; \n always @ (posedge BUS_CLK) begin \n  if(IP_RD) begin \n  if(IP_ADD == 0) \n  IP_DATA_OUT <= VERSION; \n  else if(IP_ADD - 1 < IO_BYTES) \n  IP_DATA_OUT <= INPUT_DATA[IO_BYTES - IP_ADD]; \n  else if(IP_ADD - (IO_BYTES+1) < IO_BYTES) \n  IP_DATA_OUT <= OUTPUT_DATA[(IO_BYTES*2) - IP_ADD]; \n  else if(IP_ADD - (IO_BYTES*2+1) < IO_BYTES) \n  IP_DATA_OUT <= DIRECTION_DATA[(IO_BYTES*3) - IP_ADD]; \n  end \n end \n assign SOFT_RST = (IP_ADD==0 && IP_WR); \n wire RST; \n assign RST = BUS_RST | SOFT_RST; \n integer bi; \n always @(posedge BUS_CLK) begin \n  if(RST) begin \n  for(bi = 0; bi < IO_BYTES; bi = bi + 1) begin \n  DIRECTION_DATA[bi] <= 0; \n  OUTPUT_DATA[bi] <= 0; \n  end \n  end \n  else if(IP_WR) begin \n if(IP_ADD - 1 < IO_BYTES); \n  else if(IP_ADD - (IO_BYTES+1) < IO_BYTES) \n  OUTPUT_DATA[(IO_BYTES*2) - IP_ADD] <= IP_DATA_IN; \n  else if(IP_ADD - (IO_BYTES*2+1) < IO_BYTES) \n  DIRECTION_DATA[(IO_BYTES*3) - IP_ADD] <= IP_DATA_IN; \n  end \n end \n genvar i; \n generate \n  for(i=0; i<IO_WIDTH; i=i+1) begin: sreggen \n  if(IO_TRI[i]) \n  assign IO[i] = DIRECTION_DATA[i/8][i%8] ? OUTPUT_DATA[i/8][i%8] : 1'bz; \n  else if(IO_DIRECTION[i]) \n  assign IO[i] = OUTPUT_DATA[i/8][i%8]; \n  end \n endgenerate \n always @ (*) \n  for(bi = 0; bi < IO_WIDTH; bi = bi + 1) \n  INPUT_DATA[bi/8][bi%8] = IO[bi]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a register slice that processes incoming data and control signals for a specified configuration. It generates and updates internal registers based on the input data and control signals, and generates output signals such as laguna_m_payload, laguna_m_handshake, and S_READY. The module supports two configurations, 12 and 13, with different internal register implementations. It also contains a sub-instance called tdm_sample_inst. This module operates synchronously with the ACLK and ACLK2X clocks, and includes a reset mechanism.\n\n Module header:\n\nmodule axi_register_slice_v2_1_14_source_region_slr # (parameter C_FAMILY = \"virtex6\",parameter integer C_REG_CONFIG = 12,parameter integer C_DATA_WIDTH = 32,parameter integer C_SLR_WIDTH = 32) (input wire ACLK,input wire ACLK2X,input wire ARESET,input wire [C_DATA_WIDTH-1:0] S_PAYLOAD_DATA,input wire S_VALID,output wire S_READY,output wire [C_SLR_WIDTH-1:0] laguna_m_payload,output wire laguna_m_handshake,input wire m_ready);\n [/INST]\n", "output": "generate \n  (* dont_touch=\"true\" *) reg areset_d = 1'b0; \n  always @(posedge ACLK) begin \n  areset_d <= ARESET; \n  end \n  if (C_REG_CONFIG == 13) begin : gen_slr_tdm \n  localparam integer P_EVEN_WIDTH = C_DATA_WIDTH[0] ? (C_DATA_WIDTH+1) : C_DATA_WIDTH; \n  (* shreg_extract = \"no\" *) reg [P_EVEN_WIDTH-1:0] payload_d1; \n  (* shreg_extract = \"no\" *) reg [C_SLR_WIDTH-1:0] laguna_payload_tdm_d2; \n  (* shreg_extract = \"no\" *) reg laguna_handshake_d1 = 1'b0; \n  reg s_ready_d2 = 1'b0; \n  wire sample_cycle; \n  integer i; \n  assign laguna_m_payload = laguna_payload_tdm_d2; \n  assign laguna_m_handshake = laguna_handshake_d1; \n  assign S_READY = s_ready_d2; \n  always @(posedge ACLK) begin \n  if (s_ready_d2) begin \n  payload_d1 <= S_PAYLOAD_DATA; \n  end \n  end \n  always @(posedge ACLK2X) begin \n  for (i=0;i<C_SLR_WIDTH;i=i+1) begin \n  if (s_ready_d2) begin \n  if (~sample_cycle) begin \n  laguna_payload_tdm_d2[i] <= payload_d1[2*i+1]; \n  end else begin \n  laguna_payload_tdm_d2[i] <= payload_d1[2*i]; \n  end \n  end \n  end \n  end \n  always @(posedge ACLK) begin \n  if (areset_d) begin \n  laguna_handshake_d1 <= 1'b0; \n  s_ready_d2 <= 1'b0; \n  end else begin \n  if (s_ready_d2) begin \n  laguna_handshake_d1 <= S_VALID; \n  end \n  s_ready_d2 <= m_ready; \n  end \n  end \n axi_register_slice_v2_1_14_tdm_sample tdm_sample_inst (.slow_clk (ACLK),.fast_clk (ACLK2X),.sample_cycle (sample_cycle)); \n  end else if (C_REG_CONFIG == 12) begin : gen_slr_common \n  (* shreg_extract = \"no\" *) reg [C_DATA_WIDTH-1:0] laguna_payload_d1; \n  (* shreg_extract = \"no\" *) reg laguna_handshake_d1 = 1'b0; \n  reg s_ready_d2 = 1'b0; \n  assign laguna_m_payload = laguna_payload_d1; \n  assign laguna_m_handshake = laguna_handshake_d1; \n  assign S_READY = s_ready_d2; \n  always @(posedge ACLK) begin \n  if (s_ready_d2) begin \n  laguna_payload_d1 <= S_PAYLOAD_DATA; \n  end \n  end \n  always @(posedge ACLK) begin \n  if (areset_d) begin \n  laguna_handshake_d1 <= 1'b0; \n  s_ready_d2 <= 1'b0; \n  end else begin \n  if (s_ready_d2) begin \n  laguna_handshake_d1 <= S_VALID; \n  end \n  s_ready_d2 <= m_ready; \n  end \n  end \n  end \n endgenerate \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a pipeline for data transfer. It has input and output ports for data, validity, and stall signals. The module synchronously transfers input data to the output when the stall signal is not asserted. The validity of the output data is based on the input validity and the stall condition. The validity flag is synchronized with the clock and reset signals to ensure proper data transfer.\n\n Module header:\n\nmodule acl_io_pipeline #(parameter WIDTH = 1)(input clk,input reset,input i_stall,input i_valid,input [WIDTH-1:0] i_data,output o_stall,output reg o_valid,output reg [WIDTH-1:0] o_data);\n [/INST]\n", "output": "reg R_valid; \n assign o_stall = i_stall & R_valid; \n always@(posedge clk) begin \n  if(!o_stall) {o_valid, o_data} <= {i_valid, i_data}; \n end \n always@(posedge clk or posedge reset)begin \n  if(reset) R_valid <= 1'b0; \n  else if(!o_stall) R_valid <= i_valid; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an Arithmetic Logic Unit (ALU) that performs various operations based on the input opcode, such as AND, OR, XOR, NOT, ADD, SUB, MUL, shift operations, and comparisons. The module takes in two 32-bit data inputs, src0_data and src1_data, and outputs the result in dst_data. It also outputs the equality comparison result in eq_data. The operations are selected based on the opcode input, and the results are assigned to tmp_dst_data and tmp_eq_data. The ALU module uses combinational logic and a case statement to perform the specified operation and assign the result to the output.\n\n Module header:\n\nmodule fltcpu_alu(input wire clk,input wire reset_n,input wire [5 : 0] opcode,input wire [31 : 0] src0_data,input wire [31 : 0] src1_data,output wire [31 : 0] dst_data,output wire eq_data);\n [/INST]\n", "output": "localparam OPCODE_AND = 6'h04; \n  localparam OPCODE_OR = 6'h05; \n  localparam OPCODE_XOR = 6'h06; \n  localparam OPCODE_NOT = 6'h07; \n  localparam OPCODE_ADD = 6'h08; \n  localparam OPCODE_ADDI = 6'h09; \n  localparam OPCODE_SUB = 6'h0a; \n  localparam OPCODE_SUBI = 6'h0b; \n  localparam OPCODE_MUL = 6'h0c; \n  localparam OPCODE_MULI = 6'h0d; \n  localparam OPCODE_ASL = 6'h10; \n  localparam OPCODE_ROL = 6'h11; \n  localparam OPCODE_ASR = 6'h12; \n  localparam OPCODE_ROR = 6'h13; \n  localparam OPCODE_CMP = 6'h30; \n  localparam OPCODE_CMPI = 6'h31; \n  reg [31 : 0] tmp_dst_data; \n  reg tmp_eq_data; \n  wire [4 : 0] shamt; \n  assign dst_data = tmp_dst_data; \n  assign eq_data = tmp_eq_data; \n  assign shamt = src1_data[4 : 0]; \n  always @* \n  begin : alu \n  tmp_dst_data = 32'h0; \n  tmp_eq_data = 0; \n  case (opcode) \n  OPCODE_AND: \n  tmp_dst_data = src0_data & src1_data; \n  OPCODE_OR: \n  tmp_dst_data = src0_data | src1_data; \n  OPCODE_XOR: \n  tmp_dst_data = src0_data ^ src1_data; \n  OPCODE_NOT: \n  tmp_dst_data = ~src0_data; \n  OPCODE_ADD, OPCODE_ADDI: \n  tmp_dst_data = src0_data + src1_data; \n  OPCODE_SUB, OPCODE_SUBI: \n  tmp_dst_data = src0_data - src1_data; \n  OPCODE_MUL: \n  tmp_dst_data = src0_data * src1_data; \n  OPCODE_ASL: \n  tmp_dst_data = src0_data <<< shamt; \n  OPCODE_ROL: \n  tmp_dst_data = {(src0_data <<< shamt), \n  (src0_data >>> (32 - shamt))}; \n  OPCODE_ASR: \n  tmp_dst_data = src0_data >>> shamt; \n  OPCODE_ROR: \n  tmp_dst_data = {(src0_data >>> shamt), \n  (src0_data <<< (32 - shamt))}; \n  OPCODE_CMP, OPCODE_CMPI: \n  tmp_eq_data = src0_data == src1_data; \n  default: \n  begin \n  end \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a control module for a division operation. It uses the inputs clk, rst, start, MSB, and z to control the division process and outputs INIT, DV0, SH, DEC, LDA, and BUSY signals. It contains a 3-bit state machine to manage the division process. The state machine transitions between different states based on the input and outputs control signals accordingly. The module follows a specific sequence of states including RESET, IDLE, START, SHIFT_DEC, CHECK, ADD, LOAD, and END1 to manage the division process. The state machine determines the output signals based on the current state and input signals.\n\n Module header:\n\nmodule control_div( clk , rst , start , MSB , z , INIT , SH , DEC , LDA , BUSY, DV0 );\n [/INST]\n", "output": "input clk; \n  input rst; \n  input start; \n  input MSB; \n  input z; \n  output reg INIT; \n  output reg DV0; \n  output reg SH; \n  output reg DEC; \n  output reg LDA; \n  output reg BUSY; \n  parameter RESET = 3'b000, \n  IDLE = 3'b001, \n  START = 3'b010, \n  SHIFT_DEC = 3'b011, \n  CHECK = 3'b100, \n  ADD = 3'b101, \n  LOAD = 3'b110, \n  END1 = 3'b111; \n  reg [2:0] state; \n  initial begin \n  INIT=1; \n  DV0=0; \n  SH=0; \n  DEC=0; \n  LDA=0; \n  BUSY=1; \n  end \n reg [3:0] count; \n always @(posedge clk) begin \n  if (rst) begin \n  state = RESET; \n  end else begin \n  case(state) \n  RESET: begin \n  state <= IDLE; \n  end \n  IDLE: begin \n  if(start) \n  state = START; \n  else \n  state = IDLE; \n  end \n  START: begin \n  count=0; \n  state = SHIFT_DEC; \n  end \n  SHIFT_DEC: \n  state = CHECK; \n  CHECK: begin \n  if(z) \n  state = IDLE; \n  else begin \n  if (MSB==0) \n  state = ADD; \n  else \n  state = SHIFT_DEC; \n  end \n  end \n  ADD: state=LOAD; \n  LOAD: begin \n  if(z) \n  state = IDLE; \n  else \n  state = SHIFT_DEC; \n  end \n  default: state = START; \n  endcase \n  end \n  end \n always @(state) begin \n  case(state) \n  RESET:begin \n  INIT=1; \n  DV0=0; \n  SH=0; \n  DEC=0; \n  LDA=0; \n  BUSY=1; \n  end \n  IDLE:begin \n  INIT=0; \n  DV0=0; \n  SH=0; \n  DEC=0; \n  LDA=0; \n  BUSY=0; \n  end \n  START:begin \n  INIT=1; \n  DV0=0; \n  SH=0; \n  DEC=0; \n  LDA=0; \n  BUSY=1; \n  end \n  SHIFT_DEC:begin \n  INIT=0; \n  DV0=DV0; \n  SH=1; \n  DEC=1; \n  LDA=0; \n  BUSY=1; \n  end \n  CHECK:begin \n  INIT=0; \n  DV0=0; \n  SH=0; \n  DEC=0; \n  LDA=0; \n  BUSY=1; \n  end \n  ADD:begin \n  INIT=0; \n  DV0=1; \n  SH=0; \n  DEC=0; \n  LDA=0; \n  BUSY=1; \n  end \n  LOAD:begin \n  INIT=0; \n  DV0=0; \n  SH=0; \n  DEC=0; \n  LDA=1; \n  BUSY=1; \n  end \n  END1:begin \n  INIT=0; \n  DV0=0; \n  SH=0; \n  DEC=0; \n  LDA=0; \n  BUSY=0; \n  end \n  default:begin \n  INIT=1; \n  DV0=0; \n  SH=0; \n  DEC=0; \n  LDA=0; \n  BUSY=1; \n  end \n  endcase \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module represents a testbench for a pipeline design. It initializes various signals and triggers the clock signal. It includes an encoder, decoder, and large XOR gate. The simulation involves setting and displaying the values of q and rb for different values of b and e. The simulation finishes after a defined period.\n\n Module header:\n\nmodule tb_pipeline();\n [/INST]\n", "output": "wire [22:0] c; \n  wire [22:0] cx; \n  wire [10:0] q; \n  reg [10:0] b; \n  reg [10:0] r_b; \n  reg [22:0] e; \n  reg [22:0] r_e; \n  reg [22:0] r_c; \n  reg [22:0] rr_e; \n  reg [10:0] rr_b; \n  reg [22:0] r_qx; \n  reg [10:0] rb; \n  reg clk,reset; \n  reg [22:0] e2; \n encoder enc (r_b,c); \n decoder dec (r_qx,q); \n large_xor xr (r_c,rr_e,cx); \n  always begin \n  #10 clk = 0; \n  #10 clk = 1; \n  end \n  always@(posedge clk) \n  begin \n  if(reset) \n  begin \n  r_b<=0; \n  r_e<=0; \n  end \n  else \n  begin \n  r_e<=e; \n  r_b<=b; \n  end \n  end \n  always@(posedge clk) \n  begin \n  if(reset) \n  begin \n  r_c<=0; \n  rr_e<=0; \n  rr_b<=0; \n  end \n  else \n  begin \n  r_c<=c; \n  rr_e<=r_e; \n  rr_b<=r_b; \n  end \n  end \n  always@(posedge clk) \n  begin \n  if(reset) \n  begin \n  rb<=0; \n  end \n  else \n  begin \n  r_qx<=cx; \n  rb<=rr_b; \n  e2<=rr_e; \n  end \n  end \n  initial \n  begin \n  $display(\" << Starting the simulation >>\"); \n  reset=1; \n  #20; \n  reset=0; \n  b = $random; \n  e = 23'b00000000000000000000000; \n  $display(q, \"<< Displaying q >>\"); \n  $display(rb, \"<< Displaying rb >>\"); \n  #20; \n  b = $random; \n  e = 23'b00000000000000000000000; \n  $display(q, \"<< Displaying q >>\"); \n  $display(rb, \"<< Displaying rb >>\"); \n  #20; \n  b = $random; \n  e = 23'b00000100000000000000000; \n  $display(q, \"<< Displaying q >>\"); \n  $display(rb, \"<< Displaying rb >>\"); \n  #20; \n  b = $random; \n  e = 23'b00000000000000000000000; \n  $display(q, \"<< Displaying q >>\"); \n  $display(rb, \"<< Displaying rb >>\"); \n  #20; \n  b = $random; \n  e = 23'b00000000000000000000000; \n  $display(q, \"<< Displaying q >>\"); \n  $display(rb, \"<< Displaying rb >>\"); \n  #20; \n  b = $random; \n  e = 23'b00001000000000000000000; \n  $display(q, \"<< Displaying q >>\"); \n  $display(rb, \"<< Displaying rb >>\"); \n  #20; \n  b = $random; \n  e = 23'b00000000000000010000000; \n  $display(q, \"<< Displaying q >>\"); \n  $display(rb, \"<< Displaying rb >>\"); \n  #20; \n  b = $random; \n  e = 23'b00000000000000000000000; \n  $display(q, \"<< Displaying q >>\"); \n  $display(rb, \"<< Displaying rb >>\"); \n  #20; \n  b = $random; \n  e = 23'b00100000000000000000000; \n  $display(q, \"<< Displaying q >>\"); \n  $display(rb, \"<< Displaying rb >>\"); \n  #20; \n  b = $random; \n  e = 23'b00000000000000000000000; \n  $display(q, \"<< Displaying q >>\"); \n  $display(rb, \"<< Displaying rb >>\"); \n  #300; \n  $display(\" << Finishing the simulation >>\"); \n  $finish; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"sky130_fd_sc_hs__dfrtp\" is a flip-flop circuit with synchronous reset. It has inputs for power supply, ground, clock, data, and reset signals. The output is the buffered data. The module includes a delay for the input data and reset signals, as well as a delayed clock signal. It has an output notifier, an awake signal, and two condition signals. The module uses logic gates and an inverter to implement the functionality. The output Q is the buffered version of the input D. The module is designed to ensure proper functionality and timing synchronization.\n\n Module header:\n\nmodule sky130_fd_sc_hs__dfrtp (VPWR ,VGND ,Q ,CLK ,D ,RESET_B);\n [/INST]\n", "output": "input VPWR ; \n  input VGND ; \n  output Q ; \n  input CLK ; \n  input D ; \n  input RESET_B; \n  wire buf_Q ; \n  wire RESET ; \n  reg notifier ; \n  wire D_delayed ; \n  wire RESET_B_delayed; \n  wire CLK_delayed ; \n  wire awake ; \n  wire cond0 ; \n  wire cond1 ; \n  not not0 (RESET , RESET_B_delayed ); \n  sky130_fd_sc_hs__u_df_p_r_no_pg u_df_p_r_no_pg0 (buf_Q , D_delayed, CLK_delayed, RESET, notifier, VPWR, VGND); \n  assign awake = ( VPWR === 1'b1 ); \n  assign cond0 = ( awake && ( RESET_B_delayed === 1'b1 ) ); \n  assign cond1 = ( awake && ( RESET_B === 1'b1 ) ); \n  buf buf0 (Q , buf_Q ); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module is a 36-bit demultiplexer that uses a state machine to control the output data and ready signals based on the input data, ready signals, and control signals. It checks for a match between the input data and a specified pattern, and transitions between idle and data states accordingly. The demultiplexer also handles end-of-frame (EOF) detection and controls the output ready signals and data outputs based on the state machine's current state and input signals.\n\n Module header:\n\nmodule fifo36_demux #(parameter match_data = 0,parameter match_mask = 0) (input clk, input reset, input clear,input [35:0] data_i, input src_rdy_i, output dst_rdy_o,output [35:0] data0_o, output src0_rdy_o, input dst0_rdy_i,output [35:0] data1_o, output src1_rdy_o, input dst1_rdy_i);\n [/INST]\n", "output": "localparam DMX_IDLE = 0; \n  localparam DMX_DATA0 = 1; \n  localparam DMX_DATA1 = 2; \n  reg [1:0] state; \n  wire match = |( (data_i ^ match_data) & match_mask ); \n  wire eof = data_i[33]; \n  always @(posedge clk) \n  if(reset | clear) \n  state <= DMX_IDLE; \n  else \n  case(state) \n  DMX_IDLE : \n  if(src_rdy_i) \n  if(match) \n  state <= DMX_DATA1; \n  else \n  state <= DMX_DATA0; \n  DMX_DATA0 : \n  if(src_rdy_i & dst0_rdy_i & eof) \n  state <= DMX_IDLE; \n  DMX_DATA1 : \n  if(src_rdy_i & dst1_rdy_i & eof) \n  state <= DMX_IDLE; \n  default : \n  state <= DMX_IDLE; \n  endcase \n  assign dst_rdy_o = (state==DMX_IDLE) ? 0 : (state==DMX_DATA0) ? dst0_rdy_i : dst1_rdy_i; \n  assign src0_rdy_o = (state==DMX_DATA0) ? src_rdy_i : 0; \n  assign src1_rdy_o = (state==DMX_DATA1) ? src_rdy_i : 0; \n  assign data0_o = data_i; \n  assign data1_o = data_i; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe \"data_align\" module is designed to align and reformat incoming data. The input data \"sti_data\" is processed based on the \"disabledGroups\" input and then stored in \"sto_data.\" The module's functionality is driven by the clock signal and a reset signal. The \"sto_valid\" output indicates the validity of the processed data. The alignment and formatting of the data are determined by the \"insel0\", \"insel1\", and \"insel2\" registers, which are controlled based on the \"disabledGroups\" input. The specific data manipulation operations are defined within the \"always\" blocks, which are sensitive to clock edges and the reset signal. The module effectively aligns the input data based on the specified criteria and updates the output data and validity signal accordingly.\n\n Module header:\n\nmodule data_align #(parameter integer DW = 32,parameter integer KW = DW/8)(input wire clk,input wire rst,input wire [3:0] disabledGroups,input wire sti_valid,input wire [31:0] sti_data,output reg sto_valid,output reg [31:0] sto_data);\n [/INST]\n", "output": "reg [1:0] insel0; \n reg [1:0] insel1; \n reg insel2; \n always @ (posedge clk) \n begin \n  case (insel0[1:0]) \n  2'h3 : sto_data[ 7: 0] <= sti_data[31:24]; \n  2'h2 : sto_data[ 7: 0] <= sti_data[23:16]; \n  2'h1 : sto_data[ 7: 0] <= sti_data[15: 8]; \n  default : sto_data[ 7: 0] <= sti_data[ 7: 0]; \n  endcase \n  case (insel1[1:0]) \n  2'h2 : sto_data[15: 8] <= sti_data[31:24]; \n  2'h1 : sto_data[15: 8] <= sti_data[23:16]; \n  default : sto_data[15: 8] <= sti_data[15: 8]; \n  endcase \n  case (insel2) \n  1'b1 : sto_data[23:16] <= sti_data[31:24]; \n  default : sto_data[23:16] <= sti_data[23:16]; \n  endcase \n  sto_data[31:24] <= sti_data[31:24]; \n end \n always @(posedge clk) \n begin \n  case (disabledGroups) \n  4'b0001 : begin insel2 <= 1'b1; insel1 <= 2'h1; insel0 <= 2'h1; end \n  4'b0010 : begin insel2 <= 1'b1; insel1 <= 2'h1; insel0 <= 2'h0; end \n  4'b0100 : begin insel2 <= 1'b1; insel1 <= 2'h0; insel0 <= 2'h0; end \n  4'b0011 : begin insel2 <= 1'b0; insel1 <= 2'h2; insel0 <= 2'h2; end \n  4'b0101 : begin insel2 <= 1'b0; insel1 <= 2'h2; insel0 <= 2'h1; end \n  4'b1001 : begin insel2 <= 1'b0; insel1 <= 2'h1; insel0 <= 2'h1; end \n  4'b0110 : begin insel2 <= 1'b0; insel1 <= 2'h2; insel0 <= 2'h0; end \n  4'b1010 : begin insel2 <= 1'b0; insel1 <= 2'h1; insel0 <= 2'h0; end \n  4'b1100 : begin insel2 <= 1'b0; insel1 <= 2'h0; insel0 <= 2'h0; end \n  4'b0111 : begin insel2 <= 1'b0; insel1 <= 2'h0; insel0 <= 2'h3; end \n  4'b1011 : begin insel2 <= 1'b0; insel1 <= 2'h0; insel0 <= 2'h2; end \n  4'b1101 : begin insel2 <= 1'b0; insel1 <= 2'h0; insel0 <= 2'h1; end \n  default : begin insel2 <= 1'b0; insel1 <= 2'h0; insel0 <= 2'h0; end \n  endcase \n end \n always @(posedge clk, posedge rst) \n if (rst) sto_valid <= 1'b0; \n else sto_valid <= sti_valid; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a multiplier-accumulator (MAC) circuit. It uses shift registers to store and manipulate the input and output data. The multiplier and adder components are instantiated as separate modules to perform their respective operations. The flush_counter is used to control the flushing of the intermediate data. The module continuously shifts and updates the values in the shift registers based on the clock and control signals. The module ultimately produces the result of the MAC operation at the output, `dout`.\n\n Module header:\n\nmodule mac(input clk,input reset,input [9:0] row,input [63:0] value0,input [63:0] value1,input wr,output push,output [63:0] dout,input done);\n [/INST]\n", "output": "reg multiplier_shift [14:0]; \n  reg [9:0] multiplier_row_shift [14:0]; \n  reg adder_shift [11:0]; \n  reg [9:0] adder_row_shift [11:0]; \n  wire [63:0] multy_result; \n  wire [63:0] sum; \n  wire inter_add; \n  wire [63:0] inter_add0, inter_add1; \n  wire [9:0] inter_add_row; \n  integer i; \n multiplier multy(.clk(clk),.result(multy_result),.a(value0),.b(value1)); \n  always @(posedge clk) begin \n  multiplier_shift[0] <= wr; \n  multiplier_row_shift[0] <= row; \n  for(i = 0; i < 14; i = i + 1) begin \n  multiplier_shift[i + 1] <= multiplier_shift[i]; \n  multiplier_row_shift[i + 1] <= multiplier_row_shift[i]; \n  end \n  end \n  reg [7:0] flush_counter; \n  wire flush; \n  always @(posedge clk) begin \n  if(reset) \n  flush_counter <= 0; \n  else if(done) \n  flush_counter <= flush_counter + 1; \n  else \n  flush_counter <= 0; \n  end \n  assign flush = flush_counter[7]; \n intermediator inter(.reset(reset),.clk(clk),.valid0(multiplier_shift[14]),.value0(multy_result),.row0(multiplier_row_shift[14]),.valid1(adder_shift[11]),.value1(sum),.row1(adder_row_shift[11]),.store(push),.store_value(dout),.add(inter_add),.add0(inter_add0),.add1(inter_add1),.add_row(inter_add_row),.flush(flush)); \n adder addy(.clk(clk),.result(sum),.a(inter_add0),.b(inter_add1)); \n  always @(posedge clk) begin \n  adder_shift[0] <= inter_add; \n  adder_row_shift[0] <= inter_add_row; \n  for(i = 0; i < 11; i = i + 1) begin \n  adder_shift[i + 1] <= adder_shift[i]; \n  adder_row_shift[i + 1] <= adder_row_shift[i]; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a contrast adjustment module using DSP48 blocks. It multiplies the input signals in0 and in1 and adds the result to the input in2, and then outputs the result in dout. The module uses temporary variables for the multiplication and the addition, and the multiplication is performed using signed fixed-point arithmetic.\n\n Module header:\n\nmodule hls_contrast_stredEe_DSP48_2(input [8 - 1:0] in0,input [23 - 1:0] in1,input [29 - 1:0] in2,output [30 - 1:0] dout);\n [/INST]\n", "output": "wire signed [25 - 1:0] a; \n wire signed [18 - 1:0] b; \n wire signed [48 - 1:0] c; \n wire signed [43 - 1:0] m; \n wire signed [48 - 1:0] p; \n assign a = $unsigned(in1); \n assign b = $unsigned(in0); \n assign c = $unsigned(in2); \n assign m = a * b; \n assign p = m + c; \n assign dout = p; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a DC filter that processes input data based on various control signals. It utilizes registers to store and update the DC offset and output signals based on the input data, filter coefficients, and offset values. The module also checks for valid input data and enables the filter as specified by the control signals. The output valid and data signals are updated accordingly based on the filter operation.\n\n Module header:\n\nmodule ad_dcfilter (clk,valid,data,valid_out,data_out,dcfilt_enb,dcfilt_coeff,dcfilt_offset);\n [/INST]\n", "output": "input clk; \n  input valid; \n  input [15:0] data; \n  output valid_out; \n  output [15:0] data_out; \n  input dcfilt_enb; \n  input [15:0] dcfilt_coeff; \n  input [15:0] dcfilt_offset; \n  reg [15:0] dc_offset = 'd0; \n  reg [32:0] dc_offset_33 = 'd0; \n  reg valid_d = 'd0; \n  reg [15:0] data_d = 'd0; \n  reg valid_out = 'd0; \n  reg [15:0] data_out = 'd0; \n  wire [32:0] dc_offset_33_s; \n  always @(posedge clk) begin \n  dc_offset <= dc_offset_33_s[32:17]; \n  dc_offset_33 <= dc_offset_33_s; \n  valid_d <= valid; \n  if (valid == 1'b1) begin \n  data_d <= data + dcfilt_offset; \n  end \n  if (dcfilt_enb == 1'b1) begin \n  valid_out <= valid_d; \n  data_out <= data_d - dc_offset; \n  end else begin \n  valid_out <= valid_d; \n  data_out <= data_d; \n  end \n  end \n ad_dcfilter_1 i_dcfilter_1 (.clk (clk),.d (data_d),.b (dcfilt_coeff),.a (dc_offset_33[32:17]),.c (dc_offset_33[32:17]),.p (dc_offset_33_s)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a divide-by-1, 2, 4, or 8 circuit, where the output ceout is driven based on the input divisor and the count sequence. The counter increments on the positive edge of the clock when cein is high. The ceout output is determined based on the divisor and the counter values using a case statement. If the divisor is 00, ceout is updated based on cein. If the divisor is 01, ceout is updated based on cein and the least significant bit of the counter, and so on for the other divisor values. If the divisor value is unknown, ceoutmux is set to an unknown value.\n\n Module header:\n\nmodule divby1248(input clk,input cein,input [1:0] divisor,output ceout);\n [/INST]\n", "output": "reg ceoutmux; \n  reg [2:0] counter; \n  initial counter = 0; \n  assign ceout = ceoutmux; \n  always @(posedge clk) begin \n  if(cein) \n  counter <= counter + 1; \n  end \n  always @(*) begin \n  case(divisor) \n  2'b00: \n  ceoutmux <= cein; \n  2'b01: \n  ceoutmux <= cein & counter[0]; \n  2'b10: \n  ceoutmux <= cein & counter[0] & counter[1]; \n  2'b11: \n  ceoutmux <= cein & counter[0] & counter[1] & counter[2]; \n  default: \n  ceoutmux <= 1'bx; \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, named \"atomic_alu,\" implements an atomic Arithmetic Logic Unit (ALU) that performs various atomic operations. The module has inputs for the read data, atomic operation, operand0, and operand1, and an output for the atomic result. It supports multiple atomic operations such as addition, comparison, exchange, minimum, maximum, bitwise AND, bitwise OR, and bitwise XOR. The outputs of each operation are calculated based on the input signals and the supported operations. The module uses a case statement to select the appropriate operation based on the atomic operation input.\n\n Module header:\n\nmodule atomic_alu (readdata,atomic_op,operand0,operand1,atomic_out);\n [/INST]\n", "output": "parameter ATOMIC_OP_WIDTH=3; \n parameter OPERATION_WIDTH=32; \n parameter USED_ATOMIC_OPERATIONS=8'b00000001; \n localparam a_ADD=0; \n localparam a_XCHG=1; \n localparam a_CMPXCHG=2; \n localparam a_MIN=3; \n localparam a_MAX=4; \n localparam a_AND=5; \n localparam a_OR=6; \n localparam a_XOR=7; \n input logic [OPERATION_WIDTH-1:0] readdata; \n input logic [ATOMIC_OP_WIDTH-1:0] atomic_op; \n input logic [OPERATION_WIDTH-1:0] operand0; \n input logic [OPERATION_WIDTH-1:0] operand1; \n output logic [OPERATION_WIDTH-1:0] atomic_out; \n wire [31:0] atomic_out_add ; \n wire [31:0] atomic_out_cmp ; \n wire [31:0] atomic_out_cmpxchg ; \n wire [31:0] atomic_out_min ; \n wire [31:0] atomic_out_max ; \n wire [31:0] atomic_out_and ; \n wire [31:0] atomic_out_or ; \n wire [31:0] atomic_out_xor ; \n generate \n if( ( USED_ATOMIC_OPERATIONS & (1 << a_ADD) ) != 0 ) assign atomic_out_add = readdata + operand0; \n else assign atomic_out_add = {ATOMIC_OP_WIDTH{1'bx}}; \n endgenerate \n generate \n if( ( USED_ATOMIC_OPERATIONS & (1 << a_XCHG) ) != 0 ) assign atomic_out_cmp = operand0; \n else assign atomic_out_cmp = {ATOMIC_OP_WIDTH{1'bx}}; \n endgenerate \n generate \n if( ( USED_ATOMIC_OPERATIONS & (1 << a_CMPXCHG) ) != 0 ) assign atomic_out_cmpxchg = ( readdata == operand0 ) ? operand1 : readdata; \n else assign atomic_out_cmpxchg = {ATOMIC_OP_WIDTH{1'bx}}; \n endgenerate \n generate \n if( ( USED_ATOMIC_OPERATIONS & (1 << a_MIN) ) != 0 ) assign atomic_out_min = ( readdata < operand0 ) ? readdata : operand0; \n else assign atomic_out_min = {ATOMIC_OP_WIDTH{1'bx}}; \n endgenerate \n generate \n if( ( USED_ATOMIC_OPERATIONS & (1 << a_MAX) ) != 0 ) assign atomic_out_max = (readdata > operand0) ? readdata : operand0; \n else assign atomic_out_max = {ATOMIC_OP_WIDTH{1'bx}}; \n endgenerate \n generate \n if( ( USED_ATOMIC_OPERATIONS & (1 << a_AND) ) != 0 ) assign atomic_out_and = ( readdata & operand0 ); \n else assign atomic_out_and = {ATOMIC_OP_WIDTH{1'bx}}; \n endgenerate \n generate \n if( ( USED_ATOMIC_OPERATIONS & (1 << a_OR) ) != 0 ) assign atomic_out_or = ( readdata | operand0 ); \n else assign atomic_out_or = {ATOMIC_OP_WIDTH{1'bx}}; \n endgenerate \n generate \n if( ( USED_ATOMIC_OPERATIONS & (1 << a_XOR) ) != 0 ) assign atomic_out_xor = ( readdata ^ operand0 ); \n else assign atomic_out_xor = {ATOMIC_OP_WIDTH{1'bx}}; \n endgenerate \n always @(*) \n begin \n  case ( atomic_op ) \n  a_ADD: \n  begin \n  atomic_out = atomic_out_add; \n  end \n  a_XCHG: \n  begin \n  atomic_out = atomic_out_cmp; \n  end \n  a_CMPXCHG: \n  begin \n  atomic_out = atomic_out_cmpxchg; \n  end \n  a_MIN: \n  begin \n  atomic_out = atomic_out_min; \n  end \n  a_MAX: \n  begin \n  atomic_out = atomic_out_max; \n  end \n  a_AND: \n  begin \n  atomic_out = atomic_out_and; \n  end \n  a_OR: \n  begin \n  atomic_out = atomic_out_or; \n  end \n  default: \n  begin \n  atomic_out = atomic_out_xor; \n  end \n  endcase \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module implements a MFM (Modified Frequency Modulation) decoding logic. It takes MFM data, edge detection, and skip signals as inputs and outputs a real bit and a valid signal. It maintains a timer to synchronize with the MFM data transitions, handles skip signals, and decodes the MFM data to determine the real bit value. The module includes error handling to indicate MFM errors.\n\n Module header:\n\nmodule mfmDecode(clk, rst, mfmIn, mfmEdge, skipMFMBit, currentRealBit, currentRealBitValid);\n [/INST]\n", "output": "input clk; \n  input rst; \n  input mfmIn; \n  input mfmEdge; \n  input skipMFMBit; \n  output reg currentRealBit; \n  output reg currentRealBitValid; \n  reg [2:0] mfmTimer; \n  reg firstEdgeDetected; \n  reg currentMFMBitValid; \n  reg updateRealBit; \n  reg localSkipMFMBit; \n  reg skipOutputLoop; \n  reg [3:0] prevMFMBits; \n  always @(posedge clk) begin \n  if(rst) begin \n  mfmTimer <= 4'b0; \n  firstEdgeDetected <= 0; \n  currentMFMBitValid <= 0; \n  end else begin \n  currentMFMBitValid <= 0; \n  if(mfmEdge) begin \n  mfmTimer <= 4'b0; \n  firstEdgeDetected <= 1; \n  end else begin \n  if(firstEdgeDetected) begin \n  mfmTimer <= mfmTimer + 1'b1; \n  if(mfmTimer == 2) begin \n  currentMFMBitValid <= 1; \n  end \n  end \n  end \n  end \n  end \n  always @(posedge clk) begin \n  if(rst) begin \n  currentRealBit <= 0; \n  currentRealBitValid <= 0; \n  prevMFMBits <= 4'b0; \n  updateRealBit <= 0; \n  localSkipMFMBit <= 0; \n  skipOutputLoop <= 0; \n  end else begin \n  currentRealBitValid <= 0; \n  updateRealBit <= 0; \n  if(skipMFMBit) begin \n  localSkipMFMBit <= 1; \n  end \n  if(currentMFMBitValid) begin \n  prevMFMBits <= {prevMFMBits[2:0], mfmIn}; \n  updateRealBit <= updateRealBit + 1; \n  end \n  if(updateRealBit) begin \n  if(localSkipMFMBit) begin \n  localSkipMFMBit <= 0; \n  end else if(skipOutputLoop) begin \n  skipOutputLoop <= 0; \n  end else begin \n  skipOutputLoop <= 1; \n  casez (prevMFMBits) \n  4'b0100,4'bz010: begin \n  currentRealBit <= 0; \n  currentRealBitValid <= 1; \n  end \n  4'bzz01: begin \n  currentRealBit <= 1; \n  currentRealBitValid <= 1; \n  end \n  default: begin \n  $display(\"MFM ERROR\"); \n  end \n  endcase \n  end \n  end \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a part of a USB JTAG interface. It takes in control signals and data from the JTAG protocol and manages the transmission and reception of data. The module contains logic to synchronize and control the flow of data, as well as the reception and transmission status. It also interfaces with two other modules, JTAG_REC and JTAG_TRANS, to handle the JTAG receive and transmit operations. The module also includes logic to handle the reset signal and to control the ready and done signals for data transmission and reception.\n\n Module header:\n\nmodule USB_JTAG (iTxD_DATA, oTxD_Done, iTxD_Start,oRxD_DATA, oRxD_Ready, iRST_n,iCLK,TDO, TDI, TCS, TCK);\n [/INST]\n", "output": "input [7:0] iTxD_DATA; \n input iTxD_Start, iRST_n, iCLK; \n output reg [7:0] oRxD_DATA; \n output reg oTxD_Done, oRxD_Ready; \n input TDI, TCS, TCK; \n output TDO; \n wire [7:0] mRxD_DATA; \n wire mTxD_Done, mRxD_Ready; \n reg Pre_TxD_Done, Pre_RxD_Ready; \n reg mTCK; \n  JTAG_REC u0 (mRxD_DATA, mRxD_Ready, TDI, TCS, mTCK); \n  JTAG_TRANS u1 (iTxD_DATA, iTxD_Start, mTxD_Done, TDO, TCK, TCS); \n always @(posedge iCLK) \n begin \n  mTCK <= TCK; \n end \n always @(posedge iCLK or negedge iRST_n) \n begin \n  if(!iRST_n) \n  begin \n  oRxD_Ready <= 1'b0; \n  Pre_RxD_Ready <= 1'b0; \n  end \n  else \n  begin \n  Pre_RxD_Ready <= mRxD_Ready; \n  if ({Pre_RxD_Ready, mRxD_Ready} == 2'b01 && ~iTxD_Start) \n  begin \n  oRxD_Ready <= 1'b1; \n  oRxD_DATA <= mRxD_DATA; \n  end \n  else \n  begin \n  oRxD_Ready <= 1'b0; \n  end \n  end \n end \n always @(posedge iCLK or negedge iRST_n) \n begin \n  if(!iRST_n) \n  begin \n  oTxD_Done <= 1'b0; \n  Pre_TxD_Done <= 1'b0; \n  end \n  else \n  begin \n  Pre_TxD_Done <= mTxD_Done; \n  if ({Pre_TxD_Done,mTxD_Done} == 2'b01) \n  begin \n  oTxD_Done <= 1'b1; \n  end \n  else \n  begin \n  oTxD_Done <= 1'b0; \n  end \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, named \"resetter,\" is designed to generate a synchronous reset signal based on the input clock and asynchronous reset signal. It uses a reset counter to create a clean reset pulse and synchronize it with the clock domain. The parameter \"RST_CNT_SIZE\" determines the size of the reset counter.\n\nDuring simulation, the reset signals are initialized to 0. On the rising edge of the clock or falling edge of the asynchronous reset signal, the module checks for the assertion of the reset. If the reset is asserted, it sets the reset counter and signals to 0. Otherwise, it increments the reset counter and sets the output reset signal once the counter reaches a certain value.\n\nOverall, this module provides a clean and synchronized reset signal based on the input clock and asynchronous reset signal.\n\n Module header:\n\nmodule resetter(clk,rst_in_n,rst_out_n );\n [/INST]\n", "output": "parameter RST_CNT_SIZE = 4; \n  input clk; \n  input rst_in_n; \n  output rst_out_n; \n  reg rst_out_n; \n  reg [RST_CNT_SIZE:0] rst_cnt; \n  reg rst1_n,rst2_n; \n `ifdef SIMULATE \n  initial \n  begin \n  rst_cnt = 0; \n  rst1_n = 1'b0; \n  rst2_n = 1'b0; \n  rst_out_n = 1'b0; \n  end \n `endif \n  always @(posedge clk, negedge rst_in_n) \n  if( !rst_in_n ) \n  begin \n  rst_cnt <= 0; \n  rst1_n <= 1'b0; \n  rst2_n <= 1'b0; \n  rst_out_n <= 1'b0; \n  end \n  else \n  begin \n  rst1_n <= 1'b1; \n  rst2_n <= rst1_n; \n  if( rst2_n && !rst_cnt[RST_CNT_SIZE] ) \n  begin \n  rst_cnt <= rst_cnt + 1; \n  end \n  if( rst_cnt[RST_CNT_SIZE] ) \n  begin \n  rst_out_n <= 1'b1; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a fast Fourier transform (FFT) circuit. It takes in various clock and control signals, data inputs, and configuration inputs. It includes internal logic to handle the control signals, data reformatting, and configuration. The module instantiates a specialized FFT module (syntheses_xfft_v9_0_0) to perform the FFT computation. The module outputs various events, data, and configuration signals, as well as the processed FFT data.\n\n Module header:\n\nmodule xlfast_fourier_transform_e88bcbd69f6fa35c516aded21de2b91c (ce,clk,event_data_in_channel_halt,event_data_out_channel_halt,event_frame_started,event_status_channel_halt,event_tlast_missing,event_tlast_unexpected,m_axis_data_tdata_xn_im_0,m_axis_data_tdata_xn_re_0,m_axis_data_tlast,m_axis_data_tready,m_axis_data_tvalid,rst,s_axis_config_tdata_fwd_inv,s_axis_config_tready,s_axis_config_tvalid,s_axis_data_tdata_xn_im_0,s_axis_data_tdata_xn_re_0,s_axis_data_tlast,s_axis_data_tready,s_axis_data_tvalid);\n [/INST]\n", "output": "input ce; \n input clk; \n output event_data_in_channel_halt; \n output event_data_out_channel_halt; \n output event_frame_started; \n output event_status_channel_halt; \n output event_tlast_missing; \n output event_tlast_unexpected; \n output[20:0] m_axis_data_tdata_xn_im_0; \n output[20:0] m_axis_data_tdata_xn_re_0; \n output m_axis_data_tlast; \n input m_axis_data_tready; \n output m_axis_data_tvalid; \n input rst; \n input[0:0] s_axis_config_tdata_fwd_inv; \n output s_axis_config_tready; \n input s_axis_config_tvalid; \n input[15:0] s_axis_data_tdata_xn_im_0; \n input[15:0] s_axis_data_tdata_xn_re_0; \n input s_axis_data_tlast; \n output s_axis_data_tready; \n input s_axis_data_tvalid; \n wire aresetn_net; \n wire[47:0] m_axis_data_tdata_net; \n wire[7:0] s_axis_config_tdata_net; \n wire[31:0] s_axis_data_tdata_net; \n  assign aresetn_net = rst | (~ ce); \n  assign m_axis_data_tdata_xn_im_0 = m_axis_data_tdata_net[44 : 24]; \n  assign m_axis_data_tdata_xn_re_0 = m_axis_data_tdata_net[20 : 0]; \n  assign s_axis_config_tdata_net[7 : 1] = 7'b0; \n  assign s_axis_config_tdata_net[0 : 0] = s_axis_config_tdata_fwd_inv; \n  assign s_axis_data_tdata_net[31 : 16] = s_axis_data_tdata_xn_im_0; \n  assign s_axis_data_tdata_net[15 : 0] = s_axis_data_tdata_xn_re_0; \n syntheses_xfft_v9_0_0 syntheses_xfft_v9_0_0_instance(.aclk(clk),.aclken(ce),.aresetn(aresetn_net),.event_data_in_channel_halt(event_data_in_channel_halt),.event_data_out_channel_halt(event_data_out_channel_halt),.event_frame_started(event_frame_started),.event_status_channel_halt(event_status_channel_halt),.event_tlast_missing(event_tlast_missing),.event_tlast_unexpected(event_tlast_unexpected),.m_axis_data_tdata(m_axis_data_tdata_net),.m_axis_data_tlast(m_axis_data_tlast),.m_axis_data_tready(m_axis_data_tready),.m_axis_data_tvalid(m_axis_data_tvalid),.s_axis_config_tdata(s_axis_config_tdata_net),.s_axis_config_tready(s_axis_config_tready),.s_axis_config_tvalid(s_axis_config_tvalid),.s_axis_data_tdata(s_axis_data_tdata_net),.s_axis_data_tlast(s_axis_data_tlast),.s_axis_data_tready(s_axis_data_tready),.s_axis_data_tvalid(s_axis_data_tvalid)); \n  endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module instantiates another module and connects its output to the top-level output port. The wire w0 connects the output of the instantiated module to the output port of the top-level module. The instantiated module is not provided in this code snippet.\n\n Module header:\n\nmodule v3e6c24 (output v608bd9);\n [/INST]\n", "output": "wire w0; \n  assign v608bd9 = w0; \n v3e6c24_v68c173 v68c173 (.v(w0)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module generates random numbers based on the provided seed value. It utilizes a 32-bit register to store the seed value and updates it with a new random value on every clock cycle. When the start signal is asserted, the module assigns the output based on the three most significant bits of either the seed or the seed register, depending on the start signal.\n\n Module header:\n\nmodule rand(input clk, input[31:0] seed, input start, output[2:0] number);\n [/INST]\n", "output": "reg[31:0] seed_reg; \n assign number = start ? seed[31:29] : seed_reg[31:29]; \n always @(posedge clk) \n begin \n  seed_reg <= seed_reg * 1103515245; \n  if(start) \n  seed_reg <= seed; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a request generator for a Direct Memory Access Controller (DMAC). It generates memory access requests with a specified ID, burst count, and end-of-transfer (EOT) signal based on input signals such as clock, reset, request validity, enable, and pause. The module tracks the burst count and increments the request ID. It also manages the request readiness based on the input signals and updates the request ID and burst count accordingly.\n\n Module header:\n\nmodule dmac_request_generator (input req_aclk,input req_aresetn,output [C_ID_WIDTH-1:0] request_id,input [C_ID_WIDTH-1:0] response_id,input req_valid,output reg req_ready,input [C_BURSTS_PER_TRANSFER_WIDTH-1:0] req_burst_count,input enable,input pause,output eot);\n [/INST]\n", "output": "parameter C_ID_WIDTH = 3; \n parameter C_BURSTS_PER_TRANSFER_WIDTH = 17; \n reg [C_BURSTS_PER_TRANSFER_WIDTH-1:0] burst_count = 'h00; \n reg [C_ID_WIDTH-1:0] id; \n wire [C_ID_WIDTH-1:0] id_next = inc_id(id); \n assign eot = burst_count == 'h00; \n assign request_id = id; \n always @(posedge req_aclk) \n begin \n  if (req_aresetn == 1'b0) begin \n  burst_count <= 'h00; \n  id <= 'h0; \n  req_ready <= 1'b1; \n  end else if (enable == 1'b0) begin \n  req_ready <= 1'b1; \n  end else begin \n  if (req_ready) begin \n  if (req_valid && enable) begin \n  burst_count <= req_burst_count; \n  req_ready <= 1'b0; \n  end \n  end else if (response_id != id_next && ~pause) begin \n  if (eot) \n  req_ready <= 1'b1; \n  burst_count <= burst_count - 1'b1; \n  id <= id_next; \n  end \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module instantiates an RGB to YCbCr converter, which takes in 8-bit red, green, and blue signals, as well as input horizontal and vertical synchronization signals, and outputs 8-bit luminance, chroma blue, and chroma red signals, as well as output horizontal and vertical synchronization signals, and output data enable signal. The module also includes a clock signal and chip enable signal to control the conversion process. The initial block sets the input signals to specific values and the clock signal to a frequency of 100 MHz. The always block inverts the clock signal to create a complementary signal.\n\n Module header:\n\nmodule tb_rgb2ycbcr;\n [/INST]\n", "output": "reg clk = 0; \n  reg ce = 1'b1; \n  reg [7:0] R; \n  reg [7:0] G; \n  reg [7:0] B; \n  reg in_hsync = 0; \n  reg in_vsync = 0; \n  reg in_de = 0; \n  wire [7:0] Y; \n  wire [7:0] Cb; \n  wire [7:0] Cr; \n  wire out_hsync; \n  wire out_vsync; \n  wire out_de; \n rgb2ycbcr uut (.clk(clk),.ce(ce),.R(R),.G(G),.B(B),.in_hsync(in_hsync),.in_vsync(in_vsync),.in_de(in_de),.Y(Y),.Cb(Cb),.Cr(Cr),.out_hsync(out_hsync),.out_vsync(out_vsync),.out_de(out_de)); \n  initial begin \n  clk = 0; \n  ce = 1; \n  R = 8'b11110011; \n  G = 8'b00001100; \n  B = 8'b00101101; \n  in_hsync = 0; \n  in_vsync = 0; \n  in_de = 0; \n  #100; \n  end \n always #1 clk = ~clk; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a control unit for a trace memory module. It takes various input signals such as clock, reset, and control signals, and provides outputs including the trace memory data, address, and control signals. The module uses sequential and combinational logic to handle the trace memory address and control signals based on the input conditions. It also performs operations such as address resets, updates, and validation checks to control the trace memory functionality.\n\n Module header:\n\nmodule limbus_nios2_qsys_0_nios2_oci_im (clk,jdo,jrst_n,reset_n,take_action_tracectrl,take_action_tracemem_a,take_action_tracemem_b,take_no_action_tracemem_a,trc_ctrl,tw,tracemem_on,tracemem_trcdata,tracemem_tw,trc_enb,trc_im_addr,trc_wrap,xbrk_wrap_traceoff);\n [/INST]\n", "output": "output tracemem_on; \n  output [ 35: 0] tracemem_trcdata; \n  output tracemem_tw; \n  output trc_enb; \n  output [ 6: 0] trc_im_addr; \n  output trc_wrap; \n  output xbrk_wrap_traceoff; \n  input clk; \n  input [ 37: 0] jdo; \n  input jrst_n; \n  input reset_n; \n  input take_action_tracectrl; \n  input take_action_tracemem_a; \n  input take_action_tracemem_b; \n  input take_no_action_tracemem_a; \n  input [ 15: 0] trc_ctrl; \n  input [ 35: 0] tw; \n  wire tracemem_on; \n  wire [ 35: 0] tracemem_trcdata; \n  wire tracemem_tw; \n  wire trc_enb; \n  reg [ 6: 0] trc_im_addr ; \n  wire [ 35: 0] trc_im_data; \n  reg [ 16: 0] trc_jtag_addr ; \n  wire trc_on_chip; \n  reg trc_wrap ; \n  wire tw_valid; \n  wire xbrk_wrap_traceoff; \n  assign trc_im_data = tw; \n  always @(posedge clk or negedge jrst_n) \n  begin \n  if (jrst_n == 0) \n  begin \n  trc_im_addr <= 0; \n  trc_wrap <= 0; \n  end \n  else if (!0) \n  begin \n  trc_im_addr <= 0; \n  trc_wrap <= 0; \n  end \n else if (take_action_tracectrl &&(jdo[4] | jdo[3])) \n  begin \n  if (jdo[4]) \n  trc_im_addr <= 0; \n  if (jdo[3]) \n  trc_wrap <= 0; \n  end \n  else if (trc_enb & trc_on_chip & tw_valid) \n  begin \n  trc_im_addr <= trc_im_addr+1; \n  if (&trc_im_addr) \n  trc_wrap <= 1; \n  end \n  end \n  always @(posedge clk or negedge reset_n) \n  begin \n  if (reset_n == 0) \n  trc_jtag_addr <= 0; \n else if (take_action_tracemem_a ||take_no_action_tracemem_a ||take_action_tracemem_b) \n  trc_jtag_addr <= take_action_tracemem_a ? \n  jdo[35 : 19] : \n  trc_jtag_addr + 1; \n  end \n  assign trc_enb = trc_ctrl[0]; \n  assign trc_on_chip = ~trc_ctrl[8]; \n  assign tw_valid = |trc_im_data[35 : 32]; \n  assign xbrk_wrap_traceoff = trc_ctrl[10] & trc_wrap; \n  assign tracemem_tw = trc_wrap; \n  assign tracemem_on = trc_enb; \n  assign tracemem_trcdata = 0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a positive edge-triggered D flip-flop with asynchronous reset. The input D is XORed with the input E to obtain Dtemp. Q and QN are driven by Qtemp and its complement, respectively. The Dtemp is fed into an instantiated FDC XIL_FDC, where it's clocked by CLK and reset by the negation of RSTB.\n\n Module header:\n\nmodule p_I_DFFARX1 (D,CLK,RSTB,Q,QN,E);\n [/INST]\n", "output": "input D; \n  input CLK; \n  input RSTB; \n  input E; \n  output Q; \n  output QN; \n  wire Dtemp; \n  wire Qtemp; \n  assign Dtemp = D ^ E; \n  assign QN = ~Qtemp; \n  assign Q = Qtemp; \n  FDC XIL_FDC (.D(Dtemp),.C(CLK),.CLR(~(RSTB)),.Q(Qtemp)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a 2-bit multiplexer that selects one of four 16-bit constant values based on the 2-bit input 'rot'. The selected constant value is then assigned to the output 'block'. If 'rot' is not 0, 1, 2, or 3, the module assigns 'z0' to the output 'block' by default.\n\n Module header:\n\nmodule Z_sel(input[1:0] rot, output reg[0:15] block);\n [/INST]\n", "output": "wire[0:15] z0 = 16'b1100011000000000; \n wire[0:15] z1 = 16'b0010011001000000; \n wire[0:15] z2 = 16'b0000110001100000; \n wire[0:15] z3 = 16'b0100110010000000; \n always @* \n begin \n  case(rot) \n  0: block = z0; \n  1: block = z1; \n  2: block = z2; \n  3: block = z3; \n  default: block = z0; \n  endcase \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a game text top module that controls the state of a game. It includes a state machine that transitions between states based on button inputs and other game conditions. It also generates pixel coordinates and handles the display of text and the ball in the game. The module updates the state and ball register based on button presses and game conditions. Additionally, it determines the RGB color for the display based on the game state and whether text is being displayed.\n\n Module header:\n\nmodule game_text_top (input wire clk, reset,input wire [1:0] btn,output wire hsync, vsync,output wire [2:0] rgb);\n [/INST]\n", "output": "localparam [1:0] \n  newgame = 2'b00, \n  play = 2'b01, \n  newball = 2'b10, \n  over = 2'b11; \n  reg [1:0] state_reg, state_next; \n  wire [9:0] pixel_x, pixel_y; \n  wire video_on, pixel_tick; \n  wire [3:0] text_on; \n  wire [2:0] text_rgb; \n  reg [2:0] rgb_reg, rgb_next; \n  wire [3:0] dig0, dig1; \n  reg [1:0] ball_reg, ball_next; \n  assign dig0 = 4'b0000; \n  assign dig1 = 4'b0000; \n  vga_sync vsync_unit \n (.clk(clk), .reset(reset), .hsync(hsync), .vsync(vsync),.video_on(video_on), .p_tick(pixel_tick),.pixel_x(pixel_x), .pixel_y(pixel_y)); \n  game_text game_text_unit \n (.clk(clk),.pix_x(pixel_x), .pix_y(pixel_y),.dig0(dig0), .dig1(dig1), .ball(ball_reg),.text_on(text_on), .text_rgb(text_rgb)); \n  always @(posedge clk, posedge reset) \n  if (reset) \n  begin \n  state_reg <= newgame; \n  ball_reg <= 0; \n  rgb_reg <= 0; \n  end \n  else \n  begin \n  state_reg <= state_next; \n  ball_reg <= ball_next; \n  if (pixel_tick) \n  rgb_reg <= rgb_next; \n  end \n  always @* \n  begin \n  state_next = state_reg; \n  ball_next = ball_reg; \n  case (state_reg) \n  newgame: \n  begin \n  ball_next = 2'b11; \n  if (btn != 2'b00) \n  begin \n  state_next = play; \n  ball_next = ball_reg - 1; \n  end \n  end \n  play: \n  begin \n  if (btn == 2'b11) \n  begin \n  state_next = newball; \n  ball_next = ball_reg - 2; \n  end \n  end \n  newball: \n  if ((btn == 2'b00)) \n  begin \n  state_next = over; \n  ball_next = 2'b00; \n  end \n  over: \n  state_next = newgame; \n  endcase \n  end \n  always @* \n  if (~video_on) \n  rgb_next = \"000\"; \n  else \n if (text_on[3] ||((state_reg==newgame) && text_on[1]) ||((state_reg==over) && text_on[0])) \n  rgb_next = text_rgb; \n  else if (text_on[2]) \n  rgb_next = text_rgb; \n  else \n  rgb_next = 3'b110; \n  assign rgb = rgb_reg; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `BrzUnaryFunc_1_1_s6_Invert_s5_false` is designed to invert the input signal and provide the inverted result as the output. It uses an inverter gate (IV) to perform the inversion. The module has input and output registers and assertions for controlling the input and output signals. It also includes wires for various intermediate signals and a comparison wire for checking the result. The module is triggered by a start signal and provides the inverted output once the inversion process is completed.\n\n Module header:\n\nmodule BrzUnaryFunc_1_1_s6_Invert_s5_false (out_0r, out_0a, out_0d,inp_0r, inp_0a, inp_0d);\n [/INST]\n", "output": "input out_0r; \n  output out_0a; \n  output out_0d; \n  output inp_0r; \n  input inp_0a; \n  input inp_0d; \n  wire nStart_0n; \n  wire [1:0] nCv_0n; \n  wire [1:0] c_0n; \n  wire i_0n; \n  wire j_0n; \n  wire start_0n; \n  wire done_0n; \n  IV I0 (out_0d, inp_0d); \n  assign done_0n = start_0n; \n  assign out_0a = done_0n; \n  assign start_0n = inp_0a; \n  assign inp_0r = out_0r; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `processor_tb` is a testbench for the `processor` module. It instantiates the `processor` module and sets initial values for clock and reset signals. It emulates a clock signal and negates it every 10 time units. When triggered by the clock signal, it writes data to memory and updates the instruction register based on the PC output. The PC output selects an instruction based on its value, and the corresponding instruction is assigned to the `instruction_in` input. The testbench finishes after all the instructions are fetched.\n\n Module header:\n\nmodule processor_tb;\n [/INST]\n", "output": "reg clk; \n  reg res; \n  reg [15:0] instruction_in; \n  reg [7:0] mdr_in; \n  reg [7 : 0] memory [255 : 0]; \n  wire [7:0] pc_out; \n  wire [7:0] mdr_out; \n  wire [7:0] mar_out; \n  wire write_mem; \n processor uut (.clk(clk),.res(res),.instruction_in(instruction_in),.mdr_in(mdr_in),.pc_out(pc_out),.mdr_out(mdr_out),.mar_out(mar_out),.write_mem(write_mem)); \n  initial begin \n  clk = 0; \n  res = 1; \n  #100 res = 0; \n  end \n  always \n  #10 clk = ~clk; \n  always @(posedge clk) begin \n  if(write_mem) \n  memory[mar_out] <= mdr_out; \n  mdr_in <= memory[mar_out]; \n  end \n  always @(pc_out) begin \n  case(pc_out) \n  8'h00: instruction_in = 16'h7f00; \n  8'h01: instruction_in = 16'h0100; \n  8'h02: instruction_in = 16'h0101; \n  8'h03: instruction_in = 16'h7200; \n  8'h04: instruction_in = 16'h730a; \n  8'h05: instruction_in = 16'h0aff; \n  8'h06: instruction_in = 16'h0101; \n  8'h07: instruction_in = 16'h0000; \n  8'h08: instruction_in = 16'h0100; \n  8'h09: instruction_in = 16'h0201; \n  8'h0a: instruction_in = 16'h0303; \n  default: \n  begin \n  instruction_in = 16'hffff; \n  $finish; \n  end \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes an 8-bit input vf7d213, a 16-bit input vbf8961, and outputs a 24-bit value v6d326e. It uses concatenation and instantiates an internal module va52e3b_v9a2a06 with inputs w0 and w2, and output w1. The input and output wires are assigned to the corresponding module ports, and the output v6d326e is assigned the value of w1.\n\n Module header:\n\nmodule va52e3b (input [7:0] vf7d213,input [15:0] vbf8961,output [23:0] v6d326e);\n [/INST]\n", "output": "wire [0:15] w0; \n  wire [0:23] w1; \n  wire [0:7] w2; \n  assign w0 = vbf8961; \n  assign v6d326e = w1; \n  assign w2 = vf7d213; \n va52e3b_v9a2a06 v9a2a06 (.i0(w0),.o(w1),.i1(w2)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module generates control signals for overriding certain behaviors in a PCIe 3.0 GTX design. It uses two registers, cpllpd_wait and cpllreset_wait, which are updated on the rising edge of the input signal i_ibufds_gte2. The o_cpllpd_ovrd output is driven by the most significant bit of cpllpd_wait, and o_cpllreset_ovrd is driven by the most significant bit of cpllreset_wait.\n\n Module header:\n\nmodule pcie3_7x_0_gtx_cpllpd_ovrd (input i_ibufds_gte2,output o_cpllpd_ovrd,output o_cpllreset_ovrd);\n [/INST]\n", "output": "(* equivalent_register_removal=\"no\" *) reg [95:0] cpllpd_wait = 96'hFFFFFFFFFFFFFFFFFFFFFFFF; \n  (* equivalent_register_removal=\"no\" *) reg [127:0] cpllreset_wait = 128'h000000000000000000000000000000FF; \n  always @(posedge i_ibufds_gte2) \n  begin \n  cpllpd_wait <= {cpllpd_wait[94:0], 1'b0}; \n  cpllreset_wait <= {cpllreset_wait[126:0], 1'b0}; \n  end \n  assign o_cpllpd_ovrd = cpllpd_wait[95]; \n  assign o_cpllreset_ovrd = cpllreset_wait[127]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a 3x3 closing filter using dilation and erosion operations. The module takes input signals and applies a 3x3 dilate filter to the input, followed by a 3x3 erosion filter. The output signals, including the closed signal, are derived from the erosion filter. The module utilizes clock, reset, and mask signals to control the dilation and erosion operations.\n\n Module header:\n\nmodule closing3x3#(parameter [9:0] H_SIZE = 83)(input clk,input ce,input rst,input mask,input in_de,input in_vsync,input in_hsync,output closed,output out_de,output out_vsync,output out_hsync);\n [/INST]\n", "output": "wire dilation; \n wire dilation_de; \n wire dilation_vsync; \n wire dilation_hsync; \n dilation3x3 # \n (.H_SIZE(H_SIZE)) \n dilate3 \n (.clk(clk),.ce(1'b1),.rst(1'b0),.mask(mask),.in_de(in_de),.in_vsync(in_vsync),.in_hsync(in_hsync),.dilated(dilation),.out_de(dilation_de),.out_vsync(dilation_vsync),.out_hsync(dilation_hsync)); \n wire erosion; \n wire erosion_de; \n wire erosion_vsync; \n wire erosion_hsync; \n erosion3x3 # \n (.H_SIZE(H_SIZE)) \n erode3 \n (.clk(clk),.ce(1'b1),.rst(1'b0),.mask(dilation),.in_de(dilation_de),.in_vsync(dilation_vsync),.in_hsync(dilation_hsync),.eroded(erosion),.out_de(erosion_de),.out_vsync(erosion_vsync),.out_hsync(erosion_hsync)); \n assign out_de = erosion_de; \n assign out_hsync = erosion_hsync; \n assign out_vsync = erosion_vsync; \n assign closed = erosion; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module represents a RAM (random access memory) with 2x64 bits capacity. It has input and output ports for clock signal, enable signal, write enable signal, odd signal, write address, read address, data to be read, and data to be written. The module stores and retrieves data based on the input signals and uses positive edge triggered clock signals to update the RAM. The module also utilizes a block to handle the writing and reading operations, and it includes a register and arrays to store and access data.\n\n Module header:\n\nmodule RAM2x64C_1 (CLK,ED,WE,ODD,ADDRW,ADDRR,DR,DI,DOR,DOI);\n [/INST]\n", "output": "parameter nb=16; \n  output [nb-1:0] DOR ; \n  wire [nb-1:0] DOR; \n  output [nb-1:0] DOI ; \n  wire [nb-1:0] DOI; \n  input CLK ; \n  wire CLK; \n  input ED ; \n  wire ED; \n  input WE ; \n  wire WE; \n  input ODD ; \n  wire ODD; \n  input [5:0] ADDRW ; \n  wire [5:0] ADDRW; \n  input [5:0] ADDRR ; \n  wire [5:0] ADDRR; \n  input [nb-1:0] DR ; \n  wire [nb-1:0] DR; \n  input [nb-1:0] DI ; \n  wire [nb-1:0] DI; \n  reg oddd,odd2; \n  always @( posedge CLK) begin \n  if (ED) begin \n  oddd<=ODD; \n  odd2<=oddd; \n  end \n  end \n  wire [6:0] addrr2 = {ODD,ADDRR}; \n  wire [6:0] addrw2 = {~ODD,ADDRW}; \n  wire [2*nb-1:0] di= {DR,DI}; \n  wire [2*nb-1:0] doi; \n  reg [2*nb-1:0] ram [127:0]; \n  reg [6:0] read_addra; \n  always @(posedge CLK) begin \n  if (ED) \n  begin \n  if (WE) \n  ram[addrw2] <= di; \n  read_addra <= addrr2; \n  end \n  end \n  assign doi = ram[read_addra]; \n  assign DOR=doi[2*nb-1:nb]; \n  assign DOI=doi[nb-1:0]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module performs the reduction of six 2-bit input signals (A1 to A6) using various logic operations (AND, OR, NAND, NOR, XOR) and outputs the results to Y1 to Y6. The specific logic operations used are as follows:\n- Y1 is the result of a bitwise AND operation on A1\n- Y2 is the result of a bitwise OR operation on A2\n- Y3 is the result of a bitwise NAND operation on A3\n- Y4 is the result of a bitwise NOR operation on A4\n- Y5 is the result of a bitwise XOR operation on A5\n- Y6 is the result of a bitwise XNOR operation on A6\n\n Module header:\n\nmodule f29_Reduction (A1, A2, A3, A4, A5, A6, Y1, Y2, Y3, Y4, Y5, Y6);\n [/INST]\n", "output": "input [1:0] A1; \n input [1:0] A2; \n input [1:0] A3; \n input [1:0] A4; \n input [1:0] A5; \n input [1:0] A6; \n output Y1, Y2, Y3, Y4, Y5, Y6; \n assign Y1=&A1; \n assign Y2=|A2; \n assign Y3=~&A3; \n assign Y4=~|A4; \n assign Y5=^A5; \n assign Y6=~^A6; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module generates a pseudo-random number sequence and calculates the Chi-squared statistic to test for randomness. It counts the longest run of ones and updates the Chi-squared statistic based on the counts. The pass output indicates whether the Chi-squared statistic is less than a predefined threshold U. The module contains state variables and combinatorial logic to implement the counting and updating logic. The counts are cleared on reset and updated on each clock cycle. The module also handles the transition between pseudo-random iterations and updates the counts and run length accordingly.\n\n Module header:\n\nmodule Longest_Run_of_Ones(input wire clk,input wire rst,input wire rand,output wire pass);\n [/INST]\n", "output": "parameter n = 16, M = 8, k = 3, U = 448018; \n reg [7:0] count_bits0, count_bits1, count_bits2; \n reg [4:0] count_blocks, v0, v1, v2, v3; \n reg [2:0] count_run, count_run_max; \n wire [20:0] chi_sqr; \n wire en0; \n reg en1, en2; \n assign en0 = (count_blocks == 0); \n calculate_chi_sqr calculate_chi_sqr1(.v0(v0), .v1(v1), .v2(v2), .v3(v3),.en(en2 & en0),.chi_sqr(chi_sqr)); \n assign pass = (chi_sqr < U); \n always @(posedge clk) \n  if (rst) begin \n  count_bits0 <= 8'HFF; \n  count_bits1 <= 8'H00; \n  count_bits2 <= 8'H00; \n  count_blocks <= 0; \n  count_run <= 0; \n  count_run_max <= 0; \n  v0 <= 0; \n  v1 <= 0; \n  v2 <= 0; \n  v3 <= 0; \n  en1 <= 0; \n  en2 <= 0; \n  end \n  else begin \n  en1 <= en0; \n  en2 <= en1; \n  count_bits0 <= count_bits0 + 1; \n  if (count_bits0 == (M-1)) begin \n  count_bits0 <= 0; \n  count_blocks <= count_blocks + 1; \n  if (count_blocks == (n-1)) begin \n  count_blocks <= 0; \n  end \n  end \n  count_bits1 <= count_bits0; \n  count_bits2 <= count_bits1; \n  if (rand) begin \n  if (count_bits0) count_run <= count_run + 1; \n  else count_run <= 1; \n  end \n  else begin \n  count_run <= 0; \n  if (count_run > count_run_max) count_run_max <= count_run; \n  end \n  if (count_bits1 == (M-1)) \n  if (count_run > count_run_max) count_run_max <= count_run; \n  if (count_bits2 == (M-1)) begin \n  count_run_max <= 0; \n  case(count_run_max) \n  0: v0 <= v0 + 1; \n  1: v0 <= v0 + 1; \n  2: v1 <= v1 + 1; \n  3: v2 <= v2 + 1; \n  4: v3 <= v3 + 1; \n  5: v3 <= v3 + 1; \n  6: v3 <= v3 + 1; \n  7: v3 <= v3 + 1; \n  8: v3 <= v3 + 1; \n  endcase \n  end \n  if ((en1) & (~en0)) begin \n  v0 <= 0; \n  v1 <= 0; \n  v2 <= 0; \n  v3 <= 0; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a simple peripheral controller with a state machine. It has inputs for clock signal, data input, address, write signal, and read signal, and an output for data output. It includes registers for internal storage and uses a state variable to control its behavior. The module responds to the read and write signals, as well as the input data and address to manipulate the internal storage and update the data output accordingly. It also has a state machine that changes states based on the input data. The module essentially acts as a controller for a peripheral device.\n\n Module header:\n\nmodule core_peripheric(clk, addr, d_in, d_out, wr, rd);\n [/INST]\n", "output": "input clk; \n  input [15:0]d_in; \n  output reg [15:0]d_out; \n  output reg [7:0]addr; \n  output reg rd; \n  output reg wr; \n reg [15:0] F_1, F_2, F_3, F_4, F_5, F_6; \n reg [3:0] estado; \n  initial begin \n  d_out = 0; \n  addr = 0; \n  rd = 0; \n  wr = 0; \n  estado = 0; \n  F_1=0; \n  F_2=0; \n  F_3=0; \n  F_4=0; \n  F_5=0; \n  F_6=0; \n  end \n always @(posedge clk) begin \n if (rd) begin \n case (addr) \n 8'h00: F_1=d_in; \n 8'h02: F_2=d_in; \n 8'h04: F_3=d_in; \n 8'h06: F_4=d_in; \n 8'h08: F_5=d_in; \n 8'h0A: F_6=d_in; \n default: F_1=F_1; \n endcase \n end \n else F_1= F_1; \n case(estado) \n 00: begin \n  if (d_in==13) estado =1; \n  else estado=0; \n end \n 01: estado=2; \n 02: estado=3; \n 03: estado=4; \n 04: estado=5; \n 05: estado=6; \n 06: estado=7; \n 07: estado=8; \n 08: estado=9; \n 09: estado=10; \n 10: estado=11; \n 11: estado=12; \n 12: estado=13; \n 13: estado=13; \n default: estado=0; \n endcase \n end \n always @(*) begin \n case(estado) \n 00: begin addr=8'h0A; d_out=16'h0000; wr=0; rd=1; end \n 01: begin addr=8'h00; d_out=16'h0000; wr=0; rd=1; end \n 02: begin addr=8'h02; d_out=16'h0000; wr=0; rd=1; end \n 03: begin addr=8'h04; d_out=16'h0000; wr=0; rd=1; end \n 04: begin addr=8'h06; d_out=16'h0000; wr=0; rd=1; end \n 05: begin addr=8'h08; d_out=16'h0000; wr=0; rd=1; end \n 06: begin addr=8'h0A; d_out=16'h0000; wr=0; rd=1; end \n 07: begin addr=8'h00; d_out=F_6; wr=1; rd=0; end \n 08: begin addr=8'h02; d_out=F_5; wr=1; rd=0; end \n 09: begin addr=8'h04; d_out=F_4; wr=1; rd=0; end \n 10: begin addr=8'h06; d_out=F_3; wr=1; rd=0; end \n 11: begin addr=8'h08; d_out=F_2; wr=1; rd=0; end \n 12: begin addr=8'h0A; d_out=F_1; wr=1; rd=0; end \n 13: begin addr=8'h0A; d_out=16'h0000; wr=0; rd=0; end \n default: begin addr=8'h00; d_out=16'h0000; wr=0; rd=0; end \n endcase \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes a 10-bit mantissa (man) and a 3-bit exponent (exp) as inputs and calculates a 16-bit linear representation (lin). The linear representation is determined based on the value of the exponent using a case statement, which concatenates the mantissa with leading zeros based on the value of the exponent. If exp is 7, the lin will be the concatenation of the mantissa with six leading zeros. If exp is 0, lin will be all zeros.\n\n Module header:\n\nmodule jt51_exp2lin(output reg signed [15:0] lin,input signed [9:0] man,input [2:0] exp);\n [/INST]\n", "output": "always @(*) begin \n  case( exp ) \n  3'd7: lin = { man, 6'b0 }; \n  3'd6: lin = { {1{man[9]}}, man, 5'b0 }; \n  3'd5: lin = { {2{man[9]}}, man, 4'b0 }; \n  3'd4: lin = { {3{man[9]}}, man, 3'b0 }; \n  3'd3: lin = { {4{man[9]}}, man, 2'b0 }; \n  3'd2: lin = { {5{man[9]}}, man, 1'b0 }; \n  3'd1: lin = { {6{man[9]}}, man }; \n  3'd0: lin = 16'd0; \n  endcase \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a D-type latch with a reset input and clock input. The input 'd' is latched to output 'q' using the GP_DLATCHRI module. Additionally, the output 'q2' is a register that stores the inverse of the input 'd'. The 'q2' register is updated based on the input 'd' and the clock signal. The inputs and outputs are connected to specific pins on the target hardware.\n\n Module header:\n\nmodule Latch(d, q, q2, clk, nrst);\n [/INST]\n", "output": "(* LOC = \"P3\" *) \n  input wire d; \n  (* LOC = \"P4\" *) \n  output wire q; \n  (* LOC = \"P5\" *) \n  input wire clk; \n  (* LOC = \"P6\" *) \n  input wire nrst; \n  (* LOC = \"P7\" *) \n  output reg q2 = 0; \n GP_DLATCHRI #(.INIT(1'b0)) latch (.D(d),.nQ(q),.nCLK(clk),.nRST(nrst)); \n  always @(*) begin \n  if(!clk) \n  q2 <= ~d; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a testbench for the CLA_Array_32 module. It sets up test cases by initializing the input registers a, b, and cin with specific values and then checks if the output result matches the expected output expectOutput. If there are any discrepancies, it sets the errorFlag to 1. The module also includes a loop that generates random numbers to test the functionality of the CLA_Array_32 module. If the errorFlag remains 0 after all the tests, the module displays a \"Test passed\" message; otherwise, it displays a \"Test failed\" message.\n\n Module header:\n\nmodule testbench_CLA_Array_32();\n [/INST]\n", "output": "reg[31:0] a; \n reg[31:0] b; \n reg cin; \n wire[31:0] result; \n wire cout; \n wire[32:0] expectOutput; \n reg errorFlag = 0; \n integer i; \n assign expectOutput = a + b + cin; \n initial begin \n  a = 32'h11111111; \n  b = 32'hffffffff; \n  cin = 1; \n  #10; \n  if ({cout,result} !== expectOutput) begin \n  errorFlag = 1; \n  $display(\"test fail: expect %x + %x = %x, actual %x\", a, b, expectOutput, {cout,result}); \n  end \n  a = 32'h00000000; \n  b = 32'hffffffff; \n  cin = 1; \n  #10; \n  if ({cout,result} !== expectOutput) begin \n  errorFlag = 1; \n  $display(\"test fail: expect %x + %x = %x, actual %x\", a, b, expectOutput, {cout,result}); \n  end \n  a = 32'h11111111; \n  b = 32'heeeeeeee; \n  cin = 1; \n  #10; \n  if ({cout,result} !== expectOutput) begin \n  errorFlag = 1; \n  $display(\"test fail: expect %x + %x = %x, actual %x\", a, b, expectOutput, {cout,result}); \n  end \n  for(i = 0;i < 32'hffff; i = i+1) begin \n  a = $random(); \n  b = $random(); \n  cin = ($random()&1); \n  #10; \n  if ({cout,result} !== expectOutput) begin \n  errorFlag = 1; \n  $display(\"test fail: expect %x + %x = %x, actual %x\", a, b, expectOutput, {cout,result}); \n  end \n  end \n  if (errorFlag === 0) begin \n  $display(\"Test passed\"); \n  end \n  else begin \n  $display(\"Test failed\"); \n  end \n end \n CLA_Array_32 cla(.a(a), .b(b), .cin(cin), .result(result), .cout(cout)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements an input pipeline with 11 pipeline registers. It takes input data from in_stream and shifts it through the pipeline when the clk_ena signal is asserted. The pipeline registers are reset to 0 when the reset signal is high. The input data is loaded into pipeline register 0 and then shifted through the pipeline to register 10 when the clock enable signal is active.\n\n Module header:\n\nmodule input_pipeline (clk,clk_ena,in_stream,pipeline_reg_0,pipeline_reg_1,pipeline_reg_2,pipeline_reg_3,pipeline_reg_4,pipeline_reg_5,pipeline_reg_6,pipeline_reg_7,pipeline_reg_8,pipeline_reg_9,pipeline_reg_10,reset);\n [/INST]\n", "output": "parameter WIDTH = 1; \n  input clk; \n  input clk_ena; \n  input [WIDTH-1:0] in_stream; \n  output [WIDTH-1:0] pipeline_reg_0; \n  output [WIDTH-1:0] pipeline_reg_1; \n  output [WIDTH-1:0] pipeline_reg_2; \n  output [WIDTH-1:0] pipeline_reg_3; \n  output [WIDTH-1:0] pipeline_reg_4; \n  output [WIDTH-1:0] pipeline_reg_5; \n  output [WIDTH-1:0] pipeline_reg_6; \n  output [WIDTH-1:0] pipeline_reg_7; \n  output [WIDTH-1:0] pipeline_reg_8; \n  output [WIDTH-1:0] pipeline_reg_9; \n  output [WIDTH-1:0] pipeline_reg_10; \n  reg [WIDTH-1:0] pipeline_reg_0; \n  reg [WIDTH-1:0] pipeline_reg_1; \n  reg [WIDTH-1:0] pipeline_reg_2; \n  reg [WIDTH-1:0] pipeline_reg_3; \n  reg [WIDTH-1:0] pipeline_reg_4; \n  reg [WIDTH-1:0] pipeline_reg_5; \n  reg [WIDTH-1:0] pipeline_reg_6; \n  reg [WIDTH-1:0] pipeline_reg_7; \n  reg [WIDTH-1:0] pipeline_reg_8; \n  reg [WIDTH-1:0] pipeline_reg_9; \n  reg [WIDTH-1:0] pipeline_reg_10; \n  input reset; \n  always@(posedge clk or posedge reset) begin \n  if(reset) begin \n  pipeline_reg_0 <= 0; \n  pipeline_reg_1 <= 0; \n  pipeline_reg_2 <= 0; \n  pipeline_reg_3 <= 0; \n  pipeline_reg_4 <= 0; \n  pipeline_reg_5 <= 0; \n  pipeline_reg_6 <= 0; \n  pipeline_reg_7 <= 0; \n  pipeline_reg_8 <= 0; \n  pipeline_reg_9 <= 0; \n  pipeline_reg_10 <= 0; \n  end else begin \n  if(clk_ena) begin \n  pipeline_reg_0 <= in_stream; \n  pipeline_reg_1 <= pipeline_reg_0; \n  pipeline_reg_2 <= pipeline_reg_1; \n  pipeline_reg_3 <= pipeline_reg_2; \n  pipeline_reg_4 <= pipeline_reg_3; \n  pipeline_reg_5 <= pipeline_reg_4; \n  pipeline_reg_6 <= pipeline_reg_5; \n  pipeline_reg_7 <= pipeline_reg_6; \n  pipeline_reg_8 <= pipeline_reg_7; \n  pipeline_reg_9 <= pipeline_reg_8; \n  pipeline_reg_10 <= pipeline_reg_9; \n  end \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a register that outputs the values of various control signals such as writeRegister, aluOut, memoryOut, regWrite, memToReg, and eop based on different conditions like clock edges and reset signals. The values of these signals are stored and output based on the control conditions specified in the module.\n\n Module header:\n\nmodule MEM_WB(input clock,input reset,input debugEnable,input debugReset,input [4:0] writeRegister,input [31:0] aluOut,input [31:0] memoryOut,input regWrite,input memToReg,input eop,output reg [4:0] writeRegisterOut,output reg [31:0] aluOutOut,output reg [31:0] memoryOutOut,output reg regWriteOut,output reg memToRegOut,output reg eopOut);\n [/INST]\n", "output": "always @(negedge clock,posedge reset)begin \n  if(reset)begin \n  writeRegisterOut<=0; \n  aluOutOut<=0; \n  memoryOutOut<=0; \n  regWriteOut<=0; \n  memToRegOut<=0; \n  eopOut<=0; \n  end \n  else if (debugReset)begin \n  writeRegisterOut<=0; \n  aluOutOut<=0; \n  memoryOutOut<=0; \n  regWriteOut<=0; \n  memToRegOut<=0; \n  eopOut<=0; \n  end \n  else if(debugEnable) begin \n  writeRegisterOut<=writeRegister; \n  aluOutOut<=aluOut; \n  memoryOutOut<=memoryOut; \n  regWriteOut<=regWrite; \n  memToRegOut<=memToReg; \n  eopOut<=eop; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a clock control circuit. It takes an input clock signal (`inclk`), and an enable signal (`ena`), and produces an output clock signal (`outclk`). Inside the module, it uses wire signals to manipulate the input and output signals. It also instantiates a sub-component called `clckctrl_altclkctrl_0_sub` to perform further clock control logic. The module essentially acts as an interface for controlling the output clock signal based on the input clock and an enable signal.\n\n Module header:\n\nmodule clckctrl_altclkctrl_0 (ena,inclk,outclk);\n [/INST]\n", "output": "input ena; \n  input inclk; \n  output outclk; \n `ifndef ALTERA_RESERVED_QIS \n `endif \n  tri1 ena; \n `ifndef ALTERA_RESERVED_QIS \n `endif \n  wire sub_wire0; \n  wire outclk; \n  wire sub_wire1; \n  wire [3:0] sub_wire2; \n  wire [2:0] sub_wire3; \n  assign outclk = sub_wire0; \n  assign sub_wire1 = inclk; \n  assign sub_wire2[3:0] = {sub_wire3, sub_wire1}; \n  assign sub_wire3[2:0] = 3'h0; \n clckctrl_altclkctrl_0_sub clckctrl_altclkctrl_0_sub_component (.ena (ena),.inclk (sub_wire2),.outclk (sub_wire0)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module `core_pc` implements a program counter (PC) that generates the next program instruction address based on various inputs. It has a clock input (`clk`) and a reset input (`rst`) to initialize the PC. The module takes in branch target, return address stack target, program counter source, stall signal, PC go signal, good target address, branch target type, and branch target vector as inputs. It outputs the current program counter value (`pc_out`), virtual PC output (`v_pc_out`), and the next program instruction address (`pc_plus4`).\n\nThe module uses a case statement to determine the source of the next program instruction address based on the control signals. The PC is updated on the positive edge of the clock based on the selected source, and the PC is incremented by 4 to generate the next instruction address. When reset is asserted, the PC is initialized to a predefined value.\n\n Module header:\n\nmodule core_pc(clk,rst,btb_target,ras_target,pc_go,stall,good_target,id_pc_src,btb_v,btb_type,pc_out,v_pc_out,pc_plus4);\n [/INST]\n", "output": "parameter initial_addr=32'h00040000; \n parameter br_type=2'b00; \n parameter j_type=2'b01; \n parameter jal_type=2'b10; \n parameter jr_type=2'b11; \n input clk; \n input rst; \n input [31:0] btb_target; \n input [31:0] ras_target; \n input id_pc_src; \n input stall; \n input pc_go; \n input [31:0] good_target; \n input [1:0] btb_type; \n input btb_v; \n output [31:0] pc_out; \n output v_pc_out; \n output [31:0] pc_plus4; \n wire [1:0] pc_src; \n wire [1:0] pc_src1; \n assign pc_src1=(btb_v&&(btb_type==br_type||btb_type==j_type||btb_type==jal_type))?2'b11:(btb_v&&btb_type==jr_type)?2'b10:2'b01; \n assign pc_src=(id_pc_src==1'b1)?2'b00:pc_src1; \n reg [31:0] pc_temp; \n always@(*) \n begin \n  case(pc_src) \n  2'b00:pc_temp=good_target; \n  2'b01:pc_temp=pc_plus4; \n  2'b10:pc_temp=ras_target; \n  2'b11:pc_temp=btb_target; \n  default:pc_temp=pc_plus4; \n  endcase \n end \n reg [31:0] pc; \n always@(posedge clk) \n begin \n  if(rst) \n  pc<=32'h00040000; \n  else if(pc_go&&!stall) \n  begin \n  pc<=pc_temp; \n  end \n end \n assign pc_plus4=pc+4; \n assign v_pc_out=(pc_go&&!stall); \n assign pc_out=pc; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a System-on-Chip (SoC) Peripheral Input/Output (PIO) interface for controlling LEDs. It has input and output ports for address, chip select, clock, reset, write enable, write data, output data, and read data. \n\nThe module includes a clock enable signal, a register for output data, and wires for output port, a multiplexer output for reading data, and a data bus for reading data. It also sets the clock enable signal and handles clock and reset operations. \n\nDuring reset, it initializes the output data to 682. When the chip select and write enable are low, and the address is 0, it updates the output data with the lower 10 bits of the write data.\n\nThe module then assigns the read data to be the concatenation of the multiplexer output with 32'b0 and assigns the output port to the output data.\n\nOverall, this module serves as an interface for controlling LEDs in a SoC design.\n\n Module header:\n\nmodule soc_system_pio_led (address,chipselect,clk,reset_n,write_n,writedata,out_port,readdata);\n [/INST]\n", "output": "output [ 9: 0] out_port; \n  output [ 31: 0] readdata; \n  input [ 1: 0] address; \n  input chipselect; \n  input clk; \n  input reset_n; \n  input write_n; \n  input [ 31: 0] writedata; \n  wire clk_en; \n  reg [ 9: 0] data_out; \n  wire [ 9: 0] out_port; \n  wire [ 9: 0] read_mux_out; \n  wire [ 31: 0] readdata; \n  assign clk_en = 1; \n  assign read_mux_out = {10 {(address == 0)}} & data_out; \n  always @(posedge clk or negedge reset_n) \n  begin \n  if (reset_n == 0) \n  data_out <= 682; \n  else if (chipselect && ~write_n && (address == 0)) \n  data_out <= writedata[9 : 0]; \n  end \n  assign readdata = {32'b0 | read_mux_out}; \n  assign out_port = data_out; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes a clock signal and a data input, and produces a pulse on the data_out output whenever there is a positive edge on the clock signal and the input data changes. The output pulse is generated based on the exclusive OR operation between the current and delayed data inputs. A reset signal is used to reset the internal flip-flop to ensure proper behavior during reset conditions.\n\n Module header:\n\nmodule clock_1_edge_to_pulse (clock,data_in,reset_n,data_out);\n [/INST]\n", "output": "output data_out; \n  input clock; \n  input data_in; \n  input reset_n; \n  reg data_in_d1; \n  wire data_out; \n  always @(posedge clock or negedge reset_n) \n  begin \n  if (reset_n == 0) \n  data_in_d1 <= 0; \n  else if (1) \n  data_in_d1 <= data_in; \n  end \n  assign data_out = data_in ^ data_in_d1; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `mmc3_eth_core` interfaces with a GPIO component, defines a `GPIO` base address and high address, and instantiates a `gpio` module. It uses the GPIO's first bit as an enable signal `EN` and assigns it to the `GPIO` input. It has a data source `datasource` and controls FIFO writing based on the `fifo_full` and `EN` signals. When `EN` is disabled, the module clears the `fifo_data_out` signal, and when `FIFO_WRITE` is asserted, it increments `fifo_data_out` on each clock cycle. The module's `FIFO_WRITE` output is based on the `fifo_full` and `EN` signals.\n\n Module header:\n\nmodule mmc3_eth_core (input wire RESET_N,input wire BUS_CLK, CLK125TX, CLK125TX90, CLK125RX,input wire PLL_LOCKED,input wire BUS_RST,input wire [31:0] BUS_ADD,inout wire [31:0] BUS_DATA,input wire BUS_RD,input wire BUS_WR,output wire BUS_BYTE_ACCESS,input wire fifo_empty,input wire fifo_full,input wire FIFO_NEXT,output wire FIFO_WRITE,output wire [31:0] FIFO_DATA,output wire [7:0] GPIO);\n [/INST]\n", "output": "localparam GPIO_BASEADDR = 32'h1000; \n localparam GPIO_HIGHADDR = 32'h101f; \n gpio #(.BASEADDR(GPIO_BASEADDR),.HIGHADDR(GPIO_HIGHADDR),.ABUSWIDTH(32),.IO_WIDTH(8),.IO_DIRECTION(8'hff)) i_gpio_rx (.BUS_CLK(BUS_CLK),.BUS_RST(BUS_RST),.BUS_ADD(BUS_ADD),.BUS_DATA(BUS_DATA[7:0]),.BUS_RD(BUS_RD),.BUS_WR(BUS_WR),.IO(GPIO)); \n wire EN; \n assign EN = GPIO[0]; \n reg [31:0] datasource; \n reg fifo_write; \n assign FIFO_WRITE = !fifo_full & EN; \n reg [31:0] fifo_data_out; \n assign FIFO_DATA = fifo_data_out; \n always @(posedge BUS_CLK) \n  if(!EN) \n  fifo_data_out <= 0; \n  else if(FIFO_WRITE) \n  fifo_data_out <= fifo_data_out + 1; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module instantiates a testbench for a system that includes clock, reset, address, data, ready, request, enable, selector, acknowledge, and error signals. It also includes RS232 transmit and receive data connections. The module initializes the parameters, sets the clock and reset signals, and toggles the clock at specific intervals. Additionally, it instantiates top-level PSS, RS232 receiver, and RS232 transmitter modules, and includes logic to write received data to the console.\n\n Module header:\n\nmodule tb_cbu_tasks();\n [/INST]\n", "output": "reg clk; \n reg rst; \n wire [31:0] iimx_adr_o; \n wire iimx_rqt_o; \n wire [31:0] iimx_dat_i; \n wire iimx_ack_i; \n wire iimx_rty_i; \n wire iimx_err_i; \n wire [31:0] iimx_adr_i; \n wire [31:0] dimx_adr_o; \n wire dimx_rqt_o; \n wire dimx_we_o; \n wire [3:0] dimx_sel_o; \n wire [31:0] dimx_dat_o; \n wire [31:0] dimx_dat_i; \n wire dimx_ack_i; \n wire dimx_err_i; \n wire RS232_TX_DATA; \n wire RS232_RX_DATA; \n wire [7:0] tb_rx_data; \n wire tb_rx_done; \n wire tb_tx_start; \n wire tb_tx_busy; \n wire [7:0] tb_tx_data; \n parameter HalfClkCycle = 7.8; \n parameter RstTime = 3; \n initial begin \n  rst = 0; \n  dsu_rst = 0; \n  dsu_burn_enable = 0; \n  #RstTime rst = 1; \n  dsu_rst = 1; \n  #RstTime rst = 0; \n  dsu_rst = 0; \n end \n initial \n  clk = 1; \n always #HalfClkCycle clk = ~clk; \n always @ (tb_rx_done or tb_rx_data) begin \n  if (tb_rx_done) \n  $write(\"%s\",tb_rx_data); \n end \n top_pss top_pss(.clk(clk),.rst(rst),.dsu_rst(dsu_rst),.dsu_burn_enable(dsu_burn_enable),.dsu_sram_we(dsu_sram_we),.txd(RS232_TX_DATA),.rxd(RS232_RX_DATA),.iimx_adr_o(iimx_adr_o),.iimx_rqt_o(iimx_rqt_o),.iimx_rty_i(iimx_rty_i),.iimx_ack_i(iimx_ack_i),.iimx_err_i(iimx_err_i),.iimx_dat_i(iimx_dat_i),.iimx_adr_i(iimx_adr_i),.dimx_adr_o(dimx_adr_o),.dimx_rqt_o(dimx_rqt_o),.dimx_we_o(dimx_we_o),.dimx_sel_o(dimx_sel_o),.dimx_dat_o(dimx_dat_o),.dimx_dat_i(dimx_dat_i),.dimx_ack_i(dimx_ack_i),.dimx_err_i(dimx_err_i)); \n tb_dsu_rx tb_dsu_rx(.clk(clk),.rst(rst),.RxD(RS232_TX_DATA),.RxD_data_ready(tb_rx_done),.RxD_data(tb_rx_data),.RxD_endofpacket(),.RxD_idle()); \n tb_dsu_tx tb_dsu_tx(.clk(clk),.rst(rst),.TxD_start(tb_tx_start),.TxD_data(tb_tx_data),.TxD(RS232_RX_DATA),.TxD_busy(tb_tx_busy)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is designed to generate color output for a video frame based on input signals including pixel color, palette data, and synchronization signals. The module utilizes registers to store palette data and synchronize border signals. It also includes logic to update palette data based on input signals and generate the color output for the video frame. Additionally, it handles horizontal and vertical synchronization, and processes the input signals to generate the final color output for the video frame.\n\n Module header:\n\nmodule video_palframe(input wire clk,input wire hpix,input wire vpix,input wire hblank,input wire vblank,input wire hsync_start,input wire vsync,input wire [ 3:0] pixels,input wire [ 3:0] border,input wire border_sync,input wire border_sync_ena,input wire [ 1:0] up_palsel,input wire [ 2:0] up_paper,input wire [ 2:0] up_ink,input wire up_pixel,input wire up_ena,input wire up_palwr,input wire [ 5:0] up_paladdr,input wire [ 7:0] up_paldata,input wire atm_palwr,input wire [ 5:0] atm_paldata,output wire [ 5:0] palcolor,output wire [ 5:0] color);\n [/INST]\n", "output": "reg [7:0] palette_read; \n  wire [ 3:0] zxcolor; \n  wire [ 5:0] up_color; \n  wire [ 8:0] palette_color; \n  reg [3:0] synced_border; \n  reg vsync_r; \n  reg [1:0] ctr_14; \n  reg ctr_h; \n  reg ctr_v; \n  always @(posedge clk) \n  if( border_sync ) \n  synced_border <= border; \n  assign zxcolor = (hpix&vpix) ? pixels : (border_sync_ena ? synced_border : border); \n  assign up_color = (hpix&vpix) ? {up_palsel,~up_pixel,up_pixel?up_ink:up_paper} : {3'd0,border[2:0]}; \n  assign palette_color = up_ena ? {3'b100,up_color} : {5'd0,zxcolor}; \n  reg [7:0] palette [0:511]; \n  always @(posedge clk) \n  begin \n  if( atm_palwr || up_palwr ) \n  begin : palette_write \n  reg [8:0] pal_addr; \n  pal_addr = atm_palwr ? { 5'd0, zxcolor } : { 3'b100, up_paladdr }; \n  palette[pal_addr] <= atm_palwr ? {atm_paldata[3:2],1'b0,atm_paldata[5:4],1'b0,atm_paldata[1:0]} : up_paldata; \n  end \n  palette_read <= palette[palette_color]; \n  end \n  assign palcolor = {palette_read[4:3],palette_read[7:6], palette_read[1:0]}; \n  always @(posedge clk) \n  vsync_r <= vsync; \n  wire vsync_start = vsync && !vsync_r; \n  initial ctr_14 = 2'b00; \n  always @(posedge clk) \n  ctr_14 <= ctr_14+2'b01; \n  initial ctr_h = 1'b0; \n  always @(posedge clk) if( hsync_start ) \n  ctr_h <= ~ctr_h; \n  initial ctr_v = 1'b0; \n  always @(posedge clk) if( vsync_start ) \n  ctr_v <= ~ctr_v; \n  wire plus1 = ctr_14[1] ^ ctr_h ^ ctr_v; \n  wire [1:0] red; \n  wire [1:0] grn; \n  wire [1:0] blu; \n  video_palframe_mk3bit red_color \n (.plus1 (plus1 ),.color_in (palette_read[7:5]),.color_out(red )); \n  video_palframe_mk3bit grn_color \n (.plus1 (plus1 ),.color_in (palette_read[4:2]),.color_out(grn )); \n  assign blu = palette_read[1:0]; \n  assign color = (hblank | vblank) ? 6'd0 : {grn,red,blu}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"sound\" implements an audio processing system. It includes logic for controlling audio channels, a timer, and a PWM clock. The module interfaces with a memory-mapped system, reading and writing data based on command signals. It also generates audio signals for the left and right channels using a DAC8 module. The audio processing is synchronized with the system clock and a separate PWM clock. The module also handles timeout logic and status register updates.\n\n Module header:\n\nmodule sound (input wb_clk_i,input wb_rst_i,input [ 2:0] wb_adr_i,input [ 1:0] wb_sel_i,input [15:0] wb_dat_i,output [15:0] wb_dat_o,input wb_cyc_i,input wb_stb_i,input wb_we_i,output reg wb_ack_o,input dac_clk,output audio_L,output audio_R);\n [/INST]\n", "output": "reg [7:0] sb_dat_o; \n wire [3:0] sb_adr_i = {wb_adr_i, wb_sel_i[1]}; \n wire [7:0] sb_dat_i = wb_sel_i[0] ? wb_dat_i[7:0] : wb_dat_i[15:8]; \n assign wb_dat_o = {sb_dat_o, sb_dat_o}; \n wire wb_ack_i = wb_stb_i & wb_cyc_i; \n wire wr_command = wb_ack_i & wb_we_i; \n wire rd_command = wb_ack_i & ~wb_we_i; \n always @(posedge wb_clk_i or posedge wb_rst_i) begin \n  if(wb_rst_i) wb_ack_o <= 1'b0; \n  else wb_ack_o <= wb_ack_i & ~wb_ack_o; \n end \n `define REG_CHAN01 4'h0 \n `define REG_CHAN02 4'h1 \n `define REG_TIMERH 4'h2 \n `define REG_TIMERL 4'h3 \n `define REG_CONTRL 4'h5 \n `define REG_STATUS 4'h7 \n `define DSP_DEFAULT_RATE 16'd671 \n reg start; \n reg timeout; \n reg [19:0] timer; \n reg [15:0] time_inc; \n wire [7:0] TMR_STATUS = {timeout, 7'h00}; \n always @(posedge wb_clk_i or posedge wb_rst_i) begin \n  if(wb_rst_i) begin \n  sb_dat_o <= 8'h00; \n  end \n  else begin \n  if(rd_command) begin \n  case(sb_adr_i) \n  `REG_STATUS: sb_dat_o <= TMR_STATUS; \n  `REG_TIMERH: sb_dat_o <= time_inc[15:8]; \n  `REG_TIMERL: sb_dat_o <= time_inc[ 7:0]; \n  default: sb_dat_o <= 8'h00; \n  endcase \n  end \n  end \n end \n always @(posedge wb_clk_i or posedge wb_rst_i) begin \n  if(wb_rst_i) begin \n  dsp_audio_l <= 8'h80; \n  dsp_audio_r <= 8'h80; \n  start <= 1'b0; \n  timeout <= 1'b0; \n  time_inc <= `DSP_DEFAULT_RATE; \n  end \n  else begin \n  if(wr_command) begin \n  case(sb_adr_i) \n  `REG_CHAN01: begin \n  dsp_audio_l <= sb_dat_i; \n  start <= 1'b1; \n  timeout <= 1'b0; \n  end \n  `REG_CHAN02: begin \n  dsp_audio_r <= sb_dat_i; \n  start <= 1'b1; \n  timeout <= 1'b0; \n  end \n  `REG_TIMERH: time_inc[15:8] <= sb_dat_i; \n  `REG_TIMERL: time_inc[ 7:0] <= sb_dat_i; \n  default: ; \n  endcase \n  end \n  if(timed_out) begin \n  start <= 1'b0; \n  timeout <= 1'b1; \n  end \n  end \n end \n wire timed_out = timer[19]; \n always @(posedge dac_clk) begin \n  if(wb_rst_i) begin \n  timer <= 20'd0; \n  end \n  else begin \n  if(start) timer <= timer + time_inc; \n  else timer <= 20'd0; \n  end \n end \n  wire pwm_clk = clkdiv[2]; \n  reg [8:0] clkdiv; \n  always @(posedge dac_clk) clkdiv <= clkdiv + 9'd1; \n  reg [7:0] dsp_audio_l; \n  reg [7:0] dsp_audio_r; \n  dac8 left (pwm_clk, dsp_audio_l, audio_L); \n  dac8 right(pwm_clk, dsp_audio_r, audio_R); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module oh_ser2par implements a serializer to parallel converter. It takes in serial data din, and outputs parallel data dout. The width of the input serial data is SW, and the width of the output parallel data is PW. It also has a parameter CW which is the number of bits required to represent the count for serialization. The module shifts the input data into the output register based on the clock edge and the lsbfirst and shift inputs. The count register keeps track of the shift operation.\n\n Module header:\n\nmodule oh_ser2par #(parameter PW = 64,parameter SW = 1,parameter CW = $clog2(PW/SW)) (input clk,input [SW-1:0] din,output reg [PW-1:0] dout,input lsbfirst,input shift);\n [/INST]\n", "output": "reg [CW-1:0] count; \n  wire [PW-1:0] shiftdata; \n  always @ (posedge clk) \n  if(shift & lsbfirst) \n  dout[PW-1:0] <= {din[SW-1:0],dout[PW-1:SW]}; \n  else if(shift) \n  dout[PW-1:0] <= {dout[PW-SW-1:0],din[SW-1:0]}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a parameterized AND gate functionality. It takes in a data input and computes the bitwise AND operation across the input bits to produce the result output. The module includes parameter declarations for width, size, and type, and initializes the result in an initial block. It also handles error cases for invalid parameter values. The module is designed to efficiently perform the AND operation on multi-bit inputs based on the specified width and size parameters.\n\n Module header:\n\nmodule lpm_and (data,result);\n [/INST]\n", "output": "parameter lpm_width = 1; \n  parameter lpm_size = 1; \n  parameter lpm_type = \"lpm_and\"; \n  parameter lpm_hint = \"UNUSED\"; \n  input [(lpm_size * lpm_width)-1:0] data; \n  output [lpm_width-1:0] result; \n  reg [lpm_width-1:0] result_tmp; \n  integer i; \n  integer j; \n  integer k; \n  initial \n  begin \n  if (lpm_width <= 0) \n  begin \n  $display(\"Value of lpm_width parameter must be greater than 0(ERROR)\"); \n  $display(\"Time: %0t Instance: %m\", $time); \n  $finish; \n  end \n  if (lpm_size <= 0) \n  begin \n  $display(\"Value of lpm_size parameter must be greater than 0(ERROR)\"); \n  $display(\"Time: %0t Instance: %m\", $time); \n  $finish; \n  end \n  end \n  always @(data) \n  begin \n  for (i=0; i<lpm_width; i=i+1) \n  begin \n  result_tmp[i] = 1'b1; \n  for (j=0; j<lpm_size; j=j+1) \n  begin \n  k = (j * lpm_width) + i; \n  result_tmp[i] = result_tmp[i] & data[k]; \n  end \n  end \n  end \n  assign result = result_tmp; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a master buffer for handling requests. It contains a request buffer with a configurable depth and manages write and read pointers for pushing and popping requests. The module also interfaces with a Tawas RCN master module to handle request and response signals. The buffer's fullness is indicated by the 'full' output, and request push and pop actions are controlled using the 'req_push' and 'req_pop' signals. The buffer also captures and stores the request data and manages the request busy state.\n\n Module header:\n\nmodule tawas_rcn_master_buf (input rst,input clk,input [68:0] rcn_in,output [68:0] rcn_out,input cs,input [4:0] seq,input wr,input [3:0] mask,input [23:0] addr,input [31:0] wdata,output full,output rdone,output wdone,output [4:0] rsp_seq,output [3:0] rsp_mask,output [23:0] rsp_addr,output [31:0] rsp_data);\n [/INST]\n", "output": "parameter MASTER_GROUP_8 = 0; \n  parameter DEPTH = 16; \n  reg [63:0] req_buf[(DEPTH - 1):0]; \n  reg [5:0] write_ptr; \n  reg [5:0] read_ptr; \n  reg [6:0] req_cnt; \n  assign full = (req_cnt >= (DEPTH - 5)); \n  wire req_push = cs && (req_cnt != DEPTH); \n  wire req_pop; \n  always @ (posedge clk or posedge rst) \n  if (rst) \n  req_cnt <= 7'd0; \n  else \n  case ({req_push, req_pop}) \n  2'b10: req_cnt <= req_cnt + 7'd1; \n  2'd01: req_cnt <= req_cnt - 7'd1; \n  default: ; \n  endcase \n  always @ (posedge clk or posedge rst) \n  if (rst) \n  write_ptr <= 6'd0; \n  else if (req_push) \n  write_ptr <= (write_ptr == (DEPTH - 1)) ? 6'd0 : write_ptr + 6'd1; \n  always @ (posedge clk or posedge rst) \n  if (rst) \n  read_ptr <= 6'd0; \n  else if (req_pop) \n  read_ptr <= (read_ptr == (DEPTH - 1)) ? 6'd0 : read_ptr + 6'd1; \n  always @ (posedge clk) \n  if (req_push) \n  req_buf[write_ptr] <= {seq, wr, mask[3:0], addr[23:2], wdata[31:0]}; \n  wire req_vld = (req_cnt != 0); \n  wire [63:0] req = req_buf[read_ptr][63:0]; \n  wire req_busy; \n  assign req_pop = req_vld && !req_busy; \n  tawas_rcn_master #(.MASTER_GROUP_8(MASTER_GROUP_8)) rcn_master \n (.rst(rst),.clk(clk),.rcn_in(rcn_in),.rcn_out(rcn_out),.cs(req_vld),.seq(req[63:59]),.busy(req_busy),.wr(req[58]),.mask(req[57:54]),.addr({req[53:32], 2'd0}),.wdata(req[31:0]),.rdone(rdone),.wdone(wdone),.rsp_seq(rsp_seq),.rsp_mask(rsp_mask),.rsp_addr(rsp_addr),.rsp_data(rsp_data)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a register file with three input ports (idxZ, idxX, and idxY) and one output port (valZ, valX, and valY). It uses an array of 15 registers, with initial values set to 0. The module updates the registers based on the clock signal and the input conditions. The valX, valY, and valZ outputs are determined based on the input conditions and the nextP signal. The memory is updated on the positive edge of the clock signal based on the conditions involving upZ, idxZ, and nextZ.\n\n Module header:\n\nmodule Reg(input clk, upZ, output signed[31:0] valZ, valX, valY,input[3:0] idxZ, idxX, idxY, input signed[31:0] nextZ, nextP);\n [/INST]\n", "output": "reg[31:0] store[0:14]; \n  integer k; \n  initial for (k = 0; k < 15; k = k + 1) store[k] = 0; \n  assign valX = &idxX ? nextP : store[idxX]; \n  assign valY = &idxY ? nextP : store[idxY]; \n  assign valZ = &idxZ ? nextP : store[idxZ]; \n  always @(posedge clk) if (&{upZ,|idxZ,~&idxZ}) store[idxZ] <= nextZ; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a pipeline stage that stores the values of various control signals and data from the previous pipeline stage. The values are updated on the falling edge of the clock, and the module also provides a mechanism to flush all the stored values if the flush input is asserted. If there is no stall, the values are updated from the inputs of the previous stage.\n\n Module header:\n\nmodule EX_MEM(input Clk,input stall,input flush,input [31:0]Branch_addr_EX,input [5:0]op_EX,input [2:0]Condition_EX,input Branch_EX,input MemWrite_EX,input RegWrite_EX,input MemRead_EX,input [31:0]MemData_EX,input [31:0]WBData_EX,input Less_EX,input Zero_EX,input Overflow_EX,input [4:0]Rd_EX,output reg [31:0]Branch_addr_MEM,output reg [5:0]op_MEM,output reg [2:0]Condition_MEM,output reg Branch_MEM,output reg MemWrite_MEM,output reg RegWrite_MEM,output reg MemRead_MEM,output reg [31:0]MemData_MEM,output reg [31:0]WBData_MEM,output reg Less_MEM,output reg Zero_MEM,output reg Overflow_MEM,output reg [4:0]Rd_MEM);\n [/INST]\n", "output": "initial \n begin \n Branch_addr_MEM=32'b0; \n op_MEM=6'b0; \n Condition_MEM=3'b0; \n Branch_MEM=0; \n MemWrite_MEM=0; \n RegWrite_MEM=0; \n MemRead_MEM=0; \n MemData_MEM=2'b0; \n WBData_MEM=32'b0; \n Less_MEM=0; \n Zero_MEM=0; \n Overflow_MEM=0; \n Rd_MEM=5'b0; \n end \n always @(negedge Clk)begin \n  if(flush)begin \n  op_MEM <= 0; \n  Condition_MEM <= 0; \n  Branch_MEM <= 0; \n  MemWrite_MEM <= 0; \n  RegWrite_MEM <= 0; \n  MemRead_MEM <= 0; \n  MemData_MEM <= 0; \n  WBData_MEM <= 0; \n  Less_MEM <= 0; \n  Zero_MEM <= 0; \n  Overflow_MEM <= 0; \n  Rd_MEM <= 0; \n  end \n  else if(!stall)begin \n  Branch_addr_MEM <= Branch_addr_EX; \n  op_MEM <= op_EX; \n  Condition_MEM <= Condition_EX; \n  Branch_MEM <= Branch_EX; \n  MemWrite_MEM <= MemWrite_EX; \n  RegWrite_MEM <= RegWrite_EX; \n  MemRead_MEM <= MemRead_EX; \n  MemData_MEM <= MemData_EX; \n  WBData_MEM <= WBData_EX; \n  Less_MEM <= Less_EX; \n  Zero_MEM <= Zero_EX; \n  Overflow_MEM <= Overflow_EX; \n  Rd_MEM <= Rd_EX; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module converts the input signal In1, which is a 32-bit signed number, to the output signal Out1, a 18-bit signed number by taking the most significant 18 bits of the input.\n\n Module header:\n\nmodule controllerHdl_Convert_Data_Type (In1,Out1);\n [/INST]\n", "output": "input signed [31:0] In1; \n  output signed [17:0] Out1; \n  wire signed [17:0] Data_Type_Conversion_out1; \n  assign Data_Type_Conversion_out1 = In1[31:14]; \n  assign Out1 = Data_Type_Conversion_out1; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, named sys_clk_gen_ds, generates a system clock and its complement. It takes in the system clock's positive and negative outputs, and has parameters for offset and halfcycle. It instantiates the sys_clk_gen module to generate the clock, and negates the positive clock to produce the negative clock.\n\n Module header:\n\nmodule sys_clk_gen_ds (sys_clk_p, sys_clk_n);\n [/INST]\n", "output": "output sys_clk_p; \n output sys_clk_n; \n parameter offset = 0; \n parameter halfcycle = 500; \n sys_clk_gen #(.offset( offset ),.halfcycle( halfcycle )) \n clk_gen (.sys_clk(sys_clk_p)); \n assign sys_clk_n = !sys_clk_p; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a testbench for a design called softusb_navre. It initializes and toggles the clock signal, handles read and write accesses to memory, processes input/output operations, and monitors the end_of_test signal to control the test flow. The module also instantiates the softusb_navre design, sets up test cases, and finishes the test at the end. It's designed to test the functionality of the softusb_navre design using different ROM files for different test scenarios.\n\n Module header:\n\nmodule tb_navre();\n [/INST]\n", "output": "reg sys_clk; \n initial sys_clk = 1'b1; \n always #5 sys_clk = ~sys_clk; \n reg sys_rst; \n wire pmem_ce; \n wire [9:0] pmem_a; \n reg [15:0] pmem_d; \n reg [15:0] pmem[0:1023]; \n always @(posedge sys_clk) begin \n  if(pmem_ce) \n  pmem_d <= pmem[pmem_a]; \n end \n wire dmem_we; \n wire [9:0] dmem_a; \n reg [7:0] dmem_di; \n wire [7:0] dmem_do; \n reg [7:0] dmem[0:1023]; \n always @(posedge sys_clk) begin \n  if(dmem_we) begin \n  dmem[dmem_a] <= dmem_do; \n  end \n  dmem_di <= dmem[dmem_a]; \n end \n wire io_re; \n wire io_we; \n wire [5:0] io_a; \n wire [7:0] io_do; \n reg [7:0] io_di; \n reg end_of_test; \n always @(posedge sys_clk) begin \n  end_of_test <= 1'b0; \n  if(~sys_rst) begin \n  if(io_re) begin \n  $display(\"IO READ adr=%x\", io_a); \n  if((io_a == 6'h11)|(io_a == 6'h12)) \n  io_di <= 8'hff; \n  else \n  io_di <= io_a; \n  end \n  if(io_we) begin \n  $display(\"IO WRITE adr=%x dat=%x\", io_a, io_do); \n  if((io_a == 0) && (io_do == 254)) \n  end_of_test <= 1'b1; \n  end \n  end \n end \n softusb_navre #(.pmem_width(10),.dmem_width(10)) dut (.clk(sys_clk),.rst(sys_rst),.pmem_ce(pmem_ce),.pmem_a(pmem_a),.pmem_d(pmem_d),.dmem_we(dmem_we),.dmem_a(dmem_a),.dmem_di(dmem_di),.dmem_do(dmem_do),.io_re(io_re),.io_we(io_we),.io_a(io_a),.io_do(io_do),.io_di(io_di)); \n initial begin \n  $display(\"Test: Fibonacci (assembler)\"); \n  $readmemh(\"fib.rom\", pmem); \n  sys_rst = 1'b1; \n  #15; \n  sys_rst = 1'b0; \n  @(posedge end_of_test); \n  $display(\"Test: Fibonacci (C)\"); \n  $readmemh(\"fibc.rom\", pmem); \n  sys_rst = 1'b1; \n  #15; \n  sys_rst = 1'b0; \n  @(posedge end_of_test); \n  $finish; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is designed to crop an input image based on specified top, bottom, left, and right boundaries. The module uses input signals to specify the cropping boundaries and to enable the cropping operation. The module generates output signals for the cropped image data, the cropped image count, and the readiness of the output.\n\nThe cropping operation is based on the work_mode parameter, which can be set to 0 or 1. When work_mode is 0, the output is updated on the clock edge. When work_mode is 1, the output is updated when the input is enabled.\n\nThe module has registers to store the output count and data. It also checks whether the input count is within the specified cropping boundaries. If the input is within the boundaries and the input is ready, the output data is updated with the cropped data; otherwise, the output data is set to zero.\n\nOverall, the module provides a configurable cropping functionality for image processing applications.\n\n Module header:\n\nmodule Crop(clk,rst_n,top,bottom,left,right,in_enable,in_data,in_count_x,in_count_y,out_ready,out_data,out_count_x,out_count_y);\n [/INST]\n", "output": "parameter work_mode = 0; \n  parameter data_width = 8; \n  parameter im_width = 320; \n  parameter im_height = 240; \n  parameter im_width_bits = 9; \n  input clk; \n  input rst_n; \n  input[im_width_bits - 1 : 0] top; \n  input[im_width_bits - 1 : 0] bottom; \n  input[im_width_bits - 1 : 0] left; \n  input[im_width_bits - 1 : 0] right; \n  input in_enable; \n  input [data_width - 1 : 0] in_data; \n  input[im_width_bits - 1 : 0] in_count_x; \n  input[im_width_bits - 1 : 0] in_count_y; \n  output out_ready; \n  output[data_width - 1 : 0] out_data; \n  output[im_width_bits - 1 : 0] out_count_x; \n  output[im_width_bits - 1 : 0] out_count_y; \n  generate \n  reg[im_width_bits - 1 : 0] reg_out_count_x; \n  reg[im_width_bits - 1 : 0] reg_out_count_y; \n  reg[data_width - 1 : 0] reg_out_data; \n  reg reg_out_ready; \n  reg in_range_t, in_range_b, in_range_l, in_range_r; \n  always @(posedge clk or negedge rst_n or negedge in_enable) begin \n  if(~rst_n || ~in_enable) \n  reg_out_ready <= 0; \n  else \n  reg_out_ready <= 1; \n  end \n  assign out_ready = reg_out_ready; \n  always @(posedge clk or negedge rst_n or negedge in_enable) begin \n  if(~rst_n || ~in_enable) begin \n  in_range_t <= 0; \n  in_range_b <= 0; \n  in_range_l <= 0; \n  in_range_r <= 0; \n  end else begin \n  in_range_t <= in_count_y >= top ? 1 : 0; \n  in_range_b <= in_count_y <= bottom ? 1 : 0; \n  in_range_l <= in_count_x >= left ? 1 : 0; \n  in_range_r <= in_count_x <= right ? 1 : 0; \n  end \n  end \n  if(work_mode == 0) begin \n  always @(posedge clk) begin \n  reg_out_count_x <= in_count_x; \n  reg_out_count_y <= in_count_y; \n  reg_out_data <= in_data; \n  end \n  end else begin \n  always @(posedge in_enable) begin \n  reg_out_count_x <= in_count_x; \n  reg_out_count_y <= in_count_y; \n  reg_out_data <= in_data; \n  end \n  end \n  assign out_count_x = reg_out_count_x; \n  assign out_count_y = reg_out_count_y; \n  assign out_data = out_ready & in_range_t & in_range_b & in_range_l & in_range_r ? reg_out_data : 0; \n  endgenerate \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module represents an SRAM (Static Random-Access Memory) and mirror. It has an internal memory array 'vram' of 32,768 8-bit words, initialized from a hex file and filled with zeros. When a specific condition is met based on the input signals, it writes 'din2' to the 'vram' array. It also reads from the 'vram' array and assigns the output to 'dout1'. The module also assigns the input 'a2' to 'a' and 'we2_n' to 'we_n'. The output 'dout2' is assigned to 'd' and 'd' is conditionally assigned 'din2' or '8'hZZ' based on 'we_n'.\n\n Module header:\n\nmodule sram_and_mirror (input wire clk,input wire [14:0] a1,input wire [18:0] a2,input wire we2_n,input wire [7:0] din2,output reg [7:0] dout1,output wire [7:0] dout2,output wire [18:0] a,inout wire [7:0] d,output wire we_n);\n [/INST]\n", "output": "reg [7:0] vram[0:32767]; \n  integer i; \n  initial begin \n  $readmemh(\"initial_bootscreen.hex\", vram, 0, 6912); \n  for (i=6912;i<32768;i=i+1) \n  vram[i] = 8'h00; \n  end \n  always @(posedge clk) begin \n  if (we2_n == 1'b0 && a2[18:16] == 3'b001 && a2[14] == 1'b1) \n  vram[{a2[15],a2[13:0]}] <= din2; \n  dout1 <= vram[a1]; \n  end \n  assign a = a2; \n  assign we_n = we2_n; \n  assign dout2 = d; \n  assign d = (we_n == 1'b0)? din2 : 8'hZZ; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a dual-port RAM with 32 memory locations. The module has inputs for data in (DI), clock (CLK), write enable (WE), and address (A) for reading and writing. It also has a separate address input for writing (WA). The memory is initialized with a specific value (INIT_00). The module reads data from the memory at the specified address (A) and outputs it. When the write enable signal (WE) is asserted and there is a rising edge on the clock signal (CLK), the input data (DI) is written into the memory at the specified write address (WA).\n\n Module header:\n\nmodule DPRAM32 (output O,input DI, CLK, WE,input [4:0] A, WA);\n [/INST]\n", "output": "parameter [31:0] INIT_00 = 32'h0; \n  parameter IS_WCLK_INVERTED = 1'b0; \n  wire [4:0] A; \n  wire [4:0] WA; \n  reg [31:0] mem; \n  initial mem <= INIT_00; \n  assign O = mem[A]; \n  wire clk = CLK ^ IS_WCLK_INVERTED; \n  always @(posedge clk) if (WE) begin \n  mem[WA] <= DI; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module is an Arithmetic Logic Unit (ALU) that performs arithmetic and logical operations on two 16-bit inputs, op1 and op2, based on the control signal operator. The ALU has a 16-bit output, out, and a status register. The status register is updated with the result of the operation on the positive edge of the clock signal or the negative edge of the reset signal. The ALU supports operations such as addition, subtraction, multiplication, bitwise NOT, division, modulus, comparison, and assignment, and provides the result through the output signal out. When the reset signal is low, the output and status are set to zero.\n\n Module header:\n\nmodule alu16(input clk,rst,input [2:0] operator,input [15:0] op1,op2,output reg [15:0] out, status);\n [/INST]\n", "output": "`define numBits 16 \n  `define operatorSize 4 \n  always@(*) begin \n  if(rst == 1'b0) begin \n  out <= `numBits'd0; \n  end else begin \n  case(operator) \n  `operatorSize'h0: \n  out <= op1 + op2; \n  `operatorSize'h1: \n  out <= op2 - op1; \n  `operatorSize'h2: \n  out <= (op1 * op2); \n  `operatorSize'h3: \n  out <= ~(op1 & op2); \n  `operatorSize'h4: \n  out <= op1 / op2; \n  `operatorSize'h5: \n  out <= op1 % op2; \n  `operatorSize'h6: \n  out <= op1 < op2; \n  `operatorSize'h7: \n  out <= op1 <= op2; \n  default: \n  out <= `numBits'd0; \n  endcase \n  end \n  end \n  always@(posedge clk or negedge rst) begin \n  if(rst == 1'b0) begin \n  status = `numBits'd0; \n  end else begin \n  status <= out; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a microphone input module that processes data from a microphone and controls an amplifier. It includes a clock signal, data registers, and a FIFO for data storage. It also features a PWM block for controlling the amplifier, a frequency divider for the clock signal, and a data counter. The module continuously samples the microphone data and updates the registers, while also controlling the amplifier based on the received data. The module is designed to handle the input and output operations of the microphone, as well as manage the clock signals and data processing.\n\n Module header:\n\nmodule microfono (input reset,output ledres,input clk,output mclk,output reg micLRSel,input micData,output ampPWM,output ampSD,input rd,wr,output empty,output full,output reg done);\n [/INST]\n", "output": "wire [320:0] dout; \n wire [320:0] dout1; \n wire mclk1; \n wire mclk2; \n assign mclk3=mclk2; \n assign mclk2=mclk1; \n assign mclk=mclk1; \n reg [320:0] sregt1; \n reg [320:0] sregt; \n fifo fi(.reset(reset),.din(sregt1),.dout(dout),.clock(done),.rd(rd),.wr(wr),.empty(empty),.full(full)); \n pwm pw(.ampSD(ampSD), .reset(reset),.mclk(mclk2),.ampPWM(ampPWM),.clk(clk),.dout(dout1)); \n div_freq df(.clk(clk), .reset(reset),.clkout(mclk1),.led(ledres)); \n reg [320:0] count; \n assign dout1=dout; \n initial micLRSel <= 0; \n initial count <= 0; \n initial sregt <= 0; \n initial sregt1 <= 0; \n always @(posedge mclk) \n begin \n  if (reset) \n  begin \n  sregt<=0; \n  end \n  else \n  begin \n  if(count<=320) \n  begin \n  sregt<= {sregt[320:0],micData}; \n  count<=count+1; \n  done<=0; \n  end \n  else \n  begin \n  count<=0; \n  done<=1; \n  sregt1<=sregt; \n  end \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a reset and synchronization logic for various control signals in a processor's instruction decode/execute stage. It handles the reset of control signals when the circuit is in the reset state, when debug mode is enabled, and during synchronization clears. It also maintains the output of control signals based on the current input conditions when debug mode is enabled. The control signals managed include ALU operation, signal extension, read data, ALU source, memory write, memory to register, memory read width, register write, register source/destination, load immediate, and end of packet signals.\n\n Module header:\n\nmodule ID_EX(input clock,input reset,input debugEnable,input debugReset,input syncClr,input [4:0] rs,input [4:0] rt,input [4:0] rd,input [4:0] sa,input [3:0] aluOperation,input [31:0] sigExt,input [31:0] readData1,input [31:0] readData2,input aluSrc,input aluShiftImm,input regDst,input loadImm,input [3:0]memWrite,input memToReg,input[1:0] memReadWidth,input regWrite,input eop,output reg [3:0] aluOperationOut,output reg [31:0] sigExtOut,output reg [31:0] readData1Out,output reg [31:0] readData2Out,output reg aluSrcOut,output reg aluShiftImmOut,output reg [3:0]memWriteOut,output reg memToRegOut,output reg[1:0] memReadWidthOut,output reg[4:0] rsOut,output reg[4:0] rtOut,output reg[4:0] rdOut,output reg[4:0] saOut,output reg regDstOut,output reg loadImmOut,output reg regWriteOut,output reg eopOut);\n [/INST]\n", "output": "always @(negedge clock,posedge reset)begin \n  if(reset)begin \n  aluOperationOut<=0; \n  sigExtOut<=0; \n  readData1Out<=0; \n  readData2Out<=0; \n  aluSrcOut<=0; \n  aluShiftImmOut<=0; \n  memWriteOut<=0; \n  memToRegOut<=0; \n  memReadWidthOut<=0; \n  regWriteOut<=0; \n  rsOut<=0; \n  rtOut<=0; \n  rdOut<=0; \n  saOut<=0; \n  regDstOut<=0; \n  loadImmOut<=0; \n  eopOut<=0; \n  end \n  else if(debugReset)begin \n  aluOperationOut<=0; \n  sigExtOut<=0; \n  readData1Out<=0; \n  readData2Out<=0; \n  aluSrcOut<=0; \n  aluShiftImmOut<=0; \n  memWriteOut<=0; \n  memToRegOut<=0; \n  memReadWidthOut<=0; \n  regWriteOut<=0; \n  rsOut<=0; \n  rtOut<=0; \n  rdOut<=0; \n  saOut<=0; \n  regDstOut<=0; \n  loadImmOut<=0; \n  eopOut<=0; \n  end \n  else if(syncClr)begin \n  aluOperationOut<=0; \n  sigExtOut<=0; \n  readData1Out<=0; \n  readData2Out<=0; \n  aluSrcOut<=0; \n  aluShiftImmOut<=0; \n  memWriteOut<=0; \n  memToRegOut<=0; \n  memReadWidthOut<=0; \n  regWriteOut<=0; \n  rsOut<=0; \n  rtOut<=0; \n  rdOut<=0; \n  saOut<=0; \n  regDstOut<=0; \n  loadImmOut<=0; \n  eopOut<=0; \n  end \n  else if (debugEnable) begin \n  aluOperationOut<=aluOperation; \n  sigExtOut<=sigExt; \n  readData1Out<=readData1; \n  readData2Out<=readData2; \n  aluSrcOut<=aluSrc; \n  aluShiftImmOut<=aluShiftImm; \n  memWriteOut<=memWrite; \n  memToRegOut<= memToReg; \n  memReadWidthOut<=memReadWidth; \n  regWriteOut<=regWrite; \n  rsOut<=rs; \n  rtOut<=rt; \n  rdOut<=rd; \n  saOut<=sa; \n  regDstOut<=regDst; \n  loadImmOut<=loadImm; \n  eopOut<=eop; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a logic circuit for a plane's body and wing based on input coordinates and parameters. The body and wing outputs are set based on specific conditions involving the input coordinates and parameters, as well as the clock and reset signals. The body and wing outputs are set to 1 when the conditions are met, and 0 otherwise. The body and wing logic is evaluated on the rising edge of the clock signal and when the reset signal is asserted.\n\n Module header:\n\nmodule planeB(input clk,input rst,input [10:0] x,input [10:0] y,input [10:0] poX,input [10:0] poY,output reg wing,output reg body);\n [/INST]\n", "output": "parameter pL = 40; \n parameter pW = 10; \n parameter wL = 15; \n parameter wW = 15; \n parameter wP = 10; \n always@(posedge clk, posedge rst) \n begin \n  if(rst) body <= 0; \n  else begin \n  if(x < poX+pL && x > poX && y < poY+wL+pW && y >poY+wL) body <= 1; \n  else body <= 0; \n  end \n end \n always@(posedge clk, posedge rst) \n begin \n  if(rst) wing <= 0; \n  else begin \n  if(x < poX+wP+wW && x > poX+wP && y < poY+wL && y > poY && x-poX+y-poY >wW+wP) wing <= 1; \n  else if(x < poX+wP+wW && x > poX+wP && y > poY+wL+pW && y < poY+wL+wL+pW && x-poX-y+poY >wP-wL-pW) wing <= 1; \n  else wing <= 0; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a positive-edge triggered D flip-flop with preset (pre), clear (clr), and enable (en) functionalities. The output q is initially assigned a value of 0. When the pre input is asserted, q is set to 1. When the clr input is asserted, q is cleared to 0. When the en input is asserted, q takes on the value of the input d on the positive clock edge.\n\n Module header:\n\nmodule my_dffsre_ppp (input d,clk,pre,clr,en,output reg q);\n [/INST]\n", "output": "initial q <= 1'b0; \n  always @(posedge clk or posedge pre or posedge clr) \n  if (pre) q <= 1'b1; \n  else if (clr) q <= 1'b0; \n  else if (en) q <= d; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an arbiter with configurable parameters for the number of masters and their data and address widths. It selects one of the masters for data and address outputs based on requests, and generates control signals for the selected master. The `arbiter` instance arbitrates among the masters using the requests and generates an active signal. The `master_sel` and `grant` signals are used for master selection. The module uses the `clog2` function to compute the number of bits needed to represent the selected master. The `wbs_*_o` signals are assigned based on the selected master, and the `wbm_*_o` signals are assigned based on the acknowledgement, error, and retry signals with respect to the active master.\n\n Module header:\n\nmodule wb_arbiter #(parameter dw = 32,parameter aw = 32,parameter num_masters = 0) (input wb_clk_i,input wb_rst_i,input [num_masters*aw-1:0] wbm_adr_i,input [num_masters*dw-1:0] wbm_dat_i,input [num_masters*4-1:0] wbm_sel_i,input [num_masters-1:0] wbm_we_i,input [num_masters-1:0] wbm_cyc_i,input [num_masters-1:0] wbm_stb_i,input [num_masters*3-1:0] wbm_cti_i,input [num_masters*2-1:0] wbm_bte_i,output [num_masters*dw-1:0] wbm_dat_o,output [num_masters-1:0] wbm_ack_o,output [num_masters-1:0] wbm_err_o,output [num_masters-1:0] wbm_rty_o,output [aw-1:0] wbs_adr_o,output [dw-1:0] wbs_dat_o,output [3:0] wbs_sel_o,output wbs_we_o,output wbs_cyc_o,output wbs_stb_o,output [2:0] wbs_cti_o,output [1:0] wbs_bte_o,input [dw-1:0] wbs_dat_i,input wbs_ack_i,input wbs_err_i,input wbs_rty_i);\n [/INST]\n", "output": "`ifdef BROKEN_CLOG2 \n  function integer clog2; \n  input integer in; \n  begin \n  in = in - 1; \n  for (clog2 = 0; in > 0; clog2=clog2+1) \n  in = in >> 1; \n  end \n  endfunction \n  `define clog2 clog2 \n `else \n  `define clog2 $clog2 \n `endif \n  parameter master_sel_bits = num_masters > 1 ? `clog2(num_masters) : 1; \n  wire [num_masters-1:0] grant; \n  wire [master_sel_bits-1:0] master_sel; \n  wire active; \n  arbiter \n  #(.NUM_PORTS (num_masters)) \n  arbiter0 \n (.clk (wb_clk_i),.rst (wb_rst_i),.request (wbm_cyc_i),.grant (grant),.select (master_sel),.active (active)); \n  assign wbs_adr_o = wbm_adr_i[master_sel*aw+:aw]; \n  assign wbs_dat_o = wbm_dat_i[master_sel*dw+:dw]; \n  assign wbs_sel_o = wbm_sel_i[master_sel*4+:4]; \n  assign wbs_we_o = wbm_we_i [master_sel]; \n  assign wbs_cyc_o = wbm_cyc_i[master_sel] & active; \n  assign wbs_stb_o = wbm_stb_i[master_sel]; \n  assign wbs_cti_o = wbm_cti_i[master_sel*3+:3]; \n  assign wbs_bte_o = wbm_bte_i[master_sel*2+:2]; \n  assign wbm_dat_o = {num_masters{wbs_dat_i}}; \n  assign wbm_ack_o = ((wbs_ack_i & active) << master_sel); \n  assign wbm_err_o = ((wbs_err_i & active) << master_sel); \n  assign wbm_rty_o = ((wbs_rty_i & active) << master_sel); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module instantiates a digital clock manager (DCM) called DCMInst with clock, reset, and locked inputs. The DCM produces multiple clock outputs with different phases (clock_o0, clock_o90, clock_o180, clock_o270, clock_o2x, clock_o2x180) based on the provided clock input. The module assigns the locked output to the DCM's locked output. The locked output indicates whether the DCM is locked to the input clock.\n\n Module header:\n\nmodule TestDCM(input wire [('b1) - ('b1):0] clock,input wire [('b1) - ('b1):0] reset,output wire [('b1) - ('b1):0] locked);\n [/INST]\n", "output": "wire [('b1) - ('b1):0] DCMInst_locked; \n  wire [('b1) - ('b1):0] DCMInst_clock_o0; \n  wire [('b1) - ('b1):0] DCMInst_clock_o90; \n  wire [('b1) - ('b1):0] DCMInst_clock_o180; \n  wire [('b1) - ('b1):0] DCMInst_clock_o270; \n  wire [('b1) - ('b1):0] DCMInst_clock_o2x; \n  wire [('b1) - ('b1):0] DCMInst_clock_o2x180; \n  assign locked = DCMInst_locked; \n  FPGADCM \n DCMInst(.clock(clock),.reset(reset),.locked(DCMInst_locked),.clock_o0(DCMInst_clock_o0),.clock_o90(DCMInst_clock_o90),.clock_o180(DCMInst_clock_o180),.clock_o270(DCMInst_clock_o270),.clock_o2x(DCMInst_clock_o2x),.clock_o2x180(DCMInst_clock_o2x180)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a synchronous serial-to-parallel converter (S2P). It takes in a reset signal, clock signal, enable signal, serial input, load signal, and parallel input data. It outputs parallel data. The module contains a register for the output data, which is updated based on the input signals and their conditions. When the reset signal is asserted, the output data is cleared. When the load signal is asserted, the output data is updated with the parallel input data. When the enable signal is asserted, the serial input data is merged into the output data.\n\n Module header:\n\nmodule s2p(nrst, clk, en, si, load, pi, po);\n [/INST]\n", "output": "parameter width = 8; \n  input nrst; \n  input clk; \n  input en; \n  input si; \n  input load; \n  input [width-1:0] pi; \n  output [width-1:0] po; \n  reg [width-1:0] po; \n  always @(posedge clk or negedge nrst) begin \n  if (~nrst) begin \n  po <= 0; \n  end else if (load) begin \n  po <= pi; \n  end else if (en) begin \n  po <= {po[width-2:0], si}; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a finite state machine (FSM) to control the behavior of a game. It includes two sub-modules, FSM_Barra and FSM_Bola, which handle the behavior of the bar and ball, respectively. The FSM has 8 states, each with specific actions based on input signals and the current state. The FSM transitions between these states based on the input signals start, v_sync, perdio, and the status of the bar and ball. It also sets various control signals, such as start_barra, start_ball, actualizar_bola, and actualizar_barra, to coordinate the game's behavior. Additionally, it initializes the state machine to STATE_0 upon reset and updates the state based on the input signals and the current state.\n\n Module header:\n\nmodule FSM_Main(input clock,input reset,input start,input v_sync,input perdio,output actualizar_bola,output actualizar_barra,output revisar_bordes_bola,output revisar_bordes_barra,output reg revisar_estado,output reg reset_bola,output reg reset_barra);\n [/INST]\n", "output": "reg start_barra, start_ball; \n  wire busy_barra, busy_ball; \n FSM_Barra fsm_barra(.clock(clock),.reset(reset),.start_barra(start_barra),.busy_barra(busy_barra),.actualizar_barra(actualizar_barra),.revisar_bordes_barra(revisar_bordes_barra)); \n FSM_Bola fsm_bola(.clock(clock),.reset(reset),.start_ball(start_ball),.busy_ball(busy_ball),.actualizar_bola(actualizar_bola),.revisar_bordes_bola(revisar_bordes_bola)); \n  parameter STATE_0 = 0; \n  parameter STATE_1 = 1; \n  parameter STATE_2 = 2; \n  parameter STATE_3 = 3; \n  parameter STATE_4 = 4; \n  parameter STATE_5 = 5; \n  parameter STATE_6 = 6; \n  parameter STATE_7 = 7; \n  reg [2:0] state; \n  reg displayed; \n  initial \n  begin \n  state <= STATE_0; \n  start_barra <= 1'b0; \n  start_ball <= 1'b0; \n  displayed <= 0; \n  reset_bola <= 1'b0; \n  reset_barra <= 1'b0; \n  revisar_estado <= 1'b0; \n  end \n  always@(posedge clock or posedge reset) \n  begin \n  if(reset) \n  begin \n  state <= STATE_0; \n  start_barra <= 1'b0; \n  start_ball <= 1'b0; \n  displayed <= 1'b0; \n  reset_bola <= 1'b0; \n  reset_barra <= 1'b0; \n  revisar_estado <= 1'b0; \n  end \n  else \n  begin \n  case(state) \n  STATE_0: \n  begin \n  if (start) \n  begin \n  reset_barra <= 1'b1; \n  reset_bola <=1'b1; \n  state <= STATE_1; \n  end \n  end \n  STATE_1: \n  begin \n  reset_barra <= 1'b0; \n  reset_bola <=1'b0; \n  revisar_estado <= 1'b1; \n  state <= STATE_2; \n  end \n  STATE_2: \n  begin \n  revisar_estado <= 1'b0; \n  state <= STATE_3; \n  end \n  STATE_3: \n  begin \n  if(perdio) \n  begin \n  state <= STATE_0; \n  end \n  else \n  state <= STATE_4; \n  end \n  STATE_4: \n  begin \n  if (v_sync) \n  begin \n  if(!displayed) \n  begin \n  start_barra <= 1'b1; \n  start_ball <= 1'b1; \n  displayed <= 1'b1; \n  state <= STATE_5; \n  end \n  end \n  else \n  displayed <= 0; \n  end \n  STATE_5: \n  begin \n  state <= STATE_6; \n  end \n  STATE_6: \n  begin \n  start_barra <= 1'b0; \n  start_ball <= 1'b0; \n  state <= STATE_7; \n  end \n  STATE_7: \n  begin \n  if (!busy_barra && !busy_ball) \n  begin \n  state <= STATE_1; \n  end \n  end \n  default: \n  begin \n  state <= STATE_0; \n  end \n  endcase \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, MemoryAddressHandler, is responsible for managing memory addresses and control flow based on various inputs. It features logic to handle program counter increments, stack operations, control signals, and address calculations. The module selects the appropriate stack based on the is_kernel input, updates the stack pointer and program counter based on the control signals, and generates the final result and output addresses accordingly. The module also handles reset operations and branching conditions.\n\n Module header:\n\nmodule MemoryAddressHandler #(parameter WORD_SIZE = 32,parameter KERNEL_STACK_TOP = 6144,parameter KERNEL_STACK_BOTTOM = 7167,parameter USER_STACK_TOP = 7168,parameter USER_STACK_BOTTOM = 8191,parameter MAX_NUMBER = 32'hffffffff)(input is_kernel, should_branch, reset,input [2 : 0] control,input [(WORD_SIZE - 1) : 0] ALU_result, current_PC, current_SP,output reg [(WORD_SIZE - 1) : 0] next_SP, output_address,output reg [(WORD_SIZE - 1) : 0] final_result, next_PC,output [(WORD_SIZE - 1) : 0] instruction_address);\n [/INST]\n", "output": "wire [(WORD_SIZE - 1) : 0] incr_pc, r_incr_pc; \n  assign incr_pc = current_PC + 1; \n  assign r_incr_pc = reset ? 1 : incr_pc; \n  assign instruction_address = reset ? 0 : current_PC; \n  wire [(WORD_SIZE - 1): 0] top_stack, bottom_stack; \n  assign top_stack = is_kernel ? KERNEL_STACK_TOP : USER_STACK_TOP; \n  assign bottom_stack = is_kernel ? KERNEL_STACK_BOTTOM : USER_STACK_BOTTOM; \n  always @( * ) begin \n  case (control) \n  1:begin \n  next_SP = (current_SP > top_stack) ? current_SP - 1 : top_stack; \n  output_address = next_SP; \n  next_PC = r_incr_pc; \n  final_result = ALU_result; \n  end \n  2:begin \n  next_SP = (current_SP < bottom_stack) ? current_SP + 1 : bottom_stack; \n  output_address = current_SP; \n  next_PC = r_incr_pc; \n  final_result = ALU_result; \n  end \n  3:begin \n  next_SP = ALU_result; \n  output_address = ALU_result; \n  next_PC = r_incr_pc; \n  final_result = ALU_result; \n  end \n  4:begin \n  next_PC = reset ? 1 : (should_branch ? ALU_result : incr_pc); \n  final_result = incr_pc; \n  next_SP = current_SP; \n  output_address = ALU_result; \n  end \n  default: begin \n  next_PC = r_incr_pc; \n  final_result = ALU_result; \n  output_address = ALU_result; \n  next_SP = (current_SP == 0) ? bottom_stack: current_SP; \n  end \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes a 4-bit input hex and converts it to a 7-segment display output sseg with an optional decimal point dp. The conversion is done using a case statement that maps each possible value of hex to the corresponding pattern for the 7-segment display. The decimal point dp is assigned to the 8th bit of sseg.\n\n Module header:\n\nmodule hex_to_sseg(input wire[3:0] hex,output reg[7:0] sseg,input dp);\n [/INST]\n", "output": "always @* \n  begin \n  case(hex) \n  4'h0: sseg[6:0] = 7'b0000001; \n  4'h1: sseg[6:0] = 7'b1001111; \n  4'h2: sseg[6:0] = 7'b0010010; \n  4'h3: sseg[6:0] = 7'b0000110; \n  4'h4: sseg[6:0] = 7'b1001100; \n  4'h5: sseg[6:0] = 7'b0100100; \n  4'h6: sseg[6:0] = 7'b0100000; \n  4'h7: sseg[6:0] = 7'b0001111; \n  4'h8: sseg[6:0] = 7'b0000000; \n  4'h9: sseg[6:0] = 7'b0000100; \n  4'ha: sseg[6:0] = 7'b0000010; \n  4'hb: sseg[6:0] = 7'b1100000; \n  4'hc: sseg[6:0] = 7'b0110001; \n  4'hd: sseg[6:0] = 7'b1000010; \n  4'he: sseg[6:0] = 7'b0010000; \n  4'hf: sseg[6:0] = 7'b0111000; \n  default: sseg[6:0] = 7'b111111; \n  endcase \n  sseg[7] = dp; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module implements a simple LED control with a duty cycle. The module simulates the behavior of a switch and LED based on a clock signal. The LED brightness is controlled by the duty cycle, and the module continuously prints the current values of the switch, clock, and LED. The clock signal alternates between 0 and 1, and the simulation finishes after 1000 clock cycles.\n\n Module header:\n\nmodule BDCLed_TBV ();\n [/INST]\n", "output": "reg clk = 0; \n wire [1:0] sw; \n reg [3:0] led = 0; \n wire [7:0] BDCLed0_0_duty_led; \n reg [7:0] BDCLed0_0_counter = 0; \n assign sw = 2'd0; \n assign BDCLed0_0_duty_led = 8'd8; \n always @(led, sw, clk) begin: BDCLED_TBV_PRINT_DATA \n  $write(\"%h\", sw); \n  $write(\" \"); \n  $write(\"%h\", clk); \n  $write(\" \"); \n  $write(\"%h\", led); \n  $write(\"\\n\"); \n end \n always @(posedge clk) begin: BDCLED_TBV_BDCLED0_0_LOGIC \n  BDCLed0_0_counter <= (BDCLed0_0_counter + 1); \n  if ((BDCLed0_0_counter < BDCLed0_0_duty_led)) begin \n  led <= 15; \n  end \n  else begin \n  led <= 0; \n  end \n end \n initial begin: BDCLED_TBV_CLK_SIGNAL \n  while (1'b1) begin \n  clk <= (!clk); \n  # 1; \n  end \n end \n initial begin: BDCLED_TBV_STIMULES \n  integer i; \n  i = 0; \n  while (1'b1) begin \n  if ((i == 1000)) begin \n  $finish; \n  end \n  i = i + 1; \n  @(posedge clk); \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a trigonometric table that calculates the cosine and sine values of an input angle. It utilizes a look-up table to store precalculated sine values and dynamically updates the output cos and sin values based on the input angle. The module uses a clock to synchronize the calculations and utilizes bit manipulation to compute the half-sine and half-cosine values from the table. The output cos and sin values are then calculated based on the input angle and the values from the look-up table.\n\n Module header:\n\nmodule trigTable #(parameter ANGLE_WIDTH = 12,parameter OUT_WIDTH = 18) (input wire clk,input wire [ANGLE_WIDTH-1:0] angle,output reg signed [OUT_WIDTH-1:0] cos,output reg signed [OUT_WIDTH-1:0] sin);\n [/INST]\n", "output": "localparam TABLE_LEN = 2**(ANGLE_WIDTH-2); \n wire [ANGLE_WIDTH-3:0] sinQuarterAngle; \n wire [ANGLE_WIDTH-3:0] cosQuarterAngle; \n reg [OUT_WIDTH-2:0] sineTable [TABLE_LEN-1:0]; \n reg sinBit; \n reg cosBit; \n reg [OUT_WIDTH-2:0] halfSin; \n reg [OUT_WIDTH-2:0] halfCos; \n integer i; \n assign sinQuarterAngle = (angle[ANGLE_WIDTH-2]) ? ~angle[ANGLE_WIDTH-3:0] : angle[ANGLE_WIDTH-3:0]; \n assign cosQuarterAngle = (~angle[ANGLE_WIDTH-2]) ? ~angle[ANGLE_WIDTH-3:0] : angle[ANGLE_WIDTH-3:0]; \n initial begin \n  sinBit = 1'b0; \n  cosBit = 1'b0; \n  halfSin = 'd0; \n  halfCos = 'd0; \n  sin = 'd0; \n  cos = 'd0; \n  for(i=0; i<TABLE_LEN; i=i+1) begin \n  sineTable[i] = $rtoi($floor($sin((i+0.5)*3.14159/(TABLE_LEN*2))*(2**(OUT_WIDTH-1)-1)+0.5)); \n  end \n end \n always @(posedge clk) begin \n  sinBit <= angle[ANGLE_WIDTH-1]; \n  cosBit <= angle[ANGLE_WIDTH-1] ^ angle[ANGLE_WIDTH-2]; \n  halfSin <= sineTable[sinQuarterAngle]; \n  halfCos <= sineTable[cosQuarterAngle]; \n  sin <= sinBit ? -$signed({1'b0,halfSin}) : $signed({1'b0, halfSin}); \n  cos <= cosBit ? -$signed({1'b0,halfCos}) : $signed({1'b0, halfCos}); \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a register-based data processing unit with various control signals and a clock domain crossing block. It processes input data, performs arithmetic and logical operations, and controls memory access based on the input control signals. The module is sensitive to the clock signal and a reset signal, and updates its internal state accordingly. The module also includes an Arithmetic Logic Unit (ALU) and handles clock domain crossing for the input signals.\n\n Module header:\n\nmodule exec(input clk_i,input reset_i,input [63:0] inpa_i,input [63:0] inpb_i,input invB_i,input cflag_i,input lsh_en_i,input rsh_en_i,input ltu_en_i,input lts_en_i,input sum_en_i,input and_en_i,input xor_en_i,input [4:0] rd_i,input we_i,input nomem_i,input mem_i,input [63:0] dat_i,input [2:0] xrs_rwe_i,input busy_i,output [4:0] rd_o,output [63:0] addr_o,output we_o,output nomem_o,output mem_o,output [63:0] dat_o,output [2:0] xrs_rwe_o);\n [/INST]\n", "output": "reg [63:0] inpa_r, inpb_r, dat_r; \n  reg invB_r, cflag_r, we_r, nomem_r, mem_r; \n  reg lsh_en_r, rsh_en_r, ltu_en_r, lts_en_r, sum_en_r; \n  reg and_en_r, xor_en_r; \n  reg [2:0] xrs_rwe_r; \n  reg [4:0] rd_r; \n  assign rd_o = rd_r; \n  assign we_o = we_r; \n  assign nomem_o = nomem_r; \n  assign mem_o = mem_r; \n  assign dat_o = dat_r; \n  assign xrs_rwe_o = xrs_rwe_r; \n alu alu(.inA_i(inpa_r),.inB_i(inpb_r),.cflag_i(cflag_r),.sum_en_i(sum_en_r),.and_en_i(and_en_r),.xor_en_i(xor_en_r),.invB_en_i(invB_r),.lsh_en_i(lsh_en_r),.rsh_en_i(rsh_en_r),.ltu_en_i(ltu_en_r),.lts_en_i(lts_en_r),.out_o(addr_o),.cflag_o(),.vflag_o(),.zflag_o()); \n  always @(posedge clk_i) begin \n  inpa_r <= inpa_r; \n  inpb_r <= inpb_r; \n  dat_r <= dat_r; \n  invB_r <= invB_r; \n  cflag_r <= cflag_r; \n  we_r <= we_r; \n  nomem_r <= nomem_r; \n  mem_r <= mem_r; \n  lsh_en_r <= lsh_en_r; \n  rsh_en_r <= rsh_en_r; \n  ltu_en_r <= ltu_en_r; \n  lts_en_r <= lts_en_r; \n  sum_en_r <= sum_en_r; \n  and_en_r <= and_en_r; \n  xor_en_r <= xor_en_r; \n  xrs_rwe_r <= xrs_rwe_r; \n  rd_r <= rd_i; \n if (reset_i) begin{ \n  inpa_r, inpb_r, dat_r, invB_r, cflag_r, we_r, \n  mem_r, nomem_r, lsh_en_r, rsh_en_r, ltu_en_r, \n  lts_en_r, sum_en_r, and_en_r, xor_en_r, \n  xrs_rwe_r, rd_r \n  } <= 0; \n  end \n  else if (~busy_i) begin \n  inpa_r <= inpa_i; \n  inpb_r <= inpb_i; \n  dat_r <= dat_i; \n  invB_r <= invB_i; \n  cflag_r <= cflag_i; \n  we_r <= we_i; \n  nomem_r <= nomem_i; \n  mem_r <= mem_i; \n  lsh_en_r <= lsh_en_i; \n  rsh_en_r <= rsh_en_i; \n  ltu_en_r <= ltu_en_i; \n  lts_en_r <= lts_en_i; \n  sum_en_r <= sum_en_i; \n  and_en_r <= and_en_i; \n  xor_en_r <= xor_en_i; \n  xrs_rwe_r <= xrs_rwe_i; \n  rd_r <= rd_i; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a parameterized shift register with options for formal verification. The shift register can have a configurable width and depth, with a specified number of address bits. It features a regular implementation for synthesis and an extended implementation for formal verification. The module includes an initialization process, shifting mechanism based on clock pulses, and concatenation of output data for formal verification when enabled. The shift register has a data input, clock input, address input, and a clock enable input.\n\n Module header:\n\nmodule ShiftRegisterMacro #(parameter WIDTH = 16,parameter DEPTH = 32,parameter ADDR_BITS = 5) (input wire clk,input wire[ADDR_BITS-1 : 0] addr,input wire[WIDTH-1 : 0] din,input wire ce,output wire[WIDTH-1 : 0] dout`ifdef FORMAL, output reg[WIDTH*DEPTH - 1 : 0] dout_concat`endif);\n [/INST]\n", "output": "generate \n  initial begin \n  if(DEPTH > 32) begin \n  $display(\"ERROR - ShiftRegisterMacro only supports depth values less than 32 for now\"); \n  $finish; \n  end \n  end \n  endgenerate \n  `ifndef FORMAL \n  genvar i; \n  generate \n  for(i=0; i<WIDTH; i = i+1) begin: shregblock \n ShiftRegisterPrimitiveWrapper #(.DEPTH(32), .ADDR_BITS(ADDR_BITS)) shregbit (.clk(clk),.addr(addr),.din(din[i]),.ce(ce),.dout(dout[i])); \n  end \n  endgenerate \n  `else \n  integer i; \n  reg[WIDTH-1 : 0] storage[DEPTH-1 : 0]; \n  assign dout = storage[addr]; \n  initial begin \n  for(i=0; i<DEPTH; i=i+1) \n  storage[i] <= 0; \n  end \n  always @(posedge clk) begin \n  if(ce) begin \n  for(i=DEPTH-1; i>=1; i=i-1) \n  storage[i] <= storage[i-1]; \n  storage[0] <= din; \n  end \n  end \n  `endif \n  `ifdef FORMAL \n  always @(*) begin \n  for(i=0; i<DEPTH; i=i+1) \n  dout_concat[i*WIDTH +: WIDTH] <= storage[DEPTH - i - 1]; \n  end \n  `endif \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a 32-bit lookup table with 32 different outputs, each corresponding to a unique 5-bit address. The module updates the output on every rising edge of the clock signal based on the address input. The stored outputs are accessed by providing the appropriate address.\n\n Module header:\n\nmodule D4_32169(addr, out, clk);\n [/INST]\n", "output": "input clk; \n  output [15:0] out; \n  reg [15:0] out, out2, out3; \n  input [4:0] addr; \n  always @(posedge clk) begin \n  out2 <= out3; \n  out <= out2; \n  case(addr) \n  0: out3 <= 16'h0; \n  1: out3 <= 16'hf9ba; \n  2: out3 <= 16'hf384; \n  3: out3 <= 16'hed6c; \n  4: out3 <= 16'he782; \n  5: out3 <= 16'he1d5; \n  6: out3 <= 16'hdc72; \n  7: out3 <= 16'hd766; \n  8: out3 <= 16'hd2bf; \n  9: out3 <= 16'hce87; \n  10: out3 <= 16'hcac9; \n  11: out3 <= 16'hc78f; \n  12: out3 <= 16'hc4df; \n  13: out3 <= 16'hc2c1; \n  14: out3 <= 16'hc13b; \n  15: out3 <= 16'hc04f; \n  16: out3 <= 16'hc000; \n  17: out3 <= 16'hc04f; \n  18: out3 <= 16'hc13b; \n  19: out3 <= 16'hc2c1; \n  20: out3 <= 16'hc4df; \n  21: out3 <= 16'hc78f; \n  22: out3 <= 16'hcac9; \n  23: out3 <= 16'hce87; \n  24: out3 <= 16'hd2bf; \n  25: out3 <= 16'hd766; \n  26: out3 <= 16'hdc72; \n  27: out3 <= 16'he1d5; \n  28: out3 <= 16'he782; \n  29: out3 <= 16'hed6c; \n  30: out3 <= 16'hf384; \n  31: out3 <= 16'hf9ba; \n  default: out3 <= 0; \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module represents a data interface with input and output signals, including clock and reset signals. It contains registers to buffer input data and input sideband information. The module includes a word counter, logic to generate read and write control signals, and logic for handling the resynchronization of data and sideband information. Additionally, it includes warning messages and a reset mechanism to handle full FIFO behavior. The module instantiates a `resync_fifo_nonsynt` module for resynchronization of data.\n\n Module header:\n\nmodule gtxe2_chnl_rx_dataiface #(parameter internal_data_width = 16,parameter interface_data_width = 32,parameter internal_isk_width = 2,parameter interface_isk_width = 4) (input wire usrclk,input wire usrclk2,input wire reset,output wire [interface_data_width - 1:0] outdata,output wire [interface_isk_width - 1:0] outisk,input wire [internal_data_width - 1:0] indata,input wire [internal_isk_width - 1:0] inisk,input wire realign);\n [/INST]\n", "output": "localparam div = interface_data_width / internal_data_width; \n localparam internal_total_width = internal_data_width + internal_isk_width; \n localparam interface_total_width = interface_data_width + interface_isk_width; \n reg [interface_data_width - 1:0] inbuffer_data; \n reg [interface_isk_width - 1:0] inbuffer_isk; \n reg [31:0] wordcounter; \n wire empty_rd; \n wire full_wr; \n wire val_wr; \n wire val_rd; \n wire almost_empty_rd; \n reg need_reset = 1; \n always @ (posedge usrclk) \n  wordcounter <= reset ? 32'h0 : realign & ~(div == 0) ? 32'd1 : wordcounter == (div - 1) ? 32'h0 : wordcounter + 1'b1; \n genvar ii; \n generate \n for (ii = 0; ii < div; ii = ii + 1) \n begin: splicing \n  always @ (posedge usrclk) \n  inbuffer_data[(ii + 1) * internal_data_width - 1 -: internal_data_width] <= reset ? {internal_data_width{1'b0}} : ((wordcounter == ii) | realign & (0 == ii)) ? indata : inbuffer_data[(ii + 1) * internal_data_width - 1 -: internal_data_width]; \n end \n endgenerate \n generate \n for (ii = 0; ii < div; ii = ii + 1) \n begin: splicing2 \n  always @ (posedge usrclk) \n  inbuffer_isk[(ii + 1) * internal_isk_width - 1 -: internal_isk_width] <= reset ? {internal_isk_width{1'b0}} : ((wordcounter == ii) | realign & (0 == ii)) ? inisk : inbuffer_isk[(ii + 1) * internal_isk_width - 1 -: internal_isk_width]; \n end \n endgenerate \n assign val_rd = ~empty_rd & ~almost_empty_rd; \n assign val_wr = ~full_wr & wordcounter == (div - 1); \n always @ (posedge usrclk) \n  if (reset) need_reset <= 0; \n  else if (full_wr && !need_reset) begin \n  $display(\"2:FIFO in %m is full, that is not an appropriate behaviour, needs reset @%time\", $time); \n  wordcounter = 'bx; \n  need_reset <= 1; \n  end \n wire [interface_total_width - 1:0] resync; \n assign outdata = resync[interface_data_width - 1:0]; \n assign outisk = resync[interface_data_width + interface_isk_width - 1:interface_data_width]; \n wire [interface_total_width - 1:0] data_wr; \n generate \n if (interface_data_width > internal_data_width) \n  assign data_wr = {inisk, inbuffer_isk[interface_isk_width - internal_isk_width - 1 : 0], indata, inbuffer_data[interface_data_width - internal_data_width - 1 : 0]}; \n else \n  assign data_wr = {inisk, indata}; \n endgenerate \n resync_fifo_nonsynt #(.width (interface_total_width),.log_depth (3)) \n fifo(.rst_rd (reset),.rst_wr (reset),.clk_wr (usrclk),.val_wr (val_wr),.data_wr (data_wr),.clk_rd (usrclk2),.val_rd (val_rd),.data_rd (resync),.empty_rd (empty_rd),.full_wr (full_wr),.almost_empty_rd (almost_empty_rd)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a data transmitter that operates based on a state machine. It uses a clock signal to control the data transmission process. The module has an idle state where it waits for an enable signal to start a new transmission. When the transmission starts, it goes through a sequence of states including START, DATA, and STOP, and transmits the data bits accordingly. The module also includes a reset mechanism to initialize the state machine and data transmission process. The output \"tx\" indicates the current state of the transmitter, and \"done\" indicates when the data transmission is complete. The module supports a parameter BITS that determines the number of bits in the data transmission.\n\n Module header:\n\nmodule dataSend #(parameter BITS = 8) (input wire clk, rst, enable,input wire [13:0] q,input wire [7:0] data_i,output reg done,output wire tx);\n [/INST]\n", "output": "localparam [1:0] \n  IDLE = 2'b00, \n  START = 2'b01, \n  DATA = 2'b10, \n  STOP = 2'b11; \n  reg [1:0] state_reg, state_next; \n  reg [2:0] bits_reg, bits_next; \n  reg [7:0] data_reg, data_next; \n  reg tx_reg, tx_next, load_reg; \n  always @(posedge clk, posedge rst) \n  if (rst) \n  begin \n  state_reg <= IDLE; \n  bits_reg <= 3'b0; \n  data_reg <= 7'b0; \n  tx_reg <= 1'b1; \n  end \n  else \n  begin \n  state_reg <= state_next; \n  bits_reg <= bits_next; \n  data_reg <= data_next; \n  tx_reg <= tx_next; \n  end \n  always @(*) \n  begin \n  done = 1'b0; \n  state_next = state_reg; \n  bits_next = bits_reg; \n  data_next = data_reg; \n  tx_next = tx_reg; \n  case (state_reg) \n  IDLE: \n  begin \n  tx_next = 1'b1; \n  if (enable) \n  begin \n  if (q == 14'b0) \n  begin \n  state_next = START; \n  data_next = data_i; \n  end \n  end \n  end \n  START: \n  begin \n  tx_next = 1'b0; \n  if (q == 14'b0) \n  begin \n  state_next = DATA; \n  bits_next = 0; \n  end \n  end \n  DATA: \n  begin \n  tx_next = data_reg[0]; \n  if (q == 14'b0) \n  begin \n  data_next = data_reg >> 1; \n  if (bits_reg == (BITS - 1)) \n  state_next = STOP; \n  else \n  bits_next = bits_reg + 1'b1; \n  end \n  end \n  STOP: \n  begin \n  tx_next = 1'b1; \n  done = 1'b1; \n  if (q == 14'b0) if (~enable) state_next = IDLE; \n  end \n  endcase \n  end \n  assign tx = tx_reg; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"WaitOnInput_ChangeRate_uint8_2_1__from4_to2_H1\" is designed to synchronize input and output operations. It takes input signals like CLK, reset, CE, process_valid, and process_input to produce the output signals ready and process_output. The module also instantiates the \"ChangeRate_uint8_2_1__from4_to2_H1\" module, connecting appropriate parameters and signals. The module includes error message displays and internal wire and reg declarations to handle and synchronize the input and output signals.\n\n Module header:\n\nmodule WaitOnInput_ChangeRate_uint8_2_1__from4_to2_H1(input CLK, output ready, input reset, input CE, input process_valid, input [64:0] process_input, output [32:0] process_output);\n [/INST]\n", "output": "parameter INSTANCE_NAME=\"INST\"; \n always @(posedge CLK) begin if(reset===1'bx) begin $display(\"Valid bit can't be x! Module '%s' function 'reset'\", INSTANCE_NAME); end end \n always @(posedge CLK) begin if(process_valid===1'bx) begin $display(\"Valid bit can't be x! Module '%s' function 'process'\", INSTANCE_NAME); end end \n  wire WaitOnInput_inner_ready; \n  assign ready = WaitOnInput_inner_ready; \n  wire unnamedbinop7657USEDMULTIPLEbinop;assign unnamedbinop7657USEDMULTIPLEbinop = {({({(~WaitOnInput_inner_ready)}||(process_input[64]))}&&process_valid)}; \n  wire [32:0] WaitOnInput_inner_process_output; \n  reg unnamedbinop7657_delay1_validunnamednull0_CECE; always @ (posedge CLK) begin if (CE) begin unnamedbinop7657_delay1_validunnamednull0_CECE <= unnamedbinop7657USEDMULTIPLEbinop; end end \n  assign process_output = {{((WaitOnInput_inner_process_output[32])&&unnamedbinop7657_delay1_validunnamednull0_CECE)},(WaitOnInput_inner_process_output[31:0])}; \n  ChangeRate_uint8_2_1__from4_to2_H1 #(.INSTANCE_NAME({INSTANCE_NAME,\"_WaitOnInput_inner\"})) WaitOnInput_inner(.CLK(CLK), .ready(WaitOnInput_inner_ready), .reset(reset), .CE(CE), .process_valid(unnamedbinop7657USEDMULTIPLEbinop), .process_input((process_input[63:0])), .process_output(WaitOnInput_inner_process_output)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a VGA noise demo that generates and manages VGA signals for audio and visual display. It includes components such as clock manager, binary to BCD converter, counter for incrementation, GPIO initialization, VGA driver for display output, VGA noise generator for visual effects, and a seven-segment multiplexer for displaying BCD values. The module also handles various input and output signals such as clock, color, hsync, vsync, red, green, blue, x, y, audio_l, audio_r, gpio_P1, segments, and anodes.\n\n Module header:\n\nmodule vga_noise_demo(clkin, dips, segments, anodes, hsync, vsync, red, green, blue, audio_l, audio_r, gpio_P1);\n [/INST]\n", "output": "input clkin; \n  input [8:1] dips; \n  output [7:0] segments; \n  output [3:1] anodes; \n  output hsync, vsync; \n  output [2:0] red, green; \n  output [1:0] blue; \n  wire [7:0] color; \n  wire [9:0] x, y; \n  output audio_l, audio_r; \n  output [7:0] gpio_P1; \n  wire [11:0] bcd; \n  wire clk; \n  reg [15:0] cnt; \n clock_mgr dcm (.CLKIN_IN(clkin),.CLKFX_OUT(clk),.CLKIN_IBUFG_OUT(),.CLK0_OUT()); \n binary_to_bcd conv (.binary({4'b0, ~dips}),.bcd(bcd)); \n  always @(posedge clk) cnt <= cnt + 1; \n  assign gpio_P1[0] = cnt[9]; \n  assign gpio_P1[1] = cnt[3]; \n  assign gpio_P1[2] = dips[1]&vsync; \n  assign gpio_P1[7:3] = 5'b00000; \n vga_driver vga (.clk(cnt[2]),.color(color),.hsync(hsync),.vsync(vsync),.red(red),.green(green),.blue(blue),.x(x),.y(y)); \n vga_noise vga_noise(.clk(clk),.color(color),.pause(dips[1]),.vsync(vsync),.hsync(hsync),.style(dips[2]),.test(dips[3]),.audio_l(audio_l),.audio_r(audio_r)); \n seven_segment_mux mux (.clk(cnt[15]),.value({4'b0, bcd}),.dp(3'b000),.segments(segments),.anodes(anodes)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a SPI (Serial Peripheral Interface) Slave that communicates with a master device. It has a reset input (rst_n), clock input (sck), chip select input (cs), and a 32-bit input data (sum). The module also has a single output, miso, which is the data being sent to the master.\n\nThe behavior of the module is determined by an internal state machine that responds to the signals on the input ports. It shifts out the 32-bit input data in response to the clock signal and chip select signal. The shifting is controlled by the state machine and a 5-bit counter, i, which is used to select the bits of the input data to be sent out. When there is no chip select or the module is reset, the output is 0.\n\nOverall, this module implements the functionality of an SPI Slave, which shifts out data to a master device based on clock and chip select signals, and resets the output when necessary.\n\n Module header:\n\nmodule SpiSlave(rst_n, sum, sck, cs, miso);\n [/INST]\n", "output": "input rst_n, sck, cs; \n input [31:0] sum; \n output reg miso; \n reg [4:0] i; \n always @(negedge rst_n or posedge cs or negedge sck) \n begin \n  if (~rst_n) \n  begin \n  miso <= 1'b0; \n  i <= 5'b11111; \n  end \n  else if (cs) \n  begin \n  miso <= 1'b0; \n  i <= 5'b11111; \n  end \n  else \n  begin \n  miso <= sum[i]; \n  i <= i - 5'b1; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe provided Verilog module is a program counter stage for a processor. It utilizes a variety of input signals including ALU instructions, branch information, and predictor outputs to determine the next program counter value. The module contains various multiplexers and a branch predictor to select the next program counter value based on the current program counter, ALU operations, and branch predictions. Additionally, there are components to handle stall conditions and update the program counter accordingly. The module's output includes the updated program counter, a valid signal, and a signal to indicate whether a misprediction has occurred.\n\n Module header:\n\nmodule PROGRAME_COUNTER_STAGE #(parameter ADDRESS_WIDTH = 32 ,parameter DATA_WIDTH = 32 ,parameter ALU_INS_WIDTH = 5 ,parameter PC_INITIAL = 32'b0 ,parameter ALU_JAL = 5'b01110 ,parameter ALU_JALR = 5'b01111 ,parameter HIGH = 1'b1 ,parameter LOW = 1'b0) (input CLK ,input STALL_PROGRAME_COUNTER_STAGE ,input [ALU_INS_WIDTH - 1 : 0] ALU_INSTRUCTION ,input BRANCH_TAKEN ,input [ADDRESS_WIDTH - 1 : 0] PC_EXECUTION ,input [DATA_WIDTH - 1 : 0] RS1_DATA ,input [DATA_WIDTH - 1 : 0] IMM_INPUT ,input [ADDRESS_WIDTH - 1 : 0] PC_DECODING ,output [ADDRESS_WIDTH - 1 : 0] PC ,output PC_VALID ,output PC_MISPREDICT_SELECT);\n [/INST]\n", "output": "reg [ADDRESS_WIDTH - 1 : 0] pc_reg ; \n  reg pc_rs_1_select_reg ; \n  reg pc_predict_select_reg ; \n  reg pc_mispredict_select_reg ; \n  wire pc_predictor_status ; \n  wire [ADDRESS_WIDTH - 1 : 0] pc_predictor_out ; \n  wire [ADDRESS_WIDTH - 1 : 0] pc_execution_or_rs_1 ; \n  wire [ADDRESS_WIDTH - 1 : 0] pc_current_plus_4_or_pc_predicted ; \n  wire [ADDRESS_WIDTH - 1 : 0] pc_next ; \n  initial \n  begin \n  pc_reg = PC_INITIAL ; \n  end \n MULTIPLEXER_2_TO_1 pc_execution_or_rs_1_mux(.IN1(PC_EXECUTION),.IN2(RS1_DATA),.SELECT(pc_rs_1_select_reg),.OUT(pc_execution_or_rs_1)); \n MULTIPLEXER_2_TO_1 pc_current_plus_4_or_pc_predicted_mux(.IN1(pc_reg+4),.IN2(pc_predictor_out),.SELECT(pc_predict_select_reg),.OUT(pc_current_plus_4_or_pc_predicted)); \n MULTIPLEXER_2_TO_1 pc_mispredicted_mux(.IN1(pc_current_plus_4_or_pc_predicted),.IN2($signed(pc_execution_or_rs_1)+$signed(IMM_INPUT)),.SELECT(pc_mispredict_select_reg),.OUT(pc_next)); \n BRANCH_PREDICTOR branch_predictor(.CLK(CLK),.PC(pc_reg),.PC_EXECUTION(PC_EXECUTION),.PC_PREDICT_LEARN(pc_next),.PC_PREDICT_LEARN_SELECT(pc_mispredict_select_reg),.PC_PREDICTED(pc_predictor_out),.PC_PREDICTOR_STATUS(pc_predictor_status)); \n  always@(*) \n  begin \n  if(STALL_PROGRAME_COUNTER_STAGE == LOW) \n  begin \n  if(pc_predictor_status == HIGH) \n  begin \n  pc_predict_select_reg = HIGH; \n  end \n  else \n  begin \n  pc_predict_select_reg = LOW; \n  end \n  if(ALU_INSTRUCTION == ALU_JALR) \n  begin \n  pc_rs_1_select_reg = HIGH; \n  end \n  else \n  begin \n  pc_rs_1_select_reg = LOW; \n  end \n  if((ALU_INSTRUCTION == ALU_JAL)|(ALU_INSTRUCTION == ALU_JALR)|(BRANCH_TAKEN == HIGH)) \n  begin \n  if($signed(pc_execution_or_rs_1) + $signed(IMM_INPUT) != $signed(PC_DECODING)) \n  begin \n  pc_mispredict_select_reg = HIGH; \n  end \n  else \n  begin \n  pc_mispredict_select_reg = LOW; \n  end \n  end \n  else \n  begin \n  pc_mispredict_select_reg = LOW; \n  end \n  end \n  end \n  always@(posedge CLK) \n  begin \n  if(STALL_PROGRAME_COUNTER_STAGE == LOW) \n  begin \n  pc_reg <= pc_next ; \n  end \n  end \n  assign PC = pc_reg ; \n  assign PC_VALID = HIGH ; \n  assign PC_MISPREDICT_SELECT = pc_mispredict_select_reg ; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a high-level digital signal processing (DSP) function that includes rounding, accumulation, and output. It processes the input data_in with a series of computations, including adding coefficients, accumulating partial sums, and rounding the final result. The output data_out is generated with optional bypass functionality, and the strobe signal stb_out is determined based on the bypass control and the internal rounding process. The module includes several submodules for specific functionalities such as rounding and multiplication. The computation and control logic in the module are synchronized with the clock signal and managed by the reset and run signals.\n\n Module header:\n\nmodule small_hb_dec #(parameter WIDTH=18) (input clk,input rst,input bypass,input run,input stb_in,input [WIDTH-1:0] data_in,output reg stb_out,output reg [WIDTH-1:0] data_out);\n [/INST]\n", "output": "localparam INTWIDTH = 17; \n  wire [INTWIDTH-1:0] data_rnd; \n  wire stb_rnd; \n  round_sd #(.WIDTH_IN(WIDTH),.WIDTH_OUT(INTWIDTH)) round_in \n  (.clk(clk),.reset(rst),.in(data_in),.strobe_in(stb_in),.out(data_rnd),.strobe_out(stb_rnd)); \n  reg stb_rnd_d1; \n  reg [INTWIDTH-1:0] data_rnd_d1; \n  always @(posedge clk) stb_rnd_d1 <= stb_rnd; \n  always @(posedge clk) data_rnd_d1 <= data_rnd; \n  wire go; \n  reg phase, go_d1, go_d2, go_d3, go_d4; \n  always @(posedge clk) \n  if(rst | ~run) \n  phase <= 0; \n  else if(stb_rnd_d1) \n  phase <= ~phase; \n  assign go = stb_rnd_d1 & phase; \n  always @(posedge clk) \n  if(rst | ~run) \n  begin \n  go_d1 <= 0; \n  go_d2 <= 0; \n  go_d3 <= 0; \n  go_d4 <= 0; \n  end \n  else \n  begin \n  go_d1 <= go; \n  go_d2 <= go_d1; \n  go_d3 <= go_d2; \n  go_d4 <= go_d3; \n  end \n  wire [17:0] coeff_a = -10690; \n  wire [17:0] coeff_b = 75809; \n  reg [INTWIDTH-1:0] d1, d2, d3, d4 , d5, d6; \n  always @(posedge clk) \n  if(stb_rnd_d1 | rst) \n  begin \n  d1 <= data_rnd_d1; \n  d2 <= d1; \n  d3 <= d2; \n  d4 <= d3; \n  d5 <= d4; \n  d6 <= d5; \n  end \n  reg [17:0] sum_a, sum_b, middle, middle_d1; \n  always @(posedge clk) \n  if(go) \n  begin \n  sum_a <= {data_rnd_d1[INTWIDTH-1],data_rnd_d1} + {d6[INTWIDTH-1],d6}; \n  sum_b <= {d2[INTWIDTH-1],d2} + {d4[INTWIDTH-1],d4}; \n  middle <= {d3,1'b0}; \n  end \n  always @(posedge clk) \n  if(go_d1) \n  middle_d1 <= middle; \n  wire [17:0] sum = go_d1 ? sum_b : sum_a; \n  wire [17:0] coeff = go_d1 ? coeff_b : coeff_a; \n  wire [35:0] prod; \n  MULT18X18S mult(.C(clk), .CE(go_d1 | go_d2), .R(rst), .P(prod), .A(coeff), .B(sum) ); \n  localparam ACCWIDTH = 30; \n  reg [ACCWIDTH-1:0] accum; \n  always @(posedge clk) \n  if(rst) \n  accum <= 0; \n  else if(go_d2) \n  accum <= {middle_d1[17],middle_d1[17],middle_d1,{(16+ACCWIDTH-36){1'b0}}} + {prod[35:36-ACCWIDTH]}; \n  else if(go_d3) \n  accum <= accum + {prod[35:36-ACCWIDTH]}; \n  wire [WIDTH:0] accum_rnd; \n  wire [WIDTH-1:0] accum_rnd_clip; \n  wire stb_round; \n  round_sd #(.WIDTH_IN(ACCWIDTH),.WIDTH_OUT(WIDTH+1)) round_acc \n  (.clk(clk), .reset(rst), .in(accum), .strobe_in(go_d4), .out(accum_rnd), .strobe_out(stb_round)); \n  clip #(.bits_in(WIDTH+1),.bits_out(WIDTH)) clip (.in(accum_rnd), .out(accum_rnd_clip)); \n  always @(posedge clk) \n  begin \n  stb_out <= bypass ? stb_in : stb_round; \n  data_out <= bypass ? data_in : accum_rnd_clip; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module is a modem controller with inputs for reset, clock, modem control signals, and modem status read signal, and outputs for modem status and modem control signals. It updates the modem status register based on the control and status signals and the modem status read signal. It also sets the modem control signals based on the modem control register. The module also includes logic for handling reset and updating the modem status register based on various conditions.\n\n Module header:\n\nmodule modem #(parameter WB_DAT_WIDTH = 8) (input reset,input clk,output [WB_DAT_WIDTH-1:0] msr,input [1:0] mcr,input msr_rd,input dcd_n,input cts_n,input dsr_n,input ri_n,output dtr_n,output rts_n);\n [/INST]\n", "output": "reg [WB_DAT_WIDTH-1:0] msr_reg; \n  reg ctsn_d1; \n  reg dsrn_d1; \n  reg dcdn_d1; \n  reg rin_d1; \n  assign dtr_n = ~mcr[0]; \n  assign rts_n = ~mcr[1]; \n  assign msr = msr_reg; \n  always @(posedge clk or posedge reset) begin \n  if (reset) begin \n  msr_reg <= 0; \n  ctsn_d1 <= 1'b1; \n  dsrn_d1 <= 1'b1; \n  dcdn_d1 <= 1'b1; \n  rin_d1 <= 1'b1; \n  end \n  else begin \n  ctsn_d1 <= cts_n; \n  dsrn_d1 <= dsr_n; \n  dcdn_d1 <= dcd_n; \n  rin_d1 <= ri_n ; \n  if (msr_rd) \n  msr_reg <= 0; \n  else begin \n  msr_reg[0] <= msr_reg[0] | (ctsn_d1 ^ cts_n); \n  msr_reg[1] <= msr_reg[1] | (dsrn_d1 ^ dsr_n); \n  msr_reg[2] <= msr_reg[2] | (~rin_d1 & ri_n ); \n  msr_reg[3] <= msr_reg[3] | (dcdn_d1 ^ dcd_n); \n  msr_reg[4] <= !cts_n; \n  msr_reg[5] <= !dsr_n; \n  msr_reg[6] <= !ri_n ; \n  msr_reg[7] <= !dcd_n; \n  end \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a music player that outputs music to a speaker based on an input clock signal. It uses counters and dividers to generate the appropriate tone frequencies and toggles the speaker output accordingly. The module also includes a music ROM and a clock divider to control the timing of the music notes.\n\n Module header:\n\nmodule Music (input wire clk,output reg speaker);\n [/INST]\n", "output": "wire [7:0] fullnote; \n  wire [2:0] octave; \n  wire [3:0] note; \n  reg [30:0] tone; \n  reg [8:0] clkdivider; \n  reg [8:0] counter_note; \n  reg [7:0] counter_octave; \n music_rom my_music_rom (.clk(clk),.address(tone[30:22]),.note(fullnote)); \n divide_by12 my_divide_by12 (.numerator(fullnote[5:0]),.quotient(octave),.remainder(note)); \n  always @(posedge clk) \n  tone <= tone+31'd1; \n  always @* \n  case(note) \n  0: clkdivider = 9'd511; \n  1: clkdivider = 9'd482; \n  2: clkdivider = 9'd455; \n  3: clkdivider = 9'd430; \n  4: clkdivider = 9'd405; \n  5: clkdivider = 9'd383; \n  6: clkdivider = 9'd361; \n  7: clkdivider = 9'd341; \n  8: clkdivider = 9'd322; \n  9: clkdivider = 9'd303; \n  10: clkdivider = 9'd286; \n  11: clkdivider = 9'd270; \n  default: clkdivider = 9'd0; \n  endcase \n  always @(posedge clk) counter_note <= (counter_note==0 ? clkdivider : counter_note-9'd1); \n  always @(posedge clk) if(counter_note==0) counter_octave <= (counter_octave==0 ? 8'd255 >> octave : counter_octave-8'd1); \n  always @(posedge clk) if(counter_note==0 && counter_octave==0 && fullnote!=0 && tone[21:18]!=0) speaker <= ~speaker; \n  endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a VGA controller that generates the signals required for displaying images on a VGA monitor. It takes input signals for color information (iRGB), clock (Clock25), and reset (Reset), and outputs signals for horizontal and vertical synchronization (H_Sync, V_Sync), color information (oRGB), and horizontal and vertical position (Cont_X, Cont_Y). The module uses counters to keep track of the horizontal and vertical positions, and it implements logic to determine the color output based on the position and input color information. It also checks for the MARCO region to make sure the color output is within the display resolution.\n\n Module header:\n\nmodule VGA_Controller_Josue (Clock25, Reset, iRGB, H_Sync, V_Sync, oRGB, Cont_X, Cont_Y);\n [/INST]\n", "output": "input wire Clock25, Reset; \n  input wire [2:0] iRGB; \n  output wire H_Sync, V_Sync; \n  output wire [2:0] oRGB; \n  output wire [9:0] Cont_X, Cont_Y; \n localparam RGB_MARCO = 3'b0; \n localparam MARCO_X = 48; \n localparam MARCO_Y = 32; \n localparam MARCO = 3'b0; \n localparam RESOL_X = 256; \n localparam RESOL_Y = 256; \n localparam NUM_CUADROS_X = 16; \n localparam NUM_CUADROS_Y = 16; \n wire iR, iG, iB; \n wire oR, oG, oB; \n wire [2:0] wMarco; \n wire [2:0] wColorSelectionVGA; \n assign wColorSelectionVGA = {iR, iG, iB}; \n assign iR = iRGB[2]; \n assign iG = iRGB[1]; \n assign iB = iRGB[0]; \n assign oRGB = {oR, oG, oB}; \n assign H_Sync = (Cont_X < 704) ? 1'b1 : 1'b0; \n assign V_Sync = (Cont_Y < 519) ? 1'b1 : 1'b0; \n assign {oR, oG, oB} = (Cont_Y < MARCO_Y || Cont_Y >= RESOL_Y+MARCO_Y ||Cont_X < MARCO_X || Cont_X > RESOL_X+MARCO_X) ? \n  MARCO : wColorSelectionVGA; \n UPCOUNTER_POSEDGE # (10) HORIZONTAL_COUNTER \n (.Clock ( Clock25 ),.Reset ( (Cont_X > 799) || Reset ),.Initial ( 10'b0 ),.Enable ( 1'b1 ),.Q ( Cont_X )); \n UPCOUNTER_POSEDGE # (10) VERTICAL_COUNTER \n (.Clock ( Clock25 ),.Reset ( (Cont_Y > 520) || Reset ),.Initial ( 10'b0 ),.Enable ( (Cont_X == 799) ? 1'b1:1'b0 ),.Q ( Cont_Y )); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module IMUL2 takes two 16-bit input numbers iSourceData0 and iSourceData1, and outputs a 32-bit result oResult. It performs a multiplication operation using a series of MUX4X1 modules to select the appropriate shifted values of iSourceData0, and then combines these shifted values to compute the final result. The oResult is calculated as the sum of oMux1 and the shifted values of oMux2, oMux3, oMux4, oMux5, oMux6, oMux7, and oMux8.\n\n Module header:\n\nmodule IMUL2 (input wire [15:0] iSourceData0, iSourceData1,output reg [31:0] oResult);\n [/INST]\n", "output": "wire [31:0] oMux1, oMux2, oMux3, oMux4, oMux5, oMux6,oMux7,oMux8; \n wire [31:0]cero, uno, dos, tres; \n assign cero = 0; \n assign uno = iSourceData0; \n assign dos = iSourceData0<<1; \n assign tres = (iSourceData0<<1) + iSourceData0; \n MUX4X1 Mux1(.iInput0(cero),.iInput1(uno),.iInput2(dos),.iInput3(tres),.iSelect({iSourceData1[1], iSourceData1[0]}),.oOutput(oMux1)); \n MUX4X1 Mux2(.iInput0(cero),.iInput1(uno),.iInput2(dos),.iInput3(tres),.iSelect({iSourceData1[3], iSourceData1[2]}),.oOutput(oMux2)); \n MUX4X1 Mux3(.iInput0(cero),.iInput1(uno),.iInput2(dos),.iInput3(tres),.iSelect({iSourceData1[5], iSourceData1[4]}),.oOutput(oMux3)); \n MUX4X1 Mux4(.iInput0(cero),.iInput1(uno),.iInput2(dos),.iInput3(tres),.iSelect({iSourceData1[7], iSourceData1[6]}),.oOutput(oMux4)); \n MUX4X1 Mux5(.iInput0(cero),.iInput1(uno),.iInput2(dos),.iInput3(tres),.iSelect({iSourceData1[9], iSourceData1[8]}),.oOutput(oMux5)); \n MUX4X1 Mux6(.iInput0(cero),.iInput1(uno),.iInput2(dos),.iInput3(tres),.iSelect({iSourceData1[11], iSourceData1[10]}),.oOutput(oMux6)); \n MUX4X1 Mux7(.iInput0(cero),.iInput1(uno),.iInput2(dos),.iInput3(tres),.iSelect({iSourceData1[13], iSourceData1[12]}),.oOutput(oMux7)); \n MUX4X1 Mux8(.iInput0(cero),.iInput1(uno),.iInput2(dos),.iInput3(tres),.iSelect({iSourceData1[15], iSourceData1[14]}),.oOutput(oMux8)); \n always @(*) begin \n oResult = oMux1 +(oMux2<<2)+ (oMux3<<4) + (oMux4<<6) + (oMux5<<8) + (oMux6<<10) + (oMux7<<12) +(oMux8<<14); \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a termination logic for a specific hardware device. It handles input signals such as serialloadenable, terminationclock, parallelloadenable, terminationdata, devclrn, and devpor, and generates output signals seriesterminationcontrol and parallelterminationcontrol. The module includes a shift register and a parallel load mechanism, and it utilizes clock signals usr_clk, shift_clk, and pload_clk to control the data flow and synchronization. The module also includes tri-state buffers for devclrn and devpor signals. The output_reg and shift_reg registers are updated on the rising edges of the respective clock signals. Overall, the module manages the termination control signals based on the input data and clock signals.\n\n Module header:\n\nmodule arriaiigz_termination_logic (serialloadenable,terminationclock,parallelloadenable,terminationdata,devclrn,devpor,seriesterminationcontrol,parallelterminationcontrol);\n [/INST]\n", "output": "parameter test_mode = \"false\"; \n parameter lpm_type = \"arriaiigz_termination_logic\"; \n input serialloadenable; \n input terminationclock; \n input parallelloadenable; \n input terminationdata; \n input devclrn; \n input devpor; \n output [13:0] seriesterminationcontrol; \n output [13:0] parallelterminationcontrol; \n tri1 devclrn; \n tri1 devpor; \n wire usr_clk; \n wire shift_clk; \n wire pload_clk; \n reg [27:0] shift_reg; \n reg [27:0] output_reg; \n assign seriesterminationcontrol = output_reg[27:14]; \n assign parallelterminationcontrol = output_reg[13:0]; \n assign #11 usr_clk = terminationclock; \n assign shift_clk = (serialloadenable === 1'b0) ? 1'b0 : usr_clk; \n assign pload_clk = (parallelloadenable === 1'b1) ? 1'b1 : 1'b0; \n initial begin \n  shift_reg = 'b0; \n  output_reg = 'b0; \n end \n always @(posedge shift_clk) \n  shift_reg <= {shift_reg[26:0], terminationdata}; \n always @(posedge pload_clk) \n  output_reg <= shift_reg; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a hardware description of a circuit with various input and output ports. It includes conditional compilation for data latches and delay logic. The module implements various connections and assignments for signals such as clock signals, address lines, control signals, and data buses. The module also includes conditional logic for handling data latches for both input and output data. Additionally, it includes logic for signal synchronization and control signal generation based on the inputs. The module is designed to interface with a CPU and a memory unit, as well as manage various control signals for communication and data flow.\n\n Module header:\n\nmodule level1b_mk2_m (input [15:0] cpu_adr,input resetb,input cpu_vpb,input cpu_e,input cpu_vda,input cpu_vpa,input bbc_phi0,input hsclk,input cpu_rnw,inout [7:0] cpu_data,inout [7:0] bbc_data,inout [5:0] gpio,inout rdy,inout nmib,inout irqb,output lat_en,output ram_web,output ram_ceb,output ram_oeb,output ram_adr18,output ram_adr17,output ram_adr16,output bbc_sync,output [15:8] bbc_adr,output bbc_rnw,output bbc_phi1,output bbc_phi2,output cpu_phi2);\n [/INST]\n", "output": "`ifdef USE_DATA_LATCHES_BBC2CPU \n  reg [7:0] bbc_data_lat_q; \n `endif \n `ifdef USE_DATA_LATCHES_CPU2BBC \n  reg [7:0] cpu_data_lat_q; \n `endif \n  (* KEEP=\"TRUE\" *) wire ckdel_1_b; \n  (* KEEP=\"TRUE\" *) wire ckdel_2; \n  (* KEEP=\"TRUE\" *) wire ckdel_3_b; \n  (* KEEP=\"TRUE\" *) wire ckdel_4; \n  (* KEEP=\"TRUE\" *) wire ckdel_5_b; \n  (* KEEP=\"TRUE\" *) wire ckdel_6; \n  INV ckdel1 ( .I(bbc_phi0), .O(ckdel_1_b)); \n  INV ckdel2 ( .I(ckdel_1_b), .O(ckdel_2)); \n  INV ckdel3 ( .I(ckdel_2), .O(ckdel_3_b)); \n  INV ckdel4 ( .I(ckdel_3_b), .O(ckdel_4)); \n  INV ckdel5 ( .I(ckdel_4), .O(ckdel_5_b)); \n  INV ckdel6 ( .I(ckdel_5_b), .O(ckdel_6)); \n `ifdef DELAY1 \n  assign bbc_phi1 = ckdel_1_b; \n  assign bbc_phi2 = ckdel_2; \n `endif \n `ifdef DELAY2 \n  assign bbc_phi1 = ckdel_3_b; \n  assign bbc_phi2 = ckdel_4; \n `endif \n `ifdef DELAY3 \n  assign bbc_phi1 = ckdel_5_b; \n  assign bbc_phi2 = ckdel_6; \n `endif \n  assign cpu_phi2 = bbc_phi2; \n  assign bbc_sync = cpu_vpa & cpu_vda; \n  assign rdy = 1'bz; \n  assign irqb = 1'bz; \n  assign nmib = 1'bz; \n  assign { ram_adr16, ram_adr17, ram_adr18, gpio[2], gpio[1]} = 0 ; \n  assign { ram_ceb, gpio[0], ram_web} = 3'b111; \n  assign lat_en = 1'b1; \n  assign bbc_adr = cpu_adr[15:8]; \n  assign bbc_rnw = cpu_rnw ; \n  assign gpio[5] = ( !cpu_rnw & bbc_phi2); \n  assign gpio[4] = ( cpu_rnw & cpu_phi2); \n `ifdef USE_DATA_LATCHES_CPU2BBC \n  assign bbc_data = ( !cpu_rnw & bbc_phi2) ? cpu_data_lat_q : { 8{1'bz}}; \n `else \n  assign bbc_data = ( !cpu_rnw & bbc_phi2) ? cpu_data : { 8{1'bz}}; \n `endif \n `ifdef USE_DATA_LATCHES_BBC2CPU \n  assign cpu_data = ( cpu_rnw & cpu_phi2 ) ? bbc_data_lat_q : {8{1'bz}}; \n `else \n  assign cpu_data = ( cpu_rnw & cpu_phi2 ) ? bbc_data : {8{1'bz}}; \n `endif \n `ifdef USE_DATA_LATCHES_BBC2CPU \n  always @ ( * ) \n  if ( bbc_phi2 ) \n  bbc_data_lat_q <= bbc_data; \n `endif \n `ifdef USE_DATA_LATCHES_CPU2BBC \n  always @ ( * ) \n  if ( cpu_phi2 ) \n  cpu_data_lat_q <= cpu_data; \n `endif \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is for controlling a robot with a multiplication operation. It has a parameter WIDTH for configuring the bit width of the multiplier and multiplicand inputs. It instantiates a control unit micro and a datapath. The control unit micro generates control signals based on inputs and the datapath performs the actual multiplication operation. The module also zero-extends the multiplicand input and outputs the product and a done signal.\n\n Module header:\n\nmodule robsmult #(parameter WIDTH = 8) (input clk,input reset,input [WIDTH-1:0] multiplier,input [WIDTH-1:0] multiplicand,output [WIDTH*2-1:0] product,output done);\n [/INST]\n", "output": "wire c0, c1, c2, c3, c9, c10, c5, c8, c12, c14, c13, c4, c6, c7, c11; \n  wire zq, zy, zr; \n  robs_control_unit_micro cu(clk, reset, zq, zy, zr, c0, c1, c2, c3, c9, c10, c5, c8, c12, c14, c13, c4, c6, c7, c11, done); \n  robs_datapath dp(clk, reset, multiplier, multiplicand, c0, c1, c2, c3, c9, c10, c5, c8, c12, c14, c13, c4, c6, c7, c11, product, zq, zr); \n  assign zy = ~multiplicand[WIDTH-1]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `LEDSample` consists of a 5-bit register `r_count` that increments by 1 on the positive edge of the clock when the `rst_x` signal is asserted. When `rst_x` is negated, `r_count` is reset to 0. The output `o_dp` is set to the value of the least significant bit of `r_count` ANDed with the negation of `rst_x`. Additionally, the module instantiates another module `SevenSegmentLED` with its input connected to the 4 most significant bits of `r_count`, and the outputs `o_a` to `o_g` are assigned accordingly.\n\n Module header:\n\nmodule LEDSample(clk,rst_x,o_a,o_b,o_c,o_d,o_e,o_f,o_g,o_dp);\n [/INST]\n", "output": "input clk; \n  input rst_x; \n  output o_a; \n  output o_b; \n  output o_c; \n  output o_d; \n  output o_e; \n  output o_f; \n  output o_g; \n  output o_dp; \n  reg [4:0] r_count; \n  assign o_dp = r_count[0] & rst_x; \n  always @ (posedge clk or negedge rst_x) begin \n  if (!rst_x) begin \n  r_count <= 5'h00; \n  end else begin \n  r_count <= r_count + 5'h01; \n  end \n  end \n SevenSegmentLED led(.i_data(r_count[4:1]),.o_a (o_a ),.o_b (o_b ),.o_c (o_c ),.o_d (o_d ),.o_e (o_e ),.o_f (o_f ),.o_g (o_g )); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a state machine to control the communication between different parts of a system. It uses the input signals `CLK`, `sndRec`, `BUSY`, and `RxData` to control the output signals `SS`, `getByte`, and `DOUT`. The state machine moves through different states based on the inputs, controlling the output signals and transitioning between states based on specific conditions. The module effectively manages the transfer of data and the control of the system based on the state machine's logic.\n\n Module header:\n\nmodule joy_control(input CLK,input sndRec,input BUSY,input [7:0] RxData,output SS,output reg getByte,output reg [39:0] DOUT);\n [/INST]\n", "output": "reg SS = 1; \n reg [2:0] pState = 0; \n reg [2:0] byteCnt = 0; \n reg [39:0] tmpSR = 0; \n always @(negedge CLK) \n begin \n  case(pState) \n  0 : begin \n  SS <= 1; \n  getByte <= 0; \n  tmpSR <= 0; \n  byteCnt <= 0; \n  pState <= sndRec ? 1 : 0; \n  end \n  1 : begin \n  SS <= 0; \n  getByte <= 1; \n  if(BUSY) \n  begin \n  pState <= 2; \n  byteCnt <= byteCnt + 1; \n  end \n  else \n  pState <= 1; \n  end \n  2 : begin \n  SS <= 0; \n  getByte <= 0; \n  pState <= BUSY ? 2 : 3; \n  end \n  3 : begin \n  SS <= 0; \n  getByte <= 0; \n  tmpSR <= {tmpSR[31:0], RxData}; \n  pState <= byteCnt == 5 ? 4 : 1; \n  end \n  4 : begin \n  SS <= 1; \n  getByte <= 0; \n  DOUT[39:0] <= tmpSR[39:0]; \n  pState <= sndRec ? 4 : 0; \n  end \n  endcase \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements an asynchronous comparator with configurable depth and parameters. It maintains pointers and signals for read and write operations, as well as full and empty conditions. The module also incorporates reset and clock signals for read and write operations. The logic within the module is designed to handle various asynchronous and synchronous conditions for maintaining the state of the comparator.\n\n Module header:\n\nmodule async_cmp #(parameter C_DEPTH_BITS = 4,parameter N = C_DEPTH_BITS-1) (input WR_RST,input WR_CLK,input RD_RST,input RD_CLK,input RD_VALID,input WR_VALID,output EMPTY,output FULL,input [C_DEPTH_BITS-1:0] WR_PTR,input [C_DEPTH_BITS-1:0] RD_PTR,input [C_DEPTH_BITS-1:0] WR_PTR_P1,input [C_DEPTH_BITS-1:0] RD_PTR_P1);\n [/INST]\n", "output": "reg rDir=0; \n wire wDirSet = ( (WR_PTR[N]^RD_PTR[N-1]) & ~(WR_PTR[N-1]^RD_PTR[N])); \n wire wDirClr = ((~(WR_PTR[N]^RD_PTR[N-1]) & (WR_PTR[N-1]^RD_PTR[N])) | WR_RST); \n reg rRdValid=0; \n reg rEmpty=1; \n reg rFull=0; \n wire wATBEmpty = ((WR_PTR == RD_PTR_P1) && (RD_VALID | rRdValid)); \n wire wATBFull = ((WR_PTR_P1 == RD_PTR) && WR_VALID); \n wire wEmpty = ((WR_PTR == RD_PTR) && !rDir); \n wire wFull = ((WR_PTR == RD_PTR) && rDir); \n assign EMPTY = wATBEmpty || rEmpty; \n assign FULL = wATBFull || rFull; \n always @(posedge wDirSet or posedge wDirClr) \n if (wDirClr) \n  rDir <= 1'b0; \n else \n  rDir <= 1'b1; \n always @(posedge RD_CLK) begin \n  rEmpty <= (RD_RST ? 1'd1 : wEmpty); \n  rRdValid <= (RD_RST ? 1'd0 : RD_VALID); \n end \n always @(posedge WR_CLK) begin \n  rFull <= (WR_RST ? 1'd0 : wFull); \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a controller with multiple inputs and outputs. It monitors various control signals to determine the state of the system. It uses the input signals to control the dos, in_trdemu, and trdemu_wr_disable outputs based on the current state and specific conditions. The module responds to different input conditions by setting the dos, in_trdemu, and trdemu_wr_disable outputs accordingly, with consideration for the fclk clock signal and reset conditions.\n\n Module header:\n\nmodule zdos(input wire fclk,input wire rst_n,input wire dos_turn_on,input wire dos_turn_off,input wire cpm_n,output reg dos,input wire zpos,input wire m1_n,output reg in_trdemu,input wire clr_nmi,input wire vg_rdwr_fclk,input wire [ 3:0] fdd_mask,input wire [ 1:0] vg_a,input wire romnram,output reg trdemu_wr_disable);\n [/INST]\n", "output": "wire trdemu_on = vg_rdwr_fclk && fdd_mask[vg_a] && dos && romnram; \n  always @(posedge fclk, negedge rst_n) \n  if( !rst_n ) \n  begin \n  dos = 1'b1; \n  end \n  else \n  begin \n  if( !cpm_n ) \n  dos <= 1'b1; \n  else if( dos_turn_off ) \n  dos <= 1'b0; \n  else if( dos_turn_on ) \n  dos <= 1'b1; \n  end \n  always @(posedge fclk, negedge rst_n) \n  if( !rst_n ) \n  in_trdemu <= 1'b0; \n  else if( clr_nmi ) \n  in_trdemu <= 1'b0; \n  else if( trdemu_on ) \n  in_trdemu <= 1'b1; \n  always @(posedge fclk, negedge rst_n) \n  if( !rst_n ) \n  trdemu_wr_disable <= 1'b0; \n  else if( zpos && !m1_n ) \n  trdemu_wr_disable <= 1'b0; \n  else if( trdemu_on ) \n  trdemu_wr_disable <= 1'b1; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a clock module with multiple outputs and a phase-locked loop (PLL) for clock generation and synchronization. It takes a global clock input and provides user and synchronization clock outputs. The PLL_ADV instance generates multiple clock outputs with configurable dividers. The module also includes logic to handle clock locking and feedback, ensuring stable clock generation. The output signals indicate the status of the PLL lock and provide the user and synchronized clock outputs.\n\n Module header:\n\nmodule aur1_CLOCK_MODULE # (parameter MULT = 2,parameter DIVIDE = 1,parameter CLK_PERIOD = 3.2,parameter OUT0_DIVIDE = 4,parameter OUT1_DIVIDE = 2,parameter OUT2_DIVIDE = 4,parameter OUT3_DIVIDE = 2) (GT_CLK,GT_CLK_LOCKED,USER_CLK,SYNC_CLK,PLL_NOT_LOCKED);\n [/INST]\n", "output": "`define DLY #1 \n  input GT_CLK; \n  input GT_CLK_LOCKED; \n  output USER_CLK; \n  output SYNC_CLK; \n  output PLL_NOT_LOCKED; \n  wire clkfb_w; \n  wire clkout0_o; \n  wire clkout1_o; \n  wire clkout2_o; \n  wire clkout3_o; \n  wire locked_w; \n  PLL_ADV # \n (.CLKFBOUT_MULT (MULT),.DIVCLK_DIVIDE (DIVIDE),.CLKFBOUT_PHASE (0),.CLKIN1_PERIOD (CLK_PERIOD),.CLKIN2_PERIOD (10),.CLKOUT0_DIVIDE (OUT0_DIVIDE),.CLKOUT0_PHASE (0),.CLKOUT1_DIVIDE (OUT1_DIVIDE),.CLKOUT1_PHASE (0),.CLKOUT2_DIVIDE (OUT2_DIVIDE),.CLKOUT2_PHASE (0),.CLKOUT3_DIVIDE (OUT3_DIVIDE),.CLKOUT3_PHASE (0)) \n  pll_adv_i \n (.CLKIN1 (GT_CLK),.CLKIN2 (1'b0),.CLKINSEL (1'b1),.CLKFBIN (clkfb_w),.CLKOUT0 (clkout0_o),.CLKOUT1 (clkout1_o),.CLKOUT2 (clkout2_o),.CLKOUT3 (clkout3_o),.CLKOUT4 (),.CLKOUT5 (),.CLKFBOUT (clkfb_w),.CLKFBDCM (),.CLKOUTDCM0 (),.CLKOUTDCM1 (),.CLKOUTDCM2 (),.CLKOUTDCM3 (),.CLKOUTDCM4 (),.CLKOUTDCM5 (),.DO (),.DRDY (),.DADDR (5'd0),.DCLK (1'b0),.DEN (1'b0),.DI (16'd0),.DWE (1'b0),.REL (1'b0),.LOCKED (locked_w),.RST (!GT_CLK_LOCKED)); \n  assign PLL_NOT_LOCKED = ~locked_w; \n  BUFG user_clk_net_i \n (.I(clkout0_o),.O(USER_CLK)); \n  BUFG sync_clk_net_i \n (.I(clkout1_o),.O(SYNC_CLK)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module implements a synchronous 2-stage shift register, where the input i is stored in stage_1 on the rising edge of the clock, and the previous value of stage_1 is assigned to the output o.\n\n Module header:\n\nmodule synch_2 #(parameter WIDTH = 1) (input wire [WIDTH-1:0] i,output reg [WIDTH-1:0] o,input wire clk);\n [/INST]\n", "output": "reg [WIDTH-1:0] stage_1; \n always @(posedge clk) \n  {o, stage_1} <= {stage_1, i}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, named \"td\", consists of an always block triggered by the \"vconst\" input. When \"vconst\" changes, the \"q\" output is assigned the value of \"vconst\". This module essentially passes the value of \"vconst\" to \"q\" whenever \"vconst\" changes.\n\n Module header:\n\nmodule td (input vconst,input b,output reg q);\n [/INST]\n", "output": "always @ (vconst) begin \n  q = vconst; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a flip-flop with asynchronous set and reset, as well as additional control inputs for a specific application. The input D is the data input, while SCD and SCE are control inputs. The flip-flop output is denoted by Q and its complement by Q_N.\n\nThe module includes delay elements for inputs and clock, as well as additional control signals for set, reset, and power. It also has conditional checks and a notifier register for specific conditions. The module also includes a multiplexer, a domain crossing input, and a power gate for specific power control.\n\nAdditionally, the module contains conditional checks based on the control inputs and power status, which are used to control the behavior of the flip-flop. The module also includes buffering and inversion logic for the Q and Q_N outputs.\n\n Module header:\n\nmodule sky130_fd_sc_hs__sdfbbp (Q ,Q_N ,D ,SCD ,SCE ,CLK ,SET_B ,RESET_B,VPWR ,VGND);\n [/INST]\n", "output": "output Q ; \n  output Q_N ; \n  input D ; \n  input SCD ; \n  input SCE ; \n  input CLK ; \n  input SET_B ; \n  input RESET_B; \n  input VPWR ; \n  input VGND ; \n  wire RESET ; \n  wire SET ; \n  wire buf_Q ; \n  reg notifier ; \n  wire D_delayed ; \n  wire SCD_delayed ; \n  wire SCE_delayed ; \n  wire CLK_delayed ; \n  wire SET_B_delayed ; \n  wire RESET_B_delayed; \n  wire mux_out ; \n  wire awake ; \n  wire cond0 ; \n  wire cond1 ; \n  wire condb ; \n  wire cond_D ; \n  wire cond_SCD ; \n  wire cond_SCE ; \n  not not0 (RESET , RESET_B_delayed ); \n  not not1 (SET , SET_B_delayed ); \n  sky130_fd_sc_hs__u_mux_2_1 u_mux_20 (mux_out, D_delayed, SCD_delayed, SCE_delayed ); \n  sky130_fd_sc_hs__u_dfb_setdom_notify_pg u_dfb_setdom_notify_pg0 (buf_Q , SET, RESET, CLK_delayed, mux_out, notifier, VPWR, VGND); \n  assign awake = ( VPWR === 1'b1 ); \n  assign cond0 = ( awake && ( RESET_B_delayed === 1'b1 ) ); \n  assign cond1 = ( awake && ( SET_B_delayed === 1'b1 ) ); \n  assign condb = ( cond0 & cond1 ); \n  assign cond_D = ( ( SCE_delayed === 1'b0 ) && condb ); \n  assign cond_SCD = ( ( SCE_delayed === 1'b1 ) && condb ); \n  assign cond_SCE = ( ( D_delayed !== SCD_delayed ) && condb ); \n  buf buf0 (Q , buf_Q ); \n  not not2 (Q_N , buf_Q ); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes Y, Cb, and Cr color components and converts them to RGB format. It uses three Multiply-Accumulate (MAC) units to perform the color space transformation. The inputs are synchronized to the clock signal, and the output RGB values are updated accordingly. The module also handles data validity and reset conditions. Overall, it implements the YCbCr to RGB color space conversion algorithm.\n\n Module header:\n\nmodule YCbCr2RGB (iY,iCb,iCr,Red,Green,Blue,oDVAL,iDVAL,iRESET,iCLK);\n [/INST]\n", "output": "input [7:0] iY,iCb,iCr; \n input iDVAL,iRESET,iCLK; \n output [9:0] Red,Green,Blue; \n output reg oDVAL; \n reg [9:0] oRed,oGreen,oBlue; \n reg [3:0] oDVAL_d; \n reg [19:0] X_OUT,Y_OUT,Z_OUT; \n wire [26:0] X,Y,Z; \n assign Red = oRed; \n assign Green= oGreen; \n assign Blue = oBlue; \n always@(posedge iCLK) \n begin \n  if(iRESET) \n  begin \n  oDVAL<=0; \n  oDVAL_d<=0; \n  oRed<=0; \n  oGreen<=0; \n  oBlue<=0; \n  end \n  else \n  begin \n  if(X_OUT[19]) \n  oRed<=0; \n  else if(X_OUT[18:0]>1023) \n  oRed<=1023; \n  else \n  oRed<=X_OUT[9:0]; \n  if(Y_OUT[19]) \n  oGreen<=0; \n  else if(Y_OUT[18:0]>1023) \n  oGreen<=1023; \n  else \n  oGreen<=Y_OUT[9:0]; \n  if(Z_OUT[19]) \n  oBlue<=0; \n  else if(Z_OUT[18:0]>1023) \n  oBlue<=1023; \n  else \n  oBlue<=Z_OUT[9:0]; \n  {oDVAL,oDVAL_d}<={oDVAL_d,iDVAL}; \n  end \n end \n always@(posedge iCLK) \n begin \n  if(iRESET) \n  begin \n  X_OUT<=0; \n  Y_OUT<=0; \n  Z_OUT<=0; \n  end \n  else \n  begin \n  X_OUT<=( X - 114131 ) >>7; \n  Y_OUT<=( Y + 69370 ) >>7; \n  Z_OUT<=( Z - 141787 ) >>7; \n  end \n end \n MAC_3 u0( iY, iCb, iCr,17'h00254, 17'h00000, 17'h00331,X, iRESET, iCLK); \n MAC_3 u1( iY, iCb, iCr,17'h00254, 17'h3FF38, 17'h3FE60,Y, iRESET, iCLK); \n MAC_3 u2( iY, iCb, iCr,17'h00254, 17'h00409, 17'h00000,Z, iRESET, iCLK); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an ACL FP Log Alt Priority Encoder. It takes a 4-bit input data and produces a 2-bit output q. Inside the module, it instantiates two 3-to-7 alt priority encoders for processing the input data. The output from these encoders and an additional wire are then used to determine the final output q using a logical operation.\n\n Module header:\n\nmodule acl_fp_log_altpriority_encoder_6v7 (data,q) ;\n [/INST]\n", "output": "input [3:0] data; \n  output [1:0] q; \n  wire [0:0] wire_altpriority_encoder14_q; \n  wire [0:0] wire_altpriority_encoder15_q; \n  wire wire_altpriority_encoder15_zero; \n  acl_fp_log_altpriority_encoder_3v7 altpriority_encoder14 \n (.data(data[1:0]),.q(wire_altpriority_encoder14_q)); \n  acl_fp_log_altpriority_encoder_3e8 altpriority_encoder15 \n (.data(data[3:2]),.q(wire_altpriority_encoder15_q),.zero(wire_altpriority_encoder15_zero)); \n  assign \n  q = {(~ wire_altpriority_encoder15_zero), ((wire_altpriority_encoder15_zero & wire_altpriority_encoder14_q) | ((~ wire_altpriority_encoder15_zero) & wire_altpriority_encoder15_q))}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, named N1Z000, has a single output O, which is assigned a constant value of 0.\n\n Module header:\n\nmodule N1Z000( O );\n [/INST]\n", "output": "output O; \n assign O = 1'b0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module represents a compliance test circuit for PCI Express. It includes logic to handle compliance mode, delta-sigma modulator counter, and reset signals. The module uses the reference clock, reset signals, and various input signals to control compliance mode and cycle counts. It also contains logic to synchronize and handle the reset signals. The module generates test input and output signals based on the input conditions and control signals.\n\n Module header:\n\nmodule altpcierd_compliance_test (input local_rstn,input pcie_rstn,input refclk,input req_compliance_push_button_n,input req_compliance_soft_ctrl ,input set_compliance_mode,output test_in_5_hip,output test_in_32_hip);\n [/INST]\n", "output": "wire rstn; \n wire exit_ltssm_compliance; \n wire new_edge_for_compliance; \n reg [2:0] ltssm_cnt_cycles; \n reg [15:0] dbc_cnt; \n assign test_in_5_hip = (set_compliance_mode==1'b0) ? 1'b1 : exit_ltssm_compliance; \n assign test_in_32_hip= set_compliance_mode; \n assign exit_ltssm_compliance = ltssm_cnt_cycles[2]; \n always @(posedge refclk or negedge rstn) begin \n  if (rstn == 1'b0) begin \n  ltssm_cnt_cycles <= 3'b000; \n  end \n  else begin \n  if (new_edge_for_compliance==1'b1) begin \n  ltssm_cnt_cycles <= 3'b111; \n  end \n  else if (ltssm_cnt_cycles != 3'b000) begin \n  ltssm_cnt_cycles <= ltssm_cnt_cycles - 3'b001; \n  end \n  end \n end \n reg req_compliance_cycle,req_compliance_cycle_r, req_compliance_soft_ctrl_r; \n always @(posedge refclk or negedge rstn) begin \n  if (rstn == 1'b0) begin \n  req_compliance_cycle <= 1'b1; \n  req_compliance_cycle_r <= 1'b1; \n  req_compliance_soft_ctrl_r <= 1'b1; \n  end \n  else begin \n  req_compliance_cycle <= (dbc_cnt == 16'h0000) ? 1'b0: 1'b1; \n  req_compliance_cycle_r <= req_compliance_cycle; \n  req_compliance_soft_ctrl_r <= req_compliance_soft_ctrl; \n  end \n end \n assign new_edge_for_compliance = (((req_compliance_cycle_r == 1'b1)&(req_compliance_cycle == 1'b0))||((req_compliance_soft_ctrl_r == 1'b0)&(req_compliance_soft_ctrl == 1'b1))) ?1'b1:1'b0; \n always @(posedge refclk or negedge rstn) begin \n  if (rstn == 1'b0) begin \n  dbc_cnt <= 16'hFFFF; \n  end \n  else begin \n  if (req_compliance_push_button_n == 0) begin \n  dbc_cnt <= 16'hFFFF; \n  end \n  else if (dbc_cnt != 16'h0000) begin \n  dbc_cnt <= dbc_cnt -16'h1; \n  end \n  end \n end \n wire npor ; \n reg [2:0] rstn_sync; \n assign npor = pcie_rstn & local_rstn; \n always @(posedge refclk or negedge npor) begin \n  if (npor == 1'b0) begin \n  rstn_sync[2:0] <= 3'b000; \n  end \n  else begin \n  rstn_sync[0] <= 1'b1; \n  rstn_sync[1] <= rstn_sync[0]; \n  rstn_sync[2] <= rstn_sync[1]; \n  end \n end \n assign rstn = rstn_sync[2]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module replicates SCData signals by directly assigning input signals to their corresponding output signals. Each input signal is connected to its respective output signal, without any logical or arithmetic operations. This effectively replicates the input signals to the output signals without any alteration in functionality.\n\n Module header:\n\nmodule scdata_rep(sctag_scdata_col_offset_c2_buf, sctag_scdata_fb_hit_c3_buf,sctag_scdata_fbrd_c3_buf, sctag_scdata_rd_wr_c2_buf,sctag_scdata_set_c2_buf, sctag_scdata_stdecc_c2_buf,sctag_scdata_way_sel_c2_buf, sctag_scdata_word_en_c2_buf,scdata_sctag_decc_c6,sctag_scdata_col_offset_c2, sctag_scdata_fb_hit_c3,sctag_scdata_fbrd_c3, sctag_scdata_rd_wr_c2, sctag_scdata_set_c2,sctag_scdata_stdecc_c2, sctag_scdata_way_sel_c2,sctag_scdata_word_en_c2, scdata_sctag_decc_c6_ctr);\n [/INST]\n", "output": "input [3:0] sctag_scdata_col_offset_c2; \n  input sctag_scdata_fb_hit_c3; \n  input sctag_scdata_fbrd_c3; \n  input sctag_scdata_rd_wr_c2; \n  input [9:0] sctag_scdata_set_c2; \n  input [77:0] sctag_scdata_stdecc_c2; \n  input [11:0] sctag_scdata_way_sel_c2; \n  input [15:0] sctag_scdata_word_en_c2; \n  input [155:0] scdata_sctag_decc_c6_ctr; \n  output [3:0] sctag_scdata_col_offset_c2_buf; \n  output sctag_scdata_fb_hit_c3_buf; \n  output sctag_scdata_fbrd_c3_buf; \n  output sctag_scdata_rd_wr_c2_buf; \n  output [9:0] sctag_scdata_set_c2_buf; \n  output [77:0] sctag_scdata_stdecc_c2_buf; \n  output [11:0] sctag_scdata_way_sel_c2_buf; \n  output [15:0] sctag_scdata_word_en_c2_buf; \n  output [155:0] scdata_sctag_decc_c6; \n  assign sctag_scdata_col_offset_c2_buf = sctag_scdata_col_offset_c2; \n  assign sctag_scdata_fb_hit_c3_buf = sctag_scdata_fb_hit_c3; \n  assign sctag_scdata_fbrd_c3_buf = sctag_scdata_fbrd_c3; \n  assign sctag_scdata_rd_wr_c2_buf = sctag_scdata_rd_wr_c2; \n  assign sctag_scdata_set_c2_buf = sctag_scdata_set_c2; \n  assign sctag_scdata_stdecc_c2_buf = sctag_scdata_stdecc_c2; \n  assign sctag_scdata_way_sel_c2_buf = sctag_scdata_way_sel_c2; \n  assign sctag_scdata_word_en_c2_buf = sctag_scdata_word_en_c2; \n  assign scdata_sctag_decc_c6 = scdata_sctag_decc_c6_ctr; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a 4-port register file with one read and one write port. It has two clock inputs for reading and writing. The read and write addresses are 2-bit wide. The data input for writing is 64 bits wide. It also has a write enable signal. The module stores the previous write address, data input, and write enable using flip-flops. It decodes the write address to select the appropriate line for writing. It also decodes the write enable to enable the selected line for writing. For reading, it selects the output data based on the read address. If no match is found, it outputs 'x' for all bits.\n\n Module header:\n\nmodule iobdg_1r1w_rf4 (dout,rd_clk, wr_clk, rd_a, wr_a, din, wen_l);\n [/INST]\n", "output": "parameter REG_WIDTH = 64; \n  input rd_clk; \n  input wr_clk; \n  input [1:0] rd_a; \n  input [1:0] wr_a; \n  input [REG_WIDTH-1:0] din; \n  input wen_l; \n  output [REG_WIDTH-1:0] dout; \n  wire [1:0] wr_a_d1; \n  wire [REG_WIDTH-1:0] din_d1; \n  wire wen_l_d1; \n  wire [3:0] wr_a_dec_d1; \n  wire [3:0] wen_dec_d1; \n  wire [REG_WIDTH-1:0] line0; \n  wire [REG_WIDTH-1:0] line1; \n  wire [REG_WIDTH-1:0] line2; \n  wire [REG_WIDTH-1:0] line3; \n  wire [1:0] rd_a_d1; \n  reg [REG_WIDTH-1:0] dout; \n dff_ns #(2) wr_a_d1_ff (.din(wr_a),.clk(wr_clk),.q(wr_a_d1)); \n dff_ns #(REG_WIDTH) din_d1_ff (.din(din),.clk(wr_clk),.q(din_d1)); \n dff_ns #(1) wen_l_d1_ff (.din(wen_l),.clk(wr_clk),.q(wen_l_d1)); \n  assign wr_a_dec_d1 = 1'b1 << wr_a_d1; \n  assign wen_dec_d1 = {4{~wen_l_d1}} & wr_a_dec_d1; \n  dffe_ns #(REG_WIDTH) line0_ff (.din(din_d1),.en(wen_dec_d1[0]),.clk(wr_clk),.q(line0)); \n  dffe_ns #(REG_WIDTH) line1_ff (.din(din_d1),.en(wen_dec_d1[1]),.clk(wr_clk),.q(line1)); \n  dffe_ns #(REG_WIDTH) line2_ff (.din(din_d1),.en(wen_dec_d1[2]),.clk(wr_clk),.q(line2)); \n  dffe_ns #(REG_WIDTH) line3_ff (.din(din_d1),.en(wen_dec_d1[3]),.clk(wr_clk),.q(line3)); \n dff_ns #(2) rd_a_d1_ff (.din(rd_a),.clk(rd_clk),.q(rd_a_d1)); \n  always @(line0 or line1 or line2 or line3 or rd_a_d1) begin \n  case (rd_a_d1) \n  2'd0: dout = line0; \n  2'd1: dout = line1; \n  2'd2: dout = line2; \n  2'd3: dout = line3; \n  default: dout = {REG_WIDTH{1'bx}}; \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `VCC` represents a voltage source that outputs a constant voltage level of 1.\n\n Module header:\n\nmodule VCC(output V);\n [/INST]\n", "output": "assign V = 1; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements an input buffer with configurable I/O parameters such as I/O standard, location, bus hold, weak pull-up resistor, and termination. It directly assigns the input to the output, effectively buffering the input signal.\n\n Module header:\n\nmodule alt_inbuf (i, o);\n [/INST]\n", "output": "input i; \n  output o; \n  parameter io_standard = \"NONE\"; \n  parameter location = \"NONE\"; \n  parameter enable_bus_hold = \"NONE\"; \n  parameter weak_pull_up_resistor = \"NONE\"; \n  parameter termination = \"NONE\"; \n  parameter lpm_type = \"alt_inbuf\"; \n  assign o = i; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a traffic light controller with two output signals, MainStreet and SideStreet. The module has five states S0 to S4, each representing a different combination of MainStreet and SideStreet signals. The state transition logic is based on the input x and the current state. The controller operates on a clock signal and is reset by the clear input. Depending on the state, the MainStreet and SideStreet signals are set to different combinations of the RED, YELLOW, and GREEN light states.\n\n Module header:\n\nmodule TrafficLight(input x, clock, clear,output reg [1:0] MainStreet, SideStreet);\n [/INST]\n", "output": "localparam S0 = 3'd0; \n localparam S1 = 3'd1; \n localparam S2 = 3'd2; \n localparam S3 = 3'd3; \n localparam S4 = 3'd4; \n localparam RED = 2'd0; \n localparam YELLOW = 2'd1; \n localparam GREEN = 2'd2; \n reg [2:0] state, next_state; \n always @(posedge clock) \n begin \n  if (clear) \n  state <= S0; \n  else \n  state <= next_state; \n end \n always @(posedge clock) \n begin \n  if (clear) begin \n  MainStreet <= GREEN; \n  SideStreet <= RED; \n  end else begin \n  case (next_state) \n  S4: begin \n  MainStreet <= RED; \n  SideStreet <= YELLOW; \n  end \n  S3: begin \n  MainStreet <= RED; \n  SideStreet <= GREEN; \n  end \n  S2: begin \n  MainStreet <= RED; \n  SideStreet <= RED; \n  end \n  S1: begin \n  MainStreet <= YELLOW; \n  SideStreet <= RED; \n  end \n  default: begin \n  MainStreet <= GREEN; \n  SideStreet <= RED; \n  end \n  endcase \n  end \n end \n always @(*) \n begin \n  case (state) \n  S0: \n  if (x) \n  next_state = S1; \n  else \n  next_state = S0; \n  S1: next_state = S2; \n  S2: next_state = S3; \n  S3: \n  if (x) \n  next_state = S3; \n  else \n  next_state = S4; \n  default: next_state = S0; \n  endcase \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module represents a D flip-flop with asynchronous preset and clear signals. The D flip-flop operates on the positive edge of the clock signal and updates its output Q based on the input D. The SET_B and RESET_B inputs control the asynchronous preset and clear functions, respectively. The module also includes internal logic to handle delayed versions of the clock and control signals, ensuring proper operation. The outputs Q and Q_N represent the normal and inverted outputs of the flip-flop, respectively.\n\n Module header:\n\nmodule sky130_fd_sc_ls__dfbbp (Q ,Q_N ,D ,CLK ,SET_B ,RESET_B);\n [/INST]\n", "output": "output Q ; \n  output Q_N ; \n  input D ; \n  input CLK ; \n  input SET_B ; \n  input RESET_B; \n  supply1 VPWR; \n  supply0 VGND; \n  supply1 VPB ; \n  supply0 VNB ; \n  wire RESET ; \n  wire SET ; \n  wire buf_Q ; \n  wire CLK_delayed ; \n  wire RESET_B_delayed; \n  wire SET_B_delayed ; \n  reg notifier ; \n  wire D_delayed ; \n  wire awake ; \n  wire cond0 ; \n  wire cond1 ; \n  wire condb ; \n  not not0 (RESET , RESET_B_delayed ); \n  not not1 (SET , SET_B_delayed ); \n  sky130_fd_sc_ls__udp_dff$NSR_pp$PG$N dff0 (buf_Q , SET, RESET, CLK_delayed, D_delayed, notifier, VPWR, VGND); \n  assign awake = ( VPWR === 1'b1 ); \n  assign cond0 = ( awake && ( RESET_B_delayed === 1'b1 ) ); \n  assign cond1 = ( awake && ( SET_B_delayed === 1'b1 ) ); \n  assign condb = ( cond0 & cond1 ); \n  buf buf0 (Q , buf_Q ); \n  not not2 (Q_N , buf_Q ); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module `select2_8` takes two 8-bit inputs `in1` and `in2`, and a single-bit control signal `choose`. It uses a case statement to select between the two inputs based on the value of `choose` and assigns the selected input to the output `out`. If `choose` is 0, the output `out` will be equal to `in1`. If `choose` is 1, the output `out` will be equal to `in2`. If `choose` is neither 0 nor 1, the output `out` will be all zeroes.\n\n Module header:\n\nmodule select2_8(input [7:0] in1,input [7:0] in2,input choose,output reg [7:0] out);\n [/INST]\n", "output": "always@(in1 or in2 or choose) \n case(choose) \n 1'b0:out=in1; \n 1'b1:out=in2; \n default:out=8'b0; \n endcase \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module `RAT_xlconstant_0_0` implements a 10-bit output buffer that outputs a constant value. The constant value is assigned to each bit of the output buffer `dout`, and the constant value is also connected to the `VCC` power supply pin.\n\n Module header:\n\nmodule RAT_xlconstant_0_0 (dout);\n [/INST]\n", "output": "output [9:0]dout; \n  wire \\<const1> ; \n  assign dout[9] = \\<const1> ; \n  assign dout[8] = \\<const1> ; \n  assign dout[7] = \\<const1> ; \n  assign dout[6] = \\<const1> ; \n  assign dout[5] = \\<const1> ; \n  assign dout[4] = \\<const1> ; \n  assign dout[3] = \\<const1> ; \n  assign dout[2] = \\<const1> ; \n  assign dout[1] = \\<const1> ; \n  assign dout[0] = \\<const1> ; \n  VCC VCC \n  (.P(\\<const1> )); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is designed to interface with a Wishbone bus. It handles the input and output signals for LEDs, switches, push buttons, and a non-maskable interrupt (NMI) push button. The module also contains logic to detect NMI pulses and generate NMI signals based on the push button inputs. The module's functionality includes updating the LED outputs based on the Wishbone signals and handling the NMI push button inputs to generate NMI signals.\n\n Module header:\n\nmodule sw_leds (input wb_clk_i,input wb_rst_i,input wb_adr_i,output [15:0] wb_dat_o,input [15:0] wb_dat_i,input [ 1:0] wb_sel_i,input wb_we_i,input wb_stb_i,input wb_cyc_i,output wb_ack_o,output reg [13:0] leds_,input [ 7:0] sw_,input pb_,input tick,output reg nmi_pb);\n [/INST]\n", "output": "wire op; \n  reg tick_old; \n  reg tick1; \n  reg nmi_pb_pressed; \n  reg [2:0] nmi_cnt; \n  assign op = wb_cyc_i & wb_stb_i; \n  assign wb_ack_o = op; \n  assign wb_dat_o = wb_adr_i ? { 2'b00, leds_ } \n  : { 8'h00, sw_ }; \n  always @(posedge wb_clk_i) \n  leds_ <= wb_rst_i ? 14'h0 \n  : ((op & wb_we_i & wb_adr_i) ? wb_dat_i[13:0] : leds_); \n  always @(posedge wb_clk_i) \n  begin \n  tick_old <= tick; \n  tick1 <= tick & ~tick_old; \n  end \n  always @(posedge wb_clk_i) \n  nmi_pb_pressed <= !pb_; \n  always @(posedge wb_clk_i) \n  begin \n  if (wb_rst_i) \n  begin \n  nmi_pb <= 1'b0; \n  nmi_cnt <= 3'b111; \n  end \n  else \n  begin \n  if (nmi_cnt == 3'b111) \n  begin \n  if (nmi_pb_pressed != nmi_pb) \n  begin \n  nmi_pb <= nmi_pb_pressed; \n  nmi_cnt <= nmi_cnt + 3'b001; \n  end \n  end \n  else if (tick1) \n  nmi_cnt <= nmi_cnt + 3'b001; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a control interface for a minimac2 device. It includes various registers and logic to handle control signals and data communication with the device. The module interfaces with a system clock, reset, input and output data, and various control signals. It also includes logic for managing the MII data, system and PHY resets, slot states, and interrupt signals. The module has logic to handle various control register operations based on the input signals and system states. Overall, this module serves as the interface for controlling and communicating with the minimac2 device.\n\n Module header:\n\nmodule minimac2_ctlif #(parameter csr_addr = 4'h0) (input sys_clk,input sys_rst,input [13:0] csr_a,input csr_we,input [31:0] csr_di,output reg [31:0] csr_do,output irq_rx,output irq_tx,output [1:0] rx_ready,input [1:0] rx_done,input [10:0] rx_count_0,input [10:0] rx_count_1,output tx_start,input tx_done,output reg [10:0] tx_count,output reg phy_mii_clk,inout phy_mii_data,output phy_rst_n);\n [/INST]\n", "output": "reg mii_data_oe; \n reg mii_data_do; \n assign phy_mii_data = mii_data_oe ? mii_data_do : 1'bz; \n reg mii_data_di1; \n reg mii_data_di; \n always @(posedge sys_clk) begin \n  mii_data_di1 <= phy_mii_data; \n  mii_data_di <= mii_data_di1; \n end \n reg phy_rst; \n assign phy_rst_n = ~(phy_rst | sys_rst); \n reg [1:0] slot0_state; \n reg [1:0] slot1_state; \n wire csr_selected = csr_a[13:10] == csr_addr; \n always @(posedge sys_clk) begin \n  if(sys_rst) begin \n  csr_do <= 32'd0; \n  phy_rst <= 1'b1; \n  mii_data_oe <= 1'b0; \n  mii_data_do <= 1'b0; \n  phy_mii_clk <= 1'b0; \n  phy_rst <= 1'b0; \n  slot0_state <= 2'b00; \n  slot1_state <= 2'b00; \n  tx_count <= 11'd0; \n  end else begin \n  csr_do <= 32'd0; \n  if(csr_selected) begin \n  if(csr_we) begin \n  case(csr_a[2:0]) \n  3'd0: phy_rst <= csr_di[0]; \n  3'd1: begin \n  phy_mii_clk <= csr_di[3]; \n  mii_data_oe <= csr_di[2]; \n  mii_data_do <= csr_di[0]; \n  end \n  3'd2: slot0_state <= csr_di[1:0]; \n  3'd4: slot1_state <= csr_di[1:0]; \n  3'd6: tx_count <= csr_di[10:0]; \n  endcase \n  end \n  case(csr_a[2:0]) \n  3'd0: csr_do <= phy_rst; \n  3'd1: csr_do <= {phy_mii_clk, mii_data_oe, mii_data_di, mii_data_do}; \n  3'd2: csr_do <= slot0_state; \n  3'd3: csr_do <= rx_count_0; \n  3'd4: csr_do <= slot1_state; \n  3'd5: csr_do <= rx_count_1; \n  3'd6: csr_do <= tx_count; \n  endcase \n  end \n  if(rx_done[0]) \n  slot0_state <= 2'b10; \n  if(rx_done[1]) \n  slot1_state <= 2'b10; \n  if(tx_done) \n  tx_count <= 11'd0; \n  end \n end \n wire [1:0] slots_loaded = {slot1_state[0], slot0_state[0]}; \n reg [1:0] slots_loaded_r; \n always @(posedge sys_clk) \n  slots_loaded_r <= slots_loaded; \n assign rx_ready = slots_loaded & ~slots_loaded_r; \n wire tx_remaining = |tx_count; \n reg tx_remaining_r; \n always @(posedge sys_clk) \n  tx_remaining_r <= tx_remaining; \n assign tx_start = tx_remaining & ~tx_remaining_r; \n assign irq_rx = slot0_state[1] | slot1_state[1]; \n assign irq_tx = tx_done; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is designed to calculate the wait time based on the inputs of work, reset, and the clock signal. When the reset signal is low, the wait time is set to 0 and the internal counter 'i' is reset. If the work input is 0, the module increments the wait time every 4 clock cycles until work becomes non-zero. The wait time is stored in a 12-bit register and is updated based on the clock signal and reset condition.\n\n Module header:\n\nmodule wait_time_module (reset, work, clk, wait_time);\n [/INST]\n", "output": "input clk,work,reset; \n output [11:0] wait_time; \n reg [11:0] wait_time; \n reg [5:0] i; \n always @ (posedge clk or negedge reset) \n begin \n  if(!reset) \n  begin \n  wait_time <= 0; \n  i <= 0; \n  end \n  else if (work == 0) \n  begin \n  if(i >= 4) \n  begin \n  wait_time <= wait_time +1; \n  i <= 0; \n  end \n  else i <= i+1; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module controls the power management of a system. It sets signals based on various conditions such as reset, wakeup requests, sleep requests, and transitions to wake. It manages signals such as isolation, reset, sleep, system activity, and wakeup requests. The module also uses the clock signal to synchronize its operations.\n\n Module header:\n\nmodule SLEEP_CONTROLv4 (output reg MBC_ISOLATE,output MBC_ISOLATE_B,output reg MBC_RESET,output MBC_RESET_B,output MBC_SLEEP,output MBC_SLEEP_B,output SYSTEM_ACTIVE,output WAKEUP_REQ_ORED,input CLK,input MBUS_DIN,input RESETn,input SLEEP_REQ,input WAKEUP_REQ0,input WAKEUP_REQ1,input WAKEUP_REQ2);\n [/INST]\n", "output": "reg set_tran_to_wake; \n  reg rst_tran_to_wake; \n  assign MBC_ISOLATE_B = ~MBC_ISOLATE; \n  assign MBC_RESET_B = ~MBC_RESET; \n  reg MBC_SLEEP_int; \n  assign MBC_SLEEP_B = ~MBC_SLEEP; \n  reg tran_to_wake; \n  assign SYSTEM_ACTIVE = MBC_SLEEP_B | MBC_ISOLATE_B; \n  assign WAKEUP_REQ_ORED = WAKEUP_REQ0 | WAKEUP_REQ1 | WAKEUP_REQ2; \n  always @ * \n  begin \n  if (RESETn & ( WAKEUP_REQ_ORED | ( MBC_SLEEP_int & ~MBUS_DIN ))) \n  set_tran_to_wake = 1'b1; \n  else \n  set_tran_to_wake = 1'b0; \n  end \n  always @ * \n  begin \n  if ((~RESETn) | ( WAKEUP_REQ_ORED | (MBC_SLEEP_int & ~MBUS_DIN) | ~SLEEP_REQ )) \n  rst_tran_to_wake <= 1'b1; \n  else \n  rst_tran_to_wake <= 1'b0; \n  end \n  wire tran_to_wake_r = RESETn & rst_tran_to_wake; \n  always @ (negedge tran_to_wake_r or posedge set_tran_to_wake) \n  begin \n  if (~tran_to_wake_r) \n  tran_to_wake <= 1'b0; \n  else \n  tran_to_wake <= 1'b1; \n  end \n  always @ ( negedge RESETn or posedge CLK ) \n  begin \n  if( ~RESETn ) \n  MBC_ISOLATE <= 1'b1; \n  else \n  MBC_ISOLATE <= (MBC_SLEEP_int | (~tran_to_wake)); \n  end \n  always @ ( negedge RESETn or posedge CLK ) \n  begin \n  if( ~RESETn ) \n  MBC_SLEEP_int <= 1'b1; \n  else \n  MBC_SLEEP_int <= (MBC_ISOLATE & (~tran_to_wake)); \n  end \n  assign MBC_SLEEP = MBC_SLEEP_int & ~ (WAKEUP_REQ_ORED | (MBC_SLEEP_int & ~MBUS_DIN) ); \n  always @ ( negedge RESETn or posedge CLK ) \n  begin \n  if( ~RESETn ) \n  MBC_RESET <= 1'b1; \n  else \n  MBC_RESET <= MBC_ISOLATE; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module performs arithmetic operations based on the value of the op input. If op is 0, it performs addition using the inputs x and y, and if op is 1, it performs subtraction. The resulting 4-bit output is stored in the result register. The addition and subtraction operations are carried out using ripple-carry adder and ripple-carry subtractor respectively, and the results are stored in addnum and subnum wires. The output result is then set based on the value of the op input using an always block.\n\n Module header:\n\nmodule operation(op, x, y, result);\n [/INST]\n", "output": "input op; \n  input [2:0] x; \n  input [2:0] y; \n  output reg [3:0] result; \n  wire [3:0] addnum; \n  wire [3:0] subnum; \n  ripple3add(x, y, addnum); \n  ripple3sub(x, y, subnum[2:0]); \n  always @(op) \n  if (op == 0) \n  result = addnum; \n  else \n  result = subnum; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a mask operation on input signals to generate output signals. It uses the system clock and reset to control the output pipeline handshake signals. The module sets the output `pipe_stb_o` to 1'b1 when both input `pipe_stb_i` and `pipe_ack_o` are asserted. The module then performs bitwise AND operations on the input signals `dx`, `dy`, `tx`, and `ty` with `tex_hmask` and `tex_vmask` to generate the output signals `dx_f`, `dy_f`, `tx_m`, and `ty_m` respectively. The `pipe_ack_o` signal is assigned as the negation of the OR condition of `pipe_stb_o` and `pipe_ack_i`. The `busy` output is directly assigned to the value of `pipe_stb_o`.\n\n Module header:\n\nmodule tmu2_mask(input sys_clk,input sys_rst,output busy,input pipe_stb_i,output pipe_ack_o,input signed [11:0] dx,input signed [11:0] dy,input signed [17:0] tx,input signed [17:0] ty,input [17:0] tex_hmask,input [17:0] tex_vmask,output reg pipe_stb_o,input pipe_ack_i,output reg signed [11:0] dx_f,output reg signed [11:0] dy_f,output reg signed [17:0] tx_m,output reg signed [17:0] ty_m);\n [/INST]\n", "output": "always @(posedge sys_clk) begin \n  if(sys_rst) \n  pipe_stb_o <= 1'b0; \n  else begin \n  if(pipe_ack_i) \n  pipe_stb_o <= 1'b0; \n  if(pipe_stb_i & pipe_ack_o) begin \n  pipe_stb_o <= 1'b1; \n  dx_f <= dx; \n  dy_f <= dy; \n  tx_m <= tx & tex_hmask; \n  ty_m <= ty & tex_vmask; \n  end \n  end \n end \n assign pipe_ack_o = ~pipe_stb_o | pipe_ack_i; \n assign busy = pipe_stb_o; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a MIPS coprocessor 0 with multiple registers and functionality. It has registers for EPC, Bad Address, Cause, Status, and interrupt handling. The module includes logic for reading and writing these registers based on the input addresses and control signals. It also handles clock edge detection and reset functionality. Overall, it simulates the behavior of the coprocessor 0 in a MIPS processor.\n\n Module header:\n\nmodule mips_cop0 (input clk,input rst,input[4:0] rd_addr,output[31:0] rd_data,output[31:0] rd_epc,output rd_int,output rd_status_exl,input[4:0] wr_addr,input wr_en,input[31:0] wr_data,input wr_status_exl_reset,input wr_status_exl_set,input wr_cause_en,input wr_cause_bd,input[5:0] wr_cause_int,input[3:0] wr_cause_excode,input wr_badvaddr_en,input[31:0] wr_badvaddr_data);\n [/INST]\n", "output": "reg[31:0] epc; \n  reg[31:0] badvaddr; \n  reg cause_bd; \n  reg[5:0] cause_ip; \n  reg[3:0] cause_excode; \n  reg[5:0] status_im; \n  reg status_exl; \n  reg status_ie; \n  assign rd_epc= epc; \n  assign rd_status_exl= status_exl; \n  assign rd_data= rd_addr==5'd14 ? epc : \n  rd_addr==5'd13 ? {cause_bd,15'd0, \n  cause_ip,4'd0, \n  cause_excode,2'd0} : \n  rd_addr==5'd8 ? badvaddr : \n  {16'd0, \n  status_im, \n  8'd0, \n  status_exl, \n  status_ie}; \n  assign rd_int= |(cause_ip & status_im) & status_ie & !status_exl; \n  always @(posedge clk) \n  if(rst) \n  begin \n  epc<= 32'd0; \n  cause_bd<= 1'b0; \n  cause_ip<= 6'd0; \n  cause_excode<= 4'd0; \n  status_im<= 6'd0; \n  status_exl<= 1'b1; \n  status_ie<= 1'b0; \n  badvaddr<= 32'd0; \n  end \n  else \n  begin \n  epc<= wr_en & wr_addr==5'd14 ? wr_data : epc; \n  cause_bd<= wr_cause_en ? wr_cause_bd : cause_bd; \n  cause_ip<= wr_cause_int; \n  cause_excode<= wr_cause_en ? wr_cause_excode : \n  cause_excode; \n  status_im<= wr_en & wr_addr==5'd12 ? wr_data[15:10] : status_im; \n  status_exl<= wr_status_exl_reset ? 1'b0 : \n  wr_status_exl_set ? 1'b1 : \n  wr_en & wr_addr==5'd12 ? wr_data[1] : status_exl; \n  status_ie<= wr_en & wr_addr==5'd12 ? wr_data[0] : status_ie; \n  badvaddr<= wr_badvaddr_en ? wr_badvaddr_data : badvaddr; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a test memory module that instantiates a dataMemory module. It includes inputs for clock, address, write data, memory write enable, and memory read enable, and an output for read data. The clock signal is toggled every 100 time units, and initial values are set for the address, write data, memory write enable, and memory read enable. After a delay of 185 time units, the address is changed, followed by a write data value and the memory write enable being set to 1 after 250 time units. Then, the memory read enable is set to 1 after 200 time units, and the memory write enable is finally set to 0 after this.\n\n Module header:\n\nmodule test_mem;\n [/INST]\n", "output": "reg clock_in; \n  reg [31:0] address; \n  reg [31:0] writeData; \n  reg memWrite; \n  reg memRead; \n  wire [31:0] readData; \n dataMemory uut (.clock_in(clock_in),.address(address),.writeData(writeData),.readData(readData),.memWrite(memWrite),.memRead(memRead)); \n  always #100 clock_in = ~clock_in; \n  initial begin \n  clock_in = 0; \n  address = 0; \n  writeData = 0; \n  memWrite = 0; \n  memRead = 0; \n  #185; \n  address = 32'b00000000000000000000000000001111; \n  writeData= 32'b00000000000000001111111111111111; \n  #250; \n  memWrite = 1; \n  #200; \n  memRead = 1; \n  memWrite= 0; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module 't' contains registers and wires to control clock signals, data, and wires for holding constant values. It initializes a counter, sets values for various signals, and combines multiple wires into a single wire. The 'always' blocks trigger on the positive edge of the clock and control the values of the registers based on the counter 'cyc'. It also writes output to the console based on certain conditions. The module has 'always' blocks triggered by the positive edge of 'gendlyclk_r' and 'genblkclk' as well. These blocks also set values and write outputs to the console. The module has certain condition checks and stops the simulation if the conditions are not met.\n\n Module header:\n\nmodule t (clk);\n [/INST]\n", "output": "input clk; \n  integer cyc; initial cyc=1; \n  reg gendlyclk_r; \n  reg [31:0] gendlydata_r; \n  reg [31:0] dlydata_gr; \n  reg genblkclk; \n  reg [31:0] genblkdata; \n  reg [31:0] blkdata_gr; \n  wire [31:0] constwire = 32'h11; \n  reg [31:0] initwire; \n  integer i; \n  initial begin \n  for (i=0; i<10000; i=i+1) begin \n  initwire = 32'h2200; \n  end \n  end \n  wire [31:0] either = gendlydata_r | dlydata_gr | blkdata_gr | initwire | constwire; \n  wire [31:0] either_unused = gendlydata_r | dlydata_gr | blkdata_gr | initwire | constwire; \n  always @ (posedge clk) begin \n  gendlydata_r <= 32'h0011_0000; \n  gendlyclk_r <= 0; \n  genblkclk = 0; \n  genblkdata = 0; \n  if (cyc!=0) begin \n  cyc <= cyc + 1; \n  if (cyc==2) begin \n  gendlyclk_r <= 1; \n  gendlydata_r <= 32'h00540000; \n  genblkclk = 1; \n  genblkdata = 32'hace; \n  $write(\"[%0t] Send pulse\\n\", $time); \n  end \n  if (cyc==3) begin \n  genblkdata = 32'hdce; \n  gendlydata_r <= 32'h00ff0000; \n  if (either != 32'h87542211) $stop; \n  $write(\"*-* All Finished *-*\\n\"); \n  $finish; \n  end \n  end \n  end \n  always @ (posedge gendlyclk_r) begin \n  if ($time>0) begin \n  $write(\"[%0t] Got gendlyclk_r, d=%x b=%x\\n\", $time, gendlydata_r, genblkdata); \n  dlydata_gr <= 32'h80000000; \n  if (gendlydata_r != 32'h00540000) $stop; \n  if (genblkdata != 32'hace) $stop; \n  end \n  end \n  always @ (posedge genblkclk) begin \n  if ($time>0) begin \n  $write(\"[%0t] Got genblkclk, d=%x b=%x\\n\", $time, gendlydata_r, genblkdata); \n  blkdata_gr <= 32'h07000000; \n `ifdef verilator `else \n  if (gendlydata_r != 32'h00110000) $stop; \n `endif \n  if (genblkdata != 32'hace) $stop; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a single-port RAM with 128-bit data width and 8-bit address width. It has inputs for clock, data, write enable, and address, and an output for the data read from the RAM. The RAM itself is implemented using an array of registers. The data is written to the RAM when the write enable is asserted, and the output is driven by the data read from the RAM based on the input address during the positive edge of the clock signal.\n\n Module header:\n\nmodule single_port_ram_128_8(clk,data,we,addr,out);\n [/INST]\n", "output": "`define ADDR_WIDTH_128_8 8 \n `define DATA_WIDTH_128_8 128 \n  input clk; \n  input [`DATA_WIDTH_128_8-1:0] data; \n  input we; \n  input [`ADDR_WIDTH_128_8-1:0] addr; \n  output [`DATA_WIDTH_128_8-1:0] out; \n  reg [`DATA_WIDTH_128_8-1:0] out; \n  reg [`DATA_WIDTH_128_8-1:0] RAM[255:0]; \n  always @ (posedge clk) \n  begin \n  if (we) \n  begin \n  RAM[addr] <= data; \n  out <= RAM[addr]; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `mul_wrap` is a wrapper for a multiplication operation. It takes two inputs A and B, multiplies them, and produces the output Y. The module has parameters to specify the signedness and width of inputs A and B, as well as the output width Y. It extends the widths of A, B, and Y to accommodate the multiplication operation. Additionally, it includes a techmap directive for mapping to a specific technology and includes failure checks for signedness, width constraints, and area constraints. If all checks pass, it instantiates a submodule `__mul_wrapper` to perform the actual multiplication operation.\n\n Module header:\n\nmodule mul_wrap (A, B, Y);\n [/INST]\n", "output": "parameter A_SIGNED = 0; \n parameter B_SIGNED = 0; \n parameter A_WIDTH = 1; \n parameter B_WIDTH = 1; \n parameter Y_WIDTH = 1; \n input [A_WIDTH-1:0] A; \n input [B_WIDTH-1:0] B; \n output [Y_WIDTH-1:0] Y; \n wire [17:0] A_18 = A; \n wire [24:0] B_25 = B; \n wire [47:0] Y_48; \n assign Y = Y_48; \n wire [1023:0] _TECHMAP_DO_ = \"proc; clean\"; \n reg _TECHMAP_FAIL_; \n initial begin \n  _TECHMAP_FAIL_ <= 0; \n  if (A_SIGNED || B_SIGNED) \n  _TECHMAP_FAIL_ <= 1; \n  if (A_WIDTH < 4 || B_WIDTH < 4) \n  _TECHMAP_FAIL_ <= 1; \n  if (A_WIDTH > 18 || B_WIDTH > 25) \n  _TECHMAP_FAIL_ <= 1; \n  if (A_WIDTH*B_WIDTH < 100) \n  _TECHMAP_FAIL_ <= 1; \n end \n \\$__mul_wrapper #(.A_SIGNED(A_SIGNED),.B_SIGNED(B_SIGNED),.A_WIDTH(A_WIDTH),.B_WIDTH(B_WIDTH),.Y_WIDTH(Y_WIDTH)) _TECHMAP_REPLACE_ (.A(A_18),.B(B_25),.Y(Y_48)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module \"RWire\" is a simple register file. It takes in a WVAL signal of a specified width and WSET signal. When WSET is asserted, the module updates its internal state with the value of WVAL. The WGET output provides the stored value, and the WHAS output reflects whether the WSET signal is active.\n\n Module header:\n\nmodule RWire(WGET, WHAS, WVAL, WSET);\n [/INST]\n", "output": "parameter width = 1; \n  input [width - 1 : 0] WVAL; \n  input WSET; \n  output [width - 1 : 0] WGET; \n  output WHAS; \n  assign WGET = WVAL; \n  assign WHAS = WSET; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"vc_Reg\" is a parameterized register module, where the parameter \"p_nbits\" specifies the number of bits for the input and output. It consists of a single bit register \"q\" that stores the value of the input \"d\" on the rising edge of the clock signal \"clk\". The width of the register \"q\" and the input \"d\" is determined by the parameter \"p_nbits\".\n\n Module header:\n\nmodule vc_Reg #(parameter p_nbits = 1)(input clk,output [p_nbits-1:0] q,input [p_nbits-1:0] d);\n [/INST]\n", "output": "reg q; \n  always @( posedge clk ) \n  q <= d; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module XNOR performs a bitwise XNOR operation on two input buses of size SIZE, and stores the result in the output bus of the same size. It uses a reg for the output, which is updated whenever there is a change in the input.\n\n Module header:\n\nmodule XNOR # (parameter SIZE=8) (input wire [SIZE-1:0] inA,input wire [SIZE-1:0] inB,output reg [SIZE-1:0] out);\n [/INST]\n", "output": "always @ (*) \n begin \n  out <= ~(inA ^ inB); \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module is a clock generation circuit for LVDS (Low Voltage Differential Signaling) with clock domain crossing functionality. It uses a clock buffer, clock divisor, clock multiplier, DCM (Digital Clock Manager) instance, serializer, and clock reset logic. The module takes an input clock signal and generates multiple output clocks at different frequencies, along with an LVDS clock output. It also provides a reset signal and a data clock output. The circuit performs clock domain crossing and includes clock domain crossing logic and a serializer for LVDS signaling.\n\n Module header:\n\nmodule lvds_clockgen(input clk,output clk35,output nclk35,output rstclk,output dataclock,output lvdsclk);\n [/INST]\n", "output": "wire clk_lckd; \n wire clkdcm; \n wire clo; \n DCM_SP #(.CLKIN_PERIOD (\"15.625\"),.DESKEW_ADJUST (\"0\"),.CLKFX_MULTIPLY (7),.CLKFX_DIVIDE (2)) \n dcm_clk (.CLKIN (clk),.CLKFB (clo),.RST (1'b0),.CLK0 (clkdcm),.CLKFX (clk35),.CLKFX180 (nclk35),.CLK180 (),.CLK270 (),.CLK2X (),.CLK2X180 (),.CLK90 (),.CLKDV (),.PSDONE (),.STATUS (),.DSSEN (1'b0),.PSINCDEC (1'b0),.PSEN (1'b0),.PSCLK (1'b0),.LOCKED (clk_lckd)) ; \n BUFG clk_bufg (.I(clkdcm), .O(clo) ) ; \n assign not_clk_lckd = ~clk_lckd ; \n FDP fd_rst_clk (.D(not_clk_lckd), .C(clo), .Q(rst_clk)) ; \n serializer lvdsclkman (.clk(clo),.clk35(clk35),.notclk35(nclk35),.data(7'b1100011),.rst(rst_clk),.out(lvdsclk)); \n assign rstclk = rst_clk; \n assign dataclock = clo; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module represents a video system. It takes inputs for address, clock, and reset_n, and outputs readdata. The readdata output is assigned a value of 1424559903 when the address input is non-zero and 0 when the address input is zero.\n\n Module header:\n\nmodule video_sys_sysid_qsys_0 (address,clock,reset_n,readdata);\n [/INST]\n", "output": "output [ 31: 0] readdata; \n  input address; \n  input clock; \n  input reset_n; \n  wire [ 31: 0] readdata; \n  assign readdata = address ? 1424559903 : 0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a synchronous register with a clock and reset input. When the reset signal is high, the output q is set to zero. Otherwise, if the enable signal is asserted, the input data d is loaded into the output q on the rising edge of the clock signal.\n\n Module header:\n\nmodule myregister (clk, rst, d, q, ena);\n [/INST]\n", "output": "input clk, rst, ena; \n  output [`DATA_BITS-1:0] q; \n  reg [`DATA_BITS-1:0] q; \n  input [`DATA_BITS-1:0] d; \n  always @(posedge clk or posedge rst) begin \n  if (rst == 1) begin \n  q <= 0; \n  end else if (ena) begin \n  q <= d; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module is a register with separate load signals for high and low portions of the register, and a clear signal. When the clear signal is asserted, the register is cleared to 0. When the loadh signal is asserted, the high portion of the register is loaded with the input inh, and when the loadl signal is asserted, the low portion of the register is loaded with the input inl.\n\n Module header:\n\nmodule register_hl # (parameter N = 16) (input clk,input [N/2-1:0] inh,input [N/2-1:0] inl,input loadh,input loadl,input clear,output reg [N-1:0] out);\n [/INST]\n", "output": "always @ (posedge clk or posedge clear) \n  if (clear) out <= 0; \n  else begin \n  if (loadh) out[N-1:N/2] <= inh; \n  if (loadl) out[N/2-1:0] <= inl; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe ALU32 module takes two 32-bit inputs a and b, and a control input aluc, and produces a 32-bit output r and a flag output z. It includes submodules SHIFT32, LOGIC32, and ADDSUB32 for performing shift, logical, and arithmetic operations. The result r is determined based on the control signal aluc and the inputs a and b. The z flag is set to 1 if the result is zero, and 0 otherwise.\n\n Module header:\n\nmodule ALU32(input[31:0] a,b,aluc,output[31:0] r,output z);\n [/INST]\n", "output": "reg[31:0] r_r; \n  wire[31:0] r_shift,r_logic_andor,r_logic_xorlui,r_addsub; \n  SHIFT32 SHITF0 (a[4:0],b,aluc[2],aluc[3],r_shift); \n  LOGIC32 LOGIC0 (a,b,aluc[2],r_logic_andor,r_logic_xorlui); \n  ADDSUB32 ADDSUB0 (a,b,aluc[2],r_addsub); \n  always @(*) begin \n  case(aluc[1:0]) \n  2'b00: r_r <= r_addsub; \n  2'b01: r_r <= r_logic_andor; \n  2'b10: r_r <= r_logic_xorlui; \n  2'b11: r_r <= r_shift; \n  endcase \n  end \n  assign z = r_r==0 ? 1 : 0; \n  assign r = r_r; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is designed to read data from a PS/2 keyboard interface. It takes in clock and reset signals, along with key codes, and outputs data and a parity error flag. The module processes the input signals to extract the data and detect any parity errors, following the PS/2 protocol. It uses registers, counters, and multiplexers to handle the shifting and processing of the input data, along with checking for parity errors and updating the output data and error flag accordingly.\n\n Module header:\n\nmodule ps2_read_ms(clk,rst,kd,kc,kbs,data,parity_error);\n [/INST]\n", "output": "input clk,rst,kd,kc; \n  output kbs; \n  output reg parity_error = 1'b0; \n  output reg [7:0]data; \n  reg [7:0] data_next; \n  reg [10:2]shift; \n  reg [10:2]shift_next; \n  reg [3:0] data_in_counter = 4'd0; \n  reg [3:0] data_in_counter_next; \n  reg [1:0]kd_s = 2'b00; \n  reg [1:0]kc_s = 2'b00; \n  reg reset_data_in_counter; \n  reg new_data_available = 1'b0; \n  reg new_data_available_next; \n  wire kc_ne; \n  assign kbs=new_data_available; \n  always@(posedge clk) \n  if(rst) \n  {kd_s,kc_s} <= 4'b0; \n  else \n  begin \n  kd_s <= {kd_s[0], kd}; \n  kc_s <= {kc_s[0], kc}; \n  end \n  assign kc_ne = (~kc_s[0]) & (kc_s[1]); \n  always@(*) \n  case ({rst,kc_ne}) \n  2'b00:shift_next = shift; \n  2'b01:shift_next = {kd_s[1], shift[10:3]}; \n  default:shift_next = 11'd0; \n  endcase \n  always@(posedge clk) \n  shift <= shift_next; \n  always @(*) \n  if(data_in_counter == 4'd11) \n  reset_data_in_counter = 1'b1; \n  else \n  reset_data_in_counter=rst; \n  always@(*) \n  case({reset_data_in_counter,kc_ne}) \n  2'b00: data_in_counter_next = data_in_counter; \n  2'b01: data_in_counter_next = data_in_counter + 4'd1; \n  default:data_in_counter_next = 4'd0; \n  endcase \n  always@(posedge clk) \n  data_in_counter <= data_in_counter_next; \n  reg parity_error_next; \n  always@(*) \n  if((data_in_counter == 4'd10) && (!parity_error_next)) \n  new_data_available_next = 1'b1; \n  else \n  new_data_available_next = 1'b0; \n  always@(posedge clk) \n  new_data_available <= new_data_available_next; \n  always@(*) \n  if(data_in_counter == 4'd9) \n  data_next = shift[10:3]; \n  else \n  data_next = data; \n  always@(posedge clk) \n  data <= data_next; \n  wire parity_local; \n  assign parity_local = (^shift[10:2]); \n  always@(*) \n  if(data_in_counter == 4'd10) \n  if(parity_local == 1'b1) \n  parity_error_next = 1'b0; \n  else \n  parity_error_next = 1'b1; \n  else \n  parity_error_next = parity_error; \n  always@(posedge clk or posedge rst) \n  if(rst) \n  parity_error <= 1'b0; \n  else \n  parity_error<=parity_error_next; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module `vd4bd04` instantiates a submodule `vd4bd04_v9a2a06` and connects its inputs and outputs to the corresponding ports of the parent module. The module has input ports `vee8a83` and `v03aaf0`, and an output port `v67a3fc`. Inside the module, wires `w0`, `w1`, and `w2` are created to connect the input and output ports. The values of `vee8a83` and `v03aaf0` are assigned to wires `w0` and `w1` respectively. The output `v67a3fc` is assigned the value of wire `w2`. The submodule `vd4bd04_v9a2a06` is instantiated with inputs `w0` and `w1`, and output `w2`.\n\n Module header:\n\nmodule vd4bd04 (input vee8a83,input v03aaf0,output [1:0] v67a3fc);\n [/INST]\n", "output": "wire w0; \n  wire w1; \n  wire [0:1] w2; \n  assign w0 = vee8a83; \n  assign w1 = v03aaf0; \n  assign v67a3fc = w2; \n vd4bd04_v9a2a06 v9a2a06 (.i1(w0),.i0(w1),.o(w2)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module simulates a block memory with two memory blocks. It includes row and column addresses, function select signals, and operation stage signals for each block. The module uses a clock signal, a reset signal, and an enable signal to control the memory operations. The busy signal indicates the memory block's status.\n\nThe module initializes the signals and then manipulates the reset, enable, function code, column address, row address, and enable signals at specific time intervals to simulate memory operations. The module ends after the specified time interval.\n\n Module header:\n\nmodule t_block_memory;\n [/INST]\n", "output": "reg clock; \n  reg reset; \n  reg enable; \n  reg [4:0] row1; \n  reg [4:0] row2; \n  reg [4:0] col1; \n  reg [4:0] col2; \n  reg [1:0] func; \n  reg [1:0] stage; \n  wire [2:0] block1; \n  wire [2:0] block2; \n  wire busy; \n block_memory uut (.clock(clock),.reset(reset),.enable(enable),.row1(row1),.row2(row2),.col1(col1),.col2(col2),.func(func),.stage(stage),.block1(block1),.block2(block2),.busy(busy)); \n  always #1 clock = ~clock; \n  initial begin \n  clock = 0; \n  reset = 0; \n  enable = 0; \n  row1 = 0; \n  row2 = 0; \n  col1 = 0; \n  col2 = 0; \n  func = 0; \n  stage = 1; \n  #100; \n  reset = 1; \n  #10; \n  reset = 0; \n  #10; \n  enable = 1; \n  func = 1; \n  #10; \n  enable = 0; \n  func = 0; \n  #200; \n  col1 = 8; \n  row1 = 8; \n  enable = 1; \n  func = 0; \n  #10; \n  enable = 1; \n  func = 2; \n  #10 \n  enable = 0; \n  #100; \n  func = 3; \n  enable = 1; \n  #10; \n  enable = 0; \n  #200; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a testbench for a deposit test. It includes a clock signal, a start signal, and a counter. The counter increments based on the clock and the start signal. The module also includes registers and always blocks for initializing and updating the values. There are also conditional deposits for specific values into four D-type flip-flops. The module concludes with checking if certain conditions are met and displaying corresponding messages.\n\n Module header:\n\nmodule deposit_test;\n [/INST]\n", "output": "reg ck; \n  reg start; \n  initial start = 0; \n `ifdef RTL \n  reg [3:0] cnt; \n  wire cnt_tc = &cnt; \n  always @(posedge ck) \n  if (start | ~cnt_tc) \n  cnt <= cnt + 1; \n `else \n  wire [3:0] cnt; \n  wire [3:0] cnt_1; \n  wire [3:0] cnt_c; \n  wire cnt_tc; \n  wire ne, e; \n  and (cnt_tc, cnt[0], cnt[1], cnt[2], cnt[3]); \n  not (ne, cnt_tc); \n  or (e, ne, start); \n  had A0 (cnt[0], 1'b1, cnt_c[0], cnt_1[0]); \n  had A1 (cnt[1], cnt_c[0], cnt_c[1], cnt_1[1]); \n  had A2 (cnt[2], cnt_c[1], cnt_c[2], cnt_1[2]); \n  had A3 (cnt[3], cnt_c[2], cnt_c[3], cnt_1[3]); \n  dffe C0 (ck, e, cnt_1[0], cnt[0]); \n  dffe C1 (ck, e, cnt_1[1], cnt[1]); \n  dffe C2 (ck, e, cnt_1[2], cnt[2]); \n  dffe C3 (ck, e, cnt_1[3], cnt[3]); \n `endif \n  integer r0; initial r0 = 0; \n  integer r1; initial r1 = 0; \n  always \n  begin \n  #5 ck <= 0; \n  #4; \n  $display(\"%b %b %d %d\", cnt, cnt_tc, r0, r1); \n  if (cnt_tc === 1'b0) r0 = r0 + 1; \n  if (cnt_tc === 1'b1) r1 = r1 + 1; \n  #1 ck <= 1; \n  end \n  initial \n  begin \n  #22; \n `ifdef RTL \n  cnt <= 4'b 1010; \n `else \n  $deposit(C0.Q, 1'b0); \n  $deposit(C1.Q, 1'b1); \n  $deposit(C2.Q, 1'b0); \n  $deposit(C3.Q, 1'b1); \n `endif \n  #1 if (cnt !== 4'b1010) \n  $display(\"FAILED\"); \n  #99; \n  $display(\"%d/%d\", r0, r1); \n  if (r0===5 && r1===5) \n  $display(\"PASSED\"); \n  else \n  $display(\"FAILED\"); \n  $finish; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module is an RS232 communication controller that interfaces with an external RS232 communication interface. It includes logic for handling data input and output, serial input processing, timer management, and file I/O in an ICARUS simulation environment. The module also incorporates conditional compilation directives for different simulation environments. The design contains a state machine that processes requests and generates appropriate responses, while also managing data flow and control signals. Additionally, it initializes and manages internal registers and counters, and supports debugging functionality when compiled with the ICARUS simulator.\n\n Module header:\n\nmodule rs232(input wire clk,input wire rst,input wire `REQ rs232_req,output wire `RES rs232_res,input wire rs232in_attention,input wire [7:0] rs232in_data,input wire rs232out_busy,output wire rs232out_w,output wire [7:0] rs232out_d);\n [/INST]\n", "output": "parameter debug = 1; \n `ifdef __ICARUS__ \n  parameter inputtext = \"input.txt\"; \n  integer file, ch = 32, rs232in_pending = 0; \n `endif \n  reg [31:0] tsc = 0; \n  reg [ 7:0] rs232in_cnt = 0; \n  wire [31:0] addr = rs232_req`A; \n  reg [31:0] rd_data = 0; \n  assign rs232_res`RD = rd_data; \n  assign rs232_res`HOLD = 0; \n  always @(posedge clk) \n  if (rst) begin \n  rd_data <= 0; \n  tsc <= 0; \n  rs232in_cnt <= 0; \n  end else begin \n `ifdef __ICARUS__ \n  if (rs232out_w) \n  $display(\"*** serial output '%c' ***\", rs232out_d); \n `endif \n  rd_data <= 0; \n  tsc <= tsc + 1; \n `ifndef __ICARUS__ \n  if (rs232in_attention) \n  rs232in_cnt <= rs232in_cnt + 1'h1; \n `endif \n  if (rs232_req`R) begin \n `ifdef __ICARUS__ \n  case (addr[3:2]) \n  0: rd_data <= 0; \n  1: begin \n  $display(\"*** serial input '%c' ***\", ch); \n  rd_data <= {24'h0,ch}; \n  rs232in_pending = 0; \n  end \n  2: begin \n  if (rs232in_pending > 1) begin \n  rs232in_pending = rs232in_pending - 1; \n  if (rs232in_pending == 1) begin \n  rs232in_cnt = rs232in_cnt + 1; \n  end \n  end \n  rd_data <= {24'h0,rs232in_cnt}; \n  end \n  3: rd_data <= tsc; \n  endcase \n  if (!rs232in_pending) begin \n  ch = $fgetc(file); \n  if (ch != -1) \n  rs232in_pending = 3; \n  end \n `else \n  case (addr[3:2]) \n  0: rd_data <= {31'h0,rs232out_busy}; \n  1: rd_data <= {24'h0,rs232in_data}; \n  2: rd_data <= {24'h0,rs232in_cnt}; \n  3: rd_data <= tsc; \n  endcase \n `endif \n  end \n  end \n  wire [31:0] rs232_writedata = rs232_req`WD; \n  assign rs232out_d = rs232_writedata[7:0]; \n  assign rs232out_w = rs232_req`W & addr[3:0] == 0; \n `ifdef __ICARUS__ \n  initial begin \n  file = $fopen(inputtext, \"r\"); \n  $display(\"Opening of %s resulted in %d\", inputtext, file); \n  end \n `endif \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a memory interface with addressable read and write operations. It includes address and data registers, edge detection for the write and read signals, and logic to handle read and write requests. The module supports synchronous operation with clock and reset signals. The `s_waitrequest` output indicates if the module is waiting, and `s_readdata` provides the data read from memory based on the address. The module effectively manages write and read operations while handling waiting states as needed.\n\n Module header:\n\nmodule memif(input wire clk,input wire reset,input wire [1:0] s_address,input wire s_write,input wire s_read,input wire [31:0] s_writedata,output reg [31:0] s_readdata,output wire s_waitrequest,output wire [17:0] m_address,output reg m_write,output reg m_read,output wire [35:0] m_writedata,input wire [35:0] m_readdata,input wire m_waitrequest);\n [/INST]\n", "output": "reg [17:0] addr; \n  reg [35:0] word; \n  assign m_address = addr; \n  assign m_writedata = word; \n  wire write_edge, read_edge; \n  edgedet e0(clk, reset, s_write, write_edge); \n  edgedet e1(clk, reset, s_read, read_edge); \n  reg waiting; \n  wire req = (write_edge|read_edge) & s_address == 2'h2; \n  assign s_waitrequest = req | waiting; \n  always @(posedge clk or negedge reset) begin \n  if(~reset) begin \n  m_write <= 0; \n  m_read <= 0; \n  waiting <= 0; \n  addr <= 0; \n  word <= 0; \n  end else begin \n  if(write_edge) begin \n  case(s_address) \n  2'h0: addr <= s_writedata[17:0]; \n  2'h1: word[17:0] <= s_writedata[17:0]; \n  2'h2: word[35:18] <= s_writedata[17:0]; \n  endcase \n  end \n  if(req) begin \n  waiting <= 1; \n  if(s_write) \n  m_write <= 1; \n  else if(s_read) \n  m_read <= 1; \n  end \n  if(m_write & ~m_waitrequest) begin \n  m_write <= 0; \n  waiting <= 0; \n  end \n  if(m_read & ~m_waitrequest) begin \n  m_read <= 0; \n  waiting <= 0; \n  word <= m_readdata; \n  end \n  end \n  end \n  always @(*) begin \n  case(s_address) \n  2'h1: s_readdata <= { 14'b0, word[17:0] }; \n  2'h2: s_readdata <= { 14'b0, word[35:18] }; \n  default: s_readdata <= 32'b0; \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an accumulator with a queue. It takes an input a_in and accumulates it with the previous values stored in the FIFO elements. The accumulator has a configurable bit width A_BITS and a configurable FIFO length. The head and index are used to manage the FIFO elements. The module resets the FIFO and the head and index values when the reset signal is asserted. The accumulator updates the FIFO elements and the head based on the input a_in and the stall signal. The output a_out is the accumulated value stored in the head of the FIFO.\n\n Module header:\n\nmodule AccumulateQueue #(parameter A_BITS = 32,parameter FIFO_LENGTH = 8,parameter INDEX_BITS = $clog2(FIFO_LENGTH)) (input clock,input reset,input stall,input [A_BITS-1:0] a_in,output [A_BITS-1:0] a_out);\n [/INST]\n", "output": "reg [A_BITS-1:0] fifo_e [0:(FIFO_LENGTH/2)-1]; \n  reg [A_BITS-1:0] fifo_o [0:(FIFO_LENGTH/2)-1]; \n  reg [A_BITS-1:0] head; \n  reg [INDEX_BITS-1:0] index; \n  integer i; \n  always @(posedge clock) begin \n  if (reset) begin \n  for (i = 0; i < FIFO_LENGTH; i = i + 1) begin \n  fifo_e[i] <= {A_BITS{1'b0}}; \n  fifo_o[i] <= {A_BITS{1'b0}}; \n  end \n  head <= {A_BITS{1'b0}}; \n  index <= {INDEX_BITS{1'b0}}; \n  end \n  end \n  wire [INDEX_BITS-1:0] index_next = index + 1; \n  wire [INDEX_BITS-2:0] fifo_index = index[INDEX_BITS-1:1]; \n  wire [INDEX_BITS-2:0] fifo_index_next = index_next[INDEX_BITS-1:1]; \n  wire odd = index[0]; \n  always @(posedge clock) begin \n  if (!reset && !stall) begin \n  if (odd) begin \n  fifo_o[fifo_index] <= head + a_in; \n  head <= fifo_e[fifo_index_next]; \n  end else begin \n  fifo_e[fifo_index] <= head + a_in; \n  head <= fifo_o[fifo_index_next]; \n  end \n  index <= index_next; \n  end \n  end \n  assign a_out = head; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements an altpriority encoder for the input data and outputs a 4-bit signal q. The input data is split into two parts, and each part is processed by a separate altpriority encoder. The outputs of these two encoders are combined to form the final output q using a specific logic equation.\n\n Module header:\n\nmodule acl_fp_sub_altpriority_encoder_i39 (data,q) ;\n [/INST]\n", "output": "input [15:0] data; \n  output [3:0] q; \n  wire [2:0] wire_altpriority_encoder29_q; \n  wire wire_altpriority_encoder29_zero; \n  wire [2:0] wire_altpriority_encoder30_q; \n  acl_fp_sub_altpriority_encoder_vh8 altpriority_encoder29 \n (.data(data[7:0]),.q(wire_altpriority_encoder29_q),.zero(wire_altpriority_encoder29_zero)); \n  acl_fp_sub_altpriority_encoder_v28 altpriority_encoder30 \n (.data(data[15:8]),.q(wire_altpriority_encoder30_q)); \n  assign \n  q = {wire_altpriority_encoder29_zero, (({3{wire_altpriority_encoder29_zero}} & wire_altpriority_encoder30_q) | ({3{(~ wire_altpriority_encoder29_zero)}} & wire_altpriority_encoder29_q))}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a multiply-accumulate (MAC) unit. It takes in three sets of inputs (a1, a2, a3) and (b1, b2, b3) and performs multiplication and addition operations on these inputs. It has multiple multiplier and adder units, each with its own control signals. The module also includes registers for storing intermediate results. The output is the result of the final addition operation. The registers are updated on each clock edge, and the output is computed using the stored values.\n\n Module header:\n\nmodule mm3(clock,reset,a1,a2,a3,b1,b2,b3,out);\n [/INST]\n", "output": "input clock; \n input reset; \n input [`BITS-1:0] a1; \n input [`BITS-1:0] a2; \n input [`BITS-1:0] a3; \n input [`BITS-1:0] b1; \n input [`BITS-1:0] b2; \n input [`BITS-1:0] b3; \n output [`BITS-1:0] out; \n wire [`BITS-1:0] x1; \n wire [`BITS-1:0] x2; \n wire [`BITS-1:0] x3; \n wire [`BITS-1:0] add4; \n wire [`BITS-1:0] add5; \n reg [`BITS-1:0] x3_reg1; \n reg [`BITS-1:0] x3_reg2; \n reg [`BITS-1:0] x3_reg3; \n reg [`BITS-1:0] x3_reg4; \n reg [`BITS-1:0] x3_reg5; \n reg [`BITS-1:0] x3_reg6; \n wire [`BITS-1:0] out; \n wire [7:0] x1_control; \n fpu_mul x1_mul \n (.clk(clock),.opa(a1),.opb(b1),.out(x1),.control(x1_control)); \n wire [7:0] x2_control; \n fpu_mul x2_mul \n (.clk(clock),.opa(a2),.opb(b2),.out(x2),.control(x2_control)); \n wire [7:0] x3_control; \n fpu_mul x3_mul \n (.clk(clock),.opa(a3),.opb(b3),.out(x3),.control(x3_control)); \n wire [7:0] add4_control; \n fpu_add add4_add \n (.clk(clock),.opa(x1),.opb(x2),.out(add4),.control(add4_control)); \n wire [7:0] out_control; \n fpu_add out_add \n (.clk(clock),.opa(add4),.opb(x3_reg6),.out(out),.control(out_control)); \n always @(posedge clock) \n begin \n  x3_reg1 <= x3; \n  x3_reg2 <= x3_reg1; \n  x3_reg3 <= x3_reg2; \n  x3_reg4 <= x3_reg3; \n  x3_reg5 <= x3_reg4; \n  x3_reg6 <= x3_reg5; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a CRC32 calculation. It takes inputs for clock, data, enable, shift, clear, reset, and computes the 32-bit CRC output and a serial output. It uses a parallel structure to calculate the new CRC based on the input data and the current CRC value. The CRC register is updated on the positive edge of the clock or reset signal, and it shifts the CRC register if the shift signal is high. If the enable signal is asserted, the new CRC is loaded into the register. The clear signal initializes the CRC register to all 1s. The serial output is the least significant bit of the CRC register.\n\n Module header:\n\nmodule adbg_crc32 (clk, data, enable, shift, clr, rst, crc_out, serial_out);\n [/INST]\n", "output": "input clk; \n input data; \n input enable; \n input shift; \n input clr; \n input rst; \n output [31:0] crc_out; \n output serial_out; \n reg [31:0] crc; \n wire [31:0] new_crc; \n assign new_crc[0] = crc[1]; \n assign new_crc[1] = crc[2]; \n assign new_crc[2] = crc[3]; \n assign new_crc[3] = crc[4]; \n assign new_crc[4] = crc[5]; \n assign new_crc[5] = crc[6] ^ data ^ crc[0]; \n assign new_crc[6] = crc[7]; \n assign new_crc[7] = crc[8]; \n assign new_crc[8] = crc[9] ^ data ^ crc[0]; \n assign new_crc[9] = crc[10] ^ data ^ crc[0]; \n assign new_crc[10] = crc[11]; \n assign new_crc[11] = crc[12]; \n assign new_crc[12] = crc[13]; \n assign new_crc[13] = crc[14]; \n assign new_crc[14] = crc[15]; \n assign new_crc[15] = crc[16] ^ data ^ crc[0]; \n assign new_crc[16] = crc[17]; \n assign new_crc[17] = crc[18]; \n assign new_crc[18] = crc[19]; \n assign new_crc[19] = crc[20] ^ data ^ crc[0]; \n assign new_crc[20] = crc[21] ^ data ^ crc[0]; \n assign new_crc[21] = crc[22] ^ data ^ crc[0]; \n assign new_crc[22] = crc[23]; \n assign new_crc[23] = crc[24] ^ data ^ crc[0]; \n assign new_crc[24] = crc[25] ^ data ^ crc[0]; \n assign new_crc[25] = crc[26]; \n assign new_crc[26] = crc[27] ^ data ^ crc[0]; \n assign new_crc[27] = crc[28] ^ data ^ crc[0]; \n assign new_crc[28] = crc[29]; \n assign new_crc[29] = crc[30] ^ data ^ crc[0]; \n assign new_crc[30] = crc[31] ^ data ^ crc[0]; \n assign new_crc[31] = data ^ crc[0]; \n always @ (posedge clk or posedge rst) \n begin \n  if(rst) \n  crc[31:0] <= #1 32'hffffffff; \n  else if(clr) \n  crc[31:0] <= #1 32'hffffffff; \n  else if(enable) \n  crc[31:0] <= #1 new_crc; \n  else if (shift) \n  crc[31:0] <= #1 {1'b0, crc[31:1]}; \n end \n assign crc_out = crc; \n assign serial_out = crc[0]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a 4-bit synchronous counter that increments on each clock cycle. It has inputs for the clock signal (clk) and the reset signal (rst), and an output (y) which is high when the counter value is 12. When the reset signal is asserted or the counter reaches 9, the counter is reset to 0. On each clock cycle, the counter is either incremented or reset based on the reset signal and the current value of the counter.\n\n Module header:\n\nmodule example004(clk, rst, y);\n [/INST]\n", "output": "input clk, rst; \n output y; \n reg [3:0] counter; \n always @(posedge clk) \n  case (1'b1) \n  rst, counter == 9: \n  counter <= 0; \n  default: \n  counter <= counter+1; \n  endcase \n assign y = counter == 12; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a time tagging system that interfaces with external hardware, such as a record buffer, timer functionality, and register management. It utilizes various sub-modules to manage registers, store records in a FIFO buffer, and handle record loss tracking. The module communicates with the external hardware through input and output signals, such as command signals, record ready signals, and data acknowledge signals. It also includes features such as version tracking, clock rate monitoring, and record loss detection. The design leverages synchronous and asynchronous logic, as well as control structures for conditional statements and state management.\n\n Module header:\n\nmodule timetag(fx2_clk,data_rdy, data, data_ack,cmd_wr, cmd_in,reply_rdy, reply, reply_ack, reply_end,clk,strobe_in,delta_chs);\n [/INST]\n", "output": "input fx2_clk; \n input clk; \n input cmd_wr; \n input [7:0] cmd_in; \n output reply_rdy; \n output [7:0] reply; \n input reply_ack; \n output reply_end; \n output data_rdy; \n output [7:0] data; \n input data_ack; \n input [3:0] strobe_in; \n output [3:0] delta_chs; \n wire [15:0] reg_addr; \n wire [31:0] reg_data; \n wire reg_wr; \n reg_manager reg_mgr(.clk(fx2_clk),.cmd_wr(cmd_wr),.cmd_in(cmd_in),.reply_out(reply),.reply_rdy(reply_rdy),.reply_ack(reply_ack),.reply_end(reply_end),.reg_addr(reg_addr),.reg_data(reg_data),.reg_wr(reg_wr)); \n readonly_register #(.ADDR(16'h01)) version_reg(.reg_clk(fx2_clk),.reg_addr(reg_addr),.reg_data(reg_data),.reg_wr(reg_wr),.value(`HWVERSION)); \n readonly_register #(.ADDR(16'h02)) clockrate_reg(.reg_clk(fx2_clk),.reg_addr(reg_addr),.reg_data(reg_data),.reg_wr(reg_wr),.value(`CLOCKRATE)); \n sequencer seq(.clk(clk),.outputs(delta_chs),.reg_clk(fx2_clk),.reg_addr(reg_addr),.reg_data(reg_data),.reg_wr(reg_wr)); \n wire [47:0] record; \n wire record_rdy; \n apdtimer_all apdtimer(.clk(clk),.strobe_in(strobe_in),.delta_in(delta_chs),.record_rdy(record_rdy),.record(record[46:0]),.reg_clk(fx2_clk),.reg_addr(reg_addr),.reg_data(reg_data),.reg_wr(reg_wr)); \n wire rec_buf_full; \n wire rec_buf_rdnext; \n wire rec_buf_empty; \n wire [47:0] rec_buf_out; \n reg rec_lost; \n initial rec_lost = 0; \n assign record[47] = rec_lost; \n counter_register #(.ADDR(16'h07)) rec_lost_counter(.reg_clk(fx2_clk),.reg_addr(reg_addr),.reg_data(reg_data),.reg_wr(reg_wr),.increment_clk(clk),.increment(record_rdy && rec_buf_full)); \n always @(posedge clk) \n begin \n  if (record_rdy && rec_buf_full) \n  rec_lost <= 1; \n  else if (record_rdy && !rec_buf_full) \n  rec_lost <= 0; \n end \n counter_register #(.ADDR(16'h06)) rec_counter(.reg_clk(fx2_clk),.reg_addr(reg_addr),.reg_data(reg_data),.reg_wr(reg_wr),.increment_clk(clk),.increment(record_rdy && !rec_buf_full)); \n wire [31:0] fifo_reg; \n sample_fifo rec_buf(.wrclk(clk),.wrreq(record_rdy && !rec_buf_full),.wrfull(rec_buf_full),.data(record),.rdclk(fx2_clk),.rdreq(rec_buf_rdnext),.rdempty(rec_buf_empty),.q(rec_buf_out),.aclr(fifo_reg[0])); \n sample_multiplexer mux(.clk(fx2_clk),.sample_rdy(!rec_buf_empty),.sample(rec_buf_out),.sample_req(rec_buf_rdnext),.data_rdy(data_rdy),.data(data),.data_ack(data_ack)); \n register #(.ADDR(8'h08)) rec_fifo_reg(.reg_clk(fx2_clk),.reg_addr(reg_addr),.reg_data(reg_data),.reg_wr(reg_wr),.clk(clk),.value(fifo_reg)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an asynchronous load D flip-flop with a synchronous clear. It updates the output Q based on the inputs D, C, L, and AD. When the L input is low, the Q output is updated with the AD input. When the L input is high, the Q output is updated with the D input on the rising edge of the C input.\n\n Module header:\n\nmodule \\$_ALDFF_PN_ (D, C, L, AD, Q);\n [/INST]\n", "output": "input D, C, L, AD; \n output reg Q; \n always @(posedge C or negedge L) begin \n  if (L == 0) \n  Q <= AD; \n  else \n  Q <= D; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a 1k x 8-bit synchronous RAM. It has inputs for the clock (clk), chip enable (ce), address (a), data input (din), and write enable (we), and an output for data output (dout). The memory is declared as an array of 1024 8-bit registers. On each positive edge of the clock, the module reads the memory at the specified address and assigns the output to dout. If the write enable and chip enable are both high, the module writes the data input into the memory at the specified address.\n\n Module header:\n\nmodule ram1k (input wire clk,input wire ce,input wire [9:0] a,input wire [7:0] din,output reg [7:0] dout,input wire we);\n [/INST]\n", "output": "reg [7:0] mem[0:1023]; \n  always @(posedge clk) begin \n  dout <= mem[a]; \n  if (we == 1'b1 && ce == 1'b1) \n  mem[a] <= din; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements the memory stage of a processor pipeline. It takes various control signals and data inputs from the previous stage and produces the necessary outputs for the write-back stage. The module handles the control of the register write, memory read/write, ALU output, read data, and register number for the write-back stage based on clock and reset signals and the memory and write-back stage control signals.\n\n Module header:\n\nmodule MEM_stage(clk, rst, M_flush, M_stall, WB_stall, M_regwrite,M_memtoreg, M_alu_out, M_rt_rd, M_readdata,WB_regwrite, WB_memtoreg, WB_alu_out, WB_rt_rd,WB_readdata);\n [/INST]\n", "output": "input clk; \n  input rst; \n  input M_flush; \n  input M_stall; \n  input WB_stall; \n  input M_regwrite; \n  input M_memtoreg; \n  input [31:0] M_alu_out; \n  input [31:0] M_readdata; \n  input [4:0] M_rt_rd; \n  output reg WB_regwrite; \n  output reg WB_memtoreg; \n  output reg [31:0] WB_readdata; \n  output reg [31:0] WB_alu_out; \n  output reg [4:0] WB_rt_rd; \n  always @(posedge clk) begin \n  WB_regwrite <= rst ? 0 : (WB_stall ? WB_regwrite : ((M_flush | M_stall ) ? 0 : M_regwrite)); \n  WB_memtoreg <= rst ? 0 : (WB_stall ? WB_memtoreg : M_memtoreg); \n  WB_alu_out <= rst ? 32'b0 : (WB_stall ? WB_alu_out : M_alu_out); \n  WB_readdata <= rst ? 32'b0 : (WB_stall ? WB_readdata : M_readdata); \n  WB_rt_rd <= rst ? 5'b0 : (WB_stall ? WB_rt_rd : M_rt_rd); \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a 2D Multiplier that takes two input vectors A and B of sizes M and N respectively, and produces the product P of size M+N. It uses a generate block to create partial products using a Ripple Carry Adder module and assigns the final product to P. Each iteration of the for loop generates a partial product and adds it to the previous partial product.\n\n Module header:\n\nmodule Multiplier_2D #(parameter M = 4, parameter N = 4)(input [M-1:0] A,input [N-1:0] B,output [M+N-1:0] P );\n [/INST]\n", "output": "wire [M+N-1:0] PP [N-1:0]; \n assign PP[0] = { {N{1'b0}} , { A & {M{B[0]}} } }; \n assign P = PP[N-1]; \n genvar i; \n generate \n for (i=1; i < N; i=i+1) \n begin: addPartialProduct \n  wire [M+i-1:0] gA,gB,gS; wire Cout; \n  assign gA = { A & {M{B[i]}} , {i{1'b0}} }; \n  assign gB = PP[i-1][M+i-1:0]; \n  assign PP[i] = { {(N-i){1'b0}}, Cout, gS}; \n RippleCarryAdder#(M+i) adder(.A(gA), .B(gB), .S(gS), .Cin(1'b0), .Cout(Cout) ); \n end \n endgenerate \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"merge_step\" merges two input signals X9 and Y9 using the values in the input bit vector b. The module contains temporary signal wires to store intermediate values during the merging process. It uses instances of the \"merge_loc\" module to shift the input signals based on the values of b.\n\nThe output signals X17 and Y17 are calculated based on the merged values of X9 and Y9. X17 is also constrained to a maximum value to prevent overflow. The module contains combinatorial and sequential logic to handle the merging process and updating the output signals based on the inputs and temporary values.\n\n Module header:\n\nmodule merge_step(X9,Y9,b,X17,Y17,clk);\n [/INST]\n", "output": "`define WIDTH 22 \n input clk; \n input [`WIDTH-1:0] X9; \n input [`WIDTH-1:0] Y9; \n input [7:0] b; \n output reg [`WIDTH-1:0] X17; \n output reg [`WIDTH-1:0] Y17; \n wire [`WIDTH-1:0] tmpX10; \n wire [`WIDTH-1:0] tmpX11; \n wire [`WIDTH-1:0] tmpX12; \n wire [`WIDTH-1:0] tmpX13; \n wire [`WIDTH-1:0] tmpX14; \n wire [`WIDTH-1:0] tmpX15; \n wire [`WIDTH-1:0] tmpX16; \n wire [`WIDTH-1:0] tmpX17; \n wire [`WIDTH-1:0] tmpY10; \n wire [`WIDTH-1:0] tmpY11; \n wire [`WIDTH-1:0] tmpY12; \n wire [`WIDTH-1:0] tmpY13; \n wire [`WIDTH-1:0] tmpY14; \n wire [`WIDTH-1:0] tmpY15; \n wire [`WIDTH-1:0] tmpY16; \n wire [`WIDTH-1:0] tmpY17; \n merge_loc #(.shift_num(9)) \n  M1 (.A_in(Y9),.b(b[7]),.A_out(tmpY10),.clk(clk)); \n merge_loc #(.shift_num(10)) \n  M2 (.A_in(Y9),.b(b[6]),.A_out(tmpY11),.clk(clk)); \n merge_loc #(.shift_num(11)) \n  M3 (.A_in(Y9),.b(b[5]),.A_out(tmpY12),.clk(clk)); \n merge_loc #(.shift_num(12)) \n  M4 (.A_in(Y9),.b(b[4]),.A_out(tmpY13),.clk(clk)); \n merge_loc #(.shift_num(13)) \n  M5 (.A_in(Y9),.b(b[3]),.A_out(tmpY14),.clk(clk)); \n merge_loc #(.shift_num(14)) \n  M6 (.A_in(Y9),.b(b[2]),.A_out(tmpY15),.clk(clk)); \n merge_loc #(.shift_num(15)) \n  M7 (.A_in(Y9),.b(b[1]),.A_out(tmpY16),.clk(clk)); \n merge_loc #(.shift_num(16)) \n  M8 (.A_in(Y9),.b(b[0]),.A_out(tmpY17),.clk(clk)); \n merge_loc #(.shift_num(9)) \n  M9 (.A_in(X9),.b(b[7]),.A_out(tmpX10),.clk(clk)); \n merge_loc #(.shift_num(10)) \n  M10 (.A_in(X9),.b(b[6]),.A_out(tmpX11),.clk(clk)); \n merge_loc #(.shift_num(11)) \n  M11 (.A_in(X9),.b(b[5]),.A_out(tmpX12),.clk(clk)); \n merge_loc #(.shift_num(12)) \n  M12 (.A_in(X9),.b(b[4]),.A_out(tmpX13),.clk(clk)); \n merge_loc #(.shift_num(13)) \n  M13 (.A_in(X9),.b(b[3]),.A_out(tmpX14),.clk(clk)); \n merge_loc #(.shift_num(14)) \n  M14 (.A_in(X9),.b(b[2]),.A_out(tmpX15),.clk(clk)); \n merge_loc #(.shift_num(15)) \n  M15 (.A_in(X9),.b(b[1]),.A_out(tmpX16),.clk(clk)); \n merge_loc #(.shift_num(16)) \n  M16 (.A_in(X9),.b(b[0]),.A_out(tmpX17),.clk(clk)); \n always @(*)begin \n  if(X17>=22'b0111111111111111111111) \n  X17<=22'b0111111111111111111111; \n  end \n always @(X9 or Y9) begin \n  X17<=X9-tmpY10-tmpY11-tmpY12-tmpY13-tmpY14-tmpY15-tmpY16-tmpY17; \n  Y17<=Y9+tmpX10+tmpX11+tmpX12+tmpX13+tmpX14+tmpX15+tmpX16+tmpX17; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a timer with various control and configuration signals. It includes a time-of-day (TOD) register, an alarm register, and control logic. The module updates the TOD and alarm registers based on input signals and generates an interrupt request (irq) when the TOD and alarm match and a count delay signal (count_del) is asserted. The module also handles clock enable signals, resets, and writing data to the registers. The irq output is driven high if a match occurs and count_del is asserted, indicating an interrupt request.\n\n Module header:\n\nmodule cia_timerd (input clk,input clk7_en,input wr,input reset,input tlo,input tme,input thi,input tcr,input [7:0] data_in,output reg [7:0] data_out,input count,output irq);\n [/INST]\n", "output": "reg latch_ena; \n  reg count_ena; \n  reg crb7; \n  reg [23:0] tod; \n  reg [23:0] alarm; \n  reg [23:0] tod_latch; \n  reg count_del; \n always @(posedge clk) \n  if (clk7_en) begin \n  if (reset) \n  latch_ena <= 1'd1; \n  else if (!wr) \n  begin \n  if (thi && !crb7) \n  latch_ena <= 1'd0; \n  else if (tlo) \n  latch_ena <= 1'd1; \n  end \n  end \n always @(posedge clk) \n  if (clk7_en) begin \n  if (latch_ena) \n  tod_latch[23:0] <= tod[23:0]; \n  end \n always @(*) \n  if (!wr) \n  begin \n  if (thi) \n  data_out[7:0] = tod_latch[23:16]; \n  else if (tme) \n  data_out[7:0] = tod_latch[15:8]; \n  else if (tlo) \n  data_out[7:0] = tod_latch[7:0]; \n  else if (tcr) \n  data_out[7:0] = {crb7,7'b000_0000}; \n  else \n  data_out[7:0] = 8'd0; \n  end \n  else \n  data_out[7:0] = 8'd0; \n always @(posedge clk) \n  if (clk7_en) begin \n  if (reset) \n  count_ena <= 1'd1; \n  else if (wr && !crb7) \n  begin \n  if (thi) \n  count_ena <= 1'd0; \n  else if (tlo) \n  count_ena <= 1'd1; \n  end \n  end \n always @(posedge clk) \n  if (clk7_en) begin \n  if (reset) \n  begin \n  tod[23:0] <= 24'd0; \n  end \n  else if (wr && !crb7) \n  begin \n  if (tlo) \n  tod[7:0] <= data_in[7:0]; \n  if (tme) \n  tod[15:8] <= data_in[7:0]; \n  if (thi) \n  tod[23:16] <= data_in[7:0]; \n  end \n  else if (count_ena && count) \n  tod[23:0] <= tod[23:0] + 24'd1; \n  end \n always @(posedge clk) \n  if (clk7_en) begin \n  if (reset) \n  begin \n  alarm[7:0] <= 8'b1111_1111; \n  alarm[15:8] <= 8'b1111_1111; \n  alarm[23:16] <= 8'b1111_1111; \n  end \n  else if (wr && crb7) \n  begin \n  if (tlo) \n  alarm[7:0] <= data_in[7:0]; \n  if (tme) \n  alarm[15:8] <= data_in[7:0]; \n  if (thi) \n  alarm[23:16] <= data_in[7:0]; \n  end \n  end \n always @(posedge clk) \n  if (clk7_en) begin \n  if (reset) \n  crb7 <= 1'd0; \n  else if (wr && tcr) \n  crb7 <= data_in[7]; \n  end \n always @(posedge clk) \n  if (clk7_en) begin \n  count_del <= count & count_ena; \n  end \n assign irq = (tod[23:0]==alarm[23:0] && count_del) ? 1'b1 : 1'b0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, \"Key\", is used to detect the direction of key presses. It has inputs for the clock signal and reset, as well as for the four directional keys: left, right, up, and down. The output \"direction\" is an 8-bit register representing the detected direction.\n\nThe module includes a 32-bit counter \"clk_cnt\" and four registers \"left_key_last\", \"right_key_last\", \"up_key_last\", and \"down_key_last\" for storing the previous states of the directional keys.\n\nDuring operation, the module uses the clock signal to count cycles and track the states of the directional keys. When a directional key is pressed, the module updates the \"direction\" output to indicate the corresponding direction.\n\nThe module also includes a reset mechanism that sets the output \"direction\" and all the key registers to zero when the reset signal is activated.\n\nOverall, the \"Key\" module functions as a state machine to detect the direction of key presses and updates the output accordingly based on the key states and clock cycles.\n\n Module header:\n\n module Key ( input clk,input rst,input left,input right,input up,input down,output reg[7:0] direction);\n [/INST]\n", "output": "reg [31:0]clk_cnt; \n  reg left_key_last; \n  reg right_key_last; \n  reg up_key_last; \n  reg down_key_last; \n  always@(posedge clk or negedge rst) begin \n  if(!rst) begin \n  clk_cnt <= 0; \n  direction <= 8'b0; \n  left_key_last <= 0; \n  right_key_last <= 0; \n  up_key_last <= 0; \n  down_key_last <= 0; \n  end \n  else begin \n  if(clk_cnt == 5_0000) begin \n  clk_cnt <= 0; \n  left_key_last <= left; \n  right_key_last <= right; \n  up_key_last <= up; \n  down_key_last <= down; \n  if(left_key_last == 0 && left == 1) \n  direction <= 8'b0000_0001; \n  if(right_key_last == 0 && right == 1) \n  direction <= 8'b0000_0010; \n  if(up_key_last == 0 && up == 1) \n  direction <= 8'b0000_0011; \n  if(down_key_last == 0 && down == 1) \n  direction <= 8'b0000_0100; \n  end \n  else begin \n  clk_cnt <= clk_cnt + 1; \n  direction <= 8'b0000_0000; \n  end \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe `camera` module implements the functionality of a camera system. It is sensitive to both the refclk and reset_n inputs, generating outputs for pixclk, vsync, hsync, and data.\n\nThe module maintains counters for tracking the horizontal and vertical positions. It assigns pixclk to refclk and uses a separate clock signal, clk2, to synchronize operations.\n\nOn the negative edge of refclk, the module resets the counters if reset_n is low. Otherwise, it increments the counters and manages pixel counting.\n\nThe module outputs the data signal based on temp_data and sets vsync and hsync signals based on the vertical and horizontal counters.\n\n Module header:\n\nmodule camera (input refclk,input reset_n,output pixclk,output vsync,output hsync,output [7:0] data);\n [/INST]\n", "output": "reg [12:0] hs_counter = 0; \n reg [9:0] vs_counter = 0; \n assign pixclk = refclk; \n always @(negedge refclk) \n begin \n  if(reset_n == 0) \n  begin \n  hs_counter = 0; \n  vs_counter = 0; \n  end \n  else \n  begin \n  if(hs_counter == 1567) \n  begin \n  hs_counter <= 0; \n  if(vs_counter == 510) \n  vs_counter <= 0; \n  else \n  vs_counter <= vs_counter + 1; \n  end \n  else \n  hs_counter <= hs_counter + 1; \n  end \n end \n reg clk2 = 0; \n always@(negedge refclk) \n clk2 <= !clk2; \n reg [16:0] pixel_counter = 0; \n always@(posedge clk2) \n begin \n  if(hs_counter == 1566) \n  pixel_counter <= 0; \n  else \n  pixel_counter <= pixel_counter + 1; \n end \n reg [7:0] temp_data; \n wire [15:0] line_counter; \n reg [15:0] line_counter_2; \n reg data_part = 0; \n always@(negedge refclk) \n begin \n if(reset_n == 0) \n  begin \n  data_part <= 0; \n  temp_data <= 0; \n  end \n else \n begin \n  if(!clk2) \n  temp_data[7:0] <= pixel_counter[15:8]; \n  else \n  temp_data[7:0] <= pixel_counter[7:0]; \n end \n end \n assign data = temp_data; \n assign vsync = vs_counter < 3 && reset_n != 0 ? 1 : 0; \n assign hsync = vs_counter > 19 && vs_counter < 500 && hs_counter < 1280 && reset_n != 0 ? 1 : 0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `sram_sim` simulates a static random-access memory (SRAM) with a 64Kx8 memory array. It initializes the memory with specific patterns and provides read and write functionality. The input `a` is used to address the memory, `d` is the bidirectional data bus, and `we_n` is the write enable signal. The module initializes the memory during simulation and updates the memory content based on the write enable signal. When the write enable signal is low, the module updates the memory content, and when the write enable signal is high, it outputs the data from the specified memory location.\n\n Module header:\n\nmodule sram_sim (input wire [15:0] a,inout wire [7:0] d,input wire we_n);\n [/INST]\n", "output": "reg [7:0] m[0:65535]; \n  reg [7:0] dout; \n  integer i; \n  initial begin \n  for (i=0;i<65536;i=i+1) \n  m[i] = {i[15:14],i[5:0]}; \n  end \n  assign d = (we_n == 1'b0)? 8'hZZ : dout; \n  always @* begin \n  if (we_n == 1'b0) begin \n  #35; \n  m[a] = d; \n  end \n  end \n  always @* begin \n  if (we_n == 1'b1) begin \n  #45; \n  dout = m[a]; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a Carry Look-Ahead adder (CLA) that performs addition on two input operands with an optional carry-in. It generates the sum result, carry-out, and two auxiliary outputs p and g using logic operations on the input operands and intermediate signals. The module uses generate loops to calculate the intermediate signals and the final sum result.\n\n Module header:\n\nmodule CLA(operand1, operand2, carryIn, result, carryOut, p, g);\n [/INST]\n", "output": "parameter bits = 4; \n input wire [bits-1:0] operand1; \n input wire [bits-1:0] operand2; \n input wire carryIn; \n output wire [bits-1:0] result; \n output wire carryOut; \n output wire p; \n output wire g; \n wire bitsP [bits-1:0]; \n wire bitsG [bits-1:0]; \n wire innerP [bits-1:0]; \n wire innerG [bits-1:0]; \n wire resC [bits-1:0]; \n assign p = innerP[bits-1]; \n assign g = innerG[bits-1]; \n assign resC[0] = carryIn; \n assign innerG[0] = bitsG[0]; \n assign innerP[0] = bitsP[0]; \n genvar gi; \n generate \n  for(gi = 0;gi < bits;gi = gi + 1) begin \n  assign bitsP[gi] = operand1[gi] | operand2[gi]; \n  assign bitsG[gi] = operand1[gi] & operand2[gi]; \n  end \n endgenerate \n assign carryOut = g | (p & carryIn); \n genvar gj; \n generate \n  for(gj = 1;gj < bits;gj = gj + 1) begin \n  assign innerG[gj] = bitsG[gj] | (bitsP[gj] & innerG[gj-1]); \n  assign innerP[gj] = bitsP[gj] & innerP[gj-1]; \n  assign resC[gj] = innerG[gj-1] | (innerP[gj-1] & carryIn); \n  end \n endgenerate \n genvar gk; \n generate \n  for(gk = 0;gk < bits;gk = gk + 1) begin \n  assign result[gk] = operand1[gk]^operand2[gk]^resC[gk]; \n  end \n endgenerate \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module represents a CRC (Cyclic Redundancy Check) block with clock and shift enable input signals, along with CRC error and register output signals. The module initializes the CRC error and register output signals to 0. Additionally, it defines parameters for oscillator divider, LPM type, CRC delay disable, error delay, and error DRA-DL bypass. The module is designed to perform CRC checks and handle error detection within a larger system.\n\n Module header:\n\nmodule arriaiigz_crcblock (clk,shiftnld,crcerror,regout);\n [/INST]\n", "output": "input clk; \n input shiftnld; \n output crcerror; \n output regout; \n assign crcerror = 1'b0; \n assign regout = 1'b0; \n parameter oscillator_divider = 1; \n parameter lpm_type = \"arriaiigz_crcblock\"; \n parameter crc_deld_disable = \"off\"; \n parameter error_delay = 0 ; \n parameter error_dra_dl_bypass = \"off\"; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, \"MultiplyState,\" performs a multiplication operation. It takes input signals aout_Special, bout_Special, cout_Special, zout_Special, sout_Special, modeout_Special, operationout_Special, NatLogFlagout_Special, and InsTag_Special. It also takes clock and idle_Special as input signals. \n\nThe module then performs calculations on the inputs using the clock signal and assigns the results to the output registers idle_Multiply, cout_Multiply, zout_Multiply, sout_Multiply, modeout_Multiply, operationout_Multiply, NatLogFlagout_Multiply, productout_Multiply, and InsTag_Multiply. \n\nIt also performs different operations based on the values of modeout_Special and idle_Special. If idle_Special is no_idle, it executes a multiplication process based on modeout_Special and assigns the result to zout_Multiply, sout_Multiply, cout_Multiply, and productout_Multiply. \n\nThe module then checks if the multiplication result is negative and updates the zout_Multiply accordingly. Finally, it assigns the results to the output registers according to the specified conditions.\n\n Module header:\n\nmodule MultiplyState(input [32:0] aout_Special,input [32:0] bout_Special,input [35:0] cout_Special,input [35:0] zout_Special,input [31:0] sout_Special,input [1:0] modeout_Special,input operationout_Special,input NatLogFlagout_Special,input [7:0] InsTag_Special,input clock,input [1:0] idle_Special,output reg [1:0] idle_Multiply,output reg [35:0] cout_Multiply,output reg [35:0] zout_Multiply,output reg [31:0] sout_Multiply,output reg [1:0] modeout_Multiply,output reg operationout_Multiply,output reg NatLogFlagout_Multiply,output reg [49:0] productout_Multiply,output reg [7:0] InsTag_Multiply);\n [/INST]\n", "output": "parameter mode_circular =2'b01, \n  mode_linear =2'b00, \n  mode_hyperbolic=2'b11; \n parameter no_idle = 2'b00, \n  allign_idle = 2'b01, \n  put_idle = 2'b10; \n wire a_sign; \n wire [7:0] a_exponent; \n wire [23:0] a_mantissa; \n wire b_sign; \n wire [7:0] b_exponent; \n wire [23:0] b_mantissa; \n assign a_sign = aout_Special[32]; \n assign a_exponent = aout_Special[31:24] - 127; \n assign a_mantissa = {aout_Special[23:0]}; \n assign b_sign = bout_Special[32]; \n assign b_exponent = bout_Special[31:24] - 127; \n assign b_mantissa = {bout_Special[23:0]}; \n always @ (posedge clock) \n begin \n  InsTag_Multiply <= InsTag_Special; \n  sout_Multiply <= sout_Special; \n  cout_Multiply <= cout_Special; \n  modeout_Multiply <= modeout_Special; \n  operationout_Multiply <= operationout_Special; \n  idle_Multiply <= idle_Special; \n  NatLogFlagout_Multiply <= NatLogFlagout_Special; \n  if (idle_Special == no_idle) begin \n  if (modeout_Special == mode_circular) begin \n  zout_Multiply[35] <= a_sign ^ b_sign; \n  end \n  else if (modeout_Special == mode_hyperbolic) begin \n  zout_Multiply[35] <= ~(a_sign ^ b_sign); \n  end \n  zout_Multiply[34:27] <= a_exponent + b_exponent + 1; \n  zout_Multiply[26:0] <= 0; \n  productout_Multiply <= a_mantissa * b_mantissa * 4; \n  end \n  else begin \n  zout_Multiply <= zout_Special; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a simple multiplier that takes two 32-bit input numbers and multiplies them. It has an enable input to start the multiplication and an accumulate input to add the input numbers. The module operates on the rising edge of the clock signal and includes a reset functionality. It also has outputs for the result of the multiplication, flags indicating whether the result is zero or negative, and a signal to indicate when the multiplication is done.\n\n Module header:\n\nmodule a23_multiply (input i_clk,input i_rst,input [31:0] i_a_in,input [31:0] i_b_in,input [1:0] i_function,input i_execute,output [31:0] o_out,output [1:0] o_flags,output o_done);\n [/INST]\n", "output": "wire enable; \n wire accumulate; \n reg [31:0] product; \n reg [3:0] count; \n assign enable = i_function[0]; \n assign accumulate = i_function[1]; \n assign o_out = product; \n assign o_flags = {o_out[31], o_out == 32'd0 }; \n assign o_done = 1'b1; \n always @(posedge i_clk or posedge i_rst) begin \n  if (i_rst) begin \n  product <= 32'b0; \n  count <= 4'b0; \n  end else if(enable) begin \n  count <= count + 1; \n  if (i_execute && count == 0) begin \n  product <= i_a_in*i_b_in; \n  end else if (i_execute && accumulate && count == 3) begin \n  product <= product + i_a_in; \n  end \n  end else begin \n  product <= 32'b0; \n  count <= 4'b0; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module is an asynchronous RAM with a single port. It has a parameterized width of 64 and a size of 128. It takes input position, enable, and input data, and outputs data. The module uses a data array to store values. When enabled, it either sets the input data at the specified position or retrieves the data from that position and outputs it.\n\n Module header:\n\nmodule async_ram_1port #(parameter Width = 64, Size=128) ( input [`log2(Size)-1:0] p0_pos,input p0_enable,input [Width-1:0] p0_in_data,output reg [Width-1:0] p0_out_data);\n [/INST]\n", "output": "reg [Width-1:0] data [Size-1:0]; \n  reg [Width-1:0] d0; \n  always_comb begin \n  if (p0_enable) begin \n  d0 = 'b0; \n  end else begin \n  d0 = data[p0_pos]; \n  end \n  end \n  always @(p0_pos or p0_in_data or p0_enable) begin \n  if (p0_enable) begin \n  data[p0_pos] = p0_in_data; \n  end \n  end \n  always_comb begin \n  p0_out_data = d0; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a pseudorandom binary sequence (PRBS) generator with a configurable width. It uses a linear feedback shift register (LFSR) to generate the PRBS output based on the PRBS_WIDTH parameter. The module has a clock input, a reset input, a clock enable input, and an output for the PRBS sequence. The LFSR is updated on the positive edge of the clock signal, and the PRBS sequence is generated accordingly. The module uses logic to update the LFSR based on the feedback and shift operations to produce the PRBS output.\n\n Module header:\n\nmodule prbs_gen # (parameter PRBS_WIDTH = 4) (input clk,input clk_en,input rst,output [PRBS_WIDTH-1:0] prbs_o);\n [/INST]\n", "output": "localparam PRBS_OFFSET = 0; \n reg [PRBS_WIDTH - 1:0] Next_LFSR_Reg; \n reg [PRBS_WIDTH - 1:0] LFSR_Reg; \n reg [3:0] prbs_shift_value; \n reg Bits_all, Feedback; \n integer i; \n always @ (posedge clk) \n begin \n  if (rst ) \n  LFSR_Reg <= {{PRBS_WIDTH-1{1'b0}},1'b1}; \n  else if (clk_en) begin \n  if ( PRBS_OFFSET == 0) \n  LFSR_Reg <= Next_LFSR_Reg; \n  prbs_shift_value <= {prbs_shift_value[2:0],LFSR_Reg[PRBS_WIDTH-1]}; \n  end \n end \n always @ (LFSR_Reg) \n begin :LFSR_Next \n  Bits_all = ~| LFSR_Reg[PRBS_WIDTH-2:0]; \n  Feedback = LFSR_Reg[PRBS_WIDTH-1]^Bits_all; \n  for (i = PRBS_WIDTH - 1; i >= 1 ; i = i-1) \n  Next_LFSR_Reg[i] = LFSR_Reg[i-1]; \n  case (PRBS_WIDTH) \n  32'd4: \n  Next_LFSR_Reg[0] = Feedback^LFSR_Reg[2]; \n  32'd8: \n  Next_LFSR_Reg[0] = Feedback^LFSR_Reg[3]^LFSR_Reg[4]^LFSR_Reg[5]; \n  32'd10: \n  Next_LFSR_Reg[0] = Feedback^LFSR_Reg[6]; \n  32'd14: \n  Next_LFSR_Reg[0] = Feedback^LFSR_Reg[0]^LFSR_Reg[2]^LFSR_Reg[4]; \n  32'd24: \n  Next_LFSR_Reg[0] = Feedback^LFSR_Reg[16]^LFSR_Reg[21]^LFSR_Reg[22]; \n  32'd32: \n  Next_LFSR_Reg[0] = Feedback^LFSR_Reg[0]^LFSR_Reg[1]^LFSR_Reg[21]; \n  32'd42: \n  Next_LFSR_Reg[0] = Feedback^LFSR_Reg[18]^LFSR_Reg[19]^LFSR_Reg[40]; \n  32'd56: \n  Next_LFSR_Reg[0] = Feedback^LFSR_Reg[33]^LFSR_Reg[34]^LFSR_Reg[54]; \n  32'd64: \n  Next_LFSR_Reg[0] = Feedback^LFSR_Reg[59]^LFSR_Reg[60]^LFSR_Reg[62]; \n  32'd72: \n  Next_LFSR_Reg[0] = Feedback^LFSR_Reg[18]^LFSR_Reg[24]^LFSR_Reg[65]; \n  default: \n  Next_LFSR_Reg[0] = Feedback^LFSR_Reg[59]^LFSR_Reg[60]^LFSR_Reg[62]; \n  endcase \n end \n assign prbs_o = LFSR_Reg; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a parametrized enable flop, where the width of the flop is determined by the parameter WIDTH. It takes inputs clk (clock), oe_e1 (output enable), and a (data input), and outputs q (flop output). Inside the module, it uses reg for the output enable register and the flop register. The module includes a generate block that iterates over the datapath bits and instantiates enflop_one for each bit. The output enable signals are updated on the rising edge of the clock, and the final output value is assigned based on the output enables and flop outputs.\n\n Module header:\n\nmodule enflop (clk, oe_e1, a,q);\n [/INST]\n", "output": "parameter WIDTH=1; \n  input clk; \n  input oe_e1; \n  input [WIDTH-1:0] a; \n  output [WIDTH-1:0] q; \n  reg [WIDTH-1:0] oe_r; \n  reg [WIDTH-1:0] q_r; \n  genvar i; \n  generate \n  for (i = 0; i < WIDTH; i = i + 1) begin : datapath_bits \n  enflop_one enflop_one \n (.clk (clk),.d (a[i]),.q_r (q_r[i])); \n  always @(posedge clk) oe_r[i] <= oe_e1; \n  assign q[i] = oe_r[i] ? q_r[i] : 1'bx; \n  end \n  endgenerate \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, named or1200_tt, implements the OR1200 TT module. It takes various input signals such as clk, rst, du_stall, spr_cs, spr_write, spr_addr, spr_dat_i, and outputs spr_dat_o and intr. The module includes logic for TTMR and TTCR registers, selection signals, pattern match, restart, stop, and interrupt signals. The module processes the input signals and updates the TTMR and TTCR registers based on specific conditions. It also handles address decoding and interrupt logic. If the OR1200_TT_IMPLEMENTED parameter is defined, the module's functionality is enabled.\n\n Module header:\n\nmodule or1200_tt(clk, rst, du_stall,spr_cs, spr_write, spr_addr, spr_dat_i, spr_dat_o,intr);\n [/INST]\n", "output": "input clk; \n input rst; \n input du_stall; \n input spr_cs; \n input spr_write; \n input [31:0] spr_addr; \n input [31:0] spr_dat_i; \n output [31:0] spr_dat_o; \n output intr; \n `ifdef OR1200_TT_IMPLEMENTED \n `ifdef OR1200_TT_TTMR \n reg [31:0] ttmr; \n `else \n wire [31:0] ttmr; \n `endif \n `ifdef OR1200_TT_TTCR \n reg [31:0] ttcr; \n `else \n wire [31:0] ttcr; \n `endif \n wire ttmr_sel; \n wire ttcr_sel; \n wire match; \n wire restart; \n wire stop; \n reg [31:0] spr_dat_o; \n assign ttmr_sel = (spr_cs && (spr_addr[`OR1200_TTOFS_BITS] == `OR1200_TT_OFS_TTMR)) ? 1'b1 : 1'b0; \n assign ttcr_sel = (spr_cs && (spr_addr[`OR1200_TTOFS_BITS] == `OR1200_TT_OFS_TTCR)) ? 1'b1 : 1'b0; \n `ifdef OR1200_TT_TTMR \n always @(posedge clk or posedge rst) \n  if (rst) \n  ttmr <= 32'b0; \n  else if (ttmr_sel && spr_write) \n  ttmr <= #1 spr_dat_i; \n  else if (ttmr[`OR1200_TT_TTMR_IE]) \n  ttmr[`OR1200_TT_TTMR_IP] <= #1 ttmr[`OR1200_TT_TTMR_IP] | (match & ttmr[`OR1200_TT_TTMR_IE]); \n `else \n assign ttmr = {2'b11, 30'b0}; \n `endif \n `ifdef OR1200_TT_TTCR \n always @(posedge clk or posedge rst) \n  if (rst) \n  ttcr <= 32'b0; \n  else if (restart) \n  ttcr <= #1 32'b0; \n  else if (ttcr_sel && spr_write) \n  ttcr <= #1 spr_dat_i; \n  else if (!stop) \n  ttcr <= #1 ttcr + 32'd1; \n `else \n assign ttcr = 32'b0; \n `endif \n always @(spr_addr or ttmr or ttcr) \n  case (spr_addr[`OR1200_TTOFS_BITS]) \n `ifdef OR1200_TT_READREGS \n  `OR1200_TT_OFS_TTMR: spr_dat_o = ttmr; \n `endif \n  default: spr_dat_o = ttcr; \n  endcase \n assign match = (ttmr[`OR1200_TT_TTMR_TP] == ttcr[27:0]) ? 1'b1 : 1'b0; \n assign restart = match && (ttmr[`OR1200_TT_TTMR_M] == 2'b01); \n assign stop = match & (ttmr[`OR1200_TT_TTMR_M] == 2'b10) | (ttmr[`OR1200_TT_TTMR_M] == 2'b00) | du_stall; \n assign intr = ttmr[`OR1200_TT_TTMR_IP]; \n `else \n assign intr = 1'b0; \n `ifdef OR1200_TT_READREGS \n assign spr_dat_o = 32'b0; \n `endif \n `endif \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module detects the rising and falling edges of a signal \"sig\" based on the clock input \"clk\" and a reset input \"rst\". The \"sig\" is synchronized to the clock using a 2-bit shift register \"sig_reg\". The \"rise\" output is asserted when there is a rising edge on \"sig\", and the \"fall\" output is asserted when there is a falling edge on \"sig\".\n\n Module header:\n\nmodule edge_detect (input rst,input clk,input sig,output rise,output fall);\n [/INST]\n", "output": "reg [1:0] sig_reg; \n always @(posedge clk or posedge rst) \n  if (rst == 1'b1) \n  sig_reg <= 2'b00; \n  else \n  sig_reg <= {sig_reg[0], sig}; \n assign rise = sig_reg[0] == 1'b1 && sig_reg[1] == 1'b0 ? 1'b1 : 1'b0; \n assign fall = sig_reg[0] == 1'b0 && sig_reg[1] == 1'b1 ? 1'b1 : 1'b0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements the control logic for a processor. It takes a 6-bit opcode as input and sets various control signals based on the opcode. The module sets the ALU operation, memory read and write, register destination, register write enable, ALU source, jump, branch equal, and branch not equal flags based on the opcode. It uses a case statement to determine the control signals for each opcode and assigns the appropriate values to the output control signals.\n\n Module header:\n\nmodule control(input wire [5:0] opcode,output reg branch_eq, branch_ne,output reg [1:0] aluop,output reg memread, memwrite, memtoreg,output reg regdst, regwrite, alusrc,output reg jump);\n [/INST]\n", "output": "always @(*) begin \n  aluop[1:0] <= 2'b10; \n  alusrc <= 1'b0; \n  branch_eq <= 1'b0; \n  branch_ne <= 1'b0; \n  memread <= 1'b0; \n  memtoreg <= 1'b0; \n  memwrite <= 1'b0; \n  regdst <= 1'b1; \n  regwrite <= 1'b1; \n  jump <= 1'b0; \n  case (opcode) \n  6'b100011: begin \n  memread <= 1'b1; \n  regdst <= 1'b0; \n  memtoreg <= 1'b1; \n  aluop[1] <= 1'b0; \n  alusrc <= 1'b1; \n  end \n  6'b001000: begin \n  regdst <= 1'b0; \n  aluop[1] <= 1'b0; \n  alusrc <= 1'b1; \n  end \n  6'b000100: begin \n  aluop[0] <= 1'b1; \n  aluop[1] <= 1'b0; \n  branch_eq <= 1'b1; \n  regwrite <= 1'b0; \n  end \n  6'b101011: begin \n  memwrite <= 1'b1; \n  aluop[1] <= 1'b0; \n  alusrc <= 1'b1; \n  regwrite <= 1'b0; \n  end \n  6'b000101: begin \n  aluop[0] <= 1'b1; \n  aluop[1] <= 1'b0; \n  branch_ne <= 1'b1; \n  regwrite <= 1'b0; \n  end \n  6'b000000: begin \n  end \n  6'b000010: begin \n  jump <= 1'b1; \n  end \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a CRC32 (Cyclic Redundancy Check) calculator. It has clock, data, enable, shift, clear, reset, and serial output inputs, and a 32-bit CRC output. The module uses a 32-bit register to store the CRC value and computes a new CRC value based on the input data and the current CRC value. The CRC value is updated on the rising edge of the clock or when the module is reset or cleared. The serial output corresponds to the least significant bit of the CRC value.\n\n Module header:\n\nmodule adbg_crc32 (clk, data, enable, shift, clr, rst, crc_out, serial_out);\n [/INST]\n", "output": "input clk; \n input data; \n input enable; \n input shift; \n input clr; \n input rst; \n output [31:0] crc_out; \n output serial_out; \n reg [31:0] crc; \n wire [31:0] new_crc; \n assign new_crc[0] = crc[1]; \n assign new_crc[1] = crc[2]; \n assign new_crc[2] = crc[3]; \n assign new_crc[3] = crc[4]; \n assign new_crc[4] = crc[5]; \n assign new_crc[5] = crc[6] ^ data ^ crc[0]; \n assign new_crc[6] = crc[7]; \n assign new_crc[7] = crc[8]; \n assign new_crc[8] = crc[9] ^ data ^ crc[0]; \n assign new_crc[9] = crc[10] ^ data ^ crc[0]; \n assign new_crc[10] = crc[11]; \n assign new_crc[11] = crc[12]; \n assign new_crc[12] = crc[13]; \n assign new_crc[13] = crc[14]; \n assign new_crc[14] = crc[15]; \n assign new_crc[15] = crc[16] ^ data ^ crc[0]; \n assign new_crc[16] = crc[17]; \n assign new_crc[17] = crc[18]; \n assign new_crc[18] = crc[19]; \n assign new_crc[19] = crc[20] ^ data ^ crc[0]; \n assign new_crc[20] = crc[21] ^ data ^ crc[0]; \n assign new_crc[21] = crc[22] ^ data ^ crc[0]; \n assign new_crc[22] = crc[23]; \n assign new_crc[23] = crc[24] ^ data ^ crc[0]; \n assign new_crc[24] = crc[25] ^ data ^ crc[0]; \n assign new_crc[25] = crc[26]; \n assign new_crc[26] = crc[27] ^ data ^ crc[0]; \n assign new_crc[27] = crc[28] ^ data ^ crc[0]; \n assign new_crc[28] = crc[29]; \n assign new_crc[29] = crc[30] ^ data ^ crc[0]; \n assign new_crc[30] = crc[31] ^ data ^ crc[0]; \n assign new_crc[31] = data ^ crc[0]; \n always @ (posedge clk or posedge rst) \n begin \n  if(rst) \n  crc[31:0] <= #1 32'hffffffff; \n  else if(clr) \n  crc[31:0] <= #1 32'hffffffff; \n  else if(enable) \n  crc[31:0] <= #1 new_crc; \n  else if (shift) \n  crc[31:0] <= #1 {1'b0, crc[31:1]}; \n end \n assign crc_out = crc; \n assign serial_out = crc[0]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module is a clap detection state machine. It uses the mic_sample input to detect claps based on a predefined threshold. The state machine transitions through different states - waiting for a clap, delaying to confirm the clap, toggling the home state, and resetting. The delay values for different states are predefined constants. The debug output provides the current state of the state machine. The home_state output indicates whether the state machine is in the \"home\" state or not.\n\n Module header:\n\nmodule Claps(input clk_48,input rst,input [9:0] mic_sample,output reg home_state,output [3:0] debug);\n [/INST]\n", "output": "reg [2:0] state, state_d; \n  reg [2:0] state_after, state_after_d; \n  reg [31:0] delay, delay_d; \n  reg home_state_d; \n  localparam THRESHOLD = 10'd770; \n  localparam DELAY_SIM = 32'h4; \n  localparam DELAY_QUARTERSEC = 32'hB71B00; \n  localparam DELAY_2SEC = 32'h5B8D800; \n  localparam WAIT_CLAP1 = 3'd0, \n  DELAY_CLAP2 = 3'd1, \n  WAIT_CLAP2 = 3'd2, \n  TOGGLE_STATE = 3'd3, \n  DELAY_RESET = 3'd4; \n  assign debug = state; \n  always @ (posedge clk_48 or posedge rst) begin \n  if(rst) begin \n  state <= WAIT_CLAP1; \n  state_after <= WAIT_CLAP1; \n  delay <= 32'h0; \n  home_state <= 1'b0; \n  end else begin \n  state <= state_d; \n  state_after <= state_after_d; \n  delay <= delay_d; \n  home_state <= home_state_d; \n  end \n  end \n  always @ (*) begin \n  state_d = state; \n  state_after_d = state_after; \n  delay_d = delay; \n  home_state_d = home_state; \n  case(state) \n  WAIT_CLAP1: begin \n  if(mic_sample > THRESHOLD) begin \n  state_d = DELAY_CLAP2; \n  delay_d = DELAY_QUARTERSEC; \n  end else \n  state_d = WAIT_CLAP1; \n  end \n  DELAY_CLAP2: begin \n  if(delay == 32'b0) begin \n  state_d = WAIT_CLAP2; \n  delay_d = DELAY_2SEC; \n  end else \n  delay_d = delay - 1'b1; \n  end \n  WAIT_CLAP2: begin \n  if(delay == 32'b0) begin \n  state_d = WAIT_CLAP1; \n  end else begin \n  delay_d = delay - 1'b1; \n  if(mic_sample > THRESHOLD) \n  state_d = TOGGLE_STATE; \n  else \n  state_d = WAIT_CLAP2; \n  end \n  end \n  TOGGLE_STATE: begin \n  state_d = DELAY_RESET; \n  delay_d = DELAY_2SEC; \n  if(home_state == 1'b1) \n  home_state_d = 1'b0; \n  else \n  home_state_d = 1'b1; \n  end \n  DELAY_RESET: begin \n  if(delay == 32'b0) \n  state_d = WAIT_CLAP1; \n  else \n  delay_d = delay - 1'b1; \n  end \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module implements a content-addressable memory (CAM) cell. It stores and matches input data based on a match condition. The module has registers for storing data, care bits, and control signals. It also generates a bit match signal for each bit in the data. When the clock signal is negated, it computes the encode_out based on the first matching bit. Additionally, it updates the match output based on the bitwise AND of the bit_match and cell_used signals.\n\n Module header:\n\nmodule reg_cam_cell (clk,rst,wdata,wcare,wused,wena,lookup_data,match);\n [/INST]\n", "output": "parameter DATA_WIDTH = 32; \n input clk,rst; \n input [DATA_WIDTH-1:0] wdata, wcare; \n input wused,wena; \n input [DATA_WIDTH-1:0] lookup_data; \n output match; \n reg match; \n reg cell_used; \n reg [DATA_WIDTH - 1 : 0] data; \n reg [DATA_WIDTH - 1 : 0] care; \n always @(posedge clk) begin \n  if (rst) begin \n  cell_used <= 1'b0; \n  data <= {DATA_WIDTH{1'b0}}; \n  care <= {DATA_WIDTH{1'b0}}; \n  end else begin \n  if (wena) begin \n  cell_used <= wused; \n  data <= wdata; \n  care <= wcare; \n  end \n  end \n end \n wire [DATA_WIDTH-1:0] bit_match; \n genvar i; \n generate \n  for (i=0; i<DATA_WIDTH; i=i+1) \n  begin : bmt \n  assign bit_match[i] = !care[i] | !(data[i] ^ lookup_data[i]); \n  end \n endgenerate \n reg [4:0] encode_out; \n integer j,k; \n always @(negedge clk) begin \n  j = 0; \n  for (k=0; k < DATA_WIDTH; k=k+1) \n  if (bit_match[k] == 1'b1) \n  j = k; \n  encode_out = j; \n end \n always @(posedge clk) begin \n  if (rst) match <= 1'b0; \n  else match <= (& bit_match) & cell_used; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module 'SquareChan' is a representation of a sound channel in a digital synthesizer. It uses various input signals such as clk, ce, reset, and several others to control the generation of a synthesized square wave sound.\n\nThe module contains numerous registers and logic to control the duty cycle, length counter, volume, envelope, sweep, and sequence position. The module has logic for initializing, resetting, and updating these internal registers based on different input conditions, such as ce, reset, MW, LenCtr_Clock, Env_Clock, and Enabled.\n\nThe generated square wave sound is represented by the 'Sample' output, which is determined based on the duty cycle, length counter, volume, and envelope. The 'IsNonZero' output indicates whether the length counter is non-zero.\n\nOverall, the module performs the necessary logic and control to generate a square wave sound based on the input signals and internal registers' state.\n\n Module header:\n\nmodule SquareChan(input clk, input ce, input reset, input sq2,input [1:0] Addr,input [7:0] DIN,input MW,input LenCtr_Clock,input Env_Clock,input Enabled,input [7:0] LenCtr_In,output reg [3:0] Sample,output IsNonZero);\n [/INST]\n", "output": "reg [7:0] LenCtr; \n reg [1:0] Duty; \n reg EnvLoop, EnvDisable, EnvDoReset; \n reg [3:0] Volume, Envelope, EnvDivider; \n wire LenCtrHalt = EnvLoop; \n assign IsNonZero = (LenCtr != 0); \n reg SweepEnable, SweepNegate, SweepReset; \n reg [2:0] SweepPeriod, SweepDivider, SweepShift; \n reg [10:0] Period; \n reg [11:0] TimerCtr; \n reg [2:0] SeqPos; \n wire [10:0] ShiftedPeriod = (Period >> SweepShift); \n wire [10:0] PeriodRhs = (SweepNegate ? (~ShiftedPeriod + {10'b0, sq2}) : ShiftedPeriod); \n wire [11:0] NewSweepPeriod = Period + PeriodRhs; \n wire ValidFreq = Period[10:3] >= 8 && (SweepNegate || !NewSweepPeriod[11]); \n always @(posedge clk) if (reset) begin \n  LenCtr <= 0; \n  Duty <= 0; \n  EnvDoReset <= 0; \n  EnvLoop <= 0; \n  EnvDisable <= 0; \n  Volume <= 0; \n  Envelope <= 0; \n  EnvDivider <= 0; \n  SweepEnable <= 0; \n  SweepNegate <= 0; \n  SweepReset <= 0; \n  SweepPeriod <= 0; \n  SweepDivider <= 0; \n  SweepShift <= 0; \n  Period <= 0; \n  TimerCtr <= 0; \n  SeqPos <= 0; \n  end else if (ce) begin \n  if (MW) begin \n  case(Addr) \n  0: begin \n  Duty <= DIN[7:6]; \n  EnvLoop <= DIN[5]; \n  EnvDisable <= DIN[4]; \n  Volume <= DIN[3:0]; \n  end \n  1: begin \n  SweepEnable <= DIN[7]; \n  SweepPeriod <= DIN[6:4]; \n  SweepNegate <= DIN[3]; \n  SweepShift <= DIN[2:0]; \n  SweepReset <= 1; \n  end \n  2: begin \n  Period[7:0] <= DIN; \n  end \n  3: begin \n  Period[10:8] <= DIN[2:0]; \n  LenCtr <= LenCtr_In; \n  EnvDoReset <= 1; \n  SeqPos <= 0; \n  end \n  endcase \n  end \n  if (TimerCtr == 0) begin \n  TimerCtr <= {Period, 1'b0}; \n  SeqPos <= SeqPos - 1; \n  end else begin \n  TimerCtr <= TimerCtr - 1; \n  end \n  if (LenCtr_Clock && LenCtr != 0 && !LenCtrHalt) begin \n  LenCtr <= LenCtr - 1; \n  end \n  if (LenCtr_Clock) begin \n  if (SweepDivider == 0) begin \n  SweepDivider <= SweepPeriod; \n  if (SweepEnable && SweepShift != 0 && ValidFreq) \n  Period <= NewSweepPeriod[10:0]; \n  end else begin \n  SweepDivider <= SweepDivider - 1; \n  end \n  if (SweepReset) \n  SweepDivider <= SweepPeriod; \n  SweepReset <= 0; \n  end \n  if (Env_Clock) begin \n  if (EnvDoReset) begin \n  EnvDivider <= Volume; \n  Envelope <= 15; \n  EnvDoReset <= 0; \n  end else if (EnvDivider == 0) begin \n  EnvDivider <= Volume; \n  if (Envelope != 0 || EnvLoop) \n  Envelope <= Envelope - 1; \n  end else begin \n  EnvDivider <= EnvDivider - 1; \n  end \n  end \n  if (!Enabled) \n  LenCtr <= 0; \n end \n reg DutyEnabled; \n always @* begin \n  case (Duty) \n  0: DutyEnabled = (SeqPos == 7); \n  1: DutyEnabled = (SeqPos >= 6); \n  2: DutyEnabled = (SeqPos >= 4); \n  3: DutyEnabled = (SeqPos < 6); \n  endcase \n  if (LenCtr == 0 || !ValidFreq || !DutyEnabled) \n  Sample = 0; \n  else \n  Sample = EnvDisable ? Volume : Envelope; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `packet32_tb` simulates a packet generator and verifier with a clock, reset, and clear signal. It instantiates a packet generator and verifier, connecting their input and output ports. The clock signal toggles at regular intervals, and the reset signal initializes the simulation. The `clear` signal is initially set low. The module also declares wires for total, CRC error, sequence error, and length error. The module also initializes a VCD dump file for simulation waveform tracing.\n\n Module header:\n\nmodule packet32_tb();\n [/INST]\n", "output": "wire [35:0] data; \n  wire src_rdy, dst_rdy; \n  wire clear = 0; \n  reg clk = 0; \n  reg reset = 1; \n  always #10 clk <= ~clk; \n  initial #1000 reset <= 0; \n  initial $dumpfile(\"packet32_tb.vcd\"); \n  initial $dumpvars(0,packet32_tb); \n  wire [31:0] total, crc_err, seq_err, len_err; \n packet_generator32 pkt_gen (.clk(clk), .reset(reset), .clear(clear),.data_o(data), .src_rdy_o(src_rdy), .dst_rdy_i(dst_rdy)); \n packet_verifier32 pkt_ver (.clk(clk), .reset(reset), .clear(clear),.data_i(data), .src_rdy_i(src_rdy), .dst_rdy_o(dst_rdy),.total(total), .crc_err(crc_err), .seq_err(seq_err), .len_err(len_err)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements an isolation logic for various signals based on the state of the MBC_ISOLATE signal. When MBC_ISOLATE is high, it forces certain signals, such as LRC_SLEEP, LRC_CLKENB, LRC_RESET, and LRC_ISOLATE, to specific values. Otherwise, it allows these signals to follow their corresponding unisolated inputs. Additionally, it sets the TX_ADDR, TX_DATA, TX_PEND, TX_REQ, TX_PRIORITY, RX_ACK, and TX_RESP_ACK signals based on the state of LRC_ISOLATE. Notably, it generates LRC_SLEEPB as the complement of LRC_SLEEP, and LRC_CLKEN based on the complement of LRC_CLKENB.\n\n Module header:\n\nmodule mbus_isolation_testbench(input MBC_ISOLATE,input [`MBUSTB_ADDR_WIDTH-1:0] TX_ADDR_uniso,input [`MBUSTB_DATA_WIDTH-1:0] TX_DATA_uniso,input TX_PEND_uniso,input TX_REQ_uniso,input TX_PRIORITY_uniso,input RX_ACK_uniso,input TX_RESP_ACK_uniso,output reg [`MBUSTB_ADDR_WIDTH-1:0] TX_ADDR,output reg [`MBUSTB_DATA_WIDTH-1:0] TX_DATA,output reg TX_PEND,output reg TX_REQ,output reg TX_PRIORITY,output reg RX_ACK,output reg TX_RESP_ACK,input LRC_SLEEP_uniso,input LRC_CLKENB_uniso,input LRC_RESET_uniso,input LRC_ISOLATE_uniso,output reg LRC_SLEEP,output LRC_SLEEPB,output reg LRC_CLKENB,output LRC_CLKEN,output reg LRC_RESET,output LRC_RESETB,output reg LRC_ISOLATE);\n [/INST]\n", "output": "assign LRC_SLEEPB = ~LRC_SLEEP; \n  assign LRC_CLKEN = ~LRC_CLKENB; \n  assign LRC_RESETB = ~LRC_RESET; \n  always @* begin \n  if (MBC_ISOLATE) begin \n  LRC_SLEEP = 1; \n  LRC_CLKENB = 1; \n  LRC_RESET = 1; \n  LRC_ISOLATE = 1; \n  end \n  else begin \n  LRC_SLEEP = LRC_SLEEP_uniso; \n  LRC_CLKENB = LRC_CLKENB_uniso; \n  LRC_RESET = LRC_RESET_uniso; \n  LRC_ISOLATE = LRC_ISOLATE_uniso; \n  end \n  end \n  always @* begin \n  if (LRC_ISOLATE) begin \n  TX_ADDR = 0; \n  TX_DATA = 0; \n  TX_PEND = 0; \n  TX_REQ = 0; \n  TX_PRIORITY = 0; \n  RX_ACK = 0; \n  TX_RESP_ACK = 0; \n  end \n  else begin \n  TX_ADDR = TX_ADDR_uniso; \n  TX_DATA = TX_DATA_uniso; \n  TX_PEND = TX_PEND_uniso; \n  TX_REQ = TX_REQ_uniso; \n  TX_PRIORITY = TX_PRIORITY_uniso; \n  RX_ACK = RX_ACK_uniso; \n  TX_RESP_ACK = TX_RESP_ACK_uniso; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a multiplexer that combines inputs from LSInp_0a, LSInp_0d, MSInp_0a, and MSInp_0d based on the value of out_0r, and assigns the result to out_0a and out_0d. When out_0r is asserted, LSInp_0a and LSInp_0d are used, otherwise MSInp_0a and MSInp_0d are used. The output out_0d is a 33-bit vector where the first 17 bits are from LSInp_0d and the remaining 16 bits are from MSInp_0d.\n\n Module header:\n\nmodule BrzCombine_33_17_16 (out_0r, out_0a, out_0d,LSInp_0r, LSInp_0a, LSInp_0d,MSInp_0r, MSInp_0a, MSInp_0d);\n [/INST]\n", "output": "input out_0r; \n  output out_0a; \n  output [32:0] out_0d; \n  output LSInp_0r; \n  input LSInp_0a; \n  input [16:0] LSInp_0d; \n  output MSInp_0r; \n  input MSInp_0a; \n  input [15:0] MSInp_0d; \n  C2 I0 (out_0a, LSInp_0a, MSInp_0a); \n  assign LSInp_0r = out_0r; \n  assign MSInp_0r = out_0r; \n  assign out_0d[0] = LSInp_0d[0]; \n  assign out_0d[1] = LSInp_0d[1]; \n  assign out_0d[2] = LSInp_0d[2]; \n  assign out_0d[3] = LSInp_0d[3]; \n  assign out_0d[4] = LSInp_0d[4]; \n  assign out_0d[5] = LSInp_0d[5]; \n  assign out_0d[6] = LSInp_0d[6]; \n  assign out_0d[7] = LSInp_0d[7]; \n  assign out_0d[8] = LSInp_0d[8]; \n  assign out_0d[9] = LSInp_0d[9]; \n  assign out_0d[10] = LSInp_0d[10]; \n  assign out_0d[11] = LSInp_0d[11]; \n  assign out_0d[12] = LSInp_0d[12]; \n  assign out_0d[13] = LSInp_0d[13]; \n  assign out_0d[14] = LSInp_0d[14]; \n  assign out_0d[15] = LSInp_0d[15]; \n  assign out_0d[16] = LSInp_0d[16]; \n  assign out_0d[17] = MSInp_0d[0]; \n  assign out_0d[18] = MSInp_0d[1]; \n  assign out_0d[19] = MSInp_0d[2]; \n  assign out_0d[20] = MSInp_0d[3]; \n  assign out_0d[21] = MSInp_0d[4]; \n  assign out_0d[22] = MSInp_0d[5]; \n  assign out_0d[23] = MSInp_0d[6]; \n  assign out_0d[24] = MSInp_0d[7]; \n  assign out_0d[25] = MSInp_0d[8]; \n  assign out_0d[26] = MSInp_0d[9]; \n  assign out_0d[27] = MSInp_0d[10]; \n  assign out_0d[28] = MSInp_0d[11]; \n  assign out_0d[29] = MSInp_0d[12]; \n  assign out_0d[30] = MSInp_0d[13]; \n  assign out_0d[31] = MSInp_0d[14]; \n  assign out_0d[32] = MSInp_0d[15]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a register file with two read ports and one write port. It stores 32 32-bit registers. The module supports reading from two registers concurrently and writing to a single register. The read and write operations are synchronized to the clock signal, and the module also initializes the register file to 0 at the start.\n\n Module header:\n\nmodule register(clock_in, readReg1,readReg2, writeReg,writeData,regWrite,readData1,readData2);\n [/INST]\n", "output": "input clock_in; \n  input [25:21] readReg1; \n  input [20:16] readReg2; \n  input [4:0] writeReg; \n  input [31:0] writeData; \n  input regWrite; \n  output [31:0] readData1; \n  output [31:0] readData2; \n  reg[31:0] regFile[31:0]; \n  reg[31:0] readData1; \n  reg[31:0] readData2; \n  integer i; \n  initial \n  begin \n  for(i = 0; i < 32; i = i + 1) \n  regFile[i] = 0; \n  readData1 = 0; \n  readData2 = 0; \n  end \n  always @ (readReg1 or readReg2) \n  begin \n  readData1 = regFile[readReg1]; \n  readData2 = regFile[readReg2]; \n  end \n  always @ (negedge clock_in) \n  begin \n  if(regWrite) \n  regFile[writeReg] = writeData; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"comparator_2\" has inputs d0, d1, d0_idx, d1_idx, d0_dv, d1_dv, and great_n_small, and outputs c_dat, c_idx, and c_dv. It compares d0 and d1 based on their validity and the value of great_n_small, and then sets the output values c_dat, c_idx, and c_dv accordingly. If neither d0 nor d1 is valid, the outputs are set to default values.\n\n Module header:\n\nmodule comperator_2 #(parameter data_wd = 16,idx_wd = 4,hi = 15,lo = 0) (output reg [data_wd-1:0] c_dat,output reg [idx_wd-1 :0] c_idx,output reg c_dv,input wire [data_wd-1:0] d0, d1,input wire [idx_wd-1 :0] d0_idx, d1_idx,input wire d0_dv, d1_dv,input wire great_n_small);\n [/INST]\n", "output": "always @(*) begin \n  if (d0_dv && d1_dv && great_n_small) begin \n  c_dat = (d0[hi:lo] > d1[hi:lo]) ? d0 : d1; \n  c_idx = (d0[hi:lo] > d1[hi:lo]) ? d0_idx : d1_idx; \n  c_dv = 1'b1; \n  end \n  else if (d0_dv && d1_dv && !great_n_small) begin \n  c_dat = (d0[hi:lo] < d1[hi:lo]) ? d0 : d1; \n  c_idx = (d0[hi:lo] < d1[hi:lo]) ? d0_idx : d1_idx; \n  c_dv = 1'b1; \n  end \n  else if (d0_dv && !d1_dv) begin \n  c_dat = d0; \n  c_idx = d0_idx; \n  c_dv = 1'b1; \n  end \n  else if (!d0_dv && d1_dv) begin \n  c_dat = d1; \n  c_idx = d1_idx; \n  c_dv = 1'b1; \n  end \n  else begin \n  c_dat = {data_wd{1'b0}}; \n  c_idx = {idx_wd {1'b0}}; \n  c_dv = 1'b0; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a negative-edge-triggered D flip-flop with asynchronous clear. It takes an input D and clock signal C, and has an asynchronous clear input E. When the clear input E is not asserted, the flip-flop's output Q is updated to the value of the input D on the falling edge of the clock signal C.\n\n Module header:\n\nmodule \\$_DFFE_NN_ (D, C, E, Q);\n [/INST]\n", "output": "input D, C, E; \n output reg Q; \n always @(negedge C) begin \n  if (!E) Q <= D; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module aggregates ADC data and outputs it to a FIFO. It takes in clock and reset signals, data ready signal, data width, and ADC data. The module processes the ADC data based on the data width and byte location, and then pushes the data into the FIFO. The data output and FIFO push signals are updated based on the inputs and internal state.\n\n Module header:\n\nmodule wb_daq_data_aggregation (data_out, fifo_push,wb_clk, wb_rst, data_ready, data_width, adc_data_in);\n [/INST]\n", "output": "parameter dw = 32; \n  parameter adc_dw = 8; \n  input wb_clk; \n  input wb_rst; \n  input data_ready; \n  input [1:0] data_width; \n  input [adc_dw-1:0] adc_data_in; \n  output reg [dw-1:0] data_out; \n  output reg fifo_push; \n  reg [1:0] byte_location; \n  always @(posedge wb_clk) \n  if (wb_rst) begin \n  data_out <= 0; \n  byte_location <= 0; \n  fifo_push <= 0; \n  end else begin \n  if (data_ready) begin \n  if (data_width == 0) begin \n  case (byte_location) \n  0: data_out[07:00] <= adc_data_in; \n  1: data_out[15:08] <= adc_data_in; \n  2: data_out[23:16] <= adc_data_in; \n  3: data_out[31:24] <= adc_data_in; \n  default: data_out <= 0; \n  endcase \n  byte_location <= byte_location + 1; \n  if (byte_location == 3) begin \n  fifo_push <= 1; \n  byte_location <= 0; \n  end \n  end else if (data_width == 1) begin \n  case (byte_location) \n  0: data_out[15:00] <= adc_data_in; \n  1: data_out[31:16] <= adc_data_in; \n  default: data_out <= 0; \n  endcase \n  byte_location <= byte_location + 1; \n  if (byte_location == 1) begin \n  fifo_push <= 1 & !fifo_push; \n  byte_location <= 0; \n  end \n  end else if (data_width == 2) begin \n  data_out <= adc_data_in; \n  fifo_push <= 1; \n  end \n  end else begin \n  fifo_push <= 1'b0; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is designed to generate read status flags for an input FIFO. It takes inputs related to the count register, vertical 1 register, set/reset signal, clock, write enable, and RAM full flag. The module contains two input FIFO compare modules, which compare the input signals and produce the output read status flags. It also uses FDSE (flip-flop with set/reset enable) instances to create and initialize the empty flag registers for the RAM. The output of the module is the read status flags for the input FIFO.\n\n Module header:\n\nmodule input_fifo_rd_status_flags_ss (out,\\gcc0.gc0.count_d1_reg[0] ,\\gcc0.gc0.count_d1_reg[2] ,\\gcc0.gc0.count_d1_reg[4] ,\\gcc0.gc0.count_d1_reg[6] ,\\gcc0.gc0.count_d1_reg[8] ,v1_reg,srst,clk,E,wr_en,ram_full_fb_i_reg);\n [/INST]\n", "output": "output out; \n  input \\gcc0.gc0.count_d1_reg[0] ; \n  input \\gcc0.gc0.count_d1_reg[2] ; \n  input \\gcc0.gc0.count_d1_reg[4] ; \n  input \\gcc0.gc0.count_d1_reg[6] ; \n  input \\gcc0.gc0.count_d1_reg[8] ; \n  input [4:0]v1_reg; \n  input srst; \n  input clk; \n  input [0:0]E; \n  input wr_en; \n  input ram_full_fb_i_reg; \n  wire [0:0]E; \n  wire c1_n_0; \n  wire clk; \n  wire comp1; \n  wire \\gcc0.gc0.count_d1_reg[0] ; \n  wire \\gcc0.gc0.count_d1_reg[2] ; \n  wire \\gcc0.gc0.count_d1_reg[4] ; \n  wire \\gcc0.gc0.count_d1_reg[6] ; \n  wire \\gcc0.gc0.count_d1_reg[8] ; \n  (* DONT_TOUCH *) wire ram_empty_fb_i; \n  (* DONT_TOUCH *) wire ram_empty_i; \n  wire ram_full_fb_i_reg; \n  wire srst; \n  wire [4:0]v1_reg; \n  wire wr_en; \n  assign out = ram_empty_fb_i; \n  input_fifo_compare_1 c1 \n (.E(E),.comp1(comp1),.\\gcc0.gc0.count_d1_reg[0] (\\gcc0.gc0.count_d1_reg[0] ),.\\gcc0.gc0.count_d1_reg[2] (\\gcc0.gc0.count_d1_reg[2] ),.\\gcc0.gc0.count_d1_reg[4] (\\gcc0.gc0.count_d1_reg[4] ),.\\gcc0.gc0.count_d1_reg[6] (\\gcc0.gc0.count_d1_reg[6] ),.\\gcc0.gc0.count_d1_reg[8] (\\gcc0.gc0.count_d1_reg[8] ),.out(ram_empty_fb_i),.ram_empty_i_reg(c1_n_0),.ram_full_fb_i_reg(ram_full_fb_i_reg),.wr_en(wr_en)); \n  input_fifo_compare_2 c2 \n (.comp1(comp1),.v1_reg(v1_reg)); \n  (* DONT_TOUCH *) \n  (* KEEP = \"yes\" *) \n  (* equivalent_register_removal = \"no\" *) \n FDSE #(.INIT(1'b1)) \n  ram_empty_fb_i_reg \n (.C(clk),.CE(1'b1),.D(c1_n_0),.Q(ram_empty_fb_i),.S(srst)); \n  (* DONT_TOUCH *) \n  (* KEEP = \"yes\" *) \n  (* equivalent_register_removal = \"no\" *) \n FDSE #(.INIT(1'b1)) \n  ram_empty_i_reg \n (.C(clk),.CE(1'b1),.D(c1_n_0),.Q(ram_empty_i),.S(srst)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module implements a digital filter tap for signal processing. It processes input samples and applies a tap weight to each input to produce an output tap. The module also accumulates the products of the taps and the input samples to produce the final output. It includes logic for tap initialization and reset, as well as handling of clock signals and ce signals. The module also includes optional features for formal verification.\n\n Module header:\n\nmodule firtap(i_clk, i_reset, i_tap_wr, i_tap, o_tap,i_ce, i_sample, o_sample,i_partial_acc, o_acc);\n [/INST]\n", "output": "parameter IW=16, TW=IW, OW=IW+TW+8; \n  parameter [0:0] FIXED_TAPS=0; \n  parameter [(TW-1):0] INITIAL_VALUE=0; \n  input wire i_clk, i_reset; \n  input wire i_tap_wr; \n  input wire [(TW-1):0] i_tap; \n  output wire signed [(TW-1):0] o_tap; \n  input wire i_ce; \n  input wire signed [(IW-1):0] i_sample; \n  output wire [(IW-1):0] o_sample; \n  input wire [(OW-1):0] i_partial_acc; \n  output wire [(OW-1):0] o_acc; \n  reg [(IW-1):0] delayed_sample; \n  reg signed [(TW+IW-1):0] product; \n  generate \n  if (FIXED_TAPS != 0) \n  assign o_tap = i_tap; \n  else begin \n  reg [(TW-1):0] tap; \n  initial tap = INITIAL_VALUE; \n  always @(posedge i_clk) \n  if (i_tap_wr) \n  tap <= i_tap; \n  assign o_tap = tap; \n  end endgenerate \n  initial o_sample = 0; \n  initial delayed_sample = 0; \n  always @(posedge i_clk) \n  if (i_reset) \n  begin \n  delayed_sample <= 0; \n  o_sample <= 0; \n  end else if (i_ce) \n  begin \n  delayed_sample <= i_sample; \n  o_sample <= delayed_sample; \n  end \n `ifndef FORMAL \n  always @(posedge i_clk) \n  if (i_reset) \n  product <= 0; \n  else if (i_ce) \n  product <= o_tap * i_sample; \n `else \n  wire [(TW+IW-1):0] w_pre_product; \n  abs_mpy #(.AW(TW), .BW(IW), .OPT_SIGNED(1'b1)) \n  abs_bypass(i_clk, i_reset, o_tap, i_sample, w_pre_product); \n  initial product = 0; \n  always @(posedge i_clk) \n  if (i_reset) \n  product <= 0; \n  else if (i_ce) \n  product <= w_pre_product; \n `endif \n  initial o_acc = 0; \n  always @(posedge i_clk) \n  if (i_reset) \n  o_acc <= 0; \n  else if (i_ce) \n  o_acc <= i_partial_acc \n  + { {(OW-(TW+IW)){product[(TW+IW-1)]}}, \n  product }; \n  wire unused; \n  assign unused = i_tap_wr; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a logic function with a 12-bit input and two 64-bit outputs, rc1 and rc2. The logic function sets specific bits of rc1 and rc2 based on the input i. The behavior is defined using always blocks that trigger on changes to the input. The logic expressions in the module calculate the values for the bits of rc1 and rc2 based on specific combinations of the input bits.\n\n Module header:\n\nmodule rconst2in1(i, rc1, rc2);\n [/INST]\n", "output": "input [11:0] i; \n  output [63:0] rc1, rc2; \n  reg [63:0] rc1, rc2; \n  always @ (i) \n  begin \n  rc1 = 0; \n  rc1[0] = i[0] | i[2] | i[3] | i[5] | i[6] | i[7] | i[10] | i[11]; \n  rc1[1] = i[1] | i[2] | i[4] | i[6] | i[8] | i[9]; \n  rc1[3] = i[1] | i[2] | i[4] | i[5] | i[6] | i[7] | i[9]; \n  rc1[7] = i[1] | i[2] | i[3] | i[4] | i[6] | i[7] | i[10]; \n  rc1[15] = i[1] | i[2] | i[3] | i[5] | i[6] | i[7] | i[8] | i[9] | i[10]; \n  rc1[31] = i[3] | i[5] | i[6] | i[10] | i[11]; \n  rc1[63] = i[1] | i[3] | i[7] | i[8] | i[10]; \n  end \n  always @ (i) \n  begin \n  rc2 = 0; \n  rc2[0] = i[2] | i[3] | i[6] | i[7]; \n  rc2[1] = i[0] | i[5] | i[6] | i[7] | i[9]; \n  rc2[3] = i[3] | i[4] | i[5] | i[6] | i[9] | i[11]; \n  rc2[7] = i[0] | i[4] | i[6] | i[8] | i[10]; \n  rc2[15] = i[0] | i[1] | i[3] | i[7] | i[10] | i[11]; \n  rc2[31] = i[1] | i[2] | i[5] | i[9] | i[11]; \n  rc2[63] = i[1] | i[3] | i[6] | i[7] | i[8] | i[9] | i[10] | i[11]; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a 16-bit binary adder-subtractor with various control signals. The inputs arg_0, arg_1, arg_2, arg_3, arg_4, and arg_5 are used to configure the operation of the adder-subtractor. The module computes the sum or difference of arg_0 and arg_1 based on the control signals xs, ys, xn, and yn. The module also computes the carry flag, the difference sign flag, and the negation flag. The output ret_0 represents the result of the operation, while the other output signals provide additional information about the operation.\n\n Module header:\n\nmodule FP16BAddSubS3Of5(input clk,input rst,input [15:0] arg_0,input arg_1,input arg_2,input [7:0] arg_3,input arg_4,input arg_5,output [14:0] ret_0,output ret_1,output ret_2,output [7:0] ret_3,output ret_4,output ret_5,output ret_6);\n [/INST]\n", "output": "wire [15:0] r; \n  wire xs; \n  wire ys; \n  wire [7:0] e; \n  wire xn; \n  wire yn; \n  wire diff_sign; \n  wire with_carry; \n  wire neg; \n  wire [14:0] neg_r; \n  wire [14:0] half_r; \n  wire [14:0] r_diff; \n  wire [14:0] r_same; \n  wire [14:0] r_final; \n  wire [7:0] eplus; \n  wire [7:0] e_final; \n  assign r = arg_0; \n  assign xs = arg_1; \n  assign ys = arg_2; \n  assign e = arg_3; \n  assign xn = arg_4; \n  assign yn = arg_5; \n  assign diff_sign = (xn != yn); \n  assign with_carry = r[15:15]; \n  assign neg_r = (~r) + 1; \n  assign half_r = r[15:1]; \n  assign neg = diff_sign & !with_carry; \n  assign eplus = e + 1; \n  assign r_diff = with_carry ? r[14:0] : neg_r; \n  assign r_same = with_carry ? half_r : r[14:0]; \n  assign r_final = diff_sign ? r_diff : r_same; \n  assign e_final = (!diff_sign && with_carry) ? eplus : e; \n  assign ret_0 = r_final; \n  assign ret_1 = xs; \n  assign ret_2 = ys; \n  assign ret_3 = e_final; \n  assign ret_4 = neg; \n  assign ret_5 = xn; \n  assign ret_6 = yn; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a reset synchronizer for clock domain crossing (CDC). It includes a synchronizer to synchronize the pulse_in signal to the clk_out domain, and an AQ sync flip-flop. The pulse_out output is synchronized with the clk_out domain, and the aq_sync signal is synchronized with the clk_in domain. The synchronizer uses a two-stage flip-flop structure to synchronize the pulse_in signal and the AQ sync signal between different clock domains.\n\n Module header:\n\nmodule cdc_reset_sync (input wire clk_in,input wire pulse_in,input wire clk_out,output wire pulse_out);\n [/INST]\n", "output": "wire aq_sync; \n reg [1:0] in_pre_sync; \n always@(posedge clk_in) begin \n  in_pre_sync[0] <= pulse_in; \n  in_pre_sync[1] <= in_pre_sync[0]; \n end \n reg in_sync_pulse; \n initial in_sync_pulse = 0; \n always@(posedge clk_in) begin \n  if (in_pre_sync[1]) \n  in_sync_pulse <= 1; \n  else if (aq_sync) \n  in_sync_pulse <= 0; \n end \n reg [2:0] out_sync; \n always@(posedge clk_out) begin \n  out_sync[0] <= in_sync_pulse; \n  out_sync[1] <= out_sync[0]; \n  out_sync[2] <= out_sync[1]; \n end \n assign pulse_out = out_sync[2]; \n reg [1:0] aq_sync_ff; \n always@(posedge clk_in) begin \n  aq_sync_ff[0] <= out_sync[2]; \n  aq_sync_ff[1] <= aq_sync_ff[0]; \n end \n assign aq_sync = aq_sync_ff[1]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is designed for interfacing with a 7-segment display. It features various input and output ports for communication with an external memory interface. The module includes a data register, display counter, and various logic for updating the display data and position. It also uses a display decoder to generate the signals for driving the 7-segment display. The module implements functionality to initialize the data register, handle write-back operations, update the display position and data, and drive the display LED based on the input signals and clock cycles. The module also handles reset conditions to ensure proper initialization.\n\n Module header:\n\nmodule wb_7seg_new (clk_i, nrst_i, wb_adr_i, wb_dat_o, wb_dat_i, wb_sel_i, wb_we_i,wb_stb_i, wb_cyc_i, wb_ack_o, wb_err_o, wb_int_o, DISP_SEL, DISP_LED);\n [/INST]\n", "output": "input clk_i; \n  input nrst_i; \n  input [24:1] wb_adr_i; \n  output [15:0] wb_dat_o; \n  input [15:0] wb_dat_i; \n  input [1:0] wb_sel_i; \n  input wb_we_i; \n  input wb_stb_i; \n  input wb_cyc_i; \n  output wb_ack_o; \n  output wb_err_o; \n  output wb_int_o; \n  output reg [3:0] DISP_SEL; \n  output reg [6:0] DISP_LED; \n  reg [15:0] data_reg; \n  reg [6:0] disp_cnt; \n  reg [3:0] disp_data; \n  wire [6:0] disp_data_led; \n  reg [3:0] disp_pos; \n  always @(posedge clk_i or negedge nrst_i) \n  begin \n  if (nrst_i == 0) \n  data_reg <= 16'hABCD; \n  else \n  if (wb_stb_i && wb_we_i) \n  data_reg <= wb_dat_i; \n  end \n  assign wb_ack_o = wb_stb_i; \n  assign wb_err_o = 1'b0; \n  assign wb_int_o = 1'b0; \n  assign wb_dat_o = data_reg; \n  always @(posedge clk_i or negedge nrst_i) \n  begin \n  if (nrst_i == 0) \n  disp_cnt <= 7'b0000000; \n  else \n  disp_cnt <= disp_cnt + 1; \n  end \n  always @(posedge clk_i or negedge nrst_i) \n  begin \n  if (nrst_i == 0) \n  disp_pos <= 4'b0010; \n  else \n  if (disp_cnt == 7'b1111111) \n  disp_pos <= {DISP_SEL[2] , DISP_SEL[1] , DISP_SEL[0] , DISP_SEL[3]}; \n  end \n  always @(posedge clk_i or negedge nrst_i) \n  begin \n  if (nrst_i == 0) \n  disp_data <= 4'b0000; \n  else \n  case (DISP_SEL) \n  4'b1000: disp_data <= data_reg[3:0]; \n  4'b0100: disp_data <= data_reg[7:4]; \n  4'b0010: disp_data <= data_reg[11:8]; \n  4'b0001: disp_data <= data_reg[15:12]; \n  endcase \n  end \n  disp_dec u0 (disp_data, disp_data_led); \n  always @(posedge clk_i or negedge nrst_i) \n  begin \n  if (nrst_i == 0) \n  DISP_LED <= 7'b0000000; \n  else \n  DISP_LED <= disp_data_led; \n  end \n  always @(posedge clk_i or negedge nrst_i) \n  begin \n  if (nrst_i == 0) \n  DISP_SEL <= 0; \n  else \n  DISP_SEL <= disp_pos; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module instantiates a 16K x 32-bit RAM module and connects it to input and output signals. The RAM module uses a clock signal CLK1, address inputs A1ADDR and B1ADDR, data inputs A1DATA and B1DATA, and enable signals A1EN and B1EN for reading and writing data. The parameter INIT initializes the RAM with 4096 32-bit words. The module includes a WENB wire to assign the write enable signal, which is set to all 1s (32'hFFFFFFFF). This module effectively provides an interface for accessing and manipulating the 16K x 32-bit RAM module.\n\n Module header:\n\nmodule \\$__QLF_RAM16K_M0 (CLK1, A1ADDR, A1DATA, A1EN, B1ADDR, B1DATA, B1EN);\n [/INST]\n", "output": "parameter [4095:0] INIT = 4096'bx; \n  input CLK1; \n  input [8:0] A1ADDR; \n  output [31:0] A1DATA; \n  input A1EN; \n  input [8:0] B1ADDR; \n  input [31:0] B1DATA; \n  input B1EN; \n  wire [31:0] WENB; \n  assign WENB = 32'hFFFFFFFF; \n  \\$__QLF_RAM16K #() \n _TECHMAP_REPLACE_ (.RDATA(A1DATA),.RADDR(A1ADDR),.RCLK (CLK1 ),.RE (A1EN ),.WDATA(B1DATA),.WADDR(B1ADDR),.WCLK (CLK1 ),.WE (B1EN ),.WENB (WENB )); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes two input signals A and B and produces the logical OR of these signals at the output P.\n\n Module header:\n\nmodule Pi(input A, input B, output P);\n [/INST]\n", "output": "assign P = A|B; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module is a VGA FIFO that takes in a 64-bit input and produces a 16-bit output. It has storage registers for 64-bit input data and produces and consumes signals for managing the data flow. The module includes logic for resetting the produce, consume, and level signals, and for storing and outputting the data. It operates on a system clock and has a reset signal to control its behavior. The level counter is used to determine if data is available for output.\n\n Module header:\n\nmodule vgafb_fifo64to16(input sys_clk,input vga_rst,input stb,input [63:0] di,output do_valid,output reg [15:0] do,input next);\n [/INST]\n", "output": "reg [63:0] storage[0:3]; \n reg [1:0] produce; \n reg [3:0] consume; \n reg [4:0] level; \n wire [63:0] do64; \n assign do64 = storage[consume[3:2]]; \n always @(*) begin \n  case(consume[1:0]) \n  2'd0: do <= do64[63:48]; \n  2'd1: do <= do64[47:32]; \n  2'd2: do <= do64[31:16]; \n  2'd3: do <= do64[15:0]; \n  endcase \n end \n always @(posedge sys_clk) begin \n  if(vga_rst) begin \n  produce = 2'd0; \n  consume = 4'd0; \n  level = 5'd0; \n  end else begin \n  if(stb) begin \n  storage[produce] = di; \n  produce = produce + 2'd1; \n  level = level + 5'd4; \n  end \n  if(next) begin \n  consume = consume + 4'd1; \n  level = level - 5'd1; \n  end \n  end \n end \n assign do_valid = ~(level == 5'd0); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a dual-port RAM with fast access. It has separate write and read ports, and it supports concurrent read and write operations. The module interfaces with the asynchronous RAM module `async_ram_2port` to handle the read and write operations. The module includes logic for handling retry operations for both write and read requests. The read data is synchronized using a flip-flop `fflop` before being output.\n\n Module header:\n\nmodule ram_2port_fast #(parameter Width = 64, Size=128, Forward=0) (input clk,input reset,input req_wr_valid,output req_wr_retry,input [`log2(Size)-1:0] req_wr_addr,input [Width-1:0] req_wr_data,input req_rd_valid,output req_rd_retry,input [`log2(Size)-1:0] req_rd_addr,output ack_rd_valid,input ack_rd_retry,output [Width-1:0] ack_rd_data);\n [/INST]\n", "output": "logic [Width-1:0] ack_rd_data_next; \n  logic [Width-1:0] ack_wr_data_next; \n  async_ram_2port \n  #(.Width(Width), .Size(Size)) \n ram (.p0_pos (req_wr_addr),.p0_enable (req_wr_valid),.p0_in_data (req_wr_data),.p0_out_data (ack_wr_data_next),.p1_pos (req_rd_addr),.p1_enable (1'b0),.p1_in_data ('b0),.p1_out_data (ack_rd_data_next)); \n  assign req_wr_retry = 0; \n fflop #(.Size(Width)) f1 (.clk (clk),.reset (reset),.din (ack_rd_data_next),.dinValid (req_rd_valid),.dinRetry (req_rd_retry),.q (ack_rd_data),.qValid (ack_rd_valid),.qRetry (ack_rd_retry)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, named RegUN, is designed to implement a register with a configurable width. It has inputs for the clock signal, the enable signal, and the data input, and outputs the stored data. The register is initialized with a default value if the module has no initial blocks. The main functionality is within an always block that triggers on the positive edge of the clock signal. When the enable signal is asserted, the data input is assigned to the output with a specified delay. Overall, the module serves as a configurable width register with synchronous loading of data on the positive edge of the clock signal when the enable signal is active.\n\n Module header:\n\nmodule RegUN(CLK, EN, D_IN, Q_OUT);\n [/INST]\n", "output": "parameter width = 1; \n  input CLK; \n  input EN; \n  input [width - 1 : 0] D_IN; \n  output [width - 1 : 0] Q_OUT; \n  reg [width - 1 : 0] Q_OUT; \n `ifdef BSV_NO_INITIAL_BLOCKS \n `else \n  initial begin \n  Q_OUT = {((width + 1)/2){2'b10}} ; \n  end \n `endif \n  always@(posedge CLK) \n  begin \n  if (EN) \n  Q_OUT <= `BSV_ASSIGNMENT_DELAY D_IN; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an I2S clock controller with several input and output ports. It contains command registers cmd_reg1 and cmd_reg2, which are selected based on the input address paddr. The master_slave_mode and clk_sel_48_44 outputs are controlled by bits in cmd_reg1. The module also contains logic for writing to and reading from the command registers based on the penable and pwrite signals.\n\nThe clock selection and mode control signals are generated based on the values of cmd_reg1 and cmd_reg2. Additionally, there are audio clock generators for both playback and capture, which produce the master clock (mclk), bit clock (bclk), and left/right clock (playback_lrclk and capture_lrclk) signals.\n\nThe output signals are selected based on the master/slave mode and clock selection, or driven by external signals. The pready output is directly connected to the penable input.\n\n Module header:\n\nmodule i2s_clkctrl_apb (input clk,input reset_n,input [4:0] paddr,input penable,input pwrite,input [31:0] pwdata,input psel,output reg [31:0] prdata,output pready,input clk_48,input clk_44,input ext_bclk,input ext_playback_lrclk,input ext_capture_lrclk,output master_slave_mode,output clk_sel_48_44,output mclk,output bclk,output playback_lrclk,output capture_lrclk);\n [/INST]\n", "output": "reg [31:0] cmd_reg1; \n  wire cmd_sel1 = psel && (paddr == 0); \n  reg [31:0] cmd_reg2; \n  wire cmd_sel2 = psel && (paddr == 4); \n  assign master_slave_mode = cmd_reg1[0]; \n  assign clk_sel_48_44 = cmd_reg1[1]; \n  wire cmd_reg2_wr = cmd_sel2 & pwrite & penable; \n  always @(posedge clk or negedge reset_n) \n  begin \n  if (~reset_n) \n  begin \n  cmd_reg1 <= 0; \n  cmd_reg2 <= 0; \n  end \n  else \n  begin \n  if (cmd_sel1 & pwrite & penable) \n  cmd_reg1 <= pwdata; \n  else if (cmd_sel1 & ~pwrite & ~penable) \n  prdata <= cmd_reg1; \n  if (cmd_reg2_wr) \n  cmd_reg2 <= pwdata; \n  else if (cmd_sel2 & ~pwrite & ~penable) \n  prdata <= cmd_reg2; \n  end \n  end \n  wire mclk48; \n  wire bclk48; \n  wire playback_lrclk48; \n  wire capture_lrclk48; \n audio_clock_generator playback_gen48 (.clk (clk_48),.reset_n (reset_n),.cmd_reg1 (cmd_reg1),.cmd_reg2 (cmd_reg2),.mclk (mclk48),.bclk (bclk48),.lrclk_clear(cmd_reg2_wr),.lrclk1 (playback_lrclk48),.lrclk2 (capture_lrclk48)); \n  wire mclk44; \n  wire bclk44; \n  wire playback_lrclk44; \n  wire capture_lrclk44; \n audio_clock_generator playback_gen44 (.clk (clk_44),.reset_n (reset_n & ~cmd_reg2_wr),.cmd_reg1 (cmd_reg1),.cmd_reg2 (cmd_reg2),.mclk (mclk44),.bclk (bclk44),.lrclk_clear(cmd_reg2_wr),.lrclk1 (playback_lrclk44),.lrclk2 (capture_lrclk44)); \n  assign mclk = clk_sel_48_44 ? mclk44 : mclk48; \n  assign bclk = master_slave_mode \n  ? (clk_sel_48_44 ? bclk44 : bclk48) \n  : ext_bclk; \n  assign playback_lrclk = master_slave_mode \n  ? (clk_sel_48_44 ? playback_lrclk44 : playback_lrclk48) \n  : ext_playback_lrclk; \n  assign capture_lrclk = master_slave_mode \n  ? (clk_sel_48_44 ? capture_lrclk44 : capture_lrclk48) \n  : ext_capture_lrclk; \n  assign pready = penable; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a pipeline stage for memory-writeback. It stores the input values for control signals, data, ALU result, and write register, and updates them on the positive edge of the clock signal. The initial block initializes the output registers to zero.\n\n Module header:\n\nmodule MEM_WB(input clk,input [1:0] control_wb_in,input [31:0] Read_data_in,input [31:0] ALU_result_in,input [4:0] Write_reg_in,output reg [1:0] mem_control_wb,output reg [31:0] Read_data,output reg [31:0] mem_ALU_result,output reg [4:0] mem_Write_reg);\n [/INST]\n", "output": "initial \n  begin \n  mem_control_wb <= 0; \n  Read_data <= 0; \n  mem_ALU_result <= 0; \n  mem_Write_reg <= 0; \n  end \n  always @ (posedge clk) \n  begin \n  mem_control_wb <= control_wb_in; \n  Read_data <= Read_data_in; \n  mem_ALU_result <= ALU_result_in; \n  mem_Write_reg <= Write_reg_in; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `dly3_9` is a delay line that takes a 9-bit input and outputs the same 9 bits delayed by three cycles. It uses nine buffers, each with a true signal set, to sequentially delay the input signal. The output `o` is assigned to the delayed signal from the final buffer `n3`.\n\n Module header:\n\nmodule dly3_9 ( i, o );\n [/INST]\n", "output": "input [8:0] i; \n  output [8:0] o; \n  wire [8:0] n0; \n  wire [8:0] n1; \n  wire [8:0] n2; \n  wire [8:0] n3; \n  assign n0 = i; \n  (* S = \"TRUE\" *) \n  BUF dly00 (.I(n0[0]), .O(n1[0])); \n  (* S = \"TRUE\" *) \n  BUF dly01 (.I(n0[1]), .O(n1[1])); \n  (* S = \"TRUE\" *) \n  BUF dly02 (.I(n0[2]), .O(n1[2])); \n  (* S = \"TRUE\" *) \n  BUF dly03 (.I(n0[3]), .O(n1[3])); \n  (* S = \"TRUE\" *) \n  BUF dly04 (.I(n0[4]), .O(n1[4])); \n  (* S = \"TRUE\" *) \n  BUF dly05 (.I(n0[5]), .O(n1[5])); \n  (* S = \"TRUE\" *) \n  BUF dly06 (.I(n0[6]), .O(n1[6])); \n  (* S = \"TRUE\" *) \n  BUF dly07 (.I(n0[7]), .O(n1[7])); \n  (* S = \"TRUE\" *) \n  BUF dly08 (.I(n0[8]), .O(n1[8])); \n  (* S = \"TRUE\" *) \n  BUF dly10 (.I(n1[0]), .O(n2[0])); \n  (* S = \"TRUE\" *) \n  BUF dly11 (.I(n1[1]), .O(n2[1])); \n  (* S = \"TRUE\" *) \n  BUF dly12 (.I(n1[2]), .O(n2[2])); \n  (* S = \"TRUE\" *) \n  BUF dly13 (.I(n1[3]), .O(n2[3])); \n  (* S = \"TRUE\" *) \n  BUF dly14 (.I(n1[4]), .O(n2[4])); \n  (* S = \"TRUE\" *) \n  BUF dly15 (.I(n1[5]), .O(n2[5])); \n  (* S = \"TRUE\" *) \n  BUF dly16 (.I(n1[6]), .O(n2[6])); \n  (* S = \"TRUE\" *) \n  BUF dly17 (.I(n1[7]), .O(n2[7])); \n  (* S = \"TRUE\" *) \n  BUF dly18 (.I(n1[8]), .O(n2[8])); \n  (* S = \"TRUE\" *) \n  BUF dly20 (.I(n2[0]), .O(n3[0])); \n  (* S = \"TRUE\" *) \n  BUF dly21 (.I(n2[1]), .O(n3[1])); \n  (* S = \"TRUE\" *) \n  BUF dly22 (.I(n2[2]), .O(n3[2])); \n  (* S = \"TRUE\" *) \n  BUF dly23 (.I(n2[3]), .O(n3[3])); \n  (* S = \"TRUE\" *) \n  BUF dly24 (.I(n2[4]), .O(n3[4])); \n  (* S = \"TRUE\" *) \n  BUF dly25 (.I(n2[5]), .O(n3[5])); \n  (* S = \"TRUE\" *) \n  BUF dly26 (.I(n2[6]), .O(n3[6])); \n  (* S = \"TRUE\" *) \n  BUF dly27 (.I(n2[7]), .O(n3[7])); \n  (* S = \"TRUE\" *) \n  BUF dly28 (.I(n2[8]), .O(n3[8])); \n  assign o = n3; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a circuit to determine the leading zeros in a 16-bit input. It has inputs to check for specific bits being equal to zero, and outputs to indicate the presence of leading zeros. The module performs logic operations on the inputs to determine the number and position of leading zeros, and assigns the results to the corresponding outputs.\n\n Module header:\n\nmodule fpu_cnt_lead0_lvl3 (din_15_8_eq_0,din_15_12_eq_0,lead0_8b_1_hi,lead0_8b_0_hi,din_7_0_eq_0,din_7_4_eq_0,lead0_8b_1_lo,lead0_8b_0_lo,din_15_0_eq_0,lead0_16b_2,lead0_16b_1,lead0_16b_0);\n [/INST]\n", "output": "input din_15_8_eq_0; \n input din_15_12_eq_0; \n input lead0_8b_1_hi; \n input lead0_8b_0_hi; \n input din_7_0_eq_0; \n input din_7_4_eq_0; \n input lead0_8b_1_lo; \n input lead0_8b_0_lo; \n output din_15_0_eq_0; \n output lead0_16b_2; \n output lead0_16b_1; \n output lead0_16b_0; \n wire din_15_0_eq_0; \n wire lead0_16b_2; \n wire lead0_16b_1; \n wire lead0_16b_0; \n assign din_15_0_eq_0= din_7_0_eq_0 && din_15_8_eq_0; \n assign lead0_16b_2= ((!din_15_8_eq_0) && din_15_12_eq_0) \n  || (din_15_8_eq_0 && din_7_4_eq_0); \n assign lead0_16b_1= ((!din_15_8_eq_0) && lead0_8b_1_hi) \n  || (din_15_8_eq_0 && lead0_8b_1_lo); \n assign lead0_16b_0= ((!din_15_8_eq_0) && lead0_8b_0_hi) \n  || (din_15_8_eq_0 && lead0_8b_0_lo); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a logic unit with a configurable bit width N. It takes inputs iCONTROL_CMD, iDATA_0, and iDATA_1, and provides outputs oDATA, oSF, oOF, oCF, oPF, and oZF. It uses a function f_logic to perform various operations based on the control command iCONTROL_CMD. These operations include bitwise logic operations, bitwise shifts, bit manipulations, and conditional assignments based on the control command. The oDATA output is the result of the f_logic function, and the other outputs are derived from the result of the function.\n\n Module header:\n\nmodule logic_n #(parameter N = 32) (input [4:0] iCONTROL_CMD,input [N-1:0] iDATA_0,input [N-1:0] iDATA_1,output [N-1:0] oDATA,output oSF,output oOF,output oCF,output oPF,output oZF);\n [/INST]\n", "output": "wire [31:0] tmp; \n  assign tmp = f_logic(iCONTROL_CMD, iDATA_0, iDATA_1); \n  function [N-1 : 0] f_logic; \n  input [4 : 0] f_cmd; \n  input [N-1 : 0] f_data0; \n  input [N-1 : 0] f_data1; \n  begin \n  case(f_cmd) \n  5'h0 : f_logic = f_data0; \n  5'h1 : f_logic = f_data1; \n  5'h2 : f_logic = ~f_data0; \n  5'h3 : f_logic = ~f_data1; \n  5'h4 : f_logic = f_data0 & f_data1; \n  5'h5 : f_logic = f_data0 | f_data1; \n  5'h6 : f_logic = f_data0 ^ f_data1; \n  5'h7 : f_logic = ~(f_data0 & f_data1); \n  5'h8 : f_logic = ~(f_data0 | f_data1); \n  5'h9 : f_logic = ~(f_data0 ^ f_data1); \n  5'hA : f_logic = f_data0 | (1'b1 << f_data1); \n  5'hB : f_logic = f_data0 & (32'hFFFFFFFF ^ (1'b1 << f_data1)); \n  5'hC : f_logic = {f_data0[0], f_data0[1], f_data0[2], f_data0[3], \n  f_data0[4], f_data0[5], f_data0[6], f_data0[7], \n  f_data0[8], f_data0[9], f_data0[10], f_data0[11], \n  f_data0[12], f_data0[13], f_data0[14], f_data0[15], \n  f_data0[16], f_data0[17], f_data0[18], f_data0[19], \n  f_data0[20], f_data0[21], f_data0[22], f_data0[23], \n  f_data0[24], f_data0[25], f_data0[26], f_data0[27], \n  f_data0[28], f_data0[28], f_data0[30], f_data0[31]}; \n  5'hD : f_logic = {f_data0[7:0], f_data0[15:8], f_data0[23:16], f_data0[31:24]}; \n  5'hE : f_logic = {{31{1'b0}}, f_data0[f_data1[4:0]]}; \n  5'hF : f_logic = {{28{1'b0}}, \n  f_data0[f_data1+3], f_data0[f_data1+2], f_data0[f_data1+1], f_data0[f_data1]}; \n  5'h10 : f_logic = {f_data0[31:16], f_data1[15:0]}; \n  5'h11 : f_logic = {f_data1[15:0], f_data0[15:0]}; \n  5'h12 : f_logic = {{16{f_data1[15]}}, f_data1[15:0]}; \n  5'h14 : f_logic = {16'h0, f_data1[15:0]}; \n  default : \n  begin \n  f_logic = f_data0; \n  end \n  endcase \n  end \n  endfunction \n  assign oDATA = tmp; \n  assign oSF = tmp[31]; \n  assign oOF = 1'b0; \n  assign oCF = 1'b0; \n  assign oPF = tmp[0]; \n  assign oZF = (tmp == {N{1'b0}})? 1'b1 : 1'b0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a 4-input NOR gate, with inputs A, B, C, and D, and output Y. The output Y is the logical negation of the OR operation on the inputs A, B, C, and D.\n\n Module header:\n\nmodule NOR4 (input A, B, C, D,output Y);\n [/INST]\n", "output": "assign Y = !(A | B | C | D); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module simulates a Dynamic Random Access Memory (DRAM) interface. It initializes data arrays, reads data from a DRAM file, and writes data to the arrays based on the input addresses and control signals. It also outputs data from the specified address to the dout. The module essentially emulates the behavior of a DRAM, storing and retrieving data based on the given inputs and control signals.\n\n Module header:\n\nmodule dram (input clk,input [31:0] addr,input cs,input wr,input [3:0] mask,input [31:0] din,output [31:0] dout);\n [/INST]\n", "output": "parameter DRAM_DATA_FILE = \"dram.hex\"; \n  reg [7:0] data_array_w0[(1024 * 16)-1:0]; \n  reg [7:0] data_array_w1[(1024 * 16)-1:0]; \n  reg [7:0] data_array_w2[(1024 * 16)-1:0]; \n  reg [7:0] data_array_w3[(1024 * 16)-1:0]; \n  reg [31:0] data_out; \n  initial \n  begin \n  $readmemh({DRAM_DATA_FILE, \".0\"}, data_array_w0); \n  $readmemh({DRAM_DATA_FILE, \".1\"}, data_array_w1); \n  $readmemh({DRAM_DATA_FILE, \".2\"}, data_array_w2); \n  $readmemh({DRAM_DATA_FILE, \".3\"}, data_array_w3); \n  end \n  always @ (posedge clk) \n  if (cs && wr && mask[0]) \n  data_array_w0[addr[15:2]] <= din[7:0]; \n  always @ (posedge clk) \n  if (cs && wr && mask[1]) \n  data_array_w1[addr[15:2]] <= din[15:8]; \n  always @ (posedge clk) \n  if (cs && wr && mask[2]) \n  data_array_w2[addr[15:2]] <= din[23:16]; \n  always @ (posedge clk) \n  if (cs && wr && mask[3]) \n  data_array_w3[addr[15:2]] <= din[31:24]; \n  always @ (posedge clk) \n  if (cs) \n  begin \n  data_out[7:0] <= data_array_w0[addr[15:2]]; \n  data_out[15:8] <= data_array_w1[addr[15:2]]; \n  data_out[23:16] <= data_array_w2[addr[15:2]]; \n  data_out[31:24] <= data_array_w3[addr[15:2]]; \n  end \n  assign dout = data_out; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a data memory module with a specified width and depth. It has input ports for address (A), data to be read (WD), write enable signal (WE), and clock signal (Clk). The module also has an output port for the data read (RD). \n\nThe module initializes a memory array with all zeros. It then reads the data from the memory based on the input address (A) and outputs the read data (RD). The memory is updated with the input write data (WD) when the write enable (WE) signal is asserted on the positive edge of the clock (Clk).\n\n Module header:\n\nmodule DataMem(A,RD,WD,WE,Clk);\n [/INST]\n", "output": "parameter Width = 32, \n  Depth = 128; \n  input [Width-1:0] A; \n  input [Width-1:0] WD; \n  input WE,Clk; \n  output [Width-1:0]RD; \n  reg [Width-1:0] Data [0:Depth-1]; \n  integer i; \n  initial begin \n  for(i=0;i<Depth;i=i+1) \n  Data[i]={Width{1'b0}}; \n  end \n  assign RD = (A[31:2]<Depth) ? Data[A[31:2]]: {Width{1'bz}}; \n  always @ (posedge Clk) begin \n  if(WE) \n  begin \n  Data[A[31:2]]=WD; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements an 8-bit Ethernet CRC (Cyclic Redundancy Check) calculation. It takes an 8-bit data input and a 32-bit CRC state as inputs, and computes the next CRC state using a CRC iteration function. The resulting next CRC state is output through the crc_next port.\n\n Module header:\n\nmodule eth_crc_8 (input wire [7:0] data_in,input wire [31:0] crc_state,output wire [31:0] crc_next);\n [/INST]\n", "output": "assign crc_next = crc_iteration( 8, crc_state, { 120'h0, data_in} ); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a Motor PWM controller. It takes in various parameters such as clock signal, enable signal, pre-first, PWM delay, PWM cycle, spread, current PWM code, and outputs new PWM and motor control signals. \n\nThe module contains registers to keep track of PWM cycle count, delay count, and phase. It also uses wires for spreaded phase, PWM on, PWM off, stop command, PWM difference, and motor control. \n\nThe module calculates the new PWM based on the input parameters and the current state of the PWM cycle, and generates motor control signals based on the new PWM and stop command. \n\nThe PWM cycle count, PWM delay count, and PWM phase are updated on the positive edge of the clock signal, and the new PWM and motor control signals are updated based on the current state and input conditions.\n\n Module header:\n\nmodule motor_pwm( clk,en,pre_first,pwm_delay,pwm_cycle,spread,cur_pwm,pwm_code,new_pwm,mot);\n [/INST]\n", "output": "input clk; \n  input en; \n  input pre_first; \n  input [2:0] pwm_delay; \n  input [7:0] pwm_cycle; \n  input [2:0] spread; \n  input [2:0] cur_pwm; \n  input [3:0] pwm_code; \n  output [2:0] new_pwm; \n  output [1:0] mot; \n  reg [9:0] pwm_cycle_count; \n  reg pwm_cycle_next; \n  reg [3:0] pwm_delay_count; \n  reg pwm_delay_end; \n  reg [2:0] pwm_phase; \n  wire [2:0] spreaded_phase; \n  wire pwn_on; \n  wire pwn_off; \n  wire [2:0] new_pwm; \n  wire stop_cmd; \n  wire [3:0] pwm_diff; \n  wire [1:0] mot; \n  assign spreaded_phase[2:0]= pwm_phase[2:0]+spread[2:0]; \n  assign pwn_on= pwm_cycle_next && (spreaded_phase == 0) && (pwm_code != 0); \n  assign pwn_off=pwm_cycle_next && (spreaded_phase == pwm_code[2:0]); \n  assign stop_cmd= !en || (pwm_code==8) ; \n  assign pwm_diff[3:0]={1'b0,pwm_code[2:0]}-{1'b0,spreaded_phase[2:0]}; \n  assign new_pwm[0]=!stop_cmd && (pwm_cycle_next? pwm_code[3] : cur_pwm[0]); \n  assign new_pwm[1]=!stop_cmd && (pwm_cycle_next?((pwm_code[2:0]!=0) && !pwm_diff[3]):cur_pwm[1]); \n  assign new_pwm[2]=!en || (pwm_cycle_next? (new_pwm[1:0]!=cur_pwm[1:0]):(cur_pwm[2]&& !pwm_delay_end)); \n  assign mot[1:0]=(stop_cmd || new_pwm[2])? 2'b0:(new_pwm[1]?{new_pwm[0],!new_pwm[0]}:2'b11); \n  always @ (posedge clk) if (pre_first) begin \n  pwm_cycle_count<= (!en || (pwm_cycle_count==0)) ? {2'b0,pwm_cycle}:(pwm_cycle_count-1); \n  pwm_cycle_next<= en && (pwm_cycle_count==0); \n  pwm_delay_count<= (!en || pwm_cycle_next)?{1'b0,pwm_delay}:((pwm_delay_count==0)? 4'b0: (pwm_delay_count-1)); \n  pwm_delay_end<= en && (pwm_delay_count==1); \n  pwm_phase<= (!en)? 0: (pwm_phase + pwm_cycle_next); \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a loopback for the input signal `din` to the output signal `dout`, which is 17 times the width of `din`. The output `dout` is connected to multiple pins specified by the LOC attribute.\n\n Module header:\n\nmodule SocketTestLoopback_STQFN20(din, dout);\n [/INST]\n", "output": "(* LOC = \"P2\" *) \n  input wire din; \n  (* LOC = \"P20 P19 P18 P17 P16 P15 P14 P13 P12 P10 P9 P8 P7 P6 P5 P4 P3\" *) \n  output wire[16:0] dout; \n  assign dout = {17{din}}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `ps2lab1` is a circuit that interfaces with a PS/2 keyboard and displays input history on 7-segment displays. It uses clock and input signals to capture keyboard scan codes, update a shift register with the scan codes, and display the history on the 7-segment displays. The reset functionality is tied to one of the input keys, and LED outputs are assigned based on switch inputs. The module also uses a one-shot pulser and an on-board clock signal.\n\n Module header:\n\nmodule ps2lab1(input CLOCK_50,input [3:0] KEY,input [17:0] SW,output [6:0] HEX0, HEX1, HEX2, HEX3, HEX4, HEX5, HEX6, HEX7,output [8:0] LEDG,output [17:0] LEDR,input PS2_DAT,input PS2_CLK,inout [35:0] GPIO_0, GPIO_1);\n [/INST]\n", "output": "assign GPIO_0 = 36'hzzzzzzzzz; \n assign GPIO_1 = 36'hzzzzzzzzz; \n wire RST; \n assign RST = KEY[0]; \n assign LEDR[17:0] = SW[17:0]; \n assign LEDG = 0; \n wire reset = 1'b0; \n wire [7:0] scan_code; \n reg [7:0] history[1:4]; \n wire read, scan_ready; \n oneshot pulser(.pulse_out(read),.trigger_in(scan_ready),.clk(CLOCK_50)); \n keyboard kbd(.keyboard_clk(PS2_CLK),.keyboard_data(PS2_DAT),.clock50(CLOCK_50),.reset(reset),.read(read),.scan_ready(scan_ready),.scan_code(scan_code)); \n hex_7seg dsp0(history[1][3:0],HEX0); \n hex_7seg dsp1(history[1][7:4],HEX1); \n hex_7seg dsp2(history[2][3:0],HEX2); \n hex_7seg dsp3(history[2][7:4],HEX3); \n hex_7seg dsp4(history[3][3:0],HEX4); \n hex_7seg dsp5(history[3][7:4],HEX5); \n hex_7seg dsp6(history[4][3:0],HEX6); \n hex_7seg dsp7(history[4][7:4],HEX7); \n always @(posedge scan_ready) \n begin \n  history[4] <= history[3]; \n  history[3] <= history[2]; \n  history[2] <= history[1]; \n  history[1] <= scan_code; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a 64-bit FIFO memory using a 512-entry RAM. It has separate read and write addresses, with the read address controlled by a clock enable signal. The module also includes logic to handle reset conditions for the read address. When the write clock signal is asserted, the module writes the input data to the RAM at the specified write address.\n\n Module header:\n\nmodule DE4_SOPC_burst_2_fifo_module_fifo_ram_module (clk,data,rdaddress,rdclken,reset_n,wraddress,wrclock,wren,q);\n [/INST]\n", "output": "output [ 63: 0] q; \n  input clk; \n  input [ 63: 0] data; \n  input [ 8: 0] rdaddress; \n  input rdclken; \n  input reset_n; \n  input [ 8: 0] wraddress; \n  input wrclock; \n  input wren; \n  reg [ 63: 0] mem_array [511: 0]; \n  wire [ 63: 0] q; \n  reg [ 8: 0] read_address; \n  always @(posedge clk or negedge reset_n) \n  begin \n  if (reset_n == 0) \n  read_address <= 0; \n  else if (rdclken) \n  read_address <= rdaddress; \n  end \n  assign q = mem_array[read_address]; \n  always @(posedge wrclock) \n  begin \n  if (wren) \n  mem_array[wraddress] <= data; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a 32-bit multioperand carry-save adder. It takes three inputs, a, b, and c, and computes the sum and the carry-out. It uses bitwise XOR and AND operations to calculate intermediate signals x, y0, y1, and y2. The sum output is the XOR of c and x, and the carry-out is the OR of y0, y1, and y2.\n\n Module header:\n\nmodule mul_csa32 (sum, cout, a, b, c);\n [/INST]\n", "output": "output sum, cout; \n input a, b, c; \n wire x, y0, y1, y2; \n assign x = a ^ b; \n assign sum = c ^ x; \n assign y0 = a & b ; \n assign y1 = a & c ; \n assign y2 = b & c ; \n assign cout = y0 | y1 | y2 ; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes two 4-bit inputs, iSOURCE0 and iSOURCE1, and performs a multiplication operation to produce an 8-bit output, oOUTPUT. The module multiplies each bit of iSOURCE0 with iSOURCE1 shifted by a corresponding amount, and then adds the results together to obtain the final output.\n\n Module header:\n\nmodule mul4(input [3 : 0] iSOURCE0,input [3 : 0] iSOURCE1,output [7 : 0] oOUTPUT);\n [/INST]\n", "output": "assign oOUTPUT = ((iSOURCE0[0])? iSOURCE1 : 7'h00) + ((iSOURCE0[1])? iSOURCE1 << 1 : 7'h00) + ((iSOURCE0[2])? iSOURCE1 << 2 : 7'h00) + ((iSOURCE0[3])? iSOURCE1 << 3 : 7'h00); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a pattern-matching circuit that compares a set of input data with multiple patterns. The module uses a shifter to align the patterns with the input data and then compares the aligned patterns with the input data to detect partial and complete matches. It selects the pattern to be compared based on a control signal. The module also tracks the shift amount and indicates when a complete match occurs.\n\n Module header:\n\nmodule compare #(parameter MSG_WIDTH=4, B=3, PATTERN_WIDTH=14,SHIFT_WIDTH=$clog2(PATTERN_WIDTH-B+1)+1,NOS_KEY=4) ( input clk,input reset,input compare_enable,input [MSG_WIDTH*PATTERN_WIDTH-1:0] data_in,input [MSG_WIDTH*PATTERN_WIDTH*NOS_KEY-1:0] patterns,output reg [SHIFT_WIDTH-1:0] shift_amount,output reg complete_match);\n [/INST]\n", "output": "localparam nos_shifters = PATTERN_WIDTH -B+1; \n wire [nos_shifters-1:1] compare_data, compare_data_tmp, priority_cmp; \n wire [MSG_WIDTH*B-1:0] pattern_comb [nos_shifters-1:1]; \n wire [SHIFT_WIDTH:0] shift_amount_wire; \n wire partial_match_wire,complete_match_wire; \n wire [MSG_WIDTH*PATTERN_WIDTH-1:0] pattern; \n reg [$clog2(NOS_KEY)-1:0] sel; \n generate \n  genvar i; \n  for(i=1;i<nos_shifters;i=i+1) \n  begin: compare \n  assign compare_data_tmp[i] = ~(| (data_in[MSG_WIDTH*B-1:0] ^ pattern_comb[i])); \n  end \n endgenerate \n generate \n  genvar j; \n  for(j=1;j<nos_shifters;j=j+1) \n  begin: shifter_mux \n  assign pattern_comb[j] = pattern[MSG_WIDTH*(j+B)-1:MSG_WIDTH*j]; \n  end \n endgenerate \n generate \n  genvar n; \n  for(n=1;n<nos_shifters;n=n+1) \n  begin: shifters \n  if(n==1) begin \n  assign priority_cmp[n]=1; \n  assign compare_data[n] = priority_cmp[n] & compare_data_tmp[n]; \n  end \n  else begin \n  assign priority_cmp[n] = ~(|(compare_data_tmp[n-1:1])); \n  assign compare_data[n] = priority_cmp[n] & compare_data_tmp[n]; \n  end \n  assign shift_amount_wire = compare_data[n] ? n: {SHIFT_WIDTH+1{1'bz}}; \n  end \n endgenerate \n assign partial_match_wire = |(compare_data); \n assign complete_match_wire = ~(|(pattern ^ data_in)); \n always@(posedge clk) \n begin \n  complete_match <= complete_match_wire; \n  if(reset) begin \n  shift_amount <= 0; \n  sel <= 0; \n  end \n  else begin \n  if(partial_match_wire == 1) begin \n  shift_amount <= shift_amount_wire; \n  end \n  else begin \n  shift_amount <= PATTERN_WIDTH-B+1; \n  end \n  if(compare_enable ) begin \n  sel <= sel + 1; \n  end \n  end \n end \n generate \n  genvar k; \n  for (k=0; k<NOS_KEY; k=k+1) \n  begin: patter \n  assign pattern = (sel == k) ? patterns[PATTERN_WIDTH*(k+1)*MSG_WIDTH-1: (PATTERN_WIDTH*k)*MSG_WIDTH] : {MSG_WIDTH*PATTERN_WIDTH{1'bz}}; \n  end \n endgenerate \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module represents a constant 17 generator. It has an input 'out_0r' and outputs 'out_0a' and 'out_0d' which is a 17-bit vector. The output 'out_0a' is set to the value of the input 'out_0r'. The 17-bit vector 'out_0d' has all its bits set to ground.\n\n Module header:\n\nmodule BrzConstant_17_0 (out_0r, out_0a, out_0d);\n [/INST]\n", "output": "input out_0r; \n  output out_0a; \n  output [16:0] out_0d; \n  wire gnd; \n  GND gnd_cell_instance (gnd); \n  assign out_0a = out_0r; \n  assign out_0d[0] = gnd; \n  assign out_0d[1] = gnd; \n  assign out_0d[2] = gnd; \n  assign out_0d[3] = gnd; \n  assign out_0d[4] = gnd; \n  assign out_0d[5] = gnd; \n  assign out_0d[6] = gnd; \n  assign out_0d[7] = gnd; \n  assign out_0d[8] = gnd; \n  assign out_0d[9] = gnd; \n  assign out_0d[10] = gnd; \n  assign out_0d[11] = gnd; \n  assign out_0d[12] = gnd; \n  assign out_0d[13] = gnd; \n  assign out_0d[14] = gnd; \n  assign out_0d[15] = gnd; \n  assign out_0d[16] = gnd; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a configurable Look-Up Table (LUT) that implements different combinational logic functions based on the width of the input. It uses a generate block to instantiate different LUT instances based on the value of the WIDTH parameter. Each LUT instance has a different number of inputs and implements the corresponding logic function. The output Y is generated based on the input A and the configured LUT mask. If the WIDTH is not within the supported range, the module indicates failure using a wire signal.\n\n Module header:\n\nmodule \\$lut (A, Y);\n [/INST]\n", "output": "parameter WIDTH = 0; \n  parameter LUT = 0; \n  input [WIDTH-1:0] A; \n  output Y; \n  generate \n  if (WIDTH == 1) begin \n  assign Y = ~A[0]; \n  end \n  else \n  if (WIDTH == 2) begin \n  cyclonev_lcell_comb #(.lut_mask({16{LUT}}), .shared_arith(\"off\"), .extended_lut(\"off\")) \n  _TECHMAP_REPLACE_ \n (.combout(Y),.dataa(A[0]),.datab(A[1]),.datac(1'b1),.datad(1'b1),.datae(1'b1),.dataf(1'b1),.datag(1'b1)); \n  end \n  else \n  if(WIDTH == 3) begin \n  cyclonev_lcell_comb #(.lut_mask({8{LUT}}), .shared_arith(\"off\"), .extended_lut(\"off\")) \n  _TECHMAP_REPLACE_ \n (.combout(Y),.dataa(A[0]),.datab(A[1]),.datac(A[2]),.datad(1'b1),.datae(1'b1),.dataf(1'b1),.datag(1'b1)); \n  end \n  else \n  if(WIDTH == 4) begin \n  cyclonev_lcell_comb #(.lut_mask({4{LUT}}), .shared_arith(\"off\"), .extended_lut(\"off\")) \n  _TECHMAP_REPLACE_ \n (.combout(Y),.dataa(A[0]),.datab(A[1]),.datac(A[2]),.datad(A[3]),.datae(1'b1),.dataf(1'b1),.datag(1'b1)); \n  end \n  else \n  if(WIDTH == 5) begin \n  cyclonev_lcell_comb #(.lut_mask({2{LUT}}), .shared_arith(\"off\"), .extended_lut(\"off\")) \n  _TECHMAP_REPLACE_ \n (.combout(Y),.dataa(A[0]),.datab(A[1]),.datac(A[2]),.datad(A[3]),.datae(A[4]),.dataf(1'b1),.datag(1'b1)); \n  end \n  else \n  if(WIDTH == 6) begin \n  cyclonev_lcell_comb #(.lut_mask(LUT), .shared_arith(\"off\"), .extended_lut(\"off\")) \n  _TECHMAP_REPLACE_ \n (.combout(Y),.dataa(A[0]),.datab(A[1]),.datac(A[2]),.datad(A[3]),.datae(A[4]),.dataf(A[5]),.datag(1'b1)); \n  end \n  else \n  if(WIDTH == 7) begin \n  cyclonev_lcell_comb #(.lut_mask(LUT), .shared_arith(\"off\"), .extended_lut(\"off\")) \n  _TECHMAP_REPLACE_ \n (.combout(Y),.dataa(A[0]),.datab(A[1]),.datac(A[2]),.datad(A[3]),.datae(A[4]),.dataf(A[5]),.datag(A[6])); \n  end \n  else \n  wire _TECHMAP_FAIL_ = 1; \n  endgenerate \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a fast multiplier for the picorv32 processor. It includes logic for decoding multiplication instructions, handling operand data, performing the multiplication operation, and generating the output. The module also features optional parameters for extra functionalities and clock gating. The primary functionality involves detecting and executing multiplication instructions, performing signed and unsigned multiplication, shifting the result if necessary, and generating the output based on the instruction type.\n\n Module header:\n\nmodule picorv32_pcpi_fast_mul #(parameter EXTRA_MUL_FFS = 0,parameter EXTRA_INSN_FFS = 0,parameter MUL_CLKGATE = 0) (input clk, resetn,input pcpi_valid,input [31:0] pcpi_insn,input [31:0] pcpi_rs1,input [31:0] pcpi_rs2,output pcpi_wr,output [31:0] pcpi_rd,output pcpi_wait,output pcpi_ready);\n [/INST]\n", "output": "reg instr_mul, instr_mulh, instr_mulhsu, instr_mulhu; \n  wire instr_any_mul = |{instr_mul, instr_mulh, instr_mulhsu, instr_mulhu}; \n  wire instr_any_mulh = |{instr_mulh, instr_mulhsu, instr_mulhu}; \n  wire instr_rs1_signed = |{instr_mulh, instr_mulhsu}; \n  wire instr_rs2_signed = |{instr_mulh}; \n  reg shift_out; \n  reg [3:0] active; \n  reg [32:0] rs1, rs2, rs1_q, rs2_q; \n  reg [63:0] rd, rd_q; \n  wire pcpi_insn_valid = pcpi_valid && pcpi_insn[6:0] == 7'b0110011 && pcpi_insn[31:25] == 7'b0000001; \n  reg pcpi_insn_valid_q; \n  always @* begin \n  instr_mul = 0; \n  instr_mulh = 0; \n  instr_mulhsu = 0; \n  instr_mulhu = 0; \n  if (resetn && (EXTRA_INSN_FFS ? pcpi_insn_valid_q : pcpi_insn_valid)) begin \n  case (pcpi_insn[14:12]) \n  3'b000: instr_mul = 1; \n  3'b001: instr_mulh = 1; \n  3'b010: instr_mulhsu = 1; \n  3'b011: instr_mulhu = 1; \n  endcase \n  end \n  end \n  always @(posedge clk) begin \n  pcpi_insn_valid_q <= pcpi_insn_valid; \n  if (!MUL_CLKGATE || active[0]) begin \n  rs1_q <= rs1; \n  rs2_q <= rs2; \n  end \n  if (!MUL_CLKGATE || active[1]) begin \n  rd <= $signed(EXTRA_MUL_FFS ? rs1_q : rs1) * $signed(EXTRA_MUL_FFS ? rs2_q : rs2); \n  end \n  if (!MUL_CLKGATE || active[2]) begin \n  rd_q <= rd; \n  end \n  end \n  always @(posedge clk) begin \n  if (instr_any_mul && !(EXTRA_MUL_FFS ? active[3:0] : active[1:0])) begin \n  if (instr_rs1_signed) \n  rs1 <= $signed(pcpi_rs1); \n  else \n  rs1 <= $unsigned(pcpi_rs1); \n  if (instr_rs2_signed) \n  rs2 <= $signed(pcpi_rs2); \n  else \n  rs2 <= $unsigned(pcpi_rs2); \n  active[0] <= 1; \n  end else begin \n  active[0] <= 0; \n  end \n  active[3:1] <= active; \n  shift_out <= instr_any_mulh; \n  if (!resetn) \n  active <= 0; \n  end \n  assign pcpi_wr = active[EXTRA_MUL_FFS ? 3 : 1]; \n  assign pcpi_wait = 0; \n  assign pcpi_ready = active[EXTRA_MUL_FFS ? 3 : 1]; \n `ifdef RISCV_FORMAL_ALTOPS \n  assign pcpi_rd = \n  instr_mul ? (pcpi_rs1 + pcpi_rs2) ^ 32'h5876063e : \n  instr_mulh ? (pcpi_rs1 + pcpi_rs2) ^ 32'hf6583fb7 : \n  instr_mulhsu ? (pcpi_rs1 - pcpi_rs2) ^ 32'hecfbe137 : \n  instr_mulhu ? (pcpi_rs1 + pcpi_rs2) ^ 32'h949ce5e8 : 1'bx; \n `else \n  assign pcpi_rd = shift_out ? (EXTRA_MUL_FFS ? rd_q : rd) >> 32 : (EXTRA_MUL_FFS ? rd_q : rd); \n `endif \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements an input buffer with differential signaling. It handles various input parameters such as capacitance, differential termination, DQS bias, delay values, and low-power settings. The module also includes logic to handle attribute syntax errors and ensure that the input signals are processed appropriately to generate the output signal. Additionally, it supports timing specifications for the input and output signals.\n\n Module header:\n\nmodule IBUFDS (O, I, IB);\n [/INST]\n", "output": "`ifdef XIL_TIMING \n  parameter LOC = \"UNPLACED\"; \n `endif \n  parameter CAPACITANCE = \"DONT_CARE\"; \n  parameter DIFF_TERM = \"FALSE\"; \n  parameter DQS_BIAS = \"FALSE\"; \n  parameter IBUF_DELAY_VALUE = \"0\"; \n  parameter IBUF_LOW_PWR = \"TRUE\"; \n  parameter IFD_DELAY_VALUE = \"AUTO\"; \n  parameter IOSTANDARD = \"DEFAULT\"; \n  localparam MODULE_NAME = \"IBUFDS\"; \n  output O; \n  input I, IB; \n  wire i_in, ib_in; \n  reg o_out; \n  reg DQS_BIAS_BINARY = 1'b0; \n  assign O = o_out; \n  assign i_in = I; \n  assign ib_in = IB; \n  initial begin \n  case (DQS_BIAS) \n  \"TRUE\" : DQS_BIAS_BINARY <= #1 1'b1; \n  \"FALSE\" : DQS_BIAS_BINARY <= #1 1'b0; \n  default : begin \n  $display(\"Attribute Syntax Error : The attribute DQS_BIAS on %s instance %m is set to %s. Legal values for this attribute are TRUE or FALSE.\", MODULE_NAME, DQS_BIAS); \n  $finish; \n  end \n  endcase \n  case (CAPACITANCE) \n  \"LOW\", \"NORMAL\", \"DONT_CARE\" : ; \n  default : begin \n  $display(\"Attribute Syntax Error : The attribute CAPACITANCE on %s instance %m is set to %s. Legal values for this attribute are DONT_CARE, LOW or NORMAL.\", MODULE_NAME, CAPACITANCE); \n  $finish; \n  end \n  endcase \n  case (DIFF_TERM) \n  \"TRUE\", \"FALSE\" : ; \n  default : begin \n  $display(\"Attribute Syntax Error : The attribute DIFF_TERM on %s instance %m is set to %s. Legal values for this attribute are TRUE or FALSE.\", MODULE_NAME, DIFF_TERM); \n  $finish; \n  end \n  endcase \n  case (IBUF_DELAY_VALUE) \n  \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\" : ; \n  default : begin \n  $display(\"Attribute Syntax Error : The attribute IBUF_DELAY_VALUE on %s instance %m is set to %s. Legal values for this attribute are 0, 1, 2, ... or 16.\", MODULE_NAME, IBUF_DELAY_VALUE); \n  $finish; \n  end \n  endcase \n  case (IBUF_LOW_PWR) \n  \"FALSE\", \"TRUE\" : ; \n  default : begin \n  $display(\"Attribute Syntax Error : The attribute IBUF_LOW_PWR on %s instance %m is set to %s. Legal values for this attribute are TRUE or FALSE.\", MODULE_NAME, IBUF_LOW_PWR); \n  $finish; \n  end \n  endcase \n  case (IFD_DELAY_VALUE) \n  \"AUTO\", \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\" : ; \n  default : begin \n  $display(\"Attribute Syntax Error : The attribute IFD_DELAY_VALUE on %s instance %m is set to %s. Legal values for this attribute are AUTO, 0, 1, 2, ... or 8.\", MODULE_NAME, IFD_DELAY_VALUE); \n  $finish; \n  end \n  endcase \n end \n  always @(i_in or ib_in or DQS_BIAS_BINARY) begin \n  if (i_in == 1'b1 && ib_in == 1'b0) \n  o_out <= 1'b1; \n  else if (i_in == 1'b0 && ib_in == 1'b1) \n  o_out <= 1'b0; \n  else if ((i_in === 1'bz || i_in == 1'b0) && (ib_in === 1'bz || ib_in == 1'b1)) \n  if (DQS_BIAS_BINARY == 1'b1) \n  o_out <= 1'b0; \n  else \n  o_out <= 1'bx; \n  else if ((i_in === 1'bx) || (ib_in === 1'bx)) \n  o_out <= 1'bx; \n  end \n `ifdef XIL_TIMING \n  specify \n  (I => O) = (0:0:0, 0:0:0); \n  (IB => O) = (0:0:0, 0:0:0); \n  specparam PATHPULSE$ = 0; \n  endspecify \n `endif \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, GP_VSS, has a single output port named OUT. It continuously assigns the value 0 to the OUT port.\n\n Module header:\n\nmodule GP_VSS(output OUT);\n [/INST]\n", "output": "assign OUT = 0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module implements a circuit for capturing image data from an OV7670 camera. It uses the input signals pclk, vsync, href, and d to capture the image data and outputs the address, data output (dout), and a write enable signal (we). The module utilizes internal registers for latching captured data, an address counter, a write hold signal, and a frame counter. The captured data is latched on the rising edge of the pclk signal, and the address is updated based on vsync, href, and the write hold signal. The module ensures that the captured image data is correctly aligned and outputted when the write enable signal is asserted.\n\n Module header:\n\nmodule ov7670_capture(input pclk,input vsync,input href,input[7:0] d,output[16:0] addr,output reg[15:0] dout,output reg we);\n [/INST]\n", "output": "reg [15:0] d_latch; \n  reg [16:0] address; \n  reg [16:0] address_next; \n  reg [1:0] wr_hold; \n  reg [1:0] cnt; \n  initial d_latch = 16'b0; \n  initial address = 19'b0; \n  initial address_next = 19'b0; \n  initial wr_hold = 2'b0; \n  initial cnt = 2'b0; \n assign addr = address; \n always@(posedge pclk)begin \n  if( vsync ==1) begin \n  address <=17'b0; \n  address_next <= 17'b0; \n  wr_hold <= 2'b0; \n  cnt <= 2'b0; \n  end \n  else begin \n  if(address<76800) \n  address <= address_next; \n  else \n  address <= 76800; \n  we <= wr_hold[1]; \n  wr_hold <= {wr_hold[0] , (href &&( ! wr_hold[0])) }; \n  d_latch <= {d_latch[7:0] , d}; \n  if (wr_hold[1] ==1 )begin \n  address_next <=address_next+1; \n  dout[15:0] <= {d_latch[15:11] , d_latch[10:5] , d_latch[4:0] }; \n  end \n  end; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module performs insertion operations using adders and multipliers. It takes in four sets of 8-bit data and a 2-bit control signal. The module first computes the sum of two data sets and then performs multiplication operations. The result is selected based on the control signal and combined with another input to produce the final output.\n\n Module header:\n\nmodule Insertion(input clk,input [7:0]Data1,input [7:0]Data2,input [7:0]Data3,input [7:0]Data4,input [1:0]WM_Data,output [7:0]WM_IM_Data);\n [/INST]\n", "output": "wire [8:0] Adder1, Adder2, Adder; \n wire [7:0] m1, m11, m2, m12; \n reg [7:0] temp; \n adder8 A1(.a(Data2), .b(Data4), .add(1), .s(Adder1)); \n wire [7:0] shiftedAdder1 = Adder1[8:1]; \n adder8 A2(.a(Data3), .b(shiftedAdder1), .add(1), .s(Adder2)); \n wire [7:0] shiftedAdder2 = Adder2[8:1]; \n Amul mul2(.a(shiftedAdder2), .clk(clk), .p(m2)); \n Cmul mul1(.a(Data1), .p(m11)); \n Bmul mul3(.a(Data1), .p(m12)); \n assign m1 = (WM_Data == 2'b01)? m11 : ((WM_Data == 2'b10)? m12 : 0); \n adder8 A3(.a(m1), .b(m2), .add(1), .s(Adder)); \n assign WM_IM_Data = (WM_Data== 2'b00 | WM_Data == 2'b11)? Data1 : Adder[7:0]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a state machine to control data transfer between memory and a processor. It includes registers for handling the state machine, control signals, and the returned data. The module uses clocked and combinational logic to manage the state transitions, handle resets, and set flags based on various conditions. The state machine goes through different states to control the data transfer process, and the output signals are set based on the current state and other control signals.\n\n Module header:\n\nmodule p_source_files_sr (ap_clk,ap_rst,ap_start,ap_done,ap_continue,ap_idle,ap_ready,p_read,ap_return);\n [/INST]\n", "output": "parameter ap_ST_fsm_state1 = 1'd1; \n input ap_clk; \n input ap_rst; \n input ap_start; \n output ap_done; \n input ap_continue; \n output ap_idle; \n output ap_ready; \n input [63:0] p_read; \n output [63:0] ap_return; \n reg ap_done; \n reg ap_idle; \n reg ap_ready; \n reg[63:0] ap_return; \n reg ap_done_reg; \n (* fsm_encoding = \"none\" *) reg [0:0] ap_CS_fsm; \n wire ap_CS_fsm_state1; \n reg ap_block_state1; \n reg [63:0] ap_return_preg; \n reg [0:0] ap_NS_fsm; \n initial begin \n #0 ap_done_reg = 1'b0; \n #0 ap_CS_fsm = 1'd1; \n #0 ap_return_preg = 64'd0; \n end \n always @ (posedge ap_clk) begin \n  if (ap_rst == 1'b1) begin \n  ap_CS_fsm <= ap_ST_fsm_state1; \n  end else begin \n  ap_CS_fsm <= ap_NS_fsm; \n  end \n end \n always @ (posedge ap_clk) begin \n  if (ap_rst == 1'b1) begin \n  ap_done_reg <= 1'b0; \n  end else begin \n  if ((1'b1 == ap_continue)) begin \n  ap_done_reg <= 1'b0; \n  end else if (((1'b1 == ap_CS_fsm_state1) & ~((1'b0 == ap_start) | (ap_done_reg == 1'b1)))) begin \n  ap_done_reg <= 1'b1; \n  end \n  end \n end \n always @ (posedge ap_clk) begin \n  if (ap_rst == 1'b1) begin \n  ap_return_preg <= 64'd0; \n  end else begin \n  if (((1'b1 == ap_CS_fsm_state1) & ~((1'b0 == ap_start) | (ap_done_reg == 1'b1)))) begin \n  ap_return_preg <= p_read; \n  end \n  end \n end \n always @ (*) begin \n  if (((1'b1 == ap_CS_fsm_state1) & ~((1'b0 == ap_start) | (ap_done_reg == 1'b1)))) begin \n  ap_done = 1'b1; \n  end else begin \n  ap_done = ap_done_reg; \n  end \n end \n always @ (*) begin \n  if (((1'b0 == ap_start) & (1'b1 == ap_CS_fsm_state1))) begin \n  ap_idle = 1'b1; \n  end else begin \n  ap_idle = 1'b0; \n  end \n end \n always @ (*) begin \n  if (((1'b1 == ap_CS_fsm_state1) & ~((1'b0 == ap_start) | (ap_done_reg == 1'b1)))) begin \n  ap_ready = 1'b1; \n  end else begin \n  ap_ready = 1'b0; \n  end \n end \n always @ (*) begin \n  if (((1'b1 == ap_CS_fsm_state1) & ~((1'b0 == ap_start) | (ap_done_reg == 1'b1)))) begin \n  ap_return = p_read; \n  end else begin \n  ap_return = ap_return_preg; \n  end \n end \n always @ (*) begin \n  case (ap_CS_fsm) \n  ap_ST_fsm_state1 : begin \n  ap_NS_fsm = ap_ST_fsm_state1; \n  end \n  default : begin \n  ap_NS_fsm = 'bx; \n  end \n  endcase \n end \n assign ap_CS_fsm_state1 = ap_CS_fsm[32'd0]; \n always @ (*) begin \n  ap_block_state1 = ((1'b0 == ap_start) | (ap_done_reg == 1'b1)); \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module simply acts as a buffer, passing the input signal 'sig' directly to the output 'sig_buf'. It essentially replicates the input signal at the output without any modification.\n\n Module header:\n\nmodule sctag_min_rptr(sig_buf,sig);\n [/INST]\n", "output": "input [15:0] sig; \n output [15:0] sig_buf; \n assign sig_buf = sig ; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module is a 4-register memory with write enable inputs. It has 4 pairs of read and write ports. It stores the data from the write inputs when the corresponding write enable is asserted, and outputs the stored data on the read ports. It also has a synchronous reset signal that sets all the registers to the reset value when activated.\n\n Module header:\n\nmodule EHR_4 (CLK,RST_N,read_0,write_0,EN_write_0,read_1,write_1,EN_write_1,read_2,write_2,EN_write_2,read_3,write_3,EN_write_3);\n [/INST]\n", "output": "parameter DATA_SZ = 1; \n  parameter RESET_VAL = 0; \n  input CLK; \n  input RST_N; \n  output [DATA_SZ-1:0] read_0; \n  input [DATA_SZ-1:0] write_0; \n  input EN_write_0; \n  output [DATA_SZ-1:0] read_1; \n  input [DATA_SZ-1:0] write_1; \n  input EN_write_1; \n  output [DATA_SZ-1:0] read_2; \n  input [DATA_SZ-1:0] write_2; \n  input EN_write_2; \n  output [DATA_SZ-1:0] read_3; \n  input [DATA_SZ-1:0] write_3; \n  input EN_write_3; \n  reg [DATA_SZ-1:0] r; \n  wire [DATA_SZ-1:0] wire_0; \n  wire [DATA_SZ-1:0] wire_1; \n  wire [DATA_SZ-1:0] wire_2; \n  wire [DATA_SZ-1:0] wire_3; \n  wire [DATA_SZ-1:0] wire_4; \n  assign wire_0 = r; \n  assign wire_1 = EN_write_0 ? write_0 : wire_0; \n  assign wire_2 = EN_write_1 ? write_1 : wire_1; \n  assign wire_3 = EN_write_2 ? write_2 : wire_2; \n  assign wire_4 = EN_write_3 ? write_3 : wire_3; \n  assign read_0 = wire_0; \n  assign read_1 = wire_1; \n  assign read_2 = wire_2; \n  assign read_3 = wire_3; \n  always @(posedge CLK) begin \n  if (RST_N == 0) begin \n  r <= RESET_VAL; \n  end else begin \n  r <= wire_4; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a memory mapper for a specific hardware configuration. It utilizes the input signals to control the PRG and CHR banks, as well as the mirroring configuration. The module includes logic to set the PRG and CHR banks based on specific conditions, as well as to control the mirroring and allow access to the PRG and CHR memory areas. Additionally, it includes logic to determine the VRAM control signal based on the mirroring configuration and the input signals. The module efficiently manages memory addressing and control based on the provided input signals.\n\n Module header:\n\nmodule Mapper79(input clk, input ce, input reset,input [31:0] flags,input [15:0] prg_ain, output [21:0] prg_aout,input prg_read, prg_write,input [7:0] prg_din,output prg_allow,input [13:0] chr_ain, output [21:0] chr_aout,output chr_allow,output vram_a10,output vram_ce);\n [/INST]\n", "output": "reg [2:0] prg_bank; \n  reg [3:0] chr_bank; \n  reg mirroring; \n  wire mapper113 = (flags[7:0] == 113); \n  always @(posedge clk) if (reset) begin \n  prg_bank <= 0; \n  chr_bank <= 0; \n  mirroring <= 0; \n  end else if (ce) begin \n  if (prg_ain[15:13] == 3'b010 && prg_ain[8] && prg_write) \n  {mirroring, chr_bank[3], prg_bank, chr_bank[2:0]} <= prg_din; \n  end \n  assign prg_aout = {4'b00_00, prg_bank, prg_ain[14:0]}; \n  assign prg_allow = prg_ain[15] && !prg_write; \n  assign chr_allow = flags[15]; \n  assign chr_aout = {5'b10_000, chr_bank, chr_ain[12:0]}; \n  assign vram_ce = chr_ain[13]; \n  wire mirrconfig = mapper113 ? mirroring : flags[14]; \n  assign vram_a10 = mirrconfig ? chr_ain[10] : chr_ain[11]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module consists of combinational logic circuits and wiring for various input and output signals. It connects input wires v39966a and veb2f59 to internal wires w0 and w1. The output wire v62bf25 is assigned to w4, and v4642b6 is assigned to w5. The module then implements combinational logic circuits using the input and internal wires to generate output signals v62bf25 and v4642b6. The circuitry involves multiple instances of combinational logic circuits such as v6bdcd9, v25966b, vafb28f, and va1ce30, each utilizing different input and internal wires to produce the required outputs.\n\n Module header:\n\nmodule vcb23aa (input [7:0] v39966a,input [7:0] veb2f59,output v4642b6,output [7:0] v62bf25);\n [/INST]\n", "output": "wire [0:7] w0; \n  wire [0:7] w1; \n  wire [0:3] w2; \n  wire [0:3] w3; \n  wire [0:7] w4; \n  wire w5; \n  wire w6; \n  wire [0:3] w7; \n  wire [0:3] w8; \n  wire [0:3] w9; \n  wire [0:3] w10; \n  assign w0 = veb2f59; \n  assign w1 = v39966a; \n  assign v62bf25 = w4; \n  assign v4642b6 = w5; \n v6bdcd9 vd88c66 (.vcc8c7c(w0),.v651522(w9),.v2cc41f(w10)); \n v6bdcd9 v26a0bb (.vcc8c7c(w1),.v651522(w7),.v2cc41f(w8)); \n v25966b v9ea427 (.v817794(w3),.v4642b6(w6),.v0550b6(w8),.v24708e(w10)); \n vafb28f vc75346 (.v515fe7(w2),.v3c88fc(w3),.va9ac17(w4)); \n va1ce30 v40c17f (.v817794(w2),.v4642b6(w5),.vb9cfc3(w6),.v0550b6(w7),.v24708e(w9)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `read_i2c_eeprom` interfaces with an I2C EEPROM to read data. It initializes the LED, generates a 1-second tick signal, and implements the I2C clock and control logic. The I2C master instance controls the I2C communication with the EEPROM. It reads the specified number of bytes from the memory address and outputs the data. The module also includes clock and reset signal handling.\n\n Module header:\n\nmodule read_i2c_eeprom(input clk,input rst_n,input cclk,output[7:0]led,output spi_miso,input spi_ss,input spi_mosi,input spi_sck,output [3:0] spi_channel,input avr_tx,output avr_rx,input avr_rx_busy);\n [/INST]\n", "output": "wire reset = ~rst_n; \n assign spi_miso = 1'bz; \n assign avr_rx = 1'bz; \n assign spi_channel = 4'bzzzz; \n assign led[5:0] = 6'b000000; \n assign led[7] = tick_1s; \n assign led[6] = clk_i2c_in; \n wire tick_1s; \n wire i2c_clk_in; \n timer #(.CTR_LEN(26)) second_timer (.clk(clk),.reset(reset),.tick(tick_1s)); \n wire i2c_clk_divider_reset = reset; \n clk_divider i2c_clk_divider (.reset(i2c_clk_divider_reset),.clk_in(clk),.clk_out(i2c_clk_in)); \n wire i2c_start; \n wire i2c_reset; \n wire [7:0] i2c_nbytes; \n wire [6:0] i2c_slave_addr; \n wire i2c_rw; \n wire [7:0] i2c_write_data; \n wire [7:0] i2c_read_data; \n wire i2c_tx_data_req; \n wire i2c_rx_data_ready; \n wire i2c_sda; \n wire i2c_scl; \n wire ready; \n wire busy; \n i2c_master i2c (.clk(i2c_clk_in),.reset(i2c_reset),.start(i2c_start),.nbytes_in(i2c_nbytes),.addr_in(i2c_slave_addr),.rw_in(i2c_rw),.write_data(i2c_write_data),.read_data(i2c_read_data),.tx_data_req(i2c_tx_data_req),.rx_data_ready(i2c_rx_data_ready),.sda_w(sda_w),.scl(scl),.ready(ready),.busy(busy)); \n wire [6:0] slave_addr = 7'b1010000; \n wire [15:0] mem_addr = 16'h0000; \n wire [7:0] read_n_bytes = 8'd1; \n wire read_eeprom_reset = 1; \n wire [7:0] read_nbytes = 0; \n wire start = 0; \n wire [7:0] data_out; \n wire byte_ready; \n read_eeprom instance_name (.clk(clk),.reset(read_eeprom_reset),.slave_addr_w(slave_addr),.mem_addr_w(mem_addr),.read_nbytes_w(read_nbytes),.start(start),.data_out(data_out),.byte_ready(byte_ready),.i2c_slave_addr(i2c_slave_addr),.i2c_rw(i2c_rw),.i2c_write_data(i2c_write_data),.i2c_nbytes(i2c_nbytes),.i2c_read_data(i2c_read_data),.i2c_tx_data_req(i2c_tx_data_req),.i2c_rx_data_ready(i2c_rx_data_ready),.i2c_start(i2c_start)); \n always @(posedge tick_1s) begin \n  if (reset == 1) begin \n  end else begin \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a behavioral implementation of an Arithmetic Logic Unit (ALU) with a 16-bit word width. It takes two 16-bit inputs A and B, and a 4-bit function select input FS. The module outputs a 16-bit result F and a carry flag C.\n\nThe module uses a case statement to perform various arithmetic and logical operations based on the value of the function select input FS. Operations include addition, subtraction, bitwise AND, OR, XOR, left and right shifts, as well as bitwise inversion.\n\nThe module evaluates the case statement whenever any of the inputs A, B, or FS change. The result F and carry flag C are updated accordingly based on the selected operation.\n\n Module header:\n\nmodule Datapath_FunctionUnit_ArithmeticLogicUnit_Behavioral(F, C, A, B, FS);\n [/INST]\n", "output": "parameter WORD_WIDTH = 16; \n parameter DR_WIDTH = 3; \n parameter SB_WIDTH = DR_WIDTH; \n parameter SA_WIDTH = DR_WIDTH; \n parameter OPCODE_WIDTH = 7; \n parameter INSTR_WIDTH = WORD_WIDTH; \n output reg [WORD_WIDTH-1:0] F; \n output reg C; \n input [WORD_WIDTH-1:0] A, B; \n input [3:0] FS; \n always@(*) \n  case(FS) \n  4'b0000: {C, F} = A; \n  4'b0001: {C, F} = A+1; \n  4'b0010: {C, F} = A+B; \n  4'b0011: {C, F} = A+B+1; \n  4'b0100: {C, F} = A+(~B); \n  4'b0101: {C, F} = A+(~B)+1; \n  4'b0110: {C, F} = A-1; \n  4'b0111: {C, F} = A; \n  4'b1000: {C, F} = A&B; \n  4'b1001: {C, F} = A|B; \n  4'b1010: {C, F} = A^B; \n  4'b1011: {C, F} = (~A); \n  4'b1100: {C, F} = B; \n  4'b1101: {C, F} = (B>>1); \n  4'b1110: {C, F} = (B<<1); \n  4'b1111: {C, F} = (~B); \n  default:; \n  endcase \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes an input clock signal and generates an inverted clock signal as the output. It utilizes a simple logic gate to invert the input signal and assign it to the output.\n\n Module header:\n\nmodule bw_clk_gclk_inv_288x (clkout,clkin );\n [/INST]\n", "output": "output clkout; \n  input clkin; \n  assign clkout = ~( clkin ); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an instruction decode unit for a processor. It extracts various fields from the input instruction, such as the opcode, function code, register addresses, and immediate values. It then uses these fields to generate control signals for the processor, such as signals for memory operations, ALU operations, and register writes. Additionally, the module performs sign extension on the immediate value and concatenates the jump address with two zero bits. The module also interfaces with a control unit and a register file to generate the necessary control and data signals.\n\n Module header:\n\nmodule instructiondecode(output [31:0] read1, read2, immediateSE, PCPlus4D2,output [27:0] WAinstrD,output [4:0] rt, rd,output [2:0] ALUControlD,output RegWriteD, MemToRegD, MemWriteD, BranchD, ALUSrcD, RegDstD, JumpD,input [31:0] PCPlus4D1, instruction, ResultW,input [4:0] WriteRegW,input RegWriteW, clk);\n [/INST]\n", "output": "wire [25:0] jumpaddr; \n  wire [15:0] imm; \n  wire [5:0] opcode, funct; \n  wire [4:0] rs; \n  assign opcode = instruction[31:26]; \n  assign rs = instruction[25:21]; \n  assign jumpaddr = instruction[25:0]; \n  assign rt = instruction[20:16]; \n  assign rd = instruction[15:11]; \n  assign imm = instruction[15:0]; \n  assign funct = instruction[5:0]; \n ctrlunit ctrlunit_id(.OPCode( opcode ),.Funct( funct ),.MemToReg( MemToRegD ),.MemWrite( MemWriteD ),.Branch( BranchD ),.ALUSrc( ALUSrcD ),.RegDst( RegDstD ),.RegWrite( RegWriteD ),.Jump( JumpD ),.ALUControl( ALUControlD )); \n regfile regfile_id(.RD1( read1 ),.RD2( read2 ),.A1( rd ),.A2( rt ),.A3( WriteRegW ),.WD3( ResultW ),.WE3( RegWriteW ),.clk( clk )); \n  assign WAinstrD = {jumpaddr, {2'b00}}; \n  assign PCPlus4D2 = PCPlus4D1; \n  assign immediateSE = {{16{imm[15]}}, {imm[15:0]}}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module represents a Mealy finite state machine (FSM) with two input and two output bits. The module uses registers to store the current and next state, and it has defined states P, Q, R, and T. It operates based on the input, clock, and reset signals to update the state and output signals. The module has two always blocks - one for the state transitions and another for the outputs based on the current state and input. The state transitions and outputs are determined by specific conditions based on the current state and input values.\n\n Module header:\n\nmodule mealy_fsm ( input wire clk,input wire rst,input wire i_input,output reg o_output,output wire [1:0] o_current_state,output wire [1:0] o_next_state);\n [/INST]\n", "output": "reg [1:0] current_state; \n  reg [1:0] next_state; \n  localparam i_val_a = 1'b0; \n  localparam i_val_b = 1'b1; \n  localparam STATE_P = 2'b00; \n  localparam STATE_Q = 2'b01; \n  localparam STATE_R = 2'b10; \n  localparam STATE_T = 2'b11; \n  always @ ( posedge clk, posedge rst ) begin \n  if ( rst == 1'b1 ) begin \n  current_state <= 2'b0; \n  end else if ( clk == 1'b1) begin \n  current_state <= next_state; \n  end \n  end \n  assign o_current_state = current_state; \n  assign o_next_state = next_state; \n  always @ ( * ) begin \n  case (current_state) \n  STATE_P: begin \n  if (i_input == i_val_a) begin \n  next_state = STATE_R; \n  end else if (i_input == i_val_b) begin \n  next_state = STATE_T; \n  end \n  end \n  STATE_Q: begin \n  if (i_input == i_val_a) begin \n  next_state = STATE_P; \n  end else if (i_input == i_val_b) begin \n  next_state = STATE_Q; \n  end \n  end \n  STATE_R: begin \n  if (i_input == i_val_a) begin \n  next_state = STATE_Q; \n  end else if (i_input == i_val_b) begin \n  next_state = STATE_R; \n  end \n  end \n  STATE_T: begin \n  if (i_input == i_val_a) begin \n  next_state = STATE_R; \n  end else if (i_input == i_val_b) begin \n  next_state = STATE_P; \n  end \n  end \n  endcase \n  end \n  always @ ( * ) begin \n  case (current_state) \n  STATE_P: begin \n  if (i_input == i_val_a) begin \n  o_output = 1'b1; \n  end else if (i_input == i_val_b) begin \n  o_output = 1'b0; \n  end \n  end \n  STATE_Q: begin \n  if (i_input == i_val_a) begin \n  o_output = 1'b0; \n  end else if (i_input == i_val_b) begin \n  o_output = 1'b1; \n  end \n  end \n  STATE_R: begin \n  if (i_input == i_val_a) begin \n  o_output = 1'b1; \n  end else if (i_input == i_val_b) begin \n  o_output = 1'b0; \n  end \n  end \n  STATE_T: begin \n  if (i_input == i_val_a) begin \n  o_output = 1'b0; \n  end else if (i_input == i_val_b) begin \n  o_output = 1'b1; \n  end \n  end \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module, named shift, performs shifting operations on input A based on input B. It has parameters to specify whether A and B are signed, as well as their widths. The result is output through port Y. The module utilizes conditional assignment based on the signedness of A and B to perform the shifting operation. If A and B are signed, the module performs arithmetic right shift and left shift operations using the $signed() function. If A and B are unsigned, it performs logical right shift and left shift operations.\n\n Module header:\n\nmodule \\$shift (A, B, Y);\n [/INST]\n", "output": "parameter A_SIGNED = 0; \n parameter B_SIGNED = 0; \n parameter A_WIDTH = 0; \n parameter B_WIDTH = 0; \n parameter Y_WIDTH = 0; \n input [A_WIDTH-1:0] A; \n input [B_WIDTH-1:0] B; \n output [Y_WIDTH-1:0] Y; \n generate \n  if (A_SIGNED) begin:BLOCK1 \n  if (B_SIGNED) begin:BLOCK2 \n  assign Y = $signed(B) < 0 ? $signed(A) << -B : $signed(A) >> B; \n  end else begin:BLOCK3 \n  assign Y = $signed(A) >> B; \n  end \n  end else begin:BLOCK4 \n  if (B_SIGNED) begin:BLOCK5 \n  assign Y = $signed(B) < 0 ? A << -B : A >> B; \n  end else begin:BLOCK6 \n  assign Y = A >> B; \n  end \n  end \n endgenerate \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is designed to interface with a High-Speed (HS) communication protocol. It uses various input and output signals to manage data transmission and reception. The module includes logic to handle the readiness and validity of data transmission, and it processes the incoming and outgoing data based on the clock and reset signals. The module is structured to ensure proper synchronization and handling of the HS communication protocol.\n\n Module header:\n\nmodule myvrlg (input wire rst,input wire clk,output wire rx_hs_ready,input wire rx_hs_valid,input wire [63:0] rx_hs_data,input wire tx_hs_ready,output wire tx_hs_valid,output wire [63:0] tx_hs_data);\n [/INST]\n", "output": "reg inst_inst_tx_hs_valid; \n wire inst_inst_rx_hs_valid; \n reg [63:0] inst_inst_tx_hs_data; \n reg inst_inst_hs_en; \n reg inst_inst_rx_hs_ready; \n wire inst_inst_tx_hs_ready; \n reg inst_inst_hs_en_inst_state; \n wire inst1_snk_valid; \n wire inst1_snk_ready; \n wire [63:0] inst1_inst_snk_data; \n wire [63:0] inst0_snk_data; \n assign inst1_snk_ready = (!0) ? tx_hs_ready : 1; \n assign tx_hs_valid = inst1_snk_valid; \n assign inst1_snk_valid = inst_inst_tx_hs_valid; \n assign inst_inst_tx_hs_ready = (!0) ? inst1_snk_ready : 1; \n assign inst1_inst_snk_data = inst_inst_tx_hs_data; \n assign tx_hs_data = inst1_inst_snk_data[64-1:0]; \n assign inst_inst_rx_hs_valid = rx_hs_valid; \n assign rx_hs_ready = (!0) ? inst_inst_rx_hs_ready : 1; \n assign inst0_snk_data = rx_hs_data; \n always @(inst_inst_tx_hs_ready, inst_inst_rx_hs_valid, inst_inst_hs_en_inst_state) begin: PT_HS_TOP_INST_HS_EN_INST_RDY \n  if (((inst_inst_hs_en_inst_state == 0) || inst_inst_tx_hs_ready)) begin \n  inst_inst_rx_hs_ready = 1; \n  inst_inst_hs_en = inst_inst_rx_hs_valid; \n  end \n  else begin \n  inst_inst_rx_hs_ready = 0; \n  inst_inst_hs_en = 0; \n  end \n end \n always @(posedge clk) begin: PT_HS_TOP_INST_HS_EN_INST_CLK_PRCS \n  if (rst) begin \n  inst_inst_hs_en_inst_state <= 0; \n  inst_inst_tx_hs_valid <= 0; \n  end \n  else begin \n  if (inst_inst_rx_hs_ready) begin \n  inst_inst_hs_en_inst_state <= inst_inst_rx_hs_valid; \n  inst_inst_tx_hs_valid <= inst_inst_rx_hs_valid; \n  end \n  end \n end \n always @(posedge clk, posedge rst) begin: PT_HS_TOP_INST_CLK_PRCS_HS \n  if (rst == 1) begin \n  inst_inst_tx_hs_data <= 0; \n  end \n  else begin \n  if (inst_inst_hs_en) begin \n  inst_inst_tx_hs_data <= inst0_snk_data[64-1:0]; \n  end \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a sequential logic circuit with inputs in_a, in_b, and reset_l, and outputs a, b, and c. It uses a clock signal 'clk' for synchronization. The module uses the reset signal 'reset_l' to initialize the outputs to specific values. It also uses the inputs in_a and in_b to assign values to the outputs a and b based on the conditions of the reset signal. The module utilizes sequential logic to update the output values based on the inputs and the clock signal, ensuring synchronous operation.\n\n Module header:\n\nmodule x (a, b, c,clk, reset_l, in_a, in_b, in_c);\n [/INST]\n", "output": "input clk, reset_l, in_a,in_b,in_c; \n  output a,b,c; \n  reg a,b,c; \n  always @(posedge clk or negedge reset_l) begin \n  if (!reset_l) begin \n  c <= 1; \n  a <= #1 0; \n  b <= #1 0; \n  end \n  else begin \n  a <= in_a; \n  b <= in_b; \n  c <= in_c; \n  end \n  end \n  always @(posedge clk or negedge reset_l) begin \n  casex ({reset_l,in_a}) \n  2'b1_x: begin \n  a <= in_a; \n  b <= in_b; \n  c <= in_c; \n  end \n  2'b0_x: begin \n  c <= 1; \n  a <= #1 0; \n  b <= #1 0; \n  end \n  endcase \n  end \n  always @(in_a or in_b or reset_l) begin \n  casex ({reset_l,in_a}) \n  2'b1_x: begin \n  a = in_a; \n  b = in_b; \n  end \n  2'b0_x: begin \n  c = 1; \n  a = 0; \n  b = 0; \n  end \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a testbench for the ADC08D1020 serial interface. It simulates the clock signal, data input, address input, commit signal, and busy signal. The clock signal is generated with a specified period. The initial values for data, address, and commit signals are set, and then they are updated at specified time intervals. The module also instantiates the ADC serial module and connects its signals to the testbench signals for simulation.\n\n Module header:\n\nmodule adc08d1020_serial_tb;\n [/INST]\n", "output": "reg clk; \n  reg [15:0] data; \n  reg [3:0] addr; \n  reg commit; \n  wire busy; \n  parameter PERIOD = 16'd80; \n  always begin \n  clk = 1'b0; \n  #(PERIOD/2) clk = 1'b1; \n  #(PERIOD/2); \n  end \n  wire ADC_SCLK, ADC_SDATA, ADC_SCS; \n adc08d1020_serial adcserial (.sclk(ADC_SCLK),.sdata(ADC_SDATA),.scs(ADC_SCS),.w_data(data),.w_addr(addr),.commit(commit),.busy(busy),.clk12p5(clk)); \n  initial begin \n  data = 16'b0; \n  addr = 4'b0; \n  commit = 1'b0; \n  $stop; \n  #(PERIOD*16); \n  data = 16'hA11F; \n  #(PERIOD*16); \n  addr = 4'h3; \n  commit = 1'b1; \n  #(PERIOD*100); \n  addr = 4'h0; \n  commit = 1'b0; \n  #(PERIOD*100); \n  $stop; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, \"sink,\" takes an input \"in\" of size defined by the parameter \"SIZE.\" Inside an FPGA synthesis block, it declares a wire \"a\" and assigns it the result of a bitwise OR operation on the input \"in.\" This module is primarily used for FPGA synthesis and may optimize the logic accordingly.\n\n Module header:\n\nmodule sink (in);\n [/INST]\n", "output": "parameter SIZE = 1; \n input [SIZE-1:0] in; \n `ifdef FPGA_SYN \n  wire a; \n  assign a = | in; \n `endif \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module generates signals for controlling a VGA display. It uses the input clock signal to increment horizontal and vertical counters. When the counters reach specific values, it generates horizontal and vertical sync signals. Additionally, it resets the counters and sync signals when a reset signal is received.\n\n Module header:\n\nmodule VGA_Control (input clk,input rst,output reg HS,output reg VS,output reg [10:0] countX,output reg [9:0] countY);\n [/INST]\n", "output": "always @(posedge clk) begin \n  if(rst) begin \n  countX <= 0; \n  countY <= 0; \n  HS <= 1; \n  VS <= 1; \n  end else begin \n  if (countX == 1343) begin \n  countX <= 0; \n  if (countY == 805) countY <= 0; \n  else countY <= countY + 1'b1; \n  end else countX <= countX + 1'b1; \n  if (countX == 1047) HS <= 0; \n  else if (countX == 1143) HS <= 1; \n  if (countY == 770) VS <= 0; \n  else if (countY == 772) VS <= 1; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes in clock signals and various video mode inputs and decodes them to set different output modes based on specific conditions. For example, it sets the mode_atm_n_pent to 1 when atm_vmode is 3'b010, and it sets mode_zx to 1 when pent_vmode is 2'b00 or 2'b11. It also sets other output modes based on different combinations of input video modes. This module essentially acts as a decoder for video modes and sets various output modes based on specific input conditions.\n\n Module header:\n\nmodule video_modedecode(input wire clk,input wire [ 1:0] pent_vmode,input wire [ 2:0] atm_vmode,output reg mode_atm_n_pent,output reg mode_zx,output reg mode_p_16c,output reg mode_p_hmclr,output reg mode_a_hmclr,output reg mode_a_16c,output reg mode_a_text,output reg mode_a_txt_1page,output reg mode_pixf_14,output reg [ 1:0] mode_bw);\n [/INST]\n", "output": "always @(posedge clk) \n  begin \n  case( atm_vmode ) \n  3'b010: mode_atm_n_pent <= 1'b1; \n  3'b000: mode_atm_n_pent <= 1'b1; \n  3'b110: mode_atm_n_pent <= 1'b1; \n  3'b111: mode_atm_n_pent <= 1'b1; \n  3'b011: mode_atm_n_pent <= 1'b0; \n  default: mode_atm_n_pent <= 1'b0; \n  endcase \n  case( atm_vmode ) \n  3'b010: mode_zx <= 1'b0; \n  3'b000: mode_zx <= 1'b0; \n  3'b110: mode_zx <= 1'b0; \n  3'b111: mode_zx <= 1'b0; \n  default: begin \n  if( (pent_vmode==2'b00) || (pent_vmode==2'b11) ) \n  mode_zx <= 1'b1; \n  else \n  mode_zx <= 1'b0; \n  end \n  endcase \n  if( (atm_vmode==3'b011) && (pent_vmode==2'b10) ) \n  mode_p_16c <= 1'b1; \n  else \n  mode_p_16c <= 1'b0; \n  if( (atm_vmode==3'b011) && (pent_vmode==2'b01) ) \n  mode_p_hmclr <= 1'b1; \n  else \n  mode_p_hmclr <= 1'b0; \n  if( atm_vmode==3'b010 ) \n  mode_a_hmclr <= 1'b1; \n  else \n  mode_a_hmclr <= 1'b0; \n  if( atm_vmode==3'b000 ) \n  mode_a_16c <= 1'b1; \n  else \n  mode_a_16c <= 1'b0; \n  if( (atm_vmode==3'b110) || (atm_vmode==3'b111) ) \n  mode_a_text <= 1'b1; \n  else \n  mode_a_text <= 1'b0; \n  if( atm_vmode==3'b111 ) \n  mode_a_txt_1page <= 1'b1; \n  else \n  mode_a_txt_1page <= 1'b0; \n  if( (atm_vmode==3'b010) || (atm_vmode==3'b110) || (atm_vmode==3'b111) ) \n  mode_pixf_14 <= 1'b1; \n  else \n  mode_pixf_14 <= 1'b0; \n  if( (atm_vmode==3'b011) && (pent_vmode!=2'b10) ) \n  mode_bw <= 2'b00; \n  else \n  mode_bw <= 2'b01; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `sparc_exu_aluor32` implements a 32-bit logical NOR and NAND gate circuit. The input `in` is a 32-bit vector and the output `out` is a single bit. The module contains 16 NOR gates, 4 NAND gates, and 4 inverters. The NOR gates perform bitwise NOR operations on pairs of input bits, while the NAND gates perform bitwise NAND operations on groups of 4 NOR gate outputs. The inverters complement the outputs of the NAND gates. The final output `out` is the result of a bitwise AND operation on the outputs of the 4 inverters, producing the logical output of the circuit.\n\n Module header:\n\nmodule sparc_exu_aluor32 (out,in);\n [/INST]\n", "output": "input [31:0] in; \n  output out; \n  wire nor1_1; \n  wire nor1_2; \n  wire nor1_3; \n  wire nor1_4; \n  wire nor1_5; \n  wire nor1_6; \n  wire nor1_7; \n  wire nor1_8; \n  wire nor1_9; \n  wire nor1_10; \n  wire nor1_11; \n  wire nor1_12; \n  wire nor1_13; \n  wire nor1_14; \n  wire nor1_15; \n  wire nor1_16; \n  wire nand2_1; \n  wire nand2_2; \n  wire nand2_3; \n  wire nand2_4; \n  wire inv3_1; \n  wire inv3_2; \n  wire inv3_3; \n  wire inv3_4; \n  assign nor1_1 = ~(in[1] | in[0]); \n  assign nor1_2 = ~(in[3] | in[2]); \n  assign nor1_3 = ~(in[5] | in[4]); \n  assign nor1_4 = ~(in[7] | in[6]); \n  assign nor1_5 = ~(in[9] | in[8]); \n  assign nor1_6 = ~(in[11] | in[10]); \n  assign nor1_7 = ~(in[13] | in[12]); \n  assign nor1_8 = ~(in[15] | in[14]); \n  assign nor1_9 = ~(in[17] | in[16]); \n  assign nor1_10 = ~(in[19] | in[18]); \n  assign nor1_11 = ~(in[21] | in[20]); \n  assign nor1_12 = ~(in[23] | in[22]); \n  assign nor1_13 = ~(in[25] | in[24]); \n  assign nor1_14 = ~(in[27] | in[26]); \n  assign nor1_15 = ~(in[29] | in[28]); \n  assign nor1_16 = ~(in[31] | in[30]); \n  assign nand2_1 = ~(nor1_1 & nor1_2 & nor1_3 & nor1_4); \n  assign nand2_2 = ~(nor1_5 & nor1_6 & nor1_7 & nor1_8); \n  assign nand2_3 = ~(nor1_9 & nor1_10 & nor1_11 & nor1_12); \n  assign nand2_4 = ~(nor1_13 & nor1_14 & nor1_15 & nor1_16); \n  assign inv3_1 = ~nand2_1; \n  assign inv3_2 = ~nand2_2; \n  assign inv3_3 = ~nand2_3; \n  assign inv3_4 = ~nand2_4; \n  assign out = ~(inv3_1 & inv3_2 & inv3_3 & inv3_4); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module represents a one-wire I/O interface. It contains inputs for clock signal, data direction (DDIR), output data (DOUT), control signal for the 1-wire interface (DQ_CONTROL), and master reset signal (MR). The module also has outputs for input data (DIN), output enable for the 1-wire interface (DQ_IN), and 8 individual output enable signals (DQ0_T to DQ7_T). Additionally, it includes outputs for the 8 bits of data output (DQ0_O to DQ7_O) and inputs for the 8 bits of data input (DQ0_I to DQ7_I), as well as the DQ_SEL signal to select the input for DQ_IN.\n\nThe module contains logic to handle the input and output enables based on the DQ_SEL input and DQ_CONTROL, as well as assigning the input data to the DQ_IN register. The DQ_INTERNAL wire connects the DQ pins based on the DQ_SEL input. The always block handles the master reset signal and assigns the DQ_IN value accordingly.\n\n Module header:\n\nmodule one_wire_io (CLK, DDIR, DOUT, DQ_CONTROL, MR, DIN, DQ_IN, DATA_IN, DATA_OUT,DQ0_T, DQ1_T, DQ2_T, DQ3_T, DQ4_T, DQ5_T, DQ6_T, DQ7_T,DQ0_O, DQ1_O, DQ2_O, DQ3_O, DQ4_O, DQ5_O, DQ6_O, DQ7_O,DQ0_I, DQ1_I, DQ2_I, DQ3_I, DQ4_I, DQ5_I, DQ6_I, DQ7_I, DQ_SEL);\n [/INST]\n", "output": "input CLK; \n  input DDIR; \n  input [7:0] DOUT; \n  input DQ_CONTROL; \n  input MR; \n  output [7:0] DIN; \n  output DQ_IN; \n  input [7:0] DATA_IN; \n  output [7:0] DATA_OUT; \n  output DQ0_T; \n  output DQ1_T; \n  output DQ2_T; \n  output DQ3_T; \n  output DQ4_T; \n  output DQ5_T; \n  output DQ6_T; \n  output DQ7_T; \n  output DQ0_O; \n  output DQ1_O; \n  output DQ2_O; \n  output DQ3_O; \n  output DQ4_O; \n  output DQ5_O; \n  output DQ6_O; \n  output DQ7_O; \n  input DQ0_I; \n  input DQ1_I; \n  input DQ2_I; \n  input DQ3_I; \n  input DQ4_I; \n  input DQ5_I; \n  input DQ6_I; \n  input DQ7_I; \n  input [2:0] DQ_SEL; \n  reg DQ_IN; \n  assign DATA_OUT = DOUT; \n  assign DIN = DATA_IN; \n  wire DQ_INTERNAL; \n  assign DQ0_T = (DQ_SEL [2:0] == 0) ? DQ_CONTROL : 1'b1; \n  assign DQ1_T = (DQ_SEL [2:0] == 1) ? DQ_CONTROL : 1'b1; \n  assign DQ2_T = (DQ_SEL [2:0] == 2) ? DQ_CONTROL : 1'b1; \n  assign DQ3_T = (DQ_SEL [2:0] == 3) ? DQ_CONTROL : 1'b1; \n  assign DQ4_T = (DQ_SEL [2:0] == 4) ? DQ_CONTROL : 1'b1; \n  assign DQ5_T = (DQ_SEL [2:0] == 5) ? DQ_CONTROL : 1'b1; \n  assign DQ6_T = (DQ_SEL [2:0] == 6) ? DQ_CONTROL : 1'b1; \n  assign DQ7_T = (DQ_SEL [2:0] == 7) ? DQ_CONTROL : 1'b1; \n  assign DQ0_O = 1'b0; \n  assign DQ1_O = 1'b0; \n  assign DQ2_O = 1'b0; \n  assign DQ3_O = 1'b0; \n  assign DQ4_O = 1'b0; \n  assign DQ5_O = 1'b0; \n  assign DQ6_O = 1'b0; \n  assign DQ7_O = 1'b0; \n  assign DQ_INTERNAL = (DQ_SEL [2:0] == 0) & DQ0_I \n  | (DQ_SEL [2:0] == 1) & DQ1_I \n  | (DQ_SEL [2:0] == 2) & DQ2_I \n  | (DQ_SEL [2:0] == 3) & DQ3_I \n  | (DQ_SEL [2:0] == 4) & DQ4_I \n  | (DQ_SEL [2:0] == 5) & DQ5_I \n  | (DQ_SEL [2:0] == 6) & DQ6_I \n  | (DQ_SEL [2:0] == 7) & DQ7_I; \n  always @(posedge MR or negedge CLK) \n  if (MR) \n  DQ_IN <= 1'b1; \n  else \n  DQ_IN <= DQ_INTERNAL; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module simulates an interrupt controller. It includes signals for clock, interrupt enable, interrupt request, return address, branch, and program counter. The interrupt module receives these signals and outputs a branch to the Interrupt Service Routine (ISR) and the ISR address. During initialization, the module sets the initial values for the signals. Then, it simulates enabling and disabling interrupts and sets the interrupt request signal after a certain number of clock cycles. The clock signal is also negated in each cycle.\n\n Module header:\n\nmodule test_interrupt;\n [/INST]\n", "output": "reg clock; \n  reg IEN_d; \n  reg IOF_d; \n  reg RTI_d; \n  reg branch_d; \n  reg IRQ; \n  reg [11:0] PC; \n  wire branch_ISR; \n  wire [11:0] ISR_adr; \n interrupt uut (.clock(clock),.IEN_d(IEN_d),.IOF_d(IOF_d),.RTI_d(RTI_d),.branch_d(branch_d),.IRQ(IRQ),.PC(PC),.branch_ISR(branch_ISR),.ISR_adr(ISR_adr)); \n  initial begin \n  clock = 0; \n  IEN_d = 0; \n  IOF_d = 0; \n  RTI_d = 0; \n  branch_d = 0; \n  IRQ = 0; \n  PC = 35; \n  #1; \n  IEN_d = 1; \n  #1; \n  IEN_d = 0; \n  #5; \n  IRQ = 1; \n  end \n  always #1 clock = !clock; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a level-sensitive D latch with asynchronous reset. It has inputs D, nCLK, and nSET, and an output reg Q. The Q output is initialized to an undefined state, and it follows the input D when nCLK is low, unless nSET is low, in which case Q is set to 1.\n\n Module header:\n\nmodule GP_DLATCHS(input D, input nCLK, input nSET, output reg Q);\n [/INST]\n", "output": "parameter [0:0] INIT = 1'bx; \n  initial Q = INIT; \n  always @(*) begin \n  if(!nSET) \n  Q <= 1'b1; \n  else if(!nCLK) \n  Q <= D; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"DSC\" takes in various inputs such as clock signal, row and column addresses, and angle. It calculates and updates the real and imaginary parts of a complex number using these inputs and assigns intermediate ratios, checks for angle and position in range, and calculates the SRAM address. The module also instantiates the \"coordinate_cordic\" module, setting its inputs and outputs.\n\n Module header:\n\nmodule DSC(LCLK,Row,Column,SRAM_Addr,Inter_Ratio1,Inter_Ratio2,DeadZone,IN_Region,Real_X,Real_Y,DSC_ANGLE);\n [/INST]\n", "output": "input LCLK; \n  input [9:0] Row; \n  input [9:0] Column; \n  output reg [18:0] SRAM_Addr; \n  output reg [7:0] Inter_Ratio1; \n  output reg [7:0] Inter_Ratio2; \n  input [7:0] DeadZone; \n  output reg IN_Region; \n  output reg [17:0] Real_X; \n  output reg [14:0] Real_Y; \n  input [15:0] DSC_ANGLE; \n  reg signed [19:0] realIn; \n  reg signed [19:0] imagIn; \n  wire signed [14:0] Angle; \n  wire signed [21:0] Amp; \n  wire signed [14:0] SHADOW_ANGLE; \n  wire signed [14:0] Angle_pos; \n  assign Angle_pos = Angle + DSC_ANGLE[14:0]; \n  assign SHADOW_ANGLE = DSC_ANGLE[14:0] - 14'd100; \n  always @(posedge LCLK) begin \n  Real_X <= Amp*128/211; \n  Real_Y <= Angle_pos*256*64/DSC_ANGLE[14:0]; \n  Inter_Ratio1 <=Real_Y[7:0]; \n  Inter_Ratio2 <=Real_X[7:0]; \n  IN_Region <= (Angle[14]?(Angle>-SHADOW_ANGLE):(Angle<SHADOW_ANGLE)) && (Real_X[17:8] <10'd255+DeadZone) && (Real_X[17:8] > DeadZone) && (Column>10'd12 && Column<10'd321) ; \n  SRAM_Addr[18:8]<= {3'b0,Real_Y[14:8]}; \n  SRAM_Addr[7:0] <=(Real_X[17:8]>DeadZone)?({Real_X[17:8]}-DeadZone):9'd0; \n  realIn <= {(Row +DeadZone),8'd0}; \n  imagIn <= {Column,8'd0}+{-12'd156,8'b1111_1111}; \n  end \n  coordinate_cordic coordinate_cordic_Inst \n (.realIn(realIn),.imagIn(imagIn),.clk(LCLK),.amplitude(Amp),.angle(Angle),.test1(),.test2()); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a main decoder that takes a 6-bit input `op` and decodes it into various control signals such as `memtoreg`, `memwrite`, `branch`, `alusrc`, `regdst`, `regwrite`, `jump`, and `aluop`. It does this by using a case statement to assign values to the `controls` register based on the input `op`. The `controls` register is then used to assign the output control signals. If the input `op` does not match any of the defined cases, the output control signals are assigned to 'x'.\n\n Module header:\n\nmodule maindecoder(input [5:0] op,output memtoreg, memwrite,output branch, alusrc,output regdst, regwrite,output jump,output [1:0] aluop);\n [/INST]\n", "output": "reg [8:0] controls; \n  assign {memtoreg, memwrite, branch, alusrc, regdst, regwrite, jump, aluop} = controls; \n  always @ (op) begin \n  case(op) \n  6'b000000: controls <= 9'b000011011; \n  6'b100011: controls <= 9'b100101000; \n  6'b101011: controls <= 9'b010100000; \n  6'b000100: controls <= 9'b001000001; \n  6'b001000: controls <= 9'b000101000; \n  6'b000010: controls <= 9'b000000100; \n  default: controls <= 9'bxxxxxxxxx; \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module is a testbench for FPU (Floating Point Unit) multiplication. It involves the initialization of signals for clock, reset, FSM (Finite State Machine) controls, data inputs, and flags. It connects to an FPU multiplication function module and loads data from input files for processing. The module handles clock control, data transfer to the FPU module, file writing, and FSM interaction. The FPU module generates a final result in IEEE format, which is then written to a file. The testbench also manages the counter, clock signals, and communication with the FPU module. Additionally, it involves reading and processing input data, clock signal generation, and file writing.\n\n Module header:\n\nmodule Testbench_FPU_multiplication();\n [/INST]\n", "output": "parameter PERIOD = 10; \n `ifdef SINGLE \n  parameter W = 32; \n  parameter EW = 8; \n  parameter SW = 23; \n `endif \n `ifdef DOUBLE \n  parameter W = 64; \n  parameter EW = 11; \n  parameter SW = 52; \n `endif \n  reg clk; \n  reg rst; \n  reg beg_FSM; \n  reg ack_FSM; \n  reg [W-1:0] Data_MX; \n  reg [W-1:0] Data_MY; \n  reg [1:0] round_mode; \n  wire overflow_flag; \n  wire underflow_flag; \n  wire ready; \n  wire [W-1:0] final_result_ieee; \n FPU_Multiplication_Function #(.W(W),.EW(EW),.SW(SW)) uut(.clk(clk),.rst(rst),.beg_FSM(beg_FSM),.ack_FSM(ack_FSM),.Data_MX(Data_MX),.Data_MY(Data_MY),.round_mode(round_mode),.overflow_flag(overflow_flag),.underflow_flag(underflow_flag),.ready(ready),.final_result_ieee(final_result_ieee)); \n  reg [W-1:0] Array_IN [0:((2**PERIOD)-1)]; \n  reg [W-1:0] Array_IN_2 [0:((2**PERIOD)-1)]; \n  integer contador; \n  integer FileSaveData; \n  integer Cont_CLK; \n  integer Recept; \n  initial begin \n  clk = 0; \n  rst = 1; \n  beg_FSM = 0; \n  ack_FSM = 0; \n  Data_MX = 0; \n  Data_MY = 0; \n  round_mode = 2'b00; \n  FileSaveData = $fopen(\"ResultadoXilinxFLM.txt\",\"w\"); \n  contador = 0; \n  Cont_CLK = 0; \n  Recept = 1; \n  #100 rst = 0; \n  end \n  initial begin \n  $readmemh(\"Hexadecimal_A.txt\", Array_IN); \n  $readmemh(\"Hexadecimal_B.txt\", Array_IN_2); \n  end \n  always @(posedge clk) begin \n  if(rst) begin \n  contador = 0; \n  Cont_CLK = 0; \n  end \n  else begin \n  if (contador == (2**PERIOD)) begin \n  $fclose(FileSaveData); \n  $finish; \n  end \n  else begin \n  if(Cont_CLK ==1) begin \n  contador = contador + 1; \n  beg_FSM = 0; \n  Data_MX = Array_IN[contador]; \n  Data_MY = Array_IN_2[contador]; \n  Cont_CLK = Cont_CLK + 1; \n  ack_FSM = 0; \n  end \n  else if(Cont_CLK ==2) begin \n  ack_FSM = 0; \n  beg_FSM = 1; \n  Cont_CLK = Cont_CLK +1 ; \n  end \n  else begin \n  ack_FSM = 0; \n  Cont_CLK = Cont_CLK + 1; \n  beg_FSM = 0; \n  end \n  if(ready==1) begin \n  ack_FSM = 1; \n  Cont_CLK = 0; \n  end \n  if(ready==1 && ack_FSM) begin \n  Cont_CLK = 0; \n  end \n  end \n  end \n  end \n  always @(posedge clk) begin \n  if(ready) begin \n  if(Recept == 1) begin \n  $fwrite(FileSaveData,\"%h\\n\",final_result_ieee); \n  Recept = 0; \n  end \n  end \n  else begin \n  Recept = 1; \n  end \n  end \n  initial forever #5 clk = ~clk; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module implements an ADPCM (Adaptive Differential Pulse Code Modulation) driver for a specific audio processing application. It processes input data and generates signed 16-bit PCM output for left and right channels. It includes components for nibble selection, channel selection, address and data control, PCM decoding, interpolation, and gain adjustment. The module also handles resetting, clocking, and control signals, including restart and advance signals for the address counter. Additionally, it updates the left and right PCM channels based on specific conditions and control signals.\n\n Module header:\n\nmodule jt10_adpcm_drvB(input rst_n,input clk,input cen,input cen55,input acmd_on_b,input acmd_rep_b,input acmd_rst_b,input acmd_up_b,input [ 1:0] alr_b,input [15:0] astart_b,input [15:0] aend_b,input [15:0] adeltan_b,input [ 7:0] aeg_b,output flag,input clr_flag,output [23:0] addr,input [ 7:0] data,output reg roe_n,output reg signed [15:0] pcm55_l,output reg signed [15:0] pcm55_r);\n [/INST]\n", "output": "wire nibble_sel; \n wire adv; \n wire restart; \n wire chon; \n always @(posedge clk) roe_n <= ~(adv & cen55); \n jt10_adpcmb_cnt u_cnt(.rst_n ( rst_n ),.clk ( clk ),.cen ( cen55 ),.delta_n ( adeltan_b ),.acmd_up_b ( acmd_up_b ),.clr ( acmd_rst_b ),.on ( acmd_on_b ),.astart ( astart_b ),.aend ( aend_b ),.arepeat ( acmd_rep_b ),.addr ( addr ),.nibble_sel ( nibble_sel ),.chon ( chon ),.clr_flag ( clr_flag ),.flag ( flag ),.restart ( restart ),.adv ( adv )); \n reg [3:0] din; \n always @(posedge clk) din <= !nibble_sel ? data[7:4] : data[3:0]; \n wire signed [15:0] pcmdec, pcminter, pcmgain; \n jt10_adpcmb u_decoder(.rst_n ( rst_n ),.clk ( clk ),.cen ( cen ),.adv ( adv & cen55 ),.data ( din ),.chon ( chon ),.clr ( flag | restart ),.pcm ( pcmdec )); \n `ifndef NOBINTERPOL \n jt10_adpcmb_interpol u_interpol(.rst_n ( rst_n ),.clk ( clk ),.cen ( cen ),.cen55 ( cen55 && chon ),.adv ( adv ),.pcmdec ( pcmdec ),.pcmout ( pcminter )); \n `else \n assign pcminter = pcmdec; \n `endif \n jt10_adpcmb_gain u_gain(.rst_n ( rst_n ),.clk ( clk ),.cen55 ( cen55 ),.tl ( aeg_b ),.pcm_in ( pcminter ),.pcm_out( pcmgain )); \n always @(posedge clk) if(cen55) begin \n  pcm55_l <= alr_b[1] ? pcmgain : 16'd0; \n  pcm55_r <= alr_b[0] ? pcmgain : 16'd0; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module `efc_saed` implements a simple edge detector circuit. It has an asynchronous input `async_in` and clock input `clk`, and outputs `rise_det` and `fall_det` indicating the detection of rising and falling edges, respectively. It uses flip-flops to store and compare previous input values to detect edge transitions. The `rise_det` output is set when there is a transition from low to high, and `fall_det` is set when there is a transition from high to low.\n\n Module header:\n\nmodule efc_saed (rise_det, fall_det,async_in, clk);\n [/INST]\n", "output": "output rise_det; \n output fall_det; \n input async_in; \n input clk; \n wire snc1_ff; \n wire snc2_ff; \n wire hist_ff; \n bw_u1_syncff_4x snc1_reg(.so(),.q (snc1_ff),.ck (clk),.d (async_in),.sd(),.se(1'b0)); \n dff_ns #(1) snc2_reg (.din(snc1_ff), .q(snc2_ff), .clk(clk)); \n dff_ns #(1) hist_reg (.din(snc2_ff), .q(hist_ff), .clk(clk)); \n assign rise_det = !hist_ff && snc2_ff; \n assign fall_det = hist_ff && !snc2_ff; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module defines a ROM (Read-Only Memory) with 8 entries, each with a 3-bit address and 16-bit data. On the positive edge of the clock, the module updates the output data based on the address input using a case statement. Each address is mapped to a specific 16-bit data value.\n\n Module header:\n\nmodule coeff_rom (input clock, input [2:0] addr, output reg [15:0] data);\n [/INST]\n", "output": "always @(posedge clock) \n  case (addr) \n  3'd0 : data <= #1 -16'd49; \n  3'd1 : data <= #1 16'd165; \n  3'd2 : data <= #1 -16'd412; \n  3'd3 : data <= #1 16'd873; \n  3'd4 : data <= #1 -16'd1681; \n  3'd5 : data <= #1 16'd3135; \n  3'd6 : data <= #1 -16'd6282; \n  3'd7 : data <= #1 16'd20628; \n  endcase \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a D flip-flop with clock, enable, reset, data input, and output signals. It uses a parameter WIDTH to specify the width of the data input and output. The flip-flop updates its output q on the rising edge of the clock or when the reset signal is asserted. When reset is high, q is set to 0, and when the enable signal is high, q is updated with the input data d.\n\n Module header:\n\nmodule CC_DFlipFlop(clk, en, reset, d, q);\n [/INST]\n", "output": "parameter WIDTH=1; \n  input clk; \n  input en; \n  input reset; \n  input [WIDTH-1:0] d; \n  output [WIDTH-1:0] q; \n  reg [WIDTH-1:0] q; \n  always @ (posedge clk or posedge reset) \n  if (reset) \n  q <= 0; \n  else if (en) \n  q <= d; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a clock domain crossing circuit for an AXI Stream interface. It synchronizes the data and valid signals from the input clock domain (in_clk) to the output clock domain (aclk). The input data (cfg_data) is registered in int_tdata_reg on the input clock edge. The module uses a toggle signal to handle clock domain crossings, and the valid signal (m_axis_tvalid) is synchronized to the output clock domain. The output data (m_axis_tdata) is driven from int_tdata_reg. The module also includes a comparator to detect changes in the input data and uses this to update the valid signal.\n\n Module header:\n\nmodule axis_cdc_variable # (parameter integer AXIS_TDATA_WIDTH = 32) (input wire in_clk,input wire aclk,input wire aresetn,input wire [AXIS_TDATA_WIDTH-1:0] cfg_data,input wire m_axis_tready,output wire [AXIS_TDATA_WIDTH-1:0] m_axis_tdata,output wire m_axis_tvalid);\n [/INST]\n", "output": "reg [AXIS_TDATA_WIDTH-1:0] int_tdata_reg; \n  reg int_tvalid_reg, int_tvalid_next; \n  reg s_toggle; \n  reg [2:0] m_sync; \n  wire compare; \n  always @(posedge in_clk) \n  s_toggle <= s_toggle ^ compare ; \n  always @(posedge aclk) \n  m_sync <= {m_sync[1:0],s_toggle}; \n  always @(posedge in_clk) \n  begin \n  if(~aresetn) \n  int_tdata_reg <= {(AXIS_TDATA_WIDTH){1'b0}}; \n  else \n  int_tdata_reg <= cfg_data; \n  end \n  always @(posedge aclk) \n  int_tvalid_reg <= int_tvalid_next; \n  always @* \n  begin \n  int_tvalid_next = int_tvalid_reg; \n  if(m_sync[2] ^ m_sync[1] ) \n  begin \n  int_tvalid_next = 1'b1; \n  end \n  if(m_axis_tready & int_tvalid_reg) \n  begin \n  int_tvalid_next = 1'b0; \n  end \n  end \n  assign compare = int_tdata_reg != cfg_data; \n  assign m_axis_tdata = int_tdata_reg; \n  assign m_axis_tvalid = int_tvalid_reg; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a constant generator. It outputs a single bit signal 'op' that is always set to 0, regardless of the input signals clk, ce, and clr.\n\n Module header:\n\nmodule sysgen_constant_f007950b6c (output [(1 - 1):0] op,input clk,input ce,input clr);\n [/INST]\n", "output": "assign op = 1'b0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a state machine and checksum calculation based on input signals. It updates the reg0 and checksum values based on input channel addresses and validity signals. The f2hData_out and f2hValid_out signals are assigned based on the channel address and other conditions. The led_out signal is set to the reg0 value, and the flags signal is generated based on specific conditions. Additionally, the module interfaces with a seven-segment display module.\n\n Module header:\n\nmodule swled(input wire clk_in,input wire reset_in,input wire[6:0] chanAddr_in,input wire[7:0] h2fData_in,input wire h2fValid_in,output wire h2fReady_out,output wire[7:0] f2hData_out,output wire f2hValid_out,input wire f2hReady_in,output wire[7:0] sseg_out,output wire[3:0] anode_out,output wire[7:0] led_out,input wire[7:0] sw_in);\n [/INST]\n", "output": "wire[3:0] flags; \n  reg[7:0] reg0 = 8'h00; \n  wire[7:0] reg0_next; \n  reg[15:0] checksum = 16'h0000; \n  wire[15:0] checksum_next; \n  always @(posedge clk_in) \n  begin \n  if ( reset_in == 1'b1 ) \n  begin \n  reg0 <= 8'h00; \n  checksum <= 16'h0000; \n  end \n  else \n  begin \n  reg0 <= reg0_next; \n  checksum <= checksum_next; \n  end \n  end \n  assign reg0_next = \n  (chanAddr_in == 7'b0000000 && h2fValid_in == 1'b1) ? h2fData_in : \n  reg0; \n  assign checksum_next = \n  (chanAddr_in == 7'b0000000 && h2fValid_in == 1'b1) ? \n  checksum + h2fData_in : \n  (chanAddr_in == 7'b0000001 && h2fValid_in == 1'b1) ? \n  {h2fData_in, checksum[7:0]} : \n  (chanAddr_in == 7'b0000010 && h2fValid_in == 1'b1) ? \n  {checksum[15:8], h2fData_in} : \n  checksum; \n  assign f2hData_out = \n  (chanAddr_in == 7'b0000000) ? sw_in : \n  (chanAddr_in == 7'b0000001) ? checksum[15:8] : \n  (chanAddr_in == 7'b0000010) ? checksum[7:0] : \n  8'h00; \n  assign f2hValid_out = 1'b1; \n  assign h2fReady_out = 1'b1; \n  assign led_out = reg0; \n  assign flags = {3'b00, f2hReady_in, reset_in}; \n seven_seg seven_seg(.clk_in(clk_in),.data_in(checksum),.dots_in(flags),.segs_out(sseg_out),.anodes_out(anode_out)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module represents a control unit for a Serial Peripheral Interface (SPI) device. It interfaces with a FIFO to read and write data. The module includes logic to handle writing to and reading from the TX and RX FIFOs, as well as signaling the last frame in the TX FIFO. It also contains a state machine that monitors the penable and psel signals to determine the operation to perform based on the address input and write signal. When the conditions are met, the module sets appropriate signals to write to the TX FIFO, read from the RX FIFO, or indicate the last frame in the TX FIFO.\n\n Module header:\n\nmodule spi_control # (parameter CFG_FRAME_SIZE = 4)( input pclk,input presetn,input psel,input penable,input pwrite,input [6:0] paddr,input [CFG_FRAME_SIZE-1:0] wr_data_in,input cfg_master,input rx_fifo_empty,input tx_fifo_empty,output [CFG_FRAME_SIZE-1:0] tx_fifo_data,output tx_fifo_write,output tx_fifo_last,output rx_fifo_read);\n [/INST]\n", "output": "reg tx_fifo_write_sig; \n reg rx_fifo_read_sig; \n reg tx_last_frame_sig; \n assign tx_fifo_last = tx_last_frame_sig; \n assign tx_fifo_data = wr_data_in; \n assign tx_fifo_write = tx_fifo_write_sig; \n assign rx_fifo_read = rx_fifo_read_sig; \n always @(*) \n  begin \n  rx_fifo_read_sig = 1'b0; \n  tx_fifo_write_sig = 1'b0; \n  tx_last_frame_sig = 1'b0; \n  if (penable && psel) \n  begin \n  case (paddr) \n  6'h0C: \n  begin \n  if (pwrite) \n  begin \n  tx_fifo_write_sig = 1'b1; \n  end \n  end \n  6'h08: \n  begin \n  if (~pwrite) \n  begin \n  rx_fifo_read_sig = 1'b1; \n  end \n  end \n  6'h28: \n  begin \n  tx_fifo_write_sig = 1'b1; \n  tx_last_frame_sig = 1'b1; \n  end \n  default: \n  begin \n  end \n  endcase \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `TopLevel` takes various inputs such as `clk`, `key_in`, `switch_in`, `switch_second`, `type_in`, and generates outputs `s_out`, `LCD_ON`, `LCD_BLON`, `LCD_EN`, `LCD_RW`, `LCD_RS`, `LCD_DATA`. It also utilizes internal wires and registers to manage timing and control signals. The module instantiates sub-modules like `Timer`, `Settime`, `Countdowner`, `Display7seg`, `ShowTime`, `LCDDisplay`, and `ButtonSignal` to perform specific functions such as timekeeping, displaying on a 7-segment display, controlling an LCD, and processing user input. The functionality is driven by the clock signal and internal logic for controlling various peripherals and performing specific tasks based on the inputs.\n\n Module header:\n\nmodule TopLevel(clk,key_in,switch_in,switch_second,type_in,s_out,LCD_ON,LCD_BLON,LCD_EN,LCD_RW,LCD_RS,LCD_DATA);\n [/INST]\n", "output": "input [3:0] key_in; \n  input clk; \n  input switch_in; \n  input [15:0] switch_second; \n  input type_in; \n  output [63:0] s_out; \n  wire [63:0] seg_o; \n  assign s_out = ~seg_o; \n  output LCD_ON, LCD_BLON, LCD_EN, LCD_RW, LCD_RS; \n  output [7:0] LCD_DATA; \n  assign LCD_ON = 1; \n  assign LCD_BLON = 1; \n  wire [1:0] lcd_func; \n  wire [7:0] lcd_data; \n  assign LCD_RS = lcd_func[1]; \n  assign LCD_RW = lcd_func[0]; \n  assign LCD_DATA = lcd_data; \n  wire [31:0] second; \n  wire [31:0] second_tmp; \n  wire [31:0] second_countdown; \n  wire [2:0] key_press; \n  reg slow_clk; \n  integer slow_clk_counter; \n  initial begin \n  slow_clk <= 0; \n  slow_clk_counter <= 0; \n  end \n  always@(negedge clk) begin \n  if (slow_clk_counter == 9) begin \n  slow_clk_counter <= 0; \n  slow_clk <= ~slow_clk; \n  end else begin \n  slow_clk_counter <= slow_clk_counter + 1; \n  end \n  end \n  Timer timer(slow_clk, key_press, second); \n  Settime settime(switch_in, switch_second, clk, second_tmp); \n  Countdowner countdowner(slow_clk, second_tmp, key_press, second_countdown); \n  Display7seg display7seg(second, second_countdown, type_in, seg_o); \n  wire [127:0] show_time; \n  ShowTime showTime(second, show_time); \n  LCDDisplay lcdDisplay(slow_clk, key_press, show_time, LCD_EN, lcd_func, lcd_data); \n  ButtonSignal buttonSignal(slow_clk, key_in, key_press); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a control unit for a processor. It takes a 6-bit input from the instruction memory and controls various operations of the processor based on the input. It sets control signals for branch, memory write, memory read, ALU source, register write, register destination, ALU operation, and memory to register transfer. The module behaves differently based on the specific value of the input, and sets the control signals accordingly to facilitate the proper execution of different types of instructions in the processor.\n\n Module header:\n\nmodule controlunit(input [5:0] imemout,output brnch,output memorywrite,output memoryread,output alusrc,output regw,output regdst,output aluop,output memtoreg);\n [/INST]\n", "output": "reg brnch,memorywrite,memoryread,aluop; \n reg memtoreg,alusrc,regw,regdst; \n always @ ( imemout ) \n begin \n  if(imemout[5:0] == 6'b000000) \n  begin \n  brnch = 1'b0; \n  memorywrite = 1'b0; \n  memoryread = 1'b0; \n  alusrc = 1'b0; \n  regw = 1'b1; \n  regdst = 1'b1; \n  aluop = 1'b1; \n  memtoreg = 1'b1; \n  end \n  else \n  if(imemout[5:0] == 6'b100011) \n  begin \n  brnch = 1'b0; \n  memorywrite = 1'b0; \n  memoryread = 1'b1; \n  alusrc = 1'b1; \n  regw = 1'b1; \n  regdst = 1'b0; \n  aluop = 1'b0; \n  memtoreg = 1'b0; \n  end \n  else \n  if(imemout[5:0] == 6'b101011) \n  begin \n  brnch = 1'b0; \n  memorywrite = 1'b1; \n  memoryread = 1'b0; \n  alusrc = 1'b1; \n  regw = 1'b0; \n  regdst = 1'b0; \n  aluop = 1'b0; \n  memtoreg = 1'b0; \n  end \n  else \n  if(imemout[5:0] == 6'b000100) \n  begin \n  brnch = 1'b1; \n  memorywrite = 1'b0; \n  memoryread = 1'b0; \n  alusrc = 1'b0; \n  regw = 1'b0; \n  regdst = 1'b0; \n  aluop = 1'b0; \n  memtoreg = 1'b0; \n  end \n  else \n  begin \n  brnch = 1'b0; \n  memorywrite = 1'b0; \n  memoryread = 1'b0; \n  alusrc = 1'b0; \n  regw = 1'b0; \n  regdst = 1'b0; \n  aluop = 1'b0; \n  memtoreg = 1'b0; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements an 8-bit Linear Feedback Shift Register (LFSR) counter. The module has an input clock and reset, and an output indicating when the LFSR has cycled through 255 values. The LFSR is updated on each clock cycle, and it resets to 0 when the LFSR reaches a specific value (8'h80). The module uses an XNOR gate to compute the next value of the LFSR based on the current state, and it outputs the done flag when the LFSR has completed 255 cycles.\n\n Module header:\n\nmodule lfsr_count255(input i_sys_clk,input i_sys_rst,output reg o_lfsr_256_done);\n [/INST]\n", "output": "reg [7:0] lfsr_reg_i; \n  wire lfsr_d0_i,lfsr_256_equal_i; \n  xnor(lfsr_d0_i,lfsr_reg_i[7],lfsr_reg_i[5],lfsr_reg_i[4],lfsr_reg_i[3]); \n  assign lfsr_256_equal_i = (lfsr_reg_i == 8'h80); \n  always @(posedge i_sys_clk,posedge i_sys_rst) begin \n  if(i_sys_rst) begin \n  lfsr_reg_i <= 0; \n  o_lfsr_256_done <= 0; \n  end \n  else begin \n  lfsr_reg_i <= lfsr_256_equal_i ? 8'h0 : {lfsr_reg_i[6:0],lfsr_d0_i}; \n  o_lfsr_256_done <= lfsr_256_equal_i; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a game text display unit for a VGA display. It includes state registers for game state and RGB state, pixel coordinates, video control signals, text control signals, and digital outputs for game elements. It uses sub-modules for VGA synchronization and game text generation. The module processes input signals and produces output signals for generating game text on the display based on the current game state.\n\n Module header:\n\nmodule game_text_top_ya (input wire clk, reset,input wire [1:0] btn,output wire hsync, vsync,output wire [2:0] rgb);\n [/INST]\n", "output": "localparam [1:0] \n  newgame = 2'b00, \n  play = 2'b01, \n  newball = 2'b10, \n  over = 2'b11; \n  reg [1:0] state_reg, state_next; \n  wire [9:0] pixel_x, pixel_y; \n  wire video_on, pixel_tick; \n  wire [3:0] text_on; \n  wire [2:0] text_rgb; \n  reg [2:0] rgb_reg, rgb_next; \n  wire [3:0] dig0, dig1; \n  reg [1:0] ball_reg, ball_next; \n  assign dig0 = 4'b0000; \n  assign dig1 = 4'b0000; \n  vga_sync vsync_unit \n (.clk(clk), .reset(reset), .hsync(hsync), .vsync(vsync),.video_on(video_on), .p_tick(pixel_tick),.pixel_x(pixel_x), .pixel_y(pixel_y)); \n  game_text game_text_unit \n (.clk(clk),.pix_x(pixel_x), .pix_y(pixel_y),.dig0(dig0), .dig1(dig1), .ball(ball_reg),.text_on(text_on), .text_rgb(text_rgb)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module serves as a clock management module for the Arty board. It takes an input clock (clk_in) and a reset signal (resetn), and provides two outputs: a 50MHz clock (clk_50m) and a locked signal. The locked signal is tied to the reset signal, and the 50MHz clock is directly connected to the input clock.\n\n Module header:\n\nmodule arty_mmcm (clk_50m, locked,clk_in, resetn);\n [/INST]\n", "output": "input clk_in; \n  output clk_50m; \n  input resetn; \n  output locked; \n  reg clk_50m; \n  reg locked; \n  assign locked = resetn; \n  assign clk_50m = clk_in; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an implementation of a state machine that controls the data output based on the input signals and internal counters and timers. The state machine has five states, each with specific conditions to transition between states. The module includes registers for data storage, state machine state, timers, counters, and other control signals. It also detects edges on the input key signal and toggles the 'on' register based on the number of key presses. The data output is updated based on the state machine state and timer matches. Finally, the output 'data' is assigned the value stored in the 'r_data' register.\n\n Module header:\n\nmodule neopixels(input CLOCK_50,input [1:0] KEY,output data);\n [/INST]\n", "output": "reg r_data; \n  reg [3:0] state_reg; \n  reg [3:0] state_set = 4'b0; \n  reg [7:0] timer_0 = 7'b0; \n  reg [7:0] timer_0_compare = 7'd40; \n  reg timer_0_run = 1'b0; \n  reg timer_0_match = 1'b0; \n  reg [32:0] counter = 32'b0; \n  reg lighting = 1'b0; \n  reg [7:0] press_count = 8'b0; \n  reg [1:0] key_edge_detect = 2'b00; \n  reg on = 1'b1; \n  assign data = r_data; \n  always @(posedge CLOCK_50) begin \n  if (key_edge_detect == 2'b10) begin \n  lighting <= 1'b1; \n  counter <= 1'b0; \n  press_count <= press_count + 1'b1; \n  if (press_count == 16) begin \n  press_count <= 1'b0; \n  on <= !on; \n  end \n  end \n  if (lighting) begin \n  if (counter == (32'd24 * press_count)) begin \n  lighting <= 1'b0; \n  end else begin \n  if (state_reg == 4'b0 && state_set == 4'b0) begin \n  counter <= counter + 1'b1; \n  if (on) begin \n  state_set <= 4'b0001; \n  end else begin \n  state_set <= 4'b0100; \n  end \n  end else begin \n  state_set <= 4'b0; \n  end \n  end \n  end else begin \n  state_set <= 4'b0; \n  end \n  end \n  always @(posedge CLOCK_50) begin \n  key_edge_detect <= {key_edge_detect[0], KEY[1]}; \n  end \n  always @(posedge CLOCK_50) begin \n  if (timer_0_run) begin \n  if (timer_0 == timer_0_compare) begin \n  timer_0 <= 1'b0; \n  timer_0_match <= 1'b1; \n  end else begin \n  timer_0 <= timer_0 + 1'b1; \n  timer_0_match <= 1'b0; \n  end \n  end else begin \n  timer_0 <= 1'b0; \n  timer_0_match <= 1'b0; \n  end \n  end \n  always @(posedge CLOCK_50) begin \n  case (state_reg) \n  4'b0000: \n  begin \n  if (state_set != 4'b0) begin \n  state_reg <= state_set; \n  end \n  r_data <= 1'b0; \n  end \n  4'b0001: \n  begin \n  if (timer_0_match) begin \n  timer_0_run <= 1'b0; \n  state_reg <= 4'b0010; \n  end else begin \n  r_data <= 1'b1; \n  timer_0_compare <= 7'd40; \n  timer_0_run <= 1'b1; \n  end \n  end \n  4'b0010: \n  begin \n  if (timer_0_match) begin \n  timer_0_run <= 1'b0; \n  state_reg <= 4'b0; \n  end else begin \n  r_data <= 1'b0; \n  timer_0_compare <= 7'd20; \n  timer_0_run <= 1'b1; \n  end \n  end \n  4'b0100: \n  begin \n  if (timer_0_match) begin \n  timer_0_run <= 1'b0; \n  state_reg <= 4'b1000; \n  end else begin \n  r_data <= 1'b1; \n  timer_0_compare <= 7'd20; \n  timer_0_run <= 1'b1; \n  end \n  end \n  4'b1000: \n  begin \n  if (timer_0_match) begin \n  timer_0_run <= 1'b0; \n  state_reg <= 4'b0; \n  end else begin \n  r_data <= 1'b0; \n  timer_0_compare <= 7'd40; \n  timer_0_run <= 1'b1; \n  end \n  end \n  default: \n  begin \n  state_reg <= 4'b0; \n  end \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a combinational logic circuit that takes three 4-bit inputs (in1, in2, in3) and produces three 4-bit outputs (out1, out2, out3). The outputs are determined based on the value of the inputs. For instance, the module checks the value of in1 and assigns a specific value to out1 based on the case. Similarly, the value of in1 is also used to calculate out2 and out3 using different cases. If in1 has a particular value, the corresponding block of code determines the value of out3.\n\n Module header:\n\nmodule autoconstant_gooch (out1, out2, out3,in1, in2, in3);\n [/INST]\n", "output": "input [3:0] in1; \n  input [3:0] in2; \n  input [3:0] in3; \n  output [3:0] out1; \n  reg [3:0] out1; \n  output [3:0] out2; \n  reg [3:0] out2; \n  output [3:0] out3; \n  reg [3:0] out3; \n  always @(in1 or in2 or in3) \n  begin \n  case (in1) \n  4'b0001 : begin \n  out1 = in2; \n  end \n  4'b0010 : begin \n  out1 = in2 + in3; \n  end \n  4'b0100 : begin \n  out1 = in2 - in3; \n  end \n  4'b1000 : begin \n  out1 = in2; \n  end \n  default : begin \n  out1 = {4{1'b0}}; \n  end \n  endcase \n  end \n  always @(in1 or in2 or in3) \n  begin \n  case (in1) \n  4'b0001 : begin \n  out2 = in2; \n  end \n  4'b0010 : begin \n  out2 = in2 + in3; \n  end \n  4'b0100 : begin \n  out2 = in2 - in3; \n  end \n  4'b1000 : begin \n  out2 = in2; \n  end \n  default : begin \n  out2 = {4{1'b0}}; \n  end \n  endcase \n  end \n  always @(in1 or in2 or in3) \n  begin \n  out3 = in1 + in2; \n  temp2 = temp; \n  case (in1) \n  4'b0001 : begin \n  out3 = in2; \n  end \n  4'b0010 : begin \n  out3 = in2 + in3; \n  end \n  4'b0100 : begin \n  out3 = in2 - in3; \n  end \n  4'b1000 : begin \n  out3 = in2; \n  end \n  default : begin \n  out3 = {4{1'b0}}; \n  end \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a data shifting operation. It has input ports for data_in, wr_en, shift_en, clk, and rst, and an output port for data_out. The data_in is a vector of specified width. The module has combinational logic for write or shift operation and uses a case statement for output enable/disable. It includes a register file with a 16-bit output, and 4 multiplexers for different bit ranges. The module performs shifting based on the input signals and produces the shifted output in data_out.\n\n Module header:\n\nmodule shift_in (data_in,wr_en,shift_en,data_out,clk,rst);\n [/INST]\n", "output": "parameter WIDTH=1; \n input [(64*WIDTH)-1:0] data_in; \n input wr_en; \n input shift_en; \n output [(16*WIDTH)-1:0] data_out; \n input clk; \n input rst; \n wire [(64*WIDTH)-1:0] reg_in; \n wire [(64*WIDTH)-1:0] reg_out; \n reg line_wr_en; \n reg s_or_w_; \n always @ (shift_en or wr_en) \n begin \n  casex({shift_en,wr_en}) \n  2'b00: \n  begin \n  line_wr_en <= 1'b0; \n  s_or_w_ <= 1'bx; \n  end \n  2'b01: \n  begin \n  line_wr_en <= 1'b1; \n  s_or_w_ <= 1'b0; \n  end \n  2'b10: \n  begin \n  line_wr_en <= 1'b1; \n  s_or_w_ <= 1'b1; \n  end \n  default: \n  begin \n  line_wr_en <= 1'bx; \n  s_or_w_ <= 1'bx; \n  end \n  endcase \n end \n register #(WIDTH*16) reg_line[3:0](.out(reg_out), .in(reg_in), .wr_en(line_wr_en), .clk(clk), .rst(rst)); \n mux_2_to_1 #(WIDTH*16) line3_mux(.out(reg_in[(WIDTH*64)-1:(WIDTH*48)]), .in({{WIDTH*16{1'bx}},data_in[(WIDTH*64)-1:(WIDTH*48)]}), .select(s_or_w_)); \n mux_2_to_1 #(WIDTH*16) line2_mux(.out(reg_in[(WIDTH*48)-1:(WIDTH*32)]), .in({reg_out[(WIDTH*64)-1:WIDTH*48],data_in[(WIDTH*48)-1:(WIDTH*32)]}), .select(s_or_w_)); \n mux_2_to_1 #(WIDTH*16) line1_mux(.out(reg_in[(WIDTH*32)-1:(WIDTH*16)]), .in({reg_out[(WIDTH*48)-1:WIDTH*32],data_in[(WIDTH*32)-1:(WIDTH*16)]}), .select(s_or_w_)); \n mux_2_to_1 #(WIDTH*16) line0_mux(.out(reg_in[(WIDTH*16)-1:0]), .in({reg_out[(WIDTH*32)-1:WIDTH*16],data_in[(WIDTH*16)-1:0]}), .select(s_or_w_)); \n assign data_out = reg_out[(WIDTH*16)-1:0]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module is a halfband filter with decimation factor and interpolation rate parameters. It has a delay line, coefficient array, and a counter. On reset, it initializes the delay line and sets the output to zero. When enabled, it shifts the delay line, updates the temp variable by accumulating the delayed elements multiplied by coefficients, and then outputs the result. The module supports strobing based on the decimation and interpolation parameters.\n\n Module header:\n\nmodule halfband_ideal (input clock,input reset,input enable,input strobe_in,input wire signed [17:0] data_in,output reg strobe_out,output reg signed [17:0] data_out);\n [/INST]\n", "output": "parameter decim = 1 ; \n  parameter rate = 2 ; \n  reg signed [40:0] temp ; \n  reg signed [17:0] delay[30:0] ; \n  reg signed [17:0] coeffs[30:0] ; \n  reg [7:0] count ; \n  integer i ; \n  initial begin \n  for( i = 0 ; i < 31 ; i = i + 1 ) begin \n  coeffs[i] = 18'd0 ; \n  end \n  coeffs[0] = -1390 ; \n  coeffs[2] = 1604 ; \n  coeffs[4] = -1896 ; \n  coeffs[6] = 2317 ; \n  coeffs[8] = -2979 ; \n  coeffs[10] = 4172 ; \n  coeffs[12] = -6953 ; \n  coeffs[14] = 20860 ; \n  coeffs[15] = 32768 ; \n  coeffs[16] = 20860 ; \n  coeffs[18] = -6953 ; \n  coeffs[20] = 4172 ; \n  coeffs[22] = -2979 ; \n  coeffs[24] = 2317 ; \n  coeffs[26] = -1896 ; \n  coeffs[28] = 1604 ; \n  coeffs[30] = -1390 ; \n  end \n  always @(posedge clock) begin \n  if( reset ) begin \n  count <= 0 ; \n  for( i = 0 ; i < 31 ; i = i + 1 ) begin \n  delay[i] <= 18'd0 ; \n  end \n  temp <= 41'd0 ; \n  data_out <= 18'd0 ; \n  strobe_out <= 1'b0 ; \n  end else if( enable ) begin \n  if( (decim && (count == rate-1)) || !decim ) \n  strobe_out <= strobe_in ; \n  else \n  strobe_out <= 1'b0 ; \n  if( strobe_in ) begin \n  count <= count + 1 ; \n  for( i = 30 ; i > 0 ; i = i - 1 ) begin \n  delay[i] = delay[i-1] ; \n  end \n  delay[0] = data_in ; \n  temp = 18'd0 ; \n  if( (decim && (count == rate-1)) || !decim ) begin \n  count <= 0 ; \n  for( i = 0 ; i < 31 ; i = i + 1 ) begin \n  temp = temp + delay[i]*coeffs[i] ; \n  end \n  data_out <= temp >>> 15 ; \n  end \n  end \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an implementation of a write-first synchronous memory controller. It interfaces with a memory module and handles read and write operations. It includes features such as acknowledgment signals, interrupt signals, and sleep mode for the memory module. The module also includes a reset functionality for the memory and handles enabling and addressing of the memory for write operations. Additionally, it handles the sleep mode for the memory and decrements a sleep counter. If the sleep counter reaches zero, it sends an acknowledgment and resets the sleep counter.\n\n Module header:\n\nmodule wb_bram #(parameter DATA_WIDTH = 32,parameter ADDR_WIDTH = 12,parameter MEM_FILE = \"NOTHING\",parameter MEM_FILE_LENGTH = 0)(input clk,input rst,input i_wbs_we,input i_wbs_stb,input i_wbs_cyc,input [3:0] i_wbs_sel,input [31:0] i_wbs_adr,input [31:0] i_wbs_dat,output reg [31:0] o_wbs_dat,output reg o_wbs_ack,output reg o_wbs_int);\n [/INST]\n", "output": "localparam RAM_SIZE = ADDR_WIDTH - 1; \n localparam SLEEP_COUNT = 4; \n wire [31:0] read_data; \n reg [31:0] write_data; \n reg [RAM_SIZE:0] ram_adr; \n reg en_ram; \n reg [3:0] ram_sleep; \n bram#(.DATA_WIDTH (DATA_WIDTH ),.ADDR_WIDTH (ADDR_WIDTH ),.MEM_FILE (MEM_FILE ),.MEM_FILE_LENGTH (MEM_FILE_LENGTH ))br(.clk (clk ),.rst (rst ),.en (en_ram ),.we (i_wbs_we ),.write_address (ram_adr ),.read_address (ram_adr ),.data_in (write_data ),.data_out (read_data )); \n always @ (posedge clk) begin \n  if (rst) begin \n  o_wbs_dat <= 32'h0; \n  o_wbs_ack <= 0; \n  o_wbs_int <= 0; \n  ram_sleep <= SLEEP_COUNT; \n  ram_adr <= 0; \n  en_ram <= 0; \n  end \n  else begin \n  if (o_wbs_ack & !i_wbs_stb)begin \n  o_wbs_ack <= 0; \n  en_ram <= 0; \n  end \n  if (i_wbs_stb & i_wbs_cyc) begin \n  en_ram <= 1; \n  ram_adr <= i_wbs_adr[RAM_SIZE:0]; \n  if (i_wbs_we) begin \n  write_data <= i_wbs_dat; \n  end \n  else begin \n  o_wbs_dat <= read_data; \n  end \n  if (ram_sleep > 0) begin \n  ram_sleep <= ram_sleep - 1; \n  end \n  else begin \n  o_wbs_ack <= 1; \n  ram_sleep <= SLEEP_COUNT; \n  end \n  end \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a master Serial Peripheral Interface (SPI) controller. It interfaces with a slave device using SPI communication protocol. It has inputs for clock, reset, data in, chip select, address, read, and write signals, and outputs the data out. It utilizes registers to control the SPI protocol states, and the data and control signals are synchronized with the clock edge. It includes logic to handle the data and control signals as per the SPI protocol specifications. Additionally, it instantiates a sub-module 'spi_master' which is assumed to contain the SPI communication logic.\n\n Module header:\n\nmodule peripheral_spi_master(clk , rst , d_in , cs , addr , rd , wr, d_out,mosi ,miso, sck, ss);\n [/INST]\n", "output": "input clk; \n  input rst; \n  input [15:0]d_in; \n  input cs; \n  input [3:0]addr; \n  input rd; \n  input wr; \n  output reg [15:0]d_out; \n  input miso; \n  output mosi, sck, sssd_out; \n  reg [6:0] s; \n  reg [7:0] data_in=0; \n  reg start=0; \n  reg reset=0; \n  reg sssd_in=1; \n  wire [7:0] data_out; \n  wire busy; \n  wire new_data; \n  wire mosi; \n  wire miso; \n  wire sck; \n  wire ss; \n  always @(*) begin \n  case (addr) \n  4'h0:begin s = (cs && wr) ? 7'b0000001 : 7'b0000000 ;end \n  4'h2:begin s = (cs && wr) ? 7'b0000010 : 7'b0000000 ;end \n  4'h4:begin s = (cs && wr) ? 7'b0000100 : 7'b0000000 ;end \n  4'h6:begin s = (cs && wr) ? 7'b0001000 : 7'b0000000 ;end \n  4'h8:begin s = (cs && rd) ? 7'b0010000 : 7'b0000000 ;end \n  4'hA:begin s = (cs && rd) ? 7'b0100000 : 7'b0000000 ;end \n  4'hC:begin s = (cs && rd) ? 7'b1000000 : 7'b0000000 ;end \n  default:begin s = 7'b0000000 ; end \n  endcase \n  end \n  always @(negedge clk) begin \n  data_in = (s[0]) ? d_in[7:0] : data_in; \n  start = s[1] ; \n  reset = s[2] ; \n  sssd_in = (s[3]) ? d_in[0] : data_in; \n  end \n  always @(negedge clk) begin \n  case (s[6:4]) \n  3'b001: d_out[7:0] = data_out ; \n  3'b010: d_out[0] = busy ; \n  3'b100: d_out[0] = new_data ; \n  default: d_out = 0 ; \n  endcase \n  end \n  spi_master spi_m (.clk(clk), .rst(reset), .sssd_in(sssd_in), .data_in(data_in), .start(start), .data_out(data_out), .busy(busy), .new_data(new_data), .miso(miso), .mosi(mosi), .sck(sck), .ss(ss), .sssd_out(sssd_out)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a BIOS loader state machine that controls the loading of BIOS and VBIOS data into specific addresses. It uses a state variable to progress through different states, and based on the current state, it sets the address, write data, and write signals to specific values. The module also handles reset conditions and wait requests to ensure proper operation.\n\n Module header:\n\nmodule bios_loader (input wire clk,input wire rst,output reg [27:0] address,output reg [3:0] byteenable,output reg write,output reg [31:0] writedata,output reg read,input wire [31:0] readdata,input wire waitrequest);\n [/INST]\n", "output": "parameter PIO_OUTPUT_ADDR = 32'h00008860; \n  parameter DRIVER_SD_ADDR = 32'h00000000; \n  parameter BIOS_SECTOR = 72; \n  parameter BIOS_SIZE = (64*1024); \n  parameter BIOS_ADDR = 32'hF0000 | 32'h8000000; \n  parameter VBIOS_SECTOR = 8; \n  parameter VBIOS_SIZE = (32*1024); \n  parameter VBIOS_ADDR = 32'hC0000 | 32'h8000000; \n  parameter CTRL_READ = 2; \n  reg [31:0] state; \n  always @(posedge clk) begin \n  if(rst) state <= 1; \n  else if(state != 0 && (!(waitrequest && write))) state <= state + 1; \n  end \n  always @(posedge clk) begin \n  if(rst) begin \n  write <= 0; \n  read <= 0; \n  writedata <= 0; \n  address <= 0; \n  byteenable <= 4'b0000; \n  end else if(!(waitrequest && write))begin \n  case(state) \n  20000000: begin \n  address <= PIO_OUTPUT_ADDR; \n  writedata <= 32'h1; \n  write <= 1; \n  end \n  20001000: begin \n  write <= 1; \n  address <= DRIVER_SD_ADDR; \n  writedata <= BIOS_ADDR; \n  end \n  20002000: begin \n  write <= 1; \n  address <= DRIVER_SD_ADDR + 4; \n  writedata <= BIOS_SECTOR; \n  end \n  20003000: begin \n  write <= 1; \n  address <= DRIVER_SD_ADDR + 8; \n  writedata <= BIOS_SIZE / 512; \n  end \n  20004000: begin \n  write <= 1; \n  address <= DRIVER_SD_ADDR + 12; \n  writedata <= CTRL_READ; \n  end \n  40004000: begin \n  write <= 1; \n  address <= DRIVER_SD_ADDR; \n  writedata <= VBIOS_ADDR; \n  end \n  40005000: begin \n  write <= 1; \n  address <= DRIVER_SD_ADDR + 4; \n  writedata <= VBIOS_SECTOR; \n  end \n  40006000: begin \n  write <= 1; \n  address <= DRIVER_SD_ADDR + 8; \n  writedata <= VBIOS_SIZE / 512; \n  end \n  40007000: begin \n  write <= 1; \n  address <= DRIVER_SD_ADDR + 12; \n  writedata <= CTRL_READ; \n  end \n  60007000: begin \n  address <= PIO_OUTPUT_ADDR; \n  writedata <= 32'h0; \n  write <= 1; \n  end \n  default: begin \n  write <= 0; \n  writedata <= 0; \n  address <= 0; \n  end \n  endcase \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a simple logic gate that takes an input A and produces an output Y by inverting A. The assign statement assigns the logical complement of A to Y, effectively implementing a NOT gate.\n\n Module header:\n\nmodule my_gate (input wire A,output wire Y);\n [/INST]\n", "output": "assign Y = ~A; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a millisecond timer that uses a state machine to control the delay. It has an input clock, reset signal, and delay start signal, along with a parameter for the system clock frequency and a parameter for the delay width. The delay time is specified using the input delay_ms, and the output delay_fin indicates when the delay is finished.\n\nThe module contains a state machine with three states: IDLE, WAIT, and DONE. The timer_state variable represents the current state, and it transitions between these states based on the input signals and internal counters.\n\nWhen the delay_start signal is asserted, the module enters the WAIT state and counts the number of system clock cycles until the specified delay_ms is reached. Once the delay is reached, the module transitions to the DONE state and sets the delay_fin signal.\n\nThe module also includes a microsecond counter, a system clock counter, and a delayed microsecond counter, which are used to manage the timing of the delay.\n\nAdditionally, the module includes a function to calculate the log base 2 of a value, which is used to determine the width of the system clock counter based on the specified system clock frequency.\n\nOverall, the module acts as a configurable millisecond timer with a state machine to control the delay timing.\n\n Module header:\n\nmodule milisecond_timer #(parameter SYS_CLK_KHZ = 50,parameter DELAY_W = 12) (input clk,input reset,input delay_start,input [DELAY_W-1:0] delay_ms,output delay_fin);\n [/INST]\n", "output": "`define MS_TIMER_SM_W 2 \n localparam STATE_IDLE = `MS_TIMER_SM_W'h0; \n localparam STATE_WAIT = `MS_TIMER_SM_W'h1; \n localparam STATE_DONE = `MS_TIMER_SM_W'h2; \n localparam SYS_CLK_W = log2(SYS_CLK_KHZ); \n reg [`MS_TIMER_SM_W-1:0] timer_state; \n reg [DELAY_W-1:0] ms_counter; \n reg [DELAY_W-1:0] delay_ms_latched; \n reg [SYS_CLK_W-1:0] sys_clk_counter; \n assign delay_fin = ( (timer_state==STATE_DONE) && (delay_start==1'b0) ) ? 1'b1 : 1'b0; \n always @(posedge clk or posedge reset) begin \n  if (reset) begin \n  timer_state <= STATE_IDLE; \n  delay_ms_latched <= 'b0; \n  end else begin \n  case (timer_state) \n  STATE_IDLE: begin \n  if (delay_start==1'b1) begin \n  timer_state <= STATE_WAIT; \n  delay_ms_latched <= delay_ms; \n  end \n  end \n  STATE_WAIT: begin \n  if (ms_counter == delay_ms_latched) begin \n  timer_state <= STATE_DONE; \n  delay_ms_latched <= 'b0; \n  end \n  end \n  STATE_DONE: begin \n  if (delay_start==1'b0) begin \n  timer_state <= STATE_IDLE; \n  end \n  end \n  endcase \n  end \n end \n always @(posedge clk or posedge reset) begin \n  if (reset) begin \n  sys_clk_counter <= 'b0; \n  ms_counter <= 'b0; \n  end else begin \n  if (timer_state==STATE_WAIT) begin \n  if (sys_clk_counter == SYS_CLK_KHZ ) begin \n  sys_clk_counter <= 'b0; \n  ms_counter <= ms_counter + 1; \n  end else begin \n  sys_clk_counter <= sys_clk_counter + 1; \n  end \n  end else begin \n  sys_clk_counter <= 'b0; \n  ms_counter <= 'b0; \n  end \n  end \n end \n function [5:0] log2; \n  input [31:0] val; \n  integer i; \n  begin \n  for (i=32; i>0; i=i-1) begin \n  if (val>(32'b1<<(i-1))) begin \n  log2 = i; \n  i = 0; \n  end else begin \n  log2 = 1; \n  end \n  end \n  end \n endfunction \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a state machine with two states, S0 and S1, and has an input signal 'in', a clock signal 'clk', a reset signal 'rst_n', and an output signal 'out'. It transitions between states based on the input signal 'in', and sets the output 'out' accordingly. When the reset signal is negated, it sets the state to S0 and the output 'out' to 0. The state machine transitions based on the value of the input signal 'in', setting the temporary output 'tmp_out' to 0 or 1 based on the state and input, and finally assigns the temporary output to the actual output 'out'.\n\n Module header:\n\nmodule hw2_A (input in,input clk,input rst_n,output reg out);\n [/INST]\n", "output": "parameter S0 = 0; \n parameter S1 = 1; \n reg state, nextState; \n reg tmp_out; \n always @(posedge clk or negedge rst_n) begin \n  if (~rst_n) begin \n  state <= S0; \n  end else begin \n  state <= nextState; \n  end \n end \n always @(*) begin \n  case (state) \n  S0: begin \n  if (in == 0) begin \n  nextState <= 0; \n  end else begin \n  nextState <= 1; \n  end \n  end \n  S1: begin \n  if (in == 0) begin \n  nextState <= 0; \n  end else begin \n  nextState <= 1; \n  end \n  end \n  endcase \n end \n always @(*) begin \n  case (state) \n  S0: begin \n  if (in == 0) begin \n  tmp_out <= 0; \n  end else begin \n  tmp_out <= 1; \n  end \n  end \n  S1: begin \n  tmp_out <= 0; \n  end \n  endcase \n end \n always @(posedge clk or negedge rst_n) begin \n  if(~rst_n) begin \n  out <= 0; \n  end else begin \n  out <= tmp_out; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `mkMaths1` takes inputs `update_x`, `update_y`, and `EN_update`, and produces outputs `update` and `RDY_update`. Upon receiving the inputs, the module calculates the value `(update_x + update_y) * m_val`, where `m_val` is a parameter, and assigns the result to the `update` output. Additionally, it assigns `RDY_update` to 1, indicating that the calculation is ready. The module performs these operations on the rising edge of the CLK signal and considering the RST_N signal.\n\n Module header:\n\nmodule mkMaths1(CLK,RST_N,update_x,update_y,EN_update,update,RDY_update);\n [/INST]\n", "output": "parameter [15 : 0] m_val = 16'b0; \n  input CLK; \n  input RST_N; \n  input [15 : 0] update_x; \n  input [15 : 0] update_y; \n  input EN_update; \n  output [15 : 0] update; \n  output RDY_update; \n  wire [15 : 0] update; \n  wire RDY_update; \n  wire [31 : 0] update_x_PLUS_update_y_MUL_m_val___d2; \n  assign update = update_x_PLUS_update_y_MUL_m_val___d2[15:0] ; \n  assign RDY_update = 1'd1 ; \n  assign update_x_PLUS_update_y_MUL_m_val___d2 = \n  (update_x + update_y) * m_val ; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a 1Kx8 RAM with dual port read and single port write functionality. It has two address inputs a1 and a2, and data inputs and outputs dout1 and dout2 respectively. The module stores and retrieves data based on the provided addresses and enables we and ce signals. When the write enable we is asserted and chip enable ce is active, the module writes the input data din to the memory at the address a1. On the rising edge of the clock, the module retrieves data from the memory at the addresses a1 and a2 and outputs them through dout1 and dout2, respectively.\n\n Module header:\n\nmodule ram1k_dualport(input wire clk,input wire ce,input wire [9:0] a1,input wire [9:0] a2,input wire [7:0] din,output reg [7:0] dout1,output reg [7:0] dout2,input wire we);\n [/INST]\n", "output": "reg [7:0] mem[0:1023]; \n  always @(posedge clk) begin \n  dout2 <= mem[a2]; \n  dout1 <= mem[a1]; \n  if (we == 1'b1 && ce == 1'b1) \n  mem[a1] <= din; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements an adder circuit with a parameter for the width of the wires. It includes inputs for the carry-in, operand 1, operand 2, and outputs for the result and carry-out. The module contains logic to perform the addition operation and connect the input and output signals to the corresponding graphical representations for schematic visualization. The addition operation is performed in a combinational logic block, which updates the result and carry-out based on the inputs.\n\n Module header:\n\nmodule add #(parameter WIREWIDTH = 1) (input wire ci,input wire [WIREWIDTH:0] op1, op2,output reg [WIREWIDTH:0] res,output reg co);\n [/INST]\n", "output": "initial begin \n  $schematic_boundingbox(60,180); \n  $schematic_polygonstart; \n  $schematic_coord(10,10); \n  $schematic_coord(50,50); \n  $schematic_coord(50,130); \n  $schematic_coord(10,170); \n  $schematic_coord(10,95); \n  $schematic_coord(15,90); \n  $schematic_coord(10,85); \n  $schematic_polygonend; \n  $schematic_linestart; \n  $schematic_coord(30,29); \n  $schematic_coord(30,10); \n  $schematic_lineend; \n  $schematic_linestart; \n  $schematic_coord(30,151); \n  $schematic_coord(30,170); \n  $schematic_lineend; \n  $schematic_connector(op1,0,50); \n  $schematic_connector(op2,0,130); \n  $schematic_connector(res,60,90); \n  $schematic_connector(ci,30,0); \n  $schematic_connector(co,30,180); \n  end \n  always @* begin \n  {co,res} = {1'b0,op1} + {1'b0,op2} + ci; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a Moore finite state machine (FSM) with two input bits and one output bit. The module transitions between seven states based on the input and current state, and the output yout changes accordingly. The states and state transitions are defined with case statements and the output yout is assigned in each state based on the current state. The module operates on clock and reset signals and uses sequential and combinational logic to implement the state machine.\n\n Module header:\n\nmodule Moore_FSM(input clk,input reset,input [1:0] x,output reg yout);\n [/INST]\n", "output": "reg [2:0] state, nextState; \n  parameter s0 = 0, a0 = 1, a1 = 2, b0 = 3, b1 = 4, t0 = 5, t1 = 6; \n  always @(posedge clk or posedge reset) begin \n  if (reset) begin \n  state <= s0; \n  end \n  else begin \n  state <= nextState; \n  end \n  end \n  always @(x or state) begin \n  case (state) \n  s0: begin \n  case (x) \n  0: nextState <= s0; \n  1: nextState <= a0; \n  2: nextState <= t0; \n  3: nextState <= b0; \n  endcase \n  end \n  a0: begin \n  case (x) \n  0: nextState <= a1; \n  1: nextState <= a0; \n  2: nextState <= t0; \n  3: nextState <= b0; \n  endcase \n  end \n  a1: begin \n  case (x) \n  0: nextState <= a1; \n  1: nextState <= a0; \n  2: nextState <= t0; \n  3: nextState <= b0; \n  endcase \n  end \n  b0: begin \n  case (x) \n  0: nextState <= b1; \n  1: nextState <= a0; \n  2: nextState <= t0; \n  3: nextState <= b0; \n  endcase \n  end \n  b1: begin \n  case (x) \n  0: nextState <= b1; \n  1: nextState <= a0; \n  2: nextState <= t0; \n  3: nextState <= b0; \n  endcase \n  end \n  t0: begin \n  case (x) \n  0: nextState <= t1; \n  1: nextState <= a0; \n  2: nextState <= t0; \n  3: nextState <= b0; \n  endcase \n  end \n  t1: begin \n  case (x) \n  0: nextState <= t1; \n  1: nextState <= a0; \n  2: nextState <= t0; \n  3: nextState <= b0; \n  endcase \n  end \n  endcase \n  end \n  always @(state) begin \n  case (state) \n  s0, a1: yout <= 0; \n  a0, b0, t0: yout <= yout; \n  b1: yout <= 1; \n  t1: yout <= ~yout; \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module simply outputs the device ID high byte, which is hardcoded to 0.\n\n Module header:\n\nmodule r_DEVICE_ID_HIGH(output wire [7:0] reg_0x05);\n [/INST]\n", "output": "assign reg_0x05=8'h00; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe provided Verilog module is an Arithmetic Logic Unit (ALU) that performs various arithmetic and logical operations based on the input data and control signals. The module has multiple components, including a fadder circuit, selectors, and logic operations. It utilizes the input data i_a_in and i_b_in along with control signals i_function, i_barrel_shift_carry, and i_status_bits_carry to generate the output o_out and o_flags.\n\nThe module performs operations such as AND, OR, XOR, addition, subtraction, sign extension, zero extension, and various bit manipulation operations. It also includes conditional checks to determine the output based on the control signals. Additionally, it handles overflow conditions and sets the appropriate flags in the output o_flags.\n\nOverall, the module implements a versatile ALU capable of handling a wide range of arithmetic and logical operations based on the input data and control signals.\n\n Module header:\n\nmodule a23_alu (input [31:0] i_a_in,input [31:0] i_b_in,input i_barrel_shift_carry,input i_status_bits_carry,input [8:0] i_function,output [31:0] o_out,output [3:0] o_flags);\n [/INST]\n", "output": "wire [31:0] a, b, b_not; \n wire [31:0] and_out, or_out, xor_out; \n wire [31:0] sign_ex8_out, sign_ex_16_out; \n wire [31:0] zero_ex8_out, zero_ex_16_out; \n wire [32:0] fadder_out; \n wire swap_sel; \n wire not_sel; \n wire [1:0] cin_sel; \n wire cout_sel; \n wire [3:0] out_sel; \n wire carry_in; \n wire carry_out; \n wire overflow_out; \n wire fadder_carry_out; \n assign { swap_sel, not_sel, cin_sel, cout_sel, out_sel } = i_function; \n assign a = (swap_sel ) ? i_b_in : i_a_in ; \n assign b = (swap_sel ) ? i_a_in : i_b_in ; \n assign b_not = (not_sel ) ? ~b : b ; \n assign carry_in = (cin_sel==2'd0 ) ? 1'd0 : \n  (cin_sel==2'd1 ) ? 1'd1 : \n  i_status_bits_carry ; \n assign carry_out = (cout_sel==1'd0 ) ? fadder_carry_out : \n  i_barrel_shift_carry ; \n assign overflow_out = out_sel == 4'd1 && \n ( (!a[31] && !b_not[31] && fadder_out[31]) ||(a[31] && b_not[31] && !fadder_out[31]) ); \n `ifdef XILINX_FPGA \n  `ifdef XILINX_SPARTAN6_FPGA \n  xs6_addsub_n #(.WIDTH(33)) \n  `endif \n  `ifdef XILINX_VIRTEX6_FPGA \n  xv6_addsub_n #(.WIDTH(33)) \n  `endif \n u_xx_addsub_33(.i_a ( {1'd0,a} ),.i_b ( {1'd0,b_not} ),.i_cin ( carry_in ),.i_sub ( 1'd0 ),.o_sum ( fadder_out ),.o_co ( )); \n `else \n assign fadder_out = { 1'd0,a} + {1'd0,b_not} + {32'd0,carry_in}; \n `endif \n assign fadder_carry_out = fadder_out[32]; \n assign and_out = a & b_not; \n assign or_out = a | b_not; \n assign xor_out = a ^ b_not; \n assign zero_ex8_out = {24'd0, b_not[7:0]}; \n assign zero_ex_16_out = {16'd0, b_not[15:0]}; \n assign sign_ex8_out = {{24{b_not[7]}}, b_not[7:0]}; \n assign sign_ex_16_out = {{16{b_not[15]}}, b_not[15:0]}; \n assign o_out = out_sel == 4'd0 ? b_not : \n  out_sel == 4'd1 ? fadder_out[31:0] : \n  out_sel == 4'd2 ? zero_ex_16_out : \n  out_sel == 4'd3 ? zero_ex8_out : \n  out_sel == 4'd4 ? sign_ex_16_out : \n  out_sel == 4'd5 ? sign_ex8_out : \n  out_sel == 4'd6 ? xor_out : \n  out_sel == 4'd7 ? or_out : \n  and_out ; \n assign o_flags = { o_out[31], \n  |o_out == 1'd0, \n  carry_out, \n  overflow_out \n  }; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module \"Extend\" takes a 16-bit Imm16 input and a 2-bit ExtendI input, and generates a 32-bit Imm32 output based on the ExtendI value. The module uses a case statement to determine how the Imm32 is derived: it can be zero-extended, sign-extended, left-rotated, or left-shifted by 2 bits.\n\n Module header:\n\nmodule Extend(input [15:0] Imm16,input [1:0] ExtendI,output reg [31:0] Imm32);\n [/INST]\n", "output": "always @(*)begin \n case(ExtendI) \n 2'b00:Imm32={16'h0000,Imm16}; \n 2'b01:Imm32 = {{16{Imm16[15]}}, Imm16}; \n 2'b10:Imm32 = {Imm16, 16'h0000}; \n 2'b11:Imm32 = {{16{Imm16[15]}}, Imm16} << 2; \n endcase \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module serves as a test bench for the AES-192 module. It instantiates the AES-192 module and provides stimuli by initializing the clock, state, and key registers. It checks the output of the AES-192 module against expected values after setting specific states and keys, then displays an error message or \"Good.\" based on the comparison results. Finally, it finishes the simulation. The clock signal is negated every 5 time units.\n\n Module header:\n\nmodule test_aes_192;\n [/INST]\n", "output": "reg clk; \n  reg [127:0] state; \n  reg [191:0] key; \n  wire [127:0] out; \n aes_192 uut (.clk(clk),.state(state),.key(key),.out(out)); \n  initial begin \n  clk = 0; \n  state = 0; \n  key = 0; \n  #100; \n  @ (negedge clk); \n  #2; \n  state = 128'h3243f6a8885a308d313198a2e0370734; \n  key = 192'h2b7e151628aed2a6abf7158809cf4f3c762e7160f38b4da5; \n  #10; \n  state = 128'h00112233445566778899aabbccddeeff; \n  key = 192'h000102030405060708090a0b0c0d0e0f1011121314151617; \n  #10; \n  state = 128'h0; \n  key = 192'h0; \n  #230; \n  if (out !== 128'hf9fb29aefc384a250340d833b87ebc00) \n  begin $display(\"E\"); $finish; end \n  #10; \n  if (out !== 128'hdda97ca4864cdfe06eaf70a0ec0d7191) \n  begin $display(\"E\"); $finish; end \n  $display(\"Good.\"); \n  $finish; \n  end \n  always #5 clk = ~clk; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module `cf_adc_wr` represents an ADC (Analog to Digital Converter) write module. It takes clock and data inputs from the ADC and interfaces with a PNMON (Pulse-Code Modulation Monitor) and ADC interface. It has various input and output ports for control and data signals. The module contains logic for counting ADC clock cycles and validating ADC data, as well as shifting and storing ADC data. Additionally, it interfaces with PNMON and ADC interface modules to manage PN (Pulse Code Modulation) errors and data transfer.\n\n Module header:\n\nmodule cf_adc_wr (adc_clk_in_p,adc_clk_in_n,adc_data_in_p,adc_data_in_n,adc_data_or_p,adc_data_or_n,adc_clk,adc_valid,adc_data,adc_or,adc_pn_oos,adc_pn_err,up_pn_type,up_dmode,up_delay_sel,up_delay_rwn,up_delay_addr,up_delay_wdata,delay_clk,delay_ack,delay_rdata,delay_locked,adc_mon_valid,adc_mon_data);\n [/INST]\n", "output": "parameter C_CF_BUFTYPE = 0; \n  input adc_clk_in_p; \n  input adc_clk_in_n; \n  input [ 7:0] adc_data_in_p; \n  input [ 7:0] adc_data_in_n; \n  input adc_data_or_p; \n  input adc_data_or_n; \n  output adc_clk; \n  output adc_valid; \n  output [63:0] adc_data; \n  output adc_or; \n  output adc_pn_oos; \n  output adc_pn_err; \n  input up_pn_type; \n  input up_dmode; \n  input up_delay_sel; \n  input up_delay_rwn; \n  input [ 3:0] up_delay_addr; \n  input [ 4:0] up_delay_wdata; \n  input delay_clk; \n  output delay_ack; \n  output [ 4:0] delay_rdata; \n  output delay_locked; \n  output adc_mon_valid; \n  output [15:0] adc_mon_data; \n  reg [ 1:0] adc_count = 'd0; \n  reg adc_valid = 'd0; \n  reg [63:0] adc_data = 'd0; \n  wire [15:0] adc_data_if_s; \n  assign adc_mon_valid = 1'b1; \n  assign adc_mon_data = adc_data_if_s; \n  always @(posedge adc_clk) begin \n  adc_count <= adc_count + 1'b1; \n  adc_valid <= adc_count[0] & adc_count[1]; \n  adc_data <= {adc_data_if_s, adc_data[63:16]}; \n  end \n cf_pnmon i_pnmon_a (.adc_clk (adc_clk),.adc_data (adc_data_if_s),.adc_pn_oos (adc_pn_oos),.adc_pn_err (adc_pn_err),.up_pn_type (up_pn_type)); \n cf_adc_if #(.C_CF_BUFTYPE (C_CF_BUFTYPE)) i_adc_if (.adc_clk_in_p (adc_clk_in_p),.adc_clk_in_n (adc_clk_in_n),.adc_data_in_p (adc_data_in_p),.adc_data_in_n (adc_data_in_n),.adc_data_or_p (adc_data_or_p),.adc_data_or_n (adc_data_or_n),.adc_clk (adc_clk),.adc_data (adc_data_if_s),.adc_or (adc_or),.up_dmode (up_dmode),.up_delay_sel (up_delay_sel),.up_delay_rwn (up_delay_rwn),.up_delay_addr (up_delay_addr),.up_delay_wdata (up_delay_wdata),.delay_clk (delay_clk),.delay_ack (delay_ack),.delay_rdata (delay_rdata),.delay_locked (delay_locked)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a feedforward multiplication module. It takes in two input vectors 'a' and 'b' and computes their product. The multiplication is triggered by a clock signal 'clk' and an enable signal 'ce'. When the enable signal is high, the module registers the input vectors and computes the product, which is then stored in the output vector 'p'. The intermediate product is stored in a temporary wire 'tmp_product'. The module utilizes registers to store the input vectors and the output product.\n\n Module header:\n\nmodule feedforward_mul_7ns_31ns_38_3_Mul3S_0(clk, ce, a, b, p);\n [/INST]\n", "output": "input clk; \n input ce; \n input[7 - 1 : 0] a; \n input[31 - 1 : 0] b; \n output[38 - 1 : 0] p; \n reg [7 - 1 : 0] a_reg0; \n reg [31 - 1 : 0] b_reg0; \n wire [38 - 1 : 0] tmp_product; \n reg [38 - 1 : 0] buff0; \n assign p = buff0; \n assign tmp_product = a_reg0 * b_reg0; \n always @ (posedge clk) begin \n  if (ce) begin \n  a_reg0 <= a; \n  b_reg0 <= b; \n  buff0 <= tmp_product; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module f6_TECH_NOR2 takes a 2-bit input and outputs the logical NOR of the two bits. The inputs are first ORed together, and the result is then inverted to produce the output.\n\n Module header:\n\nmodule f6_TECH_NOR2(input [1:0] in, output out);\n [/INST]\n", "output": "assign out = ~(|in); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an implementation of a pipeline for processing data. It uses various logic and arithmetic operations to control the pipeline's readiness, process input, and output data. The module includes registers for counting cycles and output, as well as signal checks to ensure that the pipeline completes as expected. The process_output signal is generated based on multiple conditions involving the pipeline status and completion. The module also includes a pipeline completion check that triggers a display message if the pipeline completes earlier than expected.\n\n Module header:\n\nmodule Underflow_A_null_null__count153600_cycles1874016_toosoon156168_UStrue(input CLK, input ready_downstream, output ready, input reset, input process_input, output process_output);\n [/INST]\n", "output": "parameter INSTANCE_NAME=\"INST\"; \n parameter OUTPUT_COUNT=0; \n parameter INPUT_COUNT=0; \n  wire [31:0] cycleCount_GET_OUTPUT; \n  wire unnamedbinop8301USEDMULTIPLEbinop;assign unnamedbinop8301USEDMULTIPLEbinop = {((cycleCount_GET_OUTPUT)>((32'd1874016)))}; \n  assign ready = {(ready_downstream||unnamedbinop8301USEDMULTIPLEbinop)}; \n  wire unnamedbinop8303USEDMULTIPLEbinop;assign unnamedbinop8303USEDMULTIPLEbinop = {({(ready_downstream||reset)}||unnamedbinop8301USEDMULTIPLEbinop)}; \n  wire [31:0] outputCount_GET_OUTPUT; \n  wire [31:0] unnamedcast8314USEDMULTIPLEcast;assign unnamedcast8314USEDMULTIPLEcast = (32'd153600); \n  wire unnamedcast8295USEDMULTIPLEcast;assign unnamedcast8295USEDMULTIPLEcast = process_input; \n  wire unnamedunary8320USEDMULTIPLEunary;assign unnamedunary8320USEDMULTIPLEunary = {(~reset)}; \n  wire unnamedbinop8330USEDMULTIPLEbinop;assign unnamedbinop8330USEDMULTIPLEbinop = {({(cycleCount_GET_OUTPUT==(32'd156168))}&&{((outputCount_GET_OUTPUT)>=(unnamedcast8314USEDMULTIPLEcast))})}; \n  wire [31:0] outputCount_SETBY_OUTPUT; \n  wire [31:0] cycleCount_SETBY_OUTPUT; \n  always @(posedge CLK) begin if({(~unnamedbinop8330USEDMULTIPLEbinop)} == 1'b0 && unnamedunary8320USEDMULTIPLEunary==1'b1 && unnamedbinop8303USEDMULTIPLEbinop==1'b1) begin $display(\"%s: pipeline completed eariler than expected\",INSTANCE_NAME); end end \n  assign process_output = {{({({({(unnamedbinop8301USEDMULTIPLEbinop&&{((outputCount_GET_OUTPUT)<(unnamedcast8314USEDMULTIPLEcast))})}||{({(~unnamedbinop8301USEDMULTIPLEbinop)}&&unnamedcast8295USEDMULTIPLEcast)})}&&unnamedunary8320USEDMULTIPLEunary)}||unnamedbinop8330USEDMULTIPLEbinop)}}; \n  RegBy_incif_1uint32_CEtable__0x07d3ba40_CEtrue_initnil #(.INSTANCE_NAME({INSTANCE_NAME,\"_outputCount\"})) outputCount(.CLK(CLK), .set_valid(reset), .CE(unnamedbinop8303USEDMULTIPLEbinop), .set_inp((32'd0)), .setby_valid(unnamedunary8320USEDMULTIPLEunary), .setby_inp({(ready_downstream&&{(unnamedcast8295USEDMULTIPLEcast||unnamedbinop8301USEDMULTIPLEbinop)})}), .SETBY_OUTPUT(outputCount_SETBY_OUTPUT), .GET_OUTPUT(outputCount_GET_OUTPUT)); \n  RegBy_incif_1uint32_CEtable__0x07d3ba40_CEtrue_initnil #(.INSTANCE_NAME({INSTANCE_NAME,\"_cycleCount\"})) cycleCount(.CLK(CLK), .set_valid(reset), .CE((1'd1)), .set_inp((32'd0)), .setby_valid(unnamedunary8320USEDMULTIPLEunary), .setby_inp((1'd1)), .SETBY_OUTPUT(cycleCount_SETBY_OUTPUT), .GET_OUTPUT(cycleCount_GET_OUTPUT)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an instantiation of a design consisting of sub-modules. It is a handshake module that processes input data and generates output data, synchronizing the communication between the upstream and downstream components using ready signals. The module includes a shift register for delaying the valid bit, a component for processing the input, and an assignment of the processed output. The module also includes checks for valid input bits.\n\n Module header:\n\nmodule MakeHandshake_freadSeq____ov7660_raw_dup(input CLK, input ready_downstream, output ready, input reset, input process_input, output [64:0] process_output);\n [/INST]\n", "output": "parameter INSTANCE_NAME=\"INST\"; \n parameter OUTPUT_COUNT=0; \n parameter INPUT_COUNT=0; \n  assign ready = ready_downstream; \n  wire unnamedbinop8359USEDMULTIPLEbinop;assign unnamedbinop8359USEDMULTIPLEbinop = {(ready_downstream||reset)}; \n  wire unnamedcast8367USEDMULTIPLEcast;assign unnamedcast8367USEDMULTIPLEcast = process_input; \n  wire [63:0] inner_process_output; \n  wire validBitDelay_freadSeq____ov7660_raw_dup_pushPop_out; \n  always @(posedge CLK) begin if({(~{(unnamedcast8367USEDMULTIPLEcast===1'bx)})} == 1'b0 && (1'd1)==1'b1) begin $display(\"%s: MakeHandshake: input valid bit should not be X!\",INSTANCE_NAME); end end \n  assign process_output = {validBitDelay_freadSeq____ov7660_raw_dup_pushPop_out,inner_process_output}; \n  ShiftRegister_1_CEtrue_TY1 #(.INSTANCE_NAME({INSTANCE_NAME,\"_validBitDelay_freadSeq____ov7660_raw_dup\"})) validBitDelay_freadSeq____ov7660_raw_dup(.CLK(CLK), .pushPop_valid({(~reset)}), .CE(unnamedbinop8359USEDMULTIPLEbinop), .sr_input(unnamedcast8367USEDMULTIPLEcast), .pushPop_out(validBitDelay_freadSeq____ov7660_raw_dup_pushPop_out), .reset(reset)); \n  freadSeq____ov7660_raw_dup #(.INSTANCE_NAME({INSTANCE_NAME,\"_inner\"})) inner(.CLK(CLK), .process_valid(unnamedcast8367USEDMULTIPLEcast), .CE(unnamedbinop8359USEDMULTIPLEbinop), .process_output(inner_process_output), .reset(reset)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a flip-flop, with the input \"d\" being latched into the output register \"q\" on the rising edge of the clock signal \"clk.\"\n\n Module header:\n\nmodule flip_flop(input d,output reg q,input clk);\n [/INST]\n", "output": "always @(posedge clk) \n  q <= d; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a video PAL frame maker by calculating color levels, grid levels, and grid positions based on the inputs phase, x, y, and color_in. The color_out output is determined based on these calculations and a case statement that compares color levels and grid levels.\n\n Module header:\n\nmodule video_palframe_mk3bit (input wire [1:0] phase,input wire [1:0] x,input wire y,input wire [3:0] color_in,output reg [1:0] color_out);\n [/INST]\n", "output": "reg [3:0] colorlevel; \n  reg [1:0] gridlevel; \n  reg gridy; \n  reg [1:0] gridindex; \n  always @* \n  begin \n  case( color_in ) \n  4'b0000: colorlevel = 4'b0000; \n  4'b0001: colorlevel = 4'b0001; \n  4'b0010, \n  4'b0011: colorlevel = 4'b0010; \n  4'b0100: colorlevel = 4'b0011; \n  4'b0101: colorlevel = 4'b0100; \n  4'b0110: colorlevel = 4'b0101; \n  4'b0111, \n  4'b1000: colorlevel = 4'b0110; \n  4'b1001: colorlevel = 4'b0111; \n  4'b1010: colorlevel = 4'b1000; \n  4'b1011: colorlevel = 4'b1001; \n  4'b1100, \n  4'b1101: colorlevel = 4'b1010; \n  4'b1110: colorlevel = 4'b1011; \n  default: colorlevel = 4'b1100; \n  endcase \n  gridy = y ^ (x[1] & colorlevel[0]); \n  gridindex = {gridy+phase[1], x[0]+phase[0]}; \n  case(gridindex[1:0]) \n  2'b00: gridlevel = 2'b00; \n  2'b01: gridlevel = 2'b10; \n  2'b10: gridlevel = 2'b11; \n  2'b11: gridlevel = 2'b01; \n  endcase \n  color_out = colorlevel[3:2] + ((colorlevel[1:0] > gridlevel[1:0]) ? 2'b01 : 2'b00); \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a hardware module to calculate the square root of a 31-bit input e and produces a signed 17-bit output f. It leverages a 32-bit Leading Zero Detector (LZD_32bit) to identify the leading zero position. After that, it uses coefficient tables (c0, c1, c2, c3) and performs arithmetic operations to compute the square root based on the exponent and the input. The module makes use of shifting, multiplication, addition, and conditional operations to determine the square root and update the output f.\n\n Module header:\n\nmodule sqrt(e , f);\n [/INST]\n", "output": "input [30:0] e; \n  output reg signed [16:0] f; \n  reg [4:0] exp_f; \n  wire [4:0] lzd; \n  wire valid; \n  LZD_32bit l(.in({1'b0,e}),.out(lzd),.valid(valid)); \n  reg [4:0] exp_f1; \n  reg [30:0] x_f1,x_f; \n  reg [30:0] y_f; \n  reg [5:0] address; \n  reg [63:0] temp1; \n  reg [31:0] c0[63:0]; \n  reg [31:0] c1[63:0]; \n  reg [31:0] c2[63:0]; \n  reg [31:0] c3[63:0]; \n initial \n  begin \n  $readmemh(\"c0_sqrt.txt\",c0); \n  $readmemh(\"c1_sqrt.txt\", c1); \n  $readmemh(\"c2_sqrt.txt\", c2); \n  $readmemh(\"c3_sqrt.txt\", c3); \n  exp_f=0; \n  x_f1=0; \n  x_f=0; \n  y_f=0; \n  exp_f1=0; \n  end \n always @(e,lzd) \n  begin \n  exp_f= 5- lzd; \n  x_f1= e>>exp_f; \n  address=e[30:25]; \n  if (exp_f[0]) \n  begin \n  x_f= x_f1>>1; \n  temp1= c1[address]*x_f1; \n  y_f =temp1+ c0[address]; \n  end \n  else \n  begin \n  x_f=x_f1; \n  temp1= c3[address]*x_f1; \n  y_f =temp1+ c2[address]; \n  end \n  if (exp_f[0]) \n  begin \n  exp_f1= (exp_f+1)>>1; \n  end \n  else \n  begin \n  exp_f1= (exp_f)>>1; \n  end \n  f= y_f<<exp_f1; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a register file with a specified number of registers. It has read and write functionality, with the ability to write data into specific registers based on the write address and enable signal, and to read data from specific registers based on the read addresses. The module updates the registers when the write enable signal is asserted and the write address is not 0. It operates on a clock signal and includes a reset input.\n\n Module header:\n\nmodule RegisterFile #(parameter LOG2_NUM_REGISTERS = 5,parameter NUM_REGISTERS = 1 << (LOG2_NUM_REGISTERS))(input clk,input reset,input [LOG2_NUM_REGISTERS-1:0] waddr,input [`CPU_DATA_BITS-1:0] wdata,input write_enable,input [LOG2_NUM_REGISTERS-1:0] raddr0,output [`CPU_DATA_BITS-1:0] rdata0,input [LOG2_NUM_REGISTERS-1:0] raddr1,output [`CPU_DATA_BITS-1:0] rdata1);\n [/INST]\n", "output": "reg [`CPU_DATA_BITS-1:0] registers[NUM_REGISTERS-1:0]; \n  assign rdata0 = registers[raddr0]; \n  assign rdata1 = registers[raddr1]; \n  always @(posedge clk) begin \n  if (write_enable && waddr != 0) registers[waddr] <= wdata; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a memory management unit (MMU) table loader. It has a main state machine with three states: IDLE, REQ, and WAITING. The module handles memory requests and synchronization with the memory system. It also includes logic for address assignment and signal validation. The output signals indicate the busy state, memory request, memory address, valid memory access, and data and flag assignments. The module also includes reset synchronization and assignment of the request address based on specific conditions.\n\n Module header:\n\nmodule mmu_table_load(input wire iCLOCK,input wire inRESET,input wire iRESET_SYNC,input wire iLD_REQ,input wire [31:0] iLD_ADDR,output wire oLD_BUSY,output wire oMEM_REQ,input wire iMEM_LOCK,output wire [31:0] oMEM_ADDR,input wire iMEM_VALID,input wire [63:0] iMEM_DATA,output wire oDONE_VALID,output wire [31:0] oDONE_DATA,output wire [11:0] oDONE_FLAG0,output wire [11:0] oDONE_FLAG1);\n [/INST]\n", "output": "reg [1:0] b_main_state; \n  reg [31:0] b_req_addr; \n  localparam PL_MAIN_STT_IDLE = 2'h0; \n  localparam PL_MAIN_STT_REQ = 2'h1; \n  localparam PL_MAIN_STT_WAITING = 2'h2; \n  wire latch_condition = iLD_REQ && (b_main_state == PL_MAIN_STT_IDLE); \n  always@(posedge iCLOCK or negedge inRESET)begin \n  if(!inRESET)begin \n  b_req_addr <= 32'h0; \n  end \n  else if(iRESET_SYNC)begin \n  b_req_addr <= 32'h0; \n  end \n  else begin \n  if(latch_condition)begin \n  b_req_addr <= iLD_ADDR; \n  end \n  end \n  end \n  always@(posedge iCLOCK or negedge inRESET)begin \n  if(!inRESET)begin \n  b_main_state <= PL_MAIN_STT_IDLE; \n  end \n  else if(iRESET_SYNC)begin \n  b_main_state <= PL_MAIN_STT_IDLE; \n  end \n  else begin \n  case(b_main_state) \n  PL_MAIN_STT_IDLE: \n  begin \n  if(latch_condition)begin \n  if(iMEM_LOCK)begin \n  b_main_state <= PL_MAIN_STT_REQ; \n  end \n  else begin \n  b_main_state <= PL_MAIN_STT_WAITING; \n  end \n  end \n  end \n  PL_MAIN_STT_REQ: \n  begin \n  if(!iMEM_LOCK)begin \n  b_main_state <= PL_MAIN_STT_WAITING; \n  end \n  end \n  PL_MAIN_STT_WAITING: \n  begin \n  if(iMEM_VALID)begin \n  b_main_state <= PL_MAIN_STT_IDLE; \n  end \n  end \n  default: \n  begin \n  b_main_state <= PL_MAIN_STT_IDLE; \n  end \n  endcase \n  end \n  end \n  assign oLD_BUSY = (b_main_state != PL_MAIN_STT_IDLE); \n  assign oMEM_REQ = (b_main_state == PL_MAIN_STT_REQ) || latch_condition; \n  assign oMEM_ADDR = (b_main_state == PL_MAIN_STT_REQ)? b_req_addr : iLD_ADDR; \n  assign oDONE_VALID = (b_main_state == PL_MAIN_STT_WAITING) && iMEM_VALID; \n  assign oDONE_DATA = (b_req_addr[2])? iMEM_DATA[63:32] : iMEM_DATA[31:0]; \n  assign oDONE_FLAG0 = iMEM_DATA[11:0]; \n  assign oDONE_FLAG1 = iMEM_DATA[43:32]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module `select2_5` selects between two 5-bit inputs `in1` and `in2` based on the `choose` input. If `choose` is 0, the module sets the output `out` to `in1`. If `choose` is 1, it sets `out` to `in2`. If neither case is true, the output is set to 0. The output is stored in a 5-bit register.\n\n Module header:\n\nmodule select2_5(input [4:0] in1,input [4:0] in2,input choose,output reg [4:0] out);\n [/INST]\n", "output": "always@(in1 or in2 or choose) \n case(choose) \n 1'b0:out=in1; \n 1'b1:out=in2; \n default:out=5'b0; \n endcase \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module pc2 takes two 28-bit inputs c and d and generates a 48-bit output k. The module assigns specific bits of the input c and d to the output k based on their positions. The assignment of bits is defined by the logic specified in the Verilog code.\n\n Module header:\n\nmodule pc2(c,d,k);\n [/INST]\n", "output": "input [1:28] c,d; \n output [1:48] k; \n wire [1:56] YY; \n  assign YY[1:28]=c; assign YY[29:56]=d; \n  assign k[1]=YY[14]; assign k[2]=YY[17]; assign k[3]=YY[11]; assign k[4]=YY[24]; assign k[5]=YY[1]; assign k[6]=YY[5]; \n  assign k[7]=YY[3]; assign k[8]=YY[28]; assign k[9]=YY[15]; assign k[10]=YY[6]; assign k[11]=YY[21]; assign k[12]=YY[10]; \n  assign k[13]=YY[23]; assign k[14]=YY[19]; assign k[15]=YY[12]; assign k[16]=YY[4]; assign k[17]=YY[26]; assign k[18]=YY[8]; \n  assign k[19]=YY[16]; assign k[20]=YY[7]; assign k[21]=YY[27]; assign k[22]=YY[20]; assign k[23]=YY[13]; assign k[24]=YY[2]; \n  assign k[25]=YY[41]; assign k[26]=YY[52]; assign k[27]=YY[31]; assign k[28]=YY[37]; assign k[29]=YY[47]; assign k[30]=YY[55]; \n  assign k[31]=YY[30]; assign k[32]=YY[40]; assign k[33]=YY[51]; assign k[34]=YY[45]; assign k[35]=YY[33]; assign k[36]=YY[48]; \n  assign k[37]=YY[44]; assign k[38]=YY[49]; assign k[39]=YY[39]; assign k[40]=YY[56]; assign k[41]=YY[34]; assign k[42]=YY[53]; \n  assign k[43]=YY[46]; assign k[44]=YY[42]; assign k[45]=YY[50]; assign k[46]=YY[36]; assign k[47]=YY[29]; assign k[48]=YY[32]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module crc7 implements a 7-bit cyclic redundancy check (CRC) calculation using a specified polynomial and seed value. It takes inputs clk, rst, bit, and hold, and outputs a 7-bit crc value. The CRC calculation is performed on the rising edge of the clock signal, and the seed value is loaded into the internal register on reset. The crc value is updated based on the input bit and the specified polynomial when hold is not asserted.\n\n Module header:\n\nmodule crc7 #(parameter POLYNOMIAL = 8'h09,parameter SEED = 8'h00)(input clk,input rst,input bit,output [6:0] crc,input hold);\n [/INST]\n", "output": "reg [7:0] outval; \n assign crc = outval[6:0]; \n always @ (posedge clk) begin \n  if (rst) begin \n  outval <= SEED; \n  end \n  else begin \n  if (!hold) \n  outval[7:0] <= bit ? ({outval[6:0], 1'b0} ^ POLYNOMIAL) : {outval[6:0], 1'b0}; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a Brownian random number generator. It takes control inputs and clock signals to produce a high-voltage 18-bit random number output. The module includes a random number generation logic, a seed initialization, and an inversion of the clock signal. The random number is generated using the $random function and is then output as the rng_data. The module ensures that the rng_clk and rng_data signals are synchronized with the clock and control inputs.\n\n Module header:\n\nmodule bw_rng (rng_data, rng_clk,vsup_rng_hv18, sel_bg_l, vctrl, clk_jbus, rst_l);\n [/INST]\n", "output": "input vsup_rng_hv18; \n  input sel_bg_l; \n  input [2:0] vctrl; \n  input clk_jbus; \n  input rst_l ; \n  output rng_data; \n  output rng_clk; \n  integer seed; \n  reg rand_num; \n  reg rng_clk; \n  reg rng_data; \n  initial \n  begin \n  seed = 2; \n  rng_clk = 1'b0; \n  end \n  always \n  begin \n  #500000 rng_clk = ~rng_clk; \n  rand_num = $random (seed) & rst_l; \n  rng_data = rand_num; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a sorting network that sorts 32-bit input vectors using a sorting cell. It generates a sorting network using a loop for sorting and sorts the input data using the sorting cell for each element in the input vector. The module has flags for sorting, write enable for sorting, and also calculates the threshold value.\n\n Module header:\n\nmodule sort_module #(parameter K = 128,parameter SORT_WIDTH=32,parameter PRI_POS_START = 0,parameter PRI_POS_END = 32)(input clk,input reset,input sort_en,input place_en,input wren,input order,input [SORT_WIDTH-1:0] data_in,output [SORT_WIDTH-1:0] dataout_sig,input [31:0] accum_key,input shift_out,output [31:0] threshold);\n [/INST]\n", "output": "wire [SORT_WIDTH-1:0] prev_data[K-1:0]; \n wire [K-1:0] i_am_lower; \n wire [K-1:0] is_equal; \n wire write_en; \n assign write_en = wren & sort_en; \n assign threshold = prev_data[K-1][31:0]; \n genvar i; \n generate \n  for(i=0;i<K;i=i+1) begin:sort \n  if(i==0) begin \n sort_cell #(.SORT_WIDTH(SORT_WIDTH),.PRI_POS_START(PRI_POS_START),.PRI_POS_END(PRI_POS_END)) scell (.clk (clk),.reset (reset),.prev_data (32'h7F800000),.data_out (prev_data[0]),.datain (data_in),.place_en (place_en),.wren (write_en),.order (order),.left_is_lower (1'b0),.i_am_lower (i_am_lower[0])); \n  end \n  else if(i==K-1) begin \n sort_cell #(.SORT_WIDTH(SORT_WIDTH),.PRI_POS_START(PRI_POS_START),.PRI_POS_END(PRI_POS_END)) scell (.clk (clk),.reset (reset),.prev_data (prev_data[i-1]),.data_out (prev_data[i]),.datain (data_in),.place_en (place_en),.wren (write_en),.order (order),.left_is_lower (i_am_lower[i-1]),.i_am_lower (i_am_lower[i])); \n  end \n  else begin \n sort_cell #(.SORT_WIDTH(SORT_WIDTH),.PRI_POS_START(PRI_POS_START),.PRI_POS_END(PRI_POS_END)) scell (.clk (clk),.reset (reset),.prev_data (prev_data[i-1]),.data_out (prev_data[i]),.datain (data_in),.place_en (place_en),.wren (write_en),.order (order),.left_is_lower (i_am_lower[i-1]),.i_am_lower (i_am_lower[i])); \n  end \n  end \n endgenerate \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is designed to handle packet processing in a communication system. It includes functionality for header processing, checksum calculation, error handling, and state machine control. The module interfaces with external logic and input signals to process packet data and produce output. The module also contains internal logic for state management, error detection, and checksum computation. The primary functionality includes header word processing, setting flags, error handling, and state transitions based on the input conditions and header information. The module also instantiates additional checksum modules for IP and UDP packet processing.\n\n Module header:\n\nmodule prot_eng_rx #(parameter BASE=0) (input clk, input reset, input clear,input set_stb, input [7:0] set_addr, input [31:0] set_data,input [18:0] datain, input src_rdy_i, output dst_rdy_o,output [18:0] dataout, output src_rdy_o, input dst_rdy_i);\n [/INST]\n", "output": "localparam HDR_WIDTH = 16 + 7; \n  localparam HDR_LEN = 32; \n  reg [HDR_WIDTH-1:0] header_ram[0:HDR_LEN-1]; \n  wire [HDR_WIDTH-1:0] header_word; \n  always @(posedge clk) \n  if(set_stb & ((set_addr & 8'hE0) == BASE)) \n  header_ram[set_addr[4:0]] <= set_data; \n  assign header_word = header_ram[state]; \n  wire consume_input = src_rdy_i & dst_rdy_o; \n  wire produce_output = src_rdy_o & dst_rdy_i; \n  reg [15:0] pkt_length, fail_word, dataout_int; \n  reg slowpath, error, sof_o, eof_o, occ_o, odd; \n  assign dataout = {occ_o, eof_o, sof_o, dataout_int}; \n  wire [15:0] calc_ip_checksum, calc_udp_checksum; \n  reg [15:0] rx_ip_checksum, rx_udp_checksum; \n  always @(posedge clk) \n  if(header_word[19]) \n  rx_ip_checksum <= datain[15:0]; \n  always @(posedge clk) \n  if(header_word[18]) \n  rx_udp_checksum <= datain[15:0]; \n  always @(posedge clk) \n  if(reset | clear) \n  begin \n  slowpath <= 0; \n  error <= 0; \n  state <= 0; \n  fail_word <= 0; \n  eof_o <= 0; \n  occ_o <= 0; \n  end \n  else if(src_rdy_i & dst_rdy_i) \n  case (state) \n  0 : \n  begin \n  slowpath <= 0; \n  error <= 0; \n  eof_o <= 0; \n  occ_o <= 0; \n  state <= 1; \n  end \n ST_SLOWPATH :; \n ST_ERROR :; \n ST_PAYLOAD :; \n ST_FILLER :; \n ST_END1 :; \n ST_END2 :; \n  default : \n  if(header_word[21] && mismatch) \n  state <= ST_SLOWPATH; \n  else if(header_word[20] && mismatch) \n  state <= ST_ERROR; \n  else if(header_word[22]) \n  state <= ST_PAYLOAD; \n  else \n  state <= state + 1; \n  endcase \n  checksum_sm ip_chk \n (.clk(clk), .reset(reset), .in(datain),.calc(consume_input & header_word[17]), .clear(state==0), .checksum(ip_checksum)); \n  checksum_sm udp_chk \n (.clk(clk), .reset(reset), .in(datain),.calc(consume_input & header_word[16]), .clear(state==0), .checksum(udp_checksum)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a multiplexer (mux) with a parameterized output width. It selects between the inputs e0 and e1 based on the value of the select signal s. The outputs d0, d1, d2, and d3 are updated based on the value of the register reg_ and the selected input. If reg_ is '00', d0 is updated; if reg_ is '01', d1 is updated; if reg_ is '10', d2 is updated; and if reg_ is '11', d3 is updated.\n\n Module header:\n\nmodule mux_out #(parameter WIDTH = 8) (input wire [WIDTH-1:0] e0, e1,input wire s, enable,input wire [1:0] reg_,output reg [WIDTH-1:0] d0, d1, d2, d3 );\n [/INST]\n", "output": "wire [7:0] aux; \n  assign aux = s ? e1 : e0; \n  always @(reg_,aux) \n  begin \n  case (reg_) \n  2'b00: d0 = aux; \n  2'b01: d1 = aux; \n  2'b10: d2 = aux; \n  2'b11: d3 = aux; \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a shifter circuit that takes a 32-bit input data and a 5-bit count, and selects one of four shift operations based on a 2-bit select signal. The circuit uses a series of multiplexers (MUXs) to perform the shifting operations and outputs the result in Data_out. The shifting operations include logical left shift, logical right shift, arithmetic right shift, and circular shift.\n\n Module header:\n\nmodule MIPS_Shifter(input[31:0] Data_in,input [4:0] Count,input [1:0] Sel,output [31:0]Data_out);\n [/INST]\n", "output": "wire[31:0] ShiftData0,ShiftData1,ShiftData2,ShiftData3; \n wire[1:0] Select; \n wire HighBit; \n assign HighBit = (Sel[1] == 1'b1)?(Data_in[31]):(1'b0); \n assign Select[1] = Sel[1]|Sel[0]; \n assign Select[0] = ~(Sel[1]^Sel[0]); \n Mux4_1 Mux1(Data_in,{Data_in[30:0],1'b0},{HighBit,Data_in[31:1]},{Data_in[0],Data_in[31:1]},{Select[1]&Count[0],Select[0]&Count[0]},ShiftData0); \n Mux4_1 Mux2(ShiftData0,{ShiftData0[29:0],2'b0},{HighBit,HighBit,ShiftData0[31:2]},{ShiftData0[1:0],ShiftData0[31:2]},{Select[1]&Count[1],Select[0]&Count[1]},ShiftData1); \n Mux4_1 Mux3(ShiftData1,{ShiftData1[27:0],4'b0},{{4{HighBit}},ShiftData1[31:4]},{ShiftData1[3:0],ShiftData1[31:4]},{Select[1]&Count[2],Select[0]&Count[2]},ShiftData2); \n Mux4_1 Mux4(ShiftData2,{ShiftData2[23:0],8'b0},{{8{HighBit}},ShiftData2[31:8]},{ShiftData2[7:0],ShiftData2[31:8]},{Select[1]&Count[3],Select[0]&Count[3]},ShiftData3); \n Mux4_1 Mux5(ShiftData3,{ShiftData3[15:0],16'b0},{{16{HighBit}},ShiftData3[31:16]},{ShiftData3[15:0],ShiftData3[31:16]},{Select[1]&Count[4],Select[0]&Count[4]},Data_out); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a 32-bit ripple-carry adder, where the inputs a and b are added together with a carry-in bit cin. The sum output is the result of the addition, and the cout output is the carry-out bit. The module uses a generate block to create a loop that iterates from 2 to 31, performing the addition for each bit position. The G and P wires represent the generate and propagate signals used in the carry computation, and C represents the carry-out for each bit position. Finally, the cout output is computed based on the final generate and propagate signals at the most significant bit position.\n\n Module header:\n\nmodule add_ahead32(sum,cout,a,b,cin);\n [/INST]\n", "output": "output[31:0] sum; \n output cout; \n input[31:0] a,b; \n input cin; \n wire[31:0] G,P; \n wire[31:0] C,sum; \n assign G[0]=a[0]&b[0]; \n assign P[0]=a[0]|b[0]; \n assign C[0]=cin; \n assign sum[0]=G[0]^P[0]^C[0]; \n assign G[1]=a[1]&b[1]; \n assign P[1]=a[1]|b[1]; \n assign C[1]=G[0]|(P[0]&cin); \n assign sum[1]=G[1]^P[1]^C[1]; \n genvar i; \n generate \n for(i = 2; i < 32; i = i + 1) begin:aaa \n  assign G[i]=a[i]&b[i]; \n  assign P[i]=a[i]|b[i]; \n  assign C[i]=G[i-1]|(P[i-1]&C[i-1]); \n  assign sum[i]=G[i]^P[i]^C[i]; \n end \n endgenerate \n assign cout=G[31]|(P[31]&C[31]); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a VGA controller for a 512x256 display. It utilizes counters for horizontal and vertical positioning, and uses a one-hot encoding to generate the color output signals. The module also handles horizontal and vertical synchronization signals based on the specified timing parameters.\n\n Module header:\n\nmodule vga512x256 (input wire clk,input wire rst,output wire [12:0] maddr,input wire [15:0] mdata,output wire red,output wire green,output wire blue,output wire hsync,output wire vsync);\n [/INST]\n", "output": "parameter B = 50; \n  parameter C = 92; \n  parameter D = 512; \n  parameter E = 36; \n  parameter P = 4; \n  parameter Q = 61; \n  parameter R = 512; \n  parameter S = 31; \n  reg [9:0] cnt_x; \n  reg [9:0] cnt_y; \n  reg [15:0] word; \n  assign red = word[0]; \n  assign green = word[0]; \n  assign blue = word[0]; \n  assign maddr = { cnt_y[8:1], cnt_x[8:4] }; \n  assign hsync = ~(cnt_x > (D + E) && cnt_x <= (D + E + B)); \n  assign vsync = ~(cnt_y >= (R + S) && cnt_y < (R + S + P)); \n  always @(posedge clk) begin \n  if (rst || cnt_x == (B + C + D + E - 1)) \n  cnt_x <= 0; \n  else \n  cnt_x <= cnt_x + 1; \n  if (rst) \n  cnt_y <= 0; \n  else if (cnt_x == (B + C + D + E - 1)) begin \n  if (cnt_y == (P + Q + R + S - 1)) \n  cnt_y <= 0; \n  else \n  cnt_y <= cnt_y + 1; \n  end \n  if (cnt_x[3:0] == 1) begin \n  if (cnt_x <= D && cnt_y < R) \n  word <= mdata; \n  else \n  word <= 0; \n  end else \n  word <= { 1'b0, word[15:1] }; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, \"emesh_monitor\", is designed to monitor and trace packets in an Emulation Mesh (EMESH) system. It takes various inputs such as clock, reset, instruction trace, emulation time, EMESH access, EMESH packet, and EMESH wait. The module also has parameters for defining the address width, data width, module name, and packet width. \n\nThe module initializes a name, opens a trace file on startup, and on each clock cycle, it checks for a valid instruction trace packet and writes the relevant data to the trace file. The written data includes different parts of the EMESH packet in hexadecimal format.\n\nIn essence, this module captures and records EMESH packets to a trace file under certain conditions, providing monitoring and tracing functionality for an EMESH system.\n\n Module header:\n\nmodule emesh_monitor(clk, reset, itrace, etime, emesh_access, emesh_packet, emesh_wait);\n [/INST]\n", "output": "parameter AW = 32; \n  parameter DW = 32; \n  parameter NAME = \"cpu\"; \n  parameter PW = 104; \n  input clk; \n  input reset; \n  input itrace; \n  input [31:0] etime; \n  input emesh_access; \n  input [PW-1:0] emesh_packet; \n  input emesh_wait; \n  reg [63:0] name=NAME; \n  reg [31:0] ftrace; \n  initial \n  begin \n  ftrace = $fopen({NAME,\".trace\"}, \"w\"); \n  end \n  always @ (posedge clk) \n  if(itrace & ~reset & emesh_access & ~emesh_wait) \n  begin \n $fwrite(ftrace, \"%h_%h_%h_%h\\n\",emesh_packet[103:72], emesh_packet[71:40],emesh_packet[39:8],{emesh_packet[7:4],emesh_packet[3:2],emesh_packet[1],emesh_access}); \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module serves as a wrapper for the oddr component. It can be configured to use either the physical oddr or a generated oddr. The module handles the initialization of q1 and q2 based on the DDR_CLK_EDGE parameter. When OCE is high, the module updates q1 and q2 based on D1 and D2, respectively. The output signal OQ is assigned based on the clock signal C and the values of q1 and q2.\n\n Module header:\n\nmodule oddr_wrapper (input wire C,input wire OCE,input wire S,input wire R,input wire D1,input wire D2,output wire OQ);\n [/INST]\n", "output": "parameter USE_PHY_ODDR = 0; \n  parameter SRTYPE = \"SYNC\"; \n  parameter INIT = 0; \n  parameter DDR_CLK_EDGE = \"OPPOSITE_EDGE\"; \n  generate if (USE_PHY_ODDR != 0) begin \n ODDR # (.SRTYPE (SRTYPE),.INIT (INIT),.DDR_CLK_EDGE (DDR_CLK_EDGE)) the_oddr (.C (C),.CE (OCE),.S (S),.R (R),.D1 (D1),.D2 (D2),.Q (OQ)); \n  end else begin \n  reg q1; \n  reg q2; \n  initial q1 <= INIT; \n  initial q2 <= INIT; \n  if(DDR_CLK_EDGE == \"OPPOSITE_EDGE\") begin \n  always @(posedge C) \n  if (OCE) \n  q1 <= D1; \n  always @(negedge C) \n  if (OCE) \n  q2 <= D2; \n  end else if (DDR_CLK_EDGE == \"SAME_EDGE\" || DDR_CLK_EDGE == \"SAME_EDGE_PIPELINED\") begin \n  always @(posedge C) \n  if (OCE) \n  q1 <= D1; \n  always @(posedge C) \n  if (OCE) \n  q2 <= D2; \n  end \n  assign OQ = (C) ? q1 : q2; \n  end endgenerate \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module is a transmitter protocol for data transmission. It takes various input signals such as access, write, data mode, control mode, destination and source addresses, and data. The module then generates output signals including read wait, write wait, and acknowledge signals, along with frame and data signals for transmission. The module is sensitive to the clock and reset signals, updating the signals based on the input conditions, and includes synchronizers for read and write wait signals to ensure proper synchronization.\n\n Module header:\n\nmodule e_tx_protocol (e_tx_rd_wait, e_tx_wr_wait, e_tx_ack, txframe_p, txdata_p,reset, e_tx_access, e_tx_write, e_tx_datamode, e_tx_ctrlmode,e_tx_dstaddr, e_tx_srcaddr, e_tx_data, txlclk_p, tx_rd_wait,tx_wr_wait);\n [/INST]\n", "output": "input reset; \n  input e_tx_access; \n  input e_tx_write; \n  input [1:0] e_tx_datamode; \n  input [3:0] e_tx_ctrlmode; \n  input [31:0] e_tx_dstaddr; \n  input [31:0] e_tx_srcaddr; \n  input [31:0] e_tx_data; \n  output e_tx_rd_wait; \n  output e_tx_wr_wait; \n  output e_tx_ack; \n  input txlclk_p; \n  output [7:0] txframe_p; \n  output [63:0] txdata_p; \n  input tx_rd_wait; \n  input tx_wr_wait; \n  reg e_tx_ack; \n  reg [7:0] txframe_p; \n  reg [63:0] txdata_p; \n  always @( posedge txlclk_p or posedge reset ) begin \n  if( reset ) begin \n  e_tx_ack <= 1'b0; \n  txframe_p <= 'd0; \n  txdata_p <= 'd0; \n  end else begin \n  if( e_tx_access & ~e_tx_ack ) begin \n  e_tx_ack <= 1'b1; \n  txframe_p <= 8'h3F; \n  txdata_p <= \n  { 8'd0, \n  8'd0, \n  ~e_tx_write, 7'd0, \n  e_tx_ctrlmode, e_tx_dstaddr[31:28], \n  e_tx_dstaddr[27:4], \n  e_tx_dstaddr[3:0], e_tx_datamode, e_tx_write, e_tx_access \n  }; \n  end else if( e_tx_ack ) begin \n  e_tx_ack <= 1'b0; \n  txframe_p <= 8'hFF; \n  txdata_p <= { e_tx_data, e_tx_srcaddr }; \n  end else begin \n  e_tx_ack <= 1'b0; \n  txframe_p <= 8'h00; \n  txdata_p <= 64'd0; \n  end \n  end \n  end \n  reg rd_wait_sync; \n  reg wr_wait_sync; \n  reg e_tx_rd_wait; \n  reg e_tx_wr_wait; \n  always @( posedge txlclk_p ) begin \n  rd_wait_sync <= tx_rd_wait; \n  e_tx_rd_wait <= rd_wait_sync; \n  wr_wait_sync <= tx_wr_wait; \n  e_tx_wr_wait <= wr_wait_sync; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module serves as a controller for a big LCD screen. It includes counters for horizontal and vertical synchronization, as well as a pixel counter. The module outputs signals for HSYNC, VSYNC, LCD_CLK, and the color components R, G, and B for the pixels on the screen. It also enables the reading of data from the LCD. The module uses the clock and reset signals to control the counters and generate the necessary synchronization signals for the LCD.\n\n Module header:\n\nmodule big_lcd(input clk,input reset,input [15:0] lcd_readdata,output lcd_read,output wire [7:0] R,output wire [7:0] G,output wire [7:0] B,output wire HSYNC,output wire VSYNC,output wire LCD_CLK);\n [/INST]\n", "output": "reg [10:0] counter_hs; \n reg [10:0] counter_vs; \n reg [20:0] pixel_counter; \n assign LCD_CLK = reset == 1 ? clk : 0; \n always@(posedge clk) \n begin \n if(reset == 1'b0) \n  begin \n  counter_hs <= 0; \n  counter_vs <= 0; \n  end \n  else \n  begin \n  if(counter_hs == 1055 ) \n  begin \n  if(counter_vs == 524) \n  counter_vs <= 0; \n  else \n  counter_vs <= counter_vs + 1; \n  counter_hs <= 0; \n  end \n  else \n  counter_hs <= counter_hs + 1; \n  end \n end \n wire data_en; \n assign lcd_read = (counter_hs >= 42 && counter_hs <= 681 && counter_vs >= 23 && counter_vs < 503) ? 1 : 0; \n assign data_en = (counter_hs >= 46 && counter_hs <= 686 && counter_vs >= 23 && counter_vs < 503) ? 1 : 0; \n assign VSYNC = (counter_vs >= 0 && counter_vs < 10) ? 0 : 1; \n assign HSYNC = (counter_hs >= 0 && counter_hs < 10) ? 0 : 1; \n assign R = data_en == 1 ? {lcd_readdata[15:11], lcd_readdata[15:13]} : 8'hff; \n assign G = data_en == 1 ? {lcd_readdata[10:5], lcd_readdata[10:9]} : 8'h00; \n assign B = data_en == 1 ? {lcd_readdata[4:0], lcd_readdata[4:2]} : 8'h0f; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe module `tx_buffer` is designed to handle USB data transmission. It interfaces with various input signals such as usbclk, bus_reset, usbdata, WR, clear_status, txclk, reset, channels, and txstrobe, and outputs signals like have_space, tx_underrun, tx_empty, and debugbus. \n\nThe module contains internal logic to manage the USB data transmission process. It includes a FIFO buffer to store and transmit data, along with control logic to handle reset conditions, data writing, and status flag updates. The phase variable controls the state of the transmission process, and the module also handles the detection of underrun conditions during data transmission.\n\nThe debugbus output provides visibility into various internal signals for debugging purposes, including status flags, control signals, and clock signals. This module provides the necessary functionality to manage USB data transmission and monitor the status of the transmission process for debugging and validation purposes.\n\n Module header:\n\nmodule tx_buffer (input usbclk,input bus_reset,input [15:0] usbdata,input wire WR,output reg have_space,output reg tx_underrun,input clear_status,input txclk,input reset,input wire [3:0] channels,output reg [15:0] tx_i_0,output reg [15:0] tx_q_0,output reg [15:0] tx_i_1,output reg [15:0] tx_q_1,input txstrobe,output wire tx_empty,output [31:0] debugbus);\n [/INST]\n", "output": "wire [11:0] txfifolevel; \n  wire [15:0] fifodata; \n  wire rdreq; \n  reg [3:0] phase; \n  wire sop_f, iq_f; \n  reg sop; \n  reg [15:0] usbdata_reg; \n  reg wr_reg; \n  reg [8:0] write_count; \n  always @(posedge usbclk) \n  have_space <= (txfifolevel < (4092-256)); \n  always @(posedge usbclk) \n  begin \n  wr_reg <= WR; \n  usbdata_reg <= usbdata; \n  end \n  always @(posedge usbclk) \n  if(bus_reset) \n  write_count <= 0; \n  else if(wr_reg) \n  write_count <= write_count + 1; \n  else \n  write_count <= 0; \n  always @(posedge usbclk) \n  sop <= WR & ~wr_reg; \n  fifo_4k_18 txfifo \n (.data ( {sop,write_count[0],usbdata_reg} ),.wrreq ( wr_reg & ~write_count[8] ),.wrclk ( usbclk ),.wrfull ( ),.wrempty ( ),.wrusedw ( txfifolevel ),.q ( {sop_f, iq_f, fifodata} ),.rdreq ( rdreq ),.rdclk ( txclk ),.rdfull ( ),.rdempty ( tx_empty ),.rdusedw ( ),.aclr ( reset ) ); \n  always @(posedge txclk) \n  if(reset) \n  begin \n  {tx_i_0,tx_q_0,tx_i_1,tx_q_1} <= 64'h0; \n  phase <= 4'd0; \n  end \n  else if(phase == channels) \n  begin \n  if(txstrobe) \n  phase <= 4'd0; \n  end \n  else \n  if(~tx_empty) \n  begin \n  case(phase) \n  4'd0 : tx_i_0 <= fifodata; \n  4'd1 : tx_q_0 <= fifodata; \n  4'd2 : tx_i_1 <= fifodata; \n  4'd3 : tx_q_1 <= fifodata; \n  endcase \n  phase <= phase + 4'd1; \n  end \n  assign rdreq = ((phase != channels) & ~tx_empty); \n  reg clear_status_dsp, tx_underrun_dsp; \n  always @(posedge txclk) \n  clear_status_dsp <= clear_status; \n  always @(posedge usbclk) \n  tx_underrun <= tx_underrun_dsp; \n  always @(posedge txclk) \n  if(reset) \n  tx_underrun_dsp <= 1'b0; \n  else if(txstrobe & (phase != channels)) \n  tx_underrun_dsp <= 1'b1; \n  else if(clear_status_dsp) \n  tx_underrun_dsp <= 1'b0; \n  assign debugbus[0] = reset; \n  assign debugbus[1] = txstrobe; \n  assign debugbus[2] = rdreq; \n  assign debugbus[6:3] = phase; \n  assign debugbus[7] = tx_empty; \n  assign debugbus[8] = tx_underrun_dsp; \n  assign debugbus[9] = iq_f; \n  assign debugbus[10] = sop_f; \n  assign debugbus[14:11] = 0; \n  assign debugbus[15] = txclk; \n  assign debugbus[16] = bus_reset; \n  assign debugbus[17] = WR; \n  assign debugbus[18] = wr_reg; \n  assign debugbus[19] = have_space; \n  assign debugbus[20] = write_count[8]; \n  assign debugbus[21] = write_count[0]; \n  assign debugbus[22] = sop; \n  assign debugbus[23] = tx_underrun; \n  assign debugbus[30:24] = 0; \n  assign debugbus[31] = usbclk; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a DMA (Direct Memory Access) memory read controller. It manages the read access to the memory based on various input signals and control logic.\n\nThe module has inputs for clock signals, control signals like go, p1_done_read, p1_fifo_full, and read_waitrequest, and a reset signal. It also has outputs for controlling the read operation, including signals like inc_read and mem_read_n.\n\nThe module's behavior is defined by several internal registers and combinational logic. It uses these internal registers to determine the read access state and control the read select signal. The read access is enabled based on various conditions such as the state of the memory read access, fifo full, done read, go signal, and wait requests.\n\nOverall, the module acts as a controller for the memory read operation in a system with DMA capabilities, and it uses the input signals to manage and control the read access to the memory.\n\n Module header:\n\nmodule soc_design_General_DMA_mem_read (clk,clk_en,go,p1_done_read,p1_fifo_full,read_waitrequest,reset_n,inc_read,mem_read_n);\n [/INST]\n", "output": "output inc_read; \n  output mem_read_n; \n  input clk; \n  input clk_en; \n  input go; \n  input p1_done_read; \n  input p1_fifo_full; \n  input read_waitrequest; \n  input reset_n; \n  wire inc_read; \n  wire mem_read_n; \n  wire p1_read_select; \n  reg read_select; \n  reg soc_design_General_DMA_mem_read_access; \n  reg soc_design_General_DMA_mem_read_idle; \n  assign mem_read_n = ~read_select; \n  always @(posedge clk or negedge reset_n) \n  begin \n  if (reset_n == 0) \n  read_select <= 0; \n  else if (clk_en) \n  read_select <= p1_read_select; \n  end \n  assign inc_read = read_select & ~read_waitrequest; \n  always @(posedge clk or negedge reset_n) \n  begin \n  if (reset_n == 0) \n  soc_design_General_DMA_mem_read_idle <= 1; \n  else if (clk_en) \n  soc_design_General_DMA_mem_read_idle <= ((soc_design_General_DMA_mem_read_idle == 1) & (go == 0)) | \n  ((soc_design_General_DMA_mem_read_idle == 1) & (p1_done_read == 1)) | \n  ((soc_design_General_DMA_mem_read_idle == 1) & (p1_fifo_full == 1)) | \n  ((soc_design_General_DMA_mem_read_access == 1) & (p1_fifo_full == 1) & (read_waitrequest == 0)) | \n  ((soc_design_General_DMA_mem_read_access == 1) & (p1_done_read == 1) & (read_waitrequest == 0)); \n  end \n  always @(posedge clk or negedge reset_n) \n  begin \n  if (reset_n == 0) \n  soc_design_General_DMA_mem_read_access <= 0; \n  else if (clk_en) \n  soc_design_General_DMA_mem_read_access <= ((soc_design_General_DMA_mem_read_idle == 1) & (p1_fifo_full == 0) & (p1_done_read == 0) & (go == 1)) | \n  ((soc_design_General_DMA_mem_read_access == 1) & (read_waitrequest == 1)) | \n  ((soc_design_General_DMA_mem_read_access == 1) & (p1_fifo_full == 0) & (p1_done_read == 0) & (read_waitrequest == 0)); \n  end \n  assign p1_read_select = ({1 {((soc_design_General_DMA_mem_read_access && (read_waitrequest == 1)))}} & 1) | \n  ({1 {((soc_design_General_DMA_mem_read_access && (p1_done_read == 0) && (p1_fifo_full == 0) && (read_waitrequest == 0)))}} & 1) | \n  ({1 {((soc_design_General_DMA_mem_read_idle && (go == 1) && (p1_done_read == 0) && (p1_fifo_full == 0)))}} & 1); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a FIFO (First In, First Out) buffer with a configurable width. It has inputs for clock, reset, data to be pushed, push signal, and pull signal, as well as outputs for the data being pulled out, full flag, and empty flag. \n\nThe module uses a memory register to store the data and has flags to indicate whether the FIFO is full or empty. The data is loaded into the memory when a push signal is received and the FIFO is not full. Similarly, the data is pulled out from the memory when a pull signal is received and the FIFO is not empty. \n\nThe module also handles the reset condition to set the empty flag and clear the full flag. The output signals are assigned to the appropriate values based on the state of the FIFO.\n\nIn summary, this Verilog module implements a configurable FIFO buffer that can accept new data, pull out existing data, and keep track of whether it is full or empty.\n\n Module header:\n\nmodule fifo1(input clk_i,input rst_i,input [g_width-1:0] data_i,input push_i,input pull_i,output [g_width-1:0] data_o,output full_o,output empty_o);\n [/INST]\n", "output": "parameter g_width = 32; \n  reg [g_width-1:0] mem; \n  reg full; \n  reg empty; \n  initial mem = 0; \n  always @(posedge clk_i, negedge rst_i) \n  if(!rst_i) \n  begin \n  empty <= 1; \n  full <= 0; \n  end \n  else \n  begin \n  if(push_i & !full) \n  begin \n  empty <= 0; \n  mem <= data_i; \n  full <= 1; \n  end \n  else if (pull_i & !empty) \n  begin \n  empty <= 1; \n  full <= 0; \n  end \n  end \n  assign data_o = mem; \n  assign empty_o = empty; \n  assign full_o = full; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a GPIO (General Purpose Input/Output) interface for the Parallella board. It handles the input and output signals for the GPIO pins, as well as the input and output signals for the PS (Processing System) GPIO. The module supports both differential and single-ended GPIO configurations. It utilizes a generate block to instantiate the appropriate IOBUFDS or IOBUF modules based on the DIFF_GPIO parameter. Additionally, it generates and assigns the unused PS signals. The module provides a flexible and configurable interface for handling GPIO signals and PS GPIO communication on the Parallella board.\n\n Module header:\n\nmodule parallella_gpio_emio (PS_GPIO_I,GPIO_P, GPIO_N,PS_GPIO_O, PS_GPIO_T);\n [/INST]\n", "output": "parameter NUM_GPIO_PAIRS = 24; \n  parameter DIFF_GPIO = 0; \n  parameter NUM_PS_SIGS = 64; \n  inout [NUM_GPIO_PAIRS-1:0] GPIO_P; \n  inout [NUM_GPIO_PAIRS-1:0] GPIO_N; \n  output [NUM_PS_SIGS-1:0] PS_GPIO_I; \n  input [NUM_PS_SIGS-1:0] PS_GPIO_O; \n  input [NUM_PS_SIGS-1:0] PS_GPIO_T; \n  genvar m; \n  generate \n  if( DIFF_GPIO == 1 ) begin: GPIO_DIFF \n  IOBUFDS \n #(.DIFF_TERM(\"TRUE\"),.IBUF_LOW_PWR(\"TRUE\"),.IOSTANDARD(\"LVDS_25\"),.SLEW(\"FAST\")) \n  GPIOBUF_DS [NUM_GPIO_PAIRS-1:0] \n (.O(PS_GPIO_I),.IO(GPIO_P),.IOB(GPIO_N),.I(PS_GPIO_O),.T(PS_GPIO_T)); \n  end else begin: GPIO_SE \n  wire [NUM_GPIO_PAIRS-1:0] gpio_i_n, gpio_i_p; \n  wire [NUM_GPIO_PAIRS-1:0] gpio_o_n, gpio_o_p; \n  wire [NUM_GPIO_PAIRS-1:0] gpio_t_n, gpio_t_p; \n  for(m=0; m<NUM_GPIO_PAIRS; m=m+2) begin : assign_se_sigs \n  assign PS_GPIO_I[2*m] = gpio_i_n[m]; \n  assign PS_GPIO_I[2*m+1] = gpio_i_n[m+1]; \n  assign PS_GPIO_I[2*m+2] = gpio_i_p[m]; \n  assign PS_GPIO_I[2*m+3] = gpio_i_p[m+1]; \n  assign gpio_o_n[m] = PS_GPIO_O[2*m]; \n  assign gpio_o_n[m+1] = PS_GPIO_O[2*m+1]; \n  assign gpio_o_p[m] = PS_GPIO_O[2*m+2]; \n  assign gpio_o_p[m+1] = PS_GPIO_O[2*m+3]; \n  assign gpio_t_n[m] = PS_GPIO_T[2*m]; \n  assign gpio_t_n[m+1] = PS_GPIO_T[2*m+1]; \n  assign gpio_t_p[m] = PS_GPIO_T[2*m+2]; \n  assign gpio_t_p[m+1] = PS_GPIO_T[2*m+3]; \n  end \n  IOBUF \n #(.DRIVE(8),.IBUF_LOW_PWR(\"TRUE\"),.IOSTANDARD(\"LVCMOS25\"),.SLEW(\"SLOW\")) \n  GPIOBUF_SE_N [NUM_GPIO_PAIRS-1:0] \n (.O(gpio_i_n),.IO(GPIO_N),.I(gpio_o_n),.T(gpio_t_n)); \n  IOBUF \n #(.DRIVE(8),.IBUF_LOW_PWR(\"TRUE\"),.IOSTANDARD(\"LVCMOS25\"),.SLEW(\"SLOW\")) \n  GPIOBUF_SE_P [NUM_GPIO_PAIRS-1:0] \n (.O(gpio_i_p),.IO(GPIO_P),.I(gpio_o_p),.T(gpio_t_p)); \n  end \n  endgenerate \n  genvar n; \n  generate for(n=NUM_GPIO_PAIRS*2; n<48; n=n+1) begin : unused_ps_sigs \n  assign PS_GPIO_I[n] \n  = PS_GPIO_O[n] & \n  ~PS_GPIO_T[n]; \n  end \n  endgenerate \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a delay line with a configurable delay in terms of clock cycles. It uses a shift register to delay the input signal and outputs the delayed signal after the specified number of clock cycles. The module has inputs for the clock, reset, and input data, and an output for the delayed data. The delay cycles and the data width of the input and output are parameterized for configurability. When the reset is active, the delay line is reset to zero, and on each clock cycle, the input data is shifted through the shift register, propagating the delayed signal. The output is the data stored in the shift register after the specified number of delay cycles.\n\n Module header:\n\nmodule util_delay #(parameter DATA_WIDTH = 1,parameter DELAY_CYCLES = 1) (input clk,input reset,input din,output [DATA_WIDTH-1:0] dout);\n [/INST]\n", "output": "reg [DATA_WIDTH-1:0] dbuf[0:(DELAY_CYCLES-1)]; \n  always @(posedge clk) begin \n  if (reset) begin \n  dbuf[0] <= 0; \n  end else begin \n  dbuf[0] <= din; \n  end \n  end \n  generate \n  genvar i; \n  for (i = 1; i < DELAY_CYCLES; i=i+1) begin:register_pipe \n  always @(posedge clk) begin \n  if (reset) begin \n  dbuf[i] <= 0; \n  end else begin \n  dbuf[i] <= dbuf[i-1]; \n  end \n  end \n  end \n  endgenerate \n  assign dout = dbuf[(DELAY_CYCLES-1)]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module creates a simple voltage regulator. It assigns a constant value of 1 to the output port, effectively providing a fixed voltage output.\n\n Module header:\n\nmodule GP_VDD(output OUT);\n [/INST]\n", "output": "assign OUT = 1; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a read/write manager for error checking and correction. It compares read data to reference data, applies a mask, and computes the error word. The module has inputs for clock, reset, clear, enable, read data, reference data, and mask, and outputs the error word. It operates on data of a specified width and number of words. The error word is computed bitwise, with different operations based on the AFI_RATIO value. The module uses registers and bitwise operations to handle error checking and correction based on the input signals.\n\n Module header:\n\nmodule rw_manager_bitcheck(ck,reset_n,clear,enable,read_data,reference_data,mask,error_word);\n [/INST]\n", "output": "parameter DATA_WIDTH = \"\"; \n  parameter AFI_RATIO = \"\"; \n  localparam NUMBER_OF_WORDS = 2 * AFI_RATIO; \n  localparam DATA_BUS_SIZE = DATA_WIDTH * NUMBER_OF_WORDS; \n  input ck; \n  input reset_n; \n  input clear; \n  input enable; \n  input [DATA_BUS_SIZE - 1 : 0] read_data; \n  input [DATA_BUS_SIZE - 1 : 0] reference_data; \n  input [NUMBER_OF_WORDS - 1 : 0] mask; \n  output [DATA_WIDTH - 1 : 0] error_word; \n  reg [DATA_BUS_SIZE - 1 : 0] read_data_r; \n  reg [DATA_WIDTH - 1 : 0] error_word; \n  reg enable_r; \n  wire [DATA_WIDTH - 1 : 0] error_compute; \n  always @(posedge ck or negedge reset_n) begin \n  if(~reset_n) begin \n  error_word <= {DATA_WIDTH{1'b0}}; \n  read_data_r <= {DATA_BUS_SIZE{1'b0}}; \n  enable_r <= 1'b0; \n  end \n  else begin \n  if(clear) begin \n  error_word <= {DATA_WIDTH{1'b0}}; \n  end \n  else if(enable_r) begin \n  error_word <= error_word | error_compute; \n  end \n  read_data_r <= read_data; \n  enable_r <= enable; \n  end \n  end \n  genvar b; \n  generate \n  for(b = 0; b < DATA_WIDTH; b = b + 1) \n  begin : bit_loop \n  if (AFI_RATIO == 4) begin \n  assign error_compute[b] = \n  ((read_data_r[b] ^ reference_data[b]) & ~mask[0]) | \n  ((read_data_r[b + DATA_WIDTH] ^ reference_data[b + DATA_WIDTH]) & ~mask[1]) | \n  ((read_data_r[b + 2 * DATA_WIDTH] ^ reference_data[b + 2 * DATA_WIDTH]) & ~mask[2]) | \n  ((read_data_r[b + 3 * DATA_WIDTH] ^ reference_data[b + 3 * DATA_WIDTH]) & ~mask[3]) | \n  ((read_data_r[b + 4 * DATA_WIDTH] ^ reference_data[b + 4 * DATA_WIDTH]) & ~mask[4]) | \n  ((read_data_r[b + 5 * DATA_WIDTH] ^ reference_data[b + 5 * DATA_WIDTH]) & ~mask[5]) | \n  ((read_data_r[b + 6 * DATA_WIDTH] ^ reference_data[b + 6 * DATA_WIDTH]) & ~mask[6]) | \n  ((read_data_r[b + 7 * DATA_WIDTH] ^ reference_data[b + 7 * DATA_WIDTH]) & ~mask[7]); \n  end \n  else if (AFI_RATIO == 2) begin \n  assign error_compute[b] = \n  ((read_data_r[b] ^ reference_data[b]) & ~mask[0]) | \n  ((read_data_r[b + DATA_WIDTH] ^ reference_data[b + DATA_WIDTH]) & ~mask[1]) | \n  ((read_data_r[b + 2 * DATA_WIDTH] ^ reference_data[b + 2 * DATA_WIDTH]) & ~mask[2])| \n  ((read_data_r[b + 3 * DATA_WIDTH] ^ reference_data[b + 3 * DATA_WIDTH]) & ~mask[3]); \n  end \n  else begin \n  assign error_compute[b] = \n  ((read_data_r[b] ^ reference_data[b]) & ~mask[0]) | \n  ((read_data_r[b + DATA_WIDTH] ^ reference_data[b + DATA_WIDTH]) & ~mask[1]); \n  end \n  end \n  endgenerate \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, \"sparc_tlu_dec64,\" takes a 6-bit input signal and produces a 64-bit output signal. It iterates through each bit of the output and compares it with the corresponding bit of the input. If there is a match, the output bit is set to 1; otherwise, it is set to 0. This process is controlled by the always block, which is sensitive to changes in the input signal.\n\n Module header:\n\nmodule sparc_tlu_dec64(out,in);\n [/INST]\n", "output": "input [5:0] in; \n  output [63:0] out; \n  wire [5:0] in; \n  reg [63:0] out; \n  integer i; \n  always @ (in) \n  begin \n  for (i=0;i<64;i=i+1) \n  begin \n  if (i[5:0] == in[5:0]) \n  out[i] = 1'b1; \n  else \n  out[i] = 1'b0; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a UART transmitter. It uses a state machine with states for IDLE, START, DATA, and STOP. When the received data is valid, it starts the transmission by transitioning to the START state. In the DATA state, it shifts the received data left by 1 bit and increments a transmitter counter until it reaches 7. In the STOP state, it transitions back to the IDLE state. The module also controls the transmit output signal based on the state machine state and handles the transmitter enable signal.\n\n Module header:\n\nmodule uart_tx(input clk_i,input [`UART_DATA_LENGTH - 1 : 0] rx_i,input rx_i_v,output tx_o,output tx_o_v);\n [/INST]\n", "output": "localparam ST_IDLE = 3'd0; \n  localparam ST_START = 3'd1; \n  localparam ST_DATA = 3'd2; \n  localparam ST_STOP = 3'd3; \n  reg [2:0] state = ST_IDLE; \n  reg [2:0] tx_ctr = 0; \n  reg [`UART_DATA_LENGTH - 1 : 0] s_rx = 0; \n  reg s_tx = 1; \n  always @ (posedge clk_i) \n  begin \n  case (state) \n  ST_IDLE : \n  if (rx_i_v) \n  begin \n  state <= ST_START; \n  end \n  ST_START : \n  state <= ST_DATA; \n  ST_DATA : \n  if (tx_ctr == 7) \n  begin \n  state <= ST_STOP; \n  end \n  ST_STOP : \n  state <= ST_IDLE; \n  endcase \n  end \n  always @ (posedge clk_i) \n  begin \n  if (state == ST_DATA) \n  begin \n  tx_ctr <= tx_ctr + 1; \n  end \n  else \n  begin \n  tx_ctr <= 0; \n  end \n  end \n  always @ (posedge clk_i) \n  begin \n  if (state == ST_START) \n  begin \n  s_rx <= rx_i; \n  end \n  else if (state == ST_DATA) \n  begin \n  s_rx <= s_rx >> 1; \n  end \n  end \n  assign tx_o_v = (state == ST_IDLE) ? 0 : 1; \n  always @ * \n  begin \n  if (state == ST_START) \n  begin \n  s_tx = 0; \n  end \n  else if (state == ST_DATA) \n  begin \n  s_tx = s_rx[0]; \n  end \n  else if (state == ST_STOP) \n  begin \n  s_tx = 1; \n  end \n  end \n  assign tx_o = s_tx; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a special memory device with a configurable memory size, priority, and device category. It contains an internal memory array and logic to handle special memory requests. When the module is reset, it initializes the memory with specific values for the first two addresses, and sets the rest to a default value. During operation, it handles special memory requests by reading from or writing to the specified address in the memory array. The output oSPECIAL_DATA provides the data read from the memory at the requested address.\n\n Module header:\n\nmodule gci_std_display_device_special_memory #(parameter USEMEMSIZE = 32'h00000000,parameter PRIORITY = 32'h00000000,parameter DEVICECAT = 32'h00000000)(input wire iCLOCK,input wire inRESET,input wire iSPECIAL_REQ,input wire iSPECIAL_RW,input wire [7:0] iSPECIAL_ADDR,input wire [31:0] iSPECIAL_DATA,output wire [31:0] oSPECIAL_DATA);\n [/INST]\n", "output": "integer i; \n  reg [31:0] b_mem[0:255]; \n  always@(posedge iCLOCK or negedge inRESET)begin \n  if(!inRESET)begin \n  for(i = 0; i < 256; i = i + 1)begin \n  if(i == 0)begin \n  b_mem[i] <= USEMEMSIZE; \n  end \n  else if(i == 1)begin \n  b_mem[i] <= PRIORITY; \n  end \n  else begin \n  b_mem[i] <= 32'h00000000; \n  end \n  end \n  end \n  else begin \n  if(iSPECIAL_REQ && iSPECIAL_RW)begin \n  b_mem [iSPECIAL_ADDR] <= iSPECIAL_ADDR; \n  end \n  end \n  end \n  assign oSPECIAL_DATA = b_mem[iSPECIAL_ADDR]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a state machine that converts an unsigned 32-bit binary input into Binary Coded Decimal (BCD) output. The state machine has three states: S_IDLE, S_SHIFT, and S_ADD3. \n\nIn the S_IDLE state, the module waits for a trigger signal to transition to the S_SHIFT state. Once triggered, the module shifts the input left by 3 bits and stores the result in the shift register. If the shift register exceeds the value 5 in any of its nibbles, 3 is added to that nibble. The process continues until the counter reaches its maximum value of 32.\n\nUpon reaching the maximum count, the BCD output is updated with the shifted input, and the state transitions back to S_IDLE. The module resets to its initial state when the reset signal is asserted.\n\nThe module operates on the rising edge of the clock signal, updating its state, shift, BCD output, and counter based on the state transitions and input values.\n\n Module header:\n\nmodule unsigned_to_bcd (input clk,input trigger,input [31:0] in,output reg idle,output reg [31:0] bcd);\n [/INST]\n", "output": "localparam S_IDLE = 'b001; \n  localparam S_SHIFT = 'b010; \n  localparam S_ADD3 = 'b100; \n  reg [2:0] state, state_next; \n  reg [31:0] shift, shift_next; \n  reg [31:0] bcd_next; \n  localparam COUNTER_MAX = 32; \n  reg [5:0] counter, counter_next; \n  always @(*) begin \n  state_next = state; \n  shift_next = shift; \n  bcd_next = bcd; \n  counter_next = counter; \n  idle = 1'b0; \n  case (state) \n  S_IDLE: begin \n  counter_next = 'd1; \n  shift_next = 'd0; \n  idle = 1'b1; \n  if (trigger) begin \n  state_next = S_SHIFT; \n  end \n  end \n  S_ADD3: begin \n  if (shift[31:28] >= 5) \n  shift_next[31:28] = shift[31:28] + 4'd3; \n  if (shift[27:24] >= 5) \n  shift_next[27:24] = shift[27:24] + 4'd3; \n  if (shift[23:20] >= 5) \n  shift_next[23:20] = shift[23:20] + 4'd3; \n  if (shift[19:16] >= 5) \n  shift_next[19:16] = shift[19:16] + 4'd3; \n  if (shift[15:12] >= 5) \n  shift_next[15:12] = shift[15:12] + 4'd3; \n  if (shift[11:8] >= 5) \n  shift_next[11:8] = shift[11:8] + 4'd3; \n  if (shift[7:4] >= 5) \n  shift_next[7:4] = shift[7:4] + 4'd3; \n  if (shift[3:0] >= 5) \n  shift_next[3:0] = shift[3:0] + 4'd3; \n  state_next = S_SHIFT; \n  end \n  S_SHIFT: begin \n  shift_next = {shift[30:0], in[COUNTER_MAX - counter_next]}; \n  if (counter == COUNTER_MAX) begin \n  bcd_next = shift_next; \n  state_next = S_IDLE; \n  end else \n  state_next = S_ADD3; \n  counter_next = counter + 'd1; \n  end \n  default: begin \n  state_next = S_IDLE; \n  end \n  endcase \n  end \n  always @(posedge clk) begin \n  state <= state_next; \n  shift <= shift_next; \n  bcd <= bcd_next; \n  counter <= counter_next; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a dual-port RAM with 140 memory locations and 64-bit wide data. It has two separate ports, one for reading and writing data. The first port allows for reading and writing data at a specified address. The second port only allows for reading data at a specified address. The module uses clock signals and clock enable signals for each port and a write enable signal for the first port to control data access. The module contains two always blocks, one for each port, to handle the read and write operations based on the control signals.\n\n Module header:\n\nmodule feedforward_p_uOut_ram (addr0, ce0, d0, we0, q0, addr1, ce1, q1, clk);\n [/INST]\n", "output": "parameter DWIDTH = 64; \n parameter AWIDTH = 8; \n parameter MEM_SIZE = 140; \n input[AWIDTH-1:0] addr0; \n input ce0; \n input[DWIDTH-1:0] d0; \n input we0; \n output reg[DWIDTH-1:0] q0; \n input[AWIDTH-1:0] addr1; \n input ce1; \n output reg[DWIDTH-1:0] q1; \n input clk; \n (* ram_style = \"block\" *)reg [DWIDTH-1:0] ram[MEM_SIZE-1:0]; \n always @(posedge clk) \n begin \n  if (ce0) \n  begin \n  if (we0) \n  begin \n  ram[addr0] <= d0; \n  q0 <= d0; \n  end \n  else \n  q0 <= ram[addr0]; \n  end \n end \n always @(posedge clk) \n begin \n  if (ce1) \n  begin \n  q1 <= ram[addr1]; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module is a D flip-flop with two outputs Q0 and Q1, both of which are of reg type. When the RST input is high, Q0 and Q1 are both reset to 0. On the positive edge of the CLK input, Q0 is assigned the value of D0, and Q1 is assigned the value of D1.\n\n Module header:\n\nmodule DFF (output reg Q0,output reg [1:0] Q1,input wire D0,input wire [1:0] D1,input wire CLK,input wire RST);\n [/INST]\n", "output": "always @(posedge CLK or posedge RST) \n  if (RST) begin \n  Q0 <= 0; \n  Q1 <= 0; \n  end else begin \n  Q0 <= D0; \n  Q1 <= D1; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module represents a sequential element with asynchronous and synchronous set/reset inputs. It features a D flip-flop with asynchronous set/reset inputs and a clock enable. The module includes condition signals, delayed input signals, and logic gates to control the behavior of the flip-flop. The flip-flop updates its output based on the input data and clock signal, while considering the asynchronous set/reset conditions.\n\n Module header:\n\nmodule sky130_fd_sc_ls__sdfstp (Q ,CLK ,D ,SCD ,SCE ,SET_B);\n [/INST]\n", "output": "output Q ; \n  input CLK ; \n  input D ; \n  input SCD ; \n  input SCE ; \n  input SET_B; \n  supply1 VPWR; \n  supply0 VGND; \n  supply1 VPB ; \n  supply0 VNB ; \n  wire buf_Q ; \n  wire SET ; \n  wire mux_out ; \n  reg notifier ; \n  wire D_delayed ; \n  wire SCD_delayed ; \n  wire SCE_delayed ; \n  wire SET_B_delayed; \n  wire CLK_delayed ; \n  wire awake ; \n  wire cond0 ; \n  wire cond1 ; \n  wire cond2 ; \n  wire cond3 ; \n  wire cond4 ; \n  not not0 (SET , SET_B_delayed ); \n  sky130_fd_sc_ls__udp_mux_2to1 mux_2to10 (mux_out, D_delayed, SCD_delayed, SCE_delayed ); \n  sky130_fd_sc_ls__udp_dff$PS_pp$PG$N dff0 (buf_Q , mux_out, CLK_delayed, SET, notifier, VPWR, VGND); \n  assign awake = ( VPWR === 1'b1 ); \n  assign cond0 = ( ( SET_B_delayed === 1'b1 ) && awake ); \n  assign cond1 = ( ( SCE_delayed === 1'b0 ) && cond0 ); \n  assign cond2 = ( ( SCE_delayed === 1'b1 ) && cond0 ); \n  assign cond3 = ( ( D_delayed !== SCD_delayed ) && cond0 ); \n  assign cond4 = ( ( SET_B === 1'b1 ) && awake ); \n  buf buf0 (Q , buf_Q ); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a speed selection logic for a UART controller. It selects the baud rate based on the uart_ctrl input and generates the clock signals buad_clk_rx and buad_clk_tx for receiving and transmitting data. The module uses counters to divide the input clock frequency and generate the required baud rate clock signals. It also includes logic for handling reset signals to initialize the UART controller.\n\n Module header:\n\nmodule speed_select(clk, rst_n, rx_enable, tx_enable, buad_clk_rx, buad_clk_tx);\n [/INST]\n", "output": "input clk; \n input rst_n; \n input rx_enable; \n input tx_enable; \n output buad_clk_rx; \n output buad_clk_tx; \n parameter bps9600 = 5208, \n  bps19200 = 2603, \n  bps38400 = 1301, \n  bps57600 = 867, \n  bps115200 = 434, \n  bps256000 = 195; \n parameter bps9600_2 = 2604, \n  bps19200_2 = 1301, \n  bps38400_2 = 650, \n  bps57600_2 = 433, \n  bps115200_2 = 217, \n  bps256000_2 = 97; \n reg[12:0] bps_para; \n reg[12:0] bps_para_2; \n reg[2:0] uart_ctrl; \n always @ (posedge clk or negedge rst_n) begin \n  if(!rst_n) \n  begin \n  uart_ctrl <= 3'd4; \n  end \n  else \n  begin \n  case (uart_ctrl) \n  3'd0: begin \n  bps_para <= bps9600; \n  bps_para_2 <= bps9600_2; \n  end \n  3'd1: begin \n  bps_para <= bps19200; \n  bps_para_2 <= bps19200_2; \n  end \n  3'd2: begin \n  bps_para <= bps38400; \n  bps_para_2 <= bps38400_2; \n  end \n  3'd3: begin \n  bps_para <= bps57600; \n  bps_para_2 <= bps57600_2; \n  end \n  3'd4: begin \n  bps_para <= bps115200; \n  bps_para_2 <= bps115200_2; \n  end \n  3'd5: begin \n  bps_para <= bps256000; \n  bps_para_2 <= bps256000_2; \n  end \n  default:uart_ctrl <= 3'd0; \n  endcase \n  end \n end \n reg[12:0] cnt_rx; \n reg buad_clk_rx_reg; \n always @ (posedge clk or negedge rst_n) \n begin \n  if (!rst_n) \n  cnt_rx <= 13'd0; \n  else if (cnt_rx < bps_para && rx_enable) \n  cnt_rx <= cnt_rx + 13'd1; \n  else \n  cnt_rx <= 13'd0; \n end \n always @ (posedge clk or negedge rst_n) \n begin \n  if (!rst_n) \n  buad_clk_rx_reg <= 1'b0; \n  else if (cnt_rx < bps_para_2 && rx_enable && cnt_rx > 13'd10) \n  buad_clk_rx_reg <= 1'b1; \n  else \n  buad_clk_rx_reg <= 1'b0; \n end \n assign buad_clk_rx = buad_clk_rx_reg; \n reg[12:0] cnt_tx; \n reg buad_clk_tx_reg; \n always @ (posedge clk or negedge rst_n) \n begin \n  if (!rst_n) \n  cnt_tx <= 13'd0; \n  else if (cnt_tx < bps_para && tx_enable) \n  cnt_tx <= cnt_tx + 13'd1; \n  else \n  cnt_tx <= 13'd0; \n end \n always @ (posedge clk or negedge rst_n) \n begin \n  if (!rst_n) \n  buad_clk_tx_reg <= 1'b0; \n  else if (cnt_tx < bps_para_2 && tx_enable && cnt_tx > 13'd10) \n  buad_clk_tx_reg <= 1'b1; \n  else \n  buad_clk_tx_reg <= 1'b0; \n end \n assign buad_clk_tx = buad_clk_tx_reg; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a simple read-only FIFO (First-In-First-Out) buffer. It monitors the read operations and manages the available data in the FIFO. The module tracks the number of bytes left to read, updates the read data based on the FIFO read input, and handles the reset operation. It also generates signals such as `fifo_EF` to indicate whether the FIFO is empty, `fifo_rdata` to output the read data, `rfifo_full` to indicate whether the FIFO is full, and `rfifo_used` to track the number of entries used in the FIFO. The module interfaces with a JTAG UART DRM module for clock synchronization and data safety checks.\n\n Module header:\n\nmodule jtag_uart_sim_scfifo_r (clk,fifo_rd,rst_n,fifo_EF,fifo_rdata,rfifo_full,rfifo_used);\n [/INST]\n", "output": "output fifo_EF; \n  output [ 7: 0] fifo_rdata; \n  output rfifo_full; \n  output [ 5: 0] rfifo_used; \n  input clk; \n  input fifo_rd; \n  input rst_n; \n  reg [ 31: 0] bytes_left; \n  wire fifo_EF; \n  reg fifo_rd_d; \n  wire [ 7: 0] fifo_rdata; \n  wire new_rom; \n  wire [ 31: 0] num_bytes; \n  wire [ 6: 0] rfifo_entries; \n  wire rfifo_full; \n  wire [ 5: 0] rfifo_used; \n  wire safe; \n  jtag_uart_drom_module jtag_uart_drom \n (.clk (clk),.incr_addr (fifo_rd_d),.new_rom (new_rom),.num_bytes (num_bytes),.q (fifo_rdata),.reset_n (rst_n),.safe (safe)); \n  always @(posedge clk or negedge rst_n) \n  begin \n  if (rst_n == 0) \n  begin \n  bytes_left <= 32'h0; \n  fifo_rd_d <= 1'b0; \n  end \n  else \n  begin \n  fifo_rd_d <= fifo_rd; \n  if (fifo_rd_d) \n  bytes_left <= bytes_left - 1'b1; \n  if (new_rom) \n  bytes_left <= num_bytes; \n  end \n  end \n  assign fifo_EF = bytes_left == 32'b0; \n  assign rfifo_full = bytes_left > 7'h40; \n  assign rfifo_entries = (rfifo_full) ? 7'h40 : bytes_left; \n  assign rfifo_used = rfifo_entries[5 : 0]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module generates VGA horizontal and vertical synchronization signals and controls pixel blanking based on the screen row and column inputs. It uses a state machine to synchronize the signals and divides the clock frequency to achieve the desired VGA timing. The module also implements pixel_row and pixel_column logic and utilizes radix counters to drive the VGA signals. The module includes parameters for screen dimensions and timing parameters to ensure proper VGA signal generation.\n\n Module header:\n\nmodule FSM_VGA(VGA_hsync,VGA_vsync,pixel_blank,screen_row, screen_column,reset,clk);\n [/INST]\n", "output": "output VGA_hsync; \n  output VGA_vsync; \n  output pixel_blank; \n  input clk; \n  input reset; \n  reg [WORD-1:0] pixel_row; \n  reg [WORD-1:0] pixel_column; \n  output wire [WORD-1:0] screen_row; \n  output wire [WORD-1:0] screen_column; \n  reg [WORD-1:0] state_vertical; \n  reg [WORD-1:0] state_horizontal; \n  wire active_row; \n  wire active_column; \n  wire [WORD-1:0] division; \n  localparam PIXEL_H = SCREEN_WIDTH, \n  PIXEL_V = SCREEN_HEIGHT, \n  FRONT_PORCH_H = 16, \n  FRONT_PORCH_V = 10, \n  PULSE_H = 96, \n  PULSE_V = 2, \n  BACK_PORCH_H = 48, \n  BACK_PORCH_V = 29; \n  localparam SYNC_H = (PIXEL_H + FRONT_PORCH_H + PULSE_H + BACK_PORCH_H), \n  SYNC_V = (PIXEL_V + FRONT_PORCH_V + PULSE_V + BACK_PORCH_V); \n  localparam MODE_0_H = 0, \n  MODE_0_V = 0, \n  MODE_1_H = MODE_0_H + PIXEL_H, \n  MODE_1_V = MODE_0_V + PIXEL_V, \n  MODE_2_H = MODE_1_H + FRONT_PORCH_H, \n  MODE_2_V = MODE_1_V + FRONT_PORCH_V, \n  MODE_3_H = MODE_2_H + PULSE_H, \n  MODE_3_V = MODE_2_V + PULSE_V; \n  localparam STATE_PIXEL = 0, \n  STATE_FRONT_PORCH = 1, \n  STATE_PULSE = 2, \n  STATE_BACK_PORCH = 3; \n  assign pixel_blank = !((state_horizontal == STATE_PIXEL) && (state_vertical == STATE_PIXEL)); \n  assign VGA_hsync = !(state_horizontal==STATE_PULSE); \n  assign VGA_vsync = !(state_vertical ==STATE_PULSE); \n  always @(*) begin \n  if(state_vertical == STATE_PIXEL) pixel_row <= screen_row; \n  else pixel_row <= 0; \n  if(state_horizontal == STATE_PIXEL) pixel_column <= screen_column; \n  else pixel_column <= 0; \n  end \n  always @(*) begin \n  if(screen_column < MODE_1_H) state_horizontal <= STATE_PIXEL; \n  else if(screen_column < MODE_2_H) state_horizontal <= STATE_FRONT_PORCH; \n  else if(screen_column < MODE_3_H) state_horizontal <= STATE_PULSE; \n  else state_horizontal <= STATE_BACK_PORCH; \n  if(screen_row < MODE_1_V) state_vertical <= STATE_PIXEL; \n  else if(screen_row < MODE_2_V) state_vertical <= STATE_FRONT_PORCH; \n  else if(screen_row < MODE_3_V) state_vertical <= STATE_PULSE; \n  else state_vertical <= STATE_BACK_PORCH; \n  end \n  wire [4-1:0] carry; \n  assign carry[0] = 1; \n Radix_Counter #(SYNC_V) counter_screen_row(.carry_in(carry[2]),.carry_out(carry[3]),.count(screen_row),.reset(reset),.clk(clk)); \n Radix_Counter #(SYNC_H) counter_screen_column(.carry_in(carry[1]),.carry_out(carry[2]),.count(screen_column),.reset(reset),.clk(clk)); \n Radix_Counter #(VGA_SLOW) counter_divide(.carry_in(carry[0]),.carry_out(carry[1]),.count(division),.reset(reset),.clk(clk)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a serializer that reads data from a file and sends it out serially. It uses a clock signal to control the timing of the data transmission. The module reads data from a file 'test_serializer/data/in_parallel_vector.txt' and sends it out one byte at a time in a serial fashion. The clock signal is used to control the timing of the data transmission, and the send signal indicates when the data is being sent. The module ends by closing the file and resetting the clock.\n\n Module header:\n\nmodule serializer_gen_test (output [7:0] data,output send,output clk);\n [/INST]\n", "output": "reg [7:0] data_buf; \n  reg send_buf; \n  reg clk_buf; \n  assign clk = clk_buf; \n  assign send = send_buf; \n  assign data = data_buf; \n  integer data_src; \n  integer i; \n  integer j; \n  initial \n  begin \n  data_buf = 0; \n  clk_buf = 0; \n  send_buf = 0; \n  data_src = $fopen(\"test_serializer/data/in_parallel_vector.txt\", \"rb\"); \n  #100; \n  for(i = 0; i < 16; i = i + 1) \n  begin \n  clk_buf = 0; \n  #2; \n  clk_buf = 1; \n  #1; \n  data_buf = $fgetc(data_src); \n  #1; \n  clk_buf = 0; \n  #1; \n  send_buf = 1; \n  #1; \n  clk_buf = 1; \n  #1; \n  send_buf = 0; \n  #1; \n  for(j = 0; j < 10; j = j + 1) \n  begin \n  clk_buf = 0; \n  #2; \n  clk_buf = 1; \n  #2; \n  end \n  end \n  clk_buf = 0; \n  #2; \n  clk_buf = 1; \n  #2; \n  $fclose(data_src); \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"clip_reg\" instantiates the \"clip\" module, which takes an input \"in\" and generates an \"out\" after applying clipping operation. The \"clip_reg\" module passes the input \"in\" to the \"clip\" module and assigns the output \"temp\" to the register \"out\" upon a positive clock edge or when \"strobe_in\" is high or \"STROBED\" is low. It also registers the input \"strobe_in\" to the output \"strobe_out\" on every clock edge.\n\n Module header:\n\nmodule clip_reg #(parameter bits_in=0,parameter bits_out=0,parameter STROBED=1'b0) (input clk,input [bits_in-1:0] in,output reg [bits_out-1:0] out,input strobe_in,output reg strobe_out);\n [/INST]\n", "output": "wire [bits_out-1:0] temp; \n  clip #(.bits_in(bits_in),.bits_out(bits_out)) clip (.in(in),.out(temp)); \n  always @(posedge clk) \n  strobe_out <= strobe_in; \n  always @(posedge clk) \n  if(strobe_in | ~STROBED) \n  out <= temp; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is for a VGA_TEST circuit. It takes input clock signals, switches, and keys, and outputs VGA display signals. The FAN_CTRL signal is bidirectional. It assigns VGA_BLANK_N to 1 and VGA_SYNC_N to 0. The VGA_CLK output is assigned the value of pclock_w. The module contains instances of pixel_clock, vga640x480, and vga_stripes COLOR_GEN modules for generating the VGA signals based on the input clock and control signals.\n\n Module header:\n\nmodule VGA_TEST(CLOCK_50,CLOCK2_50,CLOCK3_50,KEY,SW,VGA_B,VGA_BLANK_N,VGA_CLK,VGA_G,VGA_HS,VGA_R,VGA_SYNC_N,VGA_VS,FAN_CTRL);\n [/INST]\n", "output": "input CLOCK_50; \n input CLOCK2_50; \n input CLOCK3_50; \n input [3:0] KEY; \n input [17:0] SW; \n output [7:0] VGA_B; \n output VGA_BLANK_N; \n output VGA_CLK; \n output [7:0] VGA_G; \n output VGA_HS; \n output [7:0] VGA_R; \n output VGA_SYNC_N; \n output VGA_VS; \n inout FAN_CTRL; \n wire vidon_w; \n wire [9:0] hc_w; \n wire [9:0] vc_w; \n wire pclock_w; \n assign FAN_CTRL = 1'bz; \n assign VGA_BLANK_N = 1; \n assign VGA_SYNC_N = 0; \n assign VGA_CLK = pclock_w; \n pixel_clock PCLOCK(.inclk0( CLOCK_50 ),.c0( pclock_w)); \n vga640x480 VGA(.CLK( pclock_w ),.CLR( ~KEY[0] ),.HSYNC( VGA_HS ),.VSYNC( VGA_VS ),.HC( hc_w ),.VC( vc_w ),.VIDON( vidon_w )); \n vga_stripes COLOR_GEN(.VIDON( vidon_w ),.HC( hc_w ),.VC( vc_w ),.R( VGA_R ),.G( VGA_G ),.B( VGA_B ),.SW( SW )); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a register file with a configurable width and number of addressable registers. It initializes an array R with zeros and updates R[wsel] with wdata on the positive clock edge when we is high. The module also assigns the value of R[asel] to the output adata. When we is high, it writes wdata to R[wsel] and prints the register write information to the console.\n\n Module header:\n\nmodule regfile1out #(parameter WIDTH=32, parameter RSELWIDTH=4) (input clk,input we, input [RSELWIDTH-1:0] wsel, input [WIDTH-1:0] wdata,input [RSELWIDTH-1:0] asel, output [WIDTH-1:0] adata);\n [/INST]\n", "output": "reg [WIDTH-1:0] R[0:2**RSELWIDTH-1]; \n integer k; \n initial begin \n  for (k = 0; k < RSELWIDTH**2; k = k + 1) R[k] = 0; \n end \n always @ (posedge clk) \n begin \n  if (we) \n  begin \n  R[wsel] <= wdata; \n  $display(\"reg write %h data %h\", wsel, wdata); \n  end \n end \n assign adata = R[asel]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module, lpm_constant, initializes an output result based on the parameters lpm_width and lpm_cvalue. It first checks if lpm_width is greater than 0, displaying an error message and terminating the simulation if it is not. Then, it assigns the value of lpm_cvalue to int_value and finally assigns the value of int_value to the output result.\n\n Module header:\n\nmodule lpm_constant (result);\n [/INST]\n", "output": "parameter lpm_width = 1; \n  parameter lpm_cvalue = 0; \n  parameter lpm_strength = \"UNUSED\"; \n  parameter lpm_type = \"lpm_constant\"; \n  parameter lpm_hint = \"UNUSED\"; \n  output [lpm_width-1:0] result; \n  reg[32:0] int_value; \n  initial \n  begin \n  if (lpm_width <= 0) \n  begin \n  $display(\"Value of lpm_width parameter must be greater than 0(ERROR)\"); \n  $display(\"Time: %0t Instance: %m\", $time); \n  $finish; \n  end \n  int_value = lpm_cvalue; \n  end \n  assign result = int_value[lpm_width-1:0]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"jizlots_tb\" models a testbench for the \"JIZLOTS_sel\" module. It includes a clock signal \"clk,\" an instruction type \"type,\" a rotation number \"rot,\" and an output \"block_out.\" The \"JIZLOTS_sel\" module is instantiated to write the selected and rotated block to the \"block_out\" wire. Upon simulation, the clock signal toggles every 5 time units. This testbench initializes the clock, type, and rotation signals and toggles the clock signal periodically for the simulation of the \"JIZLOTS_sel\" module.\n\n Module header:\n\nmodule jizlots_tb;\n [/INST]\n", "output": "reg clk; \n reg[2:0] type; \n reg[1:0] rot; \n wire[0:15] block_out; \n JIZLOTS_sel write(type, rot, block_out); \n initial begin \n  clk <= 0; \n  type <= 0; \n  rot <= 0; \n end \n always begin \n  #5 clk = !clk; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a wrapper for a Xilinx DSP48E1 module, which acts as a counter. It takes a clock signal, a reset signal, an increment value, and outputs the counter value. The module checks if the DATASIZE parameter is within acceptable bounds and initializes the DSP48E1 module accordingly. If the module is running in a pipelined mode, it declares a temporary register to hold the counter value and updates it on each clock cycle, otherwise it directly assigns the value to the output.\n\n Module header:\n\nmodule openhmc_counter48_wrapper_xilinx #(parameter DATASIZE = 48,parameter INC_SIZE = 1,parameter PIPELINED = 1) (input wire clk,input wire res_n,input wire [INC_SIZE-1:0] inc_value,output wire [DATASIZE-1:0] value);\n [/INST]\n", "output": "`ifdef SIMULATION \n  initial \n  begin \n  if (DATASIZE > 48) \n  begin \n  $display (\"unsupported DATASIZE parameter in counter48.\\nMax value is 48, actual value is %2d\", DATASIZE); \n  $stop; \n  end \n  end \n `endif \n  wire [47:0] value_w; \n DSP48E1 #(.ACASCREG(0),.ADREG(PIPELINED),.ALUMODEREG(PIPELINED),.AREG(0),.AUTORESET_PATDET(\"NO_RESET\"),.A_INPUT(\"DIRECT\"),.BCASCREG(PIPELINED),.BREG(PIPELINED),.B_INPUT(\"DIRECT\"),.CARRYINREG(1),.CARRYINSELREG(1),.CREG(0),.DREG(0),.INMODEREG(1),.MASK(48'h3fffffffffff),.MREG(0),.OPMODEREG(1),.PATTERN(48'h000000000000),.PREG(1),.SEL_MASK(\"MASK\"),.SEL_PATTERN(\"PATTERN\"),.USE_DPORT(\"FALSE\"),.USE_MULT(\"NONE\"),.USE_PATTERN_DETECT(\"NO_PATDET\"),.USE_SIMD(\"ONE48\")) DSP48E1_inst (.ACOUT(),.BCOUT(),.CARRYCASCOUT(),.MULTSIGNOUT(),.PCOUT(),.OVERFLOW(),.PATTERNBDETECT(),.PATTERNDETECT(),.UNDERFLOW(),.CARRYOUT(),.P(value_w),.ACIN(30'b0),.BCIN(18'b0),.CARRYCASCIN(1'b0),.MULTSIGNIN(1'b0),.PCIN(48'b0),.ALUMODE(4'b0000),.CARRYINSEL(3'b000),.CEINMODE(1'b0),.CLK(clk),.INMODE(5'b00000),.OPMODE({1'b0, 1'b1, 1'b0, 4'b0011}),.RSTINMODE(!res_n),.A(30'b0),.B({{18-INC_SIZE{1'b0}}, inc_value}),.C(48'h0),.CARRYIN(1'b0),.D(25'b0),.CEA1(1'b0),.CEA2(1'b0),.CEAD(1'b0),.CEALUMODE(1'b1),.CEB1(1'b0),.CEB2(1'b1),.CEC(1'b0),.CECARRYIN(1'b0),.CECTRL(1'b1),.CED(1'b0),.CEM(1'b0),.CEP(1'b1),.RSTA(1'b0),.RSTALLCARRYIN(1'b0),.RSTALUMODE(1'b0),.RSTB(!res_n),.RSTC(1'b0),.RSTCTRL(!res_n),.RSTD(1'b0),.RSTM(1'b0),.RSTP(!res_n)); \n generate \n  if(PIPELINED==1) begin \n  reg [DATASIZE-1:0] value_temp; \n  always @(posedge clk) begin \n  value_temp <= value_w[DATASIZE-1:0]; \n  end \n  assign value=value_temp; \n  end else begin \n  assign value = value_w[DATASIZE-1:0]; \n  end \n endgenerate \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module write_back implements a simple register-based write back stage in a processor. It selects the data to be written to the register file based on the control unit's decision (cu_reg_data_loc) and either the memory data output (m_dm_dout) or the ALU result (m_alu_result). The write enable signal (wb_reg_wea) is set based on the control unit's load signal (cu_reg_load), and the write address (wb_reg_waddr) is determined by the m_reg_waddr input.\n\n Module header:\n\nmodule write_back(input [15:0] m_alu_result,input [15:0] m_dm_dout,input [2:0] m_reg_waddr,input cu_reg_data_loc,input cu_reg_load,output [15:0] wb_reg_wdata,output wb_reg_wea,output [2:0] wb_reg_waddr);\n [/INST]\n", "output": "assign wb_reg_wdata = cu_reg_data_loc ? m_dm_dout : m_alu_result; \n assign wb_reg_wea = cu_reg_load; \n assign wb_reg_waddr = m_reg_waddr; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a 1st order Sigma-Delta modulator. It takes an input signal and generates an output signal based on the difference between the input and the feedback signal. The module includes logic for accumulator initialization, updating the accumulator based on the input and feedback, and handling of limit logic based on module parameters. The output signal is assigned the value of the Sigma-Delta modulator.\n\n Module header:\n\nmodule SigmaDelta1stOrder #(parameter IS_LIMITED = 0,parameter IN_WIDTH = 16,parameter OUT_WIDTH = 1) (input clk,input rst,input en,input signed [IN_WIDTH-1:0] in,output signed [OUT_WIDTH-1:0] sdOut);\n [/INST]\n", "output": "localparam LIMIT = (IS_LIMITED && (OUT_WIDTH != 1)) ? 1 : 0; \n localparam ACC_MSB = LIMIT ? (IN_WIDTH-OUT_WIDTH-1) : (IN_WIDTH-OUT_WIDTH); \n reg [ACC_MSB:0] acc; \n reg signed [OUT_WIDTH-1:0] sd; \n initial begin \n  acc = 'd0; \n  sd = 'd0; \n end \n assign unsignedIn = {in[IN_WIDTH-1], in[IN_WIDTH-2:0]}; \n always @(posedge clk) begin \n  if (rst) begin \n  acc <= 1 << (ACC_MSB); \n  sd <= 'd0; \n  end else if (en) begin \n  if (LIMIT) begin \n  {sd, acc} <= $signed({1'b0, acc}) + in; \n  end \n  else if (OUT_WIDTH > 1) begin \n  {sd, acc} <= $signed({1'b0, ~acc[ACC_MSB], acc[ACC_MSB-1:0]}) + in; \n  end \n  else begin \n  {sd, acc} <= $signed({~acc[ACC_MSB], acc[ACC_MSB-1:0]}) + in; \n  end \n  end \n end \n assign sdOut = sd; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a finite state machine control logic with five outputs (ENp, ENq, ENa, ENr, EOM) and two inputs (RST and STM). The state machine has four states represented by the Qp signal. The state transitions and output assignments are determined based on the current state (Qp) and the STM input. The state transitions are synchronized with the clock (CLK) and the reset signal (RST). The Qp signal is updated based on the next state (Qn) in the sequential block.\n\n Module header:\n\nmodule FSM_Ctrol (input RST,input CLK,input STM,output reg ENp,output reg ENq,output reg[3:0] ENa,output reg[3:0] ENr,output reg EOM);\n [/INST]\n", "output": "reg[2:0] Qp,Qn; \n  always @ * \n  begin : Combinacional \n  case (Qp) \n  3'b000 : begin \n  if (STM) \n  Qn = 3'b001; \n  else \n  Qn = Qp; \n  ENp = 1'b0; \n  ENq = 1'b0; \n  ENa = 4'b0000; \n  ENr = 4'b0000; \n  EOM = 1'b1; \n  end \n  3'b001 : begin \n  Qn = 3'b010; \n  ENp = 1'b1; \n  ENq = 1'b0; \n  ENa = 4'b0001; \n  ENr = 4'b0000; \n  EOM = 1'b0; \n  end \n  3'b010 : begin \n  Qn = 3'b011; \n  ENp = 1'b1; \n  ENq = 1'b1; \n  ENa = 4'b0111; \n  ENr = 4'b0001; \n  EOM = 1'b0; \n  end \n  3'b011 : begin \n  Qn = 3'b100; \n  ENp = 1'b0; \n  ENq = 1'b1; \n  ENa = 4'b1110; \n  ENr = 4'b0110; \n  EOM = 1'b0; \n  end \n  3'b100 : begin \n  Qn = 3'b000; \n  ENp = 1'b0; \n  ENq = 1'b0; \n  ENa = 4'b1110; \n  ENr = 4'b1000; \n  EOM = 1'b0; \n  end \n  endcase \n  end \n  always @ (posedge RST or posedge CLK) \n  begin : Secuencial \n  if (RST) \n  Qp <= 0; \n  else \n  Qp <= Qn; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a clock gate with an enable signal. It takes a clock signal input and an enable signal input, and generates an enabled clock signal output. The module uses internal signals to control the enable signal and the clock signal outputs. It consists of a latch and an AND gate to generate the enabled clock signal.\n\n Module header:\n\nmodule SNPS_CLOCK_GATE_HIGH_ff32_en_SIZE32_5 ( CLK, EN, ENCLK );\n [/INST]\n", "output": "input CLK, EN; \n  output ENCLK; \n  wire net3334, net3336, net3337, net3340; \n  assign net3334 = CLK; \n  assign ENCLK = net3336; \n  assign net3337 = EN; \n  DLL_X1 latch ( .D(net3337), .GN(net3334), .Q(net3340) ); \n  AND2_X1 main_gate ( .A1(net3340), .A2(net3334), .ZN(net3336) ); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a shift register and a multiplexer. It takes in a single-bit input 'i', a clock signal 'clk', and a 2-bit input 'l1' and 'l2', and outputs a 2-bit signal 'q'. The 'head' register stores the input 'i', and the 'shift1' and 'shift2' registers shift in the 'head' value on each clock cycle. The output 'q' is determined by the values in 'shift1' and 'shift2' based on the values of 'l1' and 'l2'.\n\n Module header:\n\nmodule shregmap_variable_test(input i, clk, input [1:0] l1, l2, output [1:0] q);\n [/INST]\n", "output": "reg head = 1'b0; \n reg [3:0] shift1 = 4'b0000; \n reg [3:0] shift2 = 4'b0000; \n always @(posedge clk) begin \n  head <= i; \n  shift1 <= {shift1[2:0], head}; \n  shift2 <= {shift2[2:0], head}; \n end \n assign q = {shift2[l2], shift1[l1]}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module simply assigns the constant value 1 to the output wire Result0.\n\n Module header:\n\nmodule cell1(Result0);\n [/INST]\n", "output": "output Result0; \n assign Result0 = 1; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, \"channelRequest,\" is designed to manage data transfer by controlling various signals such as request, initialization, and acknowledgment. It includes internal counters and logic to determine readiness for data transfer. The module also handles synchronization and updates based on clock signals and reset conditions. Additionally, it incorporates the handling of write enable and done signals. Overall, it is a comprehensive control module for coordinating data transfer operations.\n\n Module header:\n\nmodule channelRequest (rst,init,eclk,start,iclk,enXfer,ackn,wnr,done,rq,rqInit,rdy,rdy_async,wrempty);\n [/INST]\n", "output": "input rst; \n  input init; \n  input eclk; \n  input start; \n  input iclk; \n  input ackn; \n  input wnr; \n  input done; \n  input enXfer; \n  output rq; \n  output rqInit; \n  output rdy; \n  output rdy_async; \n  output wrempty; \n  reg [2:0] ecnt; \n  reg [2:0] icnt; \n  reg [2:0] rcnt; \n  wire[2:0] next_ecnt; \n  wire[2:0] next_icnt; \n  wire[2:0] next_rcnt; \n  wire cntrsInit; \n  reg cntrsValid; \n  reg rq; \n  reg rqInit; \n  wire ready_off; \n  reg rdy; \n  reg en_done; \n  reg current_wnr; \n  wire rdy_async; \n  assign rdy_async=!ready_off; \n  assign next_ecnt={ecnt[2]^ ((ecnt==3'b010)||(ecnt==3'b100)), \n  ecnt[1]^ ((ecnt==3'b001)||(ecnt==3'b111)), \n  ~ecnt[2] ^ ecnt[1]}; \n  assign next_icnt={icnt[2]^ ((icnt==3'b010)||(icnt==3'b100)), \n  icnt[1]^ ((icnt==3'b001)||(icnt==3'b111)), \n  ~icnt[2] ^ icnt[1]}; \n  assign next_rcnt={rcnt[2]^ ((rcnt==3'b010)||(rcnt==3'b100)), \n  rcnt[1]^ ((rcnt==3'b001)||(rcnt==3'b111)), \n  ~rcnt[2] ^ rcnt[1]}; \n  always @ (negedge iclk) en_done <= !rqInit && (en_done || ackn); \n  assign ready_off= !cntrsValid || (ecnt[2:0] == rcnt[2:0]); \n  always @ (posedge eclk or posedge rst) \n  if (rst) ecnt <= 3'b0; \n  else if (start) ecnt[2:0] <= next_ecnt; \n  always @ (posedge eclk or posedge ready_off) \n  if (ready_off) rdy <= 1'b0; \n  else rdy <= 1'b1; \n  assign wrempty= cntrsValid && (current_wnr?(ecnt[2:0]=={!rcnt[2],!rcnt[1],rcnt[0]}):(icnt[2:0] != ecnt[2:0])); \n  always @ (negedge iclk) begin \n  cntrsValid <= cntrsInit || (cntrsValid && ! init); \n  rqInit <= !rst && (init || (rqInit && !ackn)); \n  if (cntrsInit) current_wnr <=wnr; \n  icnt[2:0] <= cntrsInit? {ecnt[2]^(!wnr),ecnt[1]^(!wnr),ecnt[0]}: ((ackn && cntrsValid)? next_icnt[2:0]: icnt[2:0]); \n  rcnt[2:0] <= cntrsInit? {ecnt[2]^( wnr),ecnt[1]^( wnr),ecnt[0]}: ((en_done && done && cntrsValid)? next_rcnt[2:0]: rcnt[2:0]); \n  rq <= rqInit || (enXfer && cntrsValid && (icnt[2:0] != ecnt[2:0])); \n  end \n  MSRL16_1 i_cntrsInit (.Q(cntrsInit), .A(4'h3), .CLK(iclk), .D(ackn && rqInit)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis is a testbench module for verifying a CPU module. It initializes input signals for the CPU such as clock, button, switch, and segment output signals. It toggles the clock input signal and waits for 100 clock cycles for simulation purposes.\n\n Module header:\n\nmodule test_t;\n [/INST]\n", "output": "reg clk_in; \n  reg btn_t; \n  reg [5:0] sw; \n  wire [6:0] seg; \n  wire [3:0] an; \n Single_Cycle_CPU uut (.clk_in(clk_in),.btn_t(btn_t),.sw(sw),.seg(seg),.an(an)); \n  initial begin \n  clk_in = 0; \n  btn_t = 0; \n  sw = 0; \n  #100; \n  end \n  always #10 clk_in = ~clk_in; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a VGA serial interface by processing input signals including data, blanking, horizontal sync, vertical sync, and a clock signal. It utilizes registers and counters to generate synchronized outputs for the VGA interface signals. The input data is processed based on the horizontal sync signal to produce the appropriate output for the VGA data, blanking, horizontal sync, and vertical sync signals.\n\n Module header:\n\nmodule vga_serial (input [23:0] data,input blank,input hs,input vs,input clk3,output reg [7:0] data3,output blank3,output hs3,output vs3);\n [/INST]\n", "output": "reg hs_reg; \n reg hs_reg1; \n reg blank_reg; \n reg vs_reg; \n always @(posedge clk3) begin \n  hs_reg <= hs; \n  hs_reg1 <= hs_reg; \n  vs_reg <= vs; \n  blank_reg <= blank; \n end \n reg [1:0] cnt; \n wire sync_pulse = (hs_reg & !hs_reg1) ? 1 : 0; \n always @(posedge clk3) begin \n  if (sync_pulse) begin \n  cnt <= 2; \n  end \n  else begin \n  if (cnt == 2) \n  cnt <= 0; \n  else \n  cnt <= cnt+1; \n  end \n end \n reg [23:0] data_reg; \n always @(posedge clk3) begin \n  if (cnt == 2) \n  data_reg <= data; \n end \n always @(posedge clk3) begin \n  case ( cnt ) \n  0 : data3 <= data_reg[7:0]; \n  1 : data3 <= data_reg[15:8]; \n  default : data3 <= data_reg[23:16]; \n  endcase \n end \n assign blank3 = blank_reg; \n assign hs3 = hs_reg; \n assign vs3 = vs_reg; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a serializer-deserializer (SerDes) with configurable FIFO sizes for both transmit and receive paths. It supports flow control and includes debug outputs. The module instantiates submodules for transmit and receive paths, as well as for flow control handling. The debug outputs include various status and control signals from both transmit and receive paths, and they are constructed by concatenating and extracting specific bits from relevant signals within the module. Overall, this module provides the essential functionality for serializing and deserializing data streams with configurable FIFO sizes and flow control support.\n\n Module header:\n\nmodule serdes #(parameter TXFIFOSIZE = 9,parameter RXFIFOSIZE = 9) (input clk, input rst,output ser_tx_clk, output [15:0] ser_t, output ser_tklsb, output ser_tkmsb,input [31:0] rd_dat_i, input [3:0] rd_flags_i, output rd_ready_o, input rd_ready_i,input ser_rx_clk, input [15:0] ser_r, input ser_rklsb, input ser_rkmsb,output [31:0] wr_dat_o, output [3:0] wr_flags_o, output wr_ready_o, input wr_ready_i,output [15:0] tx_occupied, output tx_full, output tx_empty,output [15:0] rx_occupied, output rx_full, output rx_empty,output serdes_link_up,output [31:0] debug0,output [31:0] debug1);\n [/INST]\n", "output": "wire [15:0] fifo_space; \n  wire xon_rcvd, xoff_rcvd, inhibit_tx, send_xon, send_xoff, sent; \n  wire [31:0] debug_rx, debug_tx; \n serdes_tx #(.FIFOSIZE(TXFIFOSIZE)) serdes_tx (.clk(clk),.rst(rst),.ser_tx_clk(ser_tx_clk),.ser_t(ser_t),.ser_tklsb(ser_tklsb),.ser_tkmsb(ser_tkmsb),.rd_dat_i(rd_dat_i),.rd_flags_i(rd_flags_i),.rd_ready_o(rd_ready_o),.rd_ready_i(rd_ready_i),.inhibit_tx(inhibit_tx), .send_xon(send_xon), .send_xoff(send_xoff), .sent(sent),.fifo_occupied(tx_occupied),.fifo_full(tx_full),.fifo_empty(tx_empty),.debug(debug_tx) ); \n serdes_rx #(.FIFOSIZE(RXFIFOSIZE)) serdes_rx (.clk(clk),.rst(rst),.ser_rx_clk(ser_rx_clk),.ser_r(ser_r),.ser_rklsb(ser_rklsb),.ser_rkmsb(ser_rkmsb),.wr_dat_o(wr_dat_o),.wr_flags_o(wr_flags_o),.wr_ready_o(wr_ready_o),.wr_ready_i(wr_ready_i),.fifo_space(fifo_space), .xon_rcvd(xon_rcvd), .xoff_rcvd(xoff_rcvd),.fifo_occupied(rx_occupied),.fifo_full(rx_full),.fifo_empty(rx_empty),.serdes_link_up(serdes_link_up), .debug(debug_rx) ); \n  serdes_fc_tx serdes_fc_tx \n (.clk(clk),.rst(rst),.xon_rcvd(xon_rcvd),.xoff_rcvd(xoff_rcvd),.inhibit_tx(inhibit_tx) ); \n serdes_fc_rx #(.LWMARK(32),.HWMARK(128)) serdes_fc_rx (.clk(clk),.rst(rst),.fifo_space(fifo_space),.send_xon(send_xon),.send_xoff(send_xoff),.sent(sent) ); \n  assign debug0 = { { 2'b00, rd_ready_o, rd_ready_i, rd_flags_i[3:0]}, \n  { debug_tx[5:4] , inhibit_tx, send_xon, send_xoff, sent, ser_tkmsb, ser_tklsb}, \n  { ser_t[15:8] }, \n  { ser_t[7:0] } }; \n  assign debug1 = { { debug_rx[7:0] }, \n  { wr_flags_o[1:0], wr_ready_i, wr_ready_o, xon_rcvd, xoff_rcvd, ser_rkmsb, ser_rklsb }, \n  { ser_r[15:8] }, \n  { ser_r[7:0] } }; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements the functionality of the OR1200 processor freeze control logic. It has inputs for the clock signal, reset, and various control signals, and outputs signals to freeze different stages of the processor pipeline. The module uses registers and counters to handle the freeze conditions based on the input signals and generates output signals to freeze specific pipeline stages. It also has a multicycle counter to handle multicycle instructions and freeze the pipeline accordingly.\n\n Module header:\n\nmodule or1200_freeze(clk, rst,multicycle, flushpipe, extend_flush, lsu_stall, if_stall,lsu_unstall, du_stall, mac_stall,abort_ex,genpc_freeze, if_freeze, id_freeze, ex_freeze, wb_freeze,icpu_ack_i, icpu_err_i);\n [/INST]\n", "output": "input clk; \n input rst; \n input [`OR1200_MULTICYCLE_WIDTH-1:0] multicycle; \n input flushpipe; \n input extend_flush; \n input lsu_stall; \n input if_stall; \n input lsu_unstall; \n input abort_ex; \n input du_stall; \n input mac_stall; \n output genpc_freeze; \n output if_freeze; \n output id_freeze; \n output ex_freeze; \n output wb_freeze; \n input icpu_ack_i; \n input icpu_err_i; \n wire multicycle_freeze; \n reg [`OR1200_MULTICYCLE_WIDTH-1:0] multicycle_cnt; \n reg flushpipe_r; \n assign genpc_freeze = du_stall | flushpipe_r; \n assign if_freeze = id_freeze | extend_flush; \n assign id_freeze = (lsu_stall | (~lsu_unstall & if_stall) | multicycle_freeze ) | du_stall | mac_stall; \n assign ex_freeze = wb_freeze; \n assign wb_freeze = (lsu_stall | (~lsu_unstall & if_stall) | multicycle_freeze) | du_stall | mac_stall | abort_ex; \n always @(posedge clk or posedge rst) \n  if (rst) \n  flushpipe_r <= #1 1'b0; \n  else if (icpu_ack_i | icpu_err_i) \n  flushpipe_r <= #1 flushpipe; \n  else if (!flushpipe) \n  flushpipe_r <= #1 1'b0; \n assign multicycle_freeze = |multicycle_cnt; \n always @(posedge clk or posedge rst) \n  if (rst) \n  multicycle_cnt <= #1 2'b00; \n  else if (|multicycle_cnt) \n  multicycle_cnt <= #1 multicycle_cnt - 2'd1; \n  else if (|multicycle & !ex_freeze) \n  multicycle_cnt <= #1 multicycle; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module is an axis register with input and output signals for data transfer. It synchronizes the input data with the output data based on the clock signal and reset input. It also manages the ready signals for input and output data transfer. The module uses registers to store temporary and output data and performs logical OR operations to determine the input axis ready status. When the input axis is ready, it transfers data to the output axis, and if the output axis is ready, it transfers temporary data to the output axis.\n\n Module header:\n\nmodule axis_register_64 # (parameter DATA_WIDTH = 64,parameter KEEP_WIDTH = (DATA_WIDTH/8)) (input wire clk,input wire rst,input wire [DATA_WIDTH-1:0] input_axis_tdata,input wire [KEEP_WIDTH-1:0] input_axis_tkeep,input wire input_axis_tvalid,output wire input_axis_tready,input wire input_axis_tlast,input wire input_axis_tuser,output wire [DATA_WIDTH-1:0] output_axis_tdata,output wire [KEEP_WIDTH-1:0] output_axis_tkeep,output wire output_axis_tvalid,input wire output_axis_tready,output wire output_axis_tlast,output wire output_axis_tuser);\n [/INST]\n", "output": "reg input_axis_tready_reg = 0; \n reg [DATA_WIDTH-1:0] output_axis_tdata_reg = 0; \n reg [KEEP_WIDTH-1:0] output_axis_tkeep_reg = 0; \n reg output_axis_tvalid_reg = 0; \n reg output_axis_tlast_reg = 0; \n reg output_axis_tuser_reg = 0; \n reg [DATA_WIDTH-1:0] temp_axis_tdata_reg = 0; \n reg [KEEP_WIDTH-1:0] temp_axis_tkeep_reg = 0; \n reg temp_axis_tvalid_reg = 0; \n reg temp_axis_tlast_reg = 0; \n reg temp_axis_tuser_reg = 0; \n assign input_axis_tready = input_axis_tready_reg; \n assign output_axis_tdata = output_axis_tdata_reg; \n assign output_axis_tkeep = output_axis_tkeep_reg; \n assign output_axis_tvalid = output_axis_tvalid_reg; \n assign output_axis_tlast = output_axis_tlast_reg; \n assign output_axis_tuser = output_axis_tuser_reg; \n always @(posedge clk or posedge rst) begin \n  if (rst) begin \n  input_axis_tready_reg <= 0; \n  output_axis_tdata_reg <= 0; \n  output_axis_tkeep_reg <= 0; \n  output_axis_tvalid_reg <= 0; \n  output_axis_tlast_reg <= 0; \n  output_axis_tuser_reg <= 0; \n  temp_axis_tdata_reg <= 0; \n  temp_axis_tkeep_reg <= 0; \n  temp_axis_tvalid_reg <= 0; \n  temp_axis_tlast_reg <= 0; \n  temp_axis_tuser_reg <= 0; \n  end else begin \n  input_axis_tready_reg <= output_axis_tready | (~temp_axis_tvalid_reg & ~output_axis_tvalid_reg) | (~temp_axis_tvalid_reg & ~input_axis_tvalid); \n  if (input_axis_tready_reg) begin \n  if (output_axis_tready | ~output_axis_tvalid_reg) begin \n  output_axis_tdata_reg <= input_axis_tdata; \n  output_axis_tkeep_reg <= input_axis_tkeep; \n  output_axis_tvalid_reg <= input_axis_tvalid; \n  output_axis_tlast_reg <= input_axis_tlast; \n  output_axis_tuser_reg <= input_axis_tuser; \n  end else begin \n  temp_axis_tdata_reg <= input_axis_tdata; \n  temp_axis_tkeep_reg <= input_axis_tkeep; \n  temp_axis_tvalid_reg <= input_axis_tvalid; \n  temp_axis_tlast_reg <= input_axis_tlast; \n  temp_axis_tuser_reg <= input_axis_tuser; \n  end \n  end else if (output_axis_tready) begin \n  output_axis_tdata_reg <= temp_axis_tdata_reg; \n  output_axis_tkeep_reg <= temp_axis_tkeep_reg; \n  output_axis_tvalid_reg <= temp_axis_tvalid_reg; \n  output_axis_tlast_reg <= temp_axis_tlast_reg; \n  output_axis_tuser_reg <= temp_axis_tuser_reg; \n  temp_axis_tdata_reg <= 0; \n  temp_axis_tkeep_reg <= 0; \n  temp_axis_tvalid_reg <= 0; \n  temp_axis_tlast_reg <= 0; \n  temp_axis_tuser_reg <= 0; \n  end \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes two N-bit input numbers A and B and produces an (N+1)-bit output D, representing the result of the subtraction of A from B. It uses a binary adder with a carry input of 1 and complements the most significant bit of the output to obtain the subtraction result.\n\n Module header:\n\nmodule SUB_1 #(parameter N = 32)(input [N-1:0] A, B,output [N:0] D);\n [/INST]\n", "output": "wire CO; \n assign D[N] = ~CO; \n ADD \n #(.N(N)) \n ADD_ \n (.A(A),.B(~B),.CI(1'b1),.S(D[N-1:0]),.CO(CO)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe \"fetch\" module is a part of a processor design and manages the program counter and control signals for instruction fetching. It includes logic to increment the program counter, handle jumps, and enable or disable fetching based on the stall and busy signals. The module also handles branch and jump instructions, updating the program counter accordingly. The module outputs the program counter, access size, read/write flag, and enable flag for the instruction memory.\n\n Module header:\n\nmodule fetch (clk, stall, busy, pc, rw, access_size, enable, j_addr, jump, br_addr, branch);\n [/INST]\n", "output": "parameter START_ADDR = 32'h8002_0000; \n  input clk; \n  input stall; \n  input busy; \n  input [31:0] j_addr; \n  input jump; \n  input [31:0] br_addr; \n  input branch; \n  output [31:0] pc; \n  output [2:0] access_size; \n  output rw; \n  output enable; \n  reg [31:0] pc_reg = 32'h8001_FFFC; \n  reg [2:0] access_size_reg = 3'b000; \n  reg rw_reg = 1'b0; \n  reg enable_reg = 1'b1; \n  assign pc = pc_reg; \n  assign access_size = access_size_reg; \n  assign rw = rw_reg; \n  assign enable = enable_reg; \n  always @(posedge clk) \n  begin \n  if(stall != 1 & busy != 1) \n  begin \n  if(jump != 1 & branch != 1) \n  begin \n  pc_reg = pc_reg + 32'h0000_0004; \n  end \n  else if (branch == 1) \n  begin \n  pc_reg = br_addr; \n  end \n  else if(jump == 1) \n  begin \n  pc_reg = j_addr; \n  end \n  end \n  else if (branch == 1) \n  begin \n  pc_reg = br_addr; \n  end \n  else if(jump == 1) \n  begin \n  pc_reg = j_addr; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `data_gen_submodule` consists of a register `data_buf` and an always block that operates on the positive edge of the clock or the negative edge of the reset signal. \n\nThe `data_buf` is reset to 0 when the reset signal is asserted. It then increments by 1 if it is less than 511, or resets to 0 if it reaches 511.\n\nThe outputs `Data_A`, `Data_B`, `Data_C`, `Data_D`, `Data_E`, `Data_F`, `Data_G`, and `Data_H` are assigned the values of `data_buf` and subsequent increments.\n\n Module header:\n\nmodule data_gen_submodule (input clk ,input reset_n ,output [11:0] Data_A ,output [11:0] Data_B ,output [11:0] Data_C ,output [11:0] Data_D ,output [11:0] Data_E ,output [11:0] Data_F ,output [11:0] Data_G ,output [11:0] Data_H);\n [/INST]\n", "output": "reg [11:0] data_buf ; \n  always@(posedge clk or negedge reset_n ) \n  begin \n  if (!reset_n) \n  begin \n  data_buf <= 0 ; \n  end \n  else if (data_buf < 511) \n  data_buf <= data_buf + 1'b1 ; \n  else \n  data_buf <= 0 ; \n  end \n  assign Data_A = data_buf ; \n  assign Data_B = Data_A+1 ; \n  assign Data_C = Data_B+1 ; \n  assign Data_D = Data_C+1 ; \n  assign Data_E = data_buf ; \n  assign Data_F = Data_E+1 ; \n  assign Data_G = Data_F+1 ; \n  assign Data_H = Data_G+1 ; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes a 32-bit input \"dataa\" and outputs a 32-bit \"result.\" It uses a sub-module \"acl_fp_custom_clz\" to compute the count leading zero (CLZ) of the 27 least significant bits of the input. The sub-module calculates the CLZ and sets the output \"result\" with the 5-bit CLZ result and a flag \"all_zero.\" The \"result\" bits from 31 to 6 are set to zero.\n\n Module header:\n\nmodule acl_optimized_clz_27(dataa, result);\n [/INST]\n", "output": "input [31:0] dataa; \n  output [31:0] result; \n  wire all_zero; \n acl_fp_custom_clz myclz( .mantissa(dataa[26:0]),.result(result[4:0]),.all_zero(all_zero)); \n  assign result[5] = all_zero; \n  assign result[31:6] = 26'd0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a testbench for the sys_top module. It sets the clock and reset signals, and then instantiates the sys_top module. It also handles dumping trace files and variables for debugging purposes. The clock signal toggles every HCLK cycles and the reset signal is asserted for 10*PCLK cycles before being de-asserted.\n\n Module header:\n\nmodule tb_sys_top();\n [/INST]\n", "output": "localparam HCLK = 5; \n  localparam PCLK = 2*HCLK; \n  reg clk; \n  reg nrst; \n  always \n  #HCLK clk = !clk; \n  initial \n  begin \n  if(!$test$plusargs(\"NOTRACE\")) \n  begin \n  $dumpfile(`TRACE_FILE); \n  $dumpvars(0, tb_sys_top); \n  end \n  clk = 1; \n  nrst = 0; \n  #(10*PCLK) nrst = 1; \n  end \n sys_top sys(.clk(clk),.nrst(nrst)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a mock implementation of an AXI4Lite SRAM with read and write functionality. It consists of a memory array, write and read control signals, and logic to handle write and read operations. \n\nThe module captures write and read operations in response to clock signals and control inputs such as write valid, read valid, write strobe, and read ready. It handles write and read response delays using random values and updates the memory array accordingly. \n\nThe write operation is controlled by signals such as write active, write response delay, write strobe, write data, and write address. Similarly, the read operation is controlled by signals such as read active, read response delay, and read address.\n\nThe module also assigns ready, valid, and response signals based on the current state of write and read operations to ensure proper communication with external components.\n\n Module header:\n\nmodule MockAXI4LiteSRAM (input aclk,input aresetn,input awvalid,output logic awready,input [31:0] awaddr,input [2:0] awprot,input [3:0] awcache,input wvalid,output wready,input [31:0] wdata,input [3:0] wstrb,output logic bvalid,input bready,output [1:0] bresp,input arvalid,output logic arready,input [31:0] araddr,input [2:0] arprot,input [3:0] arcache,output logic rvalid,input rready,output [1:0] rresp,output logic [31:0] rdata);\n [/INST]\n", "output": "logic [31:0] mem [0:32767]; \n  logic write_active; \n  logic [3:0] write_resp_delay; \n  logic [3:0] write_strb; \n  logic [31:0] write_data; \n  logic [31:0] write_addr; \n  logic read_active; \n  logic [3:0] read_resp_delay; \n  logic [31:0] read_data; \n  logic [31:0] read_addr; \n  always @(posedge aclk) begin \n  if (awvalid && awready && wvalid && wready) begin \n  write_resp_delay <= $random; \n  end else if (write_active && write_resp_delay != 0) begin \n  write_resp_delay <= write_resp_delay - 1; \n  end \n  end \n  always @(posedge aclk) begin \n  if (!aresetn) begin \n  write_active <= 1'b0; \n  end else if (awvalid && awready && wvalid && wready) begin \n  write_active <= 1'b1; \n  end else if (bvalid && bready) begin \n  write_active <= 1'b0; \n  end \n  end \n  always @(posedge aclk) begin \n  if (awvalid && awready && wvalid && wready) begin \n  if (wstrb[0]) \n  mem[awaddr[31:2]][7:0] <= wdata[7:0]; \n  if (wstrb[1]) \n  mem[awaddr[31:2]][15:8] <= wdata[15:8]; \n  if (wstrb[2]) \n  mem[awaddr[31:2]][23:16] <= wdata[23:16]; \n  if (wstrb[3]) \n  mem[awaddr[31:2]][31:24] <= wdata[31:24]; \n  end \n  end \n  assign awready = !write_active || (bready && bvalid); \n  assign wready = !write_active || (bready && bvalid); \n  assign bvalid = write_active && write_resp_delay == 0; \n  assign bresp = 2'b0; \n  always @(posedge aclk) begin \n  if (arvalid && arready) begin \n  read_resp_delay <= $random; \n  end else if (read_active && read_resp_delay != 0) begin \n  read_resp_delay <= read_resp_delay - 1; \n  end \n  end \n  always @(posedge aclk) begin \n  if (!aresetn) begin \n  read_active <= 1'b0; \n  end else if (arvalid && arready) begin \n  read_active <= 1'b1; \n  read_addr <= araddr; \n  end else if (rvalid && rready) begin \n  read_active <= 1'b0; \n  end \n  end \n  always @(*) begin \n  rdata = mem[read_addr[31:2]]; \n  end \n  assign arready = !read_active || (rready && rvalid); \n  assign rvalid = read_active && read_resp_delay == 0; \n  assign rresp = 2'b0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements an interrupt capturer with configurable number of interrupts. It has a register to capture interrupts, and generates read data based on the address input and the interrupt register. The read data output has a wait state. It also handles cases where the number of interrupts is greater than 32. Additionally, it has reset functionality for the interrupt register and the read data with wait state.\n\n Module header:\n\nmodule intr_capturer #(parameter NUM_INTR = 32)(input clk,input rst_n,input [NUM_INTR-1:0] interrupt_in,input addr,input read,output [31:0] rddata);\n [/INST]\n", "output": "reg [NUM_INTR-1:0] interrupt_reg; \n  reg [31:0] readdata_with_waitstate; \n  wire [31:0] act_readdata; \n  wire [31:0] readdata_lower_intr; \n  wire [31:0] readdata_higher_intr; \n  wire access_lower_32; \n  wire access_higher_32; \n  always @(posedge clk or negedge rst_n) begin \n  if (!rst_n) interrupt_reg <= 'b0; \n  else interrupt_reg <= interrupt_in; \n  end \n  generate \n  if (NUM_INTR>32) begin : two_intr_reg_needed \n  assign readdata_lower_intr = interrupt_reg[31:0] & {(32){access_lower_32}}; \n  assign readdata_higher_intr = interrupt_reg[NUM_INTR-1:32] & {(NUM_INTR-32){access_higher_32}}; \n  end \n  else begin : only_1_reg \n  assign readdata_lower_intr = interrupt_reg & {(NUM_INTR){access_lower_32}}; \n  assign readdata_higher_intr = {32{1'b0}}; \n  end \n  endgenerate \n  assign access_lower_32 = read & (addr == 0); \n  assign access_higher_32 = read & (addr == 1); \n  assign act_readdata = readdata_lower_intr | readdata_higher_intr; \n  assign rddata = readdata_with_waitstate; \n  always @(posedge clk or negedge rst_n) begin \n  if (!rst_n) readdata_with_waitstate <= 32'b0; \n  else readdata_with_waitstate <= act_readdata; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a shift register with two stages, reg0 and reg1, that are updated based on the input signals and then shifted on the rising edge of the clock signal. The input signals are selected based on control inputs, and the outputs dt1, mul, ks, amsen, dt2, d1l, arate, rate1, rate2, tl, and rrate are updated accordingly. The shift register is implemented using two instances of the jt51_sh module, each with a different width and reset value. The reg0 and reg1 outputs are then assigned to the corresponding output wires.\n\n Module header:\n\nmodule jt51_csr_op(input rst,input clk,input cen,input [ 7:0] din,input up_dt1_op,input up_mul_op,input up_tl_op,input up_ks_op,input up_amsen_op,input up_dt2_op,input up_d1l_op,input up_ar_op,input up_d1r_op,input up_d2r_op,input up_rr_op,output [2:0] dt1,output [3:0] mul,output [6:0] tl,output [1:0] ks,output amsen,output [1:0] dt2,output [3:0] d1l,output [4:0] arate,output [4:0] rate1,output [4:0] rate2,output [3:0] rrate);\n [/INST]\n", "output": "wire [2:0] dt1_in = din[6:4]; \n wire [3:0] mul_in = din[3:0]; \n wire [6:0] tl_in = din[6:0]; \n wire [1:0] ks_in = din[7:6]; \n wire amsen_in= din[7]; \n wire [1:0] dt2_in = din[7:6]; \n wire [3:0] d1l_in = din[7:4]; \n wire [4:0] ar_in = din[4:0]; \n wire [4:0] d1r_in = din[4:0]; \n wire [4:0] d2r_in = din[4:0]; \n wire [3:0] rr_in = din[3:0]; \n wire [30:0] reg0_in = { \n  up_dt1_op ? dt1_in : dt1, \n  up_mul_op ? mul_in : mul, \n  up_ks_op ? ks_in : ks, \n  up_amsen_op ? amsen_in : amsen, \n  up_dt2_op ? dt2_in : dt2, \n  up_d1l_op ? d1l_in : d1l, \n  up_ar_op ? ar_in : arate, \n  up_d1r_op ? d1r_in : rate1, \n  up_d2r_op ? d2r_in : rate2 }; \n wire [10:0] reg1_in = { \n  up_tl_op ? tl_in : tl, \n  up_rr_op ? rr_in : rrate }; \n wire [30:0] reg0_out; \n wire [10:0] reg1_out; \n assign { dt1, mul, ks, amsen, dt2, d1l, arate, rate1, rate2, tl, rrate } \n  = {reg0_out, reg1_out}; \n jt51_sh #( .width(31), .stages(32)) u_reg0op(.rst ( rst ),.clk ( clk ),.cen ( cen ),.din ( reg0_in ),.drop ( reg0_out )); \n jt51_sh #( .width(11), .stages(32), .rstval(1'b1)) u_reg1op(.rst ( rst ),.clk ( clk ),.cen ( cen ),.din ( reg1_in ),.drop ( reg1_out )); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module implements a XORshift pseudo-random number generator. It takes a 128-bit seed as input and generates a 32-bit pseudo-random number as output. The module has internal registers for state storage and uses combinational and sequential logic to update the state and generate the output. The state update is performed on every clock cycle, and the seed can be initialized or modified using the reset signal. The module uses bit-wise XOR and bit shifting operations to generate the pseudo-random output.\n\n Module header:\n\nmodule xorshift(input clk,input rst,input [127:0] seed,output [31:0] out);\n [/INST]\n", "output": "reg [31:0] x_q, y_q, z_q, w_q, x_d, y_d, z_d, w_d; \n assign out = w_q; \n always @(*) begin \n  x_d = y_q; \n  y_d = z_q; \n  z_d = w_q; \n  w_d = w_q ^ (w_q >> 19) ^ (x_q ^ (x_q << 11)) ^ ((x_q ^ (x_q << 11)) >> 8); \n end \n always @(posedge clk) begin \n  if (x_q == 0 && y_q == 0 && z_q == 0 && w_q == 0) begin \n  x_q <= 32'h8de97cc5; \n  y_q <= 32'h6144a7eb; \n  z_q <= 32'h653f6dee; \n  w_q <= 32'h8b49b282; \n  end else if (rst) begin \n  x_q <= seed[127:96]; \n  y_q <= seed[95:64]; \n  z_q <= seed[63:32]; \n  w_q <= seed[31:0]; \n  end else begin \n  x_q <= x_d; \n  y_q <= y_d; \n  z_q <= z_d; \n  w_q <= w_d; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a translation layer that facilitates communication between two different interfaces. It uses pipelines for input and output processing and includes logic to handle data ready, valid, and last signals. The module also includes components for data conversion, mask generation, and offset manipulation to facilitate the exchange of data between the two interfaces. The module includes multiple stages for input and output processing and handles clock and reset signals to ensure proper data transmission.\n\n Module header:\n\nmodule txc_translation_layer #(parameter C_PCI_DATA_WIDTH = 10'd128,parameter C_PIPELINE_INPUT = 1,parameter C_PIPELINE_OUTPUT = 0) (input CLK,input RST_IN,output TXC_PKT_READY,input [C_PCI_DATA_WIDTH-1:0] TXC_PKT,input TXC_PKT_VALID,input TXC_PKT_START_FLAG,input [clog2s(C_PCI_DATA_WIDTH/32)-1:0] TXC_PKT_START_OFFSET,input TXC_PKT_END_FLAG,input [clog2s(C_PCI_DATA_WIDTH/32)-1:0] TXC_PKT_END_OFFSET,input S_AXIS_CC_TREADY,output S_AXIS_CC_TVALID,output S_AXIS_CC_TLAST,output [C_PCI_DATA_WIDTH-1:0] S_AXIS_CC_TDATA,output [(C_PCI_DATA_WIDTH/32)-1:0] S_AXIS_CC_TKEEP,output [`SIG_CC_TUSER_W-1:0] S_AXIS_CC_TUSER);\n [/INST]\n", "output": "localparam C_INPUT_STAGES = C_PIPELINE_INPUT != 0? 1:0; \n  localparam C_OUTPUT_STAGES = C_PIPELINE_OUTPUT != 0? 1:0; \n  wire wTxcPktReady; \n  wire [C_PCI_DATA_WIDTH-1:0] wTxcPkt; \n  wire wTxcPktValid; \n  wire wTxcPktStartFlag; \n  wire [clog2s(C_PCI_DATA_WIDTH/32)-1:0] wTxcPktStartOffset; \n  wire wTxcPktEndFlag; \n  wire [clog2s(C_PCI_DATA_WIDTH/32)-1:0] wTxcPktEndOffset; \n  wire wSAxisCcTReady; \n  wire wSAxisCcTValid; \n  wire wSAxisCcTLast; \n  wire [C_PCI_DATA_WIDTH-1:0] wSAxisCcTData; \n  wire [(C_PCI_DATA_WIDTH/32)-1:0] wSAxisCcTKeep; \n  wire [`SIG_CC_TUSER_W-1:0] wSAxisCcTUser; \n  assign wTxcPktReady = wSAxisCcTReady; \n  assign wSAxisCcTValid = wTxcPktValid; \n  assign wSAxisCcTLast = wTxcPktEndFlag; \n  assign wSAxisCcTData = wTxcPkt; \n  assign S_AXIS_CC_TUSER = `SIG_CC_TUSER_W'd0; \n  pipeline \n #(.C_DEPTH (C_INPUT_STAGES),.C_WIDTH (C_PCI_DATA_WIDTH + 2*(1+clog2s(C_PCI_DATA_WIDTH/32))),.C_USE_MEMORY (0)) \n  input_inst \n (.WR_DATA_READY (TXC_PKT_READY),.RD_DATA ({wTxcPkt,wTxcPktStartFlag,wTxcPktStartOffset,wTxcPktEndFlag,wTxcPktEndOffset}),.RD_DATA_VALID (wTxcPktValid),.WR_DATA ({TXC_PKT,TXC_PKT_START_FLAG,TXC_PKT_START_OFFSET,TXC_PKT_END_FLAG,TXC_PKT_END_OFFSET}),.WR_DATA_VALID (TXC_PKT_VALID),.RD_DATA_READY (wTxcPktReady),.CLK (CLK),.RST_IN (RST_IN)); \n  offset_to_mask \n #(.C_MASK_SWAP (0),.C_MASK_WIDTH (C_PCI_DATA_WIDTH/32)) \n  otom_inst \n (.MASK (wSAxisCcTKeep),.OFFSET_ENABLE (wTxcPktEndFlag),.OFFSET (wTxcPktEndOffset)); \n  pipeline \n #(.C_DEPTH (C_OUTPUT_STAGES),.C_WIDTH (C_PCI_DATA_WIDTH + 1 + (C_PCI_DATA_WIDTH/32)),.C_USE_MEMORY (0)) \n  output_inst \n (.WR_DATA_READY (wSAxisCcTReady),.RD_DATA ({S_AXIS_CC_TDATA,S_AXIS_CC_TLAST,S_AXIS_CC_TKEEP}),.RD_DATA_VALID (S_AXIS_CC_TVALID),.WR_DATA ({wSAxisCcTData,wSAxisCcTLast,wSAxisCcTKeep}),.WR_DATA_VALID (wSAxisCcTValid),.RD_DATA_READY (S_AXIS_CC_TREADY),.CLK (CLK),.RST_IN (RST_IN)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements an RC filter with hysteresis. The filter has a counter of width FILT_WIDTH, and a hysteresis bit position HYST_BIT. The output bit bitOut is controlled by the inputs clk, rst, en, and bitIn. The counter is incremented on the positive edge of the clock and reset to 0 on a reset signal. The bitOut is set to 1 when the enable signal is high, and it is set to 0 when the enable signal is low and certain conditions involving the counter and bitIn are met. The counter is incremented or decremented based on the enable and bitIn signals.\n\n Module header:\n\nmodule RCFilter #(parameter FILT_WIDTH = 8,parameter HYST_BIT = 5) (input clk,input rst,input en,input bitIn,output reg bitOut);\n [/INST]\n", "output": "reg [FILT_WIDTH-1:0] counter; \n initial begin \n  counter <= 'd0; \n  bitOut <= 1'b0; \n end \n always @(posedge clk) begin \n  if (rst) begin \n  counter <= 'd0; \n  bitOut <= 1'b0; \n  end \n  else if (en) begin \n  bitOut <= bitOut ? (|counter[FILT_WIDTH-1:HYST_BIT]) \n  : (&counter[FILT_WIDTH-1:HYST_BIT]); \n  if (~&counter && bitIn) begin \n  counter <= counter + 2'd1; \n  end \n  else if (|counter && ~bitIn) begin \n  counter <= counter - 2'd1; \n  end \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module outputs the status flag \"out\" based on the input signals, and utilizes sub-modules and registers to generate the output. It includes multiple instantiations of other modules and registers, as well as wire connections for the inputs and outputs. The \"ram_empty_fb_i\" and \"ram_empty_i\" signals are also used in the assignment of the output.\n\n Module header:\n\nmodule fifo_bt_txd_rd_status_flags_as (out,v1_reg,v1_reg_0,rd_clk,\\ngwrdrst.grst.g7serrst.rd_rst_reg_reg[2] ,rd_en,\\gpregsm1.curr_fwft_state_reg[1] );\n [/INST]\n", "output": "output out; \n  input [4:0]v1_reg; \n  input [4:0]v1_reg_0; \n  input rd_clk; \n  input [0:0]\\ngwrdrst.grst.g7serrst.rd_rst_reg_reg[2] ; \n  input rd_en; \n  input [1:0]\\gpregsm1.curr_fwft_state_reg[1] ; \n  wire c0_n_0; \n  wire comp1; \n  wire [1:0]\\gpregsm1.curr_fwft_state_reg[1] ; \n  wire [0:0]\\ngwrdrst.grst.g7serrst.rd_rst_reg_reg[2] ; \n  (* DONT_TOUCH *) wire ram_empty_fb_i; \n  (* DONT_TOUCH *) wire ram_empty_i; \n  wire rd_clk; \n  wire rd_en; \n  wire [4:0]v1_reg; \n  wire [4:0]v1_reg_0; \n  assign out = ram_empty_fb_i; \n  fifo_bt_txd_compare_4 c0 \n (.comp1(comp1),.\\gpregsm1.curr_fwft_state_reg[1] (\\gpregsm1.curr_fwft_state_reg[1] ),.out(ram_empty_fb_i),.ram_empty_fb_i_reg(c0_n_0),.rd_en(rd_en),.v1_reg(v1_reg)); \n  fifo_bt_txd_compare_5 c1 \n (.comp1(comp1),.v1_reg_0(v1_reg_0)); \n  (* DONT_TOUCH *) \n  (* KEEP = \"yes\" *) \n  (* equivalent_register_removal = \"no\" *) \n FDPE #(.INIT(1'b1)) \n  ram_empty_fb_i_reg \n (.C(rd_clk),.CE(1'b1),.D(c0_n_0),.PRE(\\ngwrdrst.grst.g7serrst.rd_rst_reg_reg[2] ),.Q(ram_empty_fb_i)); \n  (* DONT_TOUCH *) \n  (* KEEP = \"yes\" *) \n  (* equivalent_register_removal = \"no\" *) \n FDPE #(.INIT(1'b1)) \n  ram_empty_i_reg \n (.C(rd_clk),.CE(1'b1),.D(c0_n_0),.PRE(\\ngwrdrst.grst.g7serrst.rd_rst_reg_reg[2] ),.Q(ram_empty_i)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module acl_fp_sitofp_double_altpriority_encoder_bv7 takes an 8-bit input data and outputs a 3-bit q. It instantiates two sub-modules, acl_fp_sitofp_double_altpriority_encoder_6v7 and acl_fp_sitofp_double_altpriority_encoder_6e8, to encode the lower 4 bits and upper 4 bits of the input data, respectively. It then combines the outputs of the sub-modules using bitwise operations and assigns the result to the output q.\n\n Module header:\n\nmodule acl_fp_sitofp_double_altpriority_encoder_bv7 (data,q) ;\n [/INST]\n", "output": "input [7:0] data; \n  output [2:0] q; \n  wire [1:0] wire_altpriority_encoder10_q; \n  wire [1:0] wire_altpriority_encoder11_q; \n  wire wire_altpriority_encoder11_zero; \n  acl_fp_sitofp_double_altpriority_encoder_6v7 altpriority_encoder10 \n (.data(data[3:0]),.q(wire_altpriority_encoder10_q)); \n  acl_fp_sitofp_double_altpriority_encoder_6e8 altpriority_encoder11 \n (.data(data[7:4]),.q(wire_altpriority_encoder11_q),.zero(wire_altpriority_encoder11_zero)); \n  assign \n  q = {(~ wire_altpriority_encoder11_zero), (({2{wire_altpriority_encoder11_zero}} & wire_altpriority_encoder10_q) | ({2{(~ wire_altpriority_encoder11_zero)}} & wire_altpriority_encoder11_q))}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a clock generator for the YM2612 sound chip. It controls the clock speed based on the input signals `real_speed` and `uart_speed`. The module contains two counters, `cambio0` and `cambio1`, which determine the clock speed. It also generates the `ym_pm` and `pm_counter` outputs based on the clock signals. The `rst_counter` and `irq_n` inputs are used to reset the counters and the `pm_counter` is incremented based on certain conditions. The module adjusts the clock speed and manages the output signals based on the given inputs and internal counters.\n\n Module header:\n\nmodule pm_clk_real(input clk,input rst,input real_speed,input rst_counter,input irq_n,input uart_speed,output reg ym_pm,output reg [31:0] pm_counter);\n [/INST]\n", "output": "parameter stop=5'd07; \n reg [4:0] div_cnt, cambio0, cambio1; \n always @(posedge clk or posedge rst) begin : speed_mux \n  if( rst ) begin \n  cambio0 <= 5'd2; \n  cambio1 <= 5'd4; \n  end \n  else begin \n  if( real_speed ) begin \n  cambio0 <= 5'd2; \n  cambio1 <= 5'd4; \n  end \n  else begin \n  if( uart_speed ) begin \n  cambio0 <= 5'd4; \n  cambio1 <= 5'd8; \n  end else begin \n  cambio0 <= 5'd7; \n  cambio1 <= 5'd15; \n  end \n  end \n  end \n end \n always @(posedge clk or posedge rst) begin : ym_pm_ff \n  if( rst ) begin \n  div_cnt <= 5'd0; \n  ym_pm <= 1'b0; \n  end \n  else begin \n  if(div_cnt>=cambio1) begin \n  ym_pm <= 1'b1; \n  div_cnt <= 5'd0; \n  end \n  else begin \n  if( div_cnt==cambio0 ) ym_pm <= 1'b0; \n  div_cnt <= div_cnt + 1'b1; \n  end \n  end \n end \n reg ultpm; \n always @(posedge clk or posedge rst) begin : pm_counter_ff \n  if( rst ) begin \n  pm_counter <= 32'd0; \n  ultpm <= 1'b0; \n  end \n  else begin \n  ultpm <= ym_pm; \n  if(rst_counter) \n  pm_counter <= 32'd0; \n  else \n  if( irq_n && ym_pm && !ultpm ) \n  pm_counter <= pm_counter + 1'd1; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module serves as a multiplexer (MUX) with 64-bit input and 16-bit output. It selects and outputs the input address, write enable, and size based on the control signals. The output values are simply routed from the corresponding input signals.\n\n Module header:\n\nmodule MuxN_1(input [63:0] io_ins_0_addr,input io_ins_0_isWr,input [15:0] io_ins_0_size,output [63:0] io_out_addr,output io_out_isWr,output [15:0] io_out_size);\n [/INST]\n", "output": "assign io_out_addr = io_ins_0_addr; \n  assign io_out_isWr = io_ins_0_isWr; \n  assign io_out_size = io_ins_0_size; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module takes in two 2-bit inputs 'a' and 'b', and outputs the result of the logical comparison 'a == (b arithmetic right shift 1)'. The 'b' input is sign-extended before performing the arithmetic right shift operation. The result is assigned to the output 'y'.\n\n Module header:\n\nmodule test08(a, b, y);\n [/INST]\n", "output": "input [1:0] a; \n  input [1:0] b; \n  output y; \n  assign y = a == ($signed(b) >>> 1); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module `cpci_heartbeat` generates a heartbeat signal based on the input clock `clk`. It uses a counter `ten_hertz_count` to generate a 10Hz signal `ten_hertz`. The `slow_count` is used to control the heartbeat signal by toggling it between 1 and 0 at different count values. The heartbeat signal is then assigned to `heartbeat_nxt` and updated at the positive edge of the clock. The module provides a consistent and controlled heartbeat signal for monitoring the system's health.\n\n Module header:\n\nmodule cpci_heartbeat (output reg heartbeat,input reset,input clk);\n [/INST]\n", "output": "parameter MAX_COUNT = 6250000; \n  reg [23:0] ten_hertz_count; \n  always @(posedge clk) \n  if (reset) ten_hertz_count <= 'h0; \n  else \n  if (ten_hertz_count == MAX_COUNT) ten_hertz_count <= 'h0; \n  else ten_hertz_count <= ten_hertz_count + 24'h1; \n  reg ten_hertz; \n  always @(posedge clk) \n  if (reset) ten_hertz <= 'h0; \n  else ten_hertz <= (ten_hertz_count == MAX_COUNT) ? 1 : 0; \n  reg [4:0] slow_count; \n  always @(posedge clk) \n  if (reset) slow_count <= 'h0; \n  else if (ten_hertz) begin \n  if (slow_count == 20) slow_count <= 'h0; \n  else slow_count <= slow_count + 'h1; \n  end \n  reg heartbeat_nxt; \n  always @* begin \n  heartbeat_nxt = 1; \n  if (slow_count == 'd0 ) heartbeat_nxt = 0; \n  if (slow_count == 'd2 ) heartbeat_nxt = 0; \n  if (slow_count == 'd10) heartbeat_nxt = 0; \n  if (slow_count == 'd12) heartbeat_nxt = 0; \n  end \n  always @(posedge clk) heartbeat <= heartbeat_nxt; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is for an SD card input/output interface. It includes various registers for configuration, received and transmitted data, and counters for bit and byte transmission. The module operates on clock signals for data transmission and includes logic for handling read and write operations, configuration settings, and clock synchronization. The module handles the shift of transmitted data, counts the number of bits and bytes, and manages the prescaler for clock signals. The module also checks for data readiness and updates the internal state accordingly. Additionally, it implements the necessary logic for handling the MOSI and MSCK signals.\n\n Module header:\n\nmodule sdcardio (input wire clk,input wire rst,input wire [2:0] AD,input wire [7:0] DI,output reg [7:0] DO,input wire rw,input wire cs,input wire clk_in,output wire mosi,output reg msck,input wire miso);\n [/INST]\n", "output": "reg [7:0] spics_reg; \n  reg [7:0] config_reg; \n  reg [7:0] rx_data; \n  reg [7:0] tx_data; \n  reg [7:0] prescaler; \n  reg start; \n  reg [7:0] shifted_tx_data; \n  reg [3:0] bit_counter; \n  reg [7:0] scale_counter; \n  wire data_ready = ((bit_counter == 0) && (!msck))?1'b1:1'b0; \n  always @ (posedge clk) begin \n  if (rst) begin \n  config_reg <= 8'b00000001; \n  tx_data <= 8'b11111111; \n  prescaler <= 0; \n  start <= 0; \n  end else begin \n  if (cs) begin \n  if (rw) begin \n  case (AD[2:0]) \n  3'b000: DO <= {data_ready, 3'b0, config_reg[3:0]}; \n  3'b001: begin \n  DO <= rx_data; \n  end \n  3'b010: DO <= prescaler; \n  3'b011: DO <= spics_reg; \n  endcase \n  end else begin \n  case (AD[2:0]) \n  3'b000: config_reg <= DI; \n  3'b001: begin \n  tx_data <= DI; \n  start <= 1'b1; \n  end \n  3'b010: prescaler <= DI; \n  3'b011: spics_reg <= DI; \n  endcase \n  end \n  end else begin \n  if (!data_ready) start <= 1'b0; \n  end \n  end \n  end \n  assign mosi = ((bit_counter == 0) && (!msck))?1'b1:shifted_tx_data[7]; \n  always @ (posedge clk_in) begin \n  if (rst) begin \n  msck <= 0; \n  rx_data <= 8'b11111111; \n  scale_counter <= 0; \n  end else if (start) begin \n  shifted_tx_data <= tx_data; \n  bit_counter <= 8; \n  end else begin \n  if (bit_counter != 0) begin \n  if (scale_counter == prescaler) begin \n  scale_counter <= 0; \n  msck <= ~msck; \n  if (msck) begin \n  shifted_tx_data <= {shifted_tx_data[6:0], 1'b1}; \n  rx_data <= {rx_data[6:0], miso}; \n  bit_counter <= bit_counter - 1'b1; \n  end \n  end else scale_counter <= scale_counter + 1'b1; \n  end else msck <= 0; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module implements a cascaded integrator-comb (CIC) filter with interpolation functionality. The input signal is extended to accommodate the bit growth caused by integration, and is processed through N integrator and differentiator stages. The integrated and differentiated signals are then processed through a pipeline to account for the multi-stage nature of the filter. The final output is obtained through an integer shifter to adjust for the interpolation rate. The overall CIC filter operation is synchronized with the clock signal and controlled by reset and enable signals, while the input and output are buffered to ensure proper functionality.\n\n Module header:\n\nmodule cic_interp #(parameter bw = 16, parameter N = 4, parameter log2_of_max_rate = 7) (input clock,input reset,input enable,input [7:0] rate,input strobe_in,input strobe_out,input [bw-1:0] signal_in,output reg [bw-1:0] signal_out);\n [/INST]\n", "output": "integer i; \n  localparam maxbitgain = (N-1)*log2_of_max_rate; \n  wire [bw+maxbitgain-1:0] signal_in_ext; \n  reg [bw+maxbitgain-1:0] integrator [0:N-1]; \n  reg [bw+maxbitgain-1:0] differentiator [0:N-1]; \n  reg [bw+maxbitgain-1:0] pipeline [0:N-1]; \n  sign_extend #(bw,bw+maxbitgain) \n  ext_input (.in(signal_in),.out(signal_in_ext)); \n  always @(posedge clock) \n  if(reset | ~enable) \n  for(i=0;i<N;i=i+1) \n  integrator[i] <= 0; \n  else if (enable & strobe_out) \n  begin \n  if(strobe_in) \n  integrator[0] <= integrator[0] + pipeline[N-1]; \n  for(i=1;i<N;i=i+1) \n  integrator[i] <= integrator[i] + integrator[i-1]; \n  end \n  always @(posedge clock) \n  if(reset | ~enable) \n  begin \n  for(i=0;i<N;i=i+1) \n  begin \n  differentiator[i] <= 0; \n  pipeline[i] <= 0; \n  end \n  end \n  else if (enable && strobe_in) \n  begin \n  differentiator[0] <= signal_in_ext; \n  pipeline[0] <= signal_in_ext - differentiator[0]; \n  for(i=1;i<N;i=i+1) \n  begin \n  differentiator[i] <= pipeline[i-1]; \n  pipeline[i] <= pipeline[i-1] - differentiator[i]; \n  end \n  end \n  wire [bw-1:0] signal_out_unreg; \n  cic_int_shifter #(bw) \n  cic_int_shifter(rate,integrator[N-1],signal_out_unreg); \n  always @(posedge clock) \n  signal_out <= signal_out_unreg; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a datapath that processes input signals and generates output signals based on various control inputs and internal state. It includes registers to hold the head flit, address high, and address low values. The module has logic to control the selection of flits based on the selection counter and destination select signals. It also has counters for the number of flits and inverted counts. The module uses the clock signal to synchronize the processing of the input signals and generation of the output signals.\n\n Module header:\n\nmodule upload_datapath(clk,rst,clr_max,clr_inv_ids,clr_sel_cnt_inv,clr_sel_cnt,inc_sel_cnt,inc_sel_cnt_inv,en_flit_max_in,en_for_reg,en_inv_ids,inv_ids_in,dest_sel,flit_max_in,head_flit,addrhi,addrlo,flit_out,cnt_eq_max,cnt_invs_eq_3,cnt_eq_0,inv_ids_reg_out,sel_cnt_invs_out);\n [/INST]\n", "output": "input clk; \n  input rst; \n  input [15:0] head_flit; \n  input [15:0] addrhi; \n  input [15:0] addrlo; \n  input clr_max; \n  input clr_inv_ids; \n  input clr_sel_cnt_inv; \n  input clr_sel_cnt; \n  input inc_sel_cnt; \n  input inc_sel_cnt_inv; \n  input en_for_reg; \n  input en_inv_ids; \n  input [3:0] inv_ids_in; \n  input [3:0] flit_max_in; \n  input en_flit_max_in; \n  input dest_sel; \n  output [15:0] flit_out; \n  output cnt_eq_max; \n  output cnt_invs_eq_3; \n  output cnt_eq_0; \n  output [3:0] inv_ids_reg_out; \n  output [1:0] sel_cnt_invs_out; \n reg [3:0] flits_max; \n always@(posedge clk) \n begin \n  if(rst||clr_max) \n  flits_max<=4'b0000; \n  else if(en_flit_max_in) \n  flits_max<=flit_max_in; \n end \n reg [3:0] inv_ids_reg; \n always@(posedge clk) \n begin \n  if(rst||clr_inv_ids) \n  inv_ids_reg<=4'b0000; \n  else if(en_inv_ids) \n  inv_ids_reg<=inv_ids_in; \n end \n wire [3:0] inv_ids_reg_out; \n assign inv_ids_reg_out=inv_ids_reg; \n reg [3:0] sel_cnt; \n always@(posedge clk) \n begin \n  if(rst||clr_sel_cnt) \n  sel_cnt<=4'b0000; \n  else if(inc_sel_cnt) \n  sel_cnt<=sel_cnt+4'b0001; \n end \n reg [1:0] sel_cnt_invs; \n always@(posedge clk) \n begin \n  if(rst||clr_sel_cnt_inv) \n  sel_cnt_invs<=2'b00; \n  else if(inc_sel_cnt_inv) \n  sel_cnt_invs<=sel_cnt_invs+2'b01; \n end \n wire [1:0] sel_cnt_invs_out; \n assign sel_cnt_invs_out=sel_cnt_invs; \n wire cnt_eq_0; \n assign cnt_eq_0=(sel_cnt==4'b0000); \n wire cnt_eq_max; \n assign cnt_eq_max=(sel_cnt==flits_max); \n wire cnt_invs_eq_3; \n assign cnt_invs_eq_3=(sel_cnt_invs==2'b11); \n  reg [15:0] head_flit_reg; \n  reg [15:0] addrhi_reg; \n  reg [15:0] addrlo_reg; \n  always@(posedge clk) \n  begin \n  if(rst) \n  begin \n  head_flit_reg<=16'h0000; \n  addrhi_reg<=16'h0000; \n  addrlo_reg<=16'h0000; \n  end \n  else if(en_for_reg) \n  begin \n  head_flit_reg<=head_flit; \n  addrhi_reg<=addrhi; \n  addrlo_reg<=addrlo; \n  end \n end \n wire [1:0] dest_seled_id; \n assign dest_seled_id=dest_sel?head_flit_reg[15:14]:sel_cnt_invs; \n reg [15:0] flit_seled_out; \n always@(*) \n begin \n  case(sel_cnt) \n  4'b0000:flit_seled_out={dest_seled_id,head_flit_reg[13:0]}; \n  4'b0001:flit_seled_out=addrhi_reg; \n  4'b0010:flit_seled_out=addrlo_reg; \n  default:flit_seled_out=head_flit_reg; \n  endcase \n end \n assign flit_out=flit_seled_out; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a 7-segment display decoder that takes a 4-bit input value and a display polarity input. It then outputs an 8-bit signal representing the segments to be lit up on the 7-segment display. The module uses a case statement to select the appropriate segments based on the input value and sets the display polarity accordingly. If the input value does not match any specific case, it sets all segments to be turned off.\n\n Module header:\n\nmodule seven_segment_decoder(value, dp, segments);\n [/INST]\n", "output": "input [3:0] value; \n  input dp; \n  output reg [7:0] segments; \n  always @(value, dp) begin \n  case (value) \n  4'h1 : segments = 7'b1001111; \n  4'h2 : segments = 7'b0010010; \n  4'h3 : segments = 7'b0000110; \n  4'h4 : segments = 7'b1001100; \n  4'h5 : segments = 7'b0100100; \n  4'h6 : segments = 7'b0100000; \n  4'h7 : segments = 7'b0001111; \n  4'h8 : segments = 7'b0000000; \n  4'h9 : segments = 7'b0000100; \n  4'hA : segments = 7'b0001000; \n  4'hB : segments = 7'b1100000; \n  4'hC : segments = 7'b0110001; \n  4'hD : segments = 7'b1000010; \n  4'hE : segments = 7'b0110000; \n  4'hF : segments = 7'b0111000; \n  4'h0 : segments = 7'b0000001; \n  default : segments = 7'b1111111; \n  endcase \n  segments[7] = ~dp; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is designed to implement a register-based state machine. It has multiple input and output ports for data transfer and manipulation. The module includes logic to reset the output registers when a reset signal is detected. It also updates the output registers based on the input values when the clock signal is received, while considering the hold input for certain registers. This module appears to be part of a larger digital design, likely for a processor or similar complex system.\n\n Module header:\n\nmodule ID_EX(input clk,input reset,input [1:0] WB_in,input [1:0] M_in,input [3:0] EX_in,input [31:0] RDdata1_in,input [31:0] RDdata2_in,input [31:0] sign_extended_in,input [4:0] Inst_25_to_21_in,input [4:0] Inst_20_to_16_in,input [4:0] Inst_15_to_11_in,input [5:0] Inst_5_to_0_in,input [31:0] pc_plus4_in,input hold_i,output reg[1:0] WB_out,output reg[1:0] M_out,output reg ALUSrc_out,output reg [1:0] ALUOp_out,output reg RegDst_out,output reg[31:0] RDdata1_out,output reg[31:0] RDdata2_out,output reg[31:0] sign_extended_out,output reg[4:0] Inst_25_to_21_out,output reg[4:0] Inst_20_to_16_out,output reg[4:0] Inst_15_to_11_out,output reg[5:0] Inst_5_to_0_out);\n [/INST]\n", "output": "always@(posedge reset)begin \n  WB_out = 0; \n  M_out = 0; \n  ALUSrc_out = 0; \n  ALUOp_out = 0; \n  RegDst_out = 0; \n  RDdata1_out = 0; \n  RDdata2_out = 0; \n  sign_extended_out = 0; \n  Inst_15_to_11_out = 0; \n  Inst_20_to_16_out = 0; \n  Inst_25_to_21_out = 0; \n  Inst_5_to_0_out = 0; \n  end \n  always@(posedge clk)begin \n  if(hold_i) begin \n  WB_out <= WB_out; \n  M_out <= M_out; \n  ALUSrc_out <= ALUSrc_out; \n  ALUOp_out <= ALUOp_out; \n  RegDst_out <= RegDst_out; \n  RDdata1_out <= RDdata1_out; \n  RDdata2_out <= RDdata2_out; \n  sign_extended_out <= sign_extended_out; \n  Inst_15_to_11_out <= Inst_15_to_11_out; \n  Inst_20_to_16_out <= Inst_20_to_16_out; \n  Inst_25_to_21_out <= Inst_25_to_21_out; \n  Inst_5_to_0_out <= Inst_5_to_0_out; \n  end \n  else begin \n  WB_out <= WB_in; \n  M_out <= M_in; \n  ALUSrc_out <= EX_in[0]; \n  ALUOp_out <= EX_in[2:1]; \n  RegDst_out <= EX_in[3]; \n  RDdata1_out <= RDdata1_in; \n  RDdata2_out <= RDdata2_in; \n  sign_extended_out <= sign_extended_in; \n  Inst_15_to_11_out <= Inst_15_to_11_in; \n  Inst_20_to_16_out <= Inst_20_to_16_in; \n  Inst_25_to_21_out <= Inst_25_to_21_in; \n  Inst_5_to_0_out <= Inst_5_to_0_in; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes a 16-bit binary input and outputs a 7-segment display representation of the input in hexadecimal. It uses a case statement to assign the appropriate 7-bit values to the SSD output based on the input BIN. For each binary input value from 0 to 15, the module outputs the corresponding 7-segment display configuration for the hexadecimal equivalent.\n\n Module header:\n\nmodule hex_ssd (BIN, SSD);\n [/INST]\n", "output": "input [15:0] BIN; \n  output reg [0:6] SSD; \n  always begin \n  case(BIN) \n  0:SSD=7'b0000001; \n  1:SSD=7'b1001111; \n  2:SSD=7'b0010010; \n  3:SSD=7'b0000110; \n  4:SSD=7'b1001100; \n  5:SSD=7'b0100100; \n  6:SSD=7'b0100000; \n  7:SSD=7'b0001111; \n  8:SSD=7'b0000000; \n  9:SSD=7'b0001100; \n  10:SSD=7'b0001000; \n  11:SSD=7'b1100000; \n  12:SSD=7'b0110001; \n  13:SSD=7'b1000010; \n  14:SSD=7'b0110000; \n  15:SSD=7'b0111000; \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is for the DE1_SoC and is used to control LEDs and read/write data from/to a memory. It has inputs such as CLOCK_50, LEDR, SW, and KEY. The module uses a clock signal and has multiple internal signals and registers for data storage and control. It also interfaces with a memory module called SRAM2Kby16 and a register file module called registerFile. The module's behavior is determined by the state and control signals from the SW input. The LEDR output is controlled based on the state, and data is read from and written to the memory based on the state and control signals. The module also has logic for generating clock signals for different operations.\n\n Module header:\n\nmodule DE1_SoC (CLOCK_50, LEDR, SW, KEY);\n [/INST]\n", "output": "input CLOCK_50; \n  output reg [9:0] LEDR; \n  input [9:0] SW; \n  input [3:0] KEY; \n  wire clk; \n  wire [15:0] data; \n  reg [6:0] hold; \n  reg WrEn, regWR; \n  reg [10:0] adx; \n  reg [15:0] store; \n  wire [1:0] state, blockSel; \n  wire clkControl, rst, slowClk, outSel; \n  reg [4:0] readAdd0, readAdd1, writeAdd; \n  reg [31:0] writeData; \n  wire [31:0] readOutput0, readOutput1; \n  assign clkControl = SW[8]; \n  assign state = SW[7:6]; \n  assign blockSel = SW[5:4]; \n  assign outSel = SW[3]; \n  assign rst = SW[9]; \n  assign data = WrEn ? 16'bZ : store; \n  SRAM2Kby16 memory(clk, adx, WrEn, data); \n  clkSlower counter(slowClk, CLOCK_50, rst); \n  registerFile regs(clk, readAdd0, readAdd1, writeAdd, regWR, writeData, readOutput0, readOutput1); \n  always @(posedge clk) begin \n  if(rst) begin \n  hold = 0; \n  adx = 0; \n  WrEn = 1; \n  LEDR = 0; \n  end else if(state == 0) begin \n  WrEn = 0; \n  adx = hold; \n  store = 7'b1111111 - hold; \n  LEDR[6:0] = hold; \n  end else if(state == 1) begin \n  WrEn = 1; \n  regWR = 1; \n  writeAdd = hold[4:0]; \n  adx = blockSel * 32 + hold[4:0]; \n  writeData[15:0] = data; \n  end else if(state == 2) begin \n  WrEn = 1; \n  regWR = 0; \n  readAdd0 = hold[3:0]; \n  readAdd1 = 16 + hold[3:0]; \n  LEDR = outSel ? readOutput0[9:0] : readOutput1[9:0]; \n  end else if(state == 3) begin \n  WrEn = 0; \n  regWR = 0; \n  if(blockSel[0]) begin \n  readAdd1 = hold[5:2] + 16; \n  if(hold[0]) begin \n  store = readOutput1[15:0]; \n  adx = 179 + hold[5:2]; \n  end else begin \n  store = readOutput1[15:0]; \n  adx = 145 + hold[5:2]; \n  end \n  end else begin \n  readAdd0 = hold[5:2]; \n  if(hold[0]) begin \n  store = readOutput0[15:0]; \n  adx = 162 + hold[5:2]; \n  end else begin \n  store = readOutput0[15:0]; \n  adx = 128 + hold[5:2]; \n  end \n  end \n  end \n  hold = hold + 1'b1; \n  end \n  assign clk = clkControl ? slowClk : CLOCK_50; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a high-level description of a system that interfaces a Gigabit Ethernet Media Independent Interface (GMII) to a Small Form-factor Pluggable (SFP) module. It includes clock inputs and outputs, data inputs and outputs, as well as control signals for various operations. The module also instantiates submodules to handle specific functionalities, such as CRC generation, transmit FIFO operations, and GMII interface handling.\n\nThe module connects the SFP module to the GMII interface, manages clock signals, handles data validity and packet transmission, and includes status indicators such as link status and activity indication. It also manages error detection and LED indicators. The module represents a high-level view of the connectivity and data flow between the SFP module and the GMII interface, with the inclusion of necessary control and status signals for the operation of the entire system.\n\n Module header:\n\nmodule sfp_rx_tx_1000(clk,sfp_clk,reset,gmii_rx_clk,gmii_tx_clk,sfp_rxp,sfp_txp,l_link_sfp,r_act_sfp,crc_data_valid,crc_data,pkt_usedw,pkt_valid_wrreq,pkt_valid,crc_gen_to_txfifo_wrreq,crc_gen_to_txfifo_data,txfifo_data_usedw,pkt_output_valid_wrreq,pkt_output_valid,port_receive,port_discard,port_send,port_pream);\n [/INST]\n", "output": "input clk; \n  input sfp_clk; \n  input reset; \n  output gmii_rx_clk; \n  output gmii_tx_clk; \n  input sfp_rxp; \n  output sfp_txp; \n  output l_link_sfp; \n  output r_act_sfp; \n  output crc_data_valid; \n  output [138:0] crc_data; \n  input [7:0]pkt_usedw; \n  output pkt_valid_wrreq; \n  output pkt_valid; \n  input crc_gen_to_txfifo_wrreq; \n  input [138:0]crc_gen_to_txfifo_data; \n  output [7:0]txfifo_data_usedw; \n  input pkt_output_valid_wrreq; \n  input pkt_output_valid; \n  output port_receive; \n  output port_discard; \n  output port_send; \n  output port_pream; \n  wire [7:0]gmii_txd; \n  wire gmii_txen; \n  wire gmii_txer; \n  wire [7:0]gmii_rxd; \n  wire gmii_rxen; \n  wire gmii_rxer; \n  wire gmii_rx_clk; \n  wire gmii_tx_clk; \n  wire crc_data_valid; \n  wire [138:0] crc_data; \n  wire pkt_valid_wrreq; \n  wire pkt_valid; \n  wire [7:0]txfifo_data_usedw; \n  wire port_receive; \n  wire port_discard; \n  wire port_send; \n  wire port_pream; \n gmii_139_1000 gmii_139(.clk(gmii_rx_clk),.reset(reset),.gmii_rxd(gmii_rxd),.gmii_rxdv(gmii_rxen),.gmii_rxer(gmii_rxer),.crc_data_valid(crc_data_valid),.crc_data(crc_data),.pkt_usedw(pkt_usedw),.pkt_valid_wrreq(pkt_valid_wrreq),.pkt_valid(pkt_valid),.port_receive(port_receive),.port_discard(port_discard),.port_pream(port_pream)); \n tx139_gmii_1000 tx139_gmii(.clk(clk),.reset(reset),.gmii_txclk(gmii_tx_clk),.crc_gen_to_txfifo_wrreq(crc_gen_to_txfifo_wrreq),.crc_gen_to_txfifo_data(crc_gen_to_txfifo_data),.pkt_output_valid_wrreq(pkt_output_valid_wrreq),.pkt_output_valid(pkt_output_valid),.gmii_txd(gmii_txd),.gmii_txen(gmii_txen),.gmii_txer(gmii_txer),.txfifo_data_usedw(txfifo_data_usedw),.port_send(port_send)); \n  wire l_link_sfp0; \n  wire l_link_sfp; \n  assign l_link_sfp = ~l_link_sfp0; \n sfp2gmii sfp2gmii(.gmii_rx_d(gmii_rxd),.gmii_rx_dv(gmii_rxen),.gmii_rx_err(gmii_rxer),.tx_clk(gmii_tx_clk),.rx_clk(gmii_rx_clk),.readdata(),.waitrequest(),.txp(sfp_txp),.reconfig_fromgxb(),.led_an(),.led_disp_err(),.led_char_err(),.led_link(l_link_sfp0),.gmii_tx_d(gmii_txd),.gmii_tx_en(gmii_txen),.gmii_tx_err(gmii_txer),.reset_tx_clk(~reset),.reset_rx_clk(~reset),.address(5'b0),.read(1'b0),.writedata(16'b0),.write(1'b0),.clk(clk),.reset(~reset),.rxp(sfp_rxp),.ref_clk(sfp_clk),.reconfig_clk(1'b0),.reconfig_togxb(3'b010),.gxb_cal_blk_clk(sfp_clk)); \n act_led act_led(.clk(clk),.reset(reset),.gmii_rxen(gmii_rxen),.gmii_txen(gmii_txen),.r_act_sfp(r_act_sfp)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a clock divider that takes an input clock signal and outputs two divided clock signals. It uses a counter to divide the input clock frequency and produces two divided clock outputs. The counter is incremented on each rising edge of the input clock, and the divided clock outputs are the individual bits of the counter. The module also includes a reset signal to initialize the counter. When the reset signal is low, the counter is set to 0. When the reset signal is high, the counter increments and produces the divided clock signals.\n\n Module header:\n\nmodule clk_div_module(src_clk ,div_rst_n ,div_clk_0 ,div_clk_1);\n [/INST]\n", "output": "input src_clk ; \n  input div_rst_n ; \n  output div_clk_0 ; \n  output div_clk_1 ; \n  reg [01:00] clk_div_cnt ; \n  always @(posedge src_clk or negedge div_rst_n) begin : DIV_CNT_ADD \n  if(!div_rst_n) \n  begin \n  `ifndef SYNTHESIS \n  $display(\"The initial value of clk div count is 0.\"); \n  `endif \n  clk_div_cnt <= 'd0; \n  end \n  else \n  begin \n  clk_div_cnt <= clk_div_cnt + 1'b1; \n  end \n  end \n  assign div_clk_0 = clk_div_cnt[0]; \n  assign div_clk_1 = clk_div_cnt[1]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a matrix input SRAM with a depth of 256 and a data width of 8. It includes input ports for data, valid signal, clock, write enable, read enable, reset, and output ports for data, full flag, and empty flag. The module updates a valid register on the positive edge of the clock. It generates a row FIFO by instantiating 256 instances of a 256x8 FIFO module and connects them based on the index value. The module uses the valid signal to control the read enable input for the FIFO instances. Additionally, it includes a reset input for clearing the FIFO.\n\n Module header:\n\nmodule MatrixInput_sram #(parameter DEPTH = 256, ADDRESS_WIDTH =8, WIDTH = 8) ( Data_in, Data_out, valid, CLK, WEN, REN, RESET, Full_out, Empty_out);\n [/INST]\n", "output": "input wire [WIDTH-1:0] Data_in [DEPTH-1:0]; \n output wire [WIDTH-1:0] Data_out [DEPTH-1:0]; \n output wire [DEPTH-1:0] Full_out; \n output wire [DEPTH-1:0] Empty_out; \n input wire valid; \n input wire CLK; \n input wire REN; \n input wire WEN; \n input wire RESET; \n reg [DEPTH-1:0] valid_reg; \n always @(posedge CLK) begin \n  valid_reg [DEPTH-1:0] <= {valid,valid_reg[DEPTH-1:1]}; \n end \n genvar i; \n generate \n  for (i=DEPTH-1; i >=0; i=i-1) begin : ROWFIFO \n  if (i==DEPTH-1) begin : check \n  aFifo_256x8 #(.DATA_WIDTH(WIDTH),.ADDRESS_WIDTH(ADDRESS_WIDTH)) U \n (.Data_out(Data_out[i]),.Empty_out(Empty_out[i]),.ReadEn_in(valid),.RClk(CLK),.Data_in(Data_in[i]),.Full_out(Full_out[i]),.WriteEn_in(WEN),.WClk(CLK),.Clear_in(RESET)); \n  end else begin : NonZero \n  aFifo_256x8 #(.DATA_WIDTH(WIDTH),.ADDRESS_WIDTH(ADDRESS_WIDTH)) U \n (.Data_out(Data_out[i]),.Empty_out(Empty_out[i]),.ReadEn_in(valid_reg[i+1]),.RClk(CLK),.Data_in(Data_in[i]),.Full_out(Full_out[i]),.WriteEn_in(WEN),.WClk(CLK),.Clear_in(RESET)); \n  end \n  end \n endgenerate \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module, \"cliffordwolf_nonexclusive_select,\" selects an output based on the inputs x, y, z. If x is asserted, it assigns the output o to b. If y is asserted, it assigns o to c. If z is asserted, it assigns o to d. If none of x, y, or z are asserted, it assigns o to a. The output o is a registered output.\n\n Module header:\n\nmodule cliffordwolf_nonexclusive_select (input wire x, y, z,input wire a, b, c, d,output reg o);\n [/INST]\n", "output": "always @* begin \n  o = a; \n  if (x) o = b; \n  if (y) o = c; \n  if (z) o = d; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, named SISO_TBV, simulates a Serial-In-Serial-Out (SISO) shift register. It includes a clock signal (clk), a reset signal (rst), a Serial In buffer, a Serial Out wire, and a test vector (SerialInTV). The logic inside the module processes the input and clock signals to shift the data through the shift register, updating the SerialOut accordingly. The module also includes initial and always blocks for setting up stimuli and printing data, respectively. Overall, the module is designed to demonstrate the behavior of a SISO shift register in response to input stimuli and clock signals.\n\n Module header:\n\nmodule SISO_TBV ();\n [/INST]\n", "output": "reg clk = 0; \n reg rst = 0; \n wire SerialOut; \n wire [19:0] SerialInTV; \n reg SerialIn = 0; \n reg [3:0] SISO0_0_Buffer = 0; \n assign SerialInTV = 20'd989338; \n always @(rst, SerialOut, SerialIn, clk) begin: SISO_TBV_PRINT_DATA \n  $write(\"%h\", SerialIn); \n  $write(\" \"); \n  $write(\"%h\", SerialOut); \n  $write(\" \"); \n  $write(\"%h\", clk); \n  $write(\" \"); \n  $write(\"%h\", rst); \n  $write(\"\\n\"); \n end \n always @(posedge clk, negedge rst) begin: SISO_TBV_SISO0_0_LOGIC \n  if (rst) begin \n  SISO0_0_Buffer <= 0; \n  end \n  else begin \n  SISO0_0_Buffer <= {SISO0_0_Buffer[(4 - 1)-1:0], SerialIn}; \n  end \n end \n assign SerialOut = SISO0_0_Buffer[(4 - 1)]; \n initial begin: SISO_TBV_CLK_SIGNAL \n  while (1'b1) begin \n  clk <= (!clk); \n  # 1; \n  end \n end \n initial begin: SISO_TBV_STIMULES \n  integer i; \n  for (i=0; i<20; i=i+1) begin \n  SerialIn <= SerialInTV[i]; \n  @(posedge clk); \n  end \n  for (i=0; i<2; i=i+1) begin \n  if ((i == 0)) begin \n  SerialIn <= 0; \n  rst <= 1; \n  end \n  else begin \n  rst <= 0; \n  end \n  @(posedge clk); \n  end \n  for (i=0; i<(4 + 1); i=i+1) begin \n  SerialIn <= 1; \n  @(posedge clk); \n  end \n  $finish; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a DDR3 PHY cycle shifter. It takes in a data stream and shifts it based on a 2-bit control input. The data is stored in a register that can be initialized post-reset as high or low. The module then slices the input data into two parts and rearranges them based on the shift control, outputting the shifted data.\n\n Module header:\n\nmodule altera_mem_if_ddr3_phy_0001_fr_cycle_shifter(clk,reset_n,shift_by,datain,dataout);\n [/INST]\n", "output": "parameter DATA_WIDTH = \"\"; \n parameter REG_POST_RESET_HIGH = \"false\"; \n localparam RATE_MULT = 2; \n localparam FULL_DATA_WIDTH = DATA_WIDTH*RATE_MULT; \n input clk; \n input reset_n; \n input [1:0] shift_by; \n input [FULL_DATA_WIDTH-1:0] datain; \n output [FULL_DATA_WIDTH-1:0] dataout; \n reg [FULL_DATA_WIDTH-1:0] datain_r; \n always @(posedge clk or negedge reset_n) \n begin \n  if (~reset_n) begin \n  if (REG_POST_RESET_HIGH == \"true\") \n  datain_r <= {FULL_DATA_WIDTH{1'b1}}; \n  else \n  datain_r <= {FULL_DATA_WIDTH{1'b0}}; \n  end else begin \n  datain_r <= datain; \n  end \n end \n wire [DATA_WIDTH-1:0] datain_t0 = datain[(DATA_WIDTH*1)-1:(DATA_WIDTH*0)]; \n wire [DATA_WIDTH-1:0] datain_t1 = datain[(DATA_WIDTH*2)-1:(DATA_WIDTH*1)]; \n wire [DATA_WIDTH-1:0] datain_r_t1 = datain_r[(DATA_WIDTH*2)-1:(DATA_WIDTH*1)]; \n assign dataout = (shift_by[0] == 1'b1) ? {datain_t0, datain_r_t1} : {datain_t1, datain_t0}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements an alternative priority encoder for a 8-bit input data, which is then split into two 4-bit segments. The module uses two instances of a 4-bit priority encoder (altpriority_encoder19 and altpriority_encoder20) to encode each segment. It combines the output of these encoders using logical operations to produce a 3-bit output q. The first bit of q is determined by the zero flag from altpriority_encoder20, while the remaining two bits are generated based on the output of both encoders.\n\n Module header:\n\nmodule acl_fp_sitofp_altpriority_encoder_bv7 (data,q) ;\n [/INST]\n", "output": "input [7:0] data; \n  output [2:0] q; \n  wire [1:0] wire_altpriority_encoder19_q; \n  wire [1:0] wire_altpriority_encoder20_q; \n  wire wire_altpriority_encoder20_zero; \n  acl_fp_sitofp_altpriority_encoder_6v7 altpriority_encoder19 \n (.data(data[3:0]),.q(wire_altpriority_encoder19_q)); \n  acl_fp_sitofp_altpriority_encoder_6e8 altpriority_encoder20 \n (.data(data[7:4]),.q(wire_altpriority_encoder20_q),.zero(wire_altpriority_encoder20_zero)); \n  assign \n  q = {(~ wire_altpriority_encoder20_zero), (({2{wire_altpriority_encoder20_zero}} & wire_altpriority_encoder19_q) | ({2{(~ wire_altpriority_encoder20_zero)}} & wire_altpriority_encoder20_q))}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, named eth_crc_120, takes a 120-bit input data_in and a 32-bit crc_state as inputs, and produces a 32-bit crc_next output. It applies a CRC iteration function called crc_iteration using the input data_in and crc_state to calculate the next CRC value, which is then assigned to the crc_next output.\n\n Module header:\n\nmodule eth_crc_120 (input wire [119:0] data_in,input wire [31:0] crc_state,output wire [31:0] crc_next);\n [/INST]\n", "output": "assign crc_next = crc_iteration( 120, crc_state, { 8'h0, data_in} ); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module represents an output buffer for Low Voltage Differential Signaling (LVDS). It provides various parameters for different I/O standards, termination methods, pull-up/pull-down configurations, and slew rates. The module's functionality involves driving the output signals O and OB based on the input signal I and a control signal T, while considering different I/O standards and pull-up/pull-down configurations. If T is low, O will be driven with I, and OB will be driven with the complement of I; otherwise, both outputs will be in a high-impedance state.\n\n Module header:\n\nmodule OBUFTDS_M_VPR (input I,input T,output O,output OB);\n [/INST]\n", "output": "parameter [0:0] LVCMOS12_LVCMOS15_LVCMOS18_LVCMOS25_LVCMOS33_LVTTL_SSTL135_SSTL15_SLEW_SLOW = 1'b0; \n  parameter [0:0] LVCMOS12_LVCMOS15_LVCMOS18_SSTL135_SSTL15_STEPDOWN = 1'b0; \n  parameter [0:0] LVCMOS15_SSTL15_DRIVE_I16_I_FIXED = 1'b0; \n  parameter [0:0] LVDS_25_DRIVE_I_FIXED = 1'b0; \n  parameter [0:0] LVDS_25_OUT = 1'b0; \n  parameter [0:0] SSTL135_DRIVE_I_FIXED = 1'b0; \n  parameter [0:0] SSTL135_SSTL15_SLEW_FAST = 1'b0; \n  parameter [0:0] TMDS_33_DRIVE_I_FIXED = 1'b0; \n  parameter [0:0] TMDS_33_OUT = 1'b0; \n  parameter [0:0] IN_TERM_UNTUNED_SPLIT_40 = 1'b0; \n  parameter [0:0] IN_TERM_UNTUNED_SPLIT_50 = 1'b0; \n  parameter [0:0] IN_TERM_UNTUNED_SPLIT_60 = 1'b0; \n  parameter [0:0] PULLTYPE_PULLUP = 1'b0; \n  parameter [0:0] PULLTYPE_PULLDOWN = 1'b0; \n  parameter [0:0] PULLTYPE_NONE = 1'b0; \n  parameter [0:0] PULLTYPE_KEEPER = 1'b0; \n  parameter PULLTYPE = \"\"; \n  parameter IOSTANDARD = \"\"; \n  parameter SLEW = \"\"; \n  assign O = (T == 1'b0) ? I : 1'bz; \n  assign OB = (T == 1'b0) ? !I : 1'bz; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a test bench for a synchronous RAM interface. It includes logic for write and read cycles, enabling and disabling reads, address generation, and data verification. The write and read counters increment with each cycle, and the module alternates between write and read cycles. It also includes a pipeline stage for data correctness checking, and uses external modules for RAM control, input/output, and signal capture for debugging.\n\n Module header:\n\nmodule test_sram_if (input clk,input rst,input [`WIDTH-1:0] RAM_D_pi,output [`WIDTH-1:0] RAM_D_po,output RAM_D_poe,output [`DEPTH-1:0] RAM_A,output RAM_WEn,output RAM_CENn,output RAM_LDn,output RAM_OEn,output RAM_CE1n,output reg correct);\n [/INST]\n", "output": "reg [`DEPTH-1:0] write_count; \n  reg [`DEPTH-1:0] read_count; \n  reg enable; \n  reg write; \n  reg write_cycle; \n  reg read_cycle; \n  reg enable_reads; \n  reg [18:0] address; \n  reg [17:0] data_out; \n  wire [17:0] data_in; \n  wire data_in_valid; \n  reg [17:0] check_data; \n  reg [17:0] check_data_old; \n  reg [17:0] check_data_old2; \n  always @(posedge clk) \n  if (rst) \n  begin \n  write_count <= 19'h0; \n  read_count <= 19'h0; \n  end \n  else if (write_cycle) \n  if (write_count == 19'h7FFFF) \n  begin \n  write_count <= 19'h0; \n  end \n  else \n  begin \n  write_count <= write_count + 1'b1; \n  end \n  else if (read_cycle) \n  if (read_count == 19'h7FFFF) \n  begin \n  read_count <= 19'h0; \n  end \n  else \n  begin \n  read_count <= read_count + 1'b1; \n  end \n  always @(posedge clk) \n  if (rst) \n  begin \n  enable_reads <= 0; \n  read_cycle <= 0; \n  write_cycle <= 0; \n  end \n  else \n  begin \n  write_cycle <= ~write_cycle; \n  if (enable_reads) \n  read_cycle <= write_cycle; \n  if (write_count == 15) \n  enable_reads <= 1; \n  end \n  always @(posedge clk) \n  if (rst) \n  begin \n  enable <= 0; \n  end \n  else if (write_cycle) \n  begin \n  address <= write_count; \n  data_out <= write_count[17:0]; \n  enable <= 1; \n  write <= 1; \n  end \n  else if (read_cycle) \n  begin \n  address <= read_count; \n  check_data <= read_count[17:0]; \n  check_data_old <= check_data; \n  check_data_old2 <= check_data_old; \n  enable <= 1; \n  write <= 0; \n  end \n  else \n  enable <= 0; \n  always @(posedge clk) \n  if (data_in_valid) \n  begin \n  correct <= (data_in == check_data_old2); \n  end \n  nobl_if nobl_if_i1 \n (.clk(clk),.rst(rst),.RAM_D_pi(RAM_D_pi),.RAM_D_po(RAM_D_po),.RAM_D_poe(RAM_D_poe),.RAM_A(RAM_A),.RAM_WEn(RAM_WEn),.RAM_CENn(RAM_CENn),.RAM_LDn(RAM_LDn),.RAM_OEn(RAM_OEn),.RAM_CE1n(RAM_CE1n),.address(address),.data_out(data_out),.data_in(data_in),.data_in_valid(data_in_valid),.write(write),.enable(enable)); \n  wire [35:0] CONTROL0; \n  reg [7:0] data_in_reg, data_out_reg, address_reg; \n  reg data_in_valid_reg,write_reg,enable_reg,correct_reg; \n  always @(posedge clk) \n  begin \n  data_in_reg <= data_in[7:0]; \n  data_out_reg <= data_out[7:0]; \n  data_in_valid_reg <= data_in_valid; \n  write_reg <= write; \n  enable_reg <= enable; \n  correct_reg <= correct; \n  address_reg <= address; \n  end \n  icon icon_i1 \n (.CONTROL0(CONTROL0)); \n  ila ila_i1 \n (.CLK(clk),.CONTROL(CONTROL0),.TRIG0(data_in_reg[7:0]),.TRIG1(data_out_reg[7:0]),.TRIG2(address_reg[7:0]),.TRIG3({data_in_valid_reg,write_reg,enable_reg,correct_reg})); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a test bench for the \"figuras_Gato\" module. It initializes the video display, user input, X and Y coordinates, and RGB output. It also simulates the increment of the X coordinate pixel position by repeatedly adding 1, with a delay of 10 time units between each increment. This test bench is used to verify the functionality of the \"figuras_Gato\" module by observing its behavior with different inputs.\n\n Module header:\n\nmodule figuras_test;\n [/INST]\n", "output": "reg video_mostrar; \n  reg [3:0] entrada; \n  reg [9:0] pixel_x; \n  reg [9:0] pixel_y; \n  wire [2:0] salida_rgb; \n figuras_Gato uut (.video_mostrar(video_mostrar),.entrada(entrada),.pixel_x(pixel_x),.pixel_y(pixel_y),.salida_rgb(salida_rgb)); \n  initial begin \n  video_mostrar = 1; \n  entrada = 0; \n  pixel_x = 9'd160; \n  pixel_y = 9'd120; \n  #10; \n  end \n  always @ (*) begin \n  #10 \n  pixel_x= pixel_x+1; \n  #10 \n  pixel_x= pixel_x+1; \n  #10 \n  pixel_x= pixel_x+1; \n  #10 \n  pixel_x= pixel_x+1; \n  #10 \n  pixel_x= pixel_x+1; \n  #10 \n  pixel_x= pixel_x+1; \n  #10 \n  pixel_x= pixel_x+1; \n  #10 \n  pixel_x= pixel_x+1; \n  #10 \n  pixel_x= pixel_x+1; \n  #10 \n  pixel_x= pixel_x+1; \n  #10 \n  pixel_x= pixel_x+1; \n  #10 \n  pixel_x= pixel_x+1; \n  #10 \n  pixel_x= pixel_x+1; \n  #10 \n  pixel_x= pixel_x+1; \n  #10 \n  pixel_x= pixel_x+1; \n  #10 \n  pixel_x= pixel_x+1; \n  #10 \n  pixel_x= pixel_x+1; \n  #10 \n  pixel_x= pixel_x+1; \n  #10 \n  pixel_x= pixel_x+1; \n  #10 \n  pixel_x= pixel_x+1; \n  #10 \n  pixel_x= pixel_x+1; \n  #10 \n  pixel_x= pixel_x+1; \n  #10 \n  pixel_x= pixel_x+1; \n  #10 \n  pixel_x= pixel_x+1; \n  #10 \n  pixel_x= pixel_x+1; \n  #10 \n  pixel_x= pixel_x+1; \n  #10 \n  pixel_x= pixel_x+1; \n  #10 \n  pixel_x= pixel_x+1; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a clock divider circuit that divides the input clock by 2 based on the clock type and reset signals. It uses registers to store the clock output and the divided clock signal. The clock_div2 signal is updated on every positive edge of the input clock, and the reset signal is synchronized using a 3-stage register. The output clock_out is assigned based on the clock type and the synchronized reset signal, ensuring proper clock division and synchronization.\n\n Module header:\n\nmodule dcm_adv_clock_divide_by_2 (clock, clock_type, clock_out, rst);\n [/INST]\n", "output": "input clock; \n input clock_type; \n input rst; \n output clock_out; \n reg clock_out; \n reg clock_div2; \n reg [2:0] rst_reg; \n wire clk_src; \n initial begin \n  clock_out = 1'b0; \n  clock_div2 = 1'b0; \n end \n always @(posedge clock) \n  clock_div2 <= ~clock_div2; \n always @(posedge clock) begin \n  rst_reg[0] <= rst; \n  rst_reg[1] <= rst_reg[0] & rst; \n  rst_reg[2] <= rst_reg[1] & rst_reg[0] & rst; \n end \n assign clk_src = (clock_type) ? clock_div2 : clock; \n always @(clk_src or rst or rst_reg) \n  if (rst == 1'b0) \n  clock_out = clk_src; \n  else if (rst == 1'b1) begin \n  clock_out = 1'b0; \n  @(negedge rst_reg[2]); \n  if (clk_src == 1'b1) \n  @(negedge clk_src); \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a synchronous reset flip-flop (FDSE) implemented using Xilinx legacy primitive FDS. The module takes clock signal LMB_Clk, system reset SYS_Rst, and provides LMB_Rst as output. It also involves various input and output signals for address, data, read/write strobes, and other control signals for memory interfaces. The module performs signal assignments to connect these input and output signals to the corresponding internal signals and ports.\n\n Module header:\n\nmodule system_dlmb_v10_0_lmb_v10 (LMB_Clk,SYS_Rst,LMB_Rst,M_ABus,M_ReadStrobe,M_WriteStrobe,M_AddrStrobe,M_DBus,M_BE,Sl_DBus,Sl_Ready,Sl_Wait,Sl_UE,Sl_CE,LMB_ABus,LMB_ReadStrobe,LMB_WriteStrobe,LMB_AddrStrobe,LMB_ReadDBus,LMB_WriteDBus,LMB_Ready,LMB_Wait,LMB_UE,LMB_CE,LMB_BE);\n [/INST]\n", "output": "input LMB_Clk; \n  input SYS_Rst; \n  output LMB_Rst; \n  input [0:31]M_ABus; \n  input M_ReadStrobe; \n  input M_WriteStrobe; \n  input M_AddrStrobe; \n  input [0:31]M_DBus; \n  input [0:3]M_BE; \n  input [0:31]Sl_DBus; \n  input [0:0]Sl_Ready; \n  input [0:0]Sl_Wait; \n  input [0:0]Sl_UE; \n  input [0:0]Sl_CE; \n  output [0:31]LMB_ABus; \n  output LMB_ReadStrobe; \n  output LMB_WriteStrobe; \n  output LMB_AddrStrobe; \n  output [0:31]LMB_ReadDBus; \n  output [0:31]LMB_WriteDBus; \n  output LMB_Ready; \n  output LMB_Wait; \n  output LMB_UE; \n  output LMB_CE; \n  output [0:3]LMB_BE; \n  wire LMB_Clk; \n  wire LMB_Rst; \n  wire [0:31]M_ABus; \n  wire M_AddrStrobe; \n  wire [0:3]M_BE; \n  wire [0:31]M_DBus; \n  wire M_ReadStrobe; \n  wire M_WriteStrobe; \n  wire SYS_Rst; \n  wire [0:0]Sl_CE; \n  wire [0:31]Sl_DBus; \n  wire [0:0]Sl_Ready; \n  wire [0:0]Sl_UE; \n  wire [0:0]Sl_Wait; \n  assign LMB_ABus[0:31] = M_ABus; \n  assign LMB_AddrStrobe = M_AddrStrobe; \n  assign LMB_BE[0:3] = M_BE; \n  assign LMB_CE = Sl_CE; \n  assign LMB_ReadDBus[0:31] = Sl_DBus; \n  assign LMB_ReadStrobe = M_ReadStrobe; \n  assign LMB_Ready = Sl_Ready; \n  assign LMB_UE = Sl_UE; \n  assign LMB_Wait = Sl_Wait; \n  assign LMB_WriteDBus[0:31] = M_DBus; \n  assign LMB_WriteStrobe = M_WriteStrobe; \n  (* BOX_TYPE = \"PRIMITIVE\" *) \n  (* XILINX_LEGACY_PRIM = \"FDS\" *) \n FDSE #(.INIT(1'b1)) \n  POR_FF_I \n (.C(LMB_Clk),.CE(1'b1),.D(1'b0),.Q(LMB_Rst),.S(SYS_Rst)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a memory RAM with configurable data width, depth, and address width. It has separate clocks for read and write operations, and supports reading and writing data based on the read and write enable signals. The module uses a 2D array 'ram' to store data, and the read and write operations are synchronized to the respective clocks. When a write operation is enabled for a specific address and data, the module updates the corresponding memory location in the RAM.\n\n Module header:\n\nmodule oh_memory_ram # (parameter DW = 104,parameter DEPTH = 32,parameter AW = $clog2(DEPTH)) (input rd_clk,input rd_en,input [AW-1:0] rd_addr,output reg [DW-1:0] rd_dout,input wr_clk,input wr_en,input [AW-1:0] wr_addr,input [DW-1:0] wr_wem,input [DW-1:0] wr_din);\n [/INST]\n", "output": "reg [DW-1:0] ram [DEPTH-1:0]; \n  integer i; \n  always @ (posedge rd_clk) \n  if(rd_en) \n  rd_dout[DW-1:0] <= ram[rd_addr[AW-1:0]]; \n  always @(posedge wr_clk) \n  for (i=0;i<DW;i=i+1) \n  if (wr_en & wr_wem[i]) \n  ram[wr_addr[AW-1:0]][i] <= wr_din[i]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a driver for the DHT11 sensor. It uses a state machine to handle the communication protocol with the sensor. It keeps track of clock cycles and data bits, and generates the output temperature and humidity values based on the data received from the sensor. The module also controls the direction of data transfer and handles the start signal for initiating communication with the sensor.\n\n Module header:\n\nmodule dht11_driver(input clk1mhz,input rst_n,input start_signal,inout dht11_dat,output reg [7:0] output_temp,output reg[7:0] output_humidity,output reg [3:0]status);\n [/INST]\n", "output": "integer clock_count; \n  integer data_count; \n  integer global_count; \n  reg direction; \n  wire data_in; \n  reg data_out; \n  reg [39:0] data; \n  assign dht11_dat = direction ? 1'bz:data_out; \n  assign data_in = dht11_dat; \n  reg[3:0] state; \n  always@(posedge clk1mhz, negedge rst_n) \n  begin \n  if (~rst_n) \n  begin \n  state<=4'b0; \n  status <=4'b0; \n  data<=40'b0; \n  output_temp <= 8'b0; \n  output_humidity <=8'b0; \n  global_count<=0; \n  clock_count <=0; \n  data_count<=0; \n  end \n  else \n  begin \n  status<=state; \n  clock_count<=clock_count+1; \n  case( state) \n  4'b0: \n  begin \n  clock_count<=0; \n  data_count<=0; \n  global_count<=0; \n  direction <= 1'b0; \n  data_out<=1'b1; \n  if(start_signal==1'b0) \n  state <=4'd1; \n  end \n  4'b1: \n  begin \n  if(start_signal==1'b1) \n  begin \n  state<=4'd2; \n  clock_count<=0; \n  end \n  end \n  4'd2: \n  begin \n  direction<=1'd0; \n  data_out<=1'd0; \n  if(clock_count==30000) \n  begin \n  state <=4'd3; \n  clock_count<=0; \n  end \n  end \n  4'd3: \n  begin \n  data_out<=1'd1; \n  if (clock_count == 20) \n  begin \n  direction<=1'b1; \n  data_out<=1'bz; \n  state <=4'd4; \n  end \n  end \n  4'd4: \n  begin \n  if(data_in == 1'b0) \n  state <=4'd5; \n  end \n  4'd5: \n  begin \n  if(data_in == 1'b1) \n  state <=4'd6; \n  end \n  4'd6: \n  begin \n  if(data_in == 1'b0) \n  state <=4'd7; \n  end \n  4'd7: \n  begin \n  if(data_in == 1'b1) \n  begin \n  state<=4'd8; \n  clock_count<=0; \n  end \n  end \n  4'd8: \n  begin \n  global_count<=global_count+1; \n  output_temp[0]<=data[23]; \n  output_temp[1]<=data[22]; \n  output_temp[2]<=data[21]; \n  output_temp[3]<=data[20]; \n  output_temp[4]<=data[19]; \n  output_temp[5]<=data[18]; \n  output_temp[6]<=data[17]; \n  output_temp[7]<=data[16]; \n  output_humidity[0]<=data[7]; \n  output_humidity[1]<=data[6]; \n  output_humidity[2]<=data[5]; \n  output_humidity[3]<=data[4]; \n  output_humidity[4]<=data[3]; \n  output_humidity[5]<=data[2]; \n  output_humidity[6]<=data[1]; \n  output_humidity[7]<=data[0]; \n  if (global_count>10000) \n  begin \n  state<=4'd0; \n  end \n  else \n  begin \n  if(data_in == 1'b0) \n  begin \n  data_count <=data_count+1; \n  if(clock_count>40) \n  begin \n  data[data_count] <= 1'b1; \n  end \n  else \n  begin \n  data[data_count] <= 1'b0; \n  end \n  if(data_count == 39) \n  begin \n  state<=4'd9; \n  end \n  else \n  begin \n  state<=4'd7; \n  end \n  clock_count <=0; \n  end \n  end \n  end \n  4'd9: \n  begin \n  if(start_signal==1'b1) \n  state <=4'd10; \n  end \n  4'd10: \n  begin \n  if(start_signal==1'b0) \n  state <=4'd0; \n  end \n  endcase \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a VGA display controller for a 640x480 resolution display. It generates the horizontal sync, vertical sync, and blanking signals based on the provided parameters for the display timings. It fetches character data and attribute data from VRAM based on the current display position, and extracts the color components for the pixel based on the fetched font and attribute data. The module also handles the clearing and synchronization of signals when the clear signal is asserted.\n\n Module header:\n\nmodule vga640x480(input wire clk50,input wire pclk,input wire clr,output wire hsync,output wire vsync,output wire vblank,output reg [12:0] front_vram_addr,inout wire [7:0] front_vram_data,output reg front_vram_rd_low,output reg [1:0] red,output reg [1:0] green,output reg [1:0] blue);\n [/INST]\n", "output": "parameter hpixels = 800; \n parameter vlines = 521; \n parameter hpulse = 96; \n parameter vpulse = 2; \n parameter hbp = 144; \n parameter hfp = 784; \n parameter vbp = 31; \n parameter vfp = 511; \n reg [9:0] hc; \n reg [9:0] vc; \n reg [9:0] hpos; \n reg [9:0] vpos; \n reg [2:0] hdot; \n reg [3:0] vdot; \n reg [6:0] hchar; \n reg [5:0] vchar; \n wire font_pixel; \n reg fetch_attribute; \n reg [7:0] char_data; \n reg [7:0] attribute_data; \n always @(posedge pclk or posedge clr) \n begin \n  if (clr == 1) \n  begin \n  hc <= 0; \n  vc <= 0; \n  end \n  else \n  begin \n  if (hc < hpixels - 1) \n  hc <= hc + 1; \n  else \n  begin \n  hc <= 0; \n  if (vc < vlines - 1) \n  vc <= vc + 1; \n  else \n  vc <= 0; \n  end \n  end \n end \n assign hsync = (hc < hpulse) ? 0:1; \n assign vsync = (vc < vpulse) ? 0:1; \n assign vblank = (vc >= vbp && vc < vfp) ? 0:1; \n pc_vga_8x16 char_rom(.clk(clk50),.col(hdot),.row(vdot),.ascii(char_data),.pixel(font_pixel)); \n always @(posedge clk50) \n begin \n  if ((vc >= vbp && vc < vfp) && (hc >= hbp && hc < hfp)) \n  begin \n  front_vram_rd_low = 0; \n  hpos = hc - hbp; \n  vpos = vc - vbp; \n  hdot = hpos[2:0]; \n  vdot = vpos[3:0]; \n  hchar = hpos[9:3]; \n  vchar = vpos[9:4]; \n  if (fetch_attribute) begin \n  front_vram_addr = 80 * vchar + hchar; \n  attribute_data = front_vram_data; \n  end \n  else begin \n  front_vram_addr = 80 * vchar + hchar + 2400; \n  char_data = front_vram_data; \n  end \n  fetch_attribute = ~fetch_attribute; \n  red = font_pixel ? attribute_data[5:4] : 0; \n  green = font_pixel ? attribute_data[3:2] : 0; \n  blue = font_pixel ? attribute_data[1:0] : 0; \n  end \n  else \n  begin \n  fetch_attribute = 1; \n  front_vram_rd_low = 1; \n  front_vram_addr = 13'bzzzzzzzzzzzz; \n  red = 0; \n  green = 0; \n  blue = 0; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module is a synchronous, parameterized SRL FIFO with configurable FIFO size and width. It has clock, reset, enqueue (enq), dequeue (deq) inputs, and data inputs and outputs. The module uses a memory array to store the data. It updates the count (cnt) and head based on the enq and deq operations. The emp and full outputs indicate whether the FIFO is empty or full, respectively. The dot output provides the data at the head of the FIFO. The module also has an internal integer variable i for loop operations. The design includes logic for handling reset, enq, and deq operations, and updates the memory array based on the enq operation.\n\n Module header:\n\nmodule SRL_FIFO #(parameter FIFO_SIZE = 4,parameter FIFO_WIDTH = 64) (input wire CLK,input wire RST,input wire enq,input wire deq,input wire [FIFO_WIDTH-1:0] din,output wire [FIFO_WIDTH-1:0] dot,output wire emp,output wire full,output reg [FIFO_SIZE:0] cnt);\n [/INST]\n", "output": "reg [FIFO_SIZE-1:0] head; \n  reg [FIFO_WIDTH-1:0] mem [(1<<FIFO_SIZE)-1:0]; \n  assign emp = (cnt==0); \n  assign full = (cnt==(1<<FIFO_SIZE)); \n  assign dot = mem[head]; \n  always @(posedge CLK) begin \n  if (RST) begin \n  cnt <= 0; \n  head <= {(FIFO_SIZE){1'b1}}; \n  end else begin \n  case ({enq, deq}) \n  2'b01: begin cnt <= cnt - 1; head <= head - 1; end \n  2'b10: begin cnt <= cnt + 1; head <= head + 1; end \n  endcase \n  end \n  end \n  integer i; \n  always @(posedge CLK) begin \n  if (enq) begin \n  mem[0] <= din; \n  for (i=1; i<(1<<FIFO_SIZE); i=i+1) mem[i] <= mem[i-1]; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module implements a 12-to-1 multiplexer with configurable data width. The output is selected from one of the 12 inputs based on the select signals sel11 to sel0. The input with the corresponding select signal is routed to the output. The module supports a configurable data width specified by the parameter DW.\n\n Module header:\n\nmodule oh_mux12 #(parameter DW = 1 ) (input sel11,input sel10,input sel9,input sel8,input sel7,input sel6,input sel5,input sel4,input sel3,input sel2,input sel1,input sel0,input [DW-1:0] in11,input [DW-1:0] in10,input [DW-1:0] in9,input [DW-1:0] in8,input [DW-1:0] in7,input [DW-1:0] in6,input [DW-1:0] in5,input [DW-1:0] in4,input [DW-1:0] in3,input [DW-1:0] in2,input [DW-1:0] in1,input [DW-1:0] in0,output [DW-1:0] out);\n [/INST]\n", "output": "assign out[DW-1:0] = ({(DW){sel0}} & in0[DW-1:0] |{(DW){sel1}} & in1[DW-1:0] |{(DW){sel2}} & in2[DW-1:0] |{(DW){sel3}} & in3[DW-1:0] |{(DW){sel4}} & in4[DW-1:0] |{(DW){sel5}} & in5[DW-1:0] |{(DW){sel6}} & in6[DW-1:0] |{(DW){sel7}} & in7[DW-1:0] |{(DW){sel8}} & in8[DW-1:0] |{(DW){sel9}} & in9[DW-1:0] |{(DW){sel10}} & in10[DW-1:0] |{(DW){sel11}} & in11[DW-1:0]); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module premuat3_4 takes four signed 28-bit inputs, and assigns them to four signed 28-bit outputs in a specific permutation order: o_0 is assigned i_0, o_1 is assigned i_2, o_2 is assigned i_1, and o_3 is assigned i_3.\n\n Module header:\n\nmodule premuat3_4(i_0,i_1,i_2,i_3,o_0,o_1,o_2,o_3);\n [/INST]\n", "output": "input signed [27:0] i_0; \n input signed [27:0] i_1; \n input signed [27:0] i_2; \n input signed [27:0] i_3; \n output signed [27:0] o_0; \n output signed [27:0] o_1; \n output signed [27:0] o_2; \n output signed [27:0] o_3; \n assign o_0=i_0; \n assign o_1=i_2; \n assign o_2=i_1; \n assign o_3=i_3; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a transmitter for a communication system. It takes input signals, processes them, and generates output signals for transmission. The module includes logic to control the transmission of data, including managing the readiness to send, handling special characters, and generating parity bits. The module operates on a clock signal and includes a reset function to initialize its state. It also shifts the data for transmission and updates various control signals based on the input and current state. The output signals indicate the readiness to transmit and the values of the transmitted bits.\n\n Module header:\n\nmodule tx_DS_char(input TxReset,input TxClk,input valid_i,input [7:0] dat_i,input lchar_i,output Tx0,output Tx1,output ready_o);\n [/INST]\n", "output": "reg ready; \n  reg [3:0] chrLen; \n  reg [1:0] icpLen; \n  reg [7:0] shreg; \n  reg lcharFlag; \n  reg parity; \n  reg Tx0, Tx1; \n  wire isReady = (ready && (chrLen == 4'd0) && (icpLen == 2'd2)); \n  wire isSendingParity = (~ready && (icpLen == 2'd2)); \n  wire isSendingLChar = (~ready && (icpLen == 2'd1)); \n  wire isSendingBits = (~ready && (icpLen == 2'd0) && (chrLen > 0)); \n  assign ready_o = isReady & ~valid_i; \n  always @(posedge TxClk) begin \n  ready <= ready; \n  chrLen <= chrLen; \n  icpLen <= icpLen; \n  parity <= parity; \n  Tx1 <= Tx1; \n  Tx0 <= Tx0; \n  shreg <= shreg; \n  if(TxReset) begin \n  ready <= 1; \n  chrLen <= 0; \n  icpLen <= 2'd2; \n  parity <= 0; \n  Tx1 <= 0; \n  Tx0 <= 0; \n  shreg <= 8'd0; \n  end \n  else begin \n  if(isReady) begin \n  Tx0 <= 0; \n  Tx1 <= 0; \n  end \n  if(valid_i && isReady) begin \n  ready <= 0; \n  shreg <= dat_i; \n  lcharFlag <= lchar_i; \n  if(lchar_i) begin \n  chrLen <= 4'd2; \n  end \n  else begin \n  chrLen <= 4'd8; \n  end \n  end \n  if(isSendingParity) begin \n  Tx1 <= ~lcharFlag ^ parity; \n  Tx0 <= lcharFlag ^ parity; \n  icpLen <= 2'd1; \n  end \n  if(isSendingLChar) begin \n  Tx1 <= lcharFlag; \n  Tx0 <= ~lcharFlag; \n  icpLen <= 2'd0; \n  parity <= 0; \n  end \n  if(isSendingBits) begin \n  Tx1 <= shreg[0]; \n  Tx0 <= ~shreg[0]; \n  parity <= parity ^ shreg[0]; \n  shreg <= (shreg >> 1); \n  chrLen <= chrLen - 1; \n  if(chrLen == 4'd1) begin \n  ready <= 1; \n  icpLen <= 2'd2; \n  end \n  end \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a simple FIFO (First-In-First-Out) buffer. It has inputs for the clock signal, data to be written into the FIFO, and a write strobe signal to indicate when data should be written. The module also provides outputs for the data read from the FIFO, whether the FIFO is empty, and how many entries in the FIFO are used. The module contains logic to handle the FIFO operations, such as writing and reading data, as well as keeping track of the FIFO's status, like whether it is empty or full.\n\n Module header:\n\nmodule jtag_uart_0_sim_scfifo_w (clk,fifo_wdata,fifo_wr,fifo_FF,r_dat,wfifo_empty,wfifo_used);\n [/INST]\n", "output": "output fifo_FF; \n  output [ 7: 0] r_dat; \n  output wfifo_empty; \n  output [ 5: 0] wfifo_used; \n  input clk; \n  input [ 7: 0] fifo_wdata; \n  input fifo_wr; \n  wire fifo_FF; \n  wire [ 7: 0] r_dat; \n  wire wfifo_empty; \n  wire [ 5: 0] wfifo_used; \n  jtag_uart_0_log_module jtag_uart_0_log \n (.clk (clk),.data (fifo_wdata),.strobe (fifo_wr),.valid (fifo_wr)); \n  assign wfifo_used = {6{1'b0}}; \n  assign r_dat = {8{1'b0}}; \n  assign fifo_FF = 1'b0; \n  assign wfifo_empty = 1'b1; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a 3-input Look-Up Table (LUT) where the output is determined by the combination of the three input signals IN0, IN1, and IN2 using the initialization vector INIT. The output OUT is assigned based on the values of INIT corresponding to the input signals.\n\n Module header:\n\nmodule GP_3LUT(input IN0, IN1, IN2, output OUT);\n [/INST]\n", "output": "parameter [7:0] INIT = 0; \n  assign OUT = INIT[{IN2, IN1, IN0}]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a 2-to-1 multiplexer with a configurable number of bits. It selects between two input vectors d0 and d1 based on the value of the sel input and assigns the selected vector to the output q.\n\n Module header:\n\nmodule mux2 #(parameter bits = 16) (input sel,input [bits-1:0] d0, d1,output [bits-1:0] q);\n [/INST]\n", "output": "assign q = sel ? d1 : d0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module simply assigns the value of input 'a' to output 'b', essentially creating a direct connection between the two signals.\n\n Module header:\n\nmodule abc9_test007_sub(input a, output b);\n [/INST]\n", "output": "assign b = a; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a register with synchronous reset functionality. It takes in a clock signal (iCLK), a write strobe signal (iWRSFR), an 8-bit data input (iDTBUS), a 4-bit control signal (iSSFRR), and outputs an 8-bit signal (oGPO). \n\nThe output is driven by the internal register rGPO, which is assigned to oGPO. The module contains an always block sensitive to the positive edge of the clock signal. When iWRSFR is asserted and iSSFRR is equal to 4'h01, the input iDTBUS is loaded into the register rGPO. Otherwise, the register retains its current value.\n\n Module header:\n\nmodule gporeg(input iCLK,input iWRSFR,input [7:0] iDTBUS,input [3:0] iSSFRR,output [7:0] oGPO);\n [/INST]\n", "output": "reg [7:0] rGPO = 8'h00; \n  assign oGPO = rGPO; \n  always@(posedge iCLK) begin \n  if(iWRSFR && (iSSFRR == 4'h01)) begin \n  rGPO <= iDTBUS; \n  end \n  else begin \n  rGPO <= rGPO; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a 4:1 multiplexer that selects one of the four input signals (in0, in1, in2, in3) based on the select signal. The output signal (out) is driven by the selected input. If the select signal does not match any of the defined cases, the output is set to an 'x' state.\n\n Module header:\n\nmodule Mmux4_1 (out, in0, in1, in2, in3, select);\n [/INST]\n", "output": "output out; \n input in0, in1, in2, in3; \n input [1:0] select; \n  reg out; \n  always @ (select or in0 or in1 or in2 or in3) begin \n  case (select) \n  2'b00: out = in0; \n  2'b01: out = in1; \n  2'b10: out = in2; \n  2'b11: out = in3; \n  default: out = 1'hx; \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes an input signal and a vector of inputs, and outputs the inverted input signal and the inverted input vector.\n\n Module header:\n\nmodule f18_test(output out, input in, output [1:0] vout, input [1:0] vin);\n [/INST]\n", "output": "assign out = ~in; \n assign vout = ~vin; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes two sets of 6-bit inputs and produces three sets of 64-bit outputs. The module uses a generate block with a for loop to conditionally assign values to the LowLogicImm and HighLogicImm outputs based on the input values. The outputs LogicImm is then assigned as the bitwise AND of LowLogicImm and HighLogicImm.\n\n Module header:\n\nmodule example (LogicImm, LowLogicImm, HighLogicImm,LowMaskSel_Top, HighMaskSel_Top, LowMaskSel_Bot, HighMaskSel_Bot);\n [/INST]\n", "output": "input [5:0] LowMaskSel_Top, HighMaskSel_Top; \n  input [5:0] LowMaskSel_Bot, HighMaskSel_Bot; \n  output [63:0] LogicImm; \n  output [63:0] LowLogicImm, HighLogicImm; \n  wire [63:0] LowLogicImm, HighLogicImm; \n  genvar i; \n  generate \n  for (i=0;i<64;i=i+1) begin : MaskVal \n  if (i >= 32) begin \n  assign LowLogicImm[i] = (LowMaskSel_Top <= i[5:0]); \n  assign HighLogicImm[i] = (HighMaskSel_Top >= i[5:0]); \n  end \n  else begin \n  assign LowLogicImm[i] = (LowMaskSel_Bot <= i[5:0]); \n  assign HighLogicImm[i] = (HighMaskSel_Bot >= i[5:0]); \n  end \n  end \n  endgenerate \n  assign LogicImm = LowLogicImm & HighLogicImm; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module interfaces with a Spartan-3AN FPGA and connects to a PicoBlaze processor. It includes registers for input/output, address, and instruction, as well as control signals for write and read operations. The module also handles interrupt and reset signals. It instantiates components for the PicoBlaze processor and connects to the LED output. The module continuously assigns values to input ports, interrupt, reset, and LED based on the portA value.\n\n Module header:\n\nmodule Spartan3AN_PicoBlaze_Leds(CLK_50M,LED);\n [/INST]\n", "output": "parameter PORTA_ID = 8'h00; \n input wire CLK_50M; \n output wire [7:0] LED; \n wire [7:0] portA; \n  wire [9:0] address; \n  wire [17:0] instruction; \n  wire [7:0] port_id; \n  wire [7:0] out_port; \n  wire [7:0] in_port; \n  wire write_strobe; \n  wire read_strobe; \n  wire interrupt; \n  wire reset; \n kcpsm3 kcpsm3_inst (.address(address),.instruction(instruction),.port_id(port_id),.write_strobe(write_strobe),.out_port(out_port),.read_strobe(read_strobe),.in_port(in_port),.interrupt(interrupt),.interrupt_ack(),.reset(reset),.clk(CLK_50M)); \n picocode picocode_inst (.address(address),.instruction(instruction),.clk(CLK_50M)); \n PicoBlaze_OutReg #(.LOCAL_PORT_ID(PORTA_ID)) portA_inst(.clk(CLK_50M),.reset(reset),.port_id(port_id),.write_strobe(write_strobe),.out_port(out_port),.new_out_port(portA)); \n assign in_port = 8'h00; \n assign interrupt = 1'b0; \n assign reset = 1'b0; \n assign LED = portA; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a 6-input Look-Up Table (LUT) that generates two outputs, O6 and O5, based on the input signals I0-I5 and a 64-bit INIT parameter. The module uses a series of conditional assignments to generate intermediate signals s1-s5, which are then used to assign values to O6 and O5. The module effectively acts as a configurable logic block, providing flexibility in generating output logic based on the input values and INIT parameter.\n\n Module header:\n\nmodule LUT6_2(output O6, output O5, input I0, I1, I2, I3, I4, I5);\n [/INST]\n", "output": "parameter [63:0] INIT = 0; \n  wire [31: 0] s5 = I5 ? INIT[63:32] : INIT[31: 0]; \n  wire [15: 0] s4 = I4 ? s5[31:16] : s5[15: 0]; \n  wire [ 7: 0] s3 = I3 ? s4[15: 8] : s4[ 7: 0]; \n  wire [ 3: 0] s2 = I2 ? s3[ 7: 4] : s3[ 3: 0]; \n  wire [ 1: 0] s1 = I1 ? s2[ 3: 2] : s2[ 1: 0]; \n  assign O6 = I0 ? s1[1] : s1[0]; \n  wire [15: 0] s5_4 = I4 ? INIT[31:16] : INIT[15: 0]; \n  wire [ 7: 0] s5_3 = I3 ? s5_4[15: 8] : s5_4[ 7: 0]; \n  wire [ 3: 0] s5_2 = I2 ? s5_3[ 7: 4] : s5_3[ 3: 0]; \n  wire [ 1: 0] s5_1 = I1 ? s5_2[ 3: 2] : s5_2[ 1: 0]; \n  assign O5 = I0 ? s5_1[1] : s5_1[0]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a double alternative priority encoder. It takes an 8-bit input data and produces a 3-bit output q. It contains two internal instances of the altpriority_encoder module, which take the lower and upper 4 bits of the input data, and produce 2-bit outputs. The module then combines the outputs of the two internal encoders to form the final 3-bit output q using a combination of bitwise negation, AND, and OR operations.\n\n Module header:\n\nmodule acl_fp_uitofp_double_altpriority_encoder_bv7 (data,q) ;\n [/INST]\n", "output": "input [7:0] data; \n  output [2:0] q; \n  wire [1:0] wire_altpriority_encoder12_q; \n  wire [1:0] wire_altpriority_encoder13_q; \n  wire wire_altpriority_encoder13_zero; \n  acl_fp_uitofp_double_altpriority_encoder_6v7 altpriority_encoder12 \n (.data(data[3:0]),.q(wire_altpriority_encoder12_q)); \n  acl_fp_uitofp_double_altpriority_encoder_6e8 altpriority_encoder13 \n (.data(data[7:4]),.q(wire_altpriority_encoder13_q),.zero(wire_altpriority_encoder13_zero)); \n  assign \n  q = {(~ wire_altpriority_encoder13_zero), (({2{wire_altpriority_encoder13_zero}} & wire_altpriority_encoder12_q) | ({2{(~ wire_altpriority_encoder13_zero)}} & wire_altpriority_encoder13_q))}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a 4-to-1 multiplexer with a configurable width. It selects one of the four input data buses (d0, d1, d2, d3) based on the 2-bit select signal (s) and assigns the selected data to the output y. The width of the data buses and the output is configurable and is set to 8 bits by default. The module uses a case statement to select the appropriate input based on the value of the select signal. If the select signal is invalid, the output will be set to all 'x's.\n\n Module header:\n\nmodule mux_in #(parameter WIDTH = 8) (input wire [WIDTH-1:0] d0, d1, d2, d3,input wire [1:0] s,output wire [WIDTH-1:0] y);\n [/INST]\n", "output": "reg [7:0] aux; \n  always @(d0,d1,d2,d3,s) \n  begin \n  case (s) \n  2'b00: aux = d0; \n  2'b01: aux = d1; \n  2'b10: aux = d2; \n  2'b11: aux = d3; \n  default: aux = 8'bxxxxxxxx; \n  endcase \n  end \n  assign y = aux; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module l4 defines an 8-bit input a and an 8-bit output z. It instantiates two instances of a module l5, one with a parameter value of 1 and the other with a parameter value of 2. The outputs of these instances are then added together to produce the final output z.\n\n Module header:\n\nmodule l4 (input [7:0] a, output [7:0] z);\n [/INST]\n", "output": "`INLINE_MODULE \n  wire [7:0] z0 `PUBLIC; wire [7:0] z1 `PUBLIC; \n  wire [7:0] z `PUBLIC; assign z = z0+z1; \n  wire [7:0] a1 = a+8'd1; \n  l5 #(1) u0 (a, z0); l5 #(2) u1 (a1, z1); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a clock wizard that generates various clock signals based on the input clock signal `clk_in1`. It uses a PLL (Phase-Locked Loop) to generate multiple output clock signals with specific frequencies and phase relationships. The module also includes logic to handle reset signals and to indicate when the PLL is locked and stable. The clock signals `clk_txd` and `clk_rxd` are routed through buffers for clean and reliable outputs.\n\n Module header:\n\nmodule clk_wiz_1_clk_wiz (output clk_txd,output clk_rxd,input resetn,output locked,input clk_in1);\n [/INST]\n", "output": "wire clk_in1_clk_wiz_1; \n wire clk_in2_clk_wiz_1; \n  IBUF clkin1_ibufg \n (.O (clk_in1_clk_wiz_1),.I (clk_in1)); \n  wire clk_txd_clk_wiz_1; \n  wire clk_rxd_clk_wiz_1; \n  wire clk_out3_clk_wiz_1; \n  wire clk_out4_clk_wiz_1; \n  wire clk_out5_clk_wiz_1; \n  wire clk_out6_clk_wiz_1; \n  wire clk_out7_clk_wiz_1; \n  wire [15:0] do_unused; \n  wire drdy_unused; \n  wire psdone_unused; \n  wire locked_int; \n  wire clkfbout_clk_wiz_1; \n  wire clkfbout_buf_clk_wiz_1; \n  wire clkfboutb_unused; \n  wire clkout0b_unused; \n  wire clkout1b_unused; \n  wire clkout2_unused; \n  wire clkout2b_unused; \n  wire clkout3_unused; \n  wire clkout3b_unused; \n  wire clkout4_unused; \n  wire clkout5_unused; \n  wire clkout6_unused; \n  wire clkfbstopped_unused; \n  wire clkinstopped_unused; \n  wire reset_high; \n  MMCME2_ADV \n #(.BANDWIDTH (\"OPTIMIZED\"),.CLKOUT4_CASCADE (\"FALSE\"),.COMPENSATION (\"ZHOLD\"),.STARTUP_WAIT (\"FALSE\"),.DIVCLK_DIVIDE (1),.CLKFBOUT_MULT_F (10.000),.CLKFBOUT_PHASE (0.000),.CLKFBOUT_USE_FINE_PS (\"FALSE\"),.CLKOUT0_DIVIDE_F (10.000),.CLKOUT0_PHASE (0.000),.CLKOUT0_DUTY_CYCLE (0.500),.CLKOUT0_USE_FINE_PS (\"FALSE\"),.CLKOUT1_DIVIDE (10),.CLKOUT1_PHASE (0.000),.CLKOUT1_DUTY_CYCLE (0.500),.CLKOUT1_USE_FINE_PS (\"FALSE\"),.CLKIN1_PERIOD (10.000)) \n  mmcm_adv_inst \n (.CLKFBOUT (clkfbout_clk_wiz_1),.CLKFBOUTB (clkfboutb_unused),.CLKOUT0 (clk_txd_clk_wiz_1),.CLKOUT0B (clkout0b_unused),.CLKOUT1 (clk_rxd_clk_wiz_1),.CLKOUT1B (clkout1b_unused),.CLKOUT2 (clkout2_unused),.CLKOUT2B (clkout2b_unused),.CLKOUT3 (clkout3_unused),.CLKOUT3B (clkout3b_unused),.CLKOUT4 (clkout4_unused),.CLKOUT5 (clkout5_unused),.CLKOUT6 (clkout6_unused),.CLKFBIN (clkfbout_buf_clk_wiz_1),.CLKIN1 (clk_in1_clk_wiz_1),.CLKIN2 (1'b0),.CLKINSEL (1'b1),.DADDR (7'h0),.DCLK (1'b0),.DEN (1'b0),.DI (16'h0),.DO (do_unused),.DRDY (drdy_unused),.DWE (1'b0),.PSCLK (1'b0),.PSEN (1'b0),.PSINCDEC (1'b0),.PSDONE (psdone_unused),.LOCKED (locked_int),.CLKINSTOPPED (clkinstopped_unused),.CLKFBSTOPPED (clkfbstopped_unused),.PWRDWN (1'b0),.RST (reset_high)); \n  assign reset_high = ~resetn; \n  assign locked = locked_int; \n  BUFG clkf_buf \n (.O (clkfbout_buf_clk_wiz_1),.I (clkfbout_clk_wiz_1)); \n  BUFG clkout1_buf \n (.O (clk_txd),.I (clk_txd_clk_wiz_1)); \n  BUFG clkout2_buf \n (.O (clk_rxd),.I (clk_rxd_clk_wiz_1)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is named \"overflow\" and has 2 output ports (Cout and V) and 4 input ports (g, p, c31, Cin). It computes the carry out (Cout) and overflow (V) signals based on the input signals g, p, c31, and Cin. The carry out (Cout) is computed as the logical OR between g and the logical AND of p and Cin. The overflow (V) is the result of the XOR between Cout and c31.\n\n Module header:\n\nmodule overflow (Cout, V, g, p, c31, Cin);\n [/INST]\n", "output": "output Cout, V; \n  input g, p, c31, Cin; \n  assign Cout = g|(p&Cin); \n  assign V = Cout^c31; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a register-based system with input and output signals. It uses a case statement to determine the value of W_Data based on the CS signal when the RW signal is asserted. The LED output value is assigned based on the CS signal and the value of R_Data_A and R_Data_B. The LED is updated accordingly, displaying the appropriate section of the R_Data_A or R_Data_B values based on the CS signal when the RW signal is not asserted. The module also includes the instantiation of a register instance and reset logic for W_Data and LED.\n\n Module header:\n\nmodule MAIN(Address, RW, CS, clk, Reset, AB, LED);\n [/INST]\n", "output": "parameter SIZE = 5; \n  parameter LEDSIZE = 8; \n  input clk, Reset; \n  input [SIZE-1:0] Address; \n  input RW, AB; \n  input [1:0] CS; \n  output reg [LEDSIZE-1:0] LED; \n  reg [31:0] W_Data; \n  wire [31:0] R_Data_A, R_Data_B, LED_Data; \n register instance_name (.clk(clk),.Reset(Reset),.R_Addr_A(Address),.R_Addr_B(Address),.W_Addr(Address),.W_Data(W_Data),.Write_Reg(RW),.R_Data_A(R_Data_A),.R_Data_B(R_Data_B)); \n  assign LED_Data = AB ? R_Data_A : R_Data_B; \n  always @(*) \n  begin \n  W_Data=32'h0000_0000; \n  LED=8'b0000_0000; \n  if(RW) \n  begin \n  case(CS) \n  2'b00: W_Data= 32'h1234_5678; \n  2'b01: W_Data= 32'h89AB_CDEF; \n  2'b10: W_Data= 32'h7FFF_FFFF; \n  2'b11: W_Data= 32'hFFFF_FFFF; \n  endcase \n  end \n  else \n  begin \n  case(CS) \n  2'b00: LED=LED_Data[7:0]; \n  2'b01: LED=LED_Data[15:8]; \n  2'b10: LED=LED_Data[23:16]; \n  2'b11: LED=LED_Data[31:24]; \n  endcase \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `fft32_TB` simulates a 32-bit Inverse Fast Fourier Transform (FFT) with signal processing components. It includes registers for signals such as `ED`, `RST`, `CLK`, `START`, and `ifft`. The module operates using clock signals, reset signals, and enable signals to control the FFT process. It instantiates components like `READ_ROM32` and `hilbert`, and includes logic for pulse generation and count management. The `RDY` signal acts as a ready indicator, and the module is designed to display output values `DOReal` and `DOImag` based on the count and clock signals.\n\n Module header:\n\nmodule fft32_TB;\n [/INST]\n", "output": "parameter total_bits = 32; \n  reg ED; \n  reg RST; \n  reg CLK; \n  reg START; \n  reg ifft; \n  wire [total_bits-1:0] DImag; \n  wire [total_bits-1:0] DReal; \n  wire signed [total_bits-1:0] DOImag; \n  wire signed [total_bits-1:0] DOReal; \n  wire RDY; \n  reg [5:0] count; \n  initial \n  begin \n  CLK = 1'b0; \n  forever #5 CLK = ~CLK; \n  end \n  initial \n  begin \n  ifft = 1'b0; \n  ED = 1'b1; \n  RST = 1'b0; \n  count = 0; \n  START = 1'b0; \n  #13 RST =1'b1; \n  #43 RST =1'b0; \n  #53 START =1'b1; \n  #12 START =1'b0; \n  end \n  reg [4:0] ct16; \n  always @(posedge CLK or posedge START) \n  if (ED) begin \n  if (START) ct16 = 7'b000_0000; \n  else ct16 = ct16+ 'd1; \n  end \n  wire [total_bits-1:0] D_R,D_I; \n READ_ROM32 UG( .ADDR(ct16) ,.DATA_RE(D_R), .DATA_IM(D_I)); \n  assign DImag = D_I; \n  assign DReal = D_R; \n hilbert UUT(.ED(ED),.RST(RST),.CLK(CLK),.START(START),.DImag(DImag),.DReal(DReal),.DOImag(DOImag),.DOReal(DOReal),.RDY(RDY)); \n  always @(posedge RDY) \n  count <= 33; \n  always @(posedge CLK) \n  begin \n  if(count!=0) \n  begin \n  if(count<=32) \n  $display(\"%d,%d\",DOReal,DOImag); \n  count = count-1; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `v852bc8` takes a 16-bit input `v91b9c1` and assigns it to `w0`. It then assigns the values of `w0` to different 4-bit outputs `vfc89f9`, `v0b337e`, `v71a717`, and `v527ffb`. Finally, it instantiates another module `v852bc8_v9a2a06` and connects the input `w0` to its input `i`, and the outputs `w1`, `w2`, `w3`, and `w4` to its outputs `o0`, `o1`, `o2`, and `o3` respectively.\n\n Module header:\n\nmodule v852bc8 (input [15:0] v91b9c1,output [3:0] vfc89f9,output [3:0] v0b337e,output [3:0] v71a717,output [3:0] v527ffb);\n [/INST]\n", "output": "wire [0:15] w0; \n  wire [0:3] w1; \n  wire [0:3] w2; \n  wire [0:3] w3; \n  wire [0:3] w4; \n  assign w0 = v91b9c1; \n  assign v527ffb = w1; \n  assign v71a717 = w2; \n  assign v0b337e = w3; \n  assign vfc89f9 = w4; \n v852bc8_v9a2a06 v9a2a06 (.i(w0),.o0(w1),.o1(w2),.o2(w3),.o3(w4)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module calculates the parity for a given set of input data. The module takes in a data_in signal of width WIDTH * NUM and computes the parity for each group of WIDTH bits, resulting in NUM parity outputs. It uses nested for-loops to iterate over the input data and perform bitwise XOR operations to calculate the parity for each group. The calculated parities are then assigned to the parity_out outputs.\n\n Module header:\n\nmodule lsu_dc_parity_gen (parity_out, data_in);\n [/INST]\n", "output": "parameter WIDTH = 8 ; \n parameter NUM = 16 ; \n input [WIDTH * NUM - 1 : 0] data_in ; \n output [NUM - 1 : 0] parity_out ; \n reg [NUM - 1 : 0] parity ; \n integer i ; \n integer j ; \n always @(data_in) \n  for (i = 0; i <= NUM - 1 ; i = i + 1) begin \n  parity[i] = 1'b0 ; \n  for (j = WIDTH * i; j <= WIDTH * (i + 1) - 1 ; j = j + 1) begin \n  parity[i] = parity[i] ^ data_in[j] ; \n  end \n  end \n assign parity_out[NUM - 1 : 0] = parity[NUM - 1 : 0]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements logic to select the carry input for an adder. It utilizes multiplexers and registers to control the selection of the carry-in signal based on various conditions. The module takes inputs such as CARRYIN, CARRYCASCIN, CARRYCASCOUT, A, B, P, PCIN, CARRYINSEL, CIN, RSTALLCARRYIN, CECARRYIN, CEM, and CLK to generate the output wire CIN. The module also includes preprocessor conditional compilation checks and assigns values to various wires based on the input conditions. The core functionality involves the selection of the carry-in signal using multiplexers and registers.\n\n Module header:\n\nmodule CARRYINSEL_LOGIC (CARRYIN, CARRYCASCIN, CARRYCASCOUT, A, B, P, PCIN, CARRYINSEL, CIN,RSTALLCARRYIN, CECARRYIN, CEM, CLK);\n [/INST]\n", "output": "parameter MREG = 1; \n  parameter CARRYINREG = 1; \n  input wire CARRYIN; \n  input wire CARRYCASCIN; \n  input wire CARRYCASCOUT; \n  input wire [24:0] A; \n  input wire [17:0] B; \n  input wire [47:0] P; \n  input wire [47:0] PCIN; \n  input wire [2:0] CARRYINSEL; \n  output wire CIN; \n  input wire RSTALLCARRYIN; \n  input wire CECARRYIN; \n  input wire CEM; \n  input wire CLK; \n `ifndef PB_TYPE \n  wire ROUND; \n  wire ROUND_REG; \n  wire ROUND_MUX_OUT; \n  assign ROUND = A[24] ~^ B[17]; \n  REG round_reg (.D(ROUND), .Q(ROUND_REG), .CE(CEM), .CLK(CLK), .RESET(RSTALLCARRYIN)); \n  CARRYIN_MUX #(.S(MREG)) round_mux (.BYPASS(ROUND), .REG(ROUND_REG), .O(ROUND_MUX_OUT)); \n  wire CARRYIN_REG; \n  wire CARRYIN_MUX_OUT; \n  REG carryin_reg (.D(CARRYIN), .Q(CARRYIN_REG), .CE(CECARRYIN), .CLK(CLK), .RESET(RSTALLCARRYIN)); \n  CARRYIN_MUX #(.S(CARRYINREG)) carryin_mux (.BYPASS(CARRYIN), .REG(CARRYIN_REG), .O(CARRYIN_MUX_OUT)); \n MUX8 carryinsel_mux (.I0(CARRYIN_MUX_OUT), .I1(~PCIN[47]), .I2(CARRYCASCIN), .I3(PCIN[47]), .I4(CARRYCASCOUT), .I5(~P[47]), .I6(ROUND_MUX_OUT), .I7(P[47]),.S0(CARRYINSEL[0]), .S1(CARRYINSEL[1]), .S2(CARRYINSEL[2]), .O(CIN)); \n `endif \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `XOR_Shift` implements an XOR shift operation for a CRC code with a width of 32 bits. It takes in `stage_input`, `poly`, and `new_bit` as inputs and calculates the `stage_output` based on bitwise operations and XOR shifts using the polynomial `poly`. The module utilizes the XOR operation to compute the first bit of the output and then performs XOR shift operations to calculate the remaining bits of the `stage_output`.\n\n Module header:\n\nmodule XOR_Shift (stage_input,poly,new_bit,stage_output);\n [/INST]\n", "output": "parameter crc_width = 32; \n  input [crc_width-1:0] stage_input; \n  input [crc_width-1:0] poly; \n  input new_bit; \n  output [crc_width-1:0] stage_output; \n  assign stage_output[0] = new_bit ^ stage_input[crc_width-1]; \n  assign stage_output[crc_width-1:1] = stage_input[crc_width-2:0] ^ ({crc_width-1{stage_output[0]}} & poly[crc_width-1:1]); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a multiplexer with a parameterized width 'b'. It selects between two input vectors 'd0' and 'd1' based on the value of 'sel', and assigns the selected vector to the output 'o'. The output width is also 'b', matching the input vector width.\n\n Module header:\n\nmodule hardcaml_lib_mux2 #(parameter b=1) (input sel,input [b-1:0] d0,input [b-1:0] d1,output [b-1:0] o);\n [/INST]\n", "output": "assign o = sel ? d1 : d0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a 7-segment display decoder. It takes input signals for four 7-segment displays (display_0, display_1, display_2, and display_3) and two signals for selecting the active display (decplace), and outputs the corresponding 7-segment segment patterns (seg) and the active anode (an) to drive the selected display.\n\nThe module includes a counter (cnt) to cycle through the four displays and a case statement to select the active display based on the cnt value. Another case statement translates the input display patterns into the corresponding 7-segment segment patterns for each digit. The counter is driven by the clock signal and can be reset by the rstn signal.\n\nOverall, this module serves as a decoder that translates the input display patterns into the corresponding 7-segment segment patterns and controls the active display.\n\n Module header:\n\nmodule sevenseg (input wire clk,input wire rstn,input wire [7:0] display_0,input wire [7:0] display_1,input wire [7:0] display_2,input wire [7:0] display_3,input wire [1:0] decplace,output reg [7:0] seg,output reg [3:0] an);\n [/INST]\n", "output": "localparam NUM_0 = 8'b11000000; \n localparam NUM_1 = 8'b11111001; \n localparam NUM_2 = 8'b10100100; \n localparam NUM_3 = 8'b10110000; \n localparam NUM_4 = 8'b10011001; \n localparam NUM_5 = 8'b10010010; \n localparam NUM_6 = 8'b10000010; \n localparam NUM_7 = 8'b11111000; \n localparam NUM_8 = 8'b10000000; \n localparam NUM_9 = 8'b10010000; \n localparam CHAR_A = 8'b10001000; \n localparam CHAR_B = 8'b10000011; \n localparam CHAR_C = 8'b11000110; \n localparam CHAR_D = 8'b10100001; \n localparam CHAR_E = 8'b10000110; \n localparam CHAR_F = 8'b10001110; \n localparam CHAR_G = 8'b10000010; \n localparam CHAR_H = 8'b10001001; \n localparam CHAR_K = 8'b10001111; \n localparam CHAR_L = 8'b11000111; \n localparam CHAR_o = 8'b10100011; \n localparam CHAR_S = 8'b10010010; \n localparam CHAR_T = 8'b11111000; \n localparam CHAR_P = 8'b10001100; \n localparam SPACE = 8'b11111111; \n localparam HYPHEN = 8'b10111111; \n localparam UNDERLINE = 8'b11110111; \n localparam OVERRLINE = 8'b11111110; \n reg [16:0] cnt; \n reg [7:0] digit; \n always @(cnt[16:15]) begin \n  case (cnt[16:15]) \n  2'b11: an <= 4'b1110; \n  2'b10: an <= 4'b1101; \n  2'b01: an <= 4'b1011; \n  default: an <= 4'b0111; \n  endcase \n end \n always @(cnt[16:15] or display_0 or display_1 or display_2 or display_3) begin \n  case (cnt[16:15]) \n  2'b00: digit <= display_0; \n  2'b01: digit <= display_1; \n  2'b10: digit <= display_2; \n  default: digit <= display_3; \n  endcase \n  case (digit) \n  8'h20: seg <= SPACE; \n  8'h2d: seg <= HYPHEN; \n  8'h30: seg <= NUM_0; \n  8'h31: seg <= NUM_1; \n  8'h32: seg <= NUM_2; \n  8'h33: seg <= NUM_3; \n  8'h34: seg <= NUM_4; \n  8'h35: seg <= NUM_5; \n  8'h36: seg <= NUM_6; \n  8'h37: seg <= NUM_7; \n  8'h38: seg <= NUM_8; \n  8'h39: seg <= NUM_9; \n  8'h41: seg <= CHAR_A; \n  8'h43: seg <= CHAR_C; \n  8'h45: seg <= CHAR_E; \n  8'h47: seg <= CHAR_G; \n  8'h48: seg <= CHAR_H; \n  8'h4b: seg <= CHAR_K; \n  8'h4c: seg <= CHAR_L; \n  8'h50: seg <= CHAR_P; \n  8'h53: seg <= CHAR_S; \n  8'h5f: seg <= UNDERLINE; \n  8'h6f: seg <= CHAR_o; \n  default: seg <= OVERRLINE; \n  endcase \n end \n always @(posedge clk or negedge rstn) begin \n  if (!rstn) begin \n  cnt <= 0; \n  end \n  else \n  cnt <= cnt + 1; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a D flip-flop with asynchronous clear and synchronous set. When the clear signal is low, the output q is set to 0 regardless of the clock or data input. When the clear signal is high and the enable signal is also high, the output q follows the data input d on the rising edge of the clock signal.\n\n Module header:\n\nmodule my_dffre_n (input d,clk,clr,en,output reg q);\n [/INST]\n", "output": "always @(posedge clk or negedge clr) \n  if (!clr) q <= 1'b0; \n  else if (en) q <= d; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a reconciliation module for a specific port, implementing clock and data recovery logic for the input and output signals. It also includes a PLL, button debouncer, and general-purpose I/O functionality. The reconciliation module utilizes clock and data signals, and handles input and output enables for the specified port. Additionally, the module incorporates button debouncing and a PLL for clock signal synchronization.\n\n Module header:\n\nmodule recon_0_top #(parameter PORT_0_WIDTH = 32) (input sys_clk,input sys_rstn,inout [ PORT_0_WIDTH-1:0] port_0_io,output uart_0_txd,input uart_0_rxd);\n [/INST]\n", "output": "wire [PORT_0_WIDTH-1:0] port_0_out; \n  wire [PORT_0_WIDTH-1:0] port_0_in; \n  wire [PORT_0_WIDTH-1:0] port_0_oe; \n  wire [PORT_0_WIDTH-1:0] port_0_opdrn; \n  wire cpu_clk, locked; \n alt_pll pll(.areset (~sys_rstn),.inclk0 (sys_clk),.c0 (cpu_clk),.locked (locked)); \n  buttonDebouncer \n #(.pDEBOUNCE_PERIOD (100_000_000),.pCLKIN_PERIOD (20 ),.pARRAY_SIZE (1 ),.pPOLARITY (0)) resetDebounce \n (.clk (sys_clk),.buttons (sys_rstn),.buttonState (sys_rstn_db),.buttonUpTick (),.buttonDwTick ()); \n recon_0 (.clk_clk (cpu_clk),.recon_io_0_io_port_io_out (port_0_out),.recon_io_0_io_port_io_opdrn (port_0_opdrn),.recon_io_0_io_port_io_in (port_0_in),.recon_io_0_io_port_io_oe (port_0_oe),.recon_timer_0_clock_tick_second (),.recon_timer_0_clock_tick_millisecond (),.recon_timer_0_clock_tick_microsec (),.reset_reset_n (sys_rstn_db),.uart_0_rxd (uart_0_rxd),.uart_0_txd (uart_0_txd)); \n  genvar IO; \n  generate \n  for (IO = 0; IO<PORT_0_WIDTH;IO=IO+1) \n  begin : assign_io \n  assign port_0_io[IO] = (port_0_oe[IO]==1'b0||(port_0_out[IO]==1'b1&&port_0_opdrn[IO]==1'b1))?1'bz:port_0_out[IO]; \n  assign port_0_in[IO] = port_0_io[IO]; \n  end \n  endgenerate \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a digital display with four digits, driven by an input clock. It takes in a 16-bit data, format selection, and uses a counter to select a digit. The formatted data is updated based on the format select, and the digit and select outputs are updated based on the formatted data. The module supports two formats: decimal and hexadecimal. The digit and select outputs are updated at each clock cycle, and the formatted data is displayed accordingly.\n\n Module header:\n\nmodule digital_display_4(input [15:0] data,input format_select,output reg [7:0] digit,output reg [3:0] select,input clk);\n [/INST]\n", "output": "reg [31:0] data_reg_formatted; \n  wire [31:0] data_formatted_dec; \n  wire [31:0] data_formatted_hex; \n  always @(posedge clk) \n  begin \n  if (format_select == 1'b0) data_reg_formatted <= data_formatted_hex; \n  if (format_select == 1'b1) data_reg_formatted <= data_formatted_dec; \n  end \n  always @(posedge clk) \n  begin \n  select <= select << 1; \n  if (select == 0) select <= 4'b1; \n  if (select == 4'b0001) \n  digit <= data_reg_formatted[7:0]; \n  if (select == 4'b0010) \n  digit <= data_reg_formatted[15:8]; \n  if (select == 4'b0100) \n  digit <= data_reg_formatted[23:16]; \n  if (select == 4'b1000) \n  digit <= data_reg_formatted[31:24]; \n  end \n display_to_dec d2dec(.number(data),.result(data_formatted_dec)); \n display_to_hex d2hex(.number(data),.result(data_formatted_hex)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module interfaces with various input and output ports, including clock inputs, reset signals, LED outputs, slide switch inputs, and various audio and video interfaces. It instantiates a video_test_system module and sets the vga_blank signal to 1 and the vga_sync signal to 0.\n\n Module header:\n\nmodule simple_io(input wire clk_in,input wire reset_n,output wire [3:0] led,input wire [3:0] slide_sw,input wire [3:0] key,input aud_adcdat,inout aud_bclk,inout aud_daclrck,inout aud_adclrck,output aud_xck,output adu_dacdat,output aud_mute,inout fpga_sd_D0,inout fpga_sd_D1,inout fpga_sd_D2,inout fpga_sd_D3,inout fpga_sd_CMD,output fpga_sd_CLK,output [7:0] vga_r_data,output [7:0] vga_g_data,output [7:0] vga_b_data,output vga_blank,output vga_sync,output lcd_hsync,output lcd_vsync,output lcd_clk,output lcd_de,output lcd_pwm,input hdmi_int);\n [/INST]\n", "output": "video_test_system u0 (.clk_clk (clk_in),.reset_reset_n (1'b1),.video_out_vid_data ({vga_b_data[7:0], vga_g_data[7:0], vga_r_data[7:0]}),.video_out_underflow (),.video_out_vid_datavalid (lcd_de),.video_out_vid_v_sync (lcd_vsync),.video_out_vid_h_sync (lcd_hsync),.video_out_vid_f (),.video_out_vid_h (),.video_out_vid_v (),.video_clk_clk (lcd_clk)); \n  assign vga_blank = 1'b1; \n  assign vga_sync = 1'b0; \n  endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `stratixii_termination_digital` simulates a digital circuit with several input and output signals, using registers and conditional logic. It includes logic for input signal handling, clock edge detection, register initialization, signal assignment, and conditional updates based on various input conditions. The module is designed to control termination and power-down features, as well as handle various runtime and test mode scenarios. The code also includes logic for shifting, adding, and checking specific conditions for control signal generation.\n\n Module header:\n\nmodule stratixii_termination_digital (rin,clk,clr,ena,padder,devpor,devclrn,ctrlout);\n [/INST]\n", "output": "input rin; \n input clk; \n input clr; \n input ena; \n input [6:0] padder; \n input devpor; \n input devclrn; \n output [6:0] ctrlout; \n parameter runtime_control = \"false\"; \n parameter use_core_control = \"false\"; \n parameter use_both_compares = \"false\"; \n parameter pull_adder = 0; \n parameter power_down = \"true\"; \n parameter left_shift = \"false\"; \n parameter test_mode = \"false\"; \n reg rin_reg_n; \n reg [6:0] counter1; \n reg pdetect_reg_n; \n reg pdetect_reg_1; \n reg pdetect_reg_2; \n wire pdetect_out; \n wire pre_adder_reg_n_ena; \n reg [6:0] pre_adder_reg_n; \n wire pre_adder_reg_ena; \n reg [6:0] pre_adder_reg; \n wire [6:0] adder_in; \n wire [6:0] adder1; \n initial \n begin \n  rin_reg_n = 1'b0; \n  counter1 = 7'b1000000; \n  pdetect_reg_n = 1'b0; \n  pdetect_reg_1 = 1'b0; \n  pdetect_reg_2 = 1'b0; \n  pre_adder_reg_n = 7'b0100000; \n  pre_adder_reg = 7'b0100000; \n end \n assign ctrlout = (use_core_control == \"true\") ? padder : adder1; \n always @(negedge clk or posedge clr) \n begin \n  if (clr === 1'b1) \n  rin_reg_n <= 1'b0; \n  else \n  rin_reg_n <= rin; \n end \n always @(posedge clk or posedge clr) \n begin \n  if (clr === 1'b1) \n  counter1 <= 7'b1000000; \n  else if (ena === 1'b1) \n  begin \n  if (rin_reg_n === 1'b0 && counter1 > 7'b000000) \n  counter1 <= counter1 - 7'b0000001; \n  else if (rin_reg_n === 1'b1 && counter1 < 7'b1111111) \n  counter1 <= counter1 + 7'b0000001; \n  end \n end \n assign pdetect_out = ((pdetect_reg_2 === 1'b0) && (pdetect_reg_1 === 1'b1))? 1'b1 : 1'b0; \n always @(negedge clk) \n  pdetect_reg_n <= rin_reg_n; \n always @(posedge clk) \n begin \n  pdetect_reg_1 <= rin_reg_n; \n  pdetect_reg_2 <= pdetect_reg_1; \n end \n assign pre_adder_reg_n_ena = (test_mode === \"true\") ? ena \n  : (ena && pdetect_out); \n always @(negedge clk or posedge clr) \n begin \n  if (clr === 1'b1) \n  pre_adder_reg_n <= 7'b0100000; \n  else if (pre_adder_reg_n_ena === 1'b1) \n  pre_adder_reg_n <= counter1; \n end \n assign adder_in = (left_shift === \"false\") ? pre_adder_reg_n \n  : (pre_adder_reg_n << 1); \n assign adder1 = adder_in + pull_adder; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a rotary interface that generates signals to indicate left and right rotation based on the input signals. It uses two filters to detect the direction of rotation and delay the signals appropriately. The outputs, rotary_left and rotary_right, represent the direction of the rotary input. The module uses clock and reset signals to control the internal state and transitions.\n\n Module header:\n\nmodule RotaryInterface(clock,reset,rotary,rotary_left,rotary_right);\n [/INST]\n", "output": "input wire clock; \n  input wire reset; \n  input wire [1:0] rotary; \n  output wire rotary_left; \n  output wire rotary_right; \n  reg s_Filter1; \n  reg s_Filter2; \n  reg s_Filter1Delay; \n  reg s_RotaryLeft; \n  reg s_DoneRotaryLeft; \n  reg s_RotaryRight; \n  reg s_DoneRotaryRight; \n  assign rotary_left = s_RotaryLeft; \n  assign rotary_right = s_RotaryRight; \n  always @ (posedge clock) begin \n  if (reset) begin \n  s_Filter1 <= 0; \n  s_Filter2 <= 0; \n  end \n  else begin \n  case (rotary) \n  2'b00: begin \n  s_Filter1 <= 0; \n  s_Filter2 <= s_Filter2; \n  end \n  2'b01: begin \n  s_Filter1 <= s_Filter1; \n  s_Filter2 <= 0; \n  end \n  2'b10: begin \n  s_Filter1 <= s_Filter1; \n  s_Filter2 <= 1; \n  end \n  2'b11: begin \n  s_Filter1 <= 1; \n  s_Filter2 <= s_Filter2; \n  end \n  default: begin \n  s_Filter1 <= s_Filter1; \n  s_Filter2 <= s_Filter2; \n  end \n  endcase \n  end \n  end \n  always @ (posedge clock) begin \n  if (reset) begin \n  s_Filter1Delay <= 0; \n  s_RotaryLeft <= 0; \n  s_DoneRotaryLeft <= 0; \n  s_RotaryRight <= 0; \n  s_DoneRotaryRight <= 0; \n  end \n  else begin \n  if (s_Filter1 && !s_Filter1Delay) begin \n  if (s_Filter2) begin \n  if (!s_DoneRotaryRight) begin \n  s_Filter1Delay <= s_Filter1; \n  s_RotaryLeft <= 0; \n  s_DoneRotaryLeft <= 0; \n  s_RotaryRight <= 1; \n  s_DoneRotaryRight <= 1; \n  end \n  else begin \n  s_Filter1Delay <= s_Filter1; \n  s_RotaryLeft <= 0; \n  s_DoneRotaryLeft <= 0; \n  s_RotaryRight <= 0; \n  s_DoneRotaryRight <= 1; \n  end \n  end \n  else begin \n  if (!s_DoneRotaryLeft) begin \n  s_Filter1Delay <= s_Filter1; \n  s_RotaryLeft <= 1; \n  s_DoneRotaryLeft <= 1; \n  s_RotaryRight <= 0; \n  s_DoneRotaryRight <= 0; \n  end \n  else begin \n  s_Filter1Delay <= s_Filter1; \n  s_RotaryLeft <= 0; \n  s_DoneRotaryLeft <= 1; \n  s_RotaryRight <= 0; \n  s_DoneRotaryRight <= 0; \n  end \n  end \n  end \n  else begin \n  s_Filter1Delay <= s_Filter1; \n  s_RotaryLeft <= 0; \n  s_DoneRotaryLeft <= 0; \n  s_RotaryRight <= 0; \n  s_DoneRotaryRight <= 0; \n  end \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module is a 5-bit counter with an input clock and an output count. The count is updated on the falling edge of the clock and propagates a carry from the least significant bit to the most significant bit. The counter counts in a binary sequence.\n\n Module header:\n\nmodule nsCounter (input clk,output [4:0] count);\n [/INST]\n", "output": "wire clk; \n  reg[4:0] count; \n  initial \n  count = 0; \n  always @ ( negedge clk ) \n  count[0] <= ~count[0]; \n  always @ ( negedge count[0] ) \n  count[1] <= ~count[1]; \n  always @ ( negedge count[1] ) \n  count[2] <= ~count[2]; \n  always @ ( negedge count[2] ) \n  count[3] <= ~count[3]; \n  always @ ( negedge count[3] ) \n  count[4] <= ~count[4]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a wire delay with the given delay parameters. It consists of two output registers for A and B, and a control signal line_en. When the reset signal is low, the output registers are set to high-impedance state, and line_en is set to 0. When the reset signal is high, the module delays the input A or B based on the value of line_en and the specified delay parameters (Delay_g for B and Delay_rd for A). The line_en signal is used to determine whether to apply the delay to A or B. Additionally, there is a logic to check for differences between the current and delayed values of A and B, which affects the line_en control signal.\n\nIn summary, this module provides wire delay functionality for signals A and B with configurable delays, controlled by the reset signal and line_en.\n\n Module header:\n\nmodule WireDelay # (parameter Delay_g = 0,parameter Delay_rd = 0) (inout A,inout B,input reset);\n [/INST]\n", "output": "reg A_r; \n  reg B_r; \n  reg line_en; \n  assign A = A_r; \n  assign B = B_r; \n  always @(*) begin \n  if (!reset) begin \n  A_r <= 1'bz; \n  B_r <= 1'bz; \n  line_en <= 1'b0; \n  end else begin \n  if (line_en) begin \n  A_r <= #Delay_rd B; \n  B_r <= 1'bz; \n  end else begin \n  B_r <= #Delay_g A; \n  A_r <= 1'bz; \n  end \n  end \n  end \n  always @(A or B) begin \n  if (!reset) begin \n  line_en <= 1'b0; \n  end else if (A !== A_r) begin \n  line_en <= 1'b0; \n  end else if (B_r !== B) begin \n  line_en <= 1'b1; \n  end else begin \n  line_en <= line_en; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a simple implementation of a synchronous DRAM (Dynamic Random Access Memory) module. It has ports for clock (CLK), address (A), data in (DIN), data out (DOUT), enable (EN), and write enable (WE). The module uses parameters for the address width (DA_WIDTH), data width (DD_WIDTH), and depth of the memory (DA_DEPTH). \n\nThe module uses a memory array (MEM) to store data, and on the positive edge of the clock (CLK), it checks the enable input (EN) and performs read and write operations based on the write enable input (WE). If the enable input is active, it writes the data from the input (DIN) to the memory array at the specified address (A) when the write enable is active. \n\nThe module also initializes the memory array with all zeros at the beginning using an initial block. Overall, this module simulates the basic behavior of a simple DRAM module with read and write operations based on the inputs.\n\n Module header:\n\nmodule DRAM (CLK,A,DIN,DOUT,EN,WE);\n [/INST]\n", "output": "parameter DA_WIDTH = 11; \n  parameter DD_WIDTH = 8; \n  parameter DA_DEPTH = (1 << DA_WIDTH); \n  input CLK; \n  input [DA_WIDTH - 1:0] A; \n  input [DD_WIDTH - 1:0] DIN; \n  output reg [DD_WIDTH - 1:0] DOUT; \n  input EN; \n  input WE; \n  reg [7:0] MEM [0:DA_DEPTH - 1]; \n  always @ (posedge CLK) \n  if(EN) \n  begin \n  if(WE) \n  MEM[A] <= DIN; \n  DOUT <= MEM[A]; \n  end \n  integer i; \n  initial \n  for(i = 0; i < DA_DEPTH; i = i + 1) \n  MEM[i] = 8'b0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module, \"bounding_box,\" implements the functionality to calculate the bounding box of an image based on specific input signals. It uses the input image dimensions to track and update the minimum and maximum x and y coordinates of the bounding box, along with other related parameters. The module also checks whether the current pixel is on the border of the bounding box and updates relevant output signals accordingly.\n\n Module header:\n\nmodule bounding_box # (parameter [9:0] IMG_W = 720,parameter [9:0] IMG_H = 576) (input clk,input ce,input rst,input de,input hsync,input vsync,input mask,output [9:0] x_min,output [9:0] y_min,output [9:0] x_max,output [9:0] y_max,output [9:0] c_h,output [9:0] c_w,output on_border);\n [/INST]\n", "output": "reg [9:0] curr_w = 0; \n reg [9:0] curr_h = 0; \n reg [9:0] min_x = IMG_W; \n reg [9:0] max_x = 0; \n reg [9:0] min_y = IMG_H; \n reg [9:0] max_y = 0; \n wire eof; \n wire p_vsync; \n reg is_valid = 0; \n delay # \n (.DELAY(1),.N(1)) \n delay_vsync \n (.d(vsync),.ce(1'b1),.clk(clk),.q(p_vsync)); \n always @(posedge clk) \n begin \n  if (vsync == 0) begin \n  curr_w <= 0; \n  curr_h <= 0; \n  end \n  else if(de == 1) begin \n  curr_w <= curr_w + 1; \n  if (curr_w == IMG_W - 1) begin \n  curr_w <= 0; \n  curr_h <= curr_h + 1; \n  if (curr_h == IMG_H - 1) begin \n  curr_h <= 0; \n  end \n  end \n  end \n end \n assign eof = (p_vsync == 1'b1 && vsync == 1'b0) ? 1'b1 : 1'b0; \n reg [9:0] min_x_latch = 0; \n reg [9:0] max_x_latch = 0; \n reg [9:0] min_y_latch = 0; \n reg [9:0] max_y_latch = 0; \n always @(posedge clk) \n begin \n  if(eof) \n  begin \n  min_x_latch = min_x; \n  max_x_latch = max_x; \n  min_y_latch = min_y; \n  max_y_latch = max_y; \n  min_x = IMG_W; \n  max_x = 0; \n  min_y = IMG_H; \n  max_y = 0; \n  end \n  else \n  begin \n  if(curr_w > 0 && curr_h > 0 && curr_w < IMG_W - 1 && curr_h < IMG_H - 1) is_valid = 1; \n  else is_valid = 0; \n  if(is_valid == 1 && de == 1 && vsync == 1 && mask == 1'b1 && min_x > curr_w) min_x = curr_w; \n  if(is_valid == 1 && de == 1 && vsync == 1 && mask == 1'b1 && max_x < curr_w) max_x = curr_w; \n  if(is_valid == 1 && de == 1 && vsync == 1 && mask == 1'b1 && min_y > curr_h) min_y = curr_h; \n  if(is_valid == 1 && de == 1 && vsync == 1 && mask == 1'b1 && max_y < curr_h) max_y = curr_h; \n  end \n end \n reg bbox_on_border = 0; \n always @(posedge clk) \n begin \n  if((curr_h >= min_y_latch && curr_h <= max_y_latch) && (curr_w == min_x_latch || curr_w == max_x_latch)) bbox_on_border = 1; \n  else if((curr_w >= min_x_latch && curr_w <= max_x_latch) && (curr_h == min_y_latch || curr_h == max_y_latch)) bbox_on_border = 1; \n  else bbox_on_border = 0; \n end \n assign x_min = min_x_latch; \n assign x_max = max_x_latch; \n assign y_min = min_y_latch; \n assign y_max = max_y_latch; \n assign c_h = curr_h; \n assign c_w = curr_w; \n assign on_border = bbox_on_border; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a counter chain with two sub-modules for counters. It takes clock and reset signals as inputs and provides output and next output signals for each counter. The module configures the maximum value for each counter and handles the enable signals based on the configuration chain. The module instantiates two CounterCore_8 sub-modules, configures their inputs and outputs, and manages the enable signals for each counter.\n\n Module header:\n\nmodule CounterChainCore_4(input clock,input reset,output [5:0] io_out_0,output [5:0] io_out_1,output [5:0] io_next_0,output [5:0] io_next_1,input io_enable_0,input io_enable_1,input io_config_chain_0);\n [/INST]\n", "output": "wire counters_0_clock; \n  wire counters_0_reset; \n  wire [5:0] counters_0_io_out; \n  wire [5:0] counters_0_io_next; \n  wire counters_0_io_enable; \n  wire counters_0_io_done; \n  wire [5:0] counters_0_io_config_max; \n  wire counters_1_clock; \n  wire counters_1_reset; \n  wire [5:0] counters_1_io_out; \n  wire [5:0] counters_1_io_next; \n  wire counters_1_io_enable; \n  wire counters_1_io_done; \n  wire [5:0] counters_1_io_config_max; \n  wire _T_69; \n CounterCore_8 counters_0 (.clock(counters_0_clock),.reset(counters_0_reset),.io_out(counters_0_io_out),.io_next(counters_0_io_next),.io_enable(counters_0_io_enable),.io_done(counters_0_io_done),.io_config_max(counters_0_io_config_max)); \n CounterCore_8 counters_1 (.clock(counters_1_clock),.reset(counters_1_reset),.io_out(counters_1_io_out),.io_next(counters_1_io_next),.io_enable(counters_1_io_enable),.io_done(counters_1_io_done),.io_config_max(counters_1_io_config_max)); \n  assign _T_69 = io_config_chain_0 ? counters_0_io_done : io_enable_1; \n  assign io_out_0 = counters_0_io_out; \n  assign io_out_1 = counters_1_io_out; \n  assign io_next_0 = counters_0_io_next; \n  assign io_next_1 = counters_1_io_next; \n  assign counters_0_io_enable = io_enable_0; \n  assign counters_0_io_config_max = 6'h10; \n  assign counters_0_clock = clock; \n  assign counters_0_reset = reset; \n  assign counters_1_io_enable = _T_69; \n  assign counters_1_io_config_max = 6'h20; \n  assign counters_1_clock = clock; \n  assign counters_1_reset = reset; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a configurable Wishbone bus multiplexer. It takes in various Wishbone bus signals and outputs the corresponding signals for multiple slave devices based on an address match. The module contains a parameterized address match and mask to select the appropriate slave device, and it also includes error detection logic. The generated match signals compare the input address with the pre-defined match address for each slave. The module then selects the appropriate slave based on the match signal and forwards the corresponding bus signals to that slave. Additionally, it handles error signals and retry outputs for the selected slave.\n\n Module header:\n\nmodule wb_mux #(parameter dw = 32,parameter aw = 32,parameter num_slaves = 2,parameter [num_slaves*aw-1:0] MATCH_ADDR = 0,parameter [num_slaves*aw-1:0] MATCH_MASK = 0) (input wb_clk_i,input wb_rst_i,input [aw-1:0] wbm_adr_i,input [dw-1:0] wbm_dat_i,input [3:0] wbm_sel_i,input wbm_we_i,input wbm_cyc_i,input wbm_stb_i,input [2:0] wbm_cti_i,input [1:0] wbm_bte_i,output [dw-1:0] wbm_dat_o,output wbm_ack_o,output wbm_err_o,output wbm_rty_o,output [num_slaves*aw-1:0] wbs_adr_o,output [num_slaves*dw-1:0] wbs_dat_o,output [num_slaves*4-1:0] wbs_sel_o,output [num_slaves-1:0] wbs_we_o,output [num_slaves-1:0] wbs_cyc_o,output [num_slaves-1:0] wbs_stb_o,output [num_slaves*3-1:0] wbs_cti_o,output [num_slaves*2-1:0] wbs_bte_o,input [num_slaves*dw-1:0] wbs_dat_i,input [num_slaves-1:0] wbs_ack_i,input [num_slaves-1:0] wbs_err_i,input [num_slaves-1:0] wbs_rty_i);\n [/INST]\n", "output": "parameter slave_sel_bits = num_slaves > 1 ? $clog2(num_slaves) : 1; \n  reg wbm_err; \n  wire [slave_sel_bits-1:0] slave_sel; \n  wire [num_slaves-1:0] match; \n  genvar idx; \n  generate \n  for(idx=0; idx<num_slaves ; idx=idx+1) begin : addr_match \n  assign match[idx] = (wbm_adr_i & MATCH_MASK[idx*aw+:aw]) == MATCH_ADDR[idx*aw+:aw]; \n  end \n  endgenerate \n  function [slave_sel_bits-1:0] ff1; \n  input [num_slaves-1:0] in; \n  integer i; \n  begin \n  ff1 = 0; \n  for (i = num_slaves-1; i >= 0; i=i-1) begin \n  if (in[i]) \n  ff1 = i; \n  end \n  end \n  endfunction \n  assign slave_sel = ff1(match); \n  always @(posedge wb_clk_i) \n  wbm_err <= wbm_cyc_i & !(|match); \n  assign wbs_adr_o = {num_slaves{wbm_adr_i}}; \n  assign wbs_dat_o = {num_slaves{wbm_dat_i}}; \n  assign wbs_sel_o = {num_slaves{wbm_sel_i}}; \n  assign wbs_we_o = {num_slaves{wbm_we_i}}; \n  assign wbs_cyc_o = match & (wbm_cyc_i << slave_sel); \n  assign wbs_stb_o = {num_slaves{wbm_stb_i}}; \n  assign wbs_cti_o = {num_slaves{wbm_cti_i}}; \n  assign wbs_bte_o = {num_slaves{wbm_bte_i}}; \n  assign wbm_dat_o = wbs_dat_i[slave_sel*dw+:dw]; \n  assign wbm_ack_o = wbs_ack_i[slave_sel]; \n  assign wbm_err_o = wbs_err_i[slave_sel] | wbm_err; \n  assign wbm_rty_o = wbs_rty_i[slave_sel]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes a 16-bit input and performs a left shift operation based on the 4-bit shift value, resulting in a 16-bit output.\n\n Module header:\n\nmodule left_shift(in, out, shift);\n [/INST]\n", "output": "output [15:0] out; \n input [15:0] in; \n input [3:0] shift; \n assign out = in << shift; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module instantiates a flip-flop (FFType module) with inputs clock, reset, io_in, and io_init, and outputs io_out and io_enable. The inputs and outputs of the FFType module are connected to the corresponding inputs and outputs of the top module. The flip-flop's output, io_out, is assigned to the output of the top module, and the inputs io_in, io_init, and io_enable are assigned to the corresponding inputs of the top module. The module also assigns the clock and reset inputs of the top module to the corresponding inputs of the FFType module.\n\n Module header:\n\nmodule FF_11(input clock,input reset,input io_in,input io_init,output io_out,input io_enable);\n [/INST]\n", "output": "wire ff_clock; \n  wire ff_reset; \n  wire ff_io_in; \n  wire ff_io_init; \n  wire ff_io_out; \n  wire ff_io_enable; \n FFType ff (.clock(ff_clock),.reset(ff_reset),.io_in(ff_io_in),.io_init(ff_io_init),.io_out(ff_io_out),.io_enable(ff_io_enable)); \n  assign io_out = ff_io_out; \n  assign ff_io_in = io_in; \n  assign ff_io_init = io_init; \n  assign ff_io_enable = io_enable; \n  assign ff_clock = clock; \n  assign ff_reset = reset; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module is a FIFO address gray code generator. It synchronizes address signals between two clock domains. It consists of multiple registers, always blocks, and assign statements to handle the address signals and their gray code representations. The module also handles readiness and validity signals based on the address comparisons. The design ensures proper synchronization and operation of the FIFO address signals in a multi-clock environment.\n\n Module header:\n\nmodule fifo_address_gray #(parameter ADDRESS_WIDTH = 4) (input m_axis_aclk,input m_axis_aresetn,input m_axis_ready,output reg m_axis_valid,output reg [ADDRESS_WIDTH:0] m_axis_level,input s_axis_aclk,input s_axis_aresetn,output reg s_axis_ready,input s_axis_valid,output reg s_axis_empty,output [ADDRESS_WIDTH-1:0] s_axis_waddr,output reg [ADDRESS_WIDTH:0] s_axis_room);\n [/INST]\n", "output": "reg [ADDRESS_WIDTH:0] _s_axis_waddr = 'h00; \n reg [ADDRESS_WIDTH:0] _s_axis_waddr_next; \n reg [ADDRESS_WIDTH:0] _m_axis_raddr = 'h00; \n reg [ADDRESS_WIDTH:0] _m_axis_raddr_next; \n reg [ADDRESS_WIDTH:0] s_axis_waddr_gray = 'h00; \n wire [ADDRESS_WIDTH:0] s_axis_waddr_gray_next; \n wire [ADDRESS_WIDTH:0] s_axis_raddr_gray; \n reg [ADDRESS_WIDTH:0] m_axis_raddr_gray = 'h00; \n wire [ADDRESS_WIDTH:0] m_axis_raddr_gray_next; \n wire [ADDRESS_WIDTH:0] m_axis_waddr_gray; \n assign s_axis_waddr = _s_axis_waddr[ADDRESS_WIDTH-1:0]; \n always @(*) \n begin \n  if (s_axis_ready && s_axis_valid) \n  _s_axis_waddr_next <= _s_axis_waddr + 1; \n  else \n  _s_axis_waddr_next <= _s_axis_waddr; \n end \n assign s_axis_waddr_gray_next = _s_axis_waddr_next ^ _s_axis_waddr_next[ADDRESS_WIDTH:1]; \n always @(posedge s_axis_aclk) \n begin \n  if (s_axis_aresetn == 1'b0) begin \n  _s_axis_waddr <= 'h00; \n  s_axis_waddr_gray <= 'h00; \n  end else begin \n  _s_axis_waddr <= _s_axis_waddr_next; \n  s_axis_waddr_gray <= s_axis_waddr_gray_next; \n  end \n end \n always @(*) \n begin \n  if (m_axis_ready && m_axis_valid) \n  _m_axis_raddr_next <= _m_axis_raddr + 1; \n  else \n  _m_axis_raddr_next <= _m_axis_raddr; \n end \n assign m_axis_raddr_gray_next = _m_axis_raddr_next ^ _m_axis_raddr_next[ADDRESS_WIDTH:1]; \n always @(posedge m_axis_aclk) \n begin \n  if (m_axis_aresetn == 1'b0) begin \n  _m_axis_raddr <= 'h00; \n  m_axis_raddr_gray <= 'h00; \n  end else begin \n  _m_axis_raddr <= _m_axis_raddr_next; \n  m_axis_raddr_gray <= m_axis_raddr_gray_next; \n  end \n end \n sync_bits #(.NUM_OF_BITS(ADDRESS_WIDTH + 1)) i_waddr_sync (.out_clk(m_axis_aclk),.out_resetn(m_axis_aresetn),.in(s_axis_waddr_gray),.out(m_axis_waddr_gray)); \n sync_bits #(.NUM_OF_BITS(ADDRESS_WIDTH + 1)) i_raddr_sync (.out_clk(s_axis_aclk),.out_resetn(s_axis_aresetn),.in(m_axis_raddr_gray),.out(s_axis_raddr_gray)); \n always @(posedge s_axis_aclk) \n begin \n  if (s_axis_aresetn == 1'b0) begin \n  s_axis_ready <= 1'b1; \n  s_axis_empty <= 1'b1; \n  end else begin \n s_axis_ready <= (s_axis_raddr_gray[ADDRESS_WIDTH] == s_axis_waddr_gray_next[ADDRESS_WIDTH] ||s_axis_raddr_gray[ADDRESS_WIDTH-1] == s_axis_waddr_gray_next[ADDRESS_WIDTH-1] ||s_axis_raddr_gray[ADDRESS_WIDTH-2:0] != s_axis_waddr_gray_next[ADDRESS_WIDTH-2:0]); \n  s_axis_empty <= s_axis_raddr_gray == s_axis_waddr_gray_next; \n  end \n end \n always @(posedge m_axis_aclk) \n begin \n  if (s_axis_aresetn == 1'b0) \n  m_axis_valid <= 1'b0; \n  else begin \n  m_axis_valid <= m_axis_waddr_gray != m_axis_raddr_gray_next; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module represents a data path circuit with various inputs and outputs. It contains registers and combinational logic for controlling the flow of data. The module includes multiple signals for handling the state, acknowledgment, timeout, and transfer completion. It uses logical gates and registers to manage the control signals and to derive the output values. The structure enables the manipulation and routing of data within the circuit based on the input conditions.\n\n Module header:\n\nmodule DATA(CLK, RESET_L, writeRead_Regs_DATA, blockCount_Regs_DATA, multipleData_Regs_DATA, timeout_Enable_Regs_DATA, timeout_Reg_Regs_DATA, new_DAT_DMA_DATA, serial_Ready_Phy_DATA, timeout_Phy_DATA, complete_Phy_DATA, ack_IN_Phy_DATA, fifo_OK_FIFO_DATA, transfer_complete_DATA_DMA, strobe_OUT_DATA_Phy, ack_OUT_DATA_Phy, blocks_DATA_Phy, timeout_value_DATA_Phy, writeReadPhysical_DATA_Phy, multiple_DATA_Phy, idle_out_DATA_Phy);\n [/INST]\n", "output": "wire _00_; \n  wire _01_; \n  wire _02_; \n  wire _03_; \n  wire _04_; \n  wire _05_; \n  wire _06_; \n  input CLK; \n  input RESET_L; \n  wire STATE; \n  input ack_IN_Phy_DATA; \n  output ack_OUT_DATA_Phy; \n  input [3:0] blockCount_Regs_DATA; \n  output [3:0] blocks_DATA_Phy; \n  input complete_Phy_DATA; \n  input fifo_OK_FIFO_DATA; \n  output idle_out_DATA_Phy; \n  input multipleData_Regs_DATA; \n  output multiple_DATA_Phy; \n  input new_DAT_DMA_DATA; \n  input serial_Ready_Phy_DATA; \n  output strobe_OUT_DATA_Phy; \n  input timeout_Enable_Regs_DATA; \n  input timeout_Phy_DATA; \n  input [15:0] timeout_Reg_Regs_DATA; \n  output [15:0] timeout_value_DATA_Phy; \n  output transfer_complete_DATA_DMA; \n  output writeReadPhysical_DATA_Phy; \n  input writeRead_Regs_DATA; \n NOT _07_ (.A(_02_),.Y(_03_)); \n NOT _08_ (.A(_04_),.Y(_06_)); \n DFF _09_ (.C(CLK),.D(_00_),.Q(STATE)); \n \\$_DLATCH_P_ _10_ (.D(_01_),.E(STATE),.Q(timeout_value_DATA_Phy[7])); \n  assign ack_OUT_DATA_Phy = timeout_value_DATA_Phy[7]; \n  assign blocks_DATA_Phy = { timeout_value_DATA_Phy[7], timeout_value_DATA_Phy[7], timeout_value_DATA_Phy[7], timeout_value_DATA_Phy[7] }; \n  assign multiple_DATA_Phy = timeout_value_DATA_Phy[7]; \n  assign strobe_OUT_DATA_Phy = timeout_value_DATA_Phy[7]; \n  assign { timeout_value_DATA_Phy[15:8], timeout_value_DATA_Phy[6:0] } = { timeout_value_DATA_Phy[7], timeout_value_DATA_Phy[7], timeout_value_DATA_Phy[7], timeout_value_DATA_Phy[7], timeout_value_DATA_Phy[7], timeout_value_DATA_Phy[7], timeout_value_DATA_Phy[7], timeout_value_DATA_Phy[7], timeout_value_DATA_Phy[7], timeout_value_DATA_Phy[7], timeout_value_DATA_Phy[7], timeout_value_DATA_Phy[7], timeout_value_DATA_Phy[7], timeout_value_DATA_Phy[7], timeout_value_DATA_Phy[7] }; \n  assign transfer_complete_DATA_DMA = timeout_value_DATA_Phy[7]; \n  assign writeReadPhysical_DATA_Phy = timeout_value_DATA_Phy[7]; \n  assign _05_ = 1'b0; \n  assign _02_ = RESET_L; \n  assign _00_ = _03_; \n  assign _04_ = STATE; \n  assign _01_ = _05_; \n  assign idle_out_DATA_Phy = _06_; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, \"packet_memory,\" is a memory module that supports two different input modes. When \"input_mode\" is 1, it operates in 64-bit mode, and when \"input_mode\" is 0, it operates in 32-bit mode.\n\nIn 64-bit mode, the module receives a 10-bit address \"addr64\" and 64-bit data \"data_in64.\" It then writes the data to the corresponding address and outputs the data at the specified address on the \"data_out64\" bus. It also supports byte-write enable for 8 bytes.\n\nIn 32-bit mode, the module receives an 11-bit address \"addr32\" and 32-bit data \"data_in32.\" It then writes the data to the specified address and outputs the data at the specified address on the \"data_out32\" bus. It also supports byte-write enable for 4 bytes.\n\nThe module uses registers to store the write enable signals and addresses, and it instantiates a RAM block to perform the memory read and write operations based on the input data and addresses.\n\n Module header:\n\nmodule packet_memory(clk,input_mode,addr64,data_in64,data_out64,byte_we8,addr32,data_in32,data_out32,byte_we4);\n [/INST]\n", "output": "input clk; \n input input_mode; \n input [10:3] addr64; \n input [63:0] data_in64; \n output [63:0] data_out64; \n input [7:0] byte_we8; \n input [10:2] addr32; \n input [31:0] data_in32; \n output [31:0] data_out32; \n input [3:0] byte_we4; \n reg [63:0] data_out64; \n reg [31:0] data_out32; \n reg wea0; \n reg web0; \n reg [8:0] addra0; \n reg [8:0] addrb0; \n reg [31:0] dia0; \n reg [31:0] dib0; \n wire [31:0] doa0; \n wire [31:0] dob0; \n always @(*) begin \n  wea0 = 0; \n  web0 = 0; \n  if(input_mode == 1) begin \n  addra0[8:0] = {addr64[10:3], 1'b0}; \n  addrb0[8:0] = {addr64[10:3], 1'b1}; \n  dia0 = data_in64[31:0]; \n  dib0 = data_in64[63:32]; \n  data_out64 = {dob0, doa0}; \n  if(byte_we8) begin \n  wea0 = 1; \n  web0 = 1; \n  end else begin \n  wea0 = 0; \n  web0 = 0; \n  end \n  end else begin \n  addra0[8:0] = addr32[10:2]; \n  dia0 = data_in32[31:0]; \n  data_out32 = doa0; \n  if(byte_we4) begin \n  wea0 = 1; \n  end else begin \n  wea0 = 0; \n  end \n  end \n end \n wire [3:0] dipa; \n wire [3:0] dipb; \n RAMB16_S36_S36 pm0(.DOA (doa0),.DOB (dob0),.DOPA (),.DOPB (),.ADDRA (addra0),.ADDRB (addrb0),.CLKA (clk),.CLKB (clk),.DIA (dia0),.DIB (dib0),.DIPA (dipa),.DIPB (dipb),.ENA (1'b1),.ENB (1'b1),.SSRA (reset),.SSRB (reset),.WEA (wea0),.WEB (web0)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a positive edge-triggered D flip-flop. It takes an input D and a clock signal C, and on the rising edge of the clock, the value of D is transferred to the output Q.\n\n Module header:\n\nmodule \\$_DFF_P_ (D, C, Q);\n [/INST]\n", "output": "input D, C; \n output reg Q; \n always @(posedge C) begin \n  Q <= D; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"Video_System_CPU_nios2_oci_im\" is a part of a video system and has several inputs and outputs for trace control and memory operations. It includes logic for controlling trace memory, handling trace addresses and data, and managing the trace wrap and enable signals. The module also interfaces with another module \"Video_System_CPU_traceram_lpm_dram_bdp_component_module\" for trace memory operations. Overall, the module orchestrates various trace-related functions and communicates with the trace memory module.\n\n Module header:\n\nmodule Video_System_CPU_nios2_oci_im (clk,jdo,jrst_n,reset_n,take_action_tracectrl,take_action_tracemem_a,take_action_tracemem_b,take_no_action_tracemem_a,trc_ctrl,tw,tracemem_on,tracemem_trcdata,tracemem_tw,trc_enb,trc_im_addr,trc_wrap,xbrk_wrap_traceoff);\n [/INST]\n", "output": "output tracemem_on; \n  output [ 35: 0] tracemem_trcdata; \n  output tracemem_tw; \n  output trc_enb; \n  output [ 6: 0] trc_im_addr; \n  output trc_wrap; \n  output xbrk_wrap_traceoff; \n  input clk; \n  input [ 37: 0] jdo; \n  input jrst_n; \n  input reset_n; \n  input take_action_tracectrl; \n  input take_action_tracemem_a; \n  input take_action_tracemem_b; \n  input take_no_action_tracemem_a; \n  input [ 15: 0] trc_ctrl; \n  input [ 35: 0] tw; \n  wire tracemem_on; \n  wire [ 35: 0] tracemem_trcdata; \n  wire tracemem_tw; \n  wire trc_enb; \n  reg [ 6: 0] trc_im_addr ; \n  wire [ 35: 0] trc_im_data; \n  reg [ 16: 0] trc_jtag_addr ; \n  wire [ 35: 0] trc_jtag_data; \n  wire trc_on_chip; \n  reg trc_wrap ; \n  wire tw_valid; \n  wire [ 35: 0] unused_bdpram_port_q_a; \n  wire xbrk_wrap_traceoff; \n  assign trc_im_data = tw; \n  always @(posedge clk or negedge jrst_n) \n  begin \n  if (jrst_n == 0) \n  begin \n  trc_im_addr <= 0; \n  trc_wrap <= 0; \n  end \n  else if (!0) \n  begin \n  trc_im_addr <= 0; \n  trc_wrap <= 0; \n  end \n else if (take_action_tracectrl &&(jdo[4] | jdo[3])) \n  begin \n  if (jdo[4]) \n  trc_im_addr <= 0; \n  if (jdo[3]) \n  trc_wrap <= 0; \n  end \n  else if (trc_enb & trc_on_chip & tw_valid) \n  begin \n  trc_im_addr <= trc_im_addr+1; \n  if (&trc_im_addr) \n  trc_wrap <= 1; \n  end \n  end \n  always @(posedge clk or negedge reset_n) \n  begin \n  if (reset_n == 0) \n  trc_jtag_addr <= 0; \n else if (take_action_tracemem_a ||take_no_action_tracemem_a ||take_action_tracemem_b) \n  trc_jtag_addr <= take_action_tracemem_a ? \n  jdo[35 : 19] : \n  trc_jtag_addr + 1; \n  end \n  assign trc_enb = trc_ctrl[0]; \n  assign trc_on_chip = ~trc_ctrl[8]; \n  assign tw_valid = |trc_im_data[35 : 32]; \n  assign xbrk_wrap_traceoff = trc_ctrl[10] & trc_wrap; \n  assign tracemem_trcdata = (0) ? \n  trc_jtag_data : 0; \n  assign tracemem_tw = trc_wrap; \n  assign tracemem_on = trc_enb; \n Video_System_CPU_traceram_lpm_dram_bdp_component_module Video_System_CPU_traceram_lpm_dram_bdp_component \n (.address_a (trc_im_addr),.address_b (trc_jtag_addr),.clock0 (clk),.clock1 (clk),.clocken0 (1'b1),.clocken1 (1'b1),.data_a (trc_im_data),.data_b (jdo[36 : 1]),.q_a (unused_bdpram_port_q_a),.q_b (trc_jtag_data),.wren_a (tw_valid & trc_enb),.wren_b (take_action_tracemem_b)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an input/output buffer with configurable settings such as current strength, slew rate, location, bus hold enable, weak pull-up resistor, termination, and LPM type. The module assigns the value of the io signal based on the oe input, and outputs the value of the io signal. When oe is high, it forwards the input i to the output o. Otherwise, it sets the output io to high impedance (z).\n\n Module header:\n\nmodule alt_iobuf (i, oe, io, o);\n [/INST]\n", "output": "input i; \n  input oe; \n  inout io; \n  output o; \n  reg o; \n  parameter io_standard = \"NONE\"; \n  parameter current_strength = \"NONE\"; \n  parameter current_strength_new = \"NONE\"; \n  parameter slew_rate = -1; \n  parameter slow_slew_rate = \"NONE\"; \n  parameter location = \"NONE\"; \n  parameter enable_bus_hold = \"NONE\"; \n  parameter weak_pull_up_resistor = \"NONE\"; \n  parameter termination = \"NONE\"; \n  parameter input_termination = \"NONE\"; \n  parameter output_termination = \"NONE\"; \n  parameter lpm_type = \"alt_iobuf\"; \n  always @(io) \n  begin \n  o = io; \n  end \n  assign io = (oe == 1) ? i : 1'bz; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a UART transmitter. It takes in clock, reset, ce_16, tx_data, and new_tx_data as inputs, and outputs ser_out and tx_busy. The module uses various registers and counters to handle the transmission process. It generates the serial output signal and manages the transmission status based on the input signals and the state of the transmission process. The module uses the clock and reset signals to synchronize its internal operations and update its outputs.\n\n Module header:\n\nmodule uart_tx (clock, reset,ce_16, tx_data, new_tx_data,ser_out, tx_busy);\n [/INST]\n", "output": "input clock; \n input reset; \n input ce_16; \n input [7:0] tx_data; \n input new_tx_data; \n output ser_out; \n output tx_busy; \n wire ce_1; \n reg ser_out; \n reg tx_busy; \n reg [3:0] count16; \n reg [3:0] bit_count; \n reg [8:0] data_buf; \n always @ (posedge clock or posedge reset) \n begin \n  if (reset) \n  count16 <= 4'b0; \n  else if (tx_busy & ce_16) \n  count16 <= count16 + 4'b1; \n  else if (~tx_busy) \n  count16 <= 4'b0; \n end \n assign ce_1 = (count16 == 4'b1111) & ce_16; \n always @ (posedge clock or posedge reset) \n begin \n  if (reset) \n  tx_busy <= 1'b0; \n  else if (~tx_busy & new_tx_data) \n  tx_busy <= 1'b1; \n  else if (tx_busy & (bit_count == 4'h9) & ce_1) \n  tx_busy <= 1'b0; \n end \n always @ (posedge clock or posedge reset) \n begin \n  if (reset) \n  bit_count <= 4'h0; \n  else if (tx_busy & ce_1) \n  bit_count <= bit_count + 4'h1; \n  else if (~tx_busy) \n  bit_count <= 4'h0; \n end \n always @ (posedge clock or posedge reset) \n begin \n  if (reset) \n  data_buf <= 9'b0; \n  else if (~tx_busy) \n  data_buf <= {tx_data, 1'b0}; \n  else if (tx_busy & ce_1) \n  data_buf <= {1'b1, data_buf[8:1]}; \n end \n always @ (posedge clock or posedge reset) \n begin \n  if (reset) \n  ser_out <= 1'b1; \n  else if (tx_busy) \n  ser_out <= data_buf[0]; \n  else \n  ser_out <= 1'b1; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes a 4-bit BCD input and converts it into a 7-segment display format. It uses a case statement to assign the appropriate 8-bit segment data based on the BCD input. If the input does not match any of the defined BCD values, all segments are turned off.\n\n Module header:\n\nmodule bcd_to_segment (input [3:0] bcd_data,output reg [7:0] seg_data);\n [/INST]\n", "output": "always @(bcd_data) begin \n  case (bcd_data) \n  4'b0000: seg_data <= 8'b11000000; \n  4'b0001: seg_data <= 8'b11111001; \n  4'b0010: seg_data <= 8'b10100100; \n  4'b0011: seg_data <= 8'b10110000; \n  4'b0100: seg_data <= 8'b10011001; \n  4'b0101: seg_data <= 8'b10010010; \n  4'b0110: seg_data <= 8'b10000010; \n  4'b0111: seg_data <= 8'b11111000; \n  4'b1000: seg_data <= 8'b10000000; \n  4'b1001: seg_data <= 8'b10010000; \n  4'b1010: seg_data <= 8'b01111111; \n  default: seg_data <= 8'b11111111; \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a FIFO memory with read and write operations. It uses a memory array to store data and updates the read and write addresses based on the clock and control signals. The module outputs the data stored at the read address and updates the memory array with new data at the write address when the write enable signal is asserted. The read address is updated based on the read address input and the read clock signal, while the write address and data are updated based on the write address, write clock, and write enable signals.\n\n Module header:\n\nmodule soc_design_dma_fifo_module_fifo_ram_module (clk,data,rdaddress,rdclken,reset_n,wraddress,wrclock,wren,q);\n [/INST]\n", "output": "output [ 15: 0] q; \n  input clk; \n  input [ 15: 0] data; \n  input [ 4: 0] rdaddress; \n  input rdclken; \n  input reset_n; \n  input [ 4: 0] wraddress; \n  input wrclock; \n  input wren; \n  reg [ 15: 0] mem_array [ 31: 0]; \n  wire [ 15: 0] q; \n  reg [ 4: 0] read_address; \n  always @(posedge clk or negedge reset_n) \n  begin \n  if (reset_n == 0) \n  read_address <= 0; \n  else if (rdclken) \n  read_address <= rdaddress; \n  end \n  assign q = mem_array[read_address]; \n  always @(posedge wrclock) \n  begin \n  if (wren) \n  mem_array[wraddress] <= data; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a result counter with inputs for resultID, newresult, reset, globalreset, and clk, and outputs for done. It uses a count register to decrement upon specific conditions being met, and updates the curr value based on the resultID. The module also includes a big_reset signal to reset the count and curr values. The done signal is assigned based on the count and curr values.\n\n Module header:\n\n module resultcounter (resultID, newresult, done, reset, globalreset, clk);\n [/INST]\n", "output": "input[1:0] resultID; \n  input newresult; \n  output[1:0] done; \n  wire[1:0] done; \n  input reset; \n  input globalreset; \n  input clk; \n  wire big_reset; \n  reg[3:0] count; \n  reg[1:0] curr; \n  assign done = (count == 0) ? curr : 2'b00 ; \n  assign big_reset = globalreset | reset; \n  always @(posedge clk or posedge big_reset) \n  begin \n  if (big_reset == 1'b1) \n  begin \n  count <= 4'b1000 ; \n  curr <= 0; \n  end \n  else \n  begin \n  if ((resultID != 0) & (newresult == 1'b1) & (count != 0)) \n  begin \n  count <= count - 1 ; \n  curr <= resultID ; \n  end \n  end \n  end \n  endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an UART (Universal Asynchronous Receiver/Transmitter) with input and output ports for communication. It has various sub-modules for transmitting and receiving data, handling registers, and controlling the baud rate. The module supports data transmission and reception, error detection, and control signals for flow control and status indications. The top-level module connects these sub-modules and provides the necessary input and output ports for interfacing with other components in the system.\n\n Module header:\n\nmodule NIOS_Sys_uart_0 (address,begintransfer,chipselect,clk,read_n,reset_n,rxd,write_n,writedata,dataavailable,irq,readdata,readyfordata,txd);\n [/INST]\n", "output": "output dataavailable; \n  output irq; \n  output [ 15: 0] readdata; \n  output readyfordata; \n  output txd; \n  input [ 2: 0] address; \n  input begintransfer; \n  input chipselect; \n  input clk; \n  input read_n; \n  input reset_n; \n  input rxd; \n  input write_n; \n  input [ 15: 0] writedata; \n  wire [ 8: 0] baud_divisor; \n  wire break_detect; \n  wire clk_en; \n  wire dataavailable; \n  wire do_force_break; \n  wire framing_error; \n  wire irq; \n  wire parity_error; \n  wire [ 15: 0] readdata; \n  wire readyfordata; \n  wire rx_char_ready; \n  wire [ 7: 0] rx_data; \n  wire rx_overrun; \n  wire rx_rd_strobe; \n  wire status_wr_strobe; \n  wire [ 7: 0] tx_data; \n  wire tx_overrun; \n  wire tx_ready; \n  wire tx_shift_empty; \n  wire tx_wr_strobe; \n  wire txd; \n  assign clk_en = 1; \n  NIOS_Sys_uart_0_tx the_NIOS_Sys_uart_0_tx \n (.baud_divisor (baud_divisor),.begintransfer (begintransfer),.clk (clk),.clk_en (clk_en),.do_force_break (do_force_break),.reset_n (reset_n),.status_wr_strobe (status_wr_strobe),.tx_data (tx_data),.tx_overrun (tx_overrun),.tx_ready (tx_ready),.tx_shift_empty (tx_shift_empty),.tx_wr_strobe (tx_wr_strobe),.txd (txd)); \n  NIOS_Sys_uart_0_rx the_NIOS_Sys_uart_0_rx \n (.baud_divisor (baud_divisor),.begintransfer (begintransfer),.break_detect (break_detect),.clk (clk),.clk_en (clk_en),.framing_error (framing_error),.parity_error (parity_error),.reset_n (reset_n),.rx_char_ready (rx_char_ready),.rx_data (rx_data),.rx_overrun (rx_overrun),.rx_rd_strobe (rx_rd_strobe),.rxd (rxd),.status_wr_strobe (status_wr_strobe)); \n  NIOS_Sys_uart_0_regs the_NIOS_Sys_uart_0_regs \n (.address (address),.baud_divisor (baud_divisor),.break_detect (break_detect),.chipselect (chipselect),.clk (clk),.clk_en (clk_en),.dataavailable (dataavailable),.do_force_break (do_force_break),.framing_error (framing_error),.irq (irq),.parity_error (parity_error),.read_n (read_n),.readdata (readdata),.readyfordata (readyfordata),.reset_n (reset_n),.rx_char_ready (rx_char_ready),.rx_data (rx_data),.rx_overrun (rx_overrun),.rx_rd_strobe (rx_rd_strobe),.status_wr_strobe (status_wr_strobe),.tx_data (tx_data),.tx_overrun (tx_overrun),.tx_ready (tx_ready),.tx_shift_empty (tx_shift_empty),.tx_wr_strobe (tx_wr_strobe),.write_n (write_n),.writedata (writedata)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a D flip-flop with an asynchronous reset and an enable input. The output Q is updated on the falling edge of the clock signal C or the rising edge of the reset signal R. When R is asserted, Q is set to 1. Otherwise, if the enable input E is 0, Q is updated with the input D.\n\n Module header:\n\nmodule \\$_DFFE_NP1N_ (D, C, R, E, Q);\n [/INST]\n", "output": "input D, C, R, E; \n output reg Q; \n always @(negedge C or posedge R) begin \n  if (R == 1) \n  Q <= 1; \n  else if (E == 0) \n  Q <= D; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a 18x18 signed multiplier. It multiplies two 18-bit signed inputs A and B, and the result is stored in the 36-bit output P. The multiplication is triggered on the rising edge of the C signal and controlled by the CE and R inputs. If R is asserted, the output P is cleared. If CE is asserted, the product p_in is assigned to the output P.\n\n Module header:\n\nmodule MULT18X18S (output reg [35:0] P,input [17:0] A,input [17:0] B,input C, CE, R);\n [/INST]\n", "output": "wire [35:0] a_in = { {18{A[17]}}, A[17:0] }; \n  wire [35:0] b_in = { {18{B[17]}}, B[17:0] }; \n  wire [35:0] p_in; \n  reg [35:0] p_out; \n  assign p_in = a_in * b_in; \n  always @(posedge C) \n  if (R) \n  P <= 36'b0; \n  else if (CE) \n  P <= p_in; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a First Word Fall Through (FWFT) FIFO with separate input and output clocks. It includes features such as reset, input and output data, and ready and valid signals. The module uses two clock domains and a configurable data width. Additionally, it generates different FIFO configurations based on the data width, with options for 36Kb and 18Kb FIFO sizes. The module handles data writing, reading, and pointer updates, and also includes almost empty and almost full flags for managing FIFO operations.\n\n Module header:\n\nmodule fwft_fifo (input reset,input i_clock,input [NBITS-1:0] i_data,input i_valid,output i_ready,input o_clock,input o_read,output [NBITS-1:0] o_data,output o_valid,output o_almost_empty);\n [/INST]\n", "output": "parameter NBITS = 64; \n  parameter FULL_OFFSET = 9'h080; \n `ifdef SIM \n  reg [NBITS-1:0] fifo[0:511]; \n  reg [NBITS-1:0] a_d, b_d; \n  reg a_v, b_v; \n  wire a_cken = (p_out != p_in) && (~a_v | ~b_v | c_cken); \n  wire b_cken = a_v && (~b_v | c_cken); \n  wire c_cken = o_read; \n  reg [8:0] p_in, p_out; \n  wire [8:0] count = p_in - p_out; \n  assign o_valid = b_v; \n  assign o_data = b_d; \n  assign i_ready = (count < 384); \n  assign o_almost_empty = ((count + a_v + b_v) < 16); \n  always @ (posedge i_clock) \n  begin \n  if(i_valid) \n  fifo[p_in] <= i_data; \n  p_in <= reset ? 1'b0 : p_in + i_valid; \n  end \n  always @ (posedge o_clock) \n  begin \n  p_out <= reset ? 1'b0 : p_out + a_cken; \n  a_v <= reset ? 1'b0 : a_cken | (a_v && ~b_cken); \n  if(a_cken) \n  a_d <= fifo[p_out]; \n  b_v <= reset ? 1'b0 : b_cken | (b_v && ~c_cken); \n  if(b_cken) \n  b_d <= a_d; \n  end \n `else \n  wire empty, almostfull; \n  assign i_ready = ~almostfull; \n  assign o_valid = ~empty; \n  generate \n  if(NBITS>36) begin : fifo_36 \n  FIFO_DUALCLOCK_MACRO \n #(.ALMOST_EMPTY_OFFSET(9'h00F),.ALMOST_FULL_OFFSET(FULL_OFFSET),.DATA_WIDTH(NBITS),.DEVICE(\"7SERIES\"),.FIFO_SIZE (\"36Kb\"),.FIRST_WORD_FALL_THROUGH (\"TRUE\")) \n  FIFO_DUALCLOCK_MACRO_inst \n (.ALMOSTEMPTY(o_almost_empty),.ALMOSTFULL(almostfull),.DO(o_data),.EMPTY(empty),.FULL(),.RDCOUNT(),.RDERR(),.WRCOUNT(),.WRERR(),.DI(i_data),.RDCLK(o_clock),.RDEN(o_read),.RST(reset),.WRCLK(i_clock),.WREN(i_valid)); \n  end \n  else begin : fifo_18 \n  FIFO_DUALCLOCK_MACRO \n #(.ALMOST_EMPTY_OFFSET(9'h00F),.ALMOST_FULL_OFFSET(FULL_OFFSET),.DATA_WIDTH(NBITS),.DEVICE(\"7SERIES\"),.FIFO_SIZE (\"18Kb\"),.FIRST_WORD_FALL_THROUGH (\"TRUE\")) \n  FIFO_DUALCLOCK_MACRO_inst \n (.ALMOSTEMPTY(o_almost_empty),.ALMOSTFULL(almostfull),.DO(o_data),.EMPTY(empty),.FULL(),.RDCOUNT(),.RDERR(),.WRCOUNT(),.WRERR(),.DI(i_data),.RDCLK(o_clock),.RDEN(o_read),.RST(reset),.WRCLK(i_clock),.WREN(i_valid)); \n  end \n  endgenerate \n `endif \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module M_uxa_ps2_busctl implements a bus control unit. It has input signals sys_clk_i, sys_reset_i, wb_we_i, wb_stb_i, wb_dat_8_i, and wb_dat_9_i, and outputs wb_ack_o, rp_inc_o, c_oe_o, and d_oe_o. It contains registers for wb_ack, c_oe, d_oe, and rp_inc, and uses combinational logic to generate the outputs based on the input signals and clock pulses. The module handles reset pulses, pulse generation, and output enable signals based on the input conditions and clock signal.\n\n Module header:\n\nmodule M_uxa_ps2_busctl(input sys_clk_i,input sys_reset_i,input wb_we_i,input wb_stb_i,input wb_dat_8_i,input wb_dat_9_i,output wb_ack_o,output rp_inc_o,output c_oe_o,output d_oe_o);\n [/INST]\n", "output": "reg wb_ack; \n  assign wb_ack_o = wb_ack; \n  reg c_oe; \n  reg d_oe; \n  assign c_oe_o = c_oe; \n  assign d_oe_o = d_oe; \n  reg rp_inc; \n  wire rp_inc_n = (~sys_reset_i & wb_stb_i & wb_we_i); \n  assign rp_inc_o = rp_inc; \n  always @(posedge sys_clk_i) begin \n  if (sys_reset_i) begin \n  c_oe <= 0; \n  d_oe <= 0; \n  rp_inc <= 0; \n  wb_ack <= 0; \n  end else begin \n  wb_ack <= ~wb_ack & wb_stb_i; \n  rp_inc <= rp_inc_n; \n  if(wb_stb_i & wb_we_i) begin \n  c_oe <= ~wb_dat_9_i; \n  d_oe <= ~wb_dat_8_i; \n  end \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a dual-port synchronous Block RAM (BRAM) with separate read and write ports. The BRAM has configurable parameters for the address width (AWIDTH) and data width (DWIDTH). It stores data in a memory array and provides read and write access through the read control enable (rce) and write control enable (wce) signals, along with the corresponding address (ra/wa) and data (wd) inputs. The module initializes the memory with all elements set to zero.\n\n Module header:\n\nmodule BRAM_TDP #(parameter AWIDTH = 9,parameter DWIDTH = 32)(clk_a,rce_a,ra_a,rq_a,wce_a,wa_a,wd_a,clk_b,rce_b,ra_b,rq_b,wce_b,wa_b,wd_b);\n [/INST]\n", "output": "input clk_a; \n  input rce_a; \n  input [AWIDTH-1:0] ra_a; \n  output reg [DWIDTH-1:0] rq_a; \n  input wce_a; \n  input [AWIDTH-1:0] wa_a; \n  input [DWIDTH-1:0] wd_a; \n  input clk_b; \n  input rce_b; \n  input [AWIDTH-1:0] ra_b; \n  output reg [DWIDTH-1:0] rq_b; \n  input wce_b; \n  input [AWIDTH-1:0] wa_b; \n  input [DWIDTH-1:0] wd_b; \n  reg [DWIDTH-1:0] memory[0:(1<<AWIDTH)-1]; \n  always @(posedge clk_a) begin \n  if (rce_a) \n  rq_a <= memory[ra_a]; \n  if (wce_a) \n  memory[wa_a] <= wd_a; \n  end \n  always @(posedge clk_b) begin \n  if (rce_b) \n  rq_b <= memory[ra_b]; \n  if (wce_b) \n  memory[wa_b] <= wd_b; \n  end \n  integer i; \n  initial \n  begin \n  for(i = 0; i < (1<<AWIDTH)-1; i = i + 1) \n  memory[i] = 0; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module `sctag_dirg_buf` serves as a buffer for storing directory information. It takes in directory write request parameters, directory validation, lookup address, and tag directory lookup address as inputs. The module provides output buffers for write and read data. It combines the input signals to form the output data buffers.\n\n Module header:\n\nmodule sctag_dirg_buf(lkup_wr_data_up_buf, lkup_wr_data_dn_buf,dirrep_dir_wr_par_c4, dir_vld_c4_l, lkup_addr8_c4,tagdp_lkup_addr_c4);\n [/INST]\n", "output": "input dirrep_dir_wr_par_c4; \n input dir_vld_c4_l; \n input lkup_addr8_c4; \n input [39:10] tagdp_lkup_addr_c4; \n output [32:0] lkup_wr_data_up_buf; \n output [32:0] lkup_wr_data_dn_buf; \n assign lkup_wr_data_up_buf = { tagdp_lkup_addr_c4, lkup_addr8_c4, dirrep_dir_wr_par_c4, dir_vld_c4_l }; \n assign lkup_wr_data_dn_buf = { tagdp_lkup_addr_c4 , lkup_addr8_c4, dirrep_dir_wr_par_c4, dir_vld_c4_l }; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module \\$pmux has a parameter WIDTH that is used to define the width of the input A and output Y. It also has another parameter S_WIDTH which defines the number of selectors in input S. The module implements a priority multiplexer. When a selector in input S is active, the corresponding portion of input B is selected and assigned to output Y. If no selector is active, input A is assigned to output Y. The module uses a for loop to iterate through each bit in S to determine the active selector and perform the multiplexing.\n\n Module header:\n\nmodule \\$pmux (A, B, S, Y);\n [/INST]\n", "output": "parameter WIDTH = 0; \n parameter S_WIDTH = 0; \n input [WIDTH-1:0] A; \n input [WIDTH*S_WIDTH-1:0] B; \n input [S_WIDTH-1:0] S; \n output reg [WIDTH-1:0] Y; \n integer i; \n reg found_active_sel_bit; \n always @* begin \n  Y = A; \n  found_active_sel_bit = 0; \n  for (i = 0; i < S_WIDTH; i = i+1) \n  if (S[i]) begin \n  Y = found_active_sel_bit ? 'bx : B >> (WIDTH*i); \n  found_active_sel_bit = 1; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module represents a Memory-Mapped I/O (MIO) module for an LC-3 processor. It interfaces with memory, keyboard, and display by reading and writing data based on control signals. The module includes a memory address register, memory data register, and logic to control memory access. It also incorporates components for interfacing with the keyboard and display, as well as logic for selecting the appropriate data based on the input multiplexer control signal. The module outputs data to the memory, keyboard, or display based on the control signals and input multiplexer selection.\n\n Module header:\n\nmodule LC3_MIO(input clk,input reset,input [15:0] DATABUS,input MIO_EN,input R_W,input LD_MAR,input LD_MDR,input GateMDR,output [15:0] MDRbus_out,output KB_INT,output R,input LD_char,input [7:0] I_char,output [15:0] DDR,output WR_DDR);\n [/INST]\n", "output": "wire [1:0] INMUX; \n  wire LD_KBSR; \n  wire MEM_EN; \n  wire LD_DSR; \n  wire LD_DDR; \n  wire RD_KBDR; \n  wire [15:0] MEMout; \n  wire [15:0] KBSR; \n  wire [15:0] KBDR; \n  wire [15:0] DSR; \n  reg [15:0] MAR; \n  wire [15:0] MARin; \n  assign MARin=DATABUS; \n  always@(posedge clk) if (LD_MAR) \n  MAR<=MARin; \n  reg [15:0] MDR; \n  wire [15:0] MDRin; \n  reg [15:0] MIOout; \n  assign MDRin=DATABUS; \n  always@(posedge clk) if (LD_MDR) begin \n  if(MIO_EN) \n  MDR<=MIOout; \n  else \n  MDR<=MDRin; \n  end \n LC3_MIO_ADDRCTL inst_addrctl(.clk (clk),.ADDR (MAR),.MIO_EN (MIO_EN),.R_W (R_W),.INMUX (INMUX),.MEM_EN (MEM_EN),.LD_KBSR (LD_KBSR),.LD_DSR (LD_DSR),.LD_DDR (LD_DDR),.RD_KBDR (RD_KBDR),.R (R)); \n LC3_MEMORY inst_memory(.clk (clk),.ADDR (MAR),.DATAin (MDR),.R_W (R_W),.MEM_EN (MEM_EN),.MEMout (MEMout)); \n LC3_keyboard_reg inst_keyboard_reg(.clk (clk),.reset (reset),.LD_KBSR (LD_KBSR),.RD_KBDR (RD_KBDR),.DATA (MDR),.I_char (I_char),.LD_char (LD_char),.KBDR (KBDR),.KBSR (KBSR),.KB_INT (KB_INT)); \n LC3_screen_reg insr_screen_reg(.clk (clk),.LD_DDR (LD_DDR),.LD_DSR (LD_DSR),.DATA (MDR),.DSR (DSR),.DDR (DDR),.WR_DDR (WR_DDR)); \n  always@(*) begin \n  case (INMUX) \n  2'b00: MIOout=KBSR; \n  2'b01: MIOout=KBDR; \n  2'b10: MIOout=DSR; \n  2'b11: MIOout=MEMout; \n  endcase \n  end \n  assign MDRbus_out=(GateMDR?MDR:16'bz); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes inputs out_0r, inp_0a, and inp_0d and provides outputs out_0a and out_0d. It also includes a gnd cell instance to provide a ground connection. The module performs a series of assignments to the outputs based on the input values, and ensures that the gnd connection is made at specific bits in the output signal.\n\n Module header:\n\nmodule BrzAdapt_33_17_s5_false_s5_false (out_0r, out_0a, out_0d,inp_0r, inp_0a, inp_0d);\n [/INST]\n", "output": "input out_0r; \n  output out_0a; \n  output [32:0] out_0d; \n  output inp_0r; \n  input inp_0a; \n  input [16:0] inp_0d; \n  wire extend_0n; \n  wire gnd; \n  GND gnd_cell_instance (gnd); \n  assign out_0a = inp_0a; \n  assign inp_0r = out_0r; \n  assign out_0d[17] = gnd; \n  assign out_0d[18] = gnd; \n  assign out_0d[19] = gnd; \n  assign out_0d[20] = gnd; \n  assign out_0d[21] = gnd; \n  assign out_0d[22] = gnd; \n  assign out_0d[23] = gnd; \n  assign out_0d[24] = gnd; \n  assign out_0d[25] = gnd; \n  assign out_0d[26] = gnd; \n  assign out_0d[27] = gnd; \n  assign out_0d[28] = gnd; \n  assign out_0d[29] = gnd; \n  assign out_0d[30] = gnd; \n  assign out_0d[31] = gnd; \n  assign out_0d[32] = gnd; \n  assign out_0d[0] = inp_0d[0]; \n  assign out_0d[1] = inp_0d[1]; \n  assign out_0d[2] = inp_0d[2]; \n  assign out_0d[3] = inp_0d[3]; \n  assign out_0d[4] = inp_0d[4]; \n  assign out_0d[5] = inp_0d[5]; \n  assign out_0d[6] = inp_0d[6]; \n  assign out_0d[7] = inp_0d[7]; \n  assign out_0d[8] = inp_0d[8]; \n  assign out_0d[9] = inp_0d[9]; \n  assign out_0d[10] = inp_0d[10]; \n  assign out_0d[11] = inp_0d[11]; \n  assign out_0d[12] = inp_0d[12]; \n  assign out_0d[13] = inp_0d[13]; \n  assign out_0d[14] = inp_0d[14]; \n  assign out_0d[15] = inp_0d[15]; \n  assign out_0d[16] = inp_0d[16]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a tristate buffer with an interceptor. It takes in the lock and interceptorOutput signals as inputs and produces the interceptorInput signal as output. The dataLine signal is used as an inout wire. The module includes a tri-state buffer, an inverter, and an OR gate to control the data flow based on the lock signal. When the lock is asserted, the module allows data to pass through the tristate buffer to the dataLine; otherwise, the dataLine is isolated.\n\n Module header:\n\nmodule tristate_3 ( lock, interceptorOutput, interceptorInput, dataLine );\n [/INST]\n", "output": "input lock, interceptorOutput; \n  output interceptorInput; \n  inout dataLine; \n  wire N1, n1; \n  tri dataLine; \n  assign interceptorInput = N1; \n  TBUFX1 dataLine_tri ( .A(n1), .EN(lock), .Y(dataLine) ); \n  INVX1 U1 ( .A(interceptorOutput), .Y(n1) ); \n  OR2X1 U2 ( .A(dataLine), .B(lock), .Y(N1) ); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a 16x16 cross product calculation. It takes input vectors A and B (each with x, y, and z components) and computes the cross product into the output vectors Cx, Cy, and Cz. The cross product calculation is performed in a clocked always block, and the intermediate results are stored in registers AyBz, AzBy, AzBx, AxBz, AxBy, and AyBx. The results are then combined to calculate Cx, Cy, and Cz using subtractive operations. The entire computation is synchronized to the clock signal.\n\n Module header:\n\n module crossproduct16x16 (Ax, Ay, Az, Bx, By, Bz, Cx, Cy, Cz, clk);\n [/INST]\n", "output": "input[16 - 1:0] Ax; \n  input[16 - 1:0] Ay; \n  input[16 - 1:0] Az; \n  input[16 - 1:0] Bx; \n  input[16 - 1:0] By; \n  input[16 - 1:0] Bz; \n  output[16 + 16:0] Cx; \n  reg[16 + 16:0] Cx; \n  output[16 + 16:0] Cy; \n  reg[16 + 16:0] Cy; \n  output[16 + 16:0] Cz; \n  reg[16 + 16:0] Cz; \n  input clk; \n  reg[16 + 16 - 1:0] AyBz; \n  reg[16 + 16 - 1:0] AzBy; \n  reg[16 + 16 - 1:0] AzBx; \n  reg[16 + 16 - 1:0] AxBz; \n  reg[16 + 16 - 1:0] AxBy; \n  reg[16 + 16 - 1:0] AyBx; \n  always @(posedge clk) \n  begin \n  AyBz <= Ay * Bz ; \n  AzBy <= Az * By ; \n  AzBx <= Az * Bx ; \n  AxBz <= Ax * Bz ; \n  AxBy <= Ax * By ; \n  AyBx <= Ay * Bx ; \n  Cx <= ({AyBz[16 + 16 - 1], AyBz}) - ({AzBy[16 + 16 - 1], AzBy}) ; \n  Cy <= ({AzBx[16 + 16 - 1], AzBx}) - ({AxBz[16 + 16 - 1], AxBz}) ; \n  Cz <= ({AxBy[16 + 16 - 1], AxBy}) - ({AyBx[16 + 16 - 1], AyBx}) ; \n  end \n  endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a synchronous design with multiple flip-flops and logic gates to control the behavior of signals. It uses various input signals such as d, si, sib, pll_out, pll_out_l, and se to generate output signals so, sob, and out. The module includes instances of different sub-modules, such as bw_u1_soffi_4x and bw_u1_soffi_8x, to perform specific operations on the input signals and generate the desired output signals. The sub-modules use flip-flops, logical operations, and clock signals to synchronize and manipulate the input signals to produce the output signals. Overall, the module serves to coordinate and control the flow of signals based on the specified logic and timing.\n\n Module header:\n\nmodule bw_zzctu_sync (so, out, sob,d, si, sib, pll_out, pll_out_l, se);\n [/INST]\n", "output": "input d; \n input si; \n input sib; \n input pll_out; \n input pll_out_l; \n input se; \n output so; \n output sob; \n output out; \n wire ql1, ql2; \n wire so1, so2; \n wire pll_out_inv; \n  assign pll_out_inv = ~pll_out; \n bw_u1_soffi_4x u_I0(.q_l (ql1),.so (so),.ck (pll_out),.d (d),.se (se),.sd (si)); \n bw_u1_soffi_4x u_I1(.q_l (ql2),.so (sob1),.ck (pll_out_inv),.d (ql1),.se (se),.sd (sib)); \n bw_u1_soff_8x u_I2(.q (out),.so (sob ),.ck (pll_out_l),.d (ql2),.se (se),.sd (sob1)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a testbench for a 4-bit adder. It instantiates four 4-bit adder modules to perform the addition in stages. It also defines clock signals and initializes the inputs A and B. Additionally, it increments the input A on every rising edge of the clock signal. This testbench is designed to simulate the behavior of the 4-bit adder by providing stimulus inputs and observing the outputs.\n\n Module header:\n\n module proj2_testbench_3;\n [/INST]\n", "output": "wire [15:0] sum; \n  wire [3:0] cout; \n  wire P, G; \n  reg [15:0] A, B; \n  reg clk; \n  add4_LA A1(A[3:0], B[3:0], 1'b0, sum[3:0], cout[0], P, G); \n  add4_LA A2(A[7:4], B[7:4], cout[0], sum[7:4], cout[1], P, G); \n  add4_LA A3(A[11:8], B[11:8], cout[1], sum[11:8], cout[2], P, G); \n  add4_LA A4(A[15:12], B[15:12], cout[2], sum[15:12], cout[3], P, G); \n  always \n  #5 clk =~clk; \n  initial begin \n  clk = 1'b0; \n  A = 4'h0; \n  B = 4'h1; \n  end \n  always @(posedge clk) \n  A=A+1; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, named \"cdb\", acts as a central database (CDB) that arbitrates between two requesters to access its resources. It contains inputs for clock, reset, two request signals, data and tag inputs for each request, and outputs for granting access to each requester, as well as outputs for the selected data, tag, and validity of the selected request.\n\nInternally, it uses an arbiter to prioritize and grant access to the requesters. Based on the granted access, it selects the corresponding data and tag and sets the validity of the selected request.\n\nThe module's behavior is determined by the granted access signals, which decide the output data, tag, and validity. When one requester is granted access, the corresponding data, tag, and validity are set. If no request is granted, the outputs are set to zero.\n\nOverall, the module manages and grants access to its resources based on the incoming requests, ensuring fair and timely access for the requesters.\n\n Module header:\n\nmodule cdb (input clk,input rst,input cdb_req0,input cdb_req1,input [31:0] cdb_data0,input [3:0] cdb_tag0,input [31:0] cdb_data1,input [3:0] cdb_tag1,output cdb_grant0,output cdb_grant1,output reg [31:0] cdb_data,output reg [3:0] cdb_tag,output reg cdb_valid);\n [/INST]\n", "output": "wire [1:0] cdb_grant; \n arbiter #(.WIDTH(2)) u_arbiter_cdb (.req ({cdb_req0, cdb_req1}),.clk (clk),.rst (rst),.enable (1'b1),.grant ({cdb_grant0, cdb_grant1}),.anyreq()); \n  always @(*) begin \n  case ({cdb_grant0,cdb_grant1}) \n  2'b01: begin \n  cdb_data <= cdb_data1; \n  cdb_tag <= cdb_tag1; \n  cdb_valid <= 1'b1; \n  end \n  2'b10: begin \n  cdb_data <= cdb_data0; \n  cdb_tag <= cdb_tag0; \n  cdb_valid <= 1'b1; \n  end \n  default: begin \n  cdb_data <= 0; \n  cdb_tag <= 0; \n  cdb_valid <= 1'b0; \n  end \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"indicators\" takes in various control signals and status information and generates outputs for indicators such as LEDs and 7-segment displays. It uses flip-flops to store state information and logic gates to combine signals for display. The 7-segment displays are driven by sseg_decode modules, and the LEDs are controlled based on the input signals, status, and system status. The outputs are updated based on the clock signal and reset condition. The module also assigns specific values to certain outputs based on the inputs and status information.\n\n Module header:\n\nmodule indicators (input wire clk,input wire rst,input wire [ 8-1:0] track,input wire f_wr,input wire f_rd,input wire h_wr,input wire h_rd,input wire [ 4-1:0] status,input wire [ 4-1:0] ctrl_status,input wire [ 4-1:0] sys_status,input wire fifo_full,output wire [ 7-1:0] hex_0,output wire [ 7-1:0] hex_1,output wire [ 7-1:0] hex_2,output wire [ 7-1:0] hex_3,output wire [ 8-1:0] led_g,output wire [ 10-1:0] led_r);\n [/INST]\n", "output": "sseg_decode #(.REG (1),.INV (1)) sseg_HEX0 (.clk (clk),.rst (rst),.num (track[3:0]),.sseg (hex_0)); \n sseg_decode #(.REG (1),.INV (1)) sseg_HEX1 (.clk (clk),.rst (rst),.num (track[7:4]),.sseg (hex_1)); \n assign hex_2 = 7'h7f; \n assign hex_3 = ~7'h71; \n reg [1:0] r0, r1, g0, g1; \n always @ (posedge clk or posedge rst) begin \n  if (rst) begin \n  r0 <= #1 2'b00; \n  r1 <= #1 2'b00; \n  g0 <= #1 2'b00; \n  g1 <= #1 2'b00; \n  end else begin \n  r0 <= #1 {r0[0], f_wr}; \n  r1 <= #1 {r1[0], h_wr}; \n  g0 <= #1 {g0[0], f_rd}; \n  g1 <= #1 {g1[0], h_rd}; \n  end \n end \n wire r0_out, g0_out, r1_out, g1_out; \n assign r0_out = |r0; \n assign r1_out = |r1; \n assign g0_out = |g0; \n assign g1_out = |g1; \n reg [ 4-1:0] ctrl_leds; \n always @ (posedge clk, posedge rst) begin \n  if (rst) \n  ctrl_leds <= #1 4'b0; \n  else \n  ctrl_leds <= #1 ctrl_status; \n end \n assign led_g = {ctrl_leds, 1'b0,fifo_full, g1_out, g0_out}; \n assign led_r = {status, sys_status, r1_out, r0_out}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module represents an instruction memory unit. It consists of memory storage initialized with specific 8-bit values. The module has inputs for the clock signal and the memory address. On the falling edge of the clock signal, it retrieves a 32-bit instruction from the memory based on the provided address and outputs it.\n\n Module header:\n\nmodule instructionmemory(output [31:0] data,input [6:0] addr,input clk);\n [/INST]\n", "output": "reg [31:0] data; \n reg [7:0] memdata [511:0]; \n initial \n  begin \n  memdata[0] = 8'b10001101; \n  memdata[1] = 8'b10100001; \n  memdata[2] = 8'b00000000; \n  memdata[3] = 8'b00000000; \n  memdata[4] = 8'b10001101; \n  memdata[5] = 8'b10100010; \n  memdata[6] = 8'b00000000; \n  memdata[7] = 8'b00000001; \n  memdata[8] = 8'b00000000; \n  memdata[9] = 8'b00100010; \n  memdata[10] = 8'b00011000; \n  memdata[11] = 8'b00100000; \n  memdata[12] = 8'b10001101; \n  memdata[13] = 8'b10100100; \n  memdata[14] = 8'b00000000; \n  memdata[15] = 8'b00000010; \n  memdata[16] = 8'b00000000; \n  memdata[17] = 8'b01100100; \n  memdata[18] = 8'b00101000; \n  memdata[19] = 8'b00100010; \n  memdata[20] = 8'b10001101; \n  memdata[21] = 8'b10100110; \n  memdata[22] = 8'b00000000; \n  memdata[23] = 8'b00000011; \n  memdata[24] = 8'b00000000; \n  memdata[25] = 8'b10100110; \n  memdata[26] = 8'b00111000; \n  memdata[27] = 8'b00100101; \n  memdata[28] = 8'b10001101; \n  memdata[29] = 8'b10101000; \n  memdata[30] = 8'b00000000; \n  memdata[31] = 8'b00000100; \n  memdata[32] = 8'b00000000; \n  memdata[33] = 8'b11101000; \n  memdata[34] = 8'b01001000; \n  memdata[35] = 8'b00100100; \n  memdata[36] = 8'b10101101; \n  memdata[37] = 8'b10101001; \n  memdata[38] = 8'b00000000; \n  memdata[39] = 8'b00000111; \n  memdata[40] = 8'b00010001; \n  memdata[41] = 8'b10101101; \n  memdata[42] = 8'b11111111; \n  memdata[43] = 8'b11111000; \n  end \n always @(negedge clk) \n  begin \n  data = { memdata[addr] , memdata[addr+1] , memdata[addr+2] , memdata[addr+3] }; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a D flip-flop with configurable width. The flip-flop stores the input value D when the enable signal en is asserted and updates its output Q on the rising edge of the clock signal clk. Additionally, it resets the storage to zero when the asynchronous reset signal res is asserted.\n\n Module header:\n\nmodule ff_d #(parameter WIDTH=8) (input wire [WIDTH - 1 : 0] D,input wire en,input wire clk,input wire res,output wire [WIDTH - 1 : 0] Q);\n [/INST]\n", "output": "reg [WIDTH - 1 : 0] storage; \n  assign Q = storage; \n  always @(posedge clk) begin \n  if(res) \n  storage <= {WIDTH{1'b0}}; \n  else if(en) \n  storage <= D; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a 15-bit binary to 11-bit Hamming code decoder. It takes a 11-bit binary input and calculates the 4 parity bits based on specific combinations of the input bits. Then, it sets the output Hamming code with the input bits and the calculated parity bits at their respective positions.\n\n Module header:\n\nmodule ham_15_11_decoder (c,q);\n [/INST]\n", "output": "output reg [14:0] c; \n  input [10:0] d; \n  reg [3:0] p; \n  always @(*) \n  begin \n  p[0]=d[0]^d[1]^d[3]^d[4]^d[6]^d[8]^d[10]; \n  p[1]=((d[0]^d[2])^(d[3]^d[5]))^((d[6]^d[9])^d[10]); \n  p[2]=((d[1]^d[2])^(d[3]^d[7]))^((d[8]^d[9])^d[10]); \n  p[3]=((d[4]^d[5])^(d[6]^d[7]))^((d[8]^d[9])^d[10]); \n  c[2]=d[0]; \n  c[4]=d[1]; \n  c[5]=d[2]; \n  c[6]=d[3]; \n  c[8]=d[4]; \n  c[9]=d[5]; \n  c[10]=d[6]; \n  c[11]=d[7]; \n  c[12]=d[8]; \n  c[13]=d[9]; \n  c[14]=d[10]; \n  c[0]=p[0]; \n  c[1]=p[1]; \n  c[3]=p[2]; \n  c[7]=p[3]; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a counter with configurable bit width. It has inputs for clock, reset, enable, load, and initial value, and outputs the current count. The counter increments when enabled and not loading, and resets to the initial value when the reset signal is asserted.\n\n Module header:\n\nmodule counter_behavioural #(parameter bits = 16) (input clock, reset, enable, load,input [bits-1:0] init,output reg [bits-1:0] q);\n [/INST]\n", "output": "always @(posedge clock, posedge reset) \n  if (reset) \n  q <= 0; \n  else if (enable) \n  if (load) q <= init; \n  else q <= q + 1; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module defines an assertion that checks if signal A is equal to 1 when signal EN is also 1. If this condition is not met, the module will display an error message and halt the simulation. This is commonly used for verification and debugging purposes during the simulation of digital designs.\n\n Module header:\n\nmodule \\$assert (A, EN);\n [/INST]\n", "output": "input A, EN; \n `ifndef SIMLIB_NOCHECKS \n always @* begin \n  if (A !== 1'b1 && EN === 1'b1) begin \n  $display(\"Assertion %m failed!\"); \n  $stop; \n  end \n end \n `endif \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `memtest00` consists of a memory with 2 addresses, and it is sensitive to the clock signal. When `setA` is asserted, the value at memory address 0 is set to 0. When `setB` is asserted, the value at memory address 0 is set to 1. The output `y` is assigned the value stored at memory address 0.\n\n Module header:\n\nmodule memtest00(clk, setA, setB, y);\n [/INST]\n", "output": "input clk, setA, setB; \n output y; \n reg mem [1:0]; \n always @(posedge clk) begin \n  if (setA) mem[0] <= 0; \n  if (setB) mem[0] <= 1; \n end \n assign y = mem[0]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements an output buffer for the Q output, along with corresponding control and delay signals. It includes a D flip-flop with pulse trigger to synchronize the output, as well as conditions and signals for asynchronous and scan mode operation. The module also features a 2-to-1 multiplexer, a notifier register, and various condition evaluation logic. The implementation ensures proper handling of asynchronous and scan enable signals, while also considering power supply and ground conditions. Additionally, the module includes an inverter and a buffer to generate the Q and Q_N outputs.\n\n Module header:\n\nmodule sky130_fd_sc_lp__sregsbp (Q ,Q_N ,CLK ,D ,SCD ,SCE ,ASYNC,VPWR ,VGND ,VPB ,VNB);\n [/INST]\n", "output": "output Q ; \n  output Q_N ; \n  input CLK ; \n  input D ; \n  input SCD ; \n  input SCE ; \n  input ASYNC; \n  input VPWR ; \n  input VGND ; \n  input VPB ; \n  input VNB ; \n  wire buf_Q ; \n  wire set ; \n  wire mux_out ; \n  reg notifier ; \n  wire D_delayed ; \n  wire SCD_delayed ; \n  wire SCE_delayed ; \n  wire ASYNC_delayed; \n  wire CLK_delayed ; \n  wire awake ; \n  wire cond0 ; \n  wire cond1 ; \n  wire cond2 ; \n  wire cond3 ; \n  wire cond4 ; \n  not not0 (set , ASYNC_delayed ); \n  sky130_fd_sc_lp__udp_mux_2to1 mux_2to10 (mux_out, D_delayed, SCD_delayed, SCE_delayed ); \n  sky130_fd_sc_lp__udp_dff$PS_pp$PG$N dff0 (buf_Q , mux_out, CLK_delayed, set, notifier, VPWR, VGND); \n  assign awake = ( VPWR === 1'b1 ); \n  assign cond0 = ( ( ASYNC_delayed === 1'b1 ) && awake ); \n  assign cond1 = ( ( SCE_delayed === 1'b0 ) && cond0 ); \n  assign cond2 = ( ( SCE_delayed === 1'b1 ) && cond0 ); \n  assign cond3 = ( ( D_delayed !== SCD_delayed ) && cond0 ); \n  assign cond4 = ( ( ASYNC === 1'b1 ) && awake ); \n  buf buf0 (Q , buf_Q ); \n  not not1 (Q_N , buf_Q ); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is designed to implement a state machine with a 4-state sequence. It uses multiple registers and wires to control the state transitions and data manipulation.\n\nThe module has several inputs including reset, clock, and data input din, and outputs including data output dout and ordy. It also utilizes various internal wires for k-maps and m-maps.\n\nThe state machine is controlled by the pstate and nstate registers. The module transitions between the 4 states (STATE_S1 to STATE_S4) based on the values of pstate and nstate. The module manipulates the values of lda, ldb, s_ordy, c_ordy, sregb, and s to control the state transitions and data processing.\n\nThe module includes logic to calculate the value of k based on the current state and input data. It also performs multiplications and additions on the data to produce the final output stored in the dout register.\n\nOverall, the module represents a complex state machine with data manipulation and state transition control.\n\n Module header:\n\nmodule lab5dpath(reset, clk, irdy, ordy, din, dout );\n [/INST]\n", "output": "input reset, clk, irdy; \n  input [9:0] din; \n  output [9:0] dout; \n  output ordy; \n wire [11:0] k1, k2, k3, dmod, mmod, add; \n wire [23:0] m; \n reg lda, ldb, s_ordy, c_ordy, ordy; \n reg [1:0] nstate, pstate, s, sregb; \n reg [11:0] k, aq, bq, bd; \n assign k1 = 12'b110000000000; \n assign k3 = 12'b110000000000; \n assign k2 = 12'b010100000000; \n `define STATE_S1 2'b00 \n `define STATE_S2 2'b01 \n `define STATE_S3 2'b10 \n `define STATE_S4 2'b11 \n assign dmod = {din, 2'b00}; \n always @ (posedge clk) begin \n k = k1; \n  case (s) \n  2'b01: \n  k = k2; \n  2'b10: \n  k = k3; \n  2'b11: \n  k = 12'b000000000001; \n  endcase \n end \n mult12x12 i1 (.a(k), .b(dmod), .p(m)); \n assign mmod = m[22:11]; \n assign add = bq + aq; \n always @* begin \n  case (sregb) \n  2'b00: \n  bd = mmod; \n  2'b01: \n  bd = add; \n  2'b10: \n  bd = 12'b000000000000; \n  endcase \n end \n always @(posedge clk) begin \n  if (lda) \n  aq <= mmod; \n end \n always @(posedge clk) begin \n  if (ldb) \n  bq <= bd; \n end \n always @(posedge clk or posedge reset) begin \n  if (reset) begin \n  ordy <= 0; \n  end \n  else begin \n  if (s_ordy) ordy <= 1; \n  if (c_ordy) ordy <= 0; \n  end \n end \n always @(posedge clk or posedge reset) begin \n  if (reset) begin \n  pstate <= `STATE_S1; \n  end \n  else begin \n  pstate <= nstate; \n  end \n end \n always @* begin \n  lda = 0; ldb = 0; \n  s_ordy = 0; c_ordy = 0; \n  sregb = 2'b00; s = 2'b00; \n  nstate = pstate; \n  case (pstate) \n  `STATE_S1: begin \n  lda = 1; \n  if (irdy == 1)begin \n  s = 2'b01; \n  nstate = `STATE_S2; \n  c_ordy = 1; \n  end \n  end \n  `STATE_S2: begin \n  s = 2'b10; \n  ldb = 1; \n  sregb = 2'b00; \n  nstate = `STATE_S3; \n  end \n  `STATE_S3: begin \n  lda = 1; \n  sregb = 2'b01; \n  ldb = 1; \n  nstate = `STATE_S4; \n  end \n  `STATE_S4: begin \n  sregb = 2'b01; \n  ldb = 1; \n  s_ordy = 1; \n  nstate = `STATE_S1; \n  end \n  endcase \n end \n assign dout = bq[11:2]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a synchronous control logic for reading data from a memory controller. It uses various input signals such as clock, reset, data selection, active delays, and enables to manage the data path. The design includes a shift register for synchronizing the read data enable signal, and it controls the validity of the read data based on this signal and the data selection. Additionally, there's a mechanism for managing the readiness of the read path, considering both clock edges and the reset signal. The module also provides an adjustable parameter for a time constant, TCQ, for timing control.\n\n Module header:\n\nmodule phy_rdctrl_sync # (parameter TCQ = 100) (input clk,input rst_rsync,input mc_data_sel,input [4:0] rd_active_dly,input dfi_rddata_en,input phy_rddata_en,output reg dfi_rddata_valid,output reg dfi_rddata_valid_phy,output reg rdpath_rdy);\n [/INST]\n", "output": "localparam RDPATH_RDY_DLY = 10; \n  wire rddata_en; \n  wire rddata_en_rsync; \n  wire rddata_en_srl_out; \n  reg [RDPATH_RDY_DLY-1:0] rdpath_rdy_dly_r; \n  assign rddata_en = (mc_data_sel) ? dfi_rddata_en : phy_rddata_en; \n  SRLC32E u_rddata_en_srl \n (.Q (rddata_en_srl_out),.Q31 (),.A (rd_active_dly),.CE (1'b1),.CLK (clk),.D (rddata_en)); \n  always @(posedge clk) begin \n  dfi_rddata_valid <= #TCQ rddata_en_srl_out & mc_data_sel; \n  dfi_rddata_valid_phy <= #TCQ rddata_en_srl_out; \n  end \n  always @(posedge clk or posedge rst_rsync) begin \n  if (rst_rsync) \n  rdpath_rdy_dly_r <= #TCQ {{RDPATH_RDY_DLY}{1'b0}}; \n  else \n  rdpath_rdy_dly_r[RDPATH_RDY_DLY-1:1] \n  <= #TCQ {rdpath_rdy_dly_r[RDPATH_RDY_DLY-2:0], 1'b1}; \n  end \n  always @(posedge clk) \n  rdpath_rdy <= rdpath_rdy_dly_r[RDPATH_RDY_DLY-1]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a simple memory test circuit. It has a 16-word memory, with 4-bit addresses and data. On each positive edge of the clock, it writes the wr_data to the memory at the wr_addr if wr_enable is asserted. It also reads the memory at the rd_addr and outputs the result as rd_data.\n\n Module header:\n\nmodule memtest03(clk, wr_addr, wr_data, wr_enable, rd_addr, rd_data);\n [/INST]\n", "output": "input clk, wr_enable; \n input [3:0] wr_addr, wr_data, rd_addr; \n output reg [3:0] rd_data; \n reg [3:0] memory [0:15]; \n always @(posedge clk) begin \n  if (wr_enable) \n  memory[wr_addr] <= wr_data; \n  rd_data <= memory[rd_addr]; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a relational operation between input signals a and b based on an enable signal. It uses memory to store and update the output, and a shift-join register to capture and shift the result. The output op is determined by the comparison result when the enable signal is active. The module also includes control logic for the memory operations based on clock and control signals.\n\n Module header:\n\nmodule relational_440eb07a2f (input [(3 - 1):0] a,input [(6 - 1):0] b,input [(1 - 1):0] en,output [(1 - 1):0] op,input clk,input ce,input clr);\n [/INST]\n", "output": "wire [(3 - 1):0] a_1_31; \n  wire [(6 - 1):0] b_1_34; \n  wire en_1_37; \n  reg op_mem_32_22[0:(1 - 1)]; \n  initial \n  begin \n  op_mem_32_22[0] = 1'b0; \n  end \n  wire op_mem_32_22_front_din; \n  wire op_mem_32_22_back; \n  wire op_mem_32_22_push_front_pop_back_en; \n  localparam [(1 - 1):0] const_value = 1'b1; \n  wire [(6 - 1):0] cast_14_12; \n  wire result_14_3_rel; \n  reg op_mem_shift_join_34_3; \n  reg op_mem_shift_join_34_3_en; \n  assign a_1_31 = a; \n  assign b_1_34 = b; \n  assign en_1_37 = en; \n  assign op_mem_32_22_back = op_mem_32_22[0]; \n  always @(posedge clk) \n  begin:proc_op_mem_32_22 \n  integer i; \n  if (((ce == 1'b1) && (op_mem_32_22_push_front_pop_back_en == 1'b1))) \n  begin \n  op_mem_32_22[0] <= op_mem_32_22_front_din; \n  end \n  end \n  assign cast_14_12 = {3'b000, a_1_31[2:0]}; \n  assign result_14_3_rel = cast_14_12 != b_1_34; \n  always @(en_1_37 or result_14_3_rel) \n  begin:proc_if_34_3 \n  if (en_1_37) \n  begin \n  op_mem_shift_join_34_3_en = 1'b1; \n  end \n  else \n  begin \n  op_mem_shift_join_34_3_en = 1'b0; \n  end \n  op_mem_shift_join_34_3 = result_14_3_rel; \n  end \n  assign op_mem_32_22_front_din = op_mem_shift_join_34_3; \n  assign op_mem_32_22_push_front_pop_back_en = op_mem_shift_join_34_3_en; \n  assign op = op_mem_32_22_back; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module implements a delay element that takes an input din and produces an output dout after a delay specified by the dly input. The delay is achieved by shifting the values in the sr register. The behavior of the module can be different based on the SHREG_SEQUENTIAL_RESET and SIMULATION parameters. When SHREG_SEQUENTIAL_RESET is defined, the sr register is loaded with the value of din and is reset when the rst input is asserted. When SIMULATION is defined, the output dout is assigned based on the value of sr and the simulation condition. If SIMULATION is not defined, the output dout is assigned to the value of sr[dly].\n\n Module header:\n\nmodule dly01_16(input clk,input rst,input [3:0] dly,input din,output dout);\n [/INST]\n", "output": "reg [15:0] sr=0; \n `ifdef SHREG_SEQUENTIAL_RESET \n  always @ (posedge clk) begin \n  sr <= {sr[14:0], din & ~rst}; \n  end \n `else \n  always @ (posedge clk) begin \n  if (rst) sr <=0; \n  else sr <= {sr[14:0],din}; \n  end \n `endif \n `ifdef SIMULATION \n  assign dout = (|sr) ? ((&sr) ? 1'b1 : sr[dly]) : 1'b0 ; \n `else \n  assign dout =sr[dly]; \n `endif \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module compares two 8-bit inputs a and b and outputs the result of the equality comparison on each bit. The comparison is triggered by the clk signal, and the ce and clr inputs control the operation of the module.\n\n Module header:\n\nmodule sysgen_relational_fc1426e2d9 (input [(8 - 1):0] a,input [(8 - 1):0] b,output [(1 - 1):0] op,input clk,input ce,input clr);\n [/INST]\n", "output": "wire [(8 - 1):0] a_1_31; \n  wire [(8 - 1):0] b_1_34; \n  localparam [(1 - 1):0] const_value = 1'b1; \n  wire result_12_3_rel; \n  assign a_1_31 = a; \n  assign b_1_34 = b; \n  assign result_12_3_rel = a_1_31 == b_1_34; \n  assign op = result_12_3_rel; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is designed to compare two double-precision floating-point numbers. It takes inputs for enable, clock, dataa, and datab, and produces a result as an output. The comparison is performed based on COMPARISON_MODE and UNORDERED_MODE parameters. The module includes multiple wire declarations, an instance of a submodule called acl_fp_cmp_double_altfp_compare_ine_component, and a case statement that determines the result based on the comparison mode and unordered mode. The comparison logic is implemented using bitwise operations and conditional statements.\n\n Module header:\n\nmodule acl_fp_cmp_double (enable,clock,dataa,datab,result);\n [/INST]\n", "output": "input enable; \n  input clock; \n  input [63:0] dataa; \n  input [63:0] datab; \n  output reg result; \n  parameter COMPARISON_MODE = 0; \n  parameter UNORDERED_MODE = 0; \n  wire sub_wire0; \n  wire sub_wire1; \n  wire sub_wire2; \n  wire sub_wire3; \n  wire sub_wire4; \n  wire sub_wire5; \n  wire sub_wire6; \n  wire aeb = sub_wire0; \n  wire aleb = sub_wire1; \n  wire unordered = sub_wire2; \n  wire ageb = sub_wire3; \n  wire alb = sub_wire4; \n  wire agb = sub_wire5; \n  wire aneb = sub_wire6; \n acl_fp_cmp_double_altfp_compare_ine acl_fp_cmp_double_altfp_compare_ine_component (.clk_en (enable),.clock (clock),.datab (datab),.dataa (dataa),.aeb (sub_wire0),.aleb (sub_wire1),.unordered (sub_wire2),.ageb (sub_wire3),.alb (sub_wire4),.agb (sub_wire5),.aneb (sub_wire6)); \n  always@(*) \n  begin \n  case(COMPARISON_MODE) \n  1: result = (UNORDERED_MODE == 0) ? (aneb & ~unordered) : (aneb | unordered); \n  2: result = (UNORDERED_MODE == 0) ? (ageb & ~unordered) : (ageb | unordered); \n  3: result = (UNORDERED_MODE == 0) ? (agb & ~unordered) : (agb | unordered); \n  4: result = (UNORDERED_MODE == 0) ? (aleb & ~unordered) : (aleb | unordered); \n  5: result = (UNORDERED_MODE == 0) ? (alb & ~unordered) : (alb | unordered); \n  6: result = (UNORDERED_MODE == 0) ? (~unordered) : unordered; \n  default: \n  begin \n  result = (UNORDERED_MODE == 0) ? (aeb & ~unordered) : (aeb | unordered); \n  end \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a flash memory controller with a Wishbone interface. It interfaces with a flash memory device and handles read and write operations. It includes logic to handle address generation, data input/output, write enable, flash reset, and error signaling. The module also implements a flash file pointer for logging write and read operations, and incorporates counter and threshold logic for managing the flash memory access. The module includes sequential and combinational logic for handling the flash memory operations based on the Wishbone signals and internal state variables.\n\n Module header:\n\nmodule flash_top (wb_clk_i, wb_rst_i,wb_dat_i, wb_dat_o, wb_adr_i, wb_sel_i, wb_we_i, wb_cyc_i,wb_stb_i, wb_ack_o, wb_err_o,flash_rstn, cen, oen, wen, rdy, d, a, a_oe);\n [/INST]\n", "output": "input wb_clk_i; \n input wb_rst_i; \n input [31:0] wb_dat_i; \n output [31:0] wb_dat_o; \n input [31:0] wb_adr_i; \n input [3:0] wb_sel_i; \n input wb_we_i; \n input wb_cyc_i; \n input wb_stb_i; \n output wb_ack_o; \n output wb_err_o; \n output flash_rstn; \n output oen; \n output cen; \n output wen; \n input rdy; \n inout [7:0] d; \n output [20:0] a; \n output a_oe; \n reg ack; \n reg [3:0] middle_tphqv; \n reg [31:0] wb_dat_o; \n reg [4:0] counter; \n assign wb_ack_o = ~wb_err_o & ack; \n assign wb_err_o = 1'b0; \n assign flash_rstn = ~wb_rst_i; \n assign a = { ~wb_adr_i[20], wb_adr_i[19:2], counter[3:2] }; \n assign a_oe = (wb_cyc_i &! (|middle_tphqv)); \n assign oen = |middle_tphqv; \n assign wen = 1'b1; \n assign cen = ~wb_cyc_i | ~wb_stb_i | (|middle_tphqv) | (counter[1:0] == 2'b00); \n always @(posedge wb_clk_i or posedge wb_rst_i) \n begin \n  if (wb_rst_i) \n  counter <= #1 5'h0; \n  else \n  if (!wb_cyc_i | (counter == 5'h10) | (|middle_tphqv)) \n  counter <= #1 5'h0; \n  else \n  counter <= #1 counter + 1; \n end \n always @(posedge wb_clk_i or posedge wb_rst_i) \n begin \n  if (wb_rst_i) \n  ack <= #1 1'h0; \n  else \n  if (counter == 5'h0f && !(|middle_tphqv)) \n  ack <= #1 1'h1; \n  else \n  ack <= #1 1'h0; \n end \n integer fflash; \n initial fflash = $fopen(\"flash.log\"); \n always @(posedge wb_clk_i) \n begin \n  if (wb_cyc_i & !(|middle_tphqv)) begin \n  if (wb_stb_i & wb_we_i) begin \n  $fdisplay(fflash, \"%t Trying to write into flash at %h\", $time, wb_adr_i); \n  end \n  else if (ack) \n  $fdisplay(fflash, \"%t [%h] -> read %h\", $time, wb_adr_i, wb_dat_o); \n  end \n end \n always @(posedge wb_clk_i or posedge wb_rst_i) \n  if (wb_rst_i) \n  middle_tphqv <= #1 4'hf; \n  else if (middle_tphqv) \n  middle_tphqv <= #1 middle_tphqv - 1; \n always @(posedge wb_clk_i or posedge wb_rst_i) \n begin \n  if (wb_rst_i) \n  wb_dat_o <= #1 32'h0000_0000; \n  else \n  if (counter[1:0] == 2'h3) \n  begin \n  case (counter[3:2]) \n  2'h0 : wb_dat_o[31:24] <= #1 d; \n  2'h1 : wb_dat_o[23:16] <= #1 d; \n  2'h2 : wb_dat_o[15:8] <= #1 d; \n  2'h3 : wb_dat_o[7:0] <= #1 d; \n  endcase \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a multiplexer (MUX) that selects between two input buses, d0 and d1, based on the value of the select signal, s. The selected bus is then routed to the output bus, y.\n\n Module header:\n\nmodule mux1 #(parameter WIDTH = 10) (input wire [WIDTH-1:0] d0, d1,input wire s,output wire [WIDTH-1:0] y);\n [/INST]\n", "output": "assign y = s ? d1 : d0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module is a bridge between two bus interfaces. It consists of a state machine that controls the flow of data between the interfaces. The module receives inputs from one bus interface and directs the data to the other interface based on the state machine's control logic. It includes logic for address selection, write enable, data selection, acknowledgement handling, and stall signal generation. The state machine transitions through idle, request, and wait states to manage the data transfer process.\n\n Module header:\n\n module fml_wb_bridge #(parameter sdram_depth = 26) (input clk_sys_i,input rst_n_i,output reg [sdram_depth-1:0] fml_adr,output reg fml_stb,output reg fml_we,input fml_ack,output reg [3:0] fml_sel,output reg [31:0] fml_do,input [31:0] fml_di,input [31:0] wb_adr_i,input [31:0] wb_dat_i,input [3:0] wb_sel_i,input wb_cyc_i,input wb_stb_i,input wb_we_i,output reg wb_ack_o,output reg wb_stall_o,output reg [31:0] wb_dat_o );\n [/INST]\n", "output": "reg wb_we_r; \n  reg wb_ack; \n  reg is_write; \n  reg [1:0] state; \n `define ST_IDLE 0 \n `define ST_REQ 1 \n `define ST_WAIT 2 \n  reg [3:0] cnt; \n  always@(posedge clk_sys_i) \n  if(!rst_n_i) \n  begin \n  wb_stall_o <= 1; \n  wb_ack_o <= 0; \n  fml_adr <= 0; \n  fml_stb <= 0; \n  fml_we <= 0; \n  fml_sel <= 0; \n  fml_do <= 0; \n  state <= `ST_IDLE; \n  end else begin \n  case(state) \n  `ST_IDLE: if(wb_cyc_i && wb_stb_i) begin \n  wb_stall_o <= 0; \n  wb_ack_o <= 0; \n  fml_stb <= 1; \n  fml_adr <= wb_adr_i; \n  fml_sel <= wb_sel_i; \n  fml_we <= wb_we_i; \n  is_write <= wb_we_i; \n  fml_do <= wb_dat_i; \n  state <= `ST_REQ; \n  wb_stall_o <= 0; \n  end else begin \n  wb_stall_o <= 1; \n  wb_ack_o <= 0; \n  fml_stb <= 0; \n  end \n  `ST_REQ: \n  begin \n  wb_stall_o <= 1; \n  if(fml_ack) \n  begin \n  fml_do <= 0; \n  fml_sel <= is_write ? 0 : 4'hf; \n  fml_stb <= 0; \n  wb_dat_o <= fml_di; \n  state <= `ST_WAIT; \n  cnt <= 0; \n  end \n  end \n  `ST_WAIT: \n  begin \n  cnt <= cnt + 1; \n  wb_stall_o <= 1; \n  if(cnt == 2) \n  begin \n  fml_stb <= 0; \n  fml_we <= 0; \n  wb_ack_o <= 1; \n  state <= `ST_IDLE; \n  fml_sel <= 0; \n  fml_do <= 0; \n  end \n  end \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module consists of double registers that are controlled by various chip select signals. The module has inputs for the clock, data bus, selection numbers, and chip select signals, as well as outputs for the two registers. The module uses two arrays of 8-bit registers to store high and low bytes of the data. The module updates the registers based on the chip select signals and assigns the output based on the selected bytes or a combination of both.\n\n Module header:\n\nmodule DoubleRegisters(clk,bus_in, bus_out1, bus_out2,num1, num2,cs_h_in, cs_l_in, cs_16_in,cs_h_out1, cs_l_out1, cs_16_out1,cs_h_out2, cs_l_out2, cs_16_out2);\n [/INST]\n", "output": "input [15:0] bus_in; \n  output reg [15:0] bus_out1, bus_out2; \n  input [1:0] num1, num2; \n  input cs_h_in, cs_l_in, cs_16_in; \n  input cs_h_out1, cs_l_out1, cs_16_out1; \n  input cs_h_out2, cs_l_out2, cs_16_out2; \n  input clk; \n  (* ram_style=\"block\" *) \n  reg [7:0] store_h[3:0] ; \n  (* ram_style=\"block\" *) \n  reg [7:0] store_l[3:0] ; \n  always @ (posedge clk) \n  if (cs_h_out1) \n  bus_out1 <= {8'h00, store_h[num1]}; \n  else if (cs_l_out1) \n  bus_out1 <= {8'h00, store_l[num1]}; \n  else if (cs_16_out1) \n  bus_out1 <= {store_h[num1], store_l[num1]}; \n  else \n  bus_out1 <= 16'bz; \n  always @ (posedge clk) \n  if (cs_h_out2) \n  bus_out2 <= {8'h00, store_h[num2]}; \n  else if (cs_l_out2) \n  bus_out2 <= {8'h00, store_l[num2]}; \n  else if (cs_16_out2) \n  bus_out2 <= {store_h[num2], store_l[num2]}; \n  else \n  bus_out2 <= 16'bz; \n  always @(posedge clk) \n  if (cs_h_in) \n  store_h[num1] <= bus_in[7:0]; \n  else if (cs_16_in) begin \n  store_h[num1] <= bus_in[15:8]; \n  end \n  always @(posedge clk) \n  if (cs_l_in) \n  store_l[num1] <= bus_in[7:0]; \n  else if (cs_16_in) begin \n  store_l[num1] <= bus_in[7:0]; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is designed to detect an edge in the input data stream. It uses a counter to keep track of the number of consecutive clock cycles for which the input data remains unchanged. Once the counter reaches a certain value (13 in this case), it sets the \"edgeseen\" output to 1. Additionally, if the input data changes after the counter reaches 15, it also sets the \"edgeseen\" output to 1. The module includes a reset signal to initialize the internal state variables.\n\n Module header:\n\nmodule edgedet(clk, rstn, datain, edgeseen);\n [/INST]\n", "output": "input clk; \n  input rstn; \n  input datain; \n  output reg edgeseen; \n  reg lastdata; \n  reg [3:0] count; \n  always @(posedge clk or negedge rstn) begin \n  if(rstn == 0) begin \n  edgeseen <= 0; \n  lastdata <= 0; \n  count <= 4'b0000; \n  end else begin \n  edgeseen <= 0; \n  if(count < 15) begin \n  lastdata <= datain; \n  count <= count + 1'b1; \n  end \n  if(count == 13) begin \n  edgeseen <= 1; \n  end \n  if((count == 15) && (lastdata ^ datain)) begin \n  edgeseen <= 1; \n  lastdata <= datain; \n  end \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes two 32-bit parameters and assigns them to the output ports o1 and o2. The assignment statements directly assign the parameters to the outputs.\n\n Module header:\n\nmodule module_scope_ExampleLong(o1, o2);\n [/INST]\n", "output": "parameter [31:0] ThisIsAnExtremelyLongParameterNameToTriggerTheSHA1Checksum1 = 10; \n  parameter [31:0] ThisIsAnExtremelyLongParameterNameToTriggerTheSHA1Checksum2 = 20; \n  output [31:0] o1, o2; \n  assign module_scope_ExampleLong.o1 = module_scope_ExampleLong.ThisIsAnExtremelyLongParameterNameToTriggerTheSHA1Checksum1; \n  assign module_scope_ExampleLong.o2 = module_scope_ExampleLong.ThisIsAnExtremelyLongParameterNameToTriggerTheSHA1Checksum2; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module defines an adder for two 32-bit floating-point numbers. It first separates the inputs into sign, exponent, and mantissa. Then, it performs addition, subtraction, and normalization of the mantissas based on the exponents and signs. Finally, it handles rounding and shifts in the mantissa and updates the output sign, exponent, and mantissa accordingly.\n\n Module header:\n\nmodule adder(a, b, out);\n [/INST]\n", "output": "input [31:0] a, b; \n  output [31:0] out; \n  wire [31:0] out; \n  reg a_sign; \n  reg [7:0] a_exponent; \n  reg [23:0] a_mantissa; \n  reg b_sign; \n  reg [7:0] b_exponent; \n  reg [23:0] b_mantissa; \n  reg o_sign; \n  reg [7:0] o_exponent; \n  reg [24:0] o_mantissa; \n  reg [7:0] diff; \n  reg [23:0] tmp_mantissa; \n  reg [7:0] tmp_exponent; \n  reg [7:0] i_e; \n  reg [24:0] i_m; \n  wire [7:0] o_e; \n  wire [24:0] o_m; \n  addition_normaliser norm1 \n (.in_e(i_e),.in_m(i_m),.out_e(o_e),.out_m(o_m)); \n  assign out[31] = o_sign; \n  assign out[30:23] = o_exponent; \n  assign out[22:0] = o_mantissa[22:0]; \n  always @ ( * ) begin \n  a_sign = a[31]; \n  if(a[30:23] == 0) begin \n  a_exponent = 8'b00000001; \n  a_mantissa = {1'b0, a[22:0]}; \n  end else begin \n  a_exponent = a[30:23]; \n  a_mantissa = {1'b1, a[22:0]}; \n  end \n  b_sign = b[31]; \n  if(b[30:23] == 0) begin \n  b_exponent = 8'b00000001; \n  b_mantissa = {1'b0, b[22:0]}; \n  end else begin \n  b_exponent = b[30:23]; \n  b_mantissa = {1'b1, b[22:0]}; \n  end \n  if (a_exponent == b_exponent) begin \n  o_exponent = a_exponent; \n  if (a_sign == b_sign) begin \n  o_mantissa = a_mantissa + b_mantissa; \n  o_mantissa[24] = 1; \n  o_sign = a_sign; \n  end else begin \n  if(a_mantissa > b_mantissa) begin \n  o_mantissa = a_mantissa - b_mantissa; \n  o_sign = a_sign; \n  end else begin \n  o_mantissa = b_mantissa - a_mantissa; \n  o_sign = b_sign; \n  end \n  end \n  end else begin \n  if (a_exponent > b_exponent) begin \n  o_exponent = a_exponent; \n  o_sign = a_sign; \n  diff = a_exponent - b_exponent; \n  tmp_mantissa = b_mantissa >> diff; \n  if (a_sign == b_sign) \n  o_mantissa = a_mantissa + tmp_mantissa; \n  else \n  o_mantissa = a_mantissa - tmp_mantissa; \n  end else if (a_exponent < b_exponent) begin \n  o_exponent = b_exponent; \n  o_sign = b_sign; \n  diff = b_exponent - a_exponent; \n  tmp_mantissa = a_mantissa >> diff; \n  if (a_sign == b_sign) begin \n  o_mantissa = b_mantissa + tmp_mantissa; \n  end else begin \n  o_mantissa = b_mantissa - tmp_mantissa; \n  end \n  end \n  end \n  if(o_mantissa[24] == 1) begin \n  o_exponent = o_exponent + 1; \n  o_mantissa = o_mantissa >> 1; \n  end else if((o_mantissa[23] != 1) && (o_exponent != 0)) begin \n  i_e = o_exponent; \n  i_m = o_mantissa; \n  o_exponent = o_e; \n  o_mantissa = o_m; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes an input clock signal (CLK_IN) and outputs a complemented clock signal (CLK_OUT) as well as a pre-edge signal (PREEDGE). The module inverts the input clock signal to generate the output clock signal and sets the pre-edge signal to high.\n\n Module header:\n\nmodule ClockInverter(CLK_IN, PREEDGE, CLK_OUT);\n [/INST]\n", "output": "input CLK_IN; \n  output PREEDGE; \n  output CLK_OUT; \n  wire CLK_OUT; \n  wire PREEDGE; \n  assign CLK_OUT = ! CLK_IN ; \n  assign PREEDGE = 1 ; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a receiver implementing a state machine to receive and analyze data. It uses a clock signal, trxClock, reset, and rx input to determine the state of the receiver. It starts in the INIT state and transitions through WAITSTOP, WAITSTART, WAITBEGIN, READBYTE, ANALYZE, and READY states based on the input signals. The received data is analyzed and stored in the output registers op and data. The execute signal is updated based on the state transitions. The state machine and data handling logic are implemented using registers and combinatorial logic.\n\n Module header:\n\nmodule receiver #(parameter [31:0] FREQ = 100000000,parameter [31:0] RATE = 115200,parameter BITLENGTH = FREQ / RATE)(input wire clock,input wire trxClock,input wire reset,input wire rx,output wire [7:0] op,output wire [31:0] data,output reg execute);\n [/INST]\n", "output": "localparam [2:0] \n  INIT = 3'h0, \n  WAITSTOP = 3'h1, \n  WAITSTART = 3'h2, \n  WAITBEGIN = 3'h3, \n  READBYTE = 3'h4, \n  ANALYZE = 3'h5, \n  READY = 3'h6; \n reg [9:0] counter, next_counter; \n reg [3:0] bitcount, next_bitcount; \n reg [2:0] bytecount, next_bytecount; \n reg [2:0] state, next_state; \n reg [7:0] opcode, next_opcode; \n reg [31:0] databuf, next_databuf; \n reg next_execute; \n assign op = opcode; \n assign data = databuf; \n always @(posedge clock, posedge reset) \n if (reset) state <= INIT; \n else state <= next_state; \n always @(posedge clock) \n begin \n  counter <= next_counter; \n  bitcount <= next_bitcount; \n  bytecount <= next_bytecount; \n  databuf <= next_databuf; \n  opcode <= next_opcode; \n  execute <= next_execute; \n end \n always \n begin \n  next_state = state; \n  next_counter = counter; \n  next_bitcount = bitcount; \n  next_bytecount = bytecount; \n  next_opcode = opcode; \n  next_databuf = databuf; \n  next_execute = 1'b0; \n  case(state) \n  INIT : \n  begin \n  next_counter = 0; \n  next_bitcount = 0; \n  next_bytecount = 0; \n  next_opcode = 0; \n  next_databuf = 0; \n  next_state = WAITSTOP; \n  end \n  WAITSTOP : \n  begin \n  if (rx) next_state = WAITSTART; \n  end \n  WAITSTART : \n  begin \n  if (!rx) next_state = WAITBEGIN; \n  end \n  WAITBEGIN : \n  begin \n  if (counter == (BITLENGTH / 2)) \n  begin \n  next_counter = 0; \n  next_state = READBYTE; \n  end \n  else if (trxClock) \n  next_counter = counter + 1; \n  end \n  READBYTE : \n  begin \n  if (counter == BITLENGTH) \n  begin \n  next_counter = 0; \n  next_bitcount = bitcount + 1; \n  if (bitcount == 4'h8) \n  begin \n  next_bytecount = bytecount + 1; \n  next_state = ANALYZE; \n  end \n  else if (bytecount == 0) \n  begin \n  next_opcode = {rx,opcode[7:1]}; \n  next_databuf = databuf; \n  end \n  else \n  begin \n  next_opcode = opcode; \n  next_databuf = {rx,databuf[31:1]}; \n  end \n  end \n  else if (trxClock) \n  next_counter = counter + 1; \n  end \n  ANALYZE : \n  begin \n  next_counter = 0; \n  next_bitcount = 0; \n  if (bytecount == 3'h5) \n  next_state = READY; \n  else if (!opcode[7]) \n  next_state = READY; \n  else next_state = WAITSTOP; \n  end \n  READY : \n  begin \n  next_counter = counter + 1; \n  if (counter == 4'd10) \n  next_state = INIT; \n  else next_state = state; \n  end \n  endcase \n  next_execute = (next_state == READY); \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a 32-bit register with clock and write enable inputs. When the write enable signal is asserted, the input data is loaded into the register on the rising edge of the clock. The current contents of the register are output on the `dout` port.\n\n Module header:\n\nmodule reg32 (clk,we, din, dout);\n [/INST]\n", "output": "parameter WIDTH=32; \n input we; \n input clk; \n input [WIDTH-1:0] din; \n output [WIDTH-1:0] dout; \n reg [WIDTH-1:0] store; \n always @(posedge clk) \n  if(we) \n  store <= din; \n assign dout = store ; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module instantiates a top-level module with input and output ports, including leds, gpioBanks, clk, sw, and btn signals. It assigns the signals to the instantiated top-level module \"toplevel\". The initial block sets the initial value of clk to 0, and the always block toggles the value of clk every 10 time units.\n\n Module header:\n\nmodule testTopLevel;\n [/INST]\n", "output": "wire [7:0] led; \n wire [3:0] gpioBank1; \n wire[3:0] gpioBank2; \n reg clk; \n reg[7:0] sw; \n reg[3:0] btn; \n toplevel tl(led, gpioBank1, gpioBank2, clk, sw, btn); \n initial clk=0; \n always #10 clk=!clk; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a write data path for a memory interface. It takes various input signals, such as clock, reset, command valid, data, address, and mode signals, and generates WR data commands for a memory interface. It includes a WR data generator module which is instantiated to handle the generation of write data commands. The output of the module includes data_valid, last_word_wr, data, data_mask, and data_wr_end signals. The module also includes parameters for configuring the memory interface, such as burst length, data width, and burst type.\n\n Module header:\n\nmodule write_data_path #(parameter TCQ = 100,parameter FAMILY = \"SPARTAN6\",parameter MEM_TYPE = \"DDR3\",parameter ADDR_WIDTH = 32,parameter START_ADDR = 32'h00000000,parameter BL_WIDTH = 6,parameter nCK_PER_CLK = 4,parameter MEM_BURST_LEN = 8,parameter DWIDTH = 32,parameter DATA_PATTERN = \"DGEN_ALL\",parameter NUM_DQ_PINS = 8,parameter SEL_VICTIM_LINE = 3,parameter MEM_COL_WIDTH = 10,parameter EYE_TEST = \"FALSE\") (input clk_i,input [9:0] rst_i,output cmd_rdy_o,input cmd_valid_i,input cmd_validB_i,input cmd_validC_i,input [31:0] prbs_fseed_i,input [3:0] data_mode_i,input mem_init_done_i,input wr_data_mask_gen_i,input [31:0] simple_data0 ,input [31:0] simple_data1 ,input [31:0] simple_data2 ,input [31:0] simple_data3 ,input [31:0] simple_data4 ,input [31:0] simple_data5 ,input [31:0] simple_data6 ,input [31:0] simple_data7 ,input [31:0] fixed_data_i,input mode_load_i,input [31:0] addr_i,input [BL_WIDTH-1:0] bl_i,input data_rdy_i,output data_valid_o,output last_word_wr_o,output [NUM_DQ_PINS*nCK_PER_CLK*2-1:0] data_o,output [(NUM_DQ_PINS*nCK_PER_CLK*2/8) - 1:0] data_mask_o,output data_wr_end_o);\n [/INST]\n", "output": "wire data_valid; \n reg cmd_rdy; \n  assign data_valid_o = data_valid; \n wr_data_gen #(.TCQ (TCQ),.FAMILY (FAMILY),.MEM_TYPE (MEM_TYPE),.NUM_DQ_PINS (NUM_DQ_PINS),.MEM_BURST_LEN (MEM_BURST_LEN),.BL_WIDTH (BL_WIDTH),.START_ADDR (START_ADDR),.nCK_PER_CLK (nCK_PER_CLK),.SEL_VICTIM_LINE (SEL_VICTIM_LINE),.DATA_PATTERN (DATA_PATTERN),.DWIDTH (DWIDTH),.COLUMN_WIDTH (MEM_COL_WIDTH),.EYE_TEST (EYE_TEST)) \n wr_data_gen(.clk_i (clk_i ),.rst_i (rst_i[9:5]),.prbs_fseed_i (prbs_fseed_i),.wr_data_mask_gen_i (wr_data_mask_gen_i),.mem_init_done_i (mem_init_done_i),.data_mode_i (data_mode_i ),.cmd_rdy_o (cmd_rdy_o ),.cmd_valid_i (cmd_valid_i ),.cmd_validB_i (cmd_validB_i ),.cmd_validC_i (cmd_validC_i ),.last_word_o (last_word_wr_o ),.fixed_data_i (fixed_data_i),.simple_data0 (simple_data0),.simple_data1 (simple_data1),.simple_data2 (simple_data2),.simple_data3 (simple_data3),.simple_data4 (simple_data4),.simple_data5 (simple_data5),.simple_data6 (simple_data6),.simple_data7 (simple_data7),.mode_load_i (mode_load_i),.addr_i (addr_i ),.bl_i (bl_i ),.data_rdy_i (data_rdy_i ),.data_valid_o ( data_valid ),.data_o (data_o ),.data_wr_end_o (data_wr_end_o),.data_mask_o (data_mask_o)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module has one output, reg_0x06, which is an 8-bit wire. The module initializes reg_0x06 to the 8-bit value 0x00.\n\n Module header:\n\nmodule r_USBTYPEC_REV_LOW(output wire [7:0] reg_0x06);\n [/INST]\n", "output": "assign reg_0x06=8'h00; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements an IMU message handling logic. It synchronizes the incoming data and triggers based on the system clock and external clock signals. It updates various registers and generates a timestamp output based on the trigger input. The module also handles read and write enable signals and updates the address and data input registers based on the clock edges. It includes logic to control the read and write operations and instantiates a myRAM_WxD_D module to handle the data storage operations.\n\n Module header:\n\nmodule imu_message ( sclk,xclk,we,wa,di,en,trig,ts,rdy,rd_stb,rdata);\n [/INST]\n", "output": "input sclk; \n  input xclk; \n  input we; \n  input [3:0] wa; \n  input [15:0] di; \n  input en; \n  input trig; \n  output ts; \n  output rdy; \n  input rd_stb; \n  output [15:0] rdata; \n  reg [ 4:0] raddr; \n  reg rdy=1'b0; \n  reg we_d; \n  reg [ 4:1] waddr; \n  reg [ 2:0] trig_d; \n  reg [ 7:0] denoise_count; \n  reg [ 1:0] trig_denoise; \n  reg ts; \n  reg [15:0] di_d; \n  always @ (negedge sclk) begin \n  di_d[15:0] <= di[15:0]; \n  waddr[4:1] <= wa[3:0]; \n  we_d <=we; \n  end \n  always @ (posedge xclk) begin \n  if (!en) trig_d[2:0] <= 3'h0; \n  else trig_d[2:0] <= {trig_d[1:0], trig}; \n  if (!en) trig_denoise[0] <= 1'b0; \n  else if (denoise_count[7:0]==8'h0) trig_denoise[0] <= trig_d[2]; \n  if (trig_d[2]==trig_denoise[0]) denoise_count[7:0] <= 8'hff; \n  else denoise_count[7:0] <= denoise_count[7:0] - 1; \n  trig_denoise[1] <= trig_denoise[0]; \n  ts <= !trig_denoise[1] && trig_denoise[0]; \n  if (!en || ts) raddr[4:0] <= 5'h0; \n  else if (rd_stb) raddr[4:0] <= raddr[4:0] + 1; \n  if (ts || (rd_stb && (raddr[4:0]==5'h1b)) || !en) rdy <= 1'b0; \n  else if (trig_denoise[1] && !trig_denoise[0]) rdy <= 1'b1; \n  end \n  myRAM_WxD_D #( .DATA_WIDTH(16),.DATA_DEPTH(5)) \n i_odbuf (.D(di_d[15:0]),.WE(we | we_d),.clk(~sclk),.AW({waddr[4:1],we_d}),.AR(raddr[4:0]),.QW(),.QR(rdata[15:0])); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module CLA_32Bit_Adder is a 32-bit carry-lookahead adder. It consists of two 16-bit CLA_16Bits adder modules to calculate the lower and upper 16 bits of the sum. The CLA_Gen_2Bits module generates the carry lookahead signals for the 16-bit sections. The output carry CO is computed using the generated propagate (PP) and generate (GP) signals, and the carry-in (CI) signal. The sum output S is the concatenation of the lower and upper 16-bit results.\n\n Module header:\n\nmodule CLA_32Bit_Adder(CO,S,A,B,CI);\n [/INST]\n", "output": "output CO; \n  output [31:0] S; \n  input [31:0] A,B; \n  input CI; \n  wire GPP, PPP; \n  wire [1:0] PP, GP; \n  wire C16, C32, C48; \n  CLA_16Bits BITS15_0(PP[0],GP[0],S[15:0],A[15:0],B[15:0],CI), \n  BITS31_16(PP[1],GP[1],S[31:16],A[31:16],B[31:16],C16); \n  CLA_Gen_2Bits GEN31_0(PPP,GPP,C16,PP[1:0],GP[1:0],CI); \n  assign CO = GPP | PPP&CI; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a comparator mask with the functionality of comparing the values of inputs A and B using the mask M. It first extends the data width if necessary, and then uses a loop to compare the values of A, B, and M in each segment. The result of the comparison is stored in the output COUT. The module uses LUTs to perform the comparison and generate the final carry output.\n\n Module header:\n\nmodule generic_baseblocks_v2_1_0_comparator_mask # (parameter C_FAMILY = \"virtex6\",parameter integer C_DATA_WIDTH = 4) (input wire CIN,input wire [C_DATA_WIDTH-1:0] A,input wire [C_DATA_WIDTH-1:0] B,input wire [C_DATA_WIDTH-1:0] M,output wire COUT);\n [/INST]\n", "output": "genvar lut_cnt; \n  localparam integer C_BITS_PER_LUT = 2; \n  localparam integer C_NUM_LUT = ( C_DATA_WIDTH + C_BITS_PER_LUT - 1 ) / C_BITS_PER_LUT; \n  localparam integer C_FIX_DATA_WIDTH = ( C_NUM_LUT * C_BITS_PER_LUT > C_DATA_WIDTH ) ? C_NUM_LUT * C_BITS_PER_LUT : \n  C_DATA_WIDTH; \n  wire [C_FIX_DATA_WIDTH-1:0] a_local; \n  wire [C_FIX_DATA_WIDTH-1:0] b_local; \n  wire [C_FIX_DATA_WIDTH-1:0] m_local; \n  wire [C_NUM_LUT-1:0] sel; \n  wire [C_NUM_LUT:0] carry_local; \n  generate \n  assign carry_local[0] = CIN; \n  if ( C_NUM_LUT * C_BITS_PER_LUT > C_DATA_WIDTH ) begin : USE_EXTENDED_DATA \n  assign a_local = {A, {C_NUM_LUT * C_BITS_PER_LUT - C_DATA_WIDTH{1'b0}}}; \n  assign b_local = {B, {C_NUM_LUT * C_BITS_PER_LUT - C_DATA_WIDTH{1'b0}}}; \n  assign m_local = {M, {C_NUM_LUT * C_BITS_PER_LUT - C_DATA_WIDTH{1'b0}}}; \n  end else begin : NO_EXTENDED_DATA \n  assign a_local = A; \n  assign b_local = B; \n  assign m_local = M; \n  end \n  for (lut_cnt = 0; lut_cnt < C_NUM_LUT ; lut_cnt = lut_cnt + 1) begin : LUT_LEVEL \n assign sel[lut_cnt] = ( ( a_local[lut_cnt*C_BITS_PER_LUT +: C_BITS_PER_LUT] &m_local[lut_cnt*C_BITS_PER_LUT +: C_BITS_PER_LUT] ) ==( b_local[lut_cnt*C_BITS_PER_LUT +: C_BITS_PER_LUT] &m_local[lut_cnt*C_BITS_PER_LUT +: C_BITS_PER_LUT] ) ); \n  generic_baseblocks_v2_1_0_carry_and # \n (.C_FAMILY(C_FAMILY)) compare_inst \n (.COUT (carry_local[lut_cnt+1]),.CIN (carry_local[lut_cnt]),.S (sel[lut_cnt])); \n  end \n  assign COUT = carry_local[C_NUM_LUT]; \n  endgenerate \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a hierarchical module that instantiates a wb_slave module and connects its inputs and outputs to corresponding signals. The module includes signals for address, cycle, data, strobe, write enable, acknowledgment, data output, error, clock, and reset. The `wb_slave` module parameters are set with the specified ADDR_WIDTH, DATA_WIDTH, DATA_COUNT, and BASE_ADDRESS. The module effectively acts as a wrapper that facilitates the connection between the instantiated `wb_slave` module and the rest of the circuit.\n\n Module header:\n\nmodule hierarchical_wb_slave_0 #(parameter ADDR_WIDTH = 32,parameter BASE_ADDRESS = 128,parameter DATA_COUNT = 8,parameter DATA_WIDTH = 32) (input [31:0] adr_i,input cyc_i,input [31:0] dat_i,input stb_i,input we_i,output ack_o,output [31:0] dat_o,input clk_i,input rst_i);\n [/INST]\n", "output": "wire sub_slave_wb_system_to_wb_systemclk; \n  wire sub_slave_wb_system_to_wb_systemrst; \n  wire sub_slave_wb_slave_to_wb_slaveack; \n  wire [31:0] sub_slave_wb_slave_to_wb_slaveadr; \n  wire sub_slave_wb_slave_to_wb_slavecyc; \n  wire [31:0] sub_slave_wb_slave_to_wb_slavedat_ms; \n  wire [31:0] sub_slave_wb_slave_to_wb_slavedat_sm; \n  wire sub_slave_wb_slave_to_wb_slaveerr; \n  wire sub_slave_wb_slave_to_wb_slavestb; \n  wire sub_slave_wb_slave_to_wb_slavewe; \n  wire sub_slave_ack_o; \n  wire [31:0] sub_slave_adr_i; \n  wire sub_slave_clk_i; \n  wire sub_slave_cyc_i; \n  wire [31:0] sub_slave_dat_i; \n  wire [31:0] sub_slave_dat_o; \n  wire sub_slave_err_o; \n  wire sub_slave_rst_i; \n  wire sub_slave_stb_i; \n  wire sub_slave_we_i; \n  assign ack_o = sub_slave_wb_slave_to_wb_slaveack; \n  assign sub_slave_wb_slave_to_wb_slaveadr[31:0] = adr_i[31:0]; \n  assign sub_slave_wb_system_to_wb_systemclk = clk_i; \n  assign sub_slave_wb_slave_to_wb_slavecyc = cyc_i; \n  assign sub_slave_wb_slave_to_wb_slavedat_ms[31:0] = dat_i[31:0]; \n  assign dat_o[31:0] = sub_slave_wb_slave_to_wb_slavedat_sm[31:0]; \n  assign sub_slave_wb_system_to_wb_systemrst = rst_i; \n  assign sub_slave_wb_slave_to_wb_slavestb = stb_i; \n  assign sub_slave_wb_slave_to_wb_slavewe = we_i; \n  assign sub_slave_wb_slave_to_wb_slaveack = sub_slave_ack_o; \n  assign sub_slave_adr_i[31:0] = sub_slave_wb_slave_to_wb_slaveadr[31:0]; \n  assign sub_slave_clk_i = sub_slave_wb_system_to_wb_systemclk; \n  assign sub_slave_cyc_i = sub_slave_wb_slave_to_wb_slavecyc; \n  assign sub_slave_dat_i[31:0] = sub_slave_wb_slave_to_wb_slavedat_ms[31:0]; \n  assign sub_slave_wb_slave_to_wb_slavedat_sm[31:0] = sub_slave_dat_o[31:0]; \n  assign sub_slave_rst_i = sub_slave_wb_system_to_wb_systemrst; \n  assign sub_slave_stb_i = sub_slave_wb_slave_to_wb_slavestb; \n  assign sub_slave_we_i = sub_slave_wb_slave_to_wb_slavewe; \n wb_slave #(.ADDR_WIDTH (32),.DATA_WIDTH (32),.DATA_COUNT (8),.BASE_ADDRESS (128)) \n sub_slave(.adr_i (sub_slave_adr_i),.cyc_i (sub_slave_cyc_i),.dat_i (sub_slave_dat_i),.stb_i (sub_slave_stb_i),.we_i (sub_slave_we_i),.ack_o (sub_slave_ack_o),.dat_o (sub_slave_dat_o),.err_o (sub_slave_err_o),.clk_i (sub_slave_clk_i),.rst_i (sub_slave_rst_i)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements edge alignment between a fast clock signal and a slow clock signal. It detects the first edge of the fast clock signal and aligns it with the corresponding edge in the slow clock signal. The module utilizes registers to synchronize the two clock signals and identifies the first edge by combining the synchronized signals.\n\n Module header:\n\nmodule oh_edgealign (firstedge,fastclk, slowclk);\n [/INST]\n", "output": "input fastclk; \n  input slowclk; \n  output firstedge; \n  reg clk45; \n  reg clk90; \n  reg firstedge; \n  always @ (negedge fastclk) \n  clk45 <= slowclk; \n  always @ (posedge fastclk) \n  begin \n  clk90 <= clk45; \n  firstedge <= ~clk45 & clk90; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a UART transmitter. It uses a state machine to handle the transmission of data. The module has inputs for reset, clock, baud edge, and data ready, as well as an 8-bit data input. It also has outputs for the transmitted data (tx) and a signal indicating whether the data has been accepted (data_accepted). The module operates based on the baud rate edge and transitions through states of START, DATA, and END, handling the transmission of data accordingly. When data is ready, it is transmitted and the module transitions back to the START state.\n\n Module header:\n\nmodule UART_TX(input rst, clk, baud_edge, data_ready,input [7:0] data,output reg tx, data_accepted);\n [/INST]\n", "output": "localparam START = (1 << 0), DATA = (1 << 1), END = (1 << 2); \n  reg [7:0] data_reg; \n  reg [2:0] data_counter; \n  reg [3:0] state; \n  initial begin \n  tx <= 1; \n  data_accepted <= 0; \n  end \n  always @(posedge clk) begin \n  if(rst) begin \n  state <= END; \n  tx <= 1; \n  data_accepted <= 0; \n  end else if(baud_edge) begin \n  case(state) \n  START: begin \n  tx <= 0; \n  data_counter <= 0; \n  state <= DATA; \n  end \n  DATA: begin \n  tx <= data_reg[data_counter]; \n  if(data_counter != 7) begin \n  data_counter <= data_counter + 1; \n  end else begin \n  state <= END; \n  data_counter <= 0; \n  end \n  end \n  END: begin \n  tx <= 1; \n  if(data_ready) begin \n  data_accepted <= 1; \n  data_reg <= data; \n  state <= START; \n  end \n  end \n  default: begin \n  tx <= 1; \n  state <= END; \n  end \n  endcase \n  end else begin \n  data_accepted <= 0; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a D flip-flop (DFF) with synchronous reset functionality. It takes in a data input, clock input, and a reset input. The output q is the state of the D flip-flop. When the reset signal is active, the output q is set to 0. Otherwise, the output q is set to the input data on the rising edge of the clock signal.\n\n Module header:\n\nmodule dff(data ,q,clk ,reset);\n [/INST]\n", "output": "input data, clk, reset ; \n output q; \n reg q; \n always @ ( posedge clk or posedge reset) \n if (reset) begin \n  q <= 1'b0; \n end else begin \n  q <= data; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module implements a state machine that performs specific operations based on the input signals and the internal state. It uses a clock signal and a reset signal to control the state transitions. The module takes in the input N and processes it to produce output signals dp, done, counter, and sr. The state machine progresses through different states - INIT, RUN, ALMOSTDONE, DONE, and WAIT - based on the current state and input signals. The states are controlled by the clock and reset signals, and the module responds to the start input to initiate the state machine. The module also includes registers to store and manipulate the state, data pointer, shift register, counter, and other internal signals.\n\n Module header:\n\nmodule map9v3(clock, reset, start, N, dp, done, counter, sr);\n [/INST]\n", "output": "input clock; \n input start; \n input reset; \n input [8:0] N; \n output [8:0] dp; \n output done; \n output [7:0] counter; \n output [7:0] sr; \n reg [8:0] dp; \n reg [7:0] sr; \n reg [7:0] counter; \n reg [1:0] startbuf; \n reg done; \n reg [2:0] state; \n parameter INIT = 3'b000; \n parameter RUN = 3'b001; \n parameter ALMOSTDONE = 3'b010; \n parameter DONE = 3'b011; \n parameter WAIT = 3'b100; \n always @(posedge clock or posedge reset) begin \n  if (reset == 1) begin \n  dp <= 9'b0; \n  sr <= 8'b0; \n  counter <= 8'b0; \n  startbuf <= 2'b00; \n  done <= 0; \n  state <= INIT; \n  end else begin \n  if (state == INIT) begin \n  counter <= 255 - N[8:1] + 3; \n  sr <= 8'b0; \n  done <= 0; \n  state <= RUN; \n  end else if (state == RUN) begin \n  sr[7] <= sr[6]; \n  sr[6] <= sr[5]; \n  sr[5] <= sr[4]; \n  sr[4] <= sr[3]; \n  sr[3] <= sr[2]; \n  sr[2] <= sr[1]; \n  sr[1] <= sr[0]; \n  sr[0] <= ~(sr[7] ^ sr[5] ^ sr[4] ^ sr[3]); \n  counter <= counter - 1; \n  if (counter == 0) begin \n  state <= ALMOSTDONE; \n  end \n  end else if (state == ALMOSTDONE) begin \n  dp[0] <= N[0]; \n  dp[8:1] <= sr[7:0]; \n  state <= DONE; \n  end else if (state == DONE) begin \n  done <= 1; \n  state <= WAIT; \n  end else if (state == WAIT) begin \n  if (startbuf == 2'b01) begin \n  state <= INIT; \n  end \n  end \n  startbuf <= {startbuf[0], start}; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a test bench for an \"AmpTrig2\" module. It simulates the behavior of the \"AmpTrig2\" module by initializing the signals and generating clock cycles to drive the inputs. It sets the initial values of the clock, trigger, trigger_a, trig_out_en_b, and trig_out_delay_b signals. It then manipulates these signals over time using initial and always blocks. The trigger signal is set to 1 after 100 clock cycles, and then reset after a delay. The clock signal is inverted, and the trigger_a signal is updated based on the trigger signal. This test bench allows for simulation and testing of the \"AmpTrig2\" module's behavior.\n\n Module header:\n\nmodule AmpTrig_TB;\n [/INST]\n", "output": "reg clk; \n  reg trigger; \n  reg trig_out_en_b; \n  reg [6:0] trig_out_delay_b; \n  wire amp_trig; \n  reg trigger_a = 1'b0; \n AmpTrig2 uut (.clk(clk),.trigger_in(trigger_a),.trig_out_en_b(trig_out_en_b),.trig_out_delay_b(trig_out_delay_b),.amp_trig(amp_trig)); \n  initial begin \n  clk = 0; \n  trigger = 0; \n  trigger_a = 0; \n  trig_out_en_b = 0; \n  trig_out_delay_b = 0; \n  #100; \n  trig_out_en_b = 1; \n  trig_out_delay_b = 1; \n  #100; trigger = 1; \n  #9240; trigger_a = 0; \n  end \n  always #1.4 clk = ~clk; \n  always @(posedge clk) trigger_a <= trigger; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a part of an SD host physical layer. It consists of several input and output ports for interfacing with the SD host system. It also includes command and data state registers and their corresponding state machines to handle command and data transmission. The command state machine transitions through different states based on the input command signals, and the data state machine processes data based on the input data signals. The module also handles reset conditions and generates various control signals for the SD host interface.\n\n Module header:\n\nmodule sd_host_phy (input clk,input rst,input i_phy_crc_enable,input i_phy_ddr_en,input i_sd1_phy_flag,input i_sd4_phy_flag,input i_cmd_stb,input [39:0] i_cmd,input i_rsp_long_flag,output reg o_rsp_stb,output [135:0] o_rsp,input i_data_en_stb,output reg o_data_finish_ack_stb,input i_h2s_fifo_ready,output o_h2s_fifo_activate,input [23:0] i_h2s_fifo_size,output o_h2s_fifo_stb,input [31:0] i_h2s_fifo_data,input [1:0] i_s2h_fifo_ready,output [1:0] o_s2h_fifo_activate,input [23:0] i_s2h_fifo_size,input i_s2h_fifo_stb,output [31:0] o_s2h_fifo_data,output o_interrupt);\n [/INST]\n", "output": "localparam IDLE = 4'h0; \n localparam SEND_COMMAND = 4'h1; \n localparam CMD_RESPONSE = 4'h2; \n localparam SEND_DATA = 4'h1; \n localparam READ_DATA = 4'h2; \n reg [3:0] cmd_state; \n reg [3:0] data_state; \n always @ (posedge clk) begin \n  o_rsp_stb <= 1'b0; \n  if (rst) begin \n  cmd_state <= IDLE; \n  end \n  else begin \n  case (cmd_state) \n  IDLE: begin \n  if (i_cmd_stb) begin \n  end \n  end \n  SEND_COMMAND: begin \n  end \n  CMD_RESPONSE: begin \n  end \n  default: begin \n  end \n  endcase \n  end \n end \n always @ (posedge clk) begin \n  o_data_finish_ack_stb <= 1'b0; \n  if (rst) begin \n  data_state <= IDLE; \n  end \n  else begin \n  case (data_state) \n  IDLE: begin \n  if (i_data_stb) begin \n  end \n  end \n  SEND_DATA: begin \n  end \n  READ_DATA: begin \n  end \n  default: begin \n  end \n  endcase \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an implementation of an altpriority encoder. It takes an 8-bit input data and produces a 3-bit output q. The module instantiates two altpriority encoder sub-modules for the lower and upper 4 bits of the input data. The outputs from these sub-modules are combined using logical operators to generate the final output q.\n\n Module header:\n\nmodule acl_fp_add_double_altpriority_encoder_bv7 (data,q) ;\n [/INST]\n", "output": "input [7:0] data; \n  output [2:0] q; \n  wire [1:0] wire_altpriority_encoder19_q; \n  wire [1:0] wire_altpriority_encoder20_q; \n  wire wire_altpriority_encoder20_zero; \n  acl_fp_add_double_altpriority_encoder_6v7 altpriority_encoder19 \n (.data(data[3:0]),.q(wire_altpriority_encoder19_q)); \n  acl_fp_add_double_altpriority_encoder_6e8 altpriority_encoder20 \n (.data(data[7:4]),.q(wire_altpriority_encoder20_q),.zero(wire_altpriority_encoder20_zero)); \n  assign \n  q = {(~ wire_altpriority_encoder20_zero), (({2{wire_altpriority_encoder20_zero}} & wire_altpriority_encoder19_q) | ({2{(~ wire_altpriority_encoder20_zero)}} & wire_altpriority_encoder20_q))}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a serial transmitter for sending data over a communication line. It includes a state machine to control the transmission process, with a mux_state register to track the state of transmission. It generates a start signal for the serial transmission and updates the output byte to be transmitted. The module also includes a busy output to indicate if the transmitter is busy, and it instantiates an async_transmitter module to handle the actual data transmission.\n\n Module header:\n\nmodule serial_transmit (clk, TxD, busy, send, word);\n [/INST]\n", "output": "wire TxD_start; \n  wire TxD_busy; \n  reg [7:0] out_byte; \n  reg serial_start; \n  reg [3:0] mux_state = 4'b0000; \n  assign TxD_start = serial_start; \n  input clk; \n  output TxD; \n  input [31:0] word; \n  input send; \n  output busy; \n  reg [31:0] word_copy; \n  assign busy = (|mux_state); \n  always @(posedge clk) \n  begin \n  if (!busy && send) \n  begin \n  mux_state <= 4'b1000; \n  word_copy <= word; \n  end \n  else if (mux_state[3] && ~mux_state[0] && !TxD_busy) \n  begin \n  serial_start <= 1; \n  mux_state <= mux_state + 1; \n  out_byte <= word_copy[31:24]; \n  word_copy <= (word_copy << 8); \n  end \n  else if (mux_state[3] && mux_state[0]) \n  begin \n  serial_start <= 0; \n  if (!TxD_busy) mux_state <= mux_state + 1; \n  end \n  end \n  async_transmitter serializer(.clk(clk), .TxD(TxD), .TxD_start(TxD_start), .TxD_data(out_byte), .TxD_busy(TxD_busy)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a master interface for an AXI protocol. It takes input signals clk, reset, wid_in, wdata_in, wstrb_in, wlast_in, and set_cmd, and provides outputs wid, wdata, wstrb, wlast, and wvalid. The module includes a simul_axi_fifo for managing the data flow with parameters for width, latency, and depth. The module also uses delays for the output signals wid, wdata, wstrb, wlast, and wvalid. The ready output is derived based on the input wready and is used to control the data flow.\n\n Module header:\n\nmodule simul_axi_master_wdata#(parameter integer ID_WIDTH=12,parameter integer DATA_WIDTH=32,parameter integer WSTB_WIDTH= 4,parameter integer LATENCY=0,parameter integer DEPTH=8,parameter DATA_DELAY = 3.5,parameter VALID_DELAY = 4.0)(input clk,input reset,input [ID_WIDTH-1:0] wid_in,input [DATA_WIDTH-1:0] wdata_in,input [WSTB_WIDTH-1:0] wstrb_in,input wlast_in,output [ID_WIDTH-1:0] wid,output [DATA_WIDTH-1:0] wdata,output [WSTB_WIDTH-1:0] wstrb,output wlast,output wvalid,input wready,input set_cmd,output ready);\n [/INST]\n", "output": "wire [ID_WIDTH-1:0] wid_out; \n  wire [DATA_WIDTH-1:0] wdata_out; \n  wire [WSTB_WIDTH-1:0] wstrb_out; \n  wire wlast_out; \n  wire wvalid_out; \n  assign #(DATA_DELAY) wid= wid_out; \n  assign #(DATA_DELAY) wdata= wdata_out; \n  assign #(DATA_DELAY) wstrb= wstrb_out; \n  assign #(DATA_DELAY) wlast= wlast_out; \n  assign #(VALID_DELAY) wvalid= wvalid_out; \n simul_axi_fifo \n #(.WIDTH(ID_WIDTH+DATA_WIDTH+WSTB_WIDTH+1),.LATENCY(LATENCY),.DEPTH(DEPTH)) simul_axi_fifo_i (.clk(clk),.reset(reset),.data_in({wid_in, wdata_in, wstrb_in, wlast_in}),.load(set_cmd),.input_ready(ready),.data_out({wid_out, wdata_out, wstrb_out, wlast_out}),.valid(wvalid_out),.ready(wready)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a TSB (Tri-State Buffer) that takes a 32-bit input and an enable signal. When the enable signal is asserted, the input is passed through to the output; otherwise, the output is tri-stated (high impedance state).\n\n Module header:\n\nmodule tsb(in, enable, out);\n [/INST]\n", "output": "input [31:0] in; \n  input enable; \n  output [31:0] out; \n  wire [31:0] in, out; \n  wire enable; \n  assign out = (enable) ? in : 32'bz; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module implements a Mealy finite state machine. It has four states, and based on the input and current state, it transitions to the next state and generates an output. The module is sensitive to both the clock and reset signals. The output is updated based on the input and the current state, with transitions defined for each state and input combination.\n\n Module header:\n\nmodule Mealy (output out,input in,input clk,input reset_n);\n [/INST]\n", "output": "parameter S0 = 2'b00; \n parameter S1 = 2'b01; \n parameter S2 = 2'b10; \n parameter S3 = 2'b11; \n reg state, nextState; \n reg out; \n always @(posedge clk or negedge reset_n) begin \n  if (!reset_n) begin \n  state <= 0; \n  end else begin \n  state <= nextState; \n  end \n end \n always @(*) begin \n  case(state) \n  S0: begin \n  if (in == 0) begin \n  nextState <= S0; \n  out <= 0; \n  end else if (in == 1) begin \n  nextState <= S1; \n  out <= 1; \n  end else begin \n  nextState <= S0; \n  out <= 0; \n  end \n  end \n  S1: begin \n  if (in == 0) begin \n  nextState <= S1; \n  out <= 0; \n  end else if (in == 1) begin \n  nextState <= S2; \n  out <= 1; \n  end else begin \n  nextState <= S0; \n  out <= 0; \n  end \n  end \n  S2: begin \n  if (in == 0) begin \n  nextState <= S2; \n  out <= 0; \n  end else if (in == 1) begin \n  nextState <= S3; \n  out <= 1; \n  end else begin \n  nextState <= S0; \n  out <= 0; \n  end \n  end \n  S3: begin \n  if (in == 0) begin \n  nextState <= S3; \n  out <= 0; \n  end else if (in == 1) begin \n  nextState <= S0; \n  out <= 1; \n  end else begin \n  nextState <= S0; \n  out <= 0; \n  end \n  end \n  endcase \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements an alternate priority encoder. It takes a 4-bit input data and outputs a 2-bit result. It has two sub-modules, `altpriority_encoder41` and `altpriority_encoder42`, each taking a 2-bit input. The output `q` is determined by combining the outputs of these sub-modules based on specific logical conditions.\n\n Module header:\n\nmodule acl_fp_add_double_altpriority_encoder_q28 (data,q) ;\n [/INST]\n", "output": "input [3:0] data; \n  output [1:0] q; \n  wire [0:0] wire_altpriority_encoder41_q; \n  wire wire_altpriority_encoder41_zero; \n  wire [0:0] wire_altpriority_encoder42_q; \n  acl_fp_add_double_altpriority_encoder_nh8 altpriority_encoder41 \n (.data(data[1:0]),.q(wire_altpriority_encoder41_q),.zero(wire_altpriority_encoder41_zero)); \n  acl_fp_add_double_altpriority_encoder_n28 altpriority_encoder42 \n (.data(data[3:2]),.q(wire_altpriority_encoder42_q)); \n  assign \n  q = {wire_altpriority_encoder41_zero, ((wire_altpriority_encoder41_zero & wire_altpriority_encoder42_q) | ((~ wire_altpriority_encoder41_zero) & wire_altpriority_encoder41_q))}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an IO buffer with configurable data width. It takes input data dio_t and dio_i, and outputs dio_o and dio_p as well as supporting inout functionality for bidirectional communication. For each bit in the data width, it assigns the output dio_o to the inout dio_p, and it assigns the inout dio_p based on the input dio_t and dio_i. It uses a generate loop to implement the IO buffer for each bit of the data width.\n\n Module header:\n\nmodule ad_iobuf #(parameter DATA_WIDTH = 1) (input [(DATA_WIDTH-1):0] dio_t,input [(DATA_WIDTH-1):0] dio_i,output [(DATA_WIDTH-1):0] dio_o,inout [(DATA_WIDTH-1):0] dio_p);\n [/INST]\n", "output": "genvar n; \n  generate \n  for (n = 0; n < DATA_WIDTH; n = n + 1) begin: g_iobuf \n  assign dio_o[n] = dio_p[n]; \n  assign dio_p[n] = (dio_t[n] == 1'b1) ? 1'bz : dio_i[n]; \n  end \n  endgenerate \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module implements a circuit that performs a bit-serial multiplication. It takes two 4-bit inputs, x and y, and computes their product using a sequence of 20 parallel adders and compressors (CSA and CPA) to produce an 8-bit output. The output bits are assigned based on the intermediate results from the adders and compressors.\n\n Module header:\n\nmodule problem1(out, x, y);\n [/INST]\n", "output": "output [7:0] out; \n input [3:0] x, y; \n wire c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20; \n wire s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16, s17, s18, s19, s20; \n CSA CSA1(s1, c1, 1'b0, y[0], x[0], 1'b0); \n CSA CSA2(s2, c2, 1'b0, y[1], x[0], 1'b0); \n CSA CSA3(s3, c3, 1'b0, y[2], x[0], 1'b0); \n CSA CSA4(s4, c4, 1'b0, y[3], x[0], 1'b0); \n CSA CSA5(s5, c5, s2, y[0], x[1], c1); \n CSA CSA6(s6, c6, s3, y[1], x[1], c2); \n CSA CSA7(s7, c7, s4, y[2], x[1], c3); \n CSA CSA8(s8, c8, 1'b0, y[3], x[1], c4); \n CSA CSA9(s9, c9, s6, y[0], x[2], c5); \n CSA CSA10(s10, c10, s7, y[1], x[2], c6); \n CSA CSA11(s11, c11, s8, y[2], x[2], c7); \n CSA CSA12(s12, c12, 1'b0, y[3], x[2], c8); \n CSA CSA13(s13, c13, s10, y[0], x[3], c9); \n CSA CSA14(s14, c14, s11, y[1], x[3], c10); \n CSA CSA15(s15, c15, s12, y[2], x[3], c11); \n CSA CSA16(s16, c16, 1'b0, y[3], x[3], c12); \n CPA CPA17(s17, c17, s14, c13, 1'b0); \n CPA CPA18(s18, c18, s15, c14, c17); \n CPA CPA19(s19, c19, s16, c15, c18); \n CPA CPA20(s20, c20, 1'b0, c16, c19); \n assign out[0] = s1; \n assign out[1] = s5; \n assign out[2] = s9; \n assign out[3] = s13; \n assign out[4] = s17; \n assign out[5] = s18; \n assign out[6] = s19; \n assign out[7] = s20; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a configurable edge latch. It has inputs for data, clock, set/reset, and pass_high, and an output q. It includes logic to capture the input signal d when the clock is high, or when the set/reset signal is high, and outputs the captured signal based on the pass_high input. If pass_high is true, it outputs the captured signal when high; otherwise, it outputs the captured signal when low.\n\n Module header:\n\nmodule ConfigurableEdgeLatch(d, clk, sr, srval, q, pass_high);\n [/INST]\n", "output": "input wire d; \n  input wire clk; \n  output wire q; \n  input wire sr; \n  input wire srval; \n  input wire pass_high; \n  reg pass_when_high; \n  always @(*) begin \n  if(clk) \n  pass_when_high <= d; \n  if(sr) \n  pass_when_high <= srval; \n  end \n  reg pass_when_low; \n  always @(*) begin \n  if(!clk) \n  pass_when_low <= d; \n  if(sr) \n  pass_when_low <= srval; \n  end \n  assign q = pass_high ? pass_when_high : pass_when_low; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module interfaces with a SOC system, which includes memory and clock signal controls. It uses the input clock and key signals to control the output LED and memory signals. The module also includes a oneshot element for generating a delayed key signal, and a blinker for controlling the LED based on the clock, delay, and reset signals.\n\n Module header:\n\nmodule sockit_test (input CLOCK_50,input [3:0] KEY,output [3:0] LED,output [12:0] hps_memory_mem_a,output [2:0] hps_memory_mem_ba,output hps_memory_mem_ck,output hps_memory_mem_ck_n,output hps_memory_mem_cke,output hps_memory_mem_cs_n,output hps_memory_mem_ras_n,output hps_memory_mem_cas_n,output hps_memory_mem_we_n,output hps_memory_mem_reset_n,inout [7:0] hps_memory_mem_dq,inout hps_memory_mem_dqs,inout hps_memory_mem_dqs_n,output hps_memory_mem_odt,output hps_memory_mem_dm,input hps_memory_oct_rzqin);\n [/INST]\n", "output": "wire [3:0] key_os; \n wire [3:0] delay; \n wire main_clk = CLOCK_50; \n assign delay[1] = 0; \n assign delay[2] = 0; \n oneshot os (.clk (main_clk),.edge_sig (KEY),.level_sig (key_os)); \n soc_system soc (.delay_ctrl_slower (delay[0]),.delay_ctrl_faster (key_os[1]),.memory_mem_a (hps_memory_mem_a),.memory_mem_ba (hps_memory_mem_ba),.memory_mem_ck (hps_memory_mem_ck),.memory_mem_ck_n (hps_memory_mem_ck_n),.memory_mem_cke (hps_memory_mem_cke),.memory_mem_cs_n (hps_memory_mem_cs_n),.memory_mem_ras_n (hps_memory_mem_ras_n),.memory_mem_cas_n (hps_memory_mem_cas_n),.memory_mem_we_n (hps_memory_mem_we_n),.memory_mem_reset_n (hps_memory_mem_reset_n),.memory_mem_dq (hps_memory_mem_dq),.memory_mem_dqs (hps_memory_mem_dqs),.memory_mem_dqs_n (hps_memory_mem_dqs_n),.memory_mem_odt (hps_memory_mem_odt),.memory_mem_dm (hps_memory_mem_dm),.memory_oct_rzqin (hps_memory_oct_rzqin),.clk_clk (main_clk),.reset_reset_n (!key_os[3])); \n blinker b (.clk (main_clk),.delay (delay),.led (LED),.reset (key_os[3]),.pause (key_os[2])); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, named data_swap, takes an input data_in and a swap_type that selects a specific data swapping pattern. It supports four swapping types: no swap, half-word swap, byte swap, and bit swap. The module generates different swapped versions of the input data based on the selected swap_type and assigns the result to the output data_swap. The swapping patterns are implemented using bitwise operations and conditional assignments within nested for-loops.\n\n Module header:\n\nmodule data_swap #(parameter WIDTH = 32)(output [WIDTH - 1:0] data_swap,input [WIDTH - 1:0] data_in,input [ 1:0] swap_type);\n [/INST]\n", "output": "localparam NO_SWAP = 2'b00; \n localparam HALF_WORD_SWAP = 2'b01; \n localparam BYTE_SWAP = 2'b10; \n localparam BIT_SWAP = 2'b11; \n localparam TYPES = 4; \n wire [WIDTH - 1 : 0] words[0 : TYPES - 1]; \n generate \n  genvar i, j; \n  for(i = 0; i < TYPES; i = i + 1) \n  begin:BLOCK \n  for(j = 0; j < WIDTH; j = j + 1) \n  begin: SUB_BLOCK \n  if(i != 3) \n  assign words[i][j] = data_in[(WIDTH - (WIDTH/2**i)) - 2*(WIDTH/2**i)*(j/(WIDTH/2**i)) + j]; \n  else \n  assign words[i][j] = data_in[WIDTH - 1 - j]; \n  end \n  end \n endgenerate \n assign data_swap = words[swap_type]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a state machine for serial data transmission. It uses a clock signal and a baud rate signal to control the transmission process. The module takes in input data, starts and done signals, and produces an output signal for transmission. The state machine has five states for transmitting data and managing the transmission process. It handles toggling the transmitter, shifting and transmitting data bits, and ensuring that the transmission is completed correctly. The module also includes logic for counting the ticks and resetting the count based on the baud rate and reset signals.\n\n Module header:\n\nmodule TX #( parameter stateA = 'b00001,parameter stateB = 'b00010,parameter stateC = 'b00100,parameter stateD = 'b01000,parameter stateE = 'b10000) (input clk,input baud_rate,input [7:0]d_in,input tx_start,output reg tx,output reg tx_done);\n [/INST]\n", "output": "reg [4:0] state = stateA; \n  reg [4:0] next_state = stateA; \n  reg tick_enable = 0; \n  integer count = 0; \n  reg rst_count = 1; \n  integer bit_count = 0; \n  reg [7:0] d_aux; \n  always@(posedge clk) \n  begin \n  state=next_state; \n  end \n  always@(posedge clk) \n  begin \n  case(state) \n  stateA: \n  if(tx_start == 1) next_state = stateB; \n  else next_state = stateA; \n  stateB: \n  if(bit_count == 1) next_state = stateC; \n  else next_state = stateB; \n  stateC: \n  if(bit_count == 9) next_state = stateD; \n  else next_state = stateC; \n  stateD: \n  if(bit_count == 10) next_state = stateE; \n  else next_state = stateD; \n  stateE: \n  if(tx_done == 1) next_state = stateA; \n  else next_state = stateE; \n  endcase \n  end \n  always@(posedge clk) \n  begin \n  case(state) \n  stateA: \n  begin \n  tx = 1; \n  tx_done = 1; \n  rst_count = 0; \n  tick_enable = 0; \n  end \n  stateB: \n  begin \n  tx_done = 0; \n  rst_count = 1; \n  tick_enable = 1; \n  if(count == 16) \n  begin \n  tx = 0; \n  d_aux = d_in; \n  bit_count = bit_count + 1; \n  rst_count = 0; \n  end \n  end \n  stateC: \n  begin \n  rst_count = 1; \n  if(count == 16) \n  begin \n  tx = d_aux[0]; \n  d_aux = d_aux >> 1; \n  bit_count = bit_count + 1; \n  rst_count = 0; \n  end \n  end \n  stateD: \n  begin \n  rst_count = 1; \n  if(count == 16) \n  begin \n  tx = 1; \n  bit_count = bit_count + 1; \n  rst_count = 0; \n  end \n  end \n  stateE: \n  begin \n  if(count == 16) \n  begin \n  bit_count = 0; \n  tx_done = 1; \n  end \n  end \n  endcase \n  end \n always@(posedge baud_rate or negedge rst_count) \n  begin \n  if(rst_count == 0) count = 0; \n  else \n  begin \n  if(tick_enable == 1)count = count + 1; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a 2:1 compressor, which takes two input vectors 'a' and 'b', and produces two output vectors 's' and 'c'. The 's' output is the result of the XOR operation between 'a' and 'b', while the 'c' output is the result of the AND operation between 'a' and 'b'. The width of the input and output vectors is parameterized.\n\n Module header:\n\nmodule compressor2(a,b,s,c);\n [/INST]\n", "output": "parameter width = 0; \n  input [width-1:0] a; \n  input [width-1:0] b; \n  output [width-1:0] s; \n  output [width-1:0] c; \n  assign s = a ^ b; \n  assign c = a & b; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module defines a 16-bit memory with clock and reset inputs, write enable, address bus, and input/output data signals. The module initializes the memory to zeros upon reset and loads data from a hex file. It also includes logic to write data to memory when enabled. This module effectively provides the functionality of a basic 16-bit memory unit with initialization and write capabilities.\n\n Module header:\n\nmodule pdp1_memory(i_clk, i_rst,mm_we, mm_adr, mm_din, mm_dout);\n [/INST]\n", "output": "input i_clk; \n  input i_rst; \n  input mm_we; \n  input [0:11] mm_adr; \n  output [0:17] mm_din; \n  input [0:17] mm_dout; \n  reg [0:18] m_memory [0:4095]; \n  integer i; \n  assign mm_din = (~mm_we) ? m_memory[mm_adr] : 18'h00000; \n  always @(posedge i_clk) begin \n  if(i_rst) begin \n  for(i = 0; i < 4095; i = i + 1) \n  m_memory[i] = 0; \n  $readmemh(\"test.hex\", m_memory); \n  end \n  else begin \n  if(mm_we) begin \n  m_memory[mm_adr] <= mm_dout; \n  end \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes an input data (i_data0), and surrounds it with registers for synchronization. It uses a multiplier block to multiply the input data with a 32-bit constant. The result is then stored in the output data (o_data0). The module operates on a positive edge-triggered clock signal to ensure synchronous operation.\n\n Module header:\n\nmodule surround_with_regs(i_data0,o_data0,clk);\n [/INST]\n", "output": "input [31:0] i_data0; \n  output [31:0] o_data0; \n  reg [31:0] o_data0; \n  input clk; \n  reg [31:0] i_data0_reg; \n  wire [30:0] o_data0_from_mult; \n  always @(posedge clk) begin \n  i_data0_reg <= i_data0; \n  o_data0 <= o_data0_from_mult; \n  end \n multiplier_block mult_blk(.i_data0(i_data0_reg),.o_data0(o_data0_from_mult)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a D Flip-Flop with Set/Reset. It has inputs for power supply, ground, clock, data, and set/reset. The Q and Q_N outputs represent the flip-flop output and its complement. Inside the module, there's a D Flip-Flop with preset and clear, a notification register, and several conditional and delay elements. The awake signal indicates if the power supply is active. The module also contains conditional signals, a notification signal, and buffer assignments for Q and Q_N outputs. The functionality is centered around the D Flip-Flop behavior and conditional set/reset based on the input signals.\n\n Module header:\n\nmodule sky130_fd_sc_hs__dfsbp (VPWR ,VGND ,Q ,Q_N ,CLK ,D ,SET_B);\n [/INST]\n", "output": "input VPWR ; \n  input VGND ; \n  output Q ; \n  output Q_N ; \n  input CLK ; \n  input D ; \n  input SET_B; \n  wire buf_Q ; \n  wire SET ; \n  reg notifier ; \n  wire D_delayed ; \n  wire SET_B_delayed; \n  wire CLK_delayed ; \n  wire awake ; \n  wire cond0 ; \n  wire cond1 ; \n  not not0 (SET , SET_B_delayed ); \n  sky130_fd_sc_hs__u_df_p_s_no_pg u_df_p_s_no_pg0 (buf_Q , D_delayed, CLK_delayed, SET, notifier, VPWR, VGND); \n  assign awake = ( VPWR === 1'b1 ); \n  assign cond0 = ( SET_B_delayed === 1'b1 ); \n  assign cond1 = ( SET_B === 1'b1 ); \n  buf buf0 (Q , buf_Q ); \n  not not1 (Q_N , buf_Q ); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a keyboard controller that scans the keyboard matrix to detect key presses and outputs the row and column numbers, as well as the corresponding BCD codes. It includes debounce logic to ensure reliable key press detection and a reset mechanism for initialization. The module also handles the encoding of the key press into BCD format and updates the key buffer accordingly. The module employs clock signals to synchronize its operations and utilizes sensitivity lists for different event triggers.\n\n Module header:\n\nmodule KeyBoard_ctrl(CLK, RESET, ROW, COLUMN, DECODE_BCD1, DECODE_BCD0);\n [/INST]\n", "output": "input CLK; \n  input RESET; \n  input [3:0] COLUMN; \n  output [3:0] ROW; \n  output [3:0] DECODE_BCD0; \n  output [3:0] DECODE_BCD1; \n  reg [3:0] ROW; \n  reg [3:0] DEBOUNCE_COUNT; \n  reg [3:0] SCAN_CODE; \n  reg [3:0] DECODE_BCD0; \n  reg [3:0] DECODE_BCD1; \n  reg [3:0] KEY_CODE; \n  reg [7:0] KEY_BUFFER; \n  reg [14:0] DIVIDER; \n  reg PRESS; \n  wire PRESS_VALID; \n  wire DEBOUNCE_CLK; \n  wire SCAN_CLK; \n  always @(posedge CLK or negedge RESET) \n  begin \n  if (!RESET) \n  DIVIDER <= {12'h000,2'b00}; \n  else \n  DIVIDER <= DIVIDER + 1; \n  end \n  assign DEBOUNCE_CLK = DIVIDER[14]; \n  assign SCAN_CLK = DIVIDER[14]; \n  always @(posedge CLK or negedge RESET) \n  begin \n  if (!RESET) \n  SCAN_CODE <= 4'h0; \n  else if (PRESS) \n  SCAN_CODE <= SCAN_CODE + 1; \n  end \n  always @(SCAN_CODE,COLUMN) \n  begin \n  case (SCAN_CODE[3:2]) \n  2'b00 : ROW = 4'b1110; \n  2'b01 : ROW = 4'b1101; \n  2'b10 : ROW = 4'b1011; \n  2'b11 : ROW = 4'b0111; \n  endcase \n  case (SCAN_CODE[1:0]) \n  2'b00 : PRESS = COLUMN[0]; \n  2'b01 : PRESS = COLUMN[1]; \n  2'b10 : PRESS = COLUMN[2]; \n  2'b11 : PRESS = COLUMN[3]; \n  endcase \n  end \n  always @(posedge DEBOUNCE_CLK or negedge RESET) \n  begin \n  if (!RESET) \n  DEBOUNCE_COUNT <= 4'h0; \n  else if (PRESS) \n  DEBOUNCE_COUNT <= 4'h0; \n  else if (DEBOUNCE_COUNT <= 4'hE) \n  DEBOUNCE_COUNT <= DEBOUNCE_COUNT + 1; \n  end \n  assign PRESS_VALID = (DEBOUNCE_COUNT == 4'hD)? 1'b1 : 1'b0; \n  reg [3:0] TMP_VALUE; \n  always @(negedge DEBOUNCE_CLK or negedge RESET) \n  begin \n  case (SCAN_CODE) \n  4'b1100: TMP_VALUE <= 0; \n  4'b1101: TMP_VALUE <= 1; \n  4'b1001: TMP_VALUE <= 2; \n  4'b0101: TMP_VALUE <= 3; \n  4'b1110: TMP_VALUE <= 4; \n  4'b1010: TMP_VALUE <= 5; \n  4'b0110: TMP_VALUE <= 6; \n  4'b1111: TMP_VALUE <= 7; \n  4'b1011: TMP_VALUE <= 8; \n  4'b0111: TMP_VALUE <= 9; \n  default: TMP_VALUE <= 0; \n  endcase \n  if (!RESET) \n  KEY_BUFFER <= 16'hCC99; \n  else if (PRESS_VALID) \n  KEY_BUFFER <= {KEY_BUFFER[3:0],TMP_VALUE}; \n  end \n  always @(KEY_BUFFER) \n  begin \n  DECODE_BCD1 = KEY_BUFFER[7:4]; \n  DECODE_BCD0 = KEY_BUFFER[3:0]; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an I2C master that communicates with a peripheral device. It takes in various control signals including write, send, start, and endcomm, along with a clock signal and a byte of data. It utilizes these inputs to control the I2C clock and data line signals. The module has internal state machines to handle the different phases of the I2C communication protocol, such as generating start and stop conditions, sending data, and acknowledging the received data. The module also indicates completion through the 'done' output signal.\n\n Module header:\n\nmodule i2c_master (input clk,input write,input send,input start,input endcomm,input ioclk,input [7:0] byte,output reg i2c_clk,inout i2c_sda,output reg done);\n [/INST]\n", "output": "reg sda_out; \n reg sda_oe; \n assign i2c_sda = sda_oe ? sda_out : 1'bz; \n reg [3:0] sendcount; \n reg [7:0] byte_buf; \n reg [1:0] phase; \n reg sending; \n reg starting; \n reg ending; \n reg ioclk_now; \n reg ioclk_prev; \n always @(posedge ioclk) \n begin \n  if (write) begin \n  byte_buf <= byte; \n  end \n  if (send) begin \n  sda_oe <= 1'b1; \n  sending <= 1'b1; \n  starting <= 1'b0; \n  ending <= 1'b0; \n  phase <= 1'b0; \n  done <= 0; \n  sendcount <= 4'h0; \n  end else if (start) begin \n  sda_oe <= 1'b1; \n  starting <= 1'b1; \n  sending <= 1'b0; \n  ending <= 1'b0; \n  phase <= 1'b0; \n  done <= 0; \n  i2c_clk <= 1'b1; \n  end else if (endcomm) begin \n  starting <= 1'b0; \n  sending <= 1'b0; \n  ending <= 1'b1; \n  phase <= 1'b0; \n  done <= 0; \n  end \n  if (sending) begin \n  case (phase) \n  0: \n  begin \n  i2c_clk <= 1'b0; \n  phase <= 2'h1; \n  end \n  1: \n  begin \n  if (sendcount == 8) begin \n  sda_oe <= 1'b0; \n  end \n  if (sendcount == 9) begin \n  sending <= 1'b0; \n  done <= 1; \n  sda_oe <= 1'b1; \n  phase <= 2'h0; \n  end \n  sda_out <= byte_buf[7]; \n  byte_buf[7:1] <= byte_buf[6:0]; \n  phase <= 2'h2; \n  end \n  2: \n  begin \n  i2c_clk <= 1'b1; \n  phase <= 2'h3; \n  end \n  3: \n  begin \n  phase <= 2'h0; \n  sendcount <= sendcount + 1'b1; \n  end \n  endcase \n  end else if (starting) begin \n  case (phase) \n  0: \n  begin \n  i2c_clk <= 1'b1; \n  sda_out <= 1'b1; \n  phase <= 2'h1; \n  end \n  1: \n  begin \n  sda_out <= 1'b0; \n  starting <= 1'b0; \n  phase <= 2'b0; \n  done <= 1'b1; \n  end \n  endcase \n  end else if (ending) begin \n  case (phase) \n  0: \n  begin \n  phase <= 2'h1; \n  i2c_clk <= 1'b0; \n  phase <= 2'h1; \n  end \n  1: \n  begin \n  sda_oe <= 1'b1; \n  sda_out <= 1'b0; \n  phase <= 2'h2; \n  end \n  2: \n  begin \n  i2c_clk <= 1'b1; \n  phase <= 2'h3; \n  end \n  3: \n  begin \n  sda_out <= 1'b1; \n  ending <= 1'b0; \n  phase <= 2'b0; \n  done <= 1'b1; \n  end \n  endcase \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes two 28-bit vectors (Ax, Ay, Az) and (Bx, By, Bz) as inputs and performs vector subtraction to produce the output vectors (Cx, Cy, Cz) using a clock signal. The subtraction is performed by two's complement arithmetic. The resulting output vectors are stored in registers and updated on the rising edge of the clock signal.\n\n Module header:\n\n module vectsub (Ax, Ay, Az, Bx, By, Bz, Cx, Cy, Cz, clk);\n [/INST]\n", "output": "input[28 - 1:0] Ax; \n  input[28 - 1:0] Ay; \n  input[28 - 1:0] Az; \n  input[28 - 1:0] Bx; \n  input[28 - 1:0] By; \n  input[28 - 1:0] Bz; \n  output[28:0] Cx; \n  reg[28:0] Cx; \n  output[28:0] Cy; \n  reg[28:0] Cy; \n  output[28:0] Cz; \n  reg[28:0] Cz; \n  input clk; \n  always @(posedge clk) \n  begin \n  Cx <= ({Ax[28 - 1], Ax}) - ({Bx[28 - 1], Bx}) ; \n  Cy <= ({Ay[28 - 1], Ay}) - ({By[28 - 1], By}) ; \n  Cz <= ({Az[28 - 1], Az}) - ({Bz[28 - 1], Bz}) ; \n  end \n  endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module represents a basic boundary scan cell for testing digital integrated circuits. The module has inputs for the input pin, data from the previous boundary scan cell, control signals for capturing and shifting data, the TCK clock signal, and an output for the next boundary scan cell. \n\nInside the module, a latch is used to hold the selected input from either the InputPin or the data from the previous boundary scan cell, based on the CaptureDR control signal. On the positive edge of the TCK clock signal, the latch is updated with the selected input if either CaptureDR or ShiftDR is true. On the negative edge of the TCK signal, the ToNextBSCell output is updated with the value stored in the latch.\n\nOverall, this module enables the selection and capture of input data and its propagation to the next boundary scan cell based on control signals and clock edges.\n\n Module header:\n\nmodule InputCell( InputPin, FromPreviousBSCell, CaptureDR, ShiftDR, TCK, ToNextBSCell);\n [/INST]\n", "output": "input InputPin; \n input FromPreviousBSCell; \n input CaptureDR; \n input ShiftDR; \n input TCK; \n reg Latch; \n output ToNextBSCell; \n reg ToNextBSCell; \n wire SelectedInput = CaptureDR? InputPin : FromPreviousBSCell; \n always @ (posedge TCK) \n begin \n  if(CaptureDR | ShiftDR) \n  Latch<=SelectedInput; \n end \n always @ (negedge TCK) \n begin \n  ToNextBSCell<=Latch; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, named \"d_CS_shortening_matrix_alpha_to_003,\" takes a 12-bit input and generates a 12-bit output based on specific XOR combinations of the input bits. Each output bit is calculated based on a unique set of input bit XOR operations, resulting in a modified output.\n\n Module header:\n\nmodule d_CS_shortening_matrix_alpha_to_003(i_in, o_out);\n [/INST]\n", "output": "input wire [`D_CS_GF_ORDER-1:0] i_in; \n  output wire [`D_CS_GF_ORDER-1:0] o_out; \n  assign o_out[0] = i_in[0] ^ i_in[5] ^ i_in[8] ^ i_in[9] ^ i_in[10] ^ i_in[11]; \n  assign o_out[1] = i_in[0] ^ i_in[1] ^ i_in[6] ^ i_in[9] ^ i_in[10] ^ i_in[11]; \n  assign o_out[2] = i_in[1] ^ i_in[2] ^ i_in[7] ^ i_in[10] ^ i_in[11]; \n  assign o_out[3] = i_in[0] ^ i_in[2] ^ i_in[3] ^ i_in[5] ^ i_in[9] ^ i_in[10]; \n  assign o_out[4] = i_in[0] ^ i_in[1] ^ i_in[3] ^ i_in[4] ^ i_in[5] ^ i_in[6] ^ i_in[8] ^ i_in[9]; \n  assign o_out[5] = i_in[1] ^ i_in[2] ^ i_in[4] ^ i_in[5] ^ i_in[6] ^ i_in[7] ^ i_in[9] ^ i_in[10]; \n  assign o_out[6] = i_in[2] ^ i_in[3] ^ i_in[5] ^ i_in[6] ^ i_in[7] ^ i_in[8] ^ i_in[10] ^ i_in[11]; \n  assign o_out[7] = i_in[0] ^ i_in[3] ^ i_in[4] ^ i_in[5] ^ i_in[6] ^ i_in[7] ^ i_in[10]; \n  assign o_out[8] = i_in[1] ^ i_in[4] ^ i_in[5] ^ i_in[6] ^ i_in[7] ^ i_in[8] ^ i_in[11]; \n  assign o_out[9] = i_in[2] ^ i_in[5] ^ i_in[6] ^ i_in[7] ^ i_in[8] ^ i_in[9]; \n  assign o_out[10] = i_in[3] ^ i_in[6] ^ i_in[7] ^ i_in[8] ^ i_in[9] ^ i_in[10]; \n  assign o_out[11] = i_in[4] ^ i_in[7] ^ i_in[8] ^ i_in[9] ^ i_in[10] ^ i_in[11]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module implements a queue controller for a hardware design. It includes logic for incrementing the queue tail and controlling read and write pointers. The module has inputs for queue operations, clock, and reset signals. It also has outputs for queue status and addresses. The internal logic includes registers for the queue pointers, adders for pointer increments, and logic to determine queue empty status and when to stop fetching data. Overall, the module manages the queue pointers and provides control signals for reading and writing data to the queue.\n\n Module header:\n\nmodule queue_controller (q_vtail_incr,q_rd,q_wr,q_reset,q_empty,stop_fetch,buff_rd_addr,buff_wr_addr,buff_wr_en,clk,rst);\n [/INST]\n", "output": "input q_vtail_incr; \n input q_rd; \n input q_wr; \n input q_reset; \n output q_empty; \n output stop_fetch; \n output [2:0] buff_rd_addr; \n output [2:0] buff_wr_addr; \n output buff_wr_en; \n input clk; \n input rst; \n wire [2:0] vtail; \n wire [2:0] tail; \n wire [2:0] head; \n wire [2:0] next_vtail; \n wire [2:0] next_tail; \n wire [2:0] next_head; \n wire [2:0] next_vtail_qualified; \n wire [2:0] next_tail_qualified; \n wire [2:0] next_head_qualified; \n wire [2:0] vtail_plus2; \n assign next_vtail_qualified = next_vtail & ~{3{q_reset}}; \n assign next_tail_qualified = next_tail & ~{3{q_reset}}; \n assign next_head_qualified = next_head & ~{3{q_reset}}; \n reg_3b Vtail(.out(vtail), .in(next_vtail_qualified), .wr_en(q_vtail_incr|q_reset), .clk(clk), .rst(rst)); \n reg_3b Tail(.out(tail), .in(next_tail_qualified), .wr_en(q_wr|q_reset), .clk(clk), .rst(rst)); \n reg_3b Head(.out(head), .in(next_head_qualified), .wr_en(q_rd|q_reset), .clk(clk), .rst(rst)); \n adder3bit Vtail_Incr(.sum(next_vtail), .cout(), .in1(vtail), .in2(3'b1)); \n adder3bit Tail_Incr(.sum(next_tail), .cout(), .in1(tail), .in2(3'b1)); \n adder3bit Head_Incr(.sum(next_head), .cout(), .in1(head), .in2(3'b1)); \n adder3bit Vtail_Plus2(.sum(vtail_plus2), .cout(), .in1(vtail), .in2(3'd2)); \n assign q_empty = (head == tail); \n assign stop_fetch = (head == next_vtail) | (head == vtail_plus2); \n assign buff_rd_addr = head; \n assign buff_wr_addr = tail; \n assign buff_wr_en = q_wr; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"pcreg\" contains a register \"rPC\" which holds an 8-bit value. The module has inputs for clock signal \"iCLK\", reset signal \"iPCRST\", jump enable signal \"iPCJEN\", and jump input \"iPCJIN\". It also has an output \"oIADDR\" which reflects the value of \"rPC\".\n\nThe register \"rPC\" is initialized to 8'h00 and is updated based on the following conditions:\n- If \"iPCRST\" is asserted, \"rPC\" is reset to 8'h00.\n- If \"iPCJEN\" is asserted, \"rPC\" is updated to the value of \"iPCJIN\".\n- If neither \"iPCRST\" nor \"iPCJEN\" is asserted, \"rPC\" is incremented by 1 on the positive clock edge.\n\nThe module constantly checks for the positive clock edge to update the value of \"rPC\" based on the above conditions.\n\n Module header:\n\nmodule pcreg(input iCLK,input iPCRST,input iPCJEN,input [7:0] iPCJIN,output [7:0] oIADDR);\n [/INST]\n", "output": "reg [7:0] rPC = 8'h00; \n  assign oIADDR = rPC; \n  always@(posedge iCLK) begin \n  if(iPCRST) begin \n  rPC <= 8'h00; \n  end \n  else begin \n  if(iPCJEN) begin \n  rPC <= iPCJIN; \n  end \n  else begin \n  rPC <= rPC + 8'd1; \n  end \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"simple_pic\" is a processor interface that handles interrupts. It has inputs for clock, reset, cycle, strobe, address, write enable, and data, and outputs for data, acknowledge, and interrupt. The module includes registers for interrupt handling, edge and level IRQs, and IRQ events. It also has logic to generate the output based on the inputs and handles the acknowledgment and interrupt signals. The module essentially facilitates interrupt handling in a simple processor system.\n\n Module header:\n\nmodule simple_pic(clk_i, rst_i, cyc_i, stb_i, adr_i, we_i, dat_i, dat_o, ack_o, int_o,irq);\n [/INST]\n", "output": "parameter is = 8; \n  parameter dwidth = 32; \n  input clk_i; \n  input rst_i; \n  input cyc_i; \n  input stb_i; \n  input [ 2:1] adr_i; \n  input we_i; \n  input [ dwidth-1:0] dat_i; \n  output [ dwidth-1:0] dat_o; \n  output ack_o; \n  output int_o; \n  input [is:1] irq; \n  reg [is:1] pol, edgen, pending, mask; \n  reg [is:1] lirq, dirq; \n  initial \n  begin \n  if(is > dwidth) \n  $display(\"simple_pic: max number of interrupts = data bus width.\"); \n  end \n  always @(posedge clk_i) \n  lirq <= #1 irq; \n  always @(posedge clk_i) \n  dirq <= #1 lirq; \n  function trigger; \n  input edgen, pol, lirq, dirq; \n  reg edge_irq, level_irq; \n  begin \n  edge_irq = pol ? (lirq & ~dirq) : (dirq & ~lirq); \n  level_irq = pol ? lirq : ~lirq; \n  trigger = edgen ? edge_irq : level_irq; \n  end \n  endfunction \n  reg [is:1] irq_event; \n  integer n; \n  always @(posedge clk_i) \n  for(n=1; n<=is; n=n+1) \n  irq_event[n] <= #1 trigger(edgen[n], pol[n], lirq[n], dirq[n]); \n  wire wb_acc = cyc_i & stb_i; \n  wire wb_wr = wb_acc & we_i; \n  always @(posedge clk_i) \n  if (rst_i) \n  begin \n  pol <= #1 {is{1'b0}}; \n  edgen <= #1 {is{1'b0}}; \n  mask <= #1 {is{1'b1}}; \n  end \n  else if(wb_wr) \n  case (adr_i) \n  2'b00: edgen <= #1 dat_i[is-1:0]; \n  2'b01: pol <= #1 dat_i[is-1:0]; \n  2'b10: mask <= #1 dat_i[is-1:0]; \n  2'b11: ; \n  endcase \n  always @(posedge clk_i) \n  if (rst_i) \n  pending <= #1 {is{1'b0}}; \n  else if ( wb_wr & (&adr_i) ) \n  pending <= #1 (pending & ~dat_i[is-1:0]) | irq_event; \n  else \n  pending <= #1 pending | irq_event; \n  reg [dwidth-1:0] dat_o; \n  always @(posedge clk_i) \n  case (adr_i) \n  2'b00: dat_o <= #1 { {(dwidth-is){1'b0}}, edgen}; \n  2'b01: dat_o <= #1 { {(dwidth-is){1'b0}}, pol}; \n  2'b10: dat_o <= #1 { {(dwidth-is){1'b0}}, mask}; \n  2'b11: dat_o <= #1 { {(dwidth-is){1'b0}}, pending}; \n  endcase \n  reg ack_o; \n  always @(posedge clk_i) \n  ack_o <= #1 wb_acc & !ack_o; \n  reg int_o; \n  always @(posedge clk_i) \n  if(rst_i) \n  int_o <= #1 0; \n  else \n  int_o <= #1 |(pending & ~mask); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a Vita Packet Generator. It uses state and sequence registers to generate the data output based on the input len. The module also uses state transitions and control signals to manage the packet generation process, ensuring that the source is ready and the destination is ready before advancing the state. The src_rdy_o output is set to 1, indicating that the source is ready. The module also handles reset and clear signals to initialize the state and sequence. The data_o output is assigned based on the state and sequence, including the start of frame (sof) and end of frame (eof) signals.\n\n Module header:\n\nmodule vita_pkt_gen (input clk, input reset, input clear,input [15:0] len,output [35:0] data_o, output src_rdy_o, input dst_rdy_i);\n [/INST]\n", "output": "reg [15:0] state; \n  reg [31:0] seq, data; \n  wire sof = (state == 0); \n  wire eof = (state == (len-1)); \n  wire consume = src_rdy_o & dst_rdy_i; \n  assign src_rdy_o = 1; \n  always @(posedge clk) \n  if(reset | clear) \n  begin \n  state <= 0; \n  seq <= 0; \n  end \n  else \n  if(consume) \n  if(eof) \n  begin \n  state <= 0; \n  seq <= seq + 1; \n  end \n  else \n  state <= state + 1; \n  always @* \n  case(state) \n  0 : data <= {24'h000,seq[3:0],len}; \n  1 : data <= seq; \n  default : data <= {~state,state}; \n  endcase \n  assign data_o = {2'b00, eof, sof, data}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"altera_int_osc\" instantiates a Cyclone 10 LP oscillator module called \"sd1\". It has an input \"oscena\" and an output \"clkout\". The oscillator's output \"wire_sd1_clkout\" is assigned to \"clkout\", allowing the module to provide the oscillator output as the final \"clkout\" signal.\n\n Module header:\n\nmodule altera_int_osc (clkout,oscena) ;\n [/INST]\n", "output": "output clkout; \n  input oscena; \n  wire wire_sd1_clkout; \n  cyclone10lp_oscillator sd1 \n (.clkout(wire_sd1_clkout),.oscena(oscena)); \n  assign \n  clkout = wire_sd1_clkout; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a single-port, dual-port RAM with a depth of 11 and a width of 16. It has inputs for clock, write enable, address, and data, as well as a read enable signal. The module stores data at the specified address when the write enable is asserted, and outputs the data stored at the specified address when the read enable is asserted. The module has 11 output ports, each providing the stored data from a specific address in the RAM.\n\n Module header:\n\nmodule SP_rf_LUT_RAM (clk,we,wa,di,re,do0,do1,do2,do3,do4,do5,do6,do7,do8,do9,do10);\n [/INST]\n", "output": "parameter depth=11; \n parameter width=16; \n parameter addr_width=4; \n input clk; \n input we; \n input [addr_width-1:0] wa; \n input [width-1:0] di; \n input re; \n output [width-1:0] do0; \n output [width-1:0] do1; \n output [width-1:0] do2; \n output [width-1:0] do3; \n output [width-1:0] do4; \n output [width-1:0] do5; \n output [width-1:0] do6; \n output [width-1:0] do7; \n output [width-1:0] do8; \n output [width-1:0] do9; \n output [width-1:0] do10; \n reg [width-1:0] ram [depth-1:0]; \n always @(posedge clk) \n begin \n  if (we) \n  ram[wa] <= di; \n  end \n assign do0 = re?ram[0]:16'hxxxx; \n assign do1 = re?ram[1]:16'hxxxx; \n assign do2 = re?ram[2]:16'hxxxx; \n assign do3 = re?ram[3]:16'hxxxx; \n assign do4 = re?ram[4]:16'hxxxx; \n assign do5 = re?ram[5]:16'hxxxx; \n assign do6 = re?ram[6]:16'hxxxx; \n assign do7 = re?ram[7]:16'hxxxx; \n assign do8 = re?ram[8]:16'hxxxx; \n assign do9 = re?ram[9]:16'hxxxx; \n assign do10= re?ram[10]:16'hxxxx; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a 17-bit D flip-flop with synchronous reset. It takes in a 17-bit input d and a clock signal clk. When the reset signal is low, it sets the output q to 0. Otherwise, it updates q with the input d on the rising edge of the clock.\n\n Module header:\n\nmodule dffr_17 (q, d, clk, reset);\n [/INST]\n", "output": "output [16:0] q; \n  input [16:0] d; \n  input clk, reset; \n  reg [16:0] q; \n  always @ (posedge clk or negedge reset) \n  if (reset == 0) \n  q <= 0; \n  else \n  q <= d; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an ITU-656 video decoder. It takes in 8-bit input data, clock, reset signals, and control signals, and outputs YCbCr, TV X, TV Y, TV control, and data valid signals. It operates based on the input data and control signals to decode video information, manage active video, and generate the necessary output signals for display. The module includes registers for maintaining window, control, active video, start, data validity, pre-field, field, format validity, TV Y, data control, Cb, Cr, and YCbCr. The module processes the input data and control signals according to the ITU-656 video decoding standard to produce the required video output signals.\n\n Module header:\n\nmodule ITU_656_Decoder(iTD_DATA,oTV_X,oTV_Y,oTV_Cont,oYCbCr,oDVAL,iSwap_CbCr,iSkip,iRST_N,iCLK_27 );\n [/INST]\n", "output": "input [7:0] iTD_DATA; \n input iSwap_CbCr; \n input iSkip; \n input iRST_N; \n input iCLK_27; \n output [15:0] oYCbCr; \n output [9:0] oTV_X; \n output [9:0] oTV_Y; \n output [31:0] oTV_Cont; \n output oDVAL; \n reg [23:0] Window; \n reg [17:0] Cont; \n reg Active_Video; \n reg Start; \n reg Data_Valid; \n reg Pre_Field; \n reg Field; \n wire SAV; \n reg FVAL; \n reg [9:0] TV_Y; \n reg [31:0] Data_Cont; \n reg [7:0] Cb; \n reg [7:0] Cr; \n reg [15:0] YCbCr; \n assign oTV_X = Cont>>1; \n assign oTV_Y = TV_Y; \n assign oYCbCr = YCbCr; \n assign oDVAL = Data_Valid; \n assign SAV = (Window==24'hFF0000)&(iTD_DATA[4]==1'b0); \n assign oTV_Cont= Data_Cont; \n always@(posedge iCLK_27 or negedge iRST_N) \n begin \n  if(!iRST_N) \n  begin \n  Active_Video<= 1'b0; \n  Start <= 1'b0; \n  Data_Valid <= 1'b0; \n  Pre_Field <= 1'b0; \n  Field <= 1'b0; \n  Window <= 24'h0; \n  Cont <= 18'h0; \n  Cb <= 8'h0; \n  Cr <= 8'h0; \n  YCbCr <= 16'h0; \n  FVAL <= 1'b0; \n  TV_Y <= 10'h0; \n  Data_Cont <= 32'h0; \n  end \n  else \n  begin \n  Window <= {Window[15:0],iTD_DATA}; \n  if(SAV) \n  Cont <= 18'h0; \n  else if(Cont<1440) \n  Cont <= Cont+1'b1; \n  if(SAV) \n  Active_Video<= 1'b1; \n  else if(Cont==1440) \n  Active_Video<= 1'b0; \n  Pre_Field <= Field; \n  if({Pre_Field,Field}==2'b10) \n  Start <= 1'b1; \n  if(Window==24'hFF0000) \n  begin \n  FVAL <= !iTD_DATA[5]; \n  Field <= iTD_DATA[6]; \n  end \n  if(iSwap_CbCr) \n  begin \n  case(Cont[1:0]) \n  0: Cb <= iTD_DATA; \n  1: YCbCr <= {iTD_DATA,Cr}; \n  2: Cr <= iTD_DATA; \n  3: YCbCr <= {iTD_DATA,Cb}; \n  endcase \n  end \n  else \n  begin \n  case(Cont[1:0]) \n  0: Cb <= iTD_DATA; \n  1: YCbCr <= {iTD_DATA,Cb}; \n  2: Cr <= iTD_DATA; \n  3: YCbCr <= {iTD_DATA,Cr}; \n  endcase \n  end \n if( Start&& FVAL&& Active_Video&& Cont[0]&& !iSkip ) \n  Data_Valid <= 1'b1; \n  else \n  Data_Valid <= 1'b0; \n  if(FVAL && SAV) \n  TV_Y<= TV_Y+1; \n  if(!FVAL) \n  TV_Y<= 0; \n  if(!FVAL) \n  Data_Cont <= 0; \n  if(Data_Valid) \n  Data_Cont <= Data_Cont+1'b1; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module implements a state machine with four sets of inputs (X0, X1, X2, X3) and outputs (Y0, Y1, Y2, Y3), as well as inputs for clock and reset, and an output next_out. The state machine updates the outputs based on the inputs and the next input signal.\n\n Module header:\n\nmodule DirSum_30916(clk, reset, next, next_out,X0, Y0,X1, Y1,X2, Y2,X3, Y3);\n [/INST]\n", "output": "output next_out; \n  input clk, reset, next; \n  reg [0:0] i5; \n  input [15:0] X0, \n  X1, \n  X2, \n  X3; \n  output [15:0] Y0, \n  Y1, \n  Y2, \n  Y3; \n  always @(posedge clk) begin \n  if (reset == 1) begin \n  i5 <= 0; \n  end \n  else begin \n  if (next == 1) \n  i5 <= 0; \n  else if (i5 == 1) \n  i5 <= 0; \n  else \n  i5 <= i5 + 1; \n  end \n  end \n codeBlock30740 codeBlockIsnt33270(.clk(clk), .reset(reset), .next_in(next), .next_out(next_out),.i5_in(i5),.X0_in(X0), .Y0(Y0),.X1_in(X1), .Y1(Y1),.X2_in(X2), .Y2(Y2),.X3_in(X3), .Y3(Y3)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes a 15-bit input and splits it into two separate outputs. The upper 5 bits of the input are assigned to output o1, and the lower 10 bits are assigned to output o0.\n\n Module header:\n\nmodule vef0f91_v9a2a06 (input [14:0] i,output [4:0] o1,output [9:0] o0);\n [/INST]\n", "output": "assign o1 = i[14:10]; \n  assign o0 = i[9:0]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a ham_15_11_decoder that takes a 15-bit input control signal c and produces an 11-bit output quantized signal q. It includes a pipelined buffer, scaler, and temporary registers. The logic in the always block computes the outputs based on the input control signal, updating the temporary register and assigning the quantized output signal q based on specific bit values from the input signal.\n\n Module header:\n\nmodule ham_15_11_decoder (c,q);\n [/INST]\n", "output": "output [10:0] q; \n  reg [10:0] q; \n  input [14:0] c; \n  reg [3:0] pb; \n  reg [3:0] s; \n  reg [3:0] temp; \n  reg [14:0] inputs; \n  always @(c or q) \n  begin \n  pb[0]=c[2]^c[4]^c[6]^c[8]^c[10]^c[12]^c[14]; \n  pb[1]=c[2]^c[5]^c[6]^c[9]^c[10]^c[13]^c[14]; \n  pb[2]=c[4]^c[5]^c[6]^c[11]^c[12]^c[13]^c[14]; \n  pb[3]=c[8]^c[9]^c[10]^c[11]^c[12]^c[13]^c[14]; \n  s[0] = c[0]^pb[0]; \n  s[1] = c[1]^pb[1]; \n  s[2] = c[3]^pb[2]; \n  s[3] = c[7]^pb[3]; \n  inputs=c; \n  temp=s[0]*1; \n  temp=temp+s[1]*2; \n  temp=temp+s[2]*4; \n  temp=temp+s[3]*8-1; \n  inputs[temp]=c[temp]^1; \n  q[0]=inputs[2]; \n  q[1]=inputs[4]; \n  q[2]=inputs[5]; \n  q[3]=inputs[6]; \n  q[4]=inputs[8]; \n  q[5]=inputs[9]; \n  q[6]=inputs[10]; \n  q[7]=inputs[11]; \n  q[8]=inputs[12]; \n  q[9]=inputs[13]; \n  q[10]=inputs[14]; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a testbench for an IC download module. It includes signals for clock, reset, replication flit, control signals for replication and memory flits, as well as the download state and instruction word. The testbench initializes the signals, toggles the clock, and assigns values to the signals based on specific conditions. It uses display and file display statements for logging information and stops the simulation at the end.\n\n Module header:\n\nmodule tb_ic_download();\n [/INST]\n", "output": "reg clk; \n reg rst; \n reg [15:0] rep_flit_ic; \n reg v_rep_flit_ic; \n reg [1:0] rep_ctrl_ic; \n reg [127:0] mem_flits_ic; \n reg v_mem_flits_ic; \n wire ic_download_state; \n wire inst_word_ic; \n wire v_inst_word; \n ic_download uut(.clk(clk),.rst(rst),.rep_flit_ic(rep_flit_ic),.v_rep_flit_ic(v_rep_flit_ic),.rep_ctrl_ic(rep_ctrl_ic),.mem_flits_ic(mem_flits_ic),.v_mem_flits_ic(v_mem_flits_ic),.ic_download_state(ic_download_state),.inst_word_ic(inst_word_ic),.v_inst_word(v_inst_word)); \n integer i,j; \n integer log_file; \n  initial begin \n  clk = 0; \n  rst = 0; \n  rep_flit_ic=16'h1234; \n  v_rep_flit_ic=1'b0; \n  rep_ctrl_ic=2'b00; \n  mem_flits_ic=128'h12345678123456781234567812345678; \n  v_mem_flits_ic=1'b0; \n  end \n  always #20 clk=~clk; \n  `define step #40; \n  initial begin \n  $display(\"(%t) Initializing...\", $time); \n  $fdisplay(log_file, \"(%t) Initializing...\", $time); \n  rst=1; \n  `step \n  rst=0; \n  mem_flits_ic=128'h12345678123456781234567812345678; \n  v_mem_flits_ic=1'b1; \n  `step \n  $display(\"(%t)inst word sent to inst cache is valid:%d inst:%h and ic_download_state is :%b\",$time,v_inst_word_ic,inst_word_ic,ic_download_state); \n  $fdisplay(logfile,\"(%t) inst word sent to inst cache is :%h and ic_download_state is :%b\",$time,v_inst_word_ic,inst_word_ic,ic_download_state); \n  `step \n  `step \n  rep_flit_ic=16'h1234; \n  v_rep_flit_ic=1'b1; \n  rep_ctrl_ic=2'b01; \n  `step \n  rep_flit_ic=16'h1234; \n  v_rep_flit_ic=1'b1; \n  rep_ctrl_ic=2'b10; \n  `step \n  rep_flit_ic=16'h1234; \n  v_rep_flit_ic=1'b1; \n  rep_ctrl_ic=2'b10; \n  `step \n  rep_flit_ic=16'h1234; \n  v_rep_flit_ic=1'b1; \n  rep_ctrl_ic=2'b10; \n  $display(\"(%t)just test ERROR:inst word sent to inst cache is valid:%d inst:%h and ic_download_state is :%b\",$time,v_inst_word_ic,inst_word_ic,ic_download_state); \n  $fdisplay(logfile,\"(%t)just test ERROR: inst word sent to inst cache is :%h and ic_download_state is :%b\",$time,v_inst_word_ic,inst_word_ic,ic_download_state); \n  `step \n  rep_flit_ic=16'h1234; \n  v_rep_flit_ic=1'b1; \n  rep_ctrl_ic=2'b10; \n  `step \n  rep_flit_ic=16'h1234; \n  v_rep_flit_ic=1'b1; \n  rep_ctrl_ic=2'b10; \n  `step \n  rep_flit_ic=16'h1234; \n  v_rep_flit_ic=1'b1; \n  rep_ctrl_ic=2'b10; \n  `step \n  rep_flit_ic=16'h1234; \n  v_rep_flit_ic=1'b1; \n  rep_ctrl_ic=2'b10; \n  `step \n  rep_flit_ic=16'h1234; \n  v_rep_flit_ic=1'b1; \n  rep_ctrl_ic=2'b11; \n  `step \n  $display(\"(%t)inst word sent to inst cache is valid:%d inst:%h and ic_download_state is :%b\",$time,v_inst_word_ic,inst_word_ic,ic_download_state); \n  $fdisplay(logfile,\"(%t) inst word sent to inst cache is :%h and ic_download_state is :%b\",$time,v_inst_word_ic,inst_word_ic,ic_download_state); \n  $stop; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a D flip-flop with asynchronous reset. The output Q is updated on the positive edge of the clock signal C unless the reset signal R is asserted, in which case Q is set to 0. The input D determines the value of Q when the clock signal arrives. The module also contains timing specifications for different FPGA architectures, ensuring proper timing constraints are met.\n\n Module header:\n\nmodule SB_DFFR (output reg Q,input C, R, D);\n [/INST]\n", "output": "`SB_DFF_INIT \n  always @(posedge C, posedge R) \n  if (R) \n  Q <= 0; \n  else \n  Q <= D; \n `ifdef ICE40_HX \n  specify \n  $setup(D, posedge C, 470 - 449); \n  $setup(negedge R, posedge C, 160); \n `ifndef YOSYS \n  (posedge R => (Q : 1'b0)) = 599; \n `else \n  if (R) (R => Q) = 599; \n `endif \n  if (!R) (posedge C => (Q : D)) = 540; \n  endspecify \n `endif \n `ifdef ICE40_LP \n  specify \n  $setup(D, posedge C, 693 - 662); \n  $setup(negedge R, posedge C, 235); \n `ifndef YOSYS \n  (posedge R => (Q : 1'b0)) = 883; \n `else \n  if (R) (R => Q) = 883; \n `endif \n  if (!R) (posedge C => (Q : D)) = 796; \n  endspecify \n `endif \n `ifdef ICE40_U \n  specify \n  $setup(D, posedge C, 0); \n  $setup(negedge R, posedge C, 424); \n `ifndef YOSYS \n  (posedge R => (Q : 1'b0)) = 1589; \n `else \n  if (R) (R => Q) = 1589; \n `endif \n  if (!R) (posedge C => (Q : D)) = 1391; \n  endspecify \n `endif \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module contains combinational logic that takes inputs clock, ninth, and tenth, and produces output out4. It uses a D flip-flop called myc_d to process the inputs and generate a temporary signal temp5. The output out4 is then computed using XOR logic with the input tenth and the temporary signal temp4. The temporary signal temp4 is calculated as the difference between ninth and temp5.\n\n Module header:\n\nmodule c(clock,ninth,tenth,out4);\n [/INST]\n", "output": "input clock; \n input ninth; \n input tenth; \n output out4; \n wire out4; \n wire temp4; \n wire temp5; \n d myc_d(clock, ninth, tenth, temp5); \n assign out4 = temp4 ^ tenth; \n assign temp4 = ninth - temp5; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a complex data flip-flop. It takes in the inputs cpx_spc_data_cx_l, cpx_spc_data_rdy_cx, rclk, si, and se, and outputs cpx_spc_data_cx2 and cpx_spc_data_rdy_cx2. The module uses two D flip-flops to synchronize the input data and data-ready signals to the clock signal rclk. The synchronized data is then inverted and output as cpx_spc_data_cx2. The synchronized data-ready signal is output as cpx_spc_data_rdy_cx2.\n\n Module header:\n\nmodule cpx_datacx2_ff(cpx_spc_data_cx2, cpx_spc_data_rdy_cx2, so,cpx_spc_data_cx_l, cpx_spc_data_rdy_cx, rclk, si, se);\n [/INST]\n", "output": "output [`CPX_WIDTH-1:0] cpx_spc_data_cx2; \n  output cpx_spc_data_rdy_cx2; \n  output so; \n  input [`CPX_WIDTH-1:0] cpx_spc_data_cx_l; \n  input cpx_spc_data_rdy_cx; \n  input rclk; \n  input si; \n  input se; \n  wire [`CPX_WIDTH-1:0] cpx_spc_data_cx2_l; \n dff_s #(`CPX_WIDTH) dff_ccx_data_spc(.din (cpx_spc_data_cx_l[`CPX_WIDTH-1:0]),.q (cpx_spc_data_cx2_l[`CPX_WIDTH-1:0]),.clk (rclk),.se (1'b0),.si (`CPX_WIDTH'd0),.so ()); \n assign cpx_spc_data_cx2 = ~cpx_spc_data_cx2_l; \n dff_s #(1) dff_ccx_datardy_spc(.din (cpx_spc_data_rdy_cx),.q (cpx_spc_data_rdy_cx2),.clk (rclk),.se (1'b0),.si (1'd0),.so ()); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a data transfer between two FIFOs. The input FIFO has a width of 19 bits and the output FIFO has a width of 36 bits. The module uses a state machine to manage the data transfer between the two FIFOs, updating start-of-frame (SOF), end-of-frame (EOF), and occupation indicators based on the input FIFO signals. The module also includes a parameter for selecting the data order based on the Little Endian (LE) setting. The debug output is set to the current state of the state machine.\n\n Module header:\n\nmodule fifo19_to_fifo36 #(parameter LE=0) (input clk, input reset, input clear,input [18:0] f19_datain,input f19_src_rdy_i,output f19_dst_rdy_o,output [35:0] f36_dataout,output f36_src_rdy_o,input f36_dst_rdy_i,output [31:0] debug);\n [/INST]\n", "output": "wire [18:0] f19_data_int; \n  wire f19_src_rdy_int, f19_dst_rdy_int; \n  fifo_short #(.WIDTH(19)) head_fifo \n (.clk(clk),.reset(reset),.clear(clear),.datain(f19_datain), .src_rdy_i(f19_src_rdy_i), .dst_rdy_o(f19_dst_rdy_o),.dataout(f19_data_int), .src_rdy_o(f19_src_rdy_int), .dst_rdy_i(f19_dst_rdy_int),.space(),.occupied() ); \n  reg f36_sof_int, f36_eof_int; \n  reg [1:0] f36_occ_int; \n  wire [35:0] f36_data_int; \n  wire f36_src_rdy_int, f36_dst_rdy_int; \n  reg [1:0] state; \n  reg [15:0] dat0, dat1; \n  wire f19_sof_int = f19_data_int[16]; \n  wire f19_eof_int = f19_data_int[17]; \n  wire f19_occ_int = f19_data_int[18]; \n  wire xfer_out = f36_src_rdy_int & f36_dst_rdy_int; \n  always @(posedge clk) \n  if(f19_src_rdy_int & ((state==0)|xfer_out)) \n  f36_sof_int <= f19_sof_int; \n  always @(posedge clk) \n  if(f19_src_rdy_int & ((state != 2)|xfer_out)) \n  f36_eof_int <= f19_eof_int; \n  always @(posedge clk) \n  if(reset) \n  begin \n  state <= 0; \n  f36_occ_int <= 0; \n  end \n  else \n  if(f19_src_rdy_int) \n  case(state) \n  0 : \n  begin \n  dat0 <= f19_data_int; \n  if(f19_eof_int) \n  begin \n  state <= 2; \n  f36_occ_int <= f19_occ_int ? 2'b01 : 2'b10; \n  end \n  else \n  state <= 1; \n  end \n  1 : \n  begin \n  dat1 <= f19_data_int; \n  state <= 2; \n  if(f19_eof_int) \n  f36_occ_int <= f19_occ_int ? 2'b11 : 2'b00; \n  end \n  2 : \n  if(xfer_out) \n  begin \n  dat0 <= f19_data_int; \n  if(f19_eof_int) \n  f36_occ_int <= f19_occ_int ? 2'b01 : 2'b10; \n  else \n  state <= 1; \n  end \n  endcase \n  else \n  if(xfer_out) \n  begin \n  state <= 0; \n  f36_occ_int <= 0; \n  end \n  assign f19_dst_rdy_int = xfer_out | (state != 2); \n  assign f36_data_int = LE ? {f36_occ_int,f36_eof_int,f36_sof_int,dat1,dat0} : \n  {f36_occ_int,f36_eof_int,f36_sof_int,dat0,dat1}; \n  assign f36_src_rdy_int = (state == 2); \n  assign debug = state; \n  fifo_short #(.WIDTH(36)) tail_fifo \n (.clk(clk),.reset(reset),.clear(clear),.datain(f36_data_int), .src_rdy_i(f36_src_rdy_int), .dst_rdy_o(f36_dst_rdy_int),.dataout(f36_dataout), .src_rdy_o(f36_src_rdy_o), .dst_rdy_i(f36_dst_rdy_i),.space(),.occupied() ); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module \"cell1\" has one output \"Result0\" which is initialized to 1.\n\n Module header:\n\nmodule cell1(Result0);\n [/INST]\n", "output": "output Result0; \n assign Result0 = 1; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a system monitor for a SysMon device. It takes in various inputs such as addresses, clock signals, data, and control signals, and produces outputs including busy signals, channel information, data, and status information. The module instantiates a SysMon device and connects its inputs and outputs to the corresponding signals in the module's interface. The SysMon device is responsible for monitoring and controlling the system based on the provided inputs.\n\n Module header:\n\nmodule SysMon_exdes(DADDR_IN,DCLK_IN,DEN_IN,DI_IN,DWE_IN,BUSY_OUT,CHANNEL_OUT,DO_OUT,DRDY_OUT,EOC_OUT,EOS_OUT,JTAGBUSY_OUT,JTAGLOCKED_OUT,JTAGMODIFIED_OUT,VP_IN,VN_IN);\n [/INST]\n", "output": "input VP_IN; \n  input VN_IN; \n  input [6:0] DADDR_IN; \n  input DCLK_IN; \n  input DEN_IN; \n  input [15:0] DI_IN; \n  input DWE_IN; \n  output BUSY_OUT; \n  output [4:0] CHANNEL_OUT; \n  output [15:0] DO_OUT; \n  output DRDY_OUT; \n  output EOC_OUT; \n  output EOS_OUT; \n  output JTAGBUSY_OUT; \n  output JTAGLOCKED_OUT; \n  output JTAGMODIFIED_OUT; \n  wire GND_BIT; \n  wire [2:0] GND_BUS3; \n  wire FLOAT_VCCAUX; \n  wire FLOAT_VCCINT; \n  wire FLOAT_USER_TEMP_ALARM; \n  assign GND_BIT = 0; \n SysMon \n sysmon_wiz_inst (.DADDR_IN(DADDR_IN[6:0]),.DCLK_IN(DCLK_IN),.DEN_IN(DEN_IN),.DI_IN(DI_IN[15:0]),.DWE_IN(DWE_IN),.BUSY_OUT(BUSY_OUT),.CHANNEL_OUT(CHANNEL_OUT[4:0]),.DO_OUT(DO_OUT[15:0]),.DRDY_OUT(DRDY_OUT),.EOC_OUT(EOC_OUT),.EOS_OUT(EOS_OUT),.JTAGBUSY_OUT(JTAGBUSY_OUT),.JTAGLOCKED_OUT(JTAGLOCKED_OUT),.JTAGMODIFIED_OUT(JTAGMODIFIED_OUT),.VP_IN(VP_IN),.VN_IN(VN_IN)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a XOR gate using an intermediate wire, temp, which stores the result of the AND operation between the input c_in and d_in. The output, out1, is then computed as the XOR operation between temp and d_in.\n\n Module header:\n\nmodule c(c_in,d_in,out1);\n [/INST]\n", "output": "input c_in; \n input d_in; \n output out1; \n wire out1; \n wire temp; \n assign out1 = temp ^ d_in; \n assign temp = c_in & d_in; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a game controller with a 16-bit mole game. It uses a random number generator to set the mole's initial position. The game controller is driven by two clocks, clk_fast and clk_slow, and has reset functionality. The module transitions between different states, including IDLE, ON, and OFF, based on the input signals and clock cycles. The mole's position is updated based on the game state and user input. The module also detects if the game is finished and handles the game logic accordingly.\n\n Module header:\n\nmodule GameCtr(output reg [3:0] ten,output reg [3:0] one,output reg [15:0] mole16bit,input [3:0] keyIn,input isPressed,input isFinished,input clk_slow,input clk_fast,input rst_n);\n [/INST]\n", "output": "parameter IDLE = 2'b00; \n  parameter ON = 2'b01; \n  parameter OFF = 2'b10; \n  reg [3:0] next_ten, next_one; \n  wire [3:0]random_value; \n  reg [1:0] nST, ST; \n  LFSR rdgen(random_value, clk_slow, rst_n); \n  reg [15:0] next_mole; \n  always@ (posedge clk_fast or negedge rst_n) begin \n  if (!rst_n) begin \n  mole16bit <= 16'd0; \n  ten <= 4'b0; \n  one <= 4'b0; \n  end else if (!isFinished) begin \n  mole16bit <= next_mole; \n  ten <= next_ten; \n  one <= next_one; \n  end else begin \n  mole16bit <= mole16bit; \n  ten <= ten; \n  one <= one; \n  end \n  end \n  always @(posedge clk_slow or negedge rst_n) begin \n  if (!rst_n) begin \n  next_ten <= 0; \n  next_one <= 0; \n  end else if (isFinished) begin \n  next_ten <= ten; \n  next_one <= one; \n  end else if (ST == ON) begin \n  if (one == 4'd9) begin \n  next_ten <= ten + 4'd1; \n  next_one <= 4'd0; \n  end else begin \n  next_ten <= ten; \n  next_one <= one + 4'd1; \n  end \n  end else if (ST == OFF) begin \n  if (one >= 4'd8) begin \n  next_ten <= ten + 4'd1; \n  next_one <= 4'd0; \n  end else begin \n  next_ten <= ten; \n  next_one <= one + 4'd2; \n  end \n  end else begin \n  next_ten <= ten; \n  next_one <= one; \n  end \n  end \n  always @(posedge clk_fast) begin \n  if (isFinished) begin \n  next_mole <= mole16bit; \n  end else if (ST == ON || ST == OFF) begin \n  next_mole <= mole16bit; \n  next_mole[keyIn] <= 1'b0; \n  end else begin \n  next_mole <= (16'b1 << random_value); \n  end \n  end \n  always @(*) begin \n  case (ST) \n  IDLE: begin \n  if ((keyIn & 1 == 1'b1) && (mole16bit[keyIn] == 1'b1)) begin \n  nST = ON; \n  end else if (mole16bit[keyIn] == 1'b1) begin; \n  nST = OFF; \n  end else begin \n  nST = IDLE; \n  end \n  end \n  ON: begin \n  if (clk_slow) begin \n  nST = IDLE; \n  end else begin \n  nST = ON; \n  end \n  end \n  OFF: begin \n  if (clk_slow) begin \n  nST = IDLE; \n  end else begin \n  nST = OFF; \n  end \n  end \n  default: begin \n  nST = IDLE; \n  end \n  endcase \n  end \n  always @(posedge clk_fast) begin \n  ST <= nST; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is designed to implement an incremental delay generator. It uses the input signals to control the increment of the actual delay value and compares it with a specified delay value. The module contains logic to enable or disable the incrementing process based on specific conditions and is synchronized to the positive edge of the clk40 signal. The actual delay is incremented when the increment enable signal is asserted, and the count trigger input is used to activate the increment enable. Upon reaching the specified delay, the module disables the incrementor. The reset signal is used to reset the increment enable and actual delay to zero.\n\n Module header:\n\nmodule iodelay_incrementor(input clk40,input rst,input count_trig,input [5:0] spec_delay,output reg inc_en,output reg [5:0] actual_delay);\n [/INST]\n", "output": "always @(posedge clk40) begin \n  if (rst) begin \n  inc_en <= 0; \n  actual_delay <= 0; \n  end else begin \n  if (inc_en) begin \n  if (actual_delay == spec_delay) begin \n  inc_en <= 0; \n  end else begin \n  actual_delay <= actual_delay + 1; \n  end \n  end else begin \n  if (count_trig) begin \n  inc_en <= 1; \n  end \n  end \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a dual-port RAM with two sets of read and write ports. It consists of memory elements and logic to handle data reads and writes based on clock signals and control enable inputs. The module allows for simultaneous reading and writing operations on separate addresses within the memory array. The RAM operates with 256 memory locations, each storing 16-bit data. The module provides outputs for the data read from each port, which are determined based on the input addresses and control signals. The RAM also handles write operations by updating the memory values based on the write enable signals and input data. The module ensures that memory access and data integrity are maintained for each port through separate clocked processes.\n\n Module header:\n\nmodule ram_dp (ram_douta,ram_doutb,ram_addra,ram_cena,ram_clka,ram_dina,ram_wena,ram_addrb,ram_cenb,ram_clkb,ram_dinb,ram_wenb);\n [/INST]\n", "output": "parameter ADDR_MSB = 6; \n parameter MEM_SIZE = 256; \n output [15:0] ram_douta; \n output [15:0] ram_doutb; \n input [ADDR_MSB:0] ram_addra; \n input ram_cena; \n input ram_clka; \n input [15:0] ram_dina; \n input [1:0] ram_wena; \n input [ADDR_MSB:0] ram_addrb; \n input ram_cenb; \n input ram_clkb; \n input [15:0] ram_dinb; \n input [1:0] ram_wenb; \n reg [15:0] mem [0:(MEM_SIZE/2)-1]; \n reg [ADDR_MSB:0] ram_addra_reg; \n reg [ADDR_MSB:0] ram_addrb_reg; \n wire [15:0] mem_vala = mem[ram_addra]; \n wire [15:0] mem_valb = mem[ram_addrb]; \n always @(posedge ram_clka) \n  if (~ram_cena && (ram_addra<(MEM_SIZE/2))) \n  begin \n  if (ram_wena==2'b00) mem[ram_addra] <= ram_dina; \n  else if (ram_wena==2'b01) mem[ram_addra] <= {ram_dina[15:8], mem_vala[7:0]}; \n  else if (ram_wena==2'b10) mem[ram_addra] <= {mem_vala[15:8], ram_dina[7:0]}; \n  ram_addra_reg <= ram_addra; \n  end \n assign ram_douta = mem[ram_addra_reg]; \n always @(posedge ram_clkb) \n  if (~ram_cenb && (ram_addrb<(MEM_SIZE/2))) \n  begin \n  if (ram_wenb==2'b00) mem[ram_addrb] <= ram_dinb; \n  else if (ram_wenb==2'b01) mem[ram_addrb] <= {ram_dinb[15:8], mem_valb[7:0]}; \n  else if (ram_wenb==2'b10) mem[ram_addrb] <= {mem_valb[15:8], ram_dinb[7:0]}; \n  ram_addrb_reg <= ram_addrb; \n  end \n assign ram_doutb = mem[ram_addrb_reg]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `f14_TECH_XOR2` has two 2-bit inputs and a single output. It implements an XOR gate, where the output is the result of XOR operation between the two input bits.\n\n Module header:\n\nmodule f14_TECH_XOR2(input [1:0] in, output out);\n [/INST]\n", "output": "assign out = in[0] ^ in[1]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module simply sets the output signal G to a logical low (0) without any further logic or conditions.\n\n Module header:\n\nmodule GND(output G);\n [/INST]\n", "output": "assign G = 0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a Serial Peripheral Interface (SPI) sender. It has a state machine with three states: idle, sync, and enabled. When enabled is asserted, it shifts out a 48-bit data word on the falling edge of the sclk. The module also includes a reset input for initialization and a done output to signal completion.\n\n Module header:\n\nmodule spi_sender (input clk,input sclk_posedge,input sclk_negedge,input reset,input en,input [DATA_BITS-1:0] data,output reg out,output done);\n [/INST]\n", "output": "parameter DATA_BITS = 48; \n  reg [2:0] bit_counter = 7; \n  always @ (posedge clk) begin \n  if (sclk_negedge) begin \n  bit_counter <= bit_counter - 1; \n  end \n  end \n  localparam STATE_IDLE = 0; \n  localparam STATE_SYNC = 1; \n  localparam STATE_ENABLED = 2; \n  reg [1:0] state = STATE_IDLE; \n  reg [$clog2(DATA_BITS)-1:0] out_index = DATA_BITS - 1; \n  reg [DATA_BITS-1:0] saved_data = 0; \n  assign done = (STATE_IDLE == state) && !en; \n  always @ (posedge clk) begin \n  if (reset) begin \n  state <= STATE_IDLE; \n  out = 1; \n  end else begin \n  case (state) \n  STATE_IDLE: begin \n  out = 1; \n  if (en) begin \n  state <= STATE_SYNC; \n  out_index <= DATA_BITS - 1; \n  saved_data <= data; \n  end \n  end \n  STATE_SYNC: begin \n  out = 1; \n  if (7 == bit_counter) begin \n  state <= STATE_ENABLED; \n  end \n  end \n  STATE_ENABLED: begin \n  out = saved_data[out_index]; \n  if (out_index == 0) begin \n  state <= STATE_IDLE; \n  end else if (sclk_negedge) begin \n  out_index <= out_index - 1'b1; \n  end \n  end \n  endcase \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module `dqrx` is designed to handle input DQS and input DQ signals and split the DQ signal into four separate output signals q0, q1, q2, and q3. It uses a register array `q[3:0]` to store the outputs q0 to q3. The module also includes a register `ptr` to track the position in the register array where the DQ signal will be stored. When there is a change in the DQS signal, the module will capture the DQ signal and store it in the appropriate output signal while incrementing the pointer.\n\n Module header:\n\nmodule dqrx (dqs, dq, q0, q1, q2, q3);\n [/INST]\n", "output": "input dqs; \n  input [DQ_BITS/DQS_BITS-1:0] dq; \n  output [DQ_BITS/DQS_BITS-1:0] q0; \n  output [DQ_BITS/DQS_BITS-1:0] q1; \n  output [DQ_BITS/DQS_BITS-1:0] q2; \n  output [DQ_BITS/DQS_BITS-1:0] q3; \n  reg [DQ_BITS/DQS_BITS-1:0] q [3:0]; \n  assign q0 = q[0]; \n  assign q1 = q[1]; \n  assign q2 = q[2]; \n  assign q3 = q[3]; \n  reg [1:0] ptr; \n  reg dqs_q; \n  always @(dqs) begin \n  if (dqs ^ dqs_q) begin \n  #(TDQSQ + 1); \n  q[ptr] <= dq; \n  ptr <= (ptr + 1)%4; \n  end \n  dqs_q <= dqs; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module implements a 4-to-1 multiplexer, where the output Y is based on the select inputs S1 and S0. Depending on the combination of S1 and S0, the output Y will be connected to one of the four data inputs D0, D1, D2, or D3.\n\n Module header:\n\nmodule CC_MX4 (input D0, D1, D2, D3,input S0, S1,output Y);\n [/INST]\n", "output": "assign Y = S1 ? (S0 ? D3 : D2) : \n  (S0 ? D1 : D0); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `neo_d0` defines input and output ports for various signals. The module includes an initial block to toggle the `CLK_24M` signal every 20.8 time units. It also declares register variables `REG_BNK` and `REG_OUT`, along with clocks and a Z80 controller. The module assigns values to the output ports based on certain conditions and triggers updates based on negedge of `nBITWD0`. The module essentially controls various clocks and signals based on the input conditions and triggers updates to the output based on specific events.\n\n Module header:\n\nmodule neo_d0(output reg CLK_24M,input nRESET, nRESETP,output CLK_12M,output CLK_68KCLK,output CLK_68KCLKB,output CLK_6MB,output CLK_1MB,input M68K_ADDR_A4,input nBITWD0,input [5:0] M68K_DATA,input [15:11] SDA_H,input [4:2] SDA_L,input nSDRD, nSDWR, nMREQ, nIORQ,output nZ80NMI,input nSDW,output nSDZ80R, nSDZ80W, nSDZ80CLR,output nSDROM, nSDMRD, nSDMWR,output SDRD0, SDRD1,output n2610CS, n2610RD, n2610WR,output nZRAMCS,output [2:0] BNK,output [2:0] P1_OUT,output [2:0] P2_OUT);\n [/INST]\n", "output": "initial \n  CLK_24M = 0; \n  always \n  #20.8 CLK_24M = !CLK_24M; \n  reg [2:0] REG_BNK; \n  reg [5:0] REG_OUT; \n  clocks CLK(CLK_24M, nRESETP, CLK_12M, CLK_68KCLK, CLK_68KCLKB, CLK_6MB, CLK_1MB); \n z80ctrl Z80CTRL(SDA_L, SDA_H, nSDRD, nSDWR, nMREQ, nIORQ, nSDW, nRESET, nZ80NMI, nSDZ80R, nSDZ80W,nSDZ80CLR, nSDROM, nSDMRD, nSDMWR, SDRD0, SDRD1, n2610CS, n2610RD, n2610WR, nZRAMCS); \n  assign {P2_OUT, P1_OUT} = nRESETP ? REG_OUT : 6'b000000; \n  assign BNK = nRESETP ? REG_BNK : 3'b000; \n  always @(negedge nBITWD0) \n  begin \n  if (M68K_ADDR_A4) \n  REG_BNK <= M68K_DATA[2:0]; \n  else \n  REG_OUT <= M68K_DATA[5:0]; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a simple state machine with clock and reset inputs. The output al is updated based on the cmd_stop signal, which is controlled by the clock, reset, and nReset inputs. When nReset is low or the rst signal is high, al and cmd_stop are set to 0. Otherwise, al is updated based on the negation of cmd_stop.\n\n Module header:\n\nmodule i2c_test01(clk, rst, nReset, al);\n [/INST]\n", "output": "input clk, rst, nReset; \n  output reg al; \n  reg cmd_stop; \n  always @(posedge clk or negedge nReset) \n  if (~nReset) \n  cmd_stop <= #1 1'b0; \n  else if (rst) \n  cmd_stop <= #1 1'b0; \n  always @(posedge clk or negedge nReset) \n  if (~nReset) \n  al <= #1 1'b0; \n  else if (rst) \n  al <= #1 1'b0; \n  else \n  al <= #1 ~cmd_stop; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module _MUX_ implements a 2-to-1 multiplexer with inputs A and B, select signal S, and output Y. When the select signal S is high, the output Y is assigned the value of B; otherwise, it is assigned the value of A.\n\n Module header:\n\nmodule _MUX_(A, B, S, Y);\n [/INST]\n", "output": "input A, B, S; \n output reg Y; \n always @* begin \n  if (S) \n  Y = B; \n  else \n  Y = A; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module is a behavioral description of a combinational logic circuit with inputs cx0 and cx1 and outputs bm0 through bm7. The outputs are assigned based on logic operations like AND, NOR, and inverters on the inputs and intermediate signals n1 and n2. The module uses basic logic gates like AND2X1, NOR2X1, OAI21X1, NAND2X1, and inverters to determine the outputs based on the input conditions.\n\n Module header:\n\nmodule bmu ( cx0, cx1, bm0, bm1, bm2, bm3, bm4, bm5, bm6, bm7 );\n [/INST]\n", "output": "output [1:0] bm0; \n  output [1:0] bm1; \n  output [1:0] bm2; \n  output [1:0] bm3; \n  output [1:0] bm4; \n  output [1:0] bm5; \n  output [1:0] bm6; \n  output [1:0] bm7; \n  input cx0, cx1; \n  wire bm2_1_, bm6_1_, n1, n2; \n  assign bm1[1] = bm2_1_; \n  assign bm2[1] = bm2_1_; \n  assign bm0[1] = bm3[1]; \n  assign bm0[0] = bm3[0]; \n  assign bm1[0] = bm3[0]; \n  assign bm2[0] = bm3[0]; \n  assign bm5[1] = bm6_1_; \n  assign bm6[1] = bm6_1_; \n  assign bm4[1] = bm7[1]; \n  assign bm4[0] = bm7[0]; \n  assign bm5[0] = bm7[0]; \n  assign bm6[0] = bm7[0]; \n  AND2X1 U31 ( .A(n1), .B(cx1), .Y(bm7[1]) ); \n  NOR2X1 U32 ( .A(cx1), .B(n1), .Y(bm6_1_) ); \n  INVX1 U33 ( .A(cx0), .Y(n1) ); \n  NOR2X1 U34 ( .A(bm3[1]), .B(bm3[0]), .Y(bm2_1_) ); \n  INVX1 U35 ( .A(bm7[0]), .Y(bm3[0]) ); \n  OAI21X1 U36 ( .A(cx1), .B(cx0), .C(n2), .Y(bm7[0]) ); \n  INVX1 U37 ( .A(n2), .Y(bm3[1]) ); \n  NAND2X1 U38 ( .A(cx0), .B(cx1), .Y(n2) ); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, \"pgpio,\" interfaces a set of input and output GPIO signals with a PS (processor system). It includes parameters for the number of GPIO signals, PS signals, and a differential mode option. Depending on the differential mode setting, it either instantiates IOBUFDS modules for LVDS signaling or IOBUF modules for LVCMOS25 signaling. The module also includes drive strength and slew rate settings for the IOBUF and IOBUFDS instances. Additionally, it generates logic to assign PS signals to GPIO signals and vice versa. Finally, it includes a loop to assign default values to any unconnected PS signals.\n\n Module header:\n\nmodule pgpio(ps_gpio_i,gpio_p, gpio_n,ps_gpio_o, ps_gpio_t);\n [/INST]\n", "output": "parameter NGPIO = 24; \n  parameter NPS = 64; \n  parameter DIFF = 0; \n  inout [NGPIO-1:0] gpio_p; \n  inout [NGPIO-1:0] gpio_n; \n  output [NPS-1:0] ps_gpio_i; \n  input [NPS-1:0] ps_gpio_o; \n  input [NPS-1:0] ps_gpio_t; \n  genvar m; \n  generate \n  if( DIFF == 1 ) begin: gpio_diff \n  IOBUFDS \n #(.DIFF_TERM(\"TRUE\"),.IBUF_LOW_PWR(\"TRUE\"),.IOSTANDARD(\"LVDS_25\"),.SLEW(\"FAST\")) \n  i_iodiff [NGPIO-1:0] \n (.O(ps_gpio_i),.IO(gpio_p),.IOB(gpio_n),.I(ps_gpio_o),.T(ps_gpio_t)); \n  end else begin: gpio_cmos \n  wire [NGPIO-1:0] gpio_i_n, gpio_i_p; \n  wire [NGPIO-1:0] gpio_o_n, gpio_o_p; \n  wire [NGPIO-1:0] gpio_t_n, gpio_t_p; \n  for(m=0; m<NGPIO; m=m+2) begin : assign_se_sigs \n  assign ps_gpio_i[2*m] = gpio_i_n[m]; \n  assign ps_gpio_i[2*m+1] = gpio_i_n[m+1]; \n  assign ps_gpio_i[2*m+2] = gpio_i_p[m]; \n  assign ps_gpio_i[2*m+3] = gpio_i_p[m+1]; \n  assign gpio_o_n[m] = ps_gpio_o[2*m]; \n  assign gpio_o_n[m+1] = ps_gpio_o[2*m+1]; \n  assign gpio_o_p[m] = ps_gpio_o[2*m+2]; \n  assign gpio_o_p[m+1] = ps_gpio_o[2*m+3]; \n  assign gpio_t_n[m] = ps_gpio_t[2*m]; \n  assign gpio_t_n[m+1] = ps_gpio_t[2*m+1]; \n  assign gpio_t_p[m] = ps_gpio_t[2*m+2]; \n  assign gpio_t_p[m+1] = ps_gpio_t[2*m+3]; \n  end \n  IOBUF \n #(.DRIVE(8),.IBUF_LOW_PWR(\"TRUE\"),.IOSTANDARD(\"LVCMOS25\"),.SLEW(\"SLOW\")) \n  i_iocmos_n [NGPIO-1:0] \n (.O(gpio_i_n),.IO(gpio_n),.I(gpio_o_n),.T(gpio_t_n)); \n  IOBUF \n #(.DRIVE(8),.IBUF_LOW_PWR(\"TRUE\"),.IOSTANDARD(\"LVCMOS25\"),.SLEW(\"SLOW\")) \n  i_iocmos_p [NGPIO-1:0] \n (.O(gpio_i_p),.IO(gpio_p),.I(gpio_o_p),.T(gpio_t_p)); \n  end \n  endgenerate \n  genvar i; \n  generate \n  for (i=NGPIO*2;i<NPS;i=i+1) \n  assign ps_gpio_i[i] = 1'b0; \n  endgenerate \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a register pipeline with configurable depth and width. It has input and output interfaces for data and control signals. The module stores incoming data in a pipeline of registers and outputs the data in a staged manner while maintaining data validity and readiness. The pipeline stages are interconnected to enable data flow through the pipeline. The module also includes logic to handle reset signals and timing considerations.\n\n Module header:\n\nmodule reg_pipeline #(parameter C_DEPTH = 10,parameter C_WIDTH = 10) (input CLK,input RST_IN,input [C_WIDTH-1:0] WR_DATA,input WR_DATA_VALID,output WR_DATA_READY,output [C_WIDTH-1:0] RD_DATA,output RD_DATA_VALID,input RD_DATA_READY);\n [/INST]\n", "output": "genvar i; \n  wire wReady [C_DEPTH:0]; \n  reg [C_WIDTH-1:0] _rData [C_DEPTH:1], rData [C_DEPTH:0]; \n  reg _rValid [C_DEPTH:1], rValid [C_DEPTH:0]; \n  assign wReady[C_DEPTH] = RD_DATA_READY; \n  assign RD_DATA = rData[C_DEPTH]; \n  assign RD_DATA_VALID = rValid[C_DEPTH]; \n  assign WR_DATA_READY = wReady[0]; \n  always @(*) begin \n  rData[0] = WR_DATA; \n  rValid[0] = WR_DATA_VALID; \n  end \n  generate \n  for( i = 1 ; i <= C_DEPTH; i = i + 1 ) begin : gen_stages \n  assign #1 wReady[i-1] = ~rValid[i] | wReady[i]; \n  always @(*) begin \n  _rData[i] = rData[i-1]; \n  end \n  always @(posedge CLK) begin \n  if(wReady[i-1]) begin \n  rData[i] <= #1 _rData[i]; \n  end \n  end \n  always @(*) begin \n  if(RST_IN) begin \n  _rValid[i] = 1'b0; \n  end else begin \n  _rValid[i] = rValid[i-1] | (rValid[i] & ~wReady[i]); \n  end \n  end \n  always @(posedge CLK) begin \n  rValid[i] <= #1 _rValid[i]; \n  end \n  end \n  endgenerate \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes an input vector of width M and unpacks it into an output vector of width N, where N is a parameterized value, and also generates a length vector of width $clog2(MB). The input vector is divided into segments of 8 bits each, and then the module performs a series of bitwise operations to unpack and process the input to produce the output and length vectors. The unpacking is done using logic based on the input and intermediate signals gl, ub, ho, and sb. The output vector is populated based on the processing of these signals, and certain elements of the output vector are set to a predefined value based on the values of the intermediate signals. If any element of the sb signal is set, the output vector is processed further to set certain elements to a predefined value. Finally, the output vector is set to the unsigned_output vector if certain conditions are met.\n\n Module header:\n\nmodule unpack_signed #(parameter N = 64) (input [ 0:M-1] in,output reg [ N-1: 0] out,output wire [$clog2(MB)-1: 0] len);\n [/INST]\n", "output": "localparam MB = N/7+1; \n  localparam M = MB*8; \n  wire[N-1:0] unsigned_output; \n  integer i; \n  reg [MB-1:0] gl, ub, ho, sb; \n  unpack_unsigned #(.N(N)) u64(in, unsigned_output, len); \n  always @* begin \n  for(i=0; i<=MB-1; i=i+1) begin \n  gl [i ] = in[i*8 ]; \n  out[i*7 +: 7] = in[i*8+1 +: 7]; \n  end \n  ub[0] = 1; \n  for(i=1; i<=MB-1; i=i+1) \n  ub[i] = gl[i-1] & ub[i-1]; \n  for(i=0; i<=MB-2; i=i+1) \n  ho[i] = !ub[i+1] & ub[i]; \n  ho[MB-1] = ub[MB-1]; \n  for(i=0; i<=MB-1; i=i+1) \n  sb[i] = ho[i] & in[i*8+1]; \n  if(|sb) begin \n  for(i=0; i<=MB-1; i=i+1) \n  if(!ub[i]) \n  out[i*7 +: 7] = 7'b1111111; \n  end \n  else \n  out = unsigned_output; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a hex digit display encoder. It takes a 4-bit input and generates a 7-bit output to drive a 7-segment display. The encoding of the 4-bit input to the 7-bit output is based on the hexadecimal digit values. The module also includes an inversion option for the output.\n\n Module header:\n\nmodule hex_display #(parameter INVERT = 0) (input wire [3:0] in,input wire enable,output wire [6:0] out);\n [/INST]\n", "output": "reg [6:0] enc; \n always @* begin \n  enc <= 7'b0000000; \n  if (enable) begin \n  case (in) \n  4'h0: enc <= 7'b0111111; \n  4'h1: enc <= 7'b0000110; \n  4'h2: enc <= 7'b1011011; \n  4'h3: enc <= 7'b1001111; \n  4'h4: enc <= 7'b1100110; \n  4'h5: enc <= 7'b1101101; \n  4'h6: enc <= 7'b1111101; \n  4'h7: enc <= 7'b0000111; \n  4'h8: enc <= 7'b1111111; \n  4'h9: enc <= 7'b1101111; \n  4'ha: enc <= 7'b1110111; \n  4'hb: enc <= 7'b1111100; \n  4'hc: enc <= 7'b0111001; \n  4'hd: enc <= 7'b1011110; \n  4'he: enc <= 7'b1111001; \n  4'hf: enc <= 7'b1110001; \n  endcase \n  end \n end \n assign out = INVERT ? ~enc : enc; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module instantiates a register, \"reg_0x08,\" and assigns it a constant value of 8'h00.\n\n Module header:\n\nmodule r_USBPD_REV_VER_LOW(output wire [7:0] reg_0x08);\n [/INST]\n", "output": "assign reg_0x08=8'h00; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a set of registers with read and write functionality. The module has input ports for clock, reset, read and write addresses, write data, and load/store control signal. It also has output ports for the data read from two different addresses. The module contains a 32-bit array of registers. It initializes the registers to zero on reset and updates the register at the write address with the write data when the load/store control signal is asserted. The module also enables reading from the specified read addresses when requested.\n\n Module header:\n\nmodule Regs(input clk,input rst,input [4:0] R_addr_A,input [4:0] R_addr_B,input [4:0] Wt_addr,input [31:0]Wt_data,input L_S,output [31:0] rdata_A,output [31:0] rdata_B);\n [/INST]\n", "output": "reg [31:0] register [1:31]; \n integer i; \n  assign rdata_A = (R_addr_A == 0)? 0 : register[R_addr_A]; \n  assign rdata_B = (R_addr_B == 0)? 0 : register[R_addr_B]; \n  always @(posedge clk or posedge rst) \n  begin \n  if (rst==1) begin \n  for (i=1; i<32; i=i+1) \n  register[i] <= 0; \n  end \n  else begin \n  if ((Wt_addr != 0) && (L_S == 1)) \n  register[Wt_addr] <= Wt_data; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a Phase-Locked Loop (PLL) for clock generation and synchronization. It includes input and output clock signals, as well as a locked signal. The module uses various clock manipulation and synchronization components such as DCM_SP, BUFG, and IBUFG to achieve the desired clocking behavior. The DCM_SP configuration specifies clock feedback, division, multiplication, period, phase shift, and other parameters. The module effectively controls the phase and frequency of the output clock signals based on the input clock signal and feedback, ultimately producing synchronized and stable clock outputs.\n\n Module header:\n\nmodule pll(CLKIN_IN,CLKFX_OUT,CLKIN_IBUFG_OUT,CLK0_OUT,LOCKED_OUT);\n [/INST]\n", "output": "input CLKIN_IN; \n  output CLKFX_OUT; \n  output CLKIN_IBUFG_OUT; \n  output CLK0_OUT; \n  output LOCKED_OUT; \n  wire CLKFB_IN; \n  wire CLKFX_BUF; \n  wire CLKIN_IBUFG; \n  wire CLK0_BUF; \n  wire GND_BIT; \n  assign GND_BIT = 0; \n  assign CLKIN_IBUFG_OUT = CLKIN_IBUFG; \n  assign CLK0_OUT = CLKFB_IN; \n BUFG CLKFX_BUFG_INST (.I(CLKFX_BUF),.O(CLKFX_OUT)); \n IBUFG CLKIN_IBUFG_INST (.I(CLKIN_IN),.O(CLKIN_IBUFG)); \n BUFG CLK0_BUFG_INST (.I(CLK0_BUF),.O(CLKFB_IN)); \n DCM_SP #( .CLK_FEEDBACK(\"1X\"), .CLKDV_DIVIDE(2.0), .CLKFX_DIVIDE(6),.CLKFX_MULTIPLY(2), .CLKIN_DIVIDE_BY_2(\"FALSE\"),.CLKIN_PERIOD(20.000), .CLKOUT_PHASE_SHIFT(\"NONE\"),.DESKEW_ADJUST(\"SYSTEM_SYNCHRONOUS\"), .DFS_FREQUENCY_MODE(\"LOW\"),.DLL_FREQUENCY_MODE(\"LOW\"), .DUTY_CYCLE_CORRECTION(\"TRUE\"),.FACTORY_JF(16'hC080), .PHASE_SHIFT(0), .STARTUP_WAIT(\"FALSE\") ) \n DCM_SP_INST (.CLKFB(CLKFB_IN),.CLKIN(CLKIN_IBUFG),.DSSEN(GND_BIT),.PSCLK(GND_BIT),.PSEN(GND_BIT),.PSINCDEC(GND_BIT),.RST(GND_BIT),.CLKDV(),.CLKFX(CLKFX_BUF),.CLKFX180(),.CLK0(CLK0_BUF),.CLK2X(),.CLK2X180(),.CLK90(),.CLK180(),.CLK270(),.LOCKED(LOCKED_OUT),.PSDONE(),.STATUS()); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a single hot detect processing element (SHD_PE) that processes DNA data. It includes logic for updating DNA data and reference on positive clock edges, resetting DNA validity, and checking for DNA validity and pe_fifo_full. It also instantiates the SHD module, defines pe_fifo_full and pe_fifo_empty wires, and instantiates the shd_pe_fifo module for processing DNA errors. Finally, it assigns values to the dna_rd_en and coll_valid signals based on pe_fifo_full and pe_fifo_empty conditions.\n\n Module header:\n\nmodule SHD_PE #(parameter DNA_DATA_WIDTH = 128) (input clk,input rst,input[DNA_DATA_WIDTH - 1:0] dna_in,input[DNA_DATA_WIDTH - 1:0] dna_ref_in,input dna_valid_in,output dna_rd_en,input coll_clk,input coll_rd_en,output[7:0] coll_dna_err,output coll_valid);\n [/INST]\n", "output": "reg[DNA_DATA_WIDTH - 1:0] dna_r, dna_ref_r; \n  reg dna_valid_r; \n  always@(posedge clk) begin \n  if(rst) begin \n  dna_valid_r <= 1'b0; \n  dna_r <= 0; \n  dna_ref_r <= 0; \n  end \n  else begin \n  if(~dna_valid_r || ~pe_fifo_full) begin \n  dna_valid_r <= dna_valid_in; \n  dna_r <= dna_in; \n  dna_ref_r <= dna_ref_in; \n  end \n  end \n  end \n  wire[7:0] dna_err; \n SHD #(.LENGTH(DNA_DATA_WIDTH)) i_SHD(.DNA_read(dna_r),.DNA_ref(dna_ref_r),.DNA_MinErrors(dna_err)); \n  wire pe_fifo_full, pe_fifo_empty; \n shd_pe_fifo i_pe_fifo (.wr_clk(clk),.rd_clk(coll_clk),.rst(rst),.din(dna_err),.wr_en(~pe_fifo_full && dna_valid_r),.rd_en(coll_rd_en),.dout(coll_dna_err),.full(pe_fifo_full),.empty(pe_fifo_empty)); \n  assign dna_rd_en = ~pe_fifo_full; \n  assign coll_valid = ~pe_fifo_empty; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a double altpriority encoder for a 32-bit input data, resulting in a 5-bit output q. It instantiates two 4-bit altpriority encoders, one for the upper 16 bits and the other for the lower 16 bits of the input data. The final output q is computed using logical operators based on the outputs of the two encoders, ensuring that the highest priority non-zero value is encoded.\n\n Module header:\n\nmodule acl_fp_log_s5_double_altpriority_encoder_q08 (data,q) ;\n [/INST]\n", "output": "input [31:0] data; \n  output [4:0] q; \n  wire [3:0] wire_altpriority_encoder10_q; \n  wire wire_altpriority_encoder10_zero; \n  wire [3:0] wire_altpriority_encoder9_q; \n  acl_fp_log_s5_double_altpriority_encoder_rf8 altpriority_encoder10 \n (.data(data[31:16]),.q(wire_altpriority_encoder10_q),.zero(wire_altpriority_encoder10_zero)); \n  acl_fp_log_s5_double_altpriority_encoder_r08 altpriority_encoder9 \n (.data(data[15:0]),.q(wire_altpriority_encoder9_q)); \n  assign \n  q = {(~ wire_altpriority_encoder10_zero), (({4{wire_altpriority_encoder10_zero}} & wire_altpriority_encoder9_q) | ({4{(~ wire_altpriority_encoder10_zero)}} & wire_altpriority_encoder10_q))}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `control_unit` serves as a control unit for a processor. It takes a 6-bit input `op` and produces several control signals based on it. It sets various control signals such as `regdst`, `regwrite`, `branch`, `jump`, `memread`, `memtoreg`, `memwrite`, `aluop`, and `aluscr` based on the input `op`. It uses a combinational logic block to determine the values of these control signals. Each case in the logic block corresponds to a specific value of `op`, and sets the control signals accordingly. For instance, when `op` is `6'b10_0011`, it sets `memread` to 1, `regdst` to 00, `aluop` to 00, `aluscr` to 1, and `memtoreg` to 01. The module acts as a finite state machine with the input `op` determining the state transitions and the output being the control signals.\n\n Module header:\n\nmodule control_unit (input[5:0] op,output reg [1:0] regdst,output reg regwrite,output reg branch,output reg jump,output reg memread,output reg [1:0]memtoreg,output reg memwrite,output reg [1:0] aluop,output reg aluscr );\n [/INST]\n", "output": "always @(*) begin \n  branch <= 1'b0; \n  jump <= 1'b0; \n  memread <= 1'b0; \n  memtoreg[1:0] <= 2'b00; \n  memwrite <= 1'b0; \n  aluop[1:0] <= 2'b10; \n  aluscr <= 1'b0; \n  regdst[1:0] <= 2'b01; \n  regwrite <= 1'b1; \n  case(op) \n  6'b10_0011: begin \n  regdst[1:0] <= 2'b00; \n  memread <= 1'b1; \n  aluop[1:0] <= 2'b00; \n  aluscr <= 1'b1; \n  memtoreg[1:0] <= 2'b01; \n  end \n  6'b10_1011: begin \n  aluop[1] <= 1'b0; \n  aluscr <= 1'b1; \n  memwrite <= 1'b1; \n  regwrite <= 1'b0; \n  end \n  6'b00_0100: begin \n  branch <= 1'b1; \n  aluop[1:0] <= 2'b01; \n  regwrite <= 1'b0; \n  end \n  6'b00_1000: begin \n  regdst[1:0] <= 2'b00; \n  aluop[1] <= 1'b0; \n  aluscr <= 1'b1; \n  end \n  6'b00_0010: begin \n  jump <= 1'b1; \n  regwrite <= 1'b0; \n  end \n  6'b00_0011: begin \n  jump <= 1'b1; \n  regdst[1:0] <= 2'b10; \n  memtoreg[1:0] <= 2'b10; \n  end \n  6'b00_0000: begin \n  end \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes in 4 inputs (btn0, btn1, btn2, btn3) and a clock signal (clk), and outputs the values for four LEDs (led0, led1, led2, led3) and a 7-bit value (out). The LED values are determined based on the buttons pressed, and the 7-bit output value is determined by a lookup table based on the 4-bit input (in). The LED values are updated on the positive edge of the clock signal.\n\n Module header:\n\nmodule PruebaSeleccion(out, in, clk, btn0, btn1, btn2, btn3, led0, led1, led2, led3);\n [/INST]\n", "output": "output reg [6:0] out; \n  input wire [3:0] in; \n  input wire clk; \n  input wire btn0; \n  input wire btn1; \n  input wire btn2; \n  input wire btn3; \n  output reg led0; \n  output reg led1; \n  output reg led2; \n  output reg led3; \n  reg ledAux0; \n  reg ledAux1; \n  reg ledAux2; \n  reg ledAux3; \n always @(posedge clk) \n  begin \n  if(btn0 == 1) \n  begin \n  ledAux0 = 0; \n  ledAux1 = 1; \n  ledAux2 = 1; \n  ledAux3 = 1; \n  end \n  else if (btn1 == 1) \n  begin \n  ledAux0 = 1; \n  ledAux1 = 0; \n  ledAux2 = 1; \n  ledAux3 = 1; \n  end \n  else if (btn2 == 1) \n  begin \n  ledAux0 = 1; \n  ledAux1 = 1; \n  ledAux2 = 0; \n  ledAux3 = 1; \n  end \n  else if (btn3 == 1) \n  begin \n  ledAux0 = 1; \n  ledAux1 = 1; \n  ledAux2 = 1; \n  ledAux3 = 0; \n  end \n  led0 = ledAux0; \n  led1 = ledAux1; \n  led2 = ledAux2; \n  led3 = ledAux3; \n  case (in) \n  4'h0: out = 7'b1000000; \n  4'h1: out = 7'b1111001; \n  4'h2: out = 7'b0100100; \n  4'h3: out = 7'b0110000; \n  4'h4: out = 7'b0011001; \n  4'h5: out = 7'b0010010; \n  4'h6: out = 7'b0000010; \n  4'h7: out = 7'b1111000; \n  4'h8: out = 7'b0000000; \n  4'h9: out = 7'b0010000; \n  4'hA: out = 7'b0001000; \n  4'hB: out = 7'b0000011; \n  4'hC: out = 7'b1000110; \n  4'hD: out = 7'b0100001; \n  4'hE: out = 7'b0000110; \n  4'hF: out = 7'b0001110; \n  default: out = 7'b100000; \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a 58-bit adder. It takes in two 58-bit numbers x and y, a carry-in signal CarryIn, and a control signal notsub. It produces a 58-bit sum z and an equality output Eqv. The adder58 module is instantiated to perform the addition and the output zbuf is assigned the value of z.\n\n Module header:\n\nmodule ME_ADD_58 ( notsub, CarryIn, x, y, z, zbuf, Eqv );\n [/INST]\n", "output": "input notsub, CarryIn ; \n  input [57:0] x, y ; \n  output [57:0] zbuf, z ; \n  output Eqv ; \n  adder58 adr ( notsub, notsub, CarryIn, x, y, z, Eqv ) ; \n  assign zbuf = z; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes 5 inputs and concatenates them to form a 5-bit output. Each input bit is assigned to a specific position in the output, with i4 assigned to the leftmost bit and i0 assigned to the rightmost bit.\n\n Module header:\n\nmodule v36cddd_v9a2a06 (input i4,input i3,input i2,input i1,input i0,output [4:0] o);\n [/INST]\n", "output": "assign o = {i4, i3, i2, i1, i0}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an up counter with a specified counter size. It has inputs for clock and reset signals, and outputs an array of LEDs. The module utilizes a parameter to specify the counter size. Inside the module, it instantiates an UpCounter module, passing the clock and reset signals as inputs, and connecting the counter output to the LED outputs. The UpCounter module is defined with the specified counter size and generates the count sequence.\n\n Module header:\n\nmodule CountSupLimit(input wire [('b1) - ('b1):0] clock,input wire [('b1) - ('b1):0] reset,output wire [('b1000) - ('b1):0] leds);\n [/INST]\n", "output": "parameter hack_counter_Size = 'b11000; \n  wire [(hack_counter_Size) - ('b1):0] counter_data_o; \n  assign leds = counter_data_o['b10111:'b10000]; \n UpCounter #(.Size('b11000)) \n counter(.clock(clock),.reset(reset),.count('b1),.data_o(counter_data_o)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a clock divider that takes an input clock signal (refclkin) and generates an output clock signal (refclkout) based on the specified parameters. It includes a divide_by parameter to control the division factor and an enabled parameter to enable or disable the clock divider. The module has logic to handle different scenarios based on the parameters. When enabled is false and the divide_by is 1, the output clock is the same as the input clock. When divide_by is 2, the output clock is derived from the input clock using additional logic. The module also performs error checking for the enabled parameter and toggles the internal signal rxp_div2 based on the input clock.\n\n Module header:\n\nmodule cyclonev_hssi_refclk_divider #(parameter lpm_type = \"cyclonev_hssi_refclk_divider\",parameter divide_by = 1,parameter enabled = \"false\",parameter refclk_coupling_termination = \"normal_100_ohm_termination\") (input refclkin,output refclkout,input nonuserfrompmaux);\n [/INST]\n", "output": "reg rxp_div2; \n wire rxp_div2_180; \n assign refclkout = ( enabled == \"false\") && ( divide_by == 1 ) ? refclkin : \n  ( enabled == \"false\") && ( divide_by == 2 ) ? rxp_div2_180 : \n  1'bx; \n initial begin \n  rxp_div2 = 1'b1; \n  if (enabled != \"false\") \n  $display(\"[cyclonev_hssi_refclk_divider] - ERROR! - Parameter \\\"enabled\\\" does not support value $s\", enabled); \n end \n assign rxp_div2_180 = ~rxp_div2; \n always @(posedge refclkin) \n  rxp_div2 <= ~rxp_div2; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a positive edge-triggered D flip-flop. When the clock signal CLK has a positive edge, the input D is captured and stored in the output Q after a delay of 1 time unit.\n\n Module header:\n\nmodule ff (input CLK,input D,output reg Q);\n [/INST]\n", "output": "always @ (posedge CLK) begin \n  Q <= #1 D; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module serves as a master interface for two Wishbone master modules. It includes parameters for address width, base addresses, data count, and data width. The module receives clock and reset signals, as well as input and output data and control signals. It generates a done signal based on the individual done signals from the two Wishbone master modules. Each Wishbone master module instance operates with specific base addresses and data parameters, and interfaces with the common clock and reset signals, as well as the start signal. The module orchestrates the interactions between the Wishbone master modules and consolidates their individual done signals into a single done output.\n\n Module header:\n\nmodule master #(parameter ADDR_WIDTH = 16,parameter MASTER_1_BASE_ADDRESS = 64,parameter DATA_COUNT = 8,parameter DATA_WIDTH = 16,parameter MASTER_0_BASE_ADDRESS = 0,parameter AUB = 8,parameter VERILOG_SPECIFIC = 'hEE) (input ack_i_0,input [DATA_WIDTH-1:0] dat_i_0,input err_i_0,output [ADDR_WIDTH-1:0] adr_o_0,output cyc_o_0,output [DATA_WIDTH-1:0] dat_o_0,output stb_o_0,output we_o_0,input ack_i_1,input [DATA_WIDTH-1:0] dat_i_1,input err_i_1,output [ADDR_WIDTH-1:0] adr_o_1,output cyc_o_1,output [DATA_WIDTH-1:0] dat_o_1,output stb_o_1,output we_o_1,input clk_i,input rst_i,input start,output done);\n [/INST]\n", "output": "wire done_0; \n  wire done_1; \n  assign done = done_0 & done_1; \n wb_master #(.DATA_COUNT (DATA_COUNT),.BASE_ADDRESS (MASTER_0_BASE_ADDRESS),.DATA_WIDTH (DATA_WIDTH),.ADDR_WIDTH (ADDR_WIDTH)) wb_master_0(.clk_i(clk_i),.rst_i(rst_i),.cyc_o(cyc_o_0),.stb_o(stb_o_0),.ack_i(ack_i_0),.we_o(we_o_0),.dat_o(dat_o_0),.dat_i(dat_i_0),.adr_o(adr_o_0),.err_i(err_i_0),.start(start),.done(done_0)); \n wb_master #(.DATA_COUNT (DATA_COUNT),.BASE_ADDRESS (MASTER_1_BASE_ADDRESS),.DATA_WIDTH (DATA_WIDTH),.ADDR_WIDTH (ADDR_WIDTH)) wb_master_1(.clk_i(clk_i),.rst_i(rst_i),.cyc_o(cyc_o_1),.stb_o(stb_o_1),.ack_i(ack_i_1),.we_o(we_o_1),.dat_o(dat_o_1),.dat_i(dat_i_1),.adr_o(adr_o_1),.err_i(err_i_1),.start(start),.done(done_1)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module instantiates several sub-modules and connects their ports using wire assignments. It takes input signals v225d34 and vbb6b94, and produces output signals vae8b91 and v4642b6. The module includes several wire declarations and instantiates other modules such as vad119b, v91f34c, and v25966b with appropriate port connections. The vcdce79 module is also instantiated within this module, completing the functionality of the circuit.\n\n Module header:\n\nmodule v0cfc7a (input [4:0] v225d34,input [4:0] vbb6b94,output v4642b6,output [4:0] vae8b91);\n [/INST]\n", "output": "wire w0; \n  wire w1; \n  wire [0:4] w2; \n  wire [0:4] w3; \n  wire [0:4] w4; \n  wire w5; \n  wire [0:3] w6; \n  wire w7; \n  wire [0:3] w8; \n  wire w9; \n  wire [0:3] w10; \n  assign w2 = vbb6b94; \n  assign w3 = v225d34; \n  assign vae8b91 = w4; \n  assign v4642b6 = w5; \n vad119b vb8ad86 (.v0ef266(w0),.v8e8a67(w1),.v4642b6(w5),.v27dec4(w7),.v82de4f(w9)); \n v91f34c v144430 (.v427dd1(w2),.v53baa6(w9),.v479af4(w10)); \n v91f34c v09d2c7 (.v427dd1(w3),.v53baa6(w7),.v479af4(w8)); \n v25966b vd35762 (.v4642b6(w0),.v817794(w6),.v0550b6(w8),.v24708e(w10)); \n vcdce79 v758283 (.vee8a83(w1),.v6a2e9e(w4),.v167ed7(w6)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes a 32-bit input and an input flag \"io\". It computes the bitwise negation of the input if \"io\" is asserted, and the input itself if \"io\" is not asserted. It then performs a series of checks on the input to determine specific conditions based on its bit patterns, and constructs a 32-bit result accordingly. This result is then output as \"data_out\".\n\n Module header:\n\nmodule cloz(data_in, io,data_out);\n [/INST]\n", "output": "input [31:0] data_in; \n  input io; \n  output [31:0] data_out; \n  wire [31:0] result = 32'b0; \n  wire [31:0] value; \n  wire [15:0] val16; \n  wire [7:0] val8; \n  wire [3:0] val4; \n  assign value = io ? ~data_in : data_in; \n  assign result[4] = (value[31:16] == 16'b0); \n  assign val16 = result[4] ? value[15:0] : value[31:16]; \n  assign result[3] = (val16[15:8] == 8'b0); \n  assign val8 = result[3] ? val16[7:0] : val16[15:8]; \n  assign result[2] = (val8[7:4] == 4'b0); \n  assign val4 = result[2] ? val8[3:0] : val8[7:4]; \n  assign result[1] = (val4[3:2] == 2'b0); \n  assign result[0] = result[1] ? ~val4[1] : ~val4[3]; \n  assign data_out = result; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, named \"select8_8\", takes in eight 8-bit inputs and a 3-bit selection signal. Depending on the value of the selection signal, the module selects one of the eight inputs and assigns it to the output. If the selection signal does not match any of the specified cases, the output is set to 8'b0.\n\n Module header:\n\nmodule select8_8(input [7:0] in1,input [7:0] in2,input [7:0] in3,input [7:0] in4,input [7:0] in5,input [7:0] in6,input [7:0] in7,input [7:0] in8,input [2:0] choose,output reg [7:0] out);\n [/INST]\n", "output": "always@(in1 or in2 or in3 or in4 or in5 or in6 or in7 or in8 or choose) \n case(choose) \n 3'b000:out=in1; \n 3'b001:out=in2; \n 3'b010:out=in3; \n 3'b011:out=in4; \n 3'b100:out=in5; \n 3'b101:out=in6; \n 3'b110:out=in7; \n 3'b111:out=in8; \n default:out=8'b0; \n endcase \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a receiver state machine that processes incoming data and outputs it when complete. It operates on a clock divider signal and uses a 2-bit state register to keep track of the receiving process. When the incoming data starts, it enters the RX_STATE_DATA, stores the incoming bits, and then moves to the RX_STATE_STOP to output the data and mark it as available.\n\n Module header:\n\nmodule recepcion(input rx,output reg avail,output reg [7:0] dout,input wire clk_div);\n [/INST]\n", "output": "initial begin \n  avail=0; \n  dout = 8'b00000000; \n end \n parameter RX_STATE_START = 2'b00; \n parameter RX_STATE_DATA = 2'b01; \n parameter RX_STATE_STOP = 2'b10; \n reg [1:0] state = RX_STATE_START; \n reg [3:0] bitpos = 0; \n reg [7:0] scratch = 8'b00000000; \n always @(posedge clk_div) begin \n  avail<=0; \n  case (state) \n  RX_STATE_START: begin \n  if (rx==0) begin \n  avail<=0; \n  bitpos <= 0; \n  scratch <= 0; \n  state <= RX_STATE_DATA; \n  end \n  end \n  RX_STATE_DATA: begin \n  if(bitpos<=7) begin \n  scratch[bitpos] <= rx; \n  bitpos<=bitpos+1; \n  end \n  if (bitpos == 8)begin \n  state <= RX_STATE_STOP; \n  end \n  end \n  RX_STATE_STOP: begin \n  if (rx==1) begin \n  state <= RX_STATE_START; \n  dout <= scratch; \n  avail <= 1; \n  end \n  end \n  default: begin \n  state <= RX_STATE_START; \n  end \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module represents a pipelined stage in a processor. The module updates various registers based on control signals and pipeline stall/flush conditions. The input signals control the behavior of the module, and the output registers store the updated values. The update is synchronized to the rising edge of the clock signal. The operation and data inputs are passed through the stage, and various control and status signals are updated based on stall/flush conditions and input values.\n\n Module header:\n\nmodule ada_idex_stage(input clk,input rst,input [4:0] id_exu_operation,input [31:0] id_exu_port_a,input [31:0] id_exu_port_b,input [31:0] id_mem_store_data,input id_mem_write,input id_mem_read,input id_mem_byte,input id_mem_halfword,input id_mem_sign_ext,input id_mem_exu_mem_select,input [4:0] id_gpr_wa,input id_gpr_we,input id_kernel_mode,input [31:0] id_pc_current,input id_ex_can_exc,input id_mem_can_exc,input id_flush,input id_stall,input ex_stall,output reg [4:0] ex_exu_operation,output reg [31:0] ex_exu_port_a,output reg [31:0] ex_exu_port_b,output reg [31:0] ex_mem_store_data,output reg ex_mem_write,output reg ex_mem_read,output reg ex_mem_byte,output reg ex_mem_halfword,output reg ex_mem_sign_ext,output reg ex_mem_exu_mem_select,output reg [4:0] ex_gpr_wa,output reg ex_gpr_we,output reg ex_kernel_mode,output reg [31:0] ex_pc_current,output reg ex_ex_can_exc,output reg ex_mem_can_exc);\n [/INST]\n", "output": "always @(posedge clk) begin \n  ex_exu_operation <= (rst) ? 5'b0 : ((ex_stall) ? ex_exu_operation : ((id_stall | id_flush) ? 5'b0 : id_exu_operation)); \n  ex_exu_port_a <= (rst) ? 32'b0 : ((ex_stall) ? ex_exu_port_a : id_exu_port_a); \n  ex_exu_port_b <= (rst) ? 32'b0 : ((ex_stall) ? ex_exu_port_b : id_exu_port_b); \n  ex_mem_store_data <= (rst) ? 32'b0 : ((ex_stall) ? ex_mem_store_data : id_mem_store_data); \n  ex_mem_write <= (rst) ? 1'b0 : ((ex_stall) ? ex_mem_write : ((id_stall | id_flush) ? 1'b0 : id_mem_write)); \n  ex_mem_read <= (rst) ? 1'b0 : ((ex_stall) ? ex_mem_read : ((id_stall | id_flush) ? 1'b0 : id_mem_read)); \n  ex_mem_byte <= (rst) ? 1'b0 : ((ex_stall) ? ex_mem_byte : id_mem_byte); \n  ex_mem_halfword <= (rst) ? 1'b0 : ((ex_stall) ? ex_mem_halfword : id_mem_halfword); \n  ex_mem_sign_ext <= (rst) ? 1'b0 : ((ex_stall) ? ex_mem_sign_ext : id_mem_sign_ext); \n  ex_mem_exu_mem_select <= (rst) ? 1'b0 : ((ex_stall) ? ex_mem_exu_mem_select : id_mem_exu_mem_select); \n  ex_gpr_wa <= (rst) ? 5'b0 : ((ex_stall) ? ex_gpr_wa : ((id_stall | id_flush) ? 5'b0 : id_gpr_wa)); \n  ex_gpr_we <= (rst) ? 1'b0 : ((ex_stall) ? ex_gpr_we : ((id_stall | id_flush) ? 1'b0 : id_gpr_we)); \n  ex_kernel_mode <= (rst) ? 1'b0 : ((ex_stall) ? ex_kernel_mode : ((id_stall | id_flush) ? 1'b0 : id_kernel_mode)); \n  ex_pc_current <= (rst) ? 32'b0 : ((ex_stall) ? ex_pc_current : id_pc_current); \n  ex_ex_can_exc <= (rst) ? 1'b0 : ((ex_stall) ? ex_ex_can_exc : ((id_stall | id_flush) ? 1'b0 : id_ex_can_exc)); \n  ex_mem_can_exc <= (rst) ? 1'b0 : ((ex_stall) ? ex_mem_can_exc : ((id_stall | id_flush) ? 1'b0 : id_mem_can_exc)); \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"tx\" is a UART transmitter. It has inputs for clock signal, reset signal, baud rate, data to be transmitted, transmission enable signal, and an output for tx signal. It also has an output signal tx_ready. The module uses state machine to control the transmission process. The tx signal represents the transmitted data. The module samples the input data to be transmitted and sends it out based on the baud rate. The state machine transitions through states to control the start, data, and stop bits of the transmission. The tx_ready signal indicates when the module is ready to start transmitting.\n\n Module header:\n\nmodule tx (clk,reset_,baud,txdata,tx_enable,tx_ready,tx);\n [/INST]\n", "output": "input clk; \n  input reset_; \n  input baud; \n  input [7:0] txdata; \n  input tx_enable; \n  output tx_ready; \n  output tx; \n  reg tx; \n  reg [1:0] state; \n  reg [7:0] txdata_sampled; \n  reg [2:0] txpos; \n  parameter ST_IDLE = 2'd0; \n  parameter ST_TXSTART = 2'd1; \n  parameter ST_TXDATA = 2'd2; \n  parameter ST_TXSTOP = 2'd3; \n  assign tx_ready = state == ST_IDLE; \n  always@ (posedge clk or negedge reset_) \n  if (!reset_) \n  state <= ST_IDLE; \n  else if (state == ST_IDLE && tx_enable) \n  state <= ST_TXSTART; \n  else if (state == ST_TXSTART && baud) \n  state <= ST_TXDATA; \n  else if (state == ST_TXDATA && baud && txpos == 3'd7) \n  state <= ST_TXSTOP; \n  else if (state == ST_TXSTOP && baud) \n  state <= ST_IDLE; \n  always@ (posedge clk or negedge reset_) \n  if (!reset_) \n  tx <= 1'b1; \n  else if (state == ST_TXSTART && baud) \n  tx <= 1'b0; \n  else if (state == ST_TXDATA && baud) \n  tx <= txdata_sampled[txpos]; \n  else if (state == ST_TXSTOP && baud) \n  tx <= 1'b1; \n  always@ (posedge clk or negedge reset_) \n  if (!reset_) \n  txpos <= 3'd0; \n  else if (state == ST_IDLE) \n  txpos <= 3'd0; \n  else if (state == ST_TXDATA && baud) \n  txpos <= txpos + 3'd1; \n  always@ (posedge clk or negedge reset_) \n  if (!reset_) \n  txdata_sampled <= 8'h0; \n  else if (tx_enable && tx_ready) \n  txdata_sampled <= txdata; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module is an Apb3Decoder that takes input signals and decodes them to produce output signals. It uses logical operations to generate three signals _zz_1, _zz_2, and _zz_3. The module then uses these signals to determine the values of io_output_PSEL[0], io_output_PSEL[1], and io_output_PSEL[2]. It also performs assignments for other output signals based on the input signals and the generated values.\n\n Module header:\n\nmodule Apb3Decoder (input [19:0] io_input_PADDR,input [0:0] io_input_PSEL,input io_input_PENABLE,output io_input_PREADY,input io_input_PWRITE,input [31:0] io_input_PWDATA,output [31:0] io_input_PRDATA,output io_input_PSLVERROR,output [19:0] io_output_PADDR,output reg [2:0] io_output_PSEL,output io_output_PENABLE,input io_output_PREADY,output io_output_PWRITE,output [31:0] io_output_PWDATA,input [31:0] io_output_PRDATA,input io_output_PSLVERROR);\n [/INST]\n", "output": "wire [19:0] _zz_1; \n  wire [19:0] _zz_2; \n  wire [19:0] _zz_3; \n  assign _zz_1 = (20'b11111111000000000000); \n  assign _zz_2 = (20'b11111111000000000000); \n  assign _zz_3 = (20'b11111111000000000000); \n  assign io_output_PADDR = io_input_PADDR; \n  assign io_output_PENABLE = io_input_PENABLE; \n  assign io_output_PWRITE = io_input_PWRITE; \n  assign io_output_PWDATA = io_input_PWDATA; \n  always @ (*) begin \n  io_output_PSEL[0] = (((io_input_PADDR & _zz_1) == (20'b00000000000000000000)) && io_input_PSEL[0]); \n  io_output_PSEL[1] = (((io_input_PADDR & _zz_2) == (20'b00010000000000000000)) && io_input_PSEL[0]); \n  io_output_PSEL[2] = (((io_input_PADDR & _zz_3) == (20'b00100000000000000000)) && io_input_PSEL[0]); \n  end \n  assign io_input_PREADY = io_output_PREADY; \n  assign io_input_PRDATA = io_output_PRDATA; \n  assign io_input_PSLVERROR = io_output_PSLVERROR; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a simple ROM (Read-Only Memory) with two address inputs and two data outputs. It has a memory array that is initialized with data from the specified data file. On every positive edge of the clock signal, the module reads data from the memory at the specified address and assigns it to the output q_a and q_b. The memory size is determined by the width and widthad parameters, and the data file used for initialization is specified by the datafile parameter.\n\n Module header:\n\nmodule simple_rom_0(input clk,input [widthad-1:0] addr_a,output reg [width-1:0] q_a,input [widthad-1:0] addr_b,output reg [width-1:0] q_b);\n [/INST]\n", "output": "parameter width = 16; \n parameter widthad = 9; \n parameter datafile = \"./designs/sound/src/opl2_waveform_rom.hex\"; \n reg [width-1:0] mem [(2**widthad)-1:0]; \n initial \n begin \n $readmemh(datafile, mem); \n end \n always @(posedge clk) begin \n  q_a <= mem[addr_a]; \n  q_b <= mem[addr_b]; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a 3-bit register with enable functionality. The output vector 'out' stores the value of the input vector 'in' when the 'enable_l' signal is low. When 'enable_l' is high, 'out' holds the value of the 'master' register. The 'master' register is set to 4'bx when the 'clock' signal is high. The always block triggers on the positive edge of the 'clock' signal and checks the 'enable_l' and 'clock' signals to determine whether to update the 'master' register and output 'out'. When 'enable_l' is high or 'clock' is high, 'master' is set to 4'bx, and when 'enable_l' is low, 'master' is updated with the input value, and 'out' is set to 'master'.\n\n Module header:\n\nmodule Mregister_3 (out, in, clock, enable_l);\n [/INST]\n", "output": "output [2:0] out; \n input [2:0] in; \n input clock; \n input enable_l; \n  reg [2:0] out; \n  reg [2:0] master; \n  always @ (posedge clock) begin \n  if((enable_l === 1'bx) || (clock === 1'bx)) begin \n  master = 4'bx; \n  #1 out = master; \n  end \n  else if (~enable_l) begin \n  master = in; \n  #1 out = master; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a hardware design that interfaces with various memory and input/output devices. It contains registers for SNES memory, MCU memory, MCU output, and ROM memory. The module handles data transfer between these memories and devices based on control signals and the clock signal.\n\nIt assigns the input data to the MSU_DATA_IN register and controls the data flow to and from SNES, MCU, and ROM memory based on specific conditions. It also sets the output data for MCU_OUT_DATA and the ROM_DATA based on various control signals and memory writes.\n\nThe behavior is governed by the positive edge of the clock signal and specific conditions for writing to the memories based on SNES_DATA_TO_MEM, MCU_DATA_TO_MEM, ROM_DATA_TO_SNES_MEM, and ROM_DATA_TO_MCU_MEM signals.\n\nOverall, the module acts as an interface controller for managing data transfer between different memory units and input/output devices based on specific conditions and the clock signal.\n\n Module header:\n\nmodule data(input CLK,input SNES_READ,input SNES_WRITE,input MCU_READ,input MCU_WRITE,inout [7:0] SNES_DATA,inout [15:0] ROM_DATA,input [7:0] MCU_IN_DATA,output [7:0] MCU_OUT_DATA,input MODE,input SNES_DATA_TO_MEM,input MCU_DATA_TO_MEM,input ROM_DATA_TO_SNES_MEM,input ROM_DATA_TO_MCU_MEM,input MCU_OVR,input ROM_ADDR0,output [7:0] MSU_DATA_IN,input [7:0] MSU_DATA_OUT);\n [/INST]\n", "output": "reg [7:0] SNES_IN_MEM; \n reg [7:0] SNES_OUT_MEM; \n reg [7:0] MCU_IN_MEM; \n reg [7:0] MCU_OUT_MEM; \n wire [7:0] FROM_ROM_BYTE; \n assign MSU_DATA_IN = SNES_DATA; \n assign SNES_DATA = SNES_READ ? 8'bZ : (!MCU_OVR ? 8'h00 : SNES_OUT_MEM); \n assign FROM_ROM_BYTE = (ROM_ADDR0 ? ROM_DATA[7:0] : ROM_DATA[15:8]); \n assign MCU_OUT_DATA = !MCU_OVR ? (FROM_ROM_BYTE) \n  : (MCU_OUT_MEM); \n assign ROM_DATA[7:0] = ROM_ADDR0 ? (!MCU_OVR ? (!MCU_WRITE ? MCU_IN_DATA : 8'bZ): (MODE ? (!MCU_WRITE ? MCU_IN_MEM : 8'bZ): (!SNES_WRITE ? SNES_IN_MEM : 8'bZ))) \n  : 8'bZ; \n assign ROM_DATA[15:8] = ROM_ADDR0 ? 8'bZ : (!MCU_OVR ? (!MCU_WRITE ? MCU_IN_DATA : 8'bZ): (MODE ? (!MCU_WRITE ? MCU_IN_MEM : 8'bZ): (!SNES_WRITE ? SNES_IN_MEM : 8'bZ))); \n always @(posedge CLK) begin \n  if(SNES_DATA_TO_MEM) \n  SNES_IN_MEM <= SNES_DATA; \n  if(MCU_DATA_TO_MEM) \n  MCU_IN_MEM <= MCU_IN_DATA; \n  if(ROM_DATA_TO_SNES_MEM) \n  SNES_OUT_MEM <= FROM_ROM_BYTE; \n  if(ROM_DATA_TO_MCU_MEM) \n  MCU_OUT_MEM <= FROM_ROM_BYTE; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is designed to implement a circuit for handling read and write operations in a memory bank system. It receives multiple control signals and data inputs and produces row hit signals and read data outputs. The module includes two DCM panel pairs that handle the scanning and data management for each bank. The row hit output is derived by combining the bank 0 and bank 1 hit signals. The module provides read data outputs for each bank and is designed for use in a memory banking system.\n\n Module header:\n\nmodule bw_r_dcm(row_hit, rd_data0, rd_data1, rd_data2, rd_data3, so_0, so_1,cam_en, inv_mask0, inv_mask1, inv_mask2, inv_mask3, si_0, se_0,si_1, se_1, sehold_0, sehold_1, rclk, rd_en, rw_addr0,rw_addr1, rw_addr2, rw_addr3, rst_l_0, rst_l_1, rst_warm_0,rst_warm_1, wr_en, rst_tri_en_0, rst_tri_en_1, wr_data0, wr_data1,wr_data2, wr_data3);\n [/INST]\n", "output": "output [31:0] row_hit; \n output [31:0] rd_data0; \n output [31:0] rd_data1; \n output [31:0] rd_data2; \n output [31:0] rd_data3; \n input [3:0] cam_en; \n input [7:0] inv_mask0; \n input [7:0] inv_mask1; \n input [7:0] inv_mask2; \n input [7:0] inv_mask3; \n input si_0, se_0; \n output so_0; \n input si_1, se_1; \n output so_1; \n input sehold_0; \n input sehold_1; \n input rclk; \n input [3:0] rd_en ; \n input [5:0] rw_addr0; \n input [5:0] rw_addr1; \n input [5:0] rw_addr2; \n input [5:0] rw_addr3; \n input rst_l_0; \n input rst_l_1; \n input rst_warm_0; \n input rst_warm_1; \n input [3:0] wr_en; \n input rst_tri_en_0; \n input rst_tri_en_1; \n input [32:0] wr_data0; \n input [32:0] wr_data1; \n input [32:0] wr_data2; \n input [32:0] wr_data3; \n wire [31:0] bank1_hit; \n wire [31:0] bank0_hit; \n dcm_panel_pair panel_pair0(.so (),.si (),.se (se_0),.bank_hit(bank0_hit[31:0]),.rd_data0(rd_data0[31:0]),.rd_data1(rd_data1[31:0]),.cam_en(cam_en[1:0]),.inv_mask0(inv_mask0[7:0]),.inv_mask1(inv_mask1[7:0]),.rclk (rclk),.rd_en(rd_en[1:0]),.rst_l(rst_l_0),.rst_tri_en(rst_tri_en_0),.rst_warm(rst_warm_0),.rw_addr0(rw_addr0[5:0]),.rw_addr1(rw_addr1[5:0]),.sehold(sehold_0),.wr_data0(wr_data0[32:0]),.wr_data1(wr_data1[32:0]),.wr_en(wr_en[1:0])); \n  assign row_hit = bank1_hit | bank0_hit ; \n dcm_panel_pair panel_pair1(.so (),.si (),.se (se_1),.bank_hit(bank1_hit[31:0]),.rd_data0(rd_data2[31:0]),.rd_data1(rd_data3[31:0]),.cam_en(cam_en[3:2]),.inv_mask0(inv_mask2[7:0]),.inv_mask1(inv_mask3[7:0]),.rclk(rclk),.rd_en(rd_en[3:2]),.rst_l(rst_l_1),.rst_tri_en(rst_tri_en_1),.rst_warm(rst_warm_1),.rw_addr0(rw_addr2[5:0]),.rw_addr1(rw_addr3[5:0]),.sehold(sehold_1),.wr_data0(wr_data2[32:0]),.wr_data1(wr_data3[32:0]),.wr_en(wr_en[3:2])); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a multiplexer with a parameterized width. It takes two input data streams d0 and d1, a select signal s, and produces a single output y. When s is high, the output y takes the value of d1, and when s is low, y takes the value of d0. The module can be customized to support different data widths by setting the WIDTH parameter.\n\n Module header:\n\nmodule mux1 #(parameter WIDTH = 10) (input wire [WIDTH-1:0] d0, d1,input wire s,output wire [WIDTH-1:0] y);\n [/INST]\n", "output": "assign y = s ? d1 : d0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module OddParityGen takes an 8-bit input DBx and a control input EN, and generates the output DBP, which is 1 if the number of set bits in DBx is odd when EN is asserted. If EN is deasserted, the output is always 0.\n\n Module header:\n\nmodule OddParityGen (output DBP,input [7:0] DBx,input EN);\n [/INST]\n", "output": "wire tmp = 1 ^ DBx[0]; \n  wire tmpa = DBx[1] ^ DBx[2]; \n  wire tmpb = DBx[3] ^ DBx[4]; \n  wire tmpc = DBx[5] ^ DBx[6] ^ DBx[7]; \n  assign DBP = EN ? tmp ^ tmpa ^ tmpb ^ tmpc : 0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a clock signal generator. The output `clk` toggles between 0 and 1 every 250 time units, creating a basic clock pulse. This module can be used as a clock source for synchronous digital circuits.\n\n Module header:\n\nmodule reloj(clk);\n [/INST]\n", "output": "output reg clk; \n initial \n  begin \n  clk = 0; \n  end \n  always \n  begin \n  #250 clk = 1; \n  #250 clk = 0; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a priority encoder, which encodes the highest-order set bit of the input into the corresponding output. The highest-order set bit of the input is detected by sequentially checking each bit from the highest to the lowest. The output d_out is set to a specific pattern based on the position of the highest-order set bit in the input. If none of the input bits are set, d_out is set to 8'b00000000.\n\n Module header:\n\nmodule Priority_Encoder (input wire [31:0] d_in,output wire [7:0] d_out);\n [/INST]\n", "output": "assign d_out = (d_in[31]==1'b1) ? 8'b00011111: \n  (d_in[30]==1'b1) ? 8'b00011110: \n  (d_in[29]==1'b1) ? 8'b00011101: \n  (d_in[28]==1'b1) ? 8'b00011100: \n  (d_in[27]==1'b1) ? 8'b00011011: \n  (d_in[26]==1'b1) ? 8'b00011010: \n  (d_in[25]==1'b1) ? 8'b00011001: \n  (d_in[24]==1'b1) ? 8'b00011000: \n  (d_in[23]==1'b1) ? 8'b00010111: \n  (d_in[22]==1'b1) ? 8'b00010110: \n  (d_in[21]==1'b1) ? 8'b00010101: \n  (d_in[20]==1'b1) ? 8'b00010100: \n  (d_in[19]==1'b1) ? 8'b00010011: \n  (d_in[18]==1'b1) ? 8'b00010010: \n  (d_in[17]==1'b1) ? 8'b00010001: \n  (d_in[16]==1'b1) ? 8'b00010000: \n  (d_in[15]==1'b1) ? 8'b00001111: \n  (d_in[14]==1'b1) ? 8'b00001110: \n  (d_in[13]==1'b1) ? 8'b00001101: \n  (d_in[12]==1'b1) ? 8'b00001100: \n  (d_in[11]==1'b1) ? 8'b00001011: \n  (d_in[10]==1'b1) ? 8'b00001010: \n  (d_in[9]==1'b1) ? 8'b00001001: \n  (d_in[8]==1'b1) ? 8'b00001000: \n  (d_in[7]==1'b1) ? 8'b00000111: \n  (d_in[6]==1'b1) ? 8'b00000110: \n  (d_in[5]==1'b1) ? 8'b00000101: \n  (d_in[4]==1'b1) ? 8'b00000100: \n  (d_in[3]==1'b1) ? 8'b00000011: \n  (d_in[2]==1'b1) ? 8'b00000010: \n  (d_in[1]==1'b1) ? 8'b00000001: 8'b00000000; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, named \"tb,\" takes in the input \"vconst\" and generates an output \"q\" based on a positive edge of the input \"clk.\" Upon the positive edge of the clock signal, the value of \"q\" is assigned to the value of \"vconst.\"\n\n Module header:\n\nmodule tb (input vconst,input clk,output reg q);\n [/INST]\n", "output": "always @ (posedge clk) begin \n  q <= vconst; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a behavioral description of a circuit that interfaces with input signals mclk, btn, sw, and output signals led, seg, an, dp, OutBlue, OutGreen, OutRed, HS, and VS. The module initializes some of the signals and has a clock control logic that sets the clock signal based on the state of the input signals. It also contains an instantiation of the VBEncoder module and a case statement that sets the values of the seg signal based on the tmp_digit and an signals. Finally, it assigns specific values to the OutBlue, OutGreen, OutRed, HS, and VS signals.\n\n Module header:\n\nmodule Board232 (input mclk,input [3:0] btn,input [7:0] sw,output [7:0] led,output reg [6:0] seg,output reg [3:0] an,output dp,output [2:1] OutBlue,output [2:0] OutGreen,output [2:0] OutRed,output HS,output VS);\n [/INST]\n", "output": "assign dp = 1'b1; \n  initial begin \n  seg[6:0] = 7'b0111111; \n  an[3:0] = 4'b0000; \n  end \n  parameter INT4 = 8'b10000000; \n  parameter INT3 = 8'b00000000; \n  parameter INT2= 8'b00000000; \n  reg [26:0] mclk_counter; \n  initial mclk_counter<= 0; \n  always @(posedge mclk) mclk_counter = mclk_counter+1; \n  reg clk; \n  initial clk = 1'b0; \n  always@(btn[3] or mclk_counter[25] or btn[0]) \n  begin \n  if(btn[3]) \n  clk = mclk_counter[25]; \n  else \n  clk = btn[0]; \n  end \n  reg tmp_digit; \n  wire READY; \n  wire [7:0] STREAM; \n VBEncoder ins (clk,INT4,INT3,INT2,sw[7:0],btn[1],READY,led[7:0]); \n  always @(mclk_counter[18:17]) \n  begin \n  case (mclk_counter[18:17]) \n  2'b00: \n  begin \n  an = 4'b1110; \n  tmp_digit = READY; \n  end \n  default: \n  begin \n  an = 4'b1111; \n  end \n  endcase \n  case (tmp_digit) \n  4'd0: seg <= ~7'h3F; \n  4'd1: seg <= ~7'h06; \n  4'd2: seg <= ~7'h5B; \n  4'd3: seg <= ~7'h4F; \n  4'd4: seg <= ~7'h66; \n  4'd5: seg <= ~7'h6D; \n  4'd6: seg <= ~7'h7D; \n  4'd7: seg <= ~7'h07; \n  4'd8: seg <= ~7'h7F; \n  4'd9: seg <= ~7'h6F; \n  4'd10: seg <= ~7'h77; \n  4'd11: seg <= ~7'h7C; \n  4'd12: seg <= ~7'h39; \n  4'd13: seg <= ~7'h5E; \n  4'd14: seg <= ~7'h79; \n  4'd15: seg <= ~7'h71; \n  default: seg <= ~7'b0000000; \n  endcase \n  end \n  assign OutBlue = 0; \n  assign OutGreen = 0; \n  assign OutRed = 0; \n  assign HS = 0; \n  assign VS = 0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module models a finite state machine that tracks the state of a key's press. The module uses the clock and reset signals, along with an enable_in signal to determine the enable_out signal. The key state is tracked using two bits, representing KEY_FREE, KEY_PRESSED, and KEY_RELEASED states. The module updates the key_state based on the next_key_state and enable_out based on the state transitions. The enable_out signal is asserted when the key is released.\n\n Module header:\n\nmodule keypressed(clock, reset, enable_in, enable_out);\n [/INST]\n", "output": "input clock; \n  input reset; \n  input enable_in; \n  output enable_out; \n  reg [1:0] key_state, next_key_state; \n  reg enable_out; \n  parameter [1:0] KEY_FREE = 2'b00, KEY_PRESSED = 2'b01, KEY_RELEASED = 2'b10; \n  always @(posedge clock or negedge reset) begin \n  if (reset == 1'b0) \n  key_state <= KEY_FREE; \n  else \n  key_state <= next_key_state; \n  end \n  always @(key_state, enable_in) begin \n  next_key_state = key_state; \n  enable_out = 1'b0; \n  case (key_state) \n  KEY_FREE: begin \n  if (enable_in == 1'b0) \n  next_key_state = KEY_PRESSED; \n  end \n  KEY_PRESSED: begin \n  if (enable_in == 1'b1) \n  next_key_state = KEY_RELEASED; \n  end \n  KEY_RELEASED: begin \n  enable_out = 1'b1; \n  next_key_state = KEY_FREE; \n  end \n  default: begin \n  next_key_state = 2'bxx; \n  enable_out = 1'bx; \n  end \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a clock domain crossing (CDC) handshake module that ensures proper data transfer between two different clock domains. It includes clock synchronizers for request and acknowledgment signals to ensure reliable communication between the two clock domains. The module also includes a data output register that updates based on the request signal and the data enable signal. The data enable signal is generated based on the synchronized request signal.\n\n Module header:\n\nmodule axis_infrastructure_v1_1_0_cdc_handshake # (parameter integer C_WIDTH = 32,parameter integer C_NUM_SYNCHRONIZER_STAGES = 2) (input wire from_clk,input wire req,output wire ack,input wire [C_WIDTH-1:0] data_in,input wire to_clk,output wire [C_WIDTH-1:0] data_out);\n [/INST]\n", "output": "wire ack_synch; \n wire req_synch; \n wire data_en; \n reg req_synch_d1; \n reg [C_WIDTH-1:0] data_r; \n assign ack = ack_synch; \n axis_infrastructure_v1_1_0_clock_synchronizer #(.C_NUM_STAGES ( C_NUM_SYNCHRONIZER_STAGES )) \n inst_ack_synch (.clk (from_clk),.synch_in (req_synch),.synch_out (ack_synch)); \n axis_infrastructure_v1_1_0_clock_synchronizer #(.C_NUM_STAGES ( C_NUM_SYNCHRONIZER_STAGES )) \n inst_req_synch (.clk (to_clk),.synch_in (req),.synch_out (req_synch)); \n assign data_out = data_r; \n always @(posedge to_clk) begin \n  data_r = data_en ? data_in : data_r; \n end \n assign data_en = req_synch & ~req_synch_d1; \n always @(posedge to_clk) begin \n  req_synch_d1 <= req_synch; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a simple module that assigns the output o to a high-impedance state (1'bz) using the assign statement. This module does not have any inputs and simply sets the output to high-impedance.\n\n Module header:\n\nmodule hardcaml_lib_z (output o);\n [/INST]\n", "output": "assign o = 1'bz; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a Wishbone interconnect with two slave modules. It features a configurable address space for different peripherals. The module handles write, read, and interrupt signals for the slave modules based on the address presented on the input bus. It supports multiple slaves and performs the necessary signal multiplexing for each slave based on the address.\n\n Module header:\n\nmodule wishbone_interconnect (clk,rst,i_m_we,i_m_cyc,i_m_sel,i_m_stb,o_m_ack,i_m_dat,o_m_dat,i_m_adr,o_m_int,o_s0_we,o_s0_cyc,o_s0_sel,o_s0_stb,i_s0_ack,o_s0_dat,i_s0_dat,o_s0_adr,i_s0_int,o_s1_we,o_s1_cyc,o_s1_sel,o_s1_stb,i_s1_ack,o_s1_dat,i_s1_dat,o_s1_adr,i_s1_int);\n [/INST]\n", "output": "parameter ADDR_0 = 8'h00; \n parameter ADDR_1 = 8'h01; \n parameter ADDR_FF = 8'hFF; \n input clk; \n input rst; \n input i_m_we; \n input i_m_stb; \n input i_m_cyc; \n input [3:0] i_m_sel; \n input [31:0] i_m_adr; \n input [31:0] i_m_dat; \n output reg [31:0] o_m_dat = 32'h0; \n output reg o_m_ack = 1'h0; \n output o_m_int; \n output o_s0_we; \n output o_s0_stb; \n output o_s0_cyc; \n output [3:0] o_s0_sel; \n output [31:0] o_s0_adr; \n output [31:0] o_s0_dat; \n input [31:0] i_s0_dat; \n input i_s0_ack; \n input i_s0_int; \n output o_s1_we; \n output o_s1_stb; \n output o_s1_cyc; \n output [3:0] o_s1_sel; \n output [31:0] o_s1_adr; \n output [31:0] o_s1_dat; \n input [31:0] i_s1_dat; \n input i_s1_ack; \n input i_s1_int; \n wire [7:0]slave_select; \n assign slave_select = i_m_adr[31:24]; \n wire [31:0] interrupts; \n always @ (slave_select or i_s0_dat or i_s1_dat or interrupts) begin \n  case (slave_select) \n  ADDR_0: begin \n  o_m_dat <= i_s0_dat; \n  end \n  ADDR_1: begin \n  o_m_dat <= i_s1_dat; \n  end \n  default: begin \n  o_m_dat <= interrupts; \n  end \n  endcase \n end \n always @ (slave_select or i_s0_ack or i_s1_ack) begin \n  case (slave_select) \n  ADDR_0: begin \n  o_m_ack <= i_s0_ack; \n  end \n  ADDR_1: begin \n  o_m_ack <= i_s1_ack; \n  end \n  default: begin \n  o_m_ack <= 1'h0; \n  end \n  endcase \n end \n assign interrupts[0] = i_s0_int; \n assign interrupts[1] = i_s1_int; \n assign interrupts[31:2] = 0; \n assign o_m_int = (interrupts != 0); \n assign o_s0_we = (slave_select == ADDR_0) ? i_m_we: 0; \n assign o_s0_stb = (slave_select == ADDR_0) ? i_m_stb: 0; \n assign o_s0_sel = (slave_select == ADDR_0) ? i_m_sel: 0; \n assign o_s0_cyc = (slave_select == ADDR_0) ? i_m_cyc: 0; \n assign o_s0_adr = (slave_select == ADDR_0) ? {8'h0 , i_m_adr[23:0]}: 0; \n assign o_s0_dat = (slave_select == ADDR_0) ? i_m_dat: 0; \n assign o_s1_we = (slave_select == ADDR_1) ? i_m_we: 0; \n assign o_s1_stb = (slave_select == ADDR_1) ? i_m_stb: 0; \n assign o_s1_sel = (slave_select == ADDR_1) ? i_m_sel: 0; \n assign o_s1_cyc = (slave_select == ADDR_1) ? i_m_cyc: 0; \n assign o_s1_adr = (slave_select == ADDR_1) ? {8'h0 , i_m_adr[23:0]}: 0; \n assign o_s1_dat = (slave_select == ADDR_1) ? i_m_dat: 0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a UART light clock generator, which generates clock signals for transmission and reception in a UART communication system. It uses divisor values to generate the transmit and receive clocks. The module also includes logic for resetting the divisors and incrementing them based on certain conditions. The output clock signals, clk_tx and clk_rx, are assigned based on the values of the divisors.\n\n Module header:\n\nmodule uart_light_clk_gen #(parameter BR_DIVISOR_TX = 54,parameter BR_DIVISOR_RX = 5,parameter BRD_SIZE_TX = 6,parameter BRD_SIZE_RX = 3)(output wire clk_rx,output wire clk_tx,input wire clk_peri,input wire reset);\n [/INST]\n", "output": "reg [BRD_SIZE_TX-1:0] divisor_tx; \n  reg [BRD_SIZE_RX-1:0] divisor_rx; \n  assign clk_tx = divisor_tx[BRD_SIZE_TX-1]; \n  assign clk_rx = divisor_rx[BRD_SIZE_RX-1]; \n  always @(posedge clk_peri, posedge reset) begin \n  if(reset) begin \n  divisor_tx <= {(BRD_SIZE_TX){1'b0}}; \n  divisor_rx <= {(BRD_SIZE_RX){1'b0}}; \n  end \n  else begin \n  if(divisor_tx == (BR_DIVISOR_TX - 1'b1)) \n  divisor_tx <= {(BRD_SIZE_TX){1'b0}}; \n  else \n  divisor_tx <= divisor_tx + 1'b1; \n  if(divisor_rx == (BR_DIVISOR_RX - 1'b1)) \n  divisor_rx <= {(BRD_SIZE_RX){1'b0}}; \n  else \n  divisor_rx <= divisor_rx + 1'b1; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module avfb_pad_mux implements a hardware component that assigns the input BC_RA_02_fail_i to the output BC_RA_02_fail. It also declares and connects multiple output ports, such as mix_dmy_open_0 to mix_dmy_open_14. Additionally, it instantiates another module iom_24, and connects its inputs and outputs to various signals within the module. The iom_24 module seems to handle a range of signals, from lfsr_out_7 to i2s_ws_en_out1, and connects its outputs to mix_dmy_open_6, mix_dmy_open_5, and other mix_dmy_open signals.\n\n Module header:\n\nmodule avfb_pad_mux (BC_RA_02_fail_i);\n [/INST]\n", "output": "input BC_RA_02_fail_i; \n  wire BC_RA_02_fail_i; \n  wire BC_RA_02_fail; \n  assign BC_RA_02_fail = BC_RA_02_fail_i; \n  wire mix_dmy_open_0; \n  wire mix_dmy_open_1; \n  wire mix_dmy_open_2; \n  wire mix_dmy_open_3; \n  wire mix_dmy_open_4; \n  wire mix_dmy_open_5; \n  wire mix_dmy_open_6; \n  wire mix_dmy_open_7; \n  wire mix_dmy_open_8; \n  wire mix_dmy_open_9; \n  wire mix_dmy_open_10; \n  wire mix_dmy_open_11; \n  wire mix_dmy_open_12; \n  wire mix_dmy_open_13; \n  wire mix_dmy_open_14; \n iom_24 iom_i2s_ws_out1 (.dot_i({ 1'b0, lfsr_out_7, test_out_0, 1'b0, 1'b0, i2s_ws_out1_out, i2s_ws_out1_out, 1'b0, 1'b0, ts_intsig1, rgb_c_tbo_2, rgb_c_tbo_1, cvbs_c_tbo_2, cvbs_c_tbo_1, postproc_out_b_tbo, 1'b0, 1'b0, BC_RA_02_fail, scan_out_7, i2s_ws_out1_out }),.ena_i({ 1'b0, 1'b1, test_pad_oen_0, 1'b0, 1'b0, i2s_ws_en_out1, i2s_ws_en_out1, 1'b0, 1'b0, 1'b1, 1'b1, 1'b1, 1'b1, 1'b1, 1'b1, 1'b0, 1'b0, 1'b1, 1'b1, i2s_ws_en_out1 }),.ret_o({ mix_dmy_open_6, mix_dmy_open_5, test_in_0, ts_adc_samples_2, ts_adc_samples_1, mix_dmy_open_4, mix_dmy_open_3, mix_dmy_open_2, mix_dmy_open_1, mix_dmy_open_0, mix_dmy_open_14, mix_dmy_open_13, mix_dmy_open_12, mix_dmy_open_11, mix_dmy_open_10, kl_123456a2345b_c, mix_dmy_open_9, mix_dmy_open_8, mix_dmy_open_7, i2s_ws_out1_in })); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a queue with write and read functionality. It has input ports for clock, reset, write request, write flag, read request, and flash. It has output ports for write full, read valid, read flag, and read empty. The module contains counters, queue validity flags, and queue type registers. It increments the write and read counters based on write and read requests, and updates the queue validity and type accordingly. The module also handles reset logic and outputs the full and empty status of the queue.\n\n Module header:\n\nmodule mist1032sa_arbiter_matching_queue #(parameter D = 8,parameter DN = 3,parameter FN = 1)(input wire iCLOCK,input wire inRESET,input wire iFLASH,input wire iWR_REQ,input wire [FN-1:0] iWR_FLAG,output wire oWR_FULL,input wire iRD_REQ,output wire oRD_VALID,output wire [FN-1:0] oRD_FLAG,output wire oRD_EMPTY);\n [/INST]\n", "output": "wire full_flag; \n  wire empty_flag; \n  wire [DN:0] count; \n  reg [DN:0] wr_counter; \n  reg [DN:0] rd_counter; \n  reg queue_valid[0:D-1]; \n  reg [FN-1:0] queue_type[0:D-1]; \n  integer i; \n  assign full_flag = count[DN]; \n  assign empty_flag = (wr_counter == rd_counter)? 1'b1 : 1'b0; \n  assign count = wr_counter - rd_counter; \n  always@(posedge iCLOCK or negedge inRESET)begin \n  if(!inRESET)begin \n  wr_counter <= {DN+1{1'b0}}; \n  rd_counter <= {DN+1{1'b0}}; \n  for(i = 0; i < D; i = i + 1)begin \n  queue_valid[i] <= 1'b0; \n  end \n  end \n  else begin \n  if(iFLASH)begin \n  for(i = 0; i < D; i = i + 1)begin \n  queue_valid[i] <= 1'b0; \n  end \n  end \n  if(!full_flag && iWR_REQ)begin \n  wr_counter <= wr_counter + {{DN{1'b0}}, 1'b1}; \n  queue_valid[wr_counter[DN-1:0]] <= 1'b1; \n  queue_type[wr_counter[DN-1:0]] <= iWR_FLAG; \n  end \n  if(!empty_flag && iRD_REQ)begin \n  rd_counter <= rd_counter + {{DN{1'b0}}, 1'b1}; \n  queue_valid[rd_counter[DN-1:0]] <= 1'b0; \n  end \n  end \n  end \n  assign oWR_FULL = full_flag; \n  assign oRD_VALID = queue_valid[rd_counter[DN-1:0]] && !iFLASH; \n  assign oRD_FLAG = queue_type[rd_counter[DN-1:0]]; \n  assign oRD_EMPTY = empty_flag; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module generates a test for a binary adder. It takes two 8-bit input vectors a and b, and performs a bitwise addition with carry using a clock signal. The carry propagation is implemented using a case statement, and the final result is stored in the output register y, with the carry bit stored in the 9th bit.\n\n Module header:\n\nmodule gen_test2(clk, a, b, y);\n [/INST]\n", "output": "input clk; \n input [7:0] a, b; \n output reg [8:0] y; \n integer i; \n reg [8:0] carry; \n always @(posedge clk) begin \n  carry[0] = 0; \n  for (i = 0; i < 8; i = i + 1) begin \n  casez ({a[i], b[i], carry[i]}) \n  3'b?11, 3'b1?1, 3'b11?: \n  carry[i+1] = 1; \n  default: \n  carry[i+1] = 0; \n  endcase \n  y[i] = a[i] ^ b[i] ^ carry[i]; \n  end \n  y[8] = carry[8]; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module defines a parameterized output wire and instantiates another module, v3693fc_v465065, which has an output wire connected to the local parameter. The output of the module is assigned to the local wire.\n\n Module header:\n\nmodule v3693fc #(parameter vc5c8ea = 0) (output [4:0] vc8d3b9);\n [/INST]\n", "output": "localparam p0 = vc5c8ea; \n  wire [0:4] w1; \n  assign vc8d3b9 = w1; \n v3693fc_v465065 #(.VALUE(p0)) v465065 (.k(w1)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes a 3-bit input vin0 and performs a left shift on an 8-bit output vout0 based on vin0, assigning the result to myreg0. It also performs a right shift on myreg2 based on the value of the integer i and assigns the result to myreg1.\n\n Module header:\n\nmodule f33_test(vin0, vout0);\n [/INST]\n", "output": "input [2:0] vin0; \n output reg [7:0] vout0; \n wire [7:0] myreg0, myreg1, myreg2; \n integer i; \n assign myreg0 = vout0 << vin0; \n assign myreg1 = myreg2 >> i; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is designed to perform parity monitoring on an input ADC data stream. The module continuously compares the incoming ADC data with a predefined pattern and monitors for any errors. It tracks out-of-sync occurrences and updates the parity error flag accordingly. The module also tracks the validity of the ADC data and counts the number of out-of-sync events. The output signals adc_pn_oos and adc_pn_err indicate the out-of-sync status and parity errors, respectively. The module also maintains internal state and counters to keep track of the status of the ADC data.\n\n Module header:\n\nmodule ad_pnmon #(parameter DATA_WIDTH = 16) (input adc_clk,input adc_valid_in,input [(DATA_WIDTH-1):0] adc_data_in,input [(DATA_WIDTH-1):0] adc_data_pn,output adc_pn_oos,output adc_pn_err);\n [/INST]\n", "output": "reg adc_valid_d = 'd0; \n  reg adc_pn_match_d = 'd0; \n  reg adc_pn_match_z = 'd0; \n  reg adc_pn_oos_int = 'd0; \n  reg adc_pn_err_int = 'd0; \n  reg [ 3:0] adc_pn_oos_count = 'd0; \n  wire adc_pn_match_d_s; \n  wire adc_pn_match_z_s; \n  wire adc_pn_match_s; \n  wire adc_pn_update_s; \n  wire adc_pn_err_s; \n  assign adc_pn_match_d_s = (adc_data_in == adc_data_pn) ? 1'b1 : 1'b0; \n  assign adc_pn_match_z_s = (adc_data_in == 'd0) ? 1'b0 : 1'b1; \n  assign adc_pn_match_s = adc_pn_match_d & adc_pn_match_z; \n  assign adc_pn_update_s = ~(adc_pn_oos_int ^ adc_pn_match_s); \n  assign adc_pn_err_s = ~(adc_pn_oos_int | adc_pn_match_s); \n  assign adc_pn_oos = adc_pn_oos_int; \n  assign adc_pn_err = adc_pn_err_int; \n  always @(posedge adc_clk) begin \n  adc_valid_d <= adc_valid_in; \n  adc_pn_match_d <= adc_pn_match_d_s; \n  adc_pn_match_z <= adc_pn_match_z_s; \n  if (adc_valid_d == 1'b1) begin \n  adc_pn_err_int <= adc_pn_err_s; \n  if ((adc_pn_update_s == 1'b1) && (adc_pn_oos_count >= 15)) begin \n  adc_pn_oos_int <= ~adc_pn_oos_int; \n  end \n  if (adc_pn_update_s == 1'b1) begin \n  adc_pn_oos_count <= adc_pn_oos_count + 1'b1; \n  end else begin \n  adc_pn_oos_count <= 'd0; \n  end \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a multiplexer (Mux8) with 8 input ports and a 3-bit select signal (sel). It selects one of the inputs (i0-i7) based on the value of sel and outputs the selected input through the output port (o). The module uses a case statement to assign the selected input to a register (reg_o) based on the value of sel, and then assigns reg_o to the output port o.\n\n Module header:\n\nmodule Mux8(sel, i0, i1, i2, i3, i4, i5, i6, i7, o);\n [/INST]\n", "output": "parameter data_width = 8; \n  input[2 : 0] sel; \n  input[data_width - 1 : 0] i0; \n  input[data_width - 1 : 0] i1; \n  input[data_width - 1 : 0] i2; \n  input[data_width - 1 : 0] i3; \n  input[data_width - 1 : 0] i4; \n  input[data_width - 1 : 0] i5; \n  input[data_width - 1 : 0] i6; \n  input[data_width - 1 : 0] i7; \n  output[data_width - 1 : 0] o; \n  reg[data_width - 1 : 0] reg_o; \n  always @(*) begin \n  case (sel) \n  0 : reg_o <= i0; \n  1 : reg_o <= i1; \n  2 : reg_o <= i2; \n  3 : reg_o <= i3; \n  4 : reg_o <= i4; \n  5 : reg_o <= i5; \n  6 : reg_o <= i6; \n  7 : reg_o <= i7; \n  default : ; \n  endcase \n  end \n  assign o = reg_o; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements the sine and cosine functions using look-up tables. It takes a 16-bit input and calculates the sine and cosine values based on the input. The module includes memory blocks to store pre-calculated values, and uses these values to compute the sine and cosine values based on the input. The output signals g0 and g1 represent the calculated sine and cosine values, respectively, based on the input value u1. The module includes a case statement to determine the appropriate quadrant for the input value and calculates the sine and cosine values accordingly.\n\n Module header:\n\nmodule sincos(u1, g0,g1);\n [/INST]\n", "output": "input [15:0] u1; \n  output reg signed [15:0] g0; \n  output reg signed [15:0] g1; \n  reg [1:0] quad; \n  reg [13:0] x_g_a; \n  reg [13:0] x_g_b; \n  reg [6:0] address; \n  reg [15:0] y_g_a; \n  reg [15:0] y_g_b; \n  reg [33:0] temp1; \n  reg [33:0] temp2; \n  reg [18:0] c0[127:0]; \n  reg [18:0] c1[127:0]; \n initial \n  begin \n  $readmemh(\"c0_sincos.txt\", c0); \n  $readmemh(\"c1_sincos.txt\", c1); \n  end \n always@(u1 ) \n  begin \n  quad=u1[15:14]; \n  x_g_a=u1[13:0]; \n  x_g_b=(1-2^-14)- u1[13:0]; \n  address=u1[15:8]; \n  temp1=c1[address]*x_g_a; \n  temp2=c1[address]*x_g_b; \n  y_g_a=temp1+ c0[address]; \n  y_g_b=temp2+ c0[address]; \n  case(quad) \n  0: \n  begin \n  g0= y_g_b; \n  g1= y_g_a; \n  end \n  1: \n  begin \n  g0= y_g_a; \n  g1= -y_g_b; \n  end \n  2: \n  begin \n  g0= -y_g_b; \n  g1= -y_g_a; \n  end \n  3: \n  begin \n  g0= -y_g_a; \n  g1= y_g_b; \n  end \n  endcase; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module implements a full asynchronous FIFO write pointer with a configurable address size. It uses Gray code to generate the write pointer address and checks if the FIFO is full. The module's main functionality is to increment the write pointer when the FIFO is not full and update the wfull signal accordingly.\n\n Module header:\n\nmodule wptr_full #(parameter ADDRSIZE = 2) (output reg wfull,output wire [ADDRSIZE-1:0] waddr,output reg [ADDRSIZE :0] wptr,input wire [ADDRSIZE :0] wq2_rptr,input wire winc, wclk, wrst);\n [/INST]\n", "output": "reg [ADDRSIZE:0] wbin; \n wire [ADDRSIZE:0] wgraynext, wbinnext; \n always @(posedge wclk) \n  if (wrst) {wbin, wptr} <= 0; \n  else {wbin, wptr} <= {wbinnext, wgraynext}; \n assign waddr = wbin[ADDRSIZE-1:0]; \n assign wbinnext = wbin + (winc & ~wfull); \n assign wgraynext = (wbinnext>>1) ^ wbinnext; \n wire wfull_val; \n assign wfull_val = (wgraynext=={~wq2_rptr[ADDRSIZE:ADDRSIZE-1], wq2_rptr[ADDRSIZE-2:0]}); \n always @(posedge wclk) \n  if (wrst) wfull <= 1'b0; \n  else wfull <= wfull_val; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is called \"mgc_inout_stdreg_en\" and it has input and output ports to control the loading and output of data. It has parameters \"rscid\" and \"width\" set to 1 and 8 respectively. When the \"ldin\" signal is high, the \"din\" output is set to the value of the \"z\" input. When \"ldin\" is low, \"din\" is set to all high-impedance \"z\" values. The \"lzin\" output reflects the state of the \"ldin\" input. \"lzout\" reflects the state of the \"ldout\" input. The \"z\" inout signal is connected to \"dout\" when \"ldout\" is high, and set to high-impedance values when \"ldout\" is low.\n\n Module header:\n\nmodule mgc_inout_stdreg_en (ldin, din, ldout, dout, lzin, lzout, z);\n [/INST]\n", "output": "parameter integer rscid = 1; \n  parameter integer width = 8; \n  input ldin; \n  output [width-1:0] din; \n  input ldout; \n  input [width-1:0] dout; \n  output lzin; \n  output lzout; \n  inout [width-1:0] z; \n  wire [width-1:0] din; \n  wire lzin; \n  wire lzout; \n  wire [width-1:0] z; \n  assign lzin = ldin; \n  assign din = ldin ? z : {width{1'bz}}; \n  assign lzout = ldout; \n  assign z = ldout ? dout : {width{1'bz}}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, \"pc_bus_to_vga,\" includes burst address, write data, read data, read enable, read data valid, byte enable, and wait request converters. These converters handle the conversion of signals between the PC bus and the VGA memory. The burst_converter instantiates the conversion of burst-related signals, and the byteen_converter handles the conversion of byte enable signals. Additionally, the module includes a reg for VGA memory read data valid and an always block to update it on the positive edge of the system clock.\n\n Module header:\n\nmodule pc_bus_to_vga (input wire clk_sys,input wire rst,input wire [31:0] pc_bus_vga_address,input wire [3:0] pc_bus_vga_byteenable,input wire pc_bus_vga_read,output wire [31:0] pc_bus_vga_readdata,input wire pc_bus_vga_write,input wire [31:0] pc_bus_vga_writedata,output wire pc_bus_vga_waitrequest,output wire pc_bus_vga_readdatavalid,input wire [2:0] pc_bus_vga_burstcount,output wire [16:0] vga_mem_address,output wire vga_mem_read,input wire [7:0] vga_mem_readdata,output wire vga_mem_write,output wire [7:0] vga_mem_writedata);\n [/INST]\n", "output": "wire [31:0] burst_converted_address; \n  wire burst_converted_write; \n  wire [31:0] burst_converted_writedata; \n  wire burst_converted_read; \n  wire [31:0] burst_converted_readdata; \n  wire burst_converted_readdatavalid; \n  wire [3:0] burst_converted_byteenable; \n  wire burst_converted_waitrequest; \n  burst_converter #(.IADDR(32), .OADDR(32)) \n burst_converter (.clk_sys (clk_sys),.rst (rst),.addr_in (pc_bus_vga_address),.write_in (pc_bus_vga_write),.writedata_in (pc_bus_vga_writedata),.read_in (pc_bus_vga_read),.readdata_out (pc_bus_vga_readdata),.readdatavalid_out (pc_bus_vga_readdatavalid),.byteenable_in (pc_bus_vga_byteenable),.burstcount_in (pc_bus_vga_burstcount),.waitrequest_out (pc_bus_vga_waitrequest),.addr_out (burst_converted_address),.write_out (burst_converted_write),.writedata_out (burst_converted_writedata),.read_out (burst_converted_read),.readdata_in (burst_converted_readdata),.readdatavalid_in (burst_converted_readdatavalid),.byteenable_out (burst_converted_byteenable),.waitrequest_in (burst_converted_waitrequest)); \n  reg vga_mem_readdatavalid; \n  always @(posedge clk_sys) vga_mem_readdatavalid <= vga_mem_read; \n  byteen_converter #(.IADDR(32), .OADDR(17)) \n byteen_converter (.clk_sys (clk_sys),.rst (rst),.addr_in (burst_converted_address),.write_in (burst_converted_write),.writedata_in (burst_converted_writedata),.read_in (burst_converted_read),.readdata_out (burst_converted_readdata),.readdatavalid_out (burst_converted_readdatavalid),.byteenable_in (burst_converted_byteenable),.waitrequest_out (burst_converted_waitrequest),.addr_out (vga_mem_address),.write_out (vga_mem_write),.writedata_out (vga_mem_writedata),.read_out (vga_mem_read),.readdata_in (vga_mem_readdata),.readdatavalid_in (vga_mem_readdatavalid),.waitrequest_in (0)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module named \"pixels_lost_test\" simulates a test environment for the \"pixels_lost\" module, which takes in coordinates x1, y1, x2, y2, x3, y3, x4, y4 and calculates the percentage of pixels lost when forming a rectangular shape. The \"pixels_lost_test\" module initializes the coordinates and a clock signal, and instantiates the \"pixels_lost\" module. It toggles the clock and displays the coordinates and the calculated percentage of pixels lost at every clock edge.\n\n Module header:\n\nmodule pixels_lost_test;\n [/INST]\n", "output": "reg[9:0] x1; \n reg[8:0] y1; \n reg[9:0] x2; \n reg[8:0] y2; \n reg[9:0] x3; \n reg[8:0] y3; \n reg[9:0] x4; \n reg[8:0] y4; \n wire[6:0] percent_lost; \n initial begin \n x1 = 10'd80; \n y1 = 9'd80; \n x2 = 10'd80; \n y2 = 9'd160; \n x3 = 10'd160; \n y3 = 9'd160; \n x4 = 10'd160; \n y4 = 9'd80; \n end \n reg clock = 0; \n pixels_lost pixels_lost(clock, x1, y1, x2, y2, x3, y3, x4, y4, percent_lost); \n always #1 clock <= !clock; \n always @(posedge clock) begin \n $display(\"%d, %d, %d, %d, %d, %d, %d, %d, %d\", x1, y1, x2, y2, x3, y3, x4, y4, percent_lost); \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a simple UART receiver with a configurable FIFO depth. It samples the incoming serial data on the rx input, synchronizes it to the clock, and then uses a baud rate counter to sample each bit of the incoming character. When a complete character has been received, it stores the data in a shift register and writes it to the FIFO. The FIFO has its own logic for managing write and read pointers, as well as for reporting its occupancy status. This allows the received characters to be stored and read in an orderly manner.\n\n Module header:\n\nmodule simple_uart_rx #(parameter DEPTH=0) (input clk, input rst,output [7:0] fifo_out, input fifo_read, output [7:0] fifo_level, output fifo_empty,input [15:0] clkdiv, input rx);\n [/INST]\n", "output": "reg rx_d1, rx_d2; \n  always @(posedge clk) \n  if(rst) \n  {rx_d2,rx_d1} <= 0; \n  else \n  {rx_d2,rx_d1} <= {rx_d1,rx}; \n  reg [15:0] baud_ctr; \n  reg [3:0] bit_ctr; \n  reg [7:0] sr; \n  wire neg_trans = rx_d2 & ~rx_d1; \n  wire shift_now = baud_ctr == (clkdiv>>1); \n  wire stop_now = (bit_ctr == 10) && shift_now; \n  wire go_now = (bit_ctr == 0) && neg_trans; \n  always @(posedge clk) \n  if(rst) \n  sr <= 0; \n  else if(shift_now) \n  sr <= {rx_d2,sr[7:1]}; \n  always @(posedge clk) \n  if(rst) \n  baud_ctr <= 0; \n  else \n  if(go_now) \n  baud_ctr <= 1; \n  else if(stop_now) \n  baud_ctr <= 0; \n  else if(baud_ctr >= clkdiv) \n  baud_ctr <= 1; \n  else if(baud_ctr != 0) \n  baud_ctr <= baud_ctr + 1; \n  always @(posedge clk) \n  if(rst) \n  bit_ctr <= 0; \n  else \n  if(go_now) \n  bit_ctr <= 1; \n  else if(stop_now) \n  bit_ctr <= 0; \n  else if(baud_ctr == clkdiv) \n  bit_ctr <= bit_ctr + 1; \n  wire full; \n  wire write = ~full & rx_d2 & stop_now; \n  medfifo #(.WIDTH(8),.DEPTH(DEPTH)) fifo \n (.clk(clk),.rst(rst),.datain(sr),.write(write),.full(full),.dataout(fifo_out),.read(fifo_read),.empty(fifo_empty),.clear(0),.space(),.occupied(fifo_level) ); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a state machine that controls the busy state and delays the handling of input signals based on certain conditions. It has inputs for CLK, nRST, request$say__ENA, request$say$v, indication$heard__RDY, and indication$heard$v. Outputs include request$say__RDY, indication$heard__ENA, RULE$delay_rule__ENA, and RULE$delay_rule__RDY.\n\nThe module uses a set of registers to store the busy state, delay values, and temporary values. It also defines wire signals for delay rule enable and ready. The module then uses a clocked always block to update the state and perform the necessary operations based on the input signals and internal conditions.\n\nThe module's functionality includes setting the ready signal for request$say, enabling the indication$heard signal, and implementing a delay rule based on the busy state and other conditions. The state transitions are based on the input signals and internal state, controlling the busy state and delaying the handling of input signals.\n\n Module header:\n\nmodule Example1 (input wire CLK, input wire nRST,input wire request$say__ENA,input wire [31:0]request$say$v,output wire request$say__RDY,output wire indication$heard__ENA,output wire [31:0]indication$heard$v,input wire indication$heard__RDY);\n [/INST]\n", "output": "reg busy; \n  reg [1:0]busy_delay; \n  reg [31:0]v_delay; \n  reg [31:0]v_temp; \n  wire RULE$delay_rule__ENA; \n  wire RULE$delay_rule__RDY; \n  assign indication$heard$v = v_delay; \n  assign indication$heard__ENA = busy_delay == 2'd2; \n  assign request$say__RDY = !busy; \n  assign RULE$delay_rule__ENA = ( busy && ( busy_delay == 2'd0 ) ) != 0; \n  assign RULE$delay_rule__RDY = ( busy && ( busy_delay == 2'd0 ) ) != 0; \n  always @( posedge CLK) begin \n  if (!nRST) begin \n  busy <= 0; \n  busy_delay <= 0; \n  v_delay <= 0; \n  v_temp <= 0; \n  end \n  else begin \n  if (busy_delay == 2'd1) begin \n  busy_delay <= 2; \n  if (v_delay == 1) \n  busy <= 0; \n  end; \n  if (RULE$delay_rule__ENA & RULE$delay_rule__RDY) begin \n  busy_delay <= 1; \n  v_delay <= v_temp; \n  end; \n  if (( busy_delay == 2'd2 ) & indication$heard__RDY) begin \n  busy_delay <= 0; \n  if (v_delay != 1) \n  busy <= 0; \n  end; \n  if (!( busy | ( !request$say__ENA ) )) begin \n  v_temp <= request$say$v; \n  busy <= 1; \n  end; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module has a single output Z, which is always assigned a logic value of 0.\n\n Module header:\n\nmodule VLO(output Z);\n [/INST]\n", "output": "assign Z = 1'b0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a positive-edge triggered D flip-flop with preset and clear capabilities. The output q is set to 0 initially. The flip-flop responds to the positive edge of the clock signal and the preset (pre) and clear (clr) signals. When the preset signal is asserted, the output q is set to 1. When the clear signal is asserted, the output q is cleared to 0. When the enable signal (en) is high, the output q is updated with the input d on the positive clock edge.\n\n Module header:\n\nmodule my_dffsre_ppp (input d,clk,pre,clr,en,output reg q);\n [/INST]\n", "output": "initial q <= 1'b0; \n  always @(posedge clk or posedge pre or posedge clr) \n  if (pre) q <= 1'b1; \n  else if (clr) q <= 1'b0; \n  else if (en) q <= d; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a timer that interfaces with a flex counter and logic gates to control the shift_enable and byte_received signals. The flex counters are used to generate the rollover and count signals based on the input clock and reset signals. The logic gates, including inverters, NAND, and NOR gates, are used to combine and manipulate the signals from the flex counters and the rcving signal to generate the shift_enable and fullbyte signals. The fullbyte signal represents the reception of a complete byte, and it is assigned to the byte_received output.\n\n Module header:\n\nmodule timer ( clk, n_rst, d_edge, rcving, shift_enable, byte_received );\n [/INST]\n", "output": "input clk, n_rst, d_edge, rcving; \n  output shift_enable, byte_received; \n  wire fullbyte, _0_net_, n1, n2, n3, n4; \n  wire [3:0] igot; \n  assign byte_received = fullbyte; \n flex_counter_1 a0 ( .clk(clk), .n_rst(n_rst), .clear(d_edge), .count_enable(rcving), .rollover_val({1'b1, 1'b0, 1'b0, 1'b0}), .count_out(igot) ); \n flex_counter_0 a1 ( .clk(clk), .n_rst(n_rst), .clear(_0_net_),.count_enable(shift_enable), .rollover_val({1'b1, 1'b0, 1'b0, 1'b0}),.rollover_flag(fullbyte) ); \n  INVX1 U3 ( .A(n1), .Y(shift_enable) ); \n  NAND3X1 U4 ( .A(igot[1]), .B(n2), .C(n3), .Y(n1) ); \n  NOR2X1 U5 ( .A(igot[3]), .B(igot[2]), .Y(n3) ); \n  INVX1 U6 ( .A(igot[0]), .Y(n2) ); \n  NAND2X1 U7 ( .A(rcving), .B(n4), .Y(_0_net_) ); \n  INVX1 U8 ( .A(fullbyte), .Y(n4) ); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a simple counter that increments on each rising edge of the input clock signal. The output is set to the least significant bit of the counter.\n\n Module header:\n\nmodule middle (input clk,output out);\n [/INST]\n", "output": "reg [1:0] cnt = 0; \n  wire clk_int; \n  assign clk_int = clk; \n  always @(posedge clk_int) begin \n  cnt <= cnt + 1; \n  end \n  assign out = cnt[0]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a D flip-flop with asynchronous set and reset. It updates the output Q on the positive edge of the clock signal C based on the input D. Additionally, it includes timing constraints for different ICE40 FPGA families to ensure proper functionality.\n\n Module header:\n\nmodule SB_DFF (output reg Q,input C, D);\n [/INST]\n", "output": "`SB_DFF_INIT \n  always @(posedge C) \n  Q <= D; \n `ifdef ICE40_HX \n  specify \n  $setup(D, posedge C, 470 - 449); \n  (posedge C => (Q : D)) = 540; \n  endspecify \n `endif \n `ifdef ICE40_LP \n  specify \n  $setup(D, posedge C, 693 - 662); \n  (posedge C => (Q : D)) = 796; \n  endspecify \n `endif \n `ifdef ICE40_U \n  specify \n  $setup(D, posedge C, 0); \n  (posedge C => (Q : D)) = 1391; \n  endspecify \n `endif \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements an ADPCM accumulator with a parallel-to-serial converter. The input pcm_in is sign-extended when en_sum is asserted, and then processed through several steps to calculate the difference and an extended step value. \n\nThe accumulator and other internal registers are updated based on the input conditions, and the pcm_out is generated based on the calculated pcm_full value and an overflow flag. The module also handles reset conditions for registers and provides the necessary control logic for accumulation and output generation.\n\n Module header:\n\nmodule jt10_adpcm_acc(input rst_n,input clk,input cen,input [5:0] cur_ch,input [5:0] en_ch,input match,input en_sum,input signed [15:0] pcm_in,output reg signed [15:0] pcm_out);\n [/INST]\n", "output": "wire signed [17:0] pcm_in_long = en_sum ? { {2{pcm_in[15]}}, pcm_in } : 18'd0; \n reg signed [17:0] acc, last, pcm_full; \n reg signed [17:0] step; \n reg signed [17:0] diff; \n reg signed [22:0] diff_ext, step_full; \n always @(*) begin \n  diff = acc-last; \n  diff_ext = { {5{diff[17]}}, diff }; \n  step_full = diff_ext \n  + ( diff_ext << 1 ) \n  + ( diff_ext << 3 ) \n  + ( diff_ext << 5 ); \n end \n wire adv = en_ch[0] & cur_ch[0]; \n always @(posedge clk or negedge rst_n) \n  if( !rst_n ) begin \n  step <= 'd0; \n  acc <= 18'd0; \n  last <= 18'd0; \n  end else if(cen) begin \n  if( match ) \n  acc <= cur_ch[0] ? pcm_in_long : ( pcm_in_long + acc ); \n  if( adv ) begin \n  step <= { {2{step_full[22]}}, step_full[22:7] }; \n  last <= acc; \n  end \n  end \n wire overflow = |pcm_full[17:15] & ~&pcm_full[17:15]; \n always @(posedge clk or negedge rst_n) \n  if( !rst_n ) begin \n  pcm_full <= 18'd0; \n  end else if(cen && cur_ch[0]) begin \n  case( en_ch ) \n  6'b000_001: pcm_full <= last; \n  6'b000_100, \n  6'b010_000: pcm_full <= pcm_full + step; \n  default:; \n  endcase \n  if( overflow ) \n  pcm_out <= pcm_full[17] ? 16'h8000 : 16'h7fff; \n  else \n  pcm_out <= pcm_full[15:0]; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module represents a clock control system for a DE1-SoC board. It generates a CPU clock signal based on the input CLOCK2_50 and controls its frequency. The module uses a CPU clock counter to toggle the CPU clock after a specific count. It also interfaces with the DE1-SoC board's peripherals such as GPIO, HEX displays, keys, LEDs, and switches. The CPU clock signal is used to drive a core component, and the state of the CPU clock is indicated on LEDR[8].\n\n Module header:\n\nmodule de1_soc_proc(input CLOCK2_50,input CLOCK3_50,input CLOCK4_50,input CLOCK_50,inout [35:0] GPIO_0,output [6:0] HEX0,output [6:0] HEX1,output [6:0] HEX2,output [6:0] HEX3,output [6:0] HEX4,output [6:0] HEX5,input [3:0] KEY,output [9:0] LEDR,input [9:0] SW);\n [/INST]\n", "output": "reg rCPU_CLK = 1; \n integer dCPU_CLK_CNTR = 0; \n assign LEDR[8] = rCPU_CLK; \n always@(posedge CLOCK2_50) \n begin \n  if(dCPU_CLK_CNTR == 250000) begin \n  dCPU_CLK_CNTR <= 0; \n  rCPU_CLK <= ~rCPU_CLK; \n  end \n  else begin \n  dCPU_CLK_CNTR <= dCPU_CLK_CNTR + 1; \n  end \n end \n core core(.iCLK(rCPU_CLK),.iGPI(SW[7:0]),.oGPO(LEDR[7:0])); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a simple UART (Universal Asynchronous Receiver/Transmitter). It has input and output signals for clock, reset, transmit data (ser_tx), receive data (ser_rx), control signals for setting the divider and data registers, and the respective data in and data out signals. \n\nThe module uses several internal registers to handle the configuration of the UART, including the divider and receive state. It also handles the reception of serial data and transmission of data based on the configured parameters. The module is synchronous, with actions triggered by the rising edge of the clock signal and the reset signal.\n\n Module header:\n\nmodule simpleuart (input clk,input resetn,output ser_tx,input ser_rx,input [ 3:0] reg_div_we,input [31:0] reg_div_di,output [31:0] reg_div_do,input reg_dat_we,input reg_dat_re,input [31:0] reg_dat_di,output [31:0] reg_dat_do,output reg_dat_wait);\n [/INST]\n", "output": "reg [31:0] cfg_divider; \n  reg [3:0] recv_state; \n  reg [31:0] recv_divcnt; \n  reg [7:0] recv_pattern; \n  reg [7:0] recv_buf_data; \n  reg recv_buf_valid; \n  reg [9:0] send_pattern; \n  reg [3:0] send_bitcnt; \n  reg [31:0] send_divcnt; \n  reg send_dummy; \n  assign reg_div_do = cfg_divider; \n  assign reg_dat_wait = reg_dat_we && (send_bitcnt || send_dummy); \n  assign reg_dat_do = recv_buf_valid ? recv_buf_data : ~0; \n  always @(posedge clk) begin \n  if (!resetn) begin \n  cfg_divider <= 1; \n  end else begin \n  if (reg_div_we[0]) cfg_divider[7:0] <= reg_div_di[7:0]; \n  if (reg_div_we[1]) cfg_divider[15:8] <= reg_div_di[15:8]; \n  if (reg_div_we[2]) cfg_divider[23:16] <= reg_div_di[23:16]; \n  if (reg_div_we[3]) cfg_divider[31:24] <= reg_div_di[31:24]; \n  end \n  end \n  always @(posedge clk) begin \n  if (!resetn) begin \n  recv_state <= 0; \n  recv_divcnt <= 0; \n  recv_pattern <= 0; \n  recv_buf_data <= 0; \n  recv_buf_valid <= 0; \n  end else begin \n  recv_divcnt <= recv_divcnt + 1; \n  if (reg_dat_re) recv_buf_valid <= 0; \n  case (recv_state) \n  0: begin \n  if (!ser_rx) recv_state <= 1; \n  recv_divcnt <= 0; \n  end \n  1: begin \n  if (2 * recv_divcnt > cfg_divider) begin \n  recv_state <= 2; \n  recv_divcnt <= 0; \n  end \n  end \n  10: begin \n  if (recv_divcnt > cfg_divider) begin \n  recv_buf_data <= recv_pattern; \n  recv_buf_valid <= 1; \n  recv_state <= 0; \n  end \n  end \n  default: begin \n  if (recv_divcnt > cfg_divider) begin \n  recv_pattern <= {ser_rx, recv_pattern[7:1]}; \n  recv_state <= recv_state + 1; \n  recv_divcnt <= 0; \n  end \n  end \n  endcase \n  end \n  end \n  assign ser_tx = send_pattern[0]; \n  always @(posedge clk) begin \n  if (reg_div_we) send_dummy <= 1; \n  send_divcnt <= send_divcnt + 1; \n  if (!resetn) begin \n  send_pattern <= ~0; \n  send_bitcnt <= 0; \n  send_divcnt <= 0; \n  send_dummy <= 1; \n  end else begin \n  if (send_dummy && !send_bitcnt) begin \n  send_pattern <= ~0; \n  send_bitcnt <= 15; \n  send_divcnt <= 0; \n  send_dummy <= 0; \n  end else if (reg_dat_we && !send_bitcnt) begin \n  send_pattern <= {1'b1, reg_dat_di[7:0], 1'b0}; \n  send_bitcnt <= 10; \n  send_divcnt <= 0; \n  end else if (send_divcnt > cfg_divider && send_bitcnt) begin \n  send_pattern <= {1'b1, send_pattern[9:1]}; \n  send_bitcnt <= send_bitcnt - 1; \n  send_divcnt <= 0; \n  end \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements an 8-bit register with input 'val', clock 'clk', and output enable 'oe'. The 'bufif0' primitive drives the output 'out' based on the register value 'Q' and the output enable 'oe'. The register value 'Q' is updated with the input 'val' on the positive edge of the clock 'clk'.\n\n Module header:\n\nmodule register (out, val, clk, oe);\n [/INST]\n", "output": "output [7:0] out; \n  input [7:0] val; \n  input clk, oe; \n  reg [7:0] Q; \n  wire [7:0] out; \n  bufif0 drv[7:0](out, Q, oe); \n  always @(posedge clk) Q = val; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module \"GP_VSS\" simply assigns a constant value of 0 to its output \"OUT\".\n\n Module header:\n\nmodule GP_VSS(output OUT);\n [/INST]\n", "output": "assign OUT = 0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a test bench for a system that includes a clock signal, an instruction register, input signals, a serial clock module, and a finite state machine. The test bench initializes the clock signal, sets the initial instruction input, and then changes the instruction input after a certain number of clock cycles. The purpose of this test bench is to verify the functionality of the finite state machine with different sets of input instructions over time.\n\n Module header:\n\nmodule testStateMachine;\n [/INST]\n", "output": "reg clk; \n reg[9:0] instr; \n wire cs, dc, delayEn, sclk, sclkPosEdge, sclkNegEdge; \n wire[7:0] parallelData; \n serialClock #(2) sc(clk, sclk, sclkPosEdge, sclkNegEdge); \n finiteStateMachine fsm(clk, sclkPosEdge, instr, cs, dc, delayEn, parallelData); \n initial clk = 0; \n always #5 clk=!clk; \n initial begin \n instr = 10'b0010101010; \n #600 \n instr = 10'b0100110011; \n #600 \n instr = 10'b1010110110; \n #600 \n instr = 10'b0010101010; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a register-based random access memory (RAM) with a specified memory size and number of bits. It has write and read capabilities, with the ability to write data to a specific address when the write enable signal is asserted, and to read data from a specific address. Additionally, it outputs the data and integer at a specified integral address. The RAM is implemented using a register array, and the writing and reading operations are synchronized with the clock signal.\n\n Module header:\n\nmodule reg_ram (clk, we, w_addr, r_addr, integral_addr, d_in, d_out, d_out_int);\n [/INST]\n", "output": "parameter MEM_SIZE = 76800; \n  parameter BITS = 17; \n  input clk; \n  input we; \n  input [16:0] w_addr; \n  input [BITS-1:0] d_in; \n  input [16:0] r_addr; \n  input [16:0] integral_addr; \n  output reg [BITS-1:0] d_out; \n  output reg [BITS-1:0] d_out_int; \n  reg [BITS-1:0] ram [MEM_SIZE-1:0]; \n  always @(posedge clk) begin \n  if (we) \n  ram[w_addr] <= d_in; \n  d_out <= ram[r_addr]; \n  d_out_int <= ram[integral_addr]; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a set of logic functions and signal assignments for a digital design. It uses various inputs to generate outputs such as prst_1, hb_ca_rdy, de_ca_rdy, ps16s_2, ps565s_2, de_sorg_2, de_dorg_2, sorg_2, dorg_2, and or_apat_1. The module contains logical gates such as OR gate for or_apat_1, pulse trigger for prst_1, logical AND and NOT gates for ps16s_2 and ps565s_2, and signal selections for de_sorg_2, de_dorg_2, sorg_2, and dorg_2. These logical functions and signal assignments help in generating the required outputs based on the given inputs and internal signals.\n\n Module header:\n\nmodule der_misc (input de_clk,input hb_clk,input prst,input cr_pulse,input [1:0] ps_sel_2,input bc_co,input [31:0] mf_sorg_2,input [31:0] mf_dorg_2,input [1:0] apat_1,input sd_selector,output reg prst_1,output hb_ca_rdy,output de_ca_rdy,output ps16s_2,output ps565s_2,output [31:0] de_sorg_2,output [31:0] de_dorg_2,output [27:0] sorg_2,output [27:0] dorg_2,output or_apat_1);\n [/INST]\n", "output": "assign or_apat_1 = |apat_1; \n  always @(posedge de_clk) prst_1 <= prst; \n  assign ps16s_2 = ~ps_sel_2[1] & ps_sel_2[0]; \n  assign ps565s_2 = &ps_sel_2[1:0]; \n  assign hb_ca_rdy = 1'b1; \n  assign de_ca_rdy = 1'b1; \n  assign de_sorg_2 = {32{sd_selector}} & mf_sorg_2; \n  assign de_dorg_2 = {32{sd_selector}} & mf_dorg_2; \n  assign sorg_2 = {28{~sd_selector}} & {6'h0, mf_sorg_2[25:4]}; \n  assign dorg_2 = {28{~sd_selector}} & {6'h0, mf_dorg_2[25:4]}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe module encodes the control signals for a processor. The \"Run\" output is always high. The \"R1in\" output is set to the least significant bit of the input \"T\". The \"R1out\" output is set to the third bit of the input \"T\". The \"R2in\" output is the sum of the fourth and first bits of the input \"T\". The \"R2out\" output is set to the third bit of the input \"T\". The outputs \"Add\", \"Sub\", \"Mul\", and \"Div\" depend on the third bit of the input \"T\" and the four-bit control signal \"Ins\". The \"SelectY\" output is set to the third bit of the input \"T\". The \"Zin\" output is set to the third bit of the input \"T\". The \"Zout\" output is set to the fourth bit of the input \"T\". The \"Yin\" output is set to the second bit of the input \"T\". The \"End\" output is set to the fifth bit of the input \"T\".\n\n Module header:\n\nmodule Encoder( output Run,output R1in, output R1out,output R2in, output R2out,output Add, output Sub, output Mul, output Div,output SelectY, output Yin,output Zin, output Zout,output End,input [15:0] T, input [3:0] Ins);\n [/INST]\n", "output": "assign Run = 1; \n  assign R1in = T[0]; \n  assign R1out = T[2]; \n  assign R2in = T[4] + T[1]; \n  assign R2out = T[3]; \n  assign Add = T[3] & Ins[0] ; \n  assign Sub = T[3] & Ins[1]; \n  assign Mul = T[3] & Ins[2]; \n  assign Div = T[3] & Ins[3]; \n  assign SelectY = T[3]; \n  assign Zin = T[3]; \n  assign Zout = T[4]; \n  assign Yin = T[2]; \n  assign End = T[5]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a square root calculation circuit. It takes inputs e, g0_, g1_, and quad_, and produces outputs f, g0, g1, and quad. Upon the rising edge of the clock signal, it performs a series of computations based on the input e and sets the values of f, g0, g1, and quad accordingly. The circuit uses registers and performs operations such as shifting, comparisons, and additions to calculate the square root.\n\n Module header:\n\nmodule sqrt(e, f, clk, g0_, g1_, g0, g1, quad_, quad);\n [/INST]\n", "output": "input [30:0]e; input [15:0]g0_, g1_; input [1:0]quad_; \n input clk; \n output [16:0]f; reg [16:0]f; output [15:0]g0, g1; reg [15:0]g0, g1; output [1:0]quad; reg [1:0]quad; \n reg [5:0]lzd_e; \n reg [30:0]x_f_, x_f; \n reg [41:0]y_f1, y_f2, y_f; \n reg [15:0]c_1, c_2; \n integer i; \n always@(posedge clk) \n begin \n i = 30; \n while(i>=0) \n begin \n if(e[i] == 1'b1) \n begin \n lzd_e = 30 - i; \n i = 0; \n end \n i = i-1; \n end \n if(lzd_e > 5) \n lzd_e = 5; \n lzd_e = 5 - lzd_e; \n x_f_ = e >> lzd_e; \n if((x_f_[25] == 0)&&(x_f_[24] == 0)) \n x_f_[25] = 1; \n x_f = x_f_; \n c_1 = 16'b0101001011101111; \n c_2 = 16'b1011101111000001; \n y_f1 = c_1*x_f; \n y_f2[41:40] = 0; \n y_f2[39:24] = c_2[15:0]; \n y_f2[23:0] = 0; \n y_f = y_f1 + y_f2; \n if(lzd_e[0] == 1) \n lzd_e = lzd_e + 1; \n f[16:0] = y_f[41:25]; \n f = f << lzd_e; \n g0 = g0_; \n g1 = g1_; \n quad = quad_; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `seven_segment_display_x_4` implements a multiplexed four-digit seven-segment display driver. It takes in BCD input along with decimal point control signals and a clock signal. The module generates the appropriate segment patterns for the common anode display based on the BCD input and cycles through each digit sequentially. It also controls the decimal points for each digit. The module uses a clock divider to create a counter for multiplexing the display, and it includes logic to increment the counter and generate the appropriate segment patterns based on the current digit.\n\n Module header:\n\nmodule seven_segment_display_x_4(input [15:0] bcd_in,input [3:0] decimal_points,input clk,output reg [6:0] a_to_g,output reg decimal_point,output reg [3:0] anode);\n [/INST]\n", "output": "wire [1:0] counter; \n reg [3:0] digit; \n reg [19:0] clkdiv; \n assign counter = clkdiv[19:18]; \n always @(posedge clk) \n  case(counter) \n  0: {digit, decimal_point, anode} = {bcd_in[3:0], ~decimal_points[0], 4'b1110}; \n  1: {digit, decimal_point, anode} = {bcd_in[7:4], ~decimal_points[1], 4'b1101}; \n  2: {digit, decimal_point, anode} = {bcd_in[11:8], ~decimal_points[2], 4'b1011}; \n  3: {digit, decimal_point, anode} = {bcd_in[15:12], ~decimal_points[3],4'b0111}; \n  endcase \n always @(posedge clk) \n  case(digit) \n  0: a_to_g = 8'b1000000; \n  1: a_to_g = 8'b1111001; \n  2: a_to_g = 8'b0100100; \n  3: a_to_g = 8'b0110000; \n  4: a_to_g = 8'b0011001; \n  5: a_to_g = 8'b0010010; \n  6: a_to_g = 8'b0000010; \n  7: a_to_g = 8'b1111000; \n  8: a_to_g = 8'b0000000; \n  9: a_to_g = 8'b0010000; \n  default: a_to_g = 8'b11111111; \n  endcase \n always @ (posedge clk) \n  begin \n  clkdiv <= clkdiv + 20'b1; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a 3-input NAND gate. It takes inputs A, B, and C, and outputs the negation of the logical AND of these inputs as Y. This means the output Y will be high (1) only if all three inputs are low (0), otherwise, the output will be low (0).\n\n Module header:\n\nmodule NAND3 (input A, B, C,output Y);\n [/INST]\n", "output": "assign Y = !(A & B & C); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a frequency meter by dividing an input clock signal and counting the number of clock cycles. It uses a 7-bit counter to divide the input clock signal and a 16-bit counter to measure the frequency. The module also performs binary-to-BCD conversion to output the frequency in BCD format. The frequency measurement is synchronized to the clock signal and resets when a reset signal is asserted.\n\n Module header:\n\nmodule freqmeter ( input rst ,input clk_50 ,input clk_ref ,output [15:0] frq_bcd);\n [/INST]\n", "output": "reg clk_div; \n  reg [6:0] ccnt; \n  always @(posedge clk_ref) \n  if (ccnt==7'd99) {ccnt,clk_div} <= {7'd0,!clk_div}; \n  else ccnt <= ccnt+1'b1; \n  localparam cntW = 16; \n  reg [cntW-1:0] cntR,cntF,cntR_,cntF_; \n  always @(posedge clk_50) \n  if (!clk_div) cntR <= 12'd0; \n  else cntR <= cntR+1'b1; \n  always @(negedge clk_50) \n  if (!clk_div) cntF <= 12'd0; \n  else cntF <= cntF+1'b1; \n  always @(negedge clk_div) \n  {cntR_,cntF_} <= {cntR,cntF}; \n  bin2bcd16 bin2bcd16_00 (cntR_+cntF_,frq_bcd); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a basic reset mechanism, where the output VAL is set to 0 when the input RST is asserted. The VAL is a register that holds its value until the next assertion of the reset signal.\n\n Module header:\n\nmodule ResetToBool (RST, VAL);\n [/INST]\n", "output": "input RST; \n output VAL; \n reg VAL; \n always @ (RST or VAL) \n begin \n if (RST == 1) \n VAL=1'b0; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a state machine that controls the behavior of a communication interface. It has various inputs such as rxd, StringReady, CharReady, parity, and check. It uses the clock signal clk_2 and a reset signal to control the state transitions and outputs several control signals. The module has states for idle, possible start, read, error, write, and stop. \n\nThe state machine's behavior is determined by the inputs and the current state. It can set the ready, error, WriteChar, WriteString, and PossibleStart output signals based on the current state and the input conditions. The state machine transitions through the states based on the current_state and next_state variables, and the behavior is defined for each state in the case statement. \n\nThe module is designed to handle communication and data transfer, and the state transitions and output signals are controlled based on the inputs and the state machine logic. The design is aimed at controlling the flow of data and signaling readiness and error conditions in the communication interface.\n\n Module header:\n\nmodule control_o (reset, rxd, StringReady, CharReady, parity, ready, error, WriteChar, WriteString, PossibleStart, clk_2, check);\n [/INST]\n", "output": "input rxd; \n  input StringReady; \n  input CharReady; \n  input parity; \n  input clk_2; \n  input check; \n  input reset; \n  output reg ready; \n  output reg error; \n  output reg WriteChar; \n  output reg WriteString; \n  output reg PossibleStart; \n  reg [2:0] current_state; \n  reg [2:0] next_state; \n  parameter IDLE = 3'b000; \n  parameter POSSIBLESTART = 3'b001; \n  parameter READ = 3'b010; \n  parameter ERROR = 3'b011; \n  parameter WRITE = 3'b100; \n  parameter STOP = 3'b101; \n  always @(current_state or rxd or check or CharReady or StringReady or reset or parity) begin \n  if (reset==1'b1) begin \n  next_state <= 3'b000; \n  ready =1'b0; \n  error = 1'b0; \n  WriteString = 1'b0; \n  WriteChar = 1'b0; \n  PossibleStart = 1'b0; \n  end \n  else begin \n  case (current_state) \n  IDLE: begin \n  if (rxd==1) \n  next_state<=IDLE; \n  else \n  next_state<=POSSIBLESTART; \n  ready=1'b0; \n  error=1'b0; \n  WriteChar=1'b0; \n  WriteString=1'b0; \n  PossibleStart=1'b0; \n  end \n  POSSIBLESTART: begin \n  if (check == 1) begin \n  if (rxd == 0) begin \n  next_state<=READ; \n  end \n  else \n  next_state<=IDLE; \n  end \n  else \n  next_state<=POSSIBLESTART; \n  ready=1'b0; \n  error=1'b0; \n  WriteChar=1'b0; \n  WriteString=1'b0; \n  PossibleStart=1'b1; \n  end \n  READ: begin \n  if (CharReady==0) \n  next_state<=READ; \n  else \n  next_state<=ERROR; \n  ready=1'b0; \n  error=1'b0; \n  WriteChar=1'b1; \n  WriteString=1'b0; \n  PossibleStart=1'b0; \n  end \n  ERROR: begin \n  next_state<=WRITE; \n  if (parity==1) \n  error=1'b1; \n  else \n  error=1'b0; \n  ready=1'b0; \n  WriteChar=1'b0; \n  WriteString=1'b0; \n  PossibleStart=1'b0; \n  end \n  WRITE: begin \n  if (StringReady==0) \n  next_state<=IDLE; \n  else \n  next_state<=STOP; \n  ready=1'b0; \n  error=1'b0; \n  WriteChar=1'b0; \n  WriteString=1'b1; \n  PossibleStart=1'b0; \n  end \n  STOP: begin \n  next_state<=IDLE; \n  ready=1'b1; \n  error=1'b0; \n  WriteChar=1'b0; \n  WriteString=1'b0; \n  PossibleStart=1'b0; \n  end \n  default: begin \n  next_state<=IDLE; \n  ready=1'b0; \n  error=1'b0; \n  WriteChar=1'b0; \n  WriteString=1'b0; \n  PossibleStart=1'b0; \n  end \n  endcase \n  end \n  end \n  always @(negedge clk_2 or posedge reset) begin \n  if (reset == 1'b1) begin \n  current_state<=IDLE; \n  end \n  else begin \n  current_state<=next_state; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module simulates a simple game where a ball bounces around the screen and interacts with a paddle. The module updates the positions and directions of the ball and the paddle based on the clock signal and input conditions. It also checks for collisions with the screen borders, paddle, and ball, and updates the colors of different elements on the screen. The module uses various registers and wires to manage the game logic and implement the game's behavior.\n\n Module header:\n\nmodule game(input clk,input [9:0] xpos,input [9:0] ypos,input rota,input rotb,output [2:0] red,output [2:0] green,output [1:0] blue);\n [/INST]\n", "output": "reg [8:0] paddlePosition; \n  reg [2:0] quadAr, quadBr; \n  always @(posedge clk) quadAr <= {quadAr[1:0], rota}; \n  always @(posedge clk) quadBr <= {quadBr[1:0], rotb}; \n  always @(posedge clk) \n  if(quadAr[2] ^ quadAr[1] ^ quadBr[2] ^ quadBr[1]) \n  begin \n  if(quadAr[2] ^ quadBr[1]) begin \n  if(paddlePosition < 508) \n  paddlePosition <= paddlePosition + 9'd4; \n  end \n  else begin \n  if(paddlePosition > 3) \n  paddlePosition <= paddlePosition - 9'd4; \n  end \n  end \n  reg [9:0] ballX; \n  reg [8:0] ballY; \n  reg ballXdir, ballYdir; \n  reg bounceX, bounceY; \n  wire endOfFrame = (xpos == 0 && ypos == 480); \n  always @(posedge clk) begin \n  if (endOfFrame) begin \n  if (ballX == 0 && ballY == 0) begin \n  ballX <= 480; \n  ballY <= 300; \n  end \n  else begin \n  if (ballXdir ^ bounceX) \n  ballX <= ballX + 10'd2; \n  else \n  ballX <= ballX - 10'd2; \n  if (ballYdir ^ bounceY) \n  ballY <= ballY + 9'd2; \n  else \n  ballY <= ballY - 9'd2; \n  end \n  end \n  end \n  reg [5:0] missTimer; \n  wire visible = (xpos < 640 && ypos < 480); \n  wire top = (visible && ypos <= 3); \n  wire bottom = (visible && ypos >= 476); \n  wire left = (visible && xpos <= 3); \n  wire right = (visible && xpos >= 636); \n  wire border = (visible && (left || right || top)); \n  wire paddle = (xpos >= paddlePosition+4 && xpos <= paddlePosition+124 && ypos >= 440 && ypos <= 447); \n  wire ball = (xpos >= ballX && xpos <= ballX+7 && ypos >= ballY && ypos <= ballY+7); \n  wire background = (visible && !(border || paddle || ball)); \n  wire checkerboard = (xpos[5] ^ ypos[5]); \n  wire missed = visible && missTimer != 0; \n  assign red = { missed || border || paddle, paddle, paddle}; \n  assign green = { !missed && (border || paddle || ball), ball, ball}; \n  assign blue = { !missed && (border || ball), background && checkerboard}; \n  always @(posedge clk) begin \n  if (!endOfFrame) begin \n  if (ball && (left || right)) \n  bounceX <= 1; \n  if (ball && (top || bottom || (paddle && ballYdir))) \n  bounceY <= 1; \n  if (ball && bottom) \n  missTimer <= 63; \n  end \n  else begin \n  if (ballX == 0 && ballY == 0) begin \n  ballXdir <= 1; \n  ballYdir <= 1; \n  bounceX <= 0; \n  bounceY <= 0; \n  end \n  else begin \n  if (bounceX) \n  ballXdir <= ~ballXdir; \n  if (bounceY) \n  ballYdir <= ~ballYdir; \n  bounceX <= 0; \n  bounceY <= 0; \n  if (missTimer != 0) \n  missTimer <= missTimer - 6'd1; \n  end \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a dual-port RAM with different behaviors based on the state and control signals. The module includes state transitions based on the clock signal, `whichturn` control signal, memory request (`mreq_n`), read (`rd_n`), write (`wr_n`), and refresh (`rfsh_n`) signals. It also handles data transfer between the CPU and ASIC. The module includes a state machine with transitions between ASIC, CPU1, CPU2, CPU3, CPU5, CPU6, and CPU7 states, as well as default cases. The module controls the RAM address and write enable signals based on the current state and control signals. Additionally, the module routes data to and from the CPU and ASIC based on the current state.\n\n Module header:\n\nmodule ram_dual_port (input wire clk,input wire whichturn,input wire [18:0] vramaddr,input wire [18:0] cpuramaddr,input wire mreq_n,input wire rd_n,input wire wr_n,input wire rfsh_n,input wire [7:0] data_from_cpu,output wire [7:0] data_to_asic,output reg [7:0] data_to_cpu,output reg [18:0] sram_a,output reg sram_we_n,inout wire [7:0] sram_d);\n [/INST]\n", "output": "parameter ASIC = 3'd0, \n  CPU1 = 3'd1, \n  CPU2 = 3'd2, \n  CPU3 = 3'd3, \n  CPU4 = 3'd4, \n  CPU5 = 3'd5, \n  CPU6 = 3'd6, \n  CPU7 = 3'd7; \n  reg [2:0] state = ASIC; \n  assign sram_d = (state == CPU5 || state == CPU6)? data_from_cpu : 8'hZZ; \n  assign data_to_asic = sram_d; \n  always @* begin \n  if (whichturn == 1'b1) begin \n  sram_a = vramaddr; \n  sram_we_n = 1'b1; \n  end \n  else begin \n  sram_a = cpuramaddr; \n  data_to_cpu = sram_d; \n  if (state == CPU6 || state == CPU5) \n  sram_we_n = 1'b0; \n  else \n  sram_we_n = 1'b1; \n  end \n  end \n  always @(posedge clk) begin \n  case (state) \n  ASIC: \n  begin \n  if (whichturn == 1'b0) \n  state <= CPU1; \n  end \n  CPU1: \n  begin \n  if (whichturn == 1'b1) \n  state <= ASIC; \n  else if (mreq_n == 1'b0 && rd_n == 1'b0) \n  state <= CPU2; \n  else if (mreq_n == 1'b0 && rd_n == 1'b1 && rfsh_n == 1'b1) \n  state <= CPU5; \n  end \n  CPU2: \n  begin \n  if (whichturn == 1'b1) \n  state <= ASIC; \n  else \n  state <= CPU3; \n  end \n  CPU3: \n  begin \n  if (whichturn == 1'b1) \n  state <= ASIC; \n  else \n  state <= CPU1; \n  end \n  CPU5: \n  begin \n  if (whichturn == 1'b1) \n  state <= ASIC; \n  else if (mreq_n == 1'b1) \n  state <= CPU1; \n  else if (wr_n == 1'b0) \n  state <= CPU6; \n  end \n  CPU6: \n  begin \n  state <= CPU7; \n  end \n  CPU7: \n  begin \n  if (whichturn == 1'b1) \n  state <= ASIC; \n  else if (mreq_n == 1'b1) \n  state <= CPU1; \n  end \n  default: \n  begin \n  if (whichturn == 1'b1) \n  state <= ASIC; \n  else \n  state <= CPU1; \n  end \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"fifo_to_gpmc\" implements a FIFO buffer with a GPMC interface. It has state machines for both the GPMC and the FIFO, which control the read and write operations. The module also includes a 2-port RAM instance for the FIFO buffer. The GPMC state machine controls the address generation and transitions between start and empty states, while the FIFO state machine manages claiming and filling states. The data availability and the safe pointers are also handled within the module.\n\n Module header:\n\nmodule fifo_to_gpmc #(parameter PTR_WIDTH = 2, parameter ADDR_WIDTH = 10, parameter LAST_ADDR = 10'h3ff) (input clk, input reset, input clear, input arst,input [17:0] data_i, input src_rdy_i, output dst_rdy_o,output [15:0] EM_D, input [ADDR_WIDTH:1] EM_A, input EM_CLK, input EM_OE,output reg data_available);\n [/INST]\n", "output": "wire [17:0] data_o; \n  reg gpmc_state; \n  reg [ADDR_WIDTH:1] addr; \n  reg [PTR_WIDTH:0] gpmc_ptr, next_gpmc_ptr; \n  localparam GPMC_STATE_START = 0; \n  localparam GPMC_STATE_EMPTY = 1; \n  reg fifo_state; \n  reg [ADDR_WIDTH-1:0] counter; \n  reg [PTR_WIDTH:0] fifo_ptr; \n  localparam FIFO_STATE_CLAIM = 0; \n  localparam FIFO_STATE_FILL = 1; \n  always @(posedge EM_CLK or posedge arst) begin \n  if (arst) begin \n  gpmc_state <= GPMC_STATE_START; \n  gpmc_ptr <= 0; \n  next_gpmc_ptr <= 0; \n  addr <= 0; \n  end \n  else if (EM_OE) begin \n  addr <= EM_A + 1; \n  case(gpmc_state) \n  GPMC_STATE_START: begin \n  if (EM_A == 0) begin \n  gpmc_state <= GPMC_STATE_EMPTY; \n  next_gpmc_ptr <= gpmc_ptr + 1; \n  end \n  end \n  GPMC_STATE_EMPTY: begin \n  if (addr == LAST_ADDR) begin \n  gpmc_state <= GPMC_STATE_START; \n  gpmc_ptr <= next_gpmc_ptr; \n  addr <= 0; \n  end \n  end \n  endcase \n  end \n  end \n  wire [PTR_WIDTH:0] safe_gpmc_ptr; \n  cross_clock_reader #(.WIDTH(PTR_WIDTH+1)) read_gpmc_ptr \n  (.clk(clk), .rst(reset | clear), .in(gpmc_ptr), .out(safe_gpmc_ptr)); \n  wire bram_available_to_fill = (fifo_ptr ^ (1 << PTR_WIDTH)) != safe_gpmc_ptr; \n  wire [PTR_WIDTH:0] safe_next_gpmc_ptr; \n  cross_clock_reader #(.WIDTH(PTR_WIDTH+1)) read_next_gpmc_ptr \n  (.clk(clk), .rst(reset | clear), .in(next_gpmc_ptr), .out(safe_next_gpmc_ptr)); \n  always @(posedge clk) \n  if (reset | clear) data_available <= 0; \n  else data_available <= safe_next_gpmc_ptr != fifo_ptr; \n  always @(posedge clk) begin \n  if (reset | clear) begin \n  fifo_state <= FIFO_STATE_CLAIM; \n  fifo_ptr <= 0; \n  counter <= 0; \n  end \n  else begin \n  case(fifo_state) \n  FIFO_STATE_CLAIM: begin \n  if (bram_available_to_fill) fifo_state <= FIFO_STATE_FILL; \n  counter <= 0; \n  end \n  FIFO_STATE_FILL: begin \n  if (src_rdy_i && dst_rdy_o && data_i[17]) begin \n  fifo_state <= FIFO_STATE_CLAIM; \n  fifo_ptr <= fifo_ptr + 1; \n  end \n  if (src_rdy_i && dst_rdy_o) begin \n  counter <= counter + 1; \n  end \n  end \n  endcase \n  end \n  end \n  assign dst_rdy_o = fifo_state == FIFO_STATE_FILL; \n  assign EM_D = data_o[15:0]; \n  ram_2port #(.DWIDTH(18),.AWIDTH(PTR_WIDTH + ADDR_WIDTH)) async_fifo_bram \n (.clka(clk),.ena(1'b1),.wea(src_rdy_i && dst_rdy_o),.addra({fifo_ptr[PTR_WIDTH-1:0], counter}),.dia(data_i),.doa(),.clkb(EM_CLK),.enb(1'b1),.web(1'b0),.addrb({gpmc_ptr[PTR_WIDTH-1:0], addr}),.dib(18'h3ffff),.dob(data_o)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes a 4-bit binary-coded decimal (BCD) input and outputs a 7-bit code for a 7-segment display. It uses a case statement to assign the appropriate 7-segment code based on the BCD input. The default case sets the output to an undefined state.\n\n Module header:\n\nmodule bcd7seg (input [3:0] bcd,output reg [6:0] seg);\n [/INST]\n", "output": "always @(*) begin \n  case(bcd) \n  4'h0 : seg = 7'b1000000; \n  4'h1 : seg = 7'b1111001; \n  4'h2 : seg = 7'b0100100; \n  4'h3 : seg = 7'b0110000; \n  4'h4 : seg = 7'b0011001; \n  4'h5 : seg = 7'b0010010; \n  4'h6 : seg = 7'b0000010; \n  4'h7 : seg = 7'b1111000; \n  4'h8 : seg = 7'b0000000; \n  4'h9 : seg = 7'b0011000; \n  default: seg = 7'bXXXXXXX; \n  endcase \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a 3-state state machine with a 3-bit selection output and a digit output. The state machine transitions through the states S0, S1, S2, and S3 based on the rising edge of the clock signal and the negative edge of the reset signal. The module assigns the selection and digit outputs based on the current state using combinational logic.\n\n Module header:\n\nmodule Sec6_SM(input clk_i,input reset_n,output reg [2:0] sel,output reg digit);\n [/INST]\n", "output": "reg [1:0] state; \n  reg [1:0] state_next; \n  parameter S0 = 2'b00; \n  parameter S1 = 2'b01; \n  parameter S2 = 2'b10; \n  parameter S3 = 2'b11; \n  always @ (posedge clk_i, negedge reset_n) \n  begin \n  if(!reset_n) \n  state <= S0; \n  else \n  state <= state_next; \n  end \n  always @ (*) \n  begin \n  case(state) \n  S0: state_next = S1; \n  S1: state_next = S2; \n  S2: state_next = S3; \n  S3: state_next = S0; \n  default: state_next = S0; \n  endcase \n  end \n  always @ (*) \n  begin \n  case (state) \n  S0: \n  begin \n  sel = 3'b000; \n  digit = 1; \n  end \n  S1: \n  begin \n  sel = 3'b001; \n  digit = 1; \n  end \n  S2: \n  begin \n  sel = 3'b011; \n  digit = 0; \n  end \n  S3: \n  begin \n  sel = 3'b100; \n  digit = 1; \n  end \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module implements a 72-bit Linear Feedback Shift Register (LFSR) with a specific initial value. It uses the clock signal, reset signal, and enable signal to shift the bits of the word based on predefined logic, and updates the word accordingly.\n\n Module header:\n\nmodule rw_manager_lfsr72(clk,nrst,ena,word);\n [/INST]\n", "output": "input clk; \n  input nrst; \n  input ena; \n  output reg [71:0] word; \n  always @(posedge clk or negedge nrst) begin \n  if(~nrst) begin \n  word <= 72'hAAF0F0AA55F0F0AA55; \n  end \n  else if(ena) begin \n  word[71] <= word[0]; \n  word[70:66] <= word[71:67]; \n  word[65] <= word[66] ^ word[0]; \n  word[64:25] <= word[65:26]; \n  word[24] <= word[25] ^ word[0]; \n  word[23:19] <= word[24:20]; \n  word[18] <= word[19] ^ word[0]; \n  word[17:0] <= word[18:1]; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an interface for the AXI AD9250. It takes in a clock signal and data from a receiver, and outputs clock and data signals for an ADC, as well as status and OR signals. The module concatenates and processes the input data to generate the ADC data signals. It also includes logic to reset and update the ADC status signal based on the ADC reset signal and the receive clock signal.\n\n Module header:\n\nmodule axi_ad9250_if (rx_clk,rx_data,adc_clk,adc_rst,adc_data_a,adc_data_b,adc_or_a,adc_or_b,adc_status);\n [/INST]\n", "output": "input rx_clk; \n  input [63:0] rx_data; \n  output adc_clk; \n  input adc_rst; \n  output [27:0] adc_data_a; \n  output [27:0] adc_data_b; \n  output adc_or_a; \n  output adc_or_b; \n  output adc_status; \n  reg adc_status = 'd0; \n  wire [15:0] adc_data_a_s1_s; \n  wire [15:0] adc_data_a_s0_s; \n  wire [15:0] adc_data_b_s1_s; \n  wire [15:0] adc_data_b_s0_s; \n  assign adc_clk = rx_clk; \n  assign adc_or_a = 1'b0; \n  assign adc_or_b = 1'b0; \n  assign adc_data_a = {adc_data_a_s1_s[13:0], adc_data_a_s0_s[13:0]}; \n  assign adc_data_b = {adc_data_b_s1_s[13:0], adc_data_b_s0_s[13:0]}; \n  assign adc_data_a_s1_s = {rx_data[25:24], rx_data[23:16], rx_data[31:26]}; \n  assign adc_data_a_s0_s = {rx_data[ 9: 8], rx_data[ 7: 0], rx_data[15:10]}; \n  assign adc_data_b_s1_s = {rx_data[57:56], rx_data[55:48], rx_data[63:58]}; \n  assign adc_data_b_s0_s = {rx_data[41:40], rx_data[39:32], rx_data[47:42]}; \n  always @(posedge rx_clk) begin \n  if (adc_rst == 1'b1) begin \n  adc_status <= 1'b0; \n  end else begin \n  adc_status <= 1'b1; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, \"modexp_test_1_N,\" is designed to implement modular exponentiation. It utilizes a clock, reset signals, and various input and output ports. The main functionality involves calculating the modular exponentiation of the inputs m, e, and n. It uses a combinational logic block \"c\" and a register \"creg\" to store the results.\n\nAdditionally, it includes a function \"modexp_f\" that calculates the modular exponentiation operation. The module also includes test cases to verify the functionality of the implemented modular exponentiation. The clock signal is used to drive the operations, and the initial block initializes the input values and executes the modular exponentiation calculations. The module includes two instances, UUT1 and UUT2, which utilize the same module with different inputs and outputs.\n\nThe simulation is driven by the clock signal, and the test cases are verified by comparing the output with the expected results. The module incorporates clock edge detection and reset signals to control the timing of the operations and handle the initialization of the circuit.\n\n Module header:\n\nmodule modexp_test_1_N();\n [/INST]\n", "output": "parameter N = 8; \n  parameter CC = N; \n  reg clk; \n  reg rst1; \n  reg rst2; \n  reg [N-1:0] m; \n  reg [N-1:0] e; \n  reg [N-1:0] d; \n  reg [N-1:0] n; \n  wire [N-1:0] c; \n  reg [N-1:0] creg; \n  wire [N-1:0] mout; \n  function [N-1:0] modexp_f; \n  input [N-1:0] m; \n  input [N-1:0] e; \n  input [N-1:0] n; \n  reg [2*N-1:0] mm; \n  integer i, start; \n  begin \n  $display(\"modexp_f: m =%d e =%d n=%d\", m, e, n); \n  start = -1; \n  for(i=N-1;i>=0;i=i-1) \n  begin \n  if(e[i] && start == -1) \n  begin \n  start = i; \n  end \n  end \n  modexp_f = m; \n  $display(\"%d\", modexp_f); \n  for(i=start-1;i>=0;i=i-1) \n  begin \n  mm = modexp_f; \n  mm = mm*mm; \n  modexp_f = mm%n; \n  $display(\"%d\", modexp_f); \n  if(e[i]) \n  begin \n  mm = modexp_f; \n  mm = mm * m; \n  modexp_f = mm%n; \n  $display(\"* %d\", modexp_f); \n  end \n  end \n  end \n  endfunction \n  modexp \n #(.N(N),.CC(CC)) \n  UUT1 \n (.clk(clk),.rst(rst1),.m(m),.e(e),.n(n),.c(c)); \n  modexp \n #(.N(N),.CC(CC)) \n  UUT2 \n (.clk(clk),.rst(rst2),.m(creg),.e(d),.n(n),.c(mout)); \n  integer i; \n  initial \n  begin \n  m = 'd106; \n  e = 'd11; \n  d = 'd35; \n  n = 'd221; \n  creg = 0; \n  $display(\"m = %d\", m); \n  $display(\"e = %d\", e); \n  $display(\"d = %d\", d); \n  $display(\"n = %d\", n); \n  clk = 0; \n  rst1 = 1; \n  rst2 = 1; \n  @(negedge clk); \n  rst1 = 0; \n  for(i=0;i<CC-1;i=i+1) \n  @(negedge clk); \n  $display(\"c = %d, modexp_f = %d\", c, modexp_f(m,e,n)); \n  $display(\"------------\"); \n  creg = c; \n  @(negedge clk); \n  @(negedge clk); \n  @(negedge clk); \n  rst1 = 1; \n  rst2 = 0; \n  for(i=0;i<CC-1;i=i+1) \n  @(negedge clk); \n  $display(\"mout = %d, modexp_f = %d\", mout, modexp_f(creg,d,n)); \n  if(mout == m) \n  $display(\"Correct!\", mout); \n  else \n  $display(\"Error!\", mout); \n  @(negedge clk); \n  rst2 = 1; \n  $stop; \n  end \n  always #5 clk=~clk; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module represents a VGA digital-to-analog converter (DAC) with separate red, green, and blue channels. It has registers to store the red, green, and blue values for each of the 256 possible colors. On a positive clock edge, the module sets the red, green, and blue output values based on the index input. It also includes logic to read data from the red, green, and blue DACs based on the read_data_cycle and read_data_register inputs. Additionally, it supports writing data to the red, green, and blue DACs based on the write_data_cycle, write_data_register, and write_data inputs.\n\n Module header:\n\nmodule vga_dac_regs_fml (input clk,input [7:0] index,output reg [3:0] red,output reg [3:0] green,output reg [3:0] blue,input write,input [1:0] read_data_cycle,input [7:0] read_data_register,output reg [3:0] read_data,input [1:0] write_data_cycle,input [7:0] write_data_register,input [3:0] write_data);\n [/INST]\n", "output": "reg [3:0] red_dac [0:255]; \n  reg [3:0] green_dac [0:255]; \n  reg [3:0] blue_dac [0:255]; \n  always @(posedge clk) \n  begin \n  red <= red_dac[index]; \n  green <= green_dac[index]; \n  blue <= blue_dac[index]; \n  end \n  always @(posedge clk) \n  case (read_data_cycle) \n  2'b00: read_data <= red_dac[read_data_register]; \n  2'b01: read_data <= green_dac[read_data_register]; \n  2'b10: read_data <= blue_dac[read_data_register]; \n  default: read_data <= 4'h0; \n  endcase \n  always @(posedge clk) \n  if (write) \n  case (write_data_cycle) \n  2'b00: red_dac[write_data_register] <= write_data; \n  2'b01: green_dac[write_data_register] <= write_data; \n  2'b10: blue_dac[write_data_register] <= write_data; \n  endcase \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a lighting control system. It uses a clock signal and a received signal, and outputs data to the transmission line and LED lights. The module contains various components such as a UART clock, a clock divider, a step counter, PWM counter, and different types of patterns for controlling the LEDs. The behavior of the LEDs is determined by the pattern type and the current step. The module also includes components for generating random patterns, storing patterns, and serial communication. It utilizes a multiplexer to select the appropriate LED data based on the pattern type and the state of the clock switch.\n\n Module header:\n\nmodule lights(input clk,input rx,output tx,output [2*12-1:0] leds);\n [/INST]\n", "output": "wire clk_uart; \n uart_clk uart_clk_i(.CLKIN_IN(clk),.CLKFX_OUT(clk_uart),.CLKIN_IBUFG_OUT(),.CLK0_OUT()); \n  wire rx_i; \n  reg [4:0] rx_sync = 0; \n  always @ (posedge clk_uart) rx_sync <= {rx_sync[3:0], rx}; \n  assign rx_i = rx_sync[4]; \n  reg [26:0] clk_div; initial clk_div = 0; \n  always @ (posedge clk_uart) clk_div <= clk_div + 1; \n  wire clk_step = clk_div[17]; \n  reg clk_step_l; initial clk_step_l = 0; \n  always @ (posedge clk_uart) clk_step_l <= clk_step; \n  reg step; initial step = 0; \n  always @ (posedge clk_uart) \n  if (clk_step && ~clk_step_l) step <= 1; \n  else step <= 0; \n  wire [7:0] pwm_counter = clk_div[13:6]; \n  wire [71:0] leds_p, leds_r, leds_i; \n  reg [71:0] leds_mux; \n  wire [7:0] pat_up_a; \n  wire [71:0] pat_up_d; \n  wire pat_up_we; \n  wire [1:0] pattern_type; \n led specific_leds[11:0](.pwm_counter(pwm_counter),.values(leds_mux),.leds(leds)); \n  stored_pattern p(clk_uart, step, pat_up_a, pat_up_d, pat_up_we, leds_p); \n  random r(clk_uart, step, pwm_counter, leds_r); \n  serial s(clk_uart, rx_i, tx, pat_up_a, pat_up_d, pat_up_we, pattern_type, leds_i); \n  wire clk_switch = clk_div[26]; \n  always @ (*) \n  case (pattern_type) \n  0: begin \n  case(clk_switch) \n  0: leds_mux <= leds_p; \n  1: leds_mux <= leds_r; \n  endcase \n  end \n  1: leds_mux <= leds_p; \n  2: leds_mux <= leds_r; \n  3: leds_mux <= leds_i; \n  endcase \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a universal register with an N-bit width. It has synchronous behavior with the clock and an asynchronous reset. When the hold signal is not asserted, it selects between two input data sources based on the chip_select signal. If hold is asserted, the register maintains its current value. The output is driven by the register's value.\n\n Module header:\n\nmodule Registro_Universal #(parameter N = 8) (input wire hold,input wire [N-1:0]in_rtc_dato,input wire [N-1:0]in_count_dato,input wire clk,input wire reset,input wire chip_select,output wire [N-1:0]out_dato);\n [/INST]\n", "output": "reg [N-1:0]reg_dato; \n reg [N-1:0]next_dato; \n always@(negedge clk, posedge reset) \n begin \n  if(reset) reg_dato <= 0; \n  else reg_dato <= next_dato; \n end \n always@* \n  begin \n  if (~hold) begin \n  case(chip_select) \n  1'b0: next_dato = in_rtc_dato; \n  1'b1: next_dato = in_count_dato; \n  endcase \n  end \n  else next_dato = reg_dato; \n  end \n assign out_dato = reg_dato; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a VGA controller that generates horizontal and vertical synchronization signals, as well as pixel and line counts for a VGA display. It includes parameters for the display resolution and porch timings. The module increments the pixel and line counters based on the pixel clock and resets them when a reset signal is asserted. It also calculates the horizontal and vertical sync signals based on the current pixel and line counts.\n\n Module header:\n\nmodule vga_controller(pixel_clock, reset, hsync, vsync, pixel_count, line_count);\n [/INST]\n", "output": "input pixel_clock; \n  input reset; \n  output hsync; \n  output vsync; \n  output [9:0] pixel_count; \n  output [9:0] line_count; \n  reg hsync, vsync; \n  reg [9:0] pixel_count, line_count; \n  wire [9:0] next_pixel, next_line; \n  parameter NUM_LINES = 525; \n  parameter NUM_PIXELS = 800; \n  parameter WIDTH = 640; \n  parameter HEIGHT = 480; \n  parameter H_FRONT_PORCH = 16; \n  parameter H_SYNC = 96; \n  parameter H_BACK_PORCH = 48; \n  parameter V_FRONT_PORCH = 11; \n  parameter V_SYNC = 2; \n  parameter V_BACK_PORCH = 32; \n  always @(posedge pixel_clock) begin \n  if(reset) begin \n  pixel_count <= 10'b0; \n  line_count <= 10'b0; \n  hsync <= 1; \n  vsync <= 1; \n  end else begin \n  pixel_count <= next_pixel; \n  line_count <= next_line; \n hsync <= ~((next_pixel >= WIDTH + H_FRONT_PORCH) &(next_pixel < WIDTH + H_FRONT_PORCH + H_SYNC)); \n vsync <= ~((next_line >= HEIGHT + V_FRONT_PORCH) &(next_line < HEIGHT + V_FRONT_PORCH + V_SYNC)); \n  end \n  end \n  assign next_pixel = (pixel_count >= NUM_PIXELS - 1) ? 1'b0 : pixel_count + 1'b1; \n  assign next_line = (pixel_count >= NUM_PIXELS - 1) ? \n  ((line_count >= NUM_LINES - 1) ? 1'b0 : line_count + 1'b1) : line_count; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a combinational logic that maps the value of the input signal `chip_r` to an ASCII string stored in `chip_r__ascii`. The ASCII value is determined based on the value of `chip_r`. If none of the predefined cases match, it assigns the string \"%Err\" to `chip_r__ascii`.\n\n Module header:\n\nmodule sm ();\n [/INST]\n", "output": "reg [3:0] chip_r; \n  reg [31:0] chip_r__ascii; \n  always @(chip_r) begin \n  case ({chip_r}) \n  EP_C14ChipNum_RNP: chip_r__ascii = \"rnp \"; \n  EP_C14ChipNum_SPP: chip_r__ascii = \"spp \"; \n  EP_C14ChipNum_SRP: chip_r__ascii = \"srp \"; \n  EP_C14ChipNum_SMM2: chip_r__ascii = \"smm2\"; \n  EP_C14ChipNum_SMM: chip_r__ascii = \"smm \"; \n  EP_C14ChipNum_TTE: chip_r__ascii = \"tte \"; \n  EP_C14ChipNum_DLE: chip_r__ascii = \"dle \"; \n  EP_C14ChipNum_OASP: chip_r__ascii = \"oasp\"; \n  default: chip_r__ascii = \"%Err\"; \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a 32-bit register. It has a clock input, a reset input, a 32-bit data input, and a 32-bit data output. On the positive edge of the clock signal, the module loads the input data into the output register when the reset signal is not asserted, and sets the output to 0 when the reset signal is asserted.\n\n Module header:\n\nmodule reg32 (clk, reset, d_in, d_out);\n [/INST]\n", "output": "input clk, reset; \n  input [31:0] d_in; \n  output [31:0] d_out; \n  reg [31:0] d_out; \n  always @(posedge clk) \n  begin \n  if (reset) d_out <= 0; \n  else d_out <= d_in; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a display controller that interfaces with a display. It takes in a clock signal, reset signal, address, enable signal, write signal, and data input, and outputs write toggle, data output, horizontal and vertical synchronization signals, as well as signals for red, green, and blue color components. The module also includes a state machine that updates based on the input signals. When enabled and not writing, the state toggles, and the write toggle output is asserted.\n\n Module header:\n\nmodule dsp(clk, reset,addr, en, wr, wt,data_in, data_out,hsync, vsync,r, g, b);\n [/INST]\n", "output": "input clk; \n  input reset; \n  input [13:2] addr; \n  input en; \n  input wr; \n  output wt; \n  input [15:0] data_in; \n  output [15:0] data_out; \n  output hsync; \n  output vsync; \n  output [2:0] r; \n  output [2:0] g; \n  output [2:0] b; \n  reg state; \n display display1(.clk(clk),.dsp_row(addr[13:9]),.dsp_col(addr[8:2]),.dsp_en(en),.dsp_wr(wr),.dsp_wr_data(data_in[15:0]),.dsp_rd_data(data_out[15:0]),.hsync(hsync),.vsync(vsync),.r(r[2:0]),.g(g[2:0]),.b(b[2:0])); \n  always @(posedge clk) begin \n  if (reset == 1) begin \n  state <= 1'b0; \n  end else begin \n  case (state) \n  1'b0: \n  begin \n  if (en == 1 && wr == 0) begin \n  state <= 1'b1; \n  end \n  end \n  1'b1: \n  begin \n  state <= 1'b0; \n  end \n  endcase \n  end \n  end \n  assign wt = (en == 1 && wr == 0 && state == 1'b0) ? 1 : 0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"amsacid\" implements a sequential logic circuit with an 8-bit output \"PinSIN\". It uses the clock signal \"PinCLK\", address inputs \"PinA\", output enable signal \"PinOE\", and clear signal \"PinCCLR\" to control the shift register \"ShiftReg\". The module also utilizes combinatorial logic to compare the address inputs with predefined values and calculates the XOR value. The shifting of \"ShiftReg\" is triggered by the negative edge of \"PinCLK\" and is determined by the control signals \"PinOE\" and \"PinCCLR\", as well as the comparison result and XOR value. The module outputs the lower 8 bits of \"ShiftReg\" as \"PinSIN\".\n\n Module header:\n\nmodule amsacid(PinCLK, PinA, PinOE, PinCCLR, PinSIN);\n [/INST]\n", "output": "input PinCLK; \n input [7:0]PinA; \n input PinOE; \n input PinCCLR; \n output [7:0]PinSIN; \n wire PinCLK; \n reg [16:0]ShiftReg = 17'h1FFFF; \n wire [16:0]CmpVal; \n wire [16:0]XorVal; \n assign CmpVal = 17'h13596 ^ (PinA[0] ? 17'h0000c : 0) \n  ^ (PinA[1] ? 17'h06000 : 0) \n  ^ (PinA[2] ? 17'h000c0 : 0) \n  ^ (PinA[3] ? 17'h00030 : 0) \n  ^ (PinA[4] ? 17'h18000 : 0) \n  ^ (PinA[5] ? 17'h00003 : 0) \n  ^ (PinA[6] ? 17'h00600 : 0) \n  ^ (PinA[7] ? 17'h01800 : 0); \n assign XorVal = 17'h0C820 ^ (PinA[0] ? 17'h00004 : 0) \n  ^ (PinA[1] ? 17'h06000 : 0) \n  ^ (PinA[2] ? 17'h00080 : 0) \n  ^ (PinA[3] ? 17'h00020 : 0) \n  ^ (PinA[4] ? 17'h08000 : 0) \n  ^ (PinA[5] ? 17'h00000 : 0) \n  ^ (PinA[6] ? 17'h00000 : 0) \n  ^ (PinA[7] ? 17'h00800 : 0); \n always@(negedge PinCLK) \n  begin \n  if (PinCCLR) \n  begin \n  if (!PinOE && ((ShiftReg | 17'h00100) == CmpVal)) \n  begin \n  ShiftReg <= (ShiftReg ^ XorVal) >> 1; \n  ShiftReg[16] <= ShiftReg[0] ^ ShiftReg[9] ^ ShiftReg[12] ^ ShiftReg[16] ^ XorVal[0]; \n  end \n  else \n  begin \n  ShiftReg <= ShiftReg >> 1; \n  ShiftReg[16] <= ShiftReg[0] ^ ShiftReg[9] ^ ShiftReg[12] ^ ShiftReg[16]; \n  end \n  end \n  else \n  begin \n  ShiftReg <= 17'h1FFFF; \n  end \n  end \n assign PinSIN = ShiftReg[7:0]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module MISTRAL_ALUT2 implements a 2-input lookup table (LUT) using parameters A and B as inputs and Q as the output. Depending on the defined parameter LUT value, it uses the inputs A and B to determine the output Q. Additionally, it includes specific logic for CycloneV and Cyclone10GX devices using conditional compilation directives. The final output Q is the result of the LUT value right-shifted by the concatenation of inputs B and A.\n\n Module header:\n\nmodule MISTRAL_ALUT2(input A, B, output Q);\n [/INST]\n", "output": "parameter [3:0] LUT = 4'h0; \n `ifdef cyclonev \n specify \n  (A => Q) = 400; \n  (B => Q) = 97; \n endspecify \n `endif \n `ifdef cyclone10gx \n specify \n  (A => Q) = 162; \n  (B => Q) = 53; \n endspecify \n `endif \n assign Q = LUT >> {B, A}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module is an I2C controller with inputs for the clock signal, data to be transmitted, control signals for enabling the bus and resetting the controller, and bidirectional and output signals for the data line, clock line, end of transmission, and acknowledge. The module implements the I2C protocol and communicates with external devices by generating the necessary clock and data signals. The behavior of the module is defined by state machines driven by the clock and control signals, and it responds to the data and control inputs to handle the communication protocol.\n\n Module header:\n\nmodule I2C_Controller (CLOCK,I2C_SCLK,I2C_SDAT,I2C_DATA,GO,END,ACK,RESET);\n [/INST]\n", "output": "input CLOCK; \n  input [31:0]I2C_DATA; \n  input GO; \n  input RESET; \n  inout I2C_SDAT; \n  output I2C_SCLK; \n  output END; \n  output ACK; \n reg SDO; \n reg SCLK; \n reg END; \n reg [31:0]SD; \n reg [6:0]SD_COUNTER; \n wire I2C_SCLK=SCLK | ( ((SD_COUNTER >= 4) & (SD_COUNTER <=39))? ~CLOCK :0 ); \n wire I2C_SDAT=SDO?1'bz:0 ; \n reg ACK1,ACK2,ACK3,ACK4; \n wire ACK=ACK1 | ACK2 |ACK3 |ACK4; \n always @(negedge RESET or posedge CLOCK ) begin \n if (!RESET) SD_COUNTER=6'b111111; \n else begin \n if (GO==0) \n  SD_COUNTER=0; \n  else \n  if (SD_COUNTER < 41) SD_COUNTER=SD_COUNTER+1; \n end \n end \n always @(negedge RESET or posedge CLOCK ) begin \n if (!RESET) begin SCLK=1;SDO=1; ACK1=0;ACK2=0;ACK3=0;ACK4=0; END=1; end \n else \n case (SD_COUNTER) \n  6'd0 : begin ACK1=0 ;ACK2=0 ;ACK3=0 ;ACK4=0 ; END=0; SDO=1; SCLK=1;end \n  6'd1 : begin SD=I2C_DATA;SDO=0;end \n  6'd2 : SCLK=0; \n  6'd3 : SDO=SD[31]; \n  6'd4 : SDO=SD[30]; \n  6'd5 : SDO=SD[29]; \n  6'd6 : SDO=SD[28]; \n  6'd7 : SDO=SD[27]; \n  6'd8 : SDO=SD[26]; \n  6'd9 : SDO=SD[25]; \n  6'd10 : SDO=SD[24]; \n  6'd11 : SDO=1'b1; \n  6'd12 : begin SDO=SD[23]; ACK1=I2C_SDAT; end \n  6'd13 : SDO=SD[22]; \n  6'd14 : SDO=SD[21]; \n  6'd15 : SDO=SD[20]; \n  6'd16 : SDO=SD[19]; \n  6'd17 : SDO=SD[18]; \n  6'd18 : SDO=SD[17]; \n  6'd19 : SDO=SD[16]; \n  6'd20 : SDO=1'b1; \n  6'd21 : begin SDO=SD[15]; ACK2=I2C_SDAT; end \n  6'd22 : SDO=SD[14]; \n  6'd23 : SDO=SD[13]; \n  6'd24 : SDO=SD[12]; \n  6'd25 : SDO=SD[11]; \n  6'd26 : SDO=SD[10]; \n  6'd27 : SDO=SD[9]; \n  6'd28 : SDO=SD[8]; \n  6'd29 : SDO=1'b1; \n  6'd30 : begin SDO=SD[7]; ACK3=I2C_SDAT; end \n  6'd31 : SDO=SD[6]; \n  6'd32 : SDO=SD[5]; \n  6'd33 : SDO=SD[4]; \n  6'd34 : SDO=SD[3]; \n  6'd35 : SDO=SD[2]; \n  6'd36 : SDO=SD[1]; \n  6'd37 : SDO=SD[0]; \n  6'd38 : SDO=1'b1; \n  6'd39 : begin SDO=1'b0; SCLK=1'b0; ACK4=I2C_SDAT; end \n  6'd40 : SCLK=1'b1; \n  6'd41 : begin SDO=1'b1; END=1; end \n endcase \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a read status flags circuit. It takes inputs \\gc0.count_d1_reg[2], m_aclk, and grst.g7serrst.rd_rst_reg_reg[2], and outputs the wire out. The module includes a DONT_TOUCH wire and uses a FDPE component for register removal. The output out is assigned to ram_empty_fb_i, which is a result of the FDPE component. The module also includes another output, ram_empty_i, which is a result of a similar component.\n\n Module header:\n\nmodule system_auto_cc_0_rd_status_flags_as_19 (out,\\gc0.count_d1_reg[2] ,m_aclk,\\ngwrdrst.grst.g7serrst.rd_rst_reg_reg[2] );\n [/INST]\n", "output": "output out; \n  input \\gc0.count_d1_reg[2] ; \n  input m_aclk; \n  input [0:0]\\ngwrdrst.grst.g7serrst.rd_rst_reg_reg[2] ; \n  wire \\gc0.count_d1_reg[2] ; \n  wire m_aclk; \n  wire [0:0]\\ngwrdrst.grst.g7serrst.rd_rst_reg_reg[2] ; \n  (* DONT_TOUCH *) wire ram_empty_fb_i; \n  (* DONT_TOUCH *) wire ram_empty_i; \n  assign out = ram_empty_fb_i; \n  (* DONT_TOUCH *) \n  (* KEEP = \"yes\" *) \n  (* equivalent_register_removal = \"no\" *) \n FDPE #(.INIT(1'b1)) \n  ram_empty_fb_i_reg \n (.C(m_aclk),.CE(1'b1),.D(\\gc0.count_d1_reg[2] ),.PRE(\\ngwrdrst.grst.g7serrst.rd_rst_reg_reg[2] ),.Q(ram_empty_fb_i)); \n  (* DONT_TOUCH *) \n  (* KEEP = \"yes\" *) \n  (* equivalent_register_removal = \"no\" *) \n FDPE #(.INIT(1'b1)) \n  ram_empty_i_reg \n (.C(m_aclk),.CE(1'b1),.D(\\gc0.count_d1_reg[2] ),.PRE(\\ngwrdrst.grst.g7serrst.rd_rst_reg_reg[2] ),.Q(ram_empty_i)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an Ethernet FIFO with configurable data width, depth, and counter width. It has clock, reset, write, read, clear, data_in, data_out, almost_full, full, almost_empty, empty, and cnt as inputs and outputs. The FIFO has read and write pointers, and it uses these to manage the input and output data. The FIFO also includes Xilinx and Altera specific definitions for their respective distributed RAM and DPRAM 16x32 instances. The module is capable of writing and reading data to and from the FIFO based on the control signals, and it handles almost full, full, almost empty, and empty conditions accordingly.\n\n Module header:\n\nmodule eth_fifo (data_in, data_out, clk, reset, write, read, clear, almost_full, full, almost_empty, empty, cnt);\n [/INST]\n", "output": "parameter DATA_WIDTH = 32; \n parameter DEPTH = 8; \n parameter CNT_WIDTH = 4; \n parameter Tp = 1; \n input clk; \n input reset; \n input write; \n input read; \n input clear; \n input [DATA_WIDTH-1:0] data_in; \n output [DATA_WIDTH-1:0] data_out; \n output almost_full; \n output full; \n output almost_empty; \n output empty; \n output [CNT_WIDTH-1:0] cnt; \n `ifdef ETH_FIFO_XILINX \n `else \n  `ifdef ETH_ALTERA_ALTSYNCRAM \n  `else \n  reg [DATA_WIDTH-1:0] fifo [0:DEPTH-1]; \n  reg [DATA_WIDTH-1:0] data_out; \n  `endif \n `endif \n reg [CNT_WIDTH-1:0] cnt; \n reg [CNT_WIDTH-2:0] read_pointer; \n reg [CNT_WIDTH-2:0] write_pointer; \n always @ (posedge clk or posedge reset) \n begin \n  if(reset) \n  cnt <=#Tp 0; \n  else \n  if(clear) \n  cnt <=#Tp { {(CNT_WIDTH-1){1'b0}}, read^write}; \n  else \n  if(read ^ write) \n  if(read) \n  cnt <=#Tp cnt - 1'b1; \n  else \n  cnt <=#Tp cnt + 1'b1; \n end \n always @ (posedge clk or posedge reset) \n begin \n  if(reset) \n  read_pointer <=#Tp 0; \n  else \n  if(clear) \n  read_pointer <=#Tp { {(CNT_WIDTH-2){1'b0}}, read}; \n  else \n  if(read & ~empty) \n  read_pointer <=#Tp read_pointer + 1'b1; \n end \n always @ (posedge clk or posedge reset) \n begin \n  if(reset) \n  write_pointer <=#Tp 0; \n  else \n  if(clear) \n  write_pointer <=#Tp { {(CNT_WIDTH-2){1'b0}}, write}; \n  else \n  if(write & ~full) \n  write_pointer <=#Tp write_pointer + 1'b1; \n end \n assign empty = ~(|cnt); \n assign almost_empty = cnt == 1; \n assign full = cnt == DEPTH; \n assign almost_full = &cnt[CNT_WIDTH-2:0]; \n `ifdef ETH_FIFO_XILINX \n  xilinx_dist_ram_16x32 fifo \n ( .data_out(data_out),.we(write & ~full),.data_in(data_in),.read_address( clear ? {CNT_WIDTH-1{1'b0}} : read_pointer),.write_address(clear ? {CNT_WIDTH-1{1'b0}} : write_pointer),.wclk(clk)); \n `else \n `ifdef ETH_ALTERA_ALTSYNCRAM \n  altera_dpram_16x32 altera_dpram_16x32_inst \n (.data (data_in),.wren (write & ~full),.wraddress (clear ? {CNT_WIDTH-1{1'b0}} : write_pointer),.rdaddress (clear ? {CNT_WIDTH-1{1'b0}} : read_pointer ),.clock (clk),.q (data_out)); \n `else \n  always @ (posedge clk) \n  begin \n  if(write & clear) \n  fifo[0] <=#Tp data_in; \n  else \n  if(write & ~full) \n  fifo[write_pointer] <=#Tp data_in; \n  end \n  always @ (posedge clk) \n  begin \n  if(clear) \n  data_out <=#Tp fifo[0]; \n  else \n  data_out <=#Tp fifo[read_pointer]; \n  end \n `endif \n `endif \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a multiplexer that selects between two sets of input signals based on the `select_i` signal. When `select_i` is 1, it chooses the inputs from `inport1`. When `select_i` is 0 or any other value, it selects the inputs from `inport0`. The selected input signals are then routed to corresponding output signals based on the value of `select_i`. The module also includes a reset functionality and assigns the outputs based on the selected inputs.\n\n Module header:\n\nmodule dcache_pmem_mux (input clk_i,input rst_i,input outport_accept_i,input outport_ack_i,input outport_error_i,input [ 31:0] outport_read_data_i,input select_i,input [ 3:0] inport0_wr_i,input inport0_rd_i,input [ 7:0] inport0_len_i,input [ 31:0] inport0_addr_i,input [ 31:0] inport0_write_data_i,input [ 3:0] inport1_wr_i,input inport1_rd_i,input [ 7:0] inport1_len_i,input [ 31:0] inport1_addr_i,input [ 31:0] inport1_write_data_i,output [ 3:0] outport_wr_o,output outport_rd_o,output [ 7:0] outport_len_o,output [ 31:0] outport_addr_o,output [ 31:0] outport_write_data_o,output inport0_accept_o,output inport0_ack_o,output inport0_error_o,output [ 31:0] inport0_read_data_o,output inport1_accept_o,output inport1_ack_o,output inport1_error_o,output [ 31:0] inport1_read_data_o);\n [/INST]\n", "output": "reg [ 3:0] outport_wr_r; \n reg outport_rd_r; \n reg [ 7:0] outport_len_r; \n reg [ 31:0] outport_addr_r; \n reg [ 31:0] outport_write_data_r; \n reg select_q; \n always @ * \n begin \n  case (select_i) \n  1'd1: \n  begin \n  outport_wr_r = inport1_wr_i; \n  outport_rd_r = inport1_rd_i; \n  outport_len_r = inport1_len_i; \n  outport_addr_r = inport1_addr_i; \n  outport_write_data_r = inport1_write_data_i; \n  end \n  default: \n  begin \n  outport_wr_r = inport0_wr_i; \n  outport_rd_r = inport0_rd_i; \n  outport_len_r = inport0_len_i; \n  outport_addr_r = inport0_addr_i; \n  outport_write_data_r = inport0_write_data_i; \n  end \n  endcase \n end \n assign outport_wr_o = outport_wr_r; \n assign outport_rd_o = outport_rd_r; \n assign outport_len_o = outport_len_r; \n assign outport_addr_o = outport_addr_r; \n assign outport_write_data_o = outport_write_data_r; \n always @ (posedge clk_i or posedge rst_i) \n if (rst_i) \n  select_q <= 1'b0; \n else \n  select_q <= select_i; \n assign inport0_ack_o = (select_q == 1'd0) && outport_ack_i; \n assign inport0_error_o = (select_q == 1'd0) && outport_error_i; \n assign inport0_read_data_o = outport_read_data_i; \n assign inport0_accept_o = (select_i == 1'd0) && outport_accept_i; \n assign inport1_ack_o = (select_q == 1'd1) && outport_ack_i; \n assign inport1_error_o = (select_q == 1'd1) && outport_error_i; \n assign inport1_read_data_o = outport_read_data_i; \n assign inport1_accept_o = (select_i == 1'd1) && outport_accept_i; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a state machine with two states, IDLE and CAS1, based on the input state. The var1 output is set to 1 based on the current state. Additionally, there is another always block that triggers on changes to the inputs add, lo, mc_32pff, mc_losel, slo, or var1, and selects different values for the lo_mux based on the value of mc_losel and var1.\n\n Module header:\n\nmodule darren_jones_3 (var1,state);\n [/INST]\n", "output": "input [2:1] state; \n  output var1; \n  reg var1; \n  parameter \n  IDLE = 1, \n  CAS1 = 2; \n  always @(state) begin \n  case (1'b1) \n  state[IDLE] : begin \n  var1 = 1'b1; \n  end \n  state[CAS1] : begin \n  var1 = 1'b1; \n  end \n  default : begin \n  var1 = 1'b1; \n  end \n  endcase \n  end \n  always @(add or lo or mc_32pff or mc_losel or slo or var1) begin \n  case(mc_losel) \n  6'b000001: lo_mux = mc_32pff ? {add[39:0],lo[31:8]} : \n  {add[7:0],lo[63:8]}; \n  6'b010000: lo_mux = lo; \n  6'b100000: lo_mux = var1 ? IDLE : slo; \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module generates a slower clock signal, \"slow_clk\", from the input clock signal, \"clk\". The slow_clk signal changes state every 49,999,999 clock cycles, effectively dividing the input clock frequency. The module contains a counter that counts the input clock cycles and toggles the slow_clk signal when the count reaches the specified threshold.\n\n Module header:\n\nmodule slow_clk(input clk, output slow_clk);\n [/INST]\n", "output": "parameter TICKS = 27'd49_999_999; \n  reg [31:0] count = 0; \n  reg sig_reg = 0; \n  always @(posedge clk) begin \n  if (count == TICKS) begin \n  sig_reg <= ~sig_reg; \n  count <= 0; \n  end \n  else begin \n  count <= count + 1; \n  end \n  end \n  assign slow_clk = sig_reg; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a Pulse Width Modulation (PWM) generator. It uses the input clock and value to control the output signal `out`. The module contains an 8-bit counter `PWMCounter` and a 1-bit output variable `outreg`. On each positive edge of the clock, the module checks if `PWMCounter` is less than or equal to the input value and the input value is not zero. If the condition is true, `outreg` is set to 1; otherwise, it is set to 0. The module then increments `PWMCounter` by 1. The final output `out` is assigned the value of `outreg`.\n\n Module header:\n\nmodule LedPWM(input clk,input [7:0] value,output out);\n [/INST]\n", "output": "reg [7:0] PWMCounter; \n reg outreg; \n always @(posedge clk) \n begin \n  if(PWMCounter <= value & value != 0) \n  outreg <= 1; \n  else \n  outreg <= 0; \n  PWMCounter <= PWMCounter+1; \n end \n assign out = outreg; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"pipechecker\" is designed to monitor and report violations in a pipeline system. It takes in clock signal \"clk\", request signal \"req\", response signal \"res\", and address bus \"where\" as inputs. It has parameters \"m\" and \"n\" to set the number of bits for the address and data buses respectively.\n\nThe module includes various wires such as \"addr\", \"rd_strobe\", \"wr_strobe\", \"wr_data\", \"wr_byteena\", \"hold\", and \"rd_data\" to manage different signals within the pipeline.\n\nInside the module, there are checks for violations labeled as INV #1, INV #2, INV #3, and INV #4, each corresponding to different conditions related to the request and response signals. Whenever a violation is detected, a message is displayed including the timestamp and the address where the violation occurred.\n\nIt's worth noting that the module includes directives for simulation purposes, with registers \"req_\" and \"res_\" that are set to initial values and the use of the `$display` function to report violation messages.\n\n Module header:\n\nmodule pipechecker(where, clk, req, res);\n [/INST]\n", "output": "parameter m = 32; \n  parameter n = 32; \n  input wire clk; \n  input wire `REQ req; \n  input wire `RES res; \n  input wire [8*16:1] where; \n  wire [m-1:0] addr; \n  wire rd_strobe; \n  wire wr_strobe; \n  wire [n-1:0] wr_data; \n  wire [n/8-1:0] wr_byteena; \n  wire hold; \n  wire [n-1:0] rd_data; \n `ifdef SIMULATE_MAIN \n  reg `REQ req_ = 0; \n  reg `RES res_ = 0; \n  always @(posedge clk) begin \n  req_ <= req; \n  res_ <= res; \n  end \n  always @(posedge clk) \n  if (req`R & req`W) \n  $display(\"%5d PIPECHECKER: %s INV #1 violation, no simultaneous rd and wr\", $time, where); \n  always @(posedge clk) \n  if (res_`HOLD && req_ != req) begin \n  $display(\"%5d PIPECHECKER: %s INV #2 violation, request changed while hold active\", $time, where); \n  $display(\" OLD: A %x R %d W %d RD %x WD %x\", req_`A, req_`R, req_`W, req_`RD, req_`WD); \n  $display(\" NEW: A %x R %d W %d RD %x WD %x\", req`A, req`R, req`W, req`RD, req`WD); \n  end \n  always @(posedge clk) \n  if (~req`R & ~req`W & res`HOLD) \n  $display(\"%5d PIPECHECKER: %s INV #3 violation, hold asserted without read or write strobe\", $time, where); \n  always @(posedge clk) \n  if (~req_`R & |res`RD) \n  $display(\"%5d PIPECHECKER: %s INV #4 violation, data non-zero without a read in last cycle\", $time, where); \n `endif \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module named CRTClock generates a PixelClock signal based on the SystemClockFreq and CRTClockFreq inputs. It uses a counter to compare with the calculated MaxCounter value to generate the PixelClock output. The counter is incremented on the positive edge of the Clock signal and is reset to 0 when the Reset signal is asserted. The comparison of the counter with MaxCounter determines the value of the PixelClock output.\n\n Module header:\n\nmodule CRTClock(SystemClockFreq, CRTClockFreq, PixelClock, Reset, Clock);\n [/INST]\n", "output": "parameter SystemClockSize=10; \n  input [SystemClockSize-1:0] SystemClockFreq; \n  input [SystemClockSize-1:0] CRTClockFreq; \n  output PixelClock; \n  input Reset; \n  input Clock; \n  reg [SystemClockSize-1:0] counter; \n  wire [SystemClockSize-1:0] MaxCounter; \n  assign MaxCounter = (SystemClockFreq / CRTClockFreq) - 1; \n  assign PixelClock = counter > (MaxCounter >> 1); \n  always @ (posedge Clock or posedge Reset) \n  if (Reset) counter <= 0; \n  else begin \n  if (counter == MaxCounter) counter <= 0; \n  else counter <= counter + 1'd1; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a brush motor driver that controls the forward/backward direction, on/off state, PWM width and frequency, and provides read data functionality. It uses two clock signals for control and PWM generation. The module responds to reset signals and write commands to update the PWM settings and read data. It also generates PWM signals based on the PWM frequency and width settings and outputs them on the HX and HY wires.\n\n Module header:\n\nmodule brush_motor_driver(input rsi_MRST_reset,input csi_MCLK_clk,input [31:0] avs_ctrl_writedata,output [31:0] avs_ctrl_readdata,input [3:0] avs_ctrl_byteenable,input [2:0] avs_ctrl_address,input avs_ctrl_write,input avs_ctrl_read,output avs_ctrl_waitrequest,input rsi_PWMRST_reset,input csi_PWMCLK_clk,output HX,output HY);\n [/INST]\n", "output": "reg forward_back; \n  reg on_off; \n  reg [31:0] PWM_width; \n  reg [31:0] PWM_frequent; \n  reg [31:0] read_data; \n  assign avs_ctrl_readdata = read_data; \n  always@(posedge csi_MCLK_clk or posedge rsi_MRST_reset) \n  begin \n  if(rsi_MRST_reset) begin \n  read_data <= 0; \n  end \n  else if(avs_ctrl_write) \n  begin \n  case(avs_ctrl_address) \n  1: begin \n  if(avs_ctrl_byteenable[3]) PWM_frequent[31:24] <= avs_ctrl_writedata[31:24]; \n  if(avs_ctrl_byteenable[2]) PWM_frequent[23:16] <= avs_ctrl_writedata[23:16]; \n  if(avs_ctrl_byteenable[1]) PWM_frequent[15:8] <= avs_ctrl_writedata[15:8]; \n  if(avs_ctrl_byteenable[0]) PWM_frequent[7:0] <= avs_ctrl_writedata[7:0]; \n  end \n  2: begin \n  if(avs_ctrl_byteenable[3]) PWM_width[31:24] <= avs_ctrl_writedata[31:24]; \n  if(avs_ctrl_byteenable[2]) PWM_width[23:16] <= avs_ctrl_writedata[23:16]; \n  if(avs_ctrl_byteenable[1]) PWM_width[15:8] <= avs_ctrl_writedata[15:8]; \n  if(avs_ctrl_byteenable[0]) PWM_width[7:0] <= avs_ctrl_writedata[7:0]; \n  end \n  3: on_off <= avs_ctrl_writedata[0]; \n  4: forward_back <= avs_ctrl_writedata[0]; \n  default:; \n  endcase \n  end \n  else begin \n  case(avs_ctrl_address) \n  0: read_data <= 32'hEA680003; \n  1: read_data <= PWM_frequent; \n  2: read_data <= PWM_width; \n  3: read_data <= {31'b0,on_off}; \n  4: read_data <= {31'b0,forward_back}; \n  default: read_data <= 32'b0; \n  endcase \n  end \n  end \n  reg [31:0] PWM; \n  reg PWM_out; \n  always @ (posedge csi_PWMCLK_clk or posedge rsi_PWMRST_reset) \n  begin \n  if(rsi_PWMRST_reset) \n  PWM <= 32'b0; \n  else \n  begin \n  PWM <= PWM + PWM_frequent; \n  PWM_out <=(PWM > PWM_width) ? 1'b0:1'b1; \n  end \n  end \n  wire X, Y; \n  assign X = forward_back?PWM_out:0; \n  assign Y = forward_back?0:PWM_out; \n  assign HX = on_off?X:0; \n  assign HY = on_off?Y:0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `game_graph_simple_top` interfaces with a VGA display. It uses the `vga_sync` module to synchronize the signals and the `game_graph_simple` module to generate the pixel data. It updates the RGB value based on the pixel tick signal and the next RGB value, which is computed by the `game_graph_simple` module. The pixel data is derived from the input buttons (`btn`) and switches (`sw`). The `vsync` and `hsync` signals are also generated as outputs to control the monitor's synchronization.\n\n Module header:\n\nmodule game_graph_simple_top (input wire clk, reset,input wire [1:0] btn,input wire [1:0] sw,output wire hsync, vsync,output wire [2:0] rgb);\n [/INST]\n", "output": "wire [9:0] pixel_x, pixel_y; \n  wire video_on, pixel_tick; \n  reg [2:0] rgb_reg; \n  wire [2:0] rgb_next; \n  vga_sync vsync_unit \n (.clk(clk), .reset(reset), .hsync(hsync), .vsync(vsync),.video_on(video_on), .p_tick(pixel_tick),.pixel_x(pixel_x), .pixel_y(pixel_y)); \n  game_graph_simple game_graph_simple_unit \n (.clk(clk), .reset(reset), .btn(btn), .sw(sw),.video_on(video_on), .pix_x(pixel_x),.pix_y(pixel_y), .graph_rgb(rgb_next)); \n  always @(posedge clk) \n  if (pixel_tick) \n  rgb_reg <= rgb_next; \n  assign rgb = rgb_reg; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a DSP calculation unit. It performs operations based on the inputs charge_in, signal_in, delay_en, clk, store_strb, bunch_strb, and banana_corr. \n\nThe module uses registers to perform DSP calculations and signal delays, and updates the output signals pout and fb_cond based on the state of the inputs and internal signals. \n\nThe module also uses the clock signal to synchronize its operations, and performs arithmetic and conditional operations based on the input and internal signals.\n\n Module header:\n\nmodule DSPCalcModule(input signed [20:0] charge_in,input signed [14:0] signal_in,input delay_en,input clk,input store_strb,output reg signed [12:0] pout,input bunch_strb,input signed [12:0] banana_corr,output reg fb_cond);\n [/INST]\n", "output": "(* equivalent_register_removal = \"no\"*) reg [7:0] j; \n reg signed [36:0] DSPtemp; \n reg signed [12:0] DSPtemp2; \n reg signed [12:0] delayed =0; \n reg signed [36:0] DSPout; \n always @ (posedge clk) begin \n DSPtemp <= charge_in*signal_in; \n DSPout <= DSPtemp+{delayed, 12'b0}; \n pout<=DSPout[24:12]; \n end \n always @ (posedge clk) begin \n if (~store_strb) begin \n j<=7; \n  end \n else if (bunch_strb) begin j<=0; \n end \n else if (~bunch_strb) begin \n j<=j+1; \n end \n end \n reg [12:0] delayed_a; \n always @ (posedge clk) begin \n delayed<=delayed_a; \n if (~store_strb) begin \n delayed_a<=0; \n end \n else if (delay_en==1) begin \n if (j==5) delayed_a<=pout+banana_corr[12:2]; \n end \n end \n always @ (posedge clk) begin \n if (j==3||j==4) fb_cond<=1; \n else fb_cond<=0; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements an Altera standard synchronizer with a parameterizable depth. It includes features for metastable event injection simulation mode and verbose mode. The depth of the synchronizer is checked to ensure it is at least 2. The module includes a register `din_s1` and a shift register `dreg` to handle the synchronization of the input signal `din` with the clock signal `clk` and the reset signal `reset_n`. The output signal `dout` is assigned the value of the second most significant bit of the shift register `dreg`. The module also includes random number generation and handles metastable events.\n\n Module header:\n\nmodule altera_std_synchronizer_nocut (clk,reset_n,din,dout);\n [/INST]\n", "output": "parameter depth = 3; \n  input clk; \n  input reset_n; \n  input din; \n  output dout; \n  (* altera_attribute = {\"-name ADV_NETLIST_OPT_ALLOWED NEVER_ALLOW; -name SYNCHRONIZER_IDENTIFICATION FORCED; -name DONT_MERGE_REGISTER ON; -name PRESERVE_REGISTER ON \"} *) reg din_s1; \n  (* altera_attribute = {\"-name ADV_NETLIST_OPT_ALLOWED NEVER_ALLOW; -name DONT_MERGE_REGISTER ON; -name PRESERVE_REGISTER ON\"} *) reg [depth-2:0] dreg; \n  initial begin \n  if (depth <2) begin \n  $display(\"%m: Error: synchronizer length: %0d less than 2.\", depth); \n  end \n  end \n `ifdef __ALTERA_STD__METASTABLE_SIM \n  reg[31:0] RANDOM_SEED = 123456; \n  wire next_din_s1; \n  wire dout; \n  reg din_last; \n  reg random; \n  event metastable_event; \n  initial begin \n  $display(\"%m: Info: Metastable event injection simulation mode enabled\"); \n  end \n  always @(posedge clk) begin \n  if (reset_n == 0) \n  random <= $random(RANDOM_SEED); \n  else \n  random <= $random; \n  end \n  assign next_din_s1 = (din_last ^ din) ? random : din; \n  always @(posedge clk or negedge reset_n) begin \n  if (reset_n == 0) \n  din_last <= 1'b0; \n  else \n  din_last <= din; \n  end \n  always @(posedge clk or negedge reset_n) begin \n  if (reset_n == 0) \n  din_s1 <= 1'b0; \n  else \n  din_s1 <= next_din_s1; \n  end \n `else \n  always @(posedge clk or negedge reset_n) begin \n  if (reset_n == 0) \n  din_s1 <= 1'b0; \n  else \n  din_s1 <= din; \n  end \n `endif \n `ifdef __ALTERA_STD__METASTABLE_SIM_VERBOSE \n  always @(*) begin \n  if (reset_n && (din_last != din) && (random != din)) begin \n  $display(\"%m: Verbose Info: metastable event @ time %t\", $time); \n  ->metastable_event; \n  end \n  end \n `endif \n  generate \n  if (depth < 3) begin \n  always @(posedge clk or negedge reset_n) begin \n  if (reset_n == 0) \n  dreg <= {depth-1{1'b0}}; \n  else \n  dreg <= din_s1; \n  end \n  end else begin \n  always @(posedge clk or negedge reset_n) begin \n  if (reset_n == 0) \n  dreg <= {depth-1{1'b0}}; \n  else \n  dreg <= {dreg[depth-3:0], din_s1}; \n  end \n  end \n  endgenerate \n  assign dout = dreg[depth-2]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `incif_1uint32_CEnil` takes an input `process_input` of 33 bits and outputs a 32-bit `process_output`. It checks the most significant bit of the input and increments the lower 32 bits if the most significant bit is set, otherwise, it passes through the lower 32 bits unchanged.\n\n Module header:\n\nmodule incif_1uint32_CEnil(input CLK, input [32:0] process_input, output [31:0] process_output);\n [/INST]\n", "output": "parameter INSTANCE_NAME=\"INST\"; \n  wire [31:0] unnamedcast8585USEDMULTIPLEcast;assign unnamedcast8585USEDMULTIPLEcast = (process_input[31:0]); \n  assign process_output = (((process_input[32]))?({(unnamedcast8585USEDMULTIPLEcast+(32'd1))}):(unnamedcast8585USEDMULTIPLEcast)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is designed to act as a configurable digital-to-analog converter (DAC). It has input and output ports for clock, control, status, source and destination DAC enable, data, and valid signals. The module also includes a register to store the source DAC enable signal, source DAC valid signal, and destination DAC data. The status output concatenates the RP_ID with 24 zero bits. The module operates on the rising edge of the clock and assigns the source DAC enable with the destination DAC enable, the destination DAC data with the source DAC data, and the source DAC valid with the destination DAC valid.\n\n Module header:\n\nmodule prcfg_dac(clk,control,status,src_dac_enable,src_dac_data,src_dac_valid,dst_dac_enable,dst_dac_data,dst_dac_valid);\n [/INST]\n", "output": "localparam RP_ID = 8'hA0; \n  parameter CHANNEL_ID = 0; \n  input clk; \n  input [31:0] control; \n  output [31:0] status; \n  output src_dac_enable; \n  input [15:0] src_dac_data; \n  output src_dac_valid; \n  input dst_dac_enable; \n  output [15:0] dst_dac_data; \n  input dst_dac_valid; \n  reg src_dac_enable; \n  reg src_dac_valid; \n  reg [15:0] dst_dac_data; \n  assign status = {24'h0, RP_ID}; \n  always @(posedge clk) begin \n  src_dac_enable <= dst_dac_enable; \n  dst_dac_data <= src_dac_data; \n  src_dac_valid <= dst_dac_valid; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a 32-bit D flip-flop with asynchronous clear and synchronous enable. It stores the input d in the output q on the rising edge of the clock signal if the enable signal en is asserted, and resets the output q to 0 on the falling edge of the clear signal clrn.\n\n Module header:\n\nmodule dffe32 (d, clk, clrn, en, q);\n [/INST]\n", "output": "input [31:0] d; \n input clk, clrn, en; \n output reg [31:0] q; \n always @(posedge clk or negedge clrn) \n begin \n  if (clrn == 0) \n  q <= 0; \n  else if (en) \n  q <= d; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a gated D latch with a synchronous reset. The output Q is initialized to an undefined value. The module has a select signal SRMODE to determine the latch operation. When the nSR signal is low, the Q output follows the value of SRMODE. When the nSR signal is high, the Q output follows the input D on the falling edge of the clock signal nCLK.\n\n Module header:\n\nmodule GP_DLATCHSR(input D, input nCLK, input nSR, output reg Q);\n [/INST]\n", "output": "parameter [0:0] INIT = 1'bx; \n  parameter[0:0] SRMODE = 1'bx; \n  initial Q = INIT; \n  always @(*) begin \n  if(!nSR) \n  Q <= SRMODE; \n  else if(!nCLK) \n  Q <= D; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module fakedelay simply copies the input d to the output q on every clock cycle. The parameter WIDTH specifies the width of the input and output bus.\n\n Module header:\n\nmodule fakedelay(d,clk,q);\n [/INST]\n", "output": "parameter WIDTH=32; \n input [WIDTH-1:0] d; \n input clk; \n output [WIDTH-1:0] q; \n assign q=d; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `f4_TECH_NAND2` is designed to implement a 2-input NAND gate. It takes a 2-bit input 'in' and produces a single output 'out' that represents the logical NAND operation on the inputs. The module uses the bitwise AND operation on the inputs and then applies a bitwise NOT operation to obtain the NAND result. This is a low-level representation of a NAND gate.\n\n Module header:\n\nmodule f4_TECH_NAND2(input [1:0] in, output out);\n [/INST]\n", "output": "assign out = ~(&in); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, named adder_carry, performs binary addition with carry-out. It takes three inputs: p, g, and cin, representing the two input bits and the carry-in bit. The module then generates two outputs: sumout, which represents the sum of the inputs, and cout, which represents the carry-out. The sumout is computed using an XOR gate, while the cout is computed using an OR gate. If the input p is 1, the carry-out is equal to the carry-in; otherwise, it is equal to the input g.\n\n Module header:\n\nmodule adder_carry(output sumout,output cout,input p,input g,input cin);\n [/INST]\n", "output": "assign sumout = p ^ cin; \n  assign cout = p ? cin : g; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a counter with various control inputs. It can load data, increment the counter, reset the counter, and has inputs to enable or disable these operations. The counter can be loaded with the input data when the sload input is asserted. The counter can also be incremented if the clk_en input is enabled. The counter value is held if cnt_en is disabled, and it can be reset to 0 if aset is asserted. The counter value is stored in the q output.\n\n Module header:\n\nmodule dummy_counter (data,clock,clk_en,cnt_en,aset,sload,q);\n [/INST]\n", "output": "input [31:2] data; \n input clock; \n input clk_en; \n input cnt_en; \n input aset; \n input sload; \n output [`PC_WIDTH-1:0] q; \n reg [`PC_WIDTH-1:0] q; \n wire [2:0] sload_cnten_aset; \n assign sload_cnten_aset [0] = sload; \n assign sload_cnten_aset [1] = cnt_en; \n assign sload_cnten_aset [2] = aset; \n always @ (posedge clock) \n begin \n case (sload_cnten_aset) \n  3'b000: \n  q <= q; \n  3'b011: \n  q <= q; \n  3'b110: \n  q <= q; \n  3'b111: \n  q <= q; \n  3'b101: \n  q <= q; \n  3'b100: \n  q <= data; \n  3'b010: \n  begin \n  if (clk_en) \n  q <= q+1; \n  else \n  q <= q; \n  end \n  3'b001: \n  q <= 29'b00000000000000000000000000000; \n  default: \n  q <= q; \n endcase \n end \n  endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a CIC strober, with a parameterized width for the rate input. It uses a counter to generate a slow strobe signal based on the fast strobe signal, clock, reset, and enable inputs. The counter is updated on the positive edge of the clock signal and is reset to 0 when the reset input is asserted. The counter is incremented by the rate value when the enable input is de-asserted, and it decrements when the fast strobe signal is active. The module also generates a slow strobe output based on the counter value, enable, and fast strobe signal.\n\n Module header:\n\nmodule cic_strober #(parameter WIDTH=8) ( input clock,input reset,input enable,input [WIDTH-1:0] rate,input strobe_fast,output wire strobe_slow );\n [/INST]\n", "output": "reg [WIDTH-1:0] counter; \n  wire now = (counter==1); \n  assign strobe_slow = now && enable && strobe_fast; \n  always @(posedge clock) \n  if(reset) \n  counter <= 0; \n  else if (~enable) \n  counter <= rate; \n  else if(strobe_fast) \n  if(now) \n  counter <= rate; \n  else \n  counter <= counter - 1; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, `meganode_wrapper`, instantiates a meganode and configures clock signals using an Altera PLL. It connects various input and output signals to the meganode instance. The module also sets specific values for signals like `mextra`, `scl`, and `sda`. Additionally, it assigns a specific value to the `outb` signal.\n\n Module header:\n\nmodule meganode_wrapper ( input clk, output led, output [3:0] enet_leds,output enet_rst, output enet_clk, output enet_mdc, inout enet_mdio,output [1:0] enet_txen, output [3:0] enet_txd,input [1:0] enet_rxdv, input [3:0] enet_rxd,output [4:0] usb_oe, output [4:0] usb_pwr,inout [4:0] usb_vp, inout [4:0] usb_vm,output [2:0] mosfet_hi, output [2:0] mosfet_lo, output mosfet_en,output [2:0] mclk, input [2:0] mdata,output [15:0] outb,input mcu_io,output mcu_spim_cs, output mcu_spim_sclk,output mcu_spim_mosi, input mcu_spim_miso,input mcu_spis_cs, input mcu_spis_sclk,input mcu_spis_mosi, output mcu_spis_miso,output scl, inout sda, output mextra);\n [/INST]\n", "output": "wire clk_20, clk_25, clk_48, clk_50, clk_100; \n wire pll_locked, pll_reset; \n altera_pll \n #(.fractional_vco_multiplier(\"false\"),.reference_clock_frequency(\"25.0 MHz\"),.operation_mode(\"direct\"), .number_of_clocks(5),.output_clock_frequency0(\"50MHz\"), .phase_shift0(\"0 ps\"), .duty_cycle0(50),.output_clock_frequency1(\"25MHz\"), .phase_shift1(\"0 ps\"), .duty_cycle1(50),.output_clock_frequency2(\"20MHz\"), .phase_shift2(\"0 ps\"), .duty_cycle2(50),.output_clock_frequency3(\"48MHz\"), .phase_shift3(\"0 ps\"), .duty_cycle3(50),.output_clock_frequency4(\"100MHz\"), .phase_shift4(\"0 ps\"), .duty_cycle4(50),.pll_type(\"General\"), .pll_subtype(\"General\")) altera_pll_inst (.refclk(clk), .rst(pll_reset), .locked(pll_locked),.outclk({clk_100, clk_48, clk_20, clk_25, clk_50}),.fboutclk(), .fbclk(1'b0)); \n assign enet_clk = ~clk_50; \n assign pll_reset = 1'b0; \n assign mextra = 1'b0; \n assign scl = 1'b1; \n assign sda = 1'bz; \n meganode meganode_inst \n ( .clk_20(clk_20), .clk_25(clk_25), .clk_50(clk_50), .clk_48(clk_48), .clk_100(clk_100),.enet_rst(enet_rst), .enet_mdc(enet_mdc), .enet_mdio(enet_mdio),.enet_txen(enet_txen), .enet_txd(enet_txd),.enet_rxdv(enet_rxdv), .enet_rxd(enet_rxd),.enet_leds(enet_leds),.usb_oe(usb_oe), .usb_pwr(usb_pwr), .usb_vp(usb_vp), .usb_vm(usb_vm),.mosfet_hi(mosfet_hi), .mosfet_lo(mosfet_lo), .mclk(mclk), .mdata(mdata),.mosfet_en(mosfet_en),.mcu_io(mcu_io),.mcu_spim_cs(mcu_spim_cs), .mcu_spim_sclk(mcu_spim_sclk),.mcu_spim_mosi(mcu_spim_mosi), .mcu_spim_miso(mcu_spim_miso),.mcu_spis_cs(mcu_spis_cs), .mcu_spis_sclk(mcu_spis_sclk),.mcu_spis_mosi(mcu_spis_mosi), .mcu_spis_miso(mcu_spis_miso),.led(led)); \n assign outb = {13'h0, mcu_spis_mosi, mcu_spis_sclk, mcu_spis_cs}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a dual-port RAM with options for bypassing the write data to the read data. It includes two write enable signals, two address signals, and two sets of write and read data signals. The module contains logic to handle the bypass functionality for both read ports A and B. The read data for each port is selected based on the bypass conditions and the write data inputs. The bypass conditions are based on the bypass settings, write enable signals, and address matching. The module operates on the positive edge of the clock and includes additional logic for handling read and write data when bypassing is enabled.\n\n Module header:\n\nmodule dpram_bbs #( parameter MEMD = 16,parameter DATW = 32,parameter BYPS = 1 ,parameter ZERO = 0 ,parameter FILE = \"\")( input clk ,input WEnb_A ,input WEnb_B ,input [`log2(MEMD)-1:0] Addr_A ,input [`log2(MEMD)-1:0] Addr_B ,input [DATW -1:0] WData_A,input [DATW -1:0] WData_B,output reg [DATW -1:0] RData_A,output reg [DATW -1:0] RData_B);\n [/INST]\n", "output": "wire [DATW-1:0] RData_Ai; \n  wire [DATW-1:0] RData_Bi; \n dpram #( .MEMD (MEMD ),.DATW (DATW ),.ZERO (ZERO ),.FILE (FILE )) \n dprami ( .clk (clk ),.WEnb_A (WEnb_A ),.WEnb_B (WEnb_B ),.Addr_A (Addr_A ),.Addr_B (Addr_B ),.WData_A(WData_A ),.WData_B(WData_B ),.RData_A(RData_Ai),.RData_B(RData_Bi)); \n  reg WEnb_Ar; \n  reg WEnb_Br; \n  reg [`log2(MEMD)-1:0] Addr_Ar; \n  reg [`log2(MEMD)-1:0] Addr_Br; \n  reg [DATW-1:0] WData_Br; \n  reg [DATW-1:0] WData_Ar; \n  always @(posedge clk) begin \n  WEnb_Ar <= WEnb_A ; \n  WEnb_Br <= WEnb_B ; \n  Addr_Ar <= Addr_A; \n  Addr_Br <= Addr_B; \n  WData_Ar <= WData_A; \n  WData_Br <= WData_B; \n  end \n  wire bypsA1,bypsA2,bypsB1,bypsB2; \n  assign bypsA1 = (BYPS >= 1) && WEnb_Br && !WEnb_Ar && (Addr_Br == Addr_Ar); \n  assign bypsA2 = (BYPS == 2) && WEnb_B && !WEnb_Ar && (Addr_B == Addr_Ar); \n  assign bypsB1 = (BYPS >= 1) && WEnb_Ar && !WEnb_Br && (Addr_Ar == Addr_Br); \n  assign bypsB2 = (BYPS == 2) && WEnb_A && !WEnb_Br && (Addr_A == Addr_Br); \n  always @* \n  if (bypsA2) RData_A = WData_B ; \n  else if (bypsA1) RData_A = WData_Br; \n  else RData_A = RData_Ai; \n  always @* \n  if (bypsB2) RData_B = WData_A ; \n  else if (bypsB1) RData_B = WData_Ar; \n  else RData_B = RData_Bi; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `FramerCtrl` implements a state machine to control the start of a data frame. It has an 8-bit index register and transitions between 4 states based on the syncFlag input. The SOF signal indicates the start of a frame, and it resets the index and the state machine. The module handles transitions based on the syncFlag and the value of the index to detect the start of a frame.\n\n Module header:\n\nmodule FramerCtrl (SOF,state,syncFlag,clk,reset_n);\n [/INST]\n", "output": "output SOF; \n reg SOF; \n output [2:0] state; \n reg [2:0] state; \n input syncFlag; \n input clk; \n input reset_n; \n reg [7:0] index; \n always @(posedge clk, negedge reset_n) begin: FRAMERCTRL_FSM \n  if ((reset_n == 0)) begin \n  SOF <= 0; \n  index <= 0; \n  state <= 3'b001; \n  end \n  else begin \n  index <= ((index + 1) % 8); \n  SOF <= 0; \n  casez (state) \n  3'b??1: begin \n  index <= 1; \n  if (syncFlag) begin \n  state <= 3'b010; \n  end \n  end \n  3'b?1?: begin \n  if ((index == 0)) begin \n  if (syncFlag) begin \n  state <= 3'b100; \n  end \n  else begin \n  state <= 3'b001; \n  end \n  end \n  end \n  3'b1??: begin \n  if ((index == 0)) begin \n  if ((!syncFlag)) begin \n  state <= 3'b001; \n  end \n  end \n  SOF <= (index == (8 - 1)); \n  end \n  default: begin \n  $finish; \n  end \n  endcase \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements an altpriority encoder that takes an 8-bit input data and produces a 3-bit output q. It uses two instances of sub-modules, altpriority_encoder15 and altpriority_encoder16, each handling 4 bits of the input data. The outputs of these sub-modules are combined to form the final output q using bitwise operations.\n\n Module header:\n\nmodule acl_fp_add_sub_fast_altpriority_encoder_bv7 (data,q) ;\n [/INST]\n", "output": "input [7:0] data; \n  output [2:0] q; \n  wire [1:0] wire_altpriority_encoder15_q; \n  wire [1:0] wire_altpriority_encoder16_q; \n  wire wire_altpriority_encoder16_zero; \n  acl_fp_add_sub_fast_altpriority_encoder_6v7 altpriority_encoder15 \n (.data(data[3:0]),.q(wire_altpriority_encoder15_q)); \n  acl_fp_add_sub_fast_altpriority_encoder_6e8 altpriority_encoder16 \n (.data(data[7:4]),.q(wire_altpriority_encoder16_q),.zero(wire_altpriority_encoder16_zero)); \n  assign \n  q = {(~ wire_altpriority_encoder16_zero), (({2{wire_altpriority_encoder16_zero}} & wire_altpriority_encoder15_q) | ({2{(~ wire_altpriority_encoder16_zero)}} & wire_altpriority_encoder16_q))}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module instantiates a QAM demodulator and includes a RAM to store the QAM demodulator output. The module has input ports for address and clock enable signals, as well as output ports for the demodulator output. The RAM is initialized with QAM demodulator output from a file using the `$readmemh()` function. The demodulator output is accessed based on the address and clock enable signals and written to the respective output registers. The module operates on a specified data width and address width parameters, and the RAM size is also defined by a parameter.\n\n Module header:\n\nmodule qam_dem_top_mounstrito_cos_lut_rom (addr0, ce0, q0, addr1, ce1, q1, clk);\n [/INST]\n", "output": "parameter DWIDTH = 15; \n parameter AWIDTH = 10; \n parameter MEM_SIZE = 1024; \n input[AWIDTH-1:0] addr0; \n input ce0; \n output reg[DWIDTH-1:0] q0; \n input[AWIDTH-1:0] addr1; \n input ce1; \n output reg[DWIDTH-1:0] q1; \n input clk; \n reg [DWIDTH-1:0] ram[MEM_SIZE-1:0]; \n initial begin \n  $readmemh(\"./qam_dem_top_mounstrito_cos_lut_rom.dat\", ram); \n end \n always @(posedge clk) \n begin \n  if (ce0) \n  begin \n  q0 <= ram[addr0]; \n  end \n end \n always @(posedge clk) \n begin \n  if (ce1) \n  begin \n  q1 <= ram[addr1]; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a state machine with two states, PE_DC_RST and PE_DC_INP, based on the input signals i_RESET_KES, i_stop_dec, and i_EXECUTE_PE_DC. The module also includes registers to store the current state, next state, and input buffers. The module has conditional logic to update the state and input buffers based on the current and next states. The output is determined based on the input and current state using a parallel FFM gate, and the result is assigned to o_S_out and o_coef_2ip1.\n\n Module header:\n\nmodule d_KES_PE_DC_NMLodr (input wire i_clk,input wire i_RESET_KES,input wire i_stop_dec,input wire i_EXECUTE_PE_DC,input wire [`D_KES_GF_ORDER-1:0] i_S_in,input wire [`D_KES_GF_ORDER-1:0] i_v_2i_X,output wire [`D_KES_GF_ORDER-1:0] o_S_out,output wire [`D_KES_GF_ORDER-1:0] o_coef_2ip1);\n [/INST]\n", "output": "parameter [11:0] D_KES_VALUE_ZERO = 12'b0000_0000_0000; \n  parameter [11:0] D_KES_VALUE_ONE = 12'b0000_0000_0001; \n  parameter PE_DC_RST = 2'b01; \n  parameter PE_DC_INP = 2'b10; \n  reg [1:0] r_cur_state; \n  reg [1:0] r_nxt_state; \n  reg [`D_KES_GF_ORDER-1:0] r_S_in_b; \n  reg [`D_KES_GF_ORDER-1:0] r_v_2i_X_b; \n  wire [`D_KES_GF_ORDER-1:0] w_coef_term; \n  always @ (posedge i_clk) \n  begin \n  if ((i_RESET_KES) || (i_stop_dec)) begin \n  r_cur_state <= PE_DC_RST; \n  end else begin \n  r_cur_state <= r_nxt_state; \n  end \n  end \n  always @ ( * ) \n  begin \n  case (r_cur_state) \n  PE_DC_RST: begin \n  r_nxt_state <= (i_EXECUTE_PE_DC)? (PE_DC_INP):(PE_DC_RST); \n  end \n  PE_DC_INP: begin \n  r_nxt_state <= PE_DC_RST; \n  end \n  default: begin \n  r_nxt_state <= PE_DC_RST; \n  end \n  endcase \n  end \n  always @ (posedge i_clk) \n  begin \n  if ((i_RESET_KES) || (i_stop_dec)) begin \n  r_S_in_b <= 0; \n  r_v_2i_X_b <= 0; \n  end \n  else begin \n  case (r_nxt_state) \n  PE_DC_RST: begin \n  r_S_in_b <= r_S_in_b; \n  r_v_2i_X_b <= r_v_2i_X_b; \n  end \n  PE_DC_INP: begin \n  r_S_in_b <= i_S_in; \n  r_v_2i_X_b <= i_v_2i_X; \n  end \n  default: begin \n  r_S_in_b <= r_S_in_b; \n  r_v_2i_X_b <= r_v_2i_X_b; \n  end \n  endcase \n  end \n  end \n d_parallel_FFM_gate_GF12 d_S_in_FFM_v_2i_X (.i_poly_form_A (r_S_in_b[`D_KES_GF_ORDER-1:0]),.i_poly_form_B (r_v_2i_X_b[`D_KES_GF_ORDER-1:0]),.o_poly_form_result(w_coef_term[`D_KES_GF_ORDER-1:0])); \n  assign o_S_out[`D_KES_GF_ORDER-1:0] = r_S_in_b[`D_KES_GF_ORDER-1:0]; \n  assign o_coef_2ip1 = w_coef_term; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a flip-flop synchronizer that takes an input in0 and a clock signal s_aclk, and produces an output out that is synchronized to the clock. The module uses an asynchronous reset and the output signal is registered using a flip-flop. The flip-flop is instantiated with the input in0, clock s_aclk, and the output Q_reg.\n\n Module header:\n\nmodule system_auto_cc_0_synchronizer_ff (out,in0,s_aclk);\n [/INST]\n", "output": "output out; \n  input [0:0]in0; \n  input s_aclk; \n  (* async_reg = \"true\" *) (* msgon = \"true\" *) wire Q_reg; \n  wire [0:0]in0; \n  wire s_aclk; \n  assign out = Q_reg; \n  (* ASYNC_REG *) \n  (* KEEP = \"yes\" *) \n  (* msgon = \"true\" *) \n FDRE #(.INIT(1'b0)) \n  \\Q_reg_reg[0] \n (.C(s_aclk),.CE(1'b1),.D(in0),.Q(Q_reg),.R(1'b0)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a 16-bit variable, having input and output signals for write and read requests, acknowledgments, and data. It uses internal wires and assigns values to the read data output based on the internal data. It loads the input data into internal registers based on write requests and handles the write acknowledgment through modules.\n\n Module header:\n\nmodule BrzVariable_16_1_s0_ (write_0r, write_0a, write_0d,read_0r, read_0a, read_0d);\n [/INST]\n", "output": "input write_0r; \n  output write_0a; \n  input [15:0] write_0d; \n  input read_0r; \n  output read_0a; \n  output [15:0] read_0d; \n  wire [15:0] data_0n; \n  wire nWriteReq_0n; \n  wire bWriteReq_0n; \n  wire nbWriteReq_0n; \n  assign read_0a = read_0r; \n  assign read_0d[0] = data_0n[0]; \n  assign read_0d[1] = data_0n[1]; \n  assign read_0d[2] = data_0n[2]; \n  assign read_0d[3] = data_0n[3]; \n  assign read_0d[4] = data_0n[4]; \n  assign read_0d[5] = data_0n[5]; \n  assign read_0d[6] = data_0n[6]; \n  assign read_0d[7] = data_0n[7]; \n  assign read_0d[8] = data_0n[8]; \n  assign read_0d[9] = data_0n[9]; \n  assign read_0d[10] = data_0n[10]; \n  assign read_0d[11] = data_0n[11]; \n  assign read_0d[12] = data_0n[12]; \n  assign read_0d[13] = data_0n[13]; \n  assign read_0d[14] = data_0n[14]; \n  assign read_0d[15] = data_0n[15]; \n  LD1 I17 (write_0d[0], bWriteReq_0n, data_0n[0]); \n  LD1 I18 (write_0d[1], bWriteReq_0n, data_0n[1]); \n  LD1 I19 (write_0d[2], bWriteReq_0n, data_0n[2]); \n  LD1 I20 (write_0d[3], bWriteReq_0n, data_0n[3]); \n  LD1 I21 (write_0d[4], bWriteReq_0n, data_0n[4]); \n  LD1 I22 (write_0d[5], bWriteReq_0n, data_0n[5]); \n  LD1 I23 (write_0d[6], bWriteReq_0n, data_0n[6]); \n  LD1 I24 (write_0d[7], bWriteReq_0n, data_0n[7]); \n  LD1 I25 (write_0d[8], bWriteReq_0n, data_0n[8]); \n  LD1 I26 (write_0d[9], bWriteReq_0n, data_0n[9]); \n  LD1 I27 (write_0d[10], bWriteReq_0n, data_0n[10]); \n  LD1 I28 (write_0d[11], bWriteReq_0n, data_0n[11]); \n  LD1 I29 (write_0d[12], bWriteReq_0n, data_0n[12]); \n  LD1 I30 (write_0d[13], bWriteReq_0n, data_0n[13]); \n  LD1 I31 (write_0d[14], bWriteReq_0n, data_0n[14]); \n  LD1 I32 (write_0d[15], bWriteReq_0n, data_0n[15]); \n  IV I33 (write_0a, nbWriteReq_0n); \n  IV I34 (nbWriteReq_0n, bWriteReq_0n); \n  IV I35 (bWriteReq_0n, nWriteReq_0n); \n  IV I36 (nWriteReq_0n, write_0r); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a reset block for various digital and analog components. It takes input signals for digital and analog resets, PLL reset, and PLL enable. It generates output signals for digital and analog resets, as well as the PLL reset. The output signals are generated based on the input signals and a hard reset condition, which is a combination of the PLL reset and its enable signal. The module uses logical operations to determine the output values for each reset signal based on the hard reset condition and the input reset signals.\n\n Module header:\n\nmodule altgxb_xgm_reset_block (txdigitalreset,rxdigitalreset,rxanalogreset,pllreset,pllenable,txdigitalresetout,rxdigitalresetout,txanalogresetout,rxanalogresetout,pllresetout);\n [/INST]\n", "output": "input [3:0] txdigitalreset; \n  input [3:0] rxdigitalreset; \n  input [3:0] rxanalogreset; \n  input pllreset; \n  input pllenable; \n  output [3:0] txdigitalresetout; \n  output [3:0] rxdigitalresetout; \n  output [3:0] txanalogresetout; \n  output [3:0] rxanalogresetout; \n  output pllresetout; \n  wire HARD_RESET; \n  assign HARD_RESET = pllreset || !pllenable; \n  assign rxanalogresetout = {(HARD_RESET | rxanalogreset[3]), \n  (HARD_RESET | rxanalogreset[2]), \n  (HARD_RESET | rxanalogreset[1]), \n  (HARD_RESET | rxanalogreset[0])}; \n  assign txanalogresetout = {HARD_RESET, HARD_RESET, \n  HARD_RESET, HARD_RESET}; \n  assign pllresetout = rxanalogresetout[0] & rxanalogresetout[1] & \n  rxanalogresetout[2] & rxanalogresetout[3] & \n  txanalogresetout[0] & txanalogresetout[1] & \n  txanalogresetout[2] & txanalogresetout[3]; \n  assign rxdigitalresetout = {(HARD_RESET | rxdigitalreset[3]), \n  (HARD_RESET | rxdigitalreset[2]), \n  (HARD_RESET | rxdigitalreset[1]), \n  (HARD_RESET | rxdigitalreset[0])}; \n  assign txdigitalresetout = {(HARD_RESET | txdigitalreset[3]), \n  (HARD_RESET | txdigitalreset[2]), \n  (HARD_RESET | txdigitalreset[1]), \n  (HARD_RESET | txdigitalreset[0])}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a segment display controller with PWM (Pulse Width Modulation) brightness control. It generates signals to drive segment displays based on the input clock, reset signals, enable signal, clock division ratio, and brightness control input. It also handles the synchronization of the segment output and controls the display brightness through PWM. The module includes a counter for strobe and segment select, and it implements asynchronous and synchronous resets. The outputs of the module include segment data and segment select signals for driving the segment display.\n\n Module header:\n\nmodule sseg_ctrl #(parameter n_digits = 8,parameter n_segs = 8) (input clk_i,input rst_i,input async_rst_i,input enable_i,input [15:0] clk_div_i,input [7:0] brightness_i,input [n_digits*n_segs-1:0] segments_i,output [n_segs-1:0] seg_o,output [n_digits-1:0] seg_sel_o,output sync_o);\n [/INST]\n", "output": "reg [15:0] cnt_strobe_reg; \n  wire strobe = (enable_i & cnt_strobe_reg == 16'b0); \n  always @(posedge clk_i or posedge async_rst_i) \n  if (async_rst_i) \n  cnt_strobe_reg <= 16'b0; \n  else if (rst_i | ~enable_i) \n  cnt_strobe_reg <= 16'b0; \n  else if (strobe) \n  cnt_strobe_reg <= clk_div_i; \n  else \n  cnt_strobe_reg <= cnt_strobe_reg - 16'd1; \n  reg [7:0] cnt_strobe_dig_reg; \n  always @(posedge clk_i or posedge async_rst_i) \n  if (async_rst_i) \n  cnt_strobe_dig_reg <= 8'b0; \n  else if (rst_i | ~enable_i) \n  cnt_strobe_dig_reg <= 8'b0; \n  else if (strobe) \n  cnt_strobe_dig_reg <= cnt_strobe_dig_reg - 8'd1; \n  wire strobe_dig = (strobe & cnt_strobe_dig_reg == 8'hff); \n  reg pwm_reg; \n  always @(posedge clk_i or posedge async_rst_i) \n  if (async_rst_i) \n  pwm_reg <= 1'b0; \n  else if (rst_i | ~enable_i) \n  pwm_reg <= 1'b0; \n  else if (strobe) \n  pwm_reg <= (cnt_strobe_dig_reg <= brightness_i); \n  reg [4:0] cnt_strobe_frame_reg; \n  always @(posedge clk_i or posedge async_rst_i) \n  if (async_rst_i) \n  cnt_strobe_frame_reg <= 5'b0; \n  else if (rst_i | ~enable_i) \n  cnt_strobe_frame_reg <= 5'b0; \n  else if (strobe_dig &cnt_strobe_frame_reg == 5'b0) \n  cnt_strobe_frame_reg <= n_digits - 1; \n  else if (strobe_dig) \n  cnt_strobe_frame_reg <= cnt_strobe_frame_reg - 5'd1; \n  wire strobe_frame = (strobe_dig & cnt_strobe_frame_reg == 5'b0); \n  wire [n_digits-1:0] seg_sel_reg_new; \n  assign seg_sel_reg_new = {strobe_frame, seg_sel_reg[n_digits-1:1]}; \n  reg [n_digits-1:0] seg_sel_reg; \n  always @(posedge clk_i or posedge async_rst_i) \n  if (async_rst_i) \n  seg_sel_reg <= 0; \n  else if (rst_i | ~enable_i) \n  seg_sel_reg <= 0; \n  else if (strobe_dig) \n  seg_sel_reg <= seg_sel_reg_new; \n  assign seg_sel_o = seg_sel_reg; \n  integer i; \n  reg [n_segs-1:0] seg_reg; \n  always @(posedge clk_i or posedge async_rst_i) \n  if (async_rst_i) \n  seg_reg <= 0; \n  else if (rst_i | ~enable_i) \n  seg_reg <= 0; \n  else if (strobe_dig) \n  for (i = 0; i < n_digits; i = i + 1) \n  if (seg_sel_reg_new[i]) \n  seg_reg <= segments_i[n_segs*(n_digits-i)-1 -: n_segs]; \n  assign seg_o = seg_reg & {n_segs{pwm_reg}}; \n  assign sync_o = strobe_frame; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module named ADD2 takes two input signals, A and B, and performs a logical AND operation on them. The result is assigned to the output signal Y.\n\n Module header:\n\nmodule ADD2 (input A, B,output Y);\n [/INST]\n", "output": "assign Y = A & B; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes a 32-bit input `addr` and assigns an 8-bit output `mod` based on specific bit patterns within `addr`. If none of the patterns match, `mod` is assigned 0. The module also assigns a 32-bit output `eff_addr` by concatenating a value derived from `mod` with specific bits of `addr`.\n\n Module header:\n\nmodule mm(addr, mod, eff_addr);\n [/INST]\n", "output": "input [31:0] addr; \n  output [7:0] mod; \n  output [31:0] eff_addr; \n  assign mod = (addr[31:20] == 12'h000) ? 0 : \n  (addr[31:24] == 8'h10) ? 1 : \n  (addr[31:20] == 12'hf00) ? 2 : \n  (addr[31:20] == 12'hf01) ? 3 : \n  (addr[31:20] == 12'hf02) ? 4 : \n  (addr[31:20] == 12'hf03) ? 5 : \n  (addr[31:20] == 12'hf04) ? 6 : \n  (addr[31:20] == 12'hf05) ? 7 : \n  (addr[31:20] == 12'hf06) ? 8 : \n  (addr[31:20] == 12'hf07) ? 10 : \n  (addr[31:20] == 12'hf08) ? 11 : \n  (addr[31:20] == 12'hf0a) ? 9 : \n  0; \n  assign eff_addr = (mod == 8'h01) ? {8'h00,addr[23:0]} : {12'h000,addr[19:0]}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a color space converter from CrYCb to RGB format. It takes inputs such as clock signal, vertical sync, horizontal sync, data enable, and data. It produces outputs including RGB vertical sync, horizontal sync, data enable, and data.\n\nThe module uses registers to store the RGB sync and data signals. It instantiates three submodules, one for each color component (R, G, B), and combines the outputs to generate the RGB signals. Each submodule utilizes the given inputs to perform color space conversion and produce the individual color component signals.\n\nThe design leverages the clock signal to synchronize the generation of the RGB signals. The module essentially functions as a top-level control and data path interface for the color space conversion process.\n\n Module header:\n\nmodule cf_csc_CrYCb2RGB (clk,CrYCb_vs,CrYCb_hs,CrYCb_de,CrYCb_data,RGB_vs,RGB_hs,RGB_de,RGB_data);\n [/INST]\n", "output": "input clk; \n  input CrYCb_vs; \n  input CrYCb_hs; \n  input CrYCb_de; \n  input [23:0] CrYCb_data; \n  output RGB_vs; \n  output RGB_hs; \n  output RGB_de; \n  output [23:0] RGB_data; \n  reg RGB_vs = 'd0; \n  reg RGB_hs = 'd0; \n  reg RGB_de = 'd0; \n  reg [23:0] RGB_data = 'd0; \n  wire R_vs_s; \n  wire R_hs_s; \n  wire R_de_s; \n  wire [ 7:0] R_data_s; \n  wire G_vs_s; \n  wire G_hs_s; \n  wire G_de_s; \n  wire [ 7:0] G_data_s; \n  wire B_vs_s; \n  wire B_hs_s; \n  wire B_de_s; \n  wire [ 7:0] B_data_s; \n  always @(posedge clk) begin \n  RGB_vs <= R_vs_s & G_vs_s & B_vs_s; \n  RGB_hs <= R_hs_s & G_hs_s & B_hs_s; \n  RGB_de <= R_de_s & G_de_s & B_de_s; \n  RGB_data <= {R_data_s, G_data_s, B_data_s}; \n  end \n cf_csc_1 i_csc_R (.clk (clk),.vs (CrYCb_vs),.hs (CrYCb_hs),.de (CrYCb_de),.data (CrYCb_data),.C1 (17'h01989),.C2 (17'h012a1),.C3 (17'h00000),.C4 (25'h10deebc),.csc_vs (R_vs_s),.csc_hs (R_hs_s),.csc_de (R_de_s),.csc_data_1 (R_data_s)); \n cf_csc_1 i_csc_G (.clk (clk),.vs (CrYCb_vs),.hs (CrYCb_hs),.de (CrYCb_de),.data (CrYCb_data),.C1 (17'h10d01),.C2 (17'h012a1),.C3 (17'h10644),.C4 (25'h0087937),.csc_vs (G_vs_s),.csc_hs (G_hs_s),.csc_de (G_de_s),.csc_data_1 (G_data_s)); \n cf_csc_1 i_csc_B (.clk (clk),.vs (CrYCb_vs),.hs (CrYCb_hs),.de (CrYCb_de),.data (CrYCb_data),.C1 (17'h00000),.C2 (17'h012a1),.C3 (17'h02046),.C4 (25'h1114d60),.csc_vs (B_vs_s),.csc_hs (B_hs_s),.csc_de (B_de_s),.csc_data_1 (B_data_s)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a parameterized 4-bit synchronizer flip-flop. It takes in 4-bit input Q and synchronizes it to the positive edge of the clock signal s_aclk. The synchronized output is stored in the 4-bit output D. The module uses four FDCE (flip-flop with asynchronous reset) components to synchronize each bit of the input. The asynchronous reset signal (\\ngwrdrst.grst.g7serrst.rd_rst_reg_reg[1]) is used to clear the flip-flops. Each flip-flop has its own Q_reg, which holds the synchronized output. The module also utilizes the ASYNC_REG attribute to specify that the flip-flop is asynchronous.\n\n Module header:\n\nmodule system_auto_cc_0_synchronizer_ff__parameterized0_63 (D,Q,s_aclk,\\ngwrdrst.grst.g7serrst.rd_rst_reg_reg[1] );\n [/INST]\n", "output": "output [3:0]D; \n  input [3:0]Q; \n  input s_aclk; \n  input [0:0]\\ngwrdrst.grst.g7serrst.rd_rst_reg_reg[1] ; \n  wire [3:0]Q; \n  (* async_reg = \"true\" *) (* msgon = \"true\" *) wire [3:0]Q_reg; \n  wire [0:0]\\ngwrdrst.grst.g7serrst.rd_rst_reg_reg[1] ; \n  wire s_aclk; \n  assign D[3:0] = Q_reg; \n  (* ASYNC_REG *) \n  (* KEEP = \"yes\" *) \n  (* msgon = \"true\" *) \n FDCE #(.INIT(1'b0)) \n  \\Q_reg_reg[0] \n (.C(s_aclk),.CE(1'b1),.CLR(\\ngwrdrst.grst.g7serrst.rd_rst_reg_reg[1] ),.D(Q[0]),.Q(Q_reg[0])); \n  (* ASYNC_REG *) \n  (* KEEP = \"yes\" *) \n  (* msgon = \"true\" *) \n FDCE #(.INIT(1'b0)) \n  \\Q_reg_reg[1] \n (.C(s_aclk),.CE(1'b1),.CLR(\\ngwrdrst.grst.g7serrst.rd_rst_reg_reg[1] ),.D(Q[1]),.Q(Q_reg[1])); \n  (* ASYNC_REG *) \n  (* KEEP = \"yes\" *) \n  (* msgon = \"true\" *) \n FDCE #(.INIT(1'b0)) \n  \\Q_reg_reg[2] \n (.C(s_aclk),.CE(1'b1),.CLR(\\ngwrdrst.grst.g7serrst.rd_rst_reg_reg[1] ),.D(Q[2]),.Q(Q_reg[2])); \n  (* ASYNC_REG *) \n  (* KEEP = \"yes\" *) \n  (* msgon = \"true\" *) \n FDCE #(.INIT(1'b0)) \n  \\Q_reg_reg[3] \n (.C(s_aclk),.CE(1'b1),.CLR(\\ngwrdrst.grst.g7serrst.rd_rst_reg_reg[1] ),.D(Q[3]),.Q(Q_reg[3])); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a clock divider that takes an input clock and a reset signal. It also takes a 6-bit counter value and outputs a divided clock signal. The module uses a temporary counter to count the input clock cycles and toggles the clock_out signal accordingly when the counter reaches the specified value. The module includes a reset functionality to reset the temporary counter and the clock_out signal.\n\n Module header:\n\nmodule clock_divider(input clock, input reset, input[5:0] counter, output reg clock_out);\n [/INST]\n", "output": "reg[5:0] temp_counter; \n  initial \n  begin \n  temp_counter <= 6'b0; \n  clock_out <= 1'b0; \n  end \n  always @(posedge clock or posedge reset) \n  begin \n  if(reset) \n  begin \n  temp_counter <= 6'b0; \n  clock_out <= 1'b0; \n  end \n  else \n  if(temp_counter == counter) \n  begin \n  temp_counter <= 6'b0; \n  clock_out <= ~clock_out; \n  end \n  else \n  begin \n  temp_counter <= temp_counter + 1; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"T_uxa_ps2_shfreg\" contains registers and wires for input and output signals. Inside, it instantiates another module and includes an always block to generate clock signals. There are initial and always blocks to set input values, and the module includes conditional checks for the output values. The module simulates a deserializer and checks if the byte grab and synchronization to the PS/2 frame are functioning correctly. Additionally, it checks if the deserializer and frame indicator reset when instructed.\n\n Module header:\n\nmodule T_uxa_ps2_shfreg;\n [/INST]\n", "output": "reg ps2_d_i; \n  reg ps2_c_i; \n  reg reset_i; \n  reg sys_clk_i; \n  wire [7:0] d_o; \n  wire frame_o; \n M_uxa_ps2_shfreg uut (.ps2_d_i(ps2_d_i),.ps2_c_i(ps2_c_i),.d_o(d_o),.frame_o(frame_o),.reset_i(reset_i),.sys_clk_i(sys_clk_i)); \n  always begin \n  #40 sys_clk_i <= 1; \n  #40 sys_clk_i <= 0; \n  end \n  initial begin \n  ps2_d_i = 1; \n  ps2_c_i = 1; \n  reset_i = 1; \n  sys_clk_i = 0; \n  #80 reset_i = 0; \n  #50000 ps2_d_i = 0; ps2_c_i = 0; \n  #50000 ps2_c_i = 1; \n  #50000 ps2_d_i = 0; ps2_c_i = 0; \n  #50000 ps2_c_i = 1; \n  #50000 ps2_d_i = 0; ps2_c_i = 0; \n  #50000 ps2_c_i = 1; \n  #50000 ps2_d_i = 1; ps2_c_i = 0; \n  #50000 ps2_c_i = 1; \n  #50000 ps2_d_i = 0; ps2_c_i = 0; \n  #50000 ps2_c_i = 1; \n  #50000 ps2_d_i = 0; ps2_c_i = 0; \n  #50000 ps2_c_i = 1; \n  #50000 ps2_d_i = 1; ps2_c_i = 0; \n  #50000 ps2_c_i = 1; \n  #50000 ps2_d_i = 1; ps2_c_i = 0; \n  #50000 ps2_c_i = 1; \n  #50000 ps2_d_i = 0; ps2_c_i = 0; \n  #50000 ps2_c_i = 1; \n  #50000 ps2_d_i = 1; ps2_c_i = 0; \n  #50000 ps2_c_i = 1; \n  #50000 ps2_d_i = 1; ps2_c_i = 0; \n  #50000 ps2_c_i = 1; \n  #320 ; \n  if(d_o != 8'b01100100) begin \n  $display(\"Deserializer failed to grab byte correctly.\"); \n  $stop; \n  end \n  if(frame_o != 1) begin \n  $display(\"Deserializer failed to sync to the PS/2 frame.\"); \n  $stop; \n  end \n  reset_i = 1; \n  #80 reset_i = 0; \n  if(d_o != 8'b11111111) begin \n  $display(\"Deserializer didn't reset when instructed.\"); \n  $stop; \n  end \n  if(frame_o != 0) begin \n  $display(\"Frame indicator didn't reset when instructed.\"); \n  $stop; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module represents a control unit for a processor. It decodes the OPcode and Fun inputs and sets various control signals based on the decoded values. The control signals include RegDst, ALUSrc_B, DatatoReg, Jal, Branch, RegWrite, mem_w, ALU_Control, eret, and CPU_MIO. The module uses a case statement to determine the values of these control signals based on the inputs. The control signals are used to control various operations within the processor, such as register writing, ALU operations, branching, and memory access.\n\n Module header:\n\nmodule SCtrl_INT(input[5:0]OPcode,input[5:0]Fun,input wire int_code,input wire MIO_ready,input wire zero,output reg RegDst,output reg ALUSrc_B,output reg [1:0] DatatoReg,output reg Jal,output reg [1:0]Branch,output reg RegWrite,output reg mem_w,output reg [2:0]ALU_Control,output reg eret,output reg CPU_MIO);\n [/INST]\n", "output": "always @* begin \n  RegDst=0; \n  ALUSrc_B=0; \n  DatatoReg=2'b00; \n  RegWrite=0; \n  Branch=2'b00; \n  Jal=0; \n  mem_w=0; \n  CPU_MIO=0; \n  eret=0; \n  case(OPcode) \n  6'b000000: begin RegDst=1;RegWrite=1; \n  case(Fun) \n  6'b100000: ALU_Control=3'b010; \n  6'b100010: ALU_Control=3'b110; \n  6'b100100: ALU_Control=3'b000; \n  6'b100101: ALU_Control=3'b001; \n  6'b101010: ALU_Control=3'b111; \n  6'b100111: ALU_Control=3'b100; \n  6'b000010: ALU_Control=3'b101; \n  6'b010110: ALU_Control=3'b011; \n  6'h08: Branch=2'b11; \n  default: ALU_Control=3'bx; \n  endcase \n  end \n  6'b100011: begin ALU_Control=3'b010; \n  ALUSrc_B=1;DatatoReg=2'b01;RegWrite=1; end \n  6'b101011: begin ALU_Control=3'b010; \n  ALUSrc_B=1; mem_w=1; end \n  6'b000100: begin ALU_Control=3'b110; \n  Branch={1'b0,zero}; end \n  6'b000010: Branch=2'b10; \n  6'h05: begin ALU_Control=3'b110; \n  Branch={1'b0,~zero}; end \n  6'h24: begin ALU_Control=3'b111; \n  ALUSrc_B=1; RegWrite=1; end \n  6'h08: begin ALU_Control=3'b010; \n  ALUSrc_B=1; RegWrite=1; end \n  6'h0c: begin ALU_Control=3'b000; \n  ALUSrc_B=1; RegWrite=1; end \n  6'h0d: begin ALU_Control=3'b001; \n  ALUSrc_B=1; RegWrite=1;end \n  6'h03: begin Jal=1; Branch=2'b10; \n  DatatoReg=2'b11; RegWrite=1; end \n  6'h0f: begin DatatoReg=2'b10; RegWrite=1;end \n  6'h10: if (int_code & Fun == 6'h18) eret=1; \n  default: ALU_Control=3'b010; \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an ALU (Arithmetic Logic Unit) that performs arithmetic and logical operations. It takes various inputs such as clk, reset, ex_src1, ex_src2, pc, imm, dstval, src_a, src_b, alu_op, spectag, specbit, issue, and prmiss. It generates outputs such as result, rrf_we, rob_we, and kill_speculative based on the inputs and internal signals. The busy signal is set based on the issue signal and reset. The module selects source operands for the ALU based on the src_a and src_b signals. The ALU operation is performed and the result is computed using the input operands and alu_op. Additionally, it sets rrf_we and rob_we based on busy and dstval, and determines the kill_speculative signal based on spectag, spectagfix, specbit, and prmiss.\n\n Module header:\n\nmodule exunit_alu (input wire clk,input wire reset,input wire [`DATA_LEN-1:0] ex_src1,input wire [`DATA_LEN-1:0] ex_src2,input wire [`ADDR_LEN-1:0] pc,input wire [`DATA_LEN-1:0] imm,input wire dstval,input wire [`SRC_A_SEL_WIDTH-1:0] src_a,input wire [`SRC_B_SEL_WIDTH-1:0] src_b,input wire [`ALU_OP_WIDTH-1:0] alu_op,input wire [`SPECTAG_LEN-1:0] spectag,input wire specbit,input wire issue,input wire prmiss,input wire [`SPECTAG_LEN-1:0] spectagfix,output wire [`DATA_LEN-1:0] result,output wire rrf_we,output wire rob_we,output wire kill_speculative);\n [/INST]\n", "output": "wire [`DATA_LEN-1:0] alusrc1; \n  wire [`DATA_LEN-1:0] alusrc2; \n  reg busy; \n  assign rob_we = busy; \n  assign rrf_we = busy & dstval; \n  assign kill_speculative = ((spectag & spectagfix) != 0) && specbit && prmiss; \n  always @ (posedge clk) begin \n  if (reset) begin \n  busy <= 0; \n  end else begin \n  busy <= issue; \n  end \n  end \n  src_a_mux samx \n (.src_a_sel(src_a),.pc(pc),.rs1(ex_src1),.alu_src_a(alusrc1)); \n  src_b_mux sbmx \n (.src_b_sel(src_b),.imm(imm),.rs2(ex_src2),.alu_src_b(alusrc2)); \n  alu alice \n (.op(alu_op),.in1(alusrc1),.in2(alusrc2),.out(result)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module `CC_Bidir` is a bidirectional buffer that selects between an input and an output based on the value of `sel_in`. When `sel_in` is high, the input `in` is connected to the I/O port `io`, otherwise the output `out` is connected to `io`. The width of the bidirectional buffer is determined by the `WIDTH` parameter. When `sel_in` is high, the input `in` is assigned to the I/O port `io`, and when `sel_in` is low, the I/O port `io` is assigned to the output `out`.\n\n Module header:\n\nmodule CC_Bidir(sel_in, io, in, out);\n [/INST]\n", "output": "parameter WIDTH=1; \n  input sel_in; \n  inout [WIDTH-1:0] io; \n  output [WIDTH-1:0] in; \n  input [WIDTH-1:0] out; \n  assign in = sel_in ? io : {WIDTH{1'bz}}; \n  assign io = sel_in ? {WIDTH{1'bz}} : out; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module `arriaiigz_io_pad` defines an input-output pad with buffering functionality. It has an input port `padin` and an output port `padout`. It includes internal signals `padin_ipd` and `padout_opd`. The module uses buffers to connect the input and output ports to the internal signals, ensuring proper signal integrity. The `padin_buf` buffers the input signal, while the `padout_buf` buffers the output signal. The output port `padout` is directly assigned to the internal signal `padout_opd`. This module essentially provides buffering for the input and output signals to ensure proper interfacing with the external environment.\n\n Module header:\n\nmodule arriaiigz_io_pad (padin,padout);\n [/INST]\n", "output": "parameter lpm_type = \"arriaiigz_io_pad\"; \n input padin; \n output padout; \n wire padin_ipd; \n wire padout_opd; \n buf padin_buf (padin_ipd,padin); \n assign padout_opd = padin_ipd; \n buf padout_buf (padout, padout_opd); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a demultiplexer that takes a 4-bit input gpio_sel and controls the tri-state output signals tri_o_out and tri_t_out. It also assigns various input and output signals based on the selected gpio_sel value. The module implements demuxing logic for the tri-state outputs and selects different signals for the tri-state inputs based on the gpio_sel value. The demultiplexer functionality is implemented using combinational logic and case statements to select the appropriate signals based on the input selection.\n\n Module header:\n\nmodule arduino_switch_digital_bit(input [3:0] gpio_sel,input tri_i_out,output reg tri_o_out,output reg tri_t_out,output tri_i_in,input tri_o_in,input tri_t_in,output spick_i_in,input spick_o_in,input spick_t_in,output miso_i_in,input miso_o_in,input miso_t_in,output mosi_i_in,input mosi_o_in,input mosi_t_in,output ss_i_in,input ss_o_in,input ss_t_in,output interrupt_i_in,input pwm_o_in,input pwm_t_in,output timer_i_in,input timer_o_in,input timer_t_in);\n [/INST]\n", "output": "reg [6:0] tri_i_out_demux; \n  assign {ss_i_in,mosi_i_in,miso_i_in,spick_i_in,timer_i_in,interrupt_i_in,tri_i_in} = tri_i_out_demux; \n  always @(gpio_sel, tri_o_in, pwm_o_in, timer_o_in, spick_o_in, miso_o_in, mosi_o_in, ss_o_in) \n  case (gpio_sel) \n  4'h0: tri_o_out = tri_o_in; \n  4'h1: tri_o_out = 1'b0; \n  4'h2: tri_o_out = pwm_o_in; \n  4'h3: tri_o_out = timer_o_in; \n  4'h4: tri_o_out = spick_o_in; \n  4'h5: tri_o_out = miso_o_in; \n  4'h6: tri_o_out = mosi_o_in; \n  4'h7: tri_o_out = ss_o_in; \n  default: tri_o_out = tri_o_in; \n  endcase \n  always @(gpio_sel, tri_i_out) \n  begin \n  tri_i_out_demux = {7{1'b0}}; \n  case (gpio_sel) \n  4'h0: tri_i_out_demux[0] = tri_i_out; \n  4'h1: tri_i_out_demux[1] = tri_i_out; \n  4'h4: tri_i_out_demux[3] = tri_i_out; \n  4'h5: tri_i_out_demux[4] = tri_i_out; \n  4'h6: tri_i_out_demux[5] = tri_i_out; \n  4'h7: tri_i_out_demux[6] = tri_i_out; \n  4'hb: tri_i_out_demux[2] = tri_i_out; \n  default: tri_i_out_demux[0] = tri_i_out; \n  endcase \n  end \n  always @(gpio_sel, tri_t_in, pwm_t_in, timer_t_in, spick_t_in, miso_t_in, mosi_t_in, ss_t_in) \n  case (gpio_sel) \n  4'h0: tri_t_out = tri_t_in; \n  4'h1: tri_t_out = 1'b1; \n  4'h2: tri_t_out = pwm_t_in; \n  4'h3: tri_t_out = timer_t_in; \n  4'h4: tri_t_out = spick_t_in; \n  4'h5: tri_t_out = miso_t_in; \n  4'h6: tri_t_out = mosi_t_in; \n  4'h7: tri_t_out = ss_t_in; \n  default: tri_t_out = tri_t_in; \n  endcase \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe `expand_key_type_C_192` module takes a 192-bit input vector and an 8-bit round constant as input, and produces two output vectors. \n\nThe input vector is split into six 32-bit words, and some operations are performed on these words to generate intermediate results. The module then combines these intermediate results to produce the final output vectors.\n\nThe output vectors are formed by combining the modified words in specific arrangements. The output `out_1` is formed by combining words `k0b`, `k1b`, `k2b`, `k3b`, `k4b`, and `k5b`. The output `out_2` is formed by combining words `k4b`, `k5b`, `k0b`, and `k1b` in a different order.\n\nThe module uses some temporary variables and performs specific operations on the input words to generate the output vectors `out_1` and `out_2`.\n\n Module header:\n\nmodule expand_key_type_C_192 (in, rcon, out_1, out_2);\n [/INST]\n", "output": "input [191:0] in; \n  input [7:0] rcon; \n  output reg [191:0] out_1; \n  output [127:0] out_2; \n  wire [31:0] k0, k1, k2, k3, k4, k5, \n  v4, v5, v0, v1; \n  reg [31:0] k0a, k1a, k2a, k3a, k4a, k5a; \n  wire [31:0] k0b, k1b, k2b, k3b, k4b, k5b, k6a; \n  assign {k0, k1, k2, k3, k4, k5} = in; \n  assign v4 = k3 ^ k4; \n  assign v5 = v4 ^ k5; \n  assign v0 = {k0[31:24] ^ rcon, k0[23:0]}; \n  assign v1 = v0 ^ k1; \n  always @ (*) \n  {k0a, k1a, k2a, k3a, k4a, k5a} <= {v0, v1, k2, k3, v4, v5}; \n  S4 \n  S4_0 ({v5[23:0], v5[31:24]}, k6a); \n  assign k0b = k0a ^ k6a; \n  assign k1b = k1a ^ k6a; \n  assign {k2b, k3b, k4b, k5b} = {k2a, k3a, k4a, k5a}; \n  always @ (*) \n  out_1 <= {k0b, k1b, k2b, k3b, k4b, k5b}; \n  assign out_2 = {k4b, k5b, k0b, k1b}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a generic comparator that takes two input signals of a specified width and outputs the result of the comparison for each bit. It uses a generate block to instantiate a 1-bit comparator module for each bit of the input signals. The result of the comparison for each bit is then assigned to the final output signal.\n\n Module header:\n\nmodule comparator_generic(Ain, Bin, CompOut);\n [/INST]\n", "output": "parameter WIDTH = 2; \n  input [WIDTH-1:0] Ain; \n  input [WIDTH-1:0] Bin; \n  output [WIDTH-1:0] CompOut; \n  wire [WIDTH-1:0] temp_cout; \n  generate \n  genvar i; \n  for (i=0; i<WIDTH; i=i+1) begin: COMPARATOR \n comparator_1bit_struct COMPARATOR_1bit(.Ain (Ain[i]),.Bin (Bin[i]),.CompOut (temp_cout[i])); \n  end \n  endgenerate \n  assign CompOut = temp_cout; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a deserializer with a parameterized width. It maintains an internal state machine to handle the deserialization process. Upon a negative clock edge, it checks for a reset signal and then transitions through states to process the incoming data. It captures the received data into a data buffer and sets a received flag when the deserialization is complete.\n\n Module header:\n\nmodule deserializer #(parameter WIDTH = 8)(input rxd,input rst,input clk,output [WIDTH - 1:0] data,output received);\n [/INST]\n", "output": "localparam s0 = 2'b00; \n  localparam s1 = 2'b01; \n  localparam s2 = 2'b11; \n  localparam s3 = 2'b10; \n  reg [1:0] state = s0; \n  reg [7:0] bit_index = 0; \n  reg [WIDTH - 1:0] data_buf = 0; \n  reg received_buf = 0; \n  assign data = data_buf; \n  assign received = received_buf; \n  always@(negedge clk) \n  begin \n  if(rst) \n  begin \n  state = s0; \n  bit_index = 0; \n  end \n  else \n  begin \n  case(state) \n  s0: \n  begin \n  if(rxd) \n  begin \n  state = s1; \n  end \n  end \n  s1: \n  begin \n  if(bit_index < WIDTH) \n  begin \n  data_buf[bit_index] = rxd; \n  bit_index = bit_index + 1; \n  end \n  else state = s2; \n  end \n  s2: \n  begin \n  received_buf = 1; \n  state = s3; \n  end \n  s3: \n  begin \n  received_buf = 0; \n  bit_index = 0; \n  data_buf = 0; \n  state = s0; \n  end \n  endcase \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module represents a 5-input Look-Up Table (LUT) implementing a logic function. It has inputs A, B, C, D, and E, and outputs Q. The behavior of the LUT is specified differently based on the targeted FPGA platform. The LUT values are specified for each input combination based on the targeted FPGA platform. The output Q is assigned the value from the LUT based on the input vectors A, B, C, D, and E.\n\n Module header:\n\nmodule MISTRAL_ALUT5(input A, B, C, D, E, output Q);\n [/INST]\n", "output": "parameter [31:0] LUT = 32'h0000_0000; \n `ifdef cyclonev \n specify \n  (A => Q) = 583; \n  (B => Q) = 510; \n  (C => Q) = 512; \n  (D => Q) = 400; \n  (E => Q) = 97; \n endspecify \n `endif \n `ifdef cyclone10gx \n specify \n  (A => Q) = 272; \n  (B => Q) = 175; \n  (C => Q) = 165; \n  (D => Q) = 162; \n  (E => Q) = 53; \n endspecify \n `endif \n assign Q = LUT >> {E, D, C, B, A}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe module `cc_encoder` is a synchronous finite state machine that encodes data based on various input signals. It has input ports for clock, ce, nrst, cc_start, rate, vin, din, and output ports for vout, dout, and a reg port for mask. It also has internal wires and registers for various signals used in the encoding process.\n\nThe module consists of combinational logic and sequential logic to handle the encoding process. It uses the input signals to compute the values of A and B, which are then combined to produce the output v. The module also has registers to hold the state values (s0-s5) and a counter (cnt) that controls the encoding process based on the input signals.\n\nThe module uses clock and reset signals to control the state transitions and encoding operations. It also includes a mask generation logic that sets the output mask based on the rate and counter values.\n\nOverall, the module encodes the input data based on the provided control signals and generates the output v and mask based on the encoding process.\n\n Module header:\n\nmodule cc_encoder (clk ,ce ,nrst ,cc_start ,rate ,vin ,din ,vout ,dout ,mask);\n [/INST]\n", "output": "input clk ; \n input ce ; \n input nrst ; \n input cc_start ; \n input [1:0] rate ; \n input vin ; \n input [3:0] din ; \n output vout ; \n output [7:0] dout ; \n output reg [7:0] mask ; \n wire [3:0] u ; \n wire [7:0] v ; \n reg s0 ; \n reg s1 ; \n reg s2 ; \n reg s3 ; \n reg s4 ; \n reg s5 ; \n wire s0_next ; \n wire s1_next ; \n wire s2_next ; \n wire s3_next ; \n wire s4_next ; \n wire s5_next ; \n wire [3:0] A ; \n wire [3:0] B ; \n reg [1:0] cnt ; \n assign vout = vin ; \n assign dout = v ; \n assign A[3] = u[3] ^ s1 ^ s2 ^ s4 ^ s5 ; \n assign B[3] = u[3] ^ s0 ^ s1 ^ s2 ^ s5 ; \n assign A[2] = (u[2] ^ s0 ^ s1 ^ s3 ^ s4) ; \n assign B[2] = (u[2] ^ u[3] ^ s0 ^ s1 ^ s4) ; \n assign A[1] = (u[1] ^ u[3] ^ s0 ^ s2 ^ s3) ; \n assign B[1] = (u[1] ^ u[2] ^ u[3] ^ s0 ^ s3) ; \n assign A[0] = (u[0] ^ u[2] ^ u[3] ^ s1 ^ s2) ; \n assign B[0] = (u[0] ^ u[1] ^ u[2] ^ u[3] ^ s2) ; \n assign u = din ; \n assign v = {A[3], B[3], A[2], B[2], A[1], B[1], A[0], B[0]} ; \n assign s0_next = u[0] ; \n assign s1_next = u[1] ; \n assign s2_next = u[2] ; \n assign s3_next = u[3] ; \n assign s4_next = s0 ; \n assign s5_next = s1 ; \n always @ (posedge clk or negedge nrst) \n  if (~nrst) \n  begin \n  s0 <= 1'b0 ; \n  s1 <= 1'b0 ; \n  s2 <= 1'b0 ; \n  s3 <= 1'b0 ; \n  s4 <= 1'b0 ; \n  s5 <= 1'b0 ; \n  end \n  else if (ce) \n  begin \n  if (cc_start) \n  begin \n  s0 <= 1'b0 ; \n  s1 <= 1'b0 ; \n  s2 <= 1'b0 ; \n  s3 <= 1'b0 ; \n  s4 <= 1'b0 ; \n  s5 <= 1'b0 ; \n  end \n  else if (vin) \n  begin \n  s0 <= s0_next ; \n  s1 <= s1_next ; \n  s2 <= s2_next ; \n  s3 <= s3_next ; \n  s4 <= s4_next ; \n  s5 <= s5_next ; \n  end \n  end \n always @ (posedge clk or negedge nrst) \n  if (~nrst) \n  cnt <= 0 ; \n  else if (ce) \n  begin \n  if (cc_start) \n  cnt <= 0 ; \n  else if (vin) \n  begin \n  if (cnt == 2) \n  cnt <= 0 ; \n  else \n  cnt <= cnt +1 ; \n  end \n  end \n always @* \n begin \n  mask = 8'd0 ; \n  if (rate == 0) \n  mask = 8'b1111_1111 ; \n  else if (rate == 1) \n  mask = 8'b1110_1110 ; \n  else \n  begin \n  case(cnt) \n  0: mask = 8'b1110_0111 ; \n  1: mask = 8'b1001_1110 ; \n  2: mask = 8'b0111_1001 ; \n  default: mask = 8'b1110_0111 ; \n  endcase \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module represents a simple synchronous static random-access memory (SRAM) model. It has various input and output ports for controlling the SRAM, such as read and write enables, data input and output, address lines, and control signals. The module uses a finite state machine to manage the read and write operations of the SRAM and transitions between the idle, read, write, and OK states based on the input signals. The module also generates an OK signal to indicate the completion of read and write operations. The OK signal is also dependent on the read and write signals. The module does not perform actual memory operations, but it simulates the behavior of an SRAM based on the input control signals.\n\n Module header:\n\nmodule mem_dummy_sram(input clk,output SRAM_CE, SRAM_OE, SRAM_WE, SRAM_UB, SRAM_LB,output [17:0] SRAM_A,inout [15:0] SRAM_D,input [0:3] nb_,input [0:15] ad_,output [0:15] ddt_,input [0:15] rdt_,input w_, r_, s_,output ok_);\n [/INST]\n", "output": "assign SRAM_CE = 0; \n  assign SRAM_UB = 0; \n  assign SRAM_LB = 0; \n  assign SRAM_WE = ~we; \n  assign SRAM_OE = ~oe; \n  assign ok_ = ~(ok & (~r_ | ~w_)); \n  `define IDLE 0 \n  `define READ 1 \n  `define WRITE 2 \n  `define OK 3 \n  reg [1:0] state = `IDLE; \n  reg we, oe, ok; \n  reg [0:15] rd_data; \n  always @ (posedge clk) begin \n  case (state) \n  `IDLE: begin \n  if (~r_) begin \n  state <= `READ; \n  oe <= 1; \n  end else if (~w_) begin \n  state <= `WRITE; \n  we <= 1; \n  end \n  end \n  `READ: begin \n  rd_data <= SRAM_D; \n  ok <= 1; \n  state <= `OK; \n  end \n  `WRITE: begin \n  we <= 0; \n  ok <= 1; \n  state <= `OK; \n  end \n  `OK: begin \n  oe <= 0; \n  if (r_ & w_) begin \n  ok <= 0; \n  state <= `IDLE; \n  end \n  end \n  endcase \n  end \n  assign SRAM_A[17:0] = {2'b00, ~ad_}; \n  assign SRAM_D = we ? ~rdt_ : 16'hzzzz; \n  assign ddt_ = ~r_ ? ~rd_data : 16'hffff; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"draw_symbols\" is used to generate signals for a VGA display based on the input signals like hcounter, vcounter, and occupied. It calculates the coordinates of the display and generates the appropriate signals for red, green, and blue components of the VGA output. It also handles the visibility of the symbols and their coloration based on the input signals. Additionally, it processes the occupied symbols and draws them onto the VGA display. Overall, the module coordinates the generation of signals for displaying symbols on a VGA monitor.\n\n Module header:\n\nmodule draw_symbols(input reset,input [10:0] vcounter,input [11:0] hcounter,input visible,input [8:0] occupied,input [8:0] symbol,output reg VGA_R,output reg VGA_G,output reg VGA_B);\n [/INST]\n", "output": "wire [10:0] down; \n wire [11:0] left; \n assign down = (479-384)/2; \n assign left = (639-384)/2; \n wire draw_out; \n wire [3:0] row, col; \n reg [1:0] select; \n always @(*) \n begin \n  if (hcounter >= left && hcounter < left+384 && vcounter >= down && vcounter < down+384) begin : selblock \n  integer j; \n  j = 3*((vcounter-down)/128)+(hcounter-left)/128; \n  if (occupied[j]) \n  select = symbol[j]+1; \n  else \n  select = 0; \n  end else \n  select = 0; \n end \n assign row = ((vcounter-down)%128)/8; \n assign col = ((hcounter-left)%128)/8; \n word w(draw_out, row, col, select); \n always @(*) \n begin \n  if (visible && ~reset) begin \n  VGA_R = 1'b1; \n  VGA_G = 1'b1; \n  VGA_B = 1'b1; \n  if (hcounter >= left && hcounter < left+384 && vcounter >= down && vcounter < down+384) begin \n  if (draw_out) begin \n  VGA_R = 1'b0; \n  VGA_G = 1'b0; \n  VGA_B = 1'b0; \n  end else begin \n  VGA_R = 1'b1; \n  VGA_G = 1'b1; \n  VGA_B = 1'b1; \n  end \n  end \n  if (hcounter ==left & vcounter>=down & vcounter<down+384) \n  begin \n  VGA_R=1'b0; \n  VGA_G=1'b0; \n  VGA_B=1'b0; \n  end \n  if (hcounter>=left+127 & hcounter<=left+128 & vcounter>=down & vcounter<down+384) \n  begin \n  VGA_R=1'b0; \n  VGA_G=1'b0; \n  VGA_B=1'b0; \n  end \n  if (hcounter>=left+255 & hcounter<=left+256 & vcounter>=down & vcounter<down+384) \n  begin \n  VGA_R=1'b0; \n  VGA_G=1'b0; \n  VGA_B=1'b0; \n  end \n  if (hcounter==left+384 & vcounter>=down & vcounter<down+384) \n  begin \n  VGA_R=1'b0; \n  VGA_G=1'b0; \n  VGA_B=1'b0; \n  end \n  if (hcounter>=left & hcounter<=left+384 & vcounter==down) \n  begin \n  VGA_R=1'b0; \n  VGA_G=1'b0; \n  VGA_B=1'b0; \n  end \n  if (hcounter>=left & hcounter<=left+384 & vcounter>=down+127 & vcounter<=down+128) \n  begin \n  VGA_R=1'b0; \n  VGA_G=1'b0; \n  VGA_B=1'b0; \n  end \n  if (hcounter>=left & hcounter<=left+384 & vcounter>=down+255 & vcounter<=down+256) \n  begin \n  VGA_R=1'b0; \n  VGA_G=1'b0; \n  VGA_B=1'b0; \n  end \n  if (hcounter>=left & hcounter<=left+384 & vcounter==down+384) \n  begin \n  VGA_R=1'b0; \n  VGA_G=1'b0; \n  VGA_B=1'b0; \n  end \n  end else begin \n  VGA_R=1'b0; \n  VGA_G=1'b0; \n  VGA_B=1'b0; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module named \"v23b15b\" takes two input signals, \"v27dec4\" and \"v6848e9\", and produces one output signal, \"v4642b6\". Inside the module, it uses some internal wires \"w0\", \"w1\", \"w2\", and \"w3\" to connect the inputs and outputs. It instantiates two submodule instances \"vd12401\" and \"v3676a0\", connecting the wires to them. The functionality of these submodules is not directly specified in the given Verilog module, so I cannot provide further details.\n\n Module header:\n\nmodule v23b15b (input v27dec4,input v6848e9,output v4642b6);\n [/INST]\n", "output": "wire w0; \n  wire w1; \n  wire w2; \n  wire w3; \n  assign w1 = v27dec4; \n  assign v4642b6 = w2; \n  assign w3 = v6848e9; \n vd12401 v955b2b (.vcbab45(w0),.v0e28cb(w1),.v3ca442(w3)); \n v3676a0 vf92936 (.v0e28cb(w0),.vcbab45(w2)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a VGA controller that generates VGA signals to display images on a screen. It uses a VGA synchronization generator and modules to handle image data and index. The module synchronizes with the VGA clock, retrieves color data from an image memory, and assigns the red, green, and blue components of the pixel for display. It includes components for coordinating the horizontal and vertical pixel coordinates, color indexing, and RGB value generation for the display.\n\n Module header:\n\nmodule vga_controller(input reset,input sys_clk,input vga_clk,output blank_n,output HS,output VS,output [7:0] red,output [7:0] green,output [7:0] blue);\n [/INST]\n", "output": "wire [10:0] pixel_h; \n  wire [10:0] pixel_v; \n  reg [7:0] r_red; \n  reg [7:0] r_green; \n  reg [7:0] r_blue; \n  wire [7:0] colour_index; \n  wire [23:0] rgb; \n  reg [18:0] img_read_address; \n  wire [31:0] next_pixel_addr; \n vga_sync_generator vga_sync(.reset(reset),.vga_clk(vga_clk),.blank_n(blank_n),.next_pixel_h(pixel_h),.next_pixel_v(pixel_v),.next_pixel_addr(next_pixel_addr),.HS(HS),.VS(VS)); \n img_data img_data_inst (.q (colour_index),.d(8'b0),.read_address(img_read_address),.write_address(19'b0),.we(1'b0),.clk(sys_clk)); \n img_index img_index_inst (.q (rgb),.d(8'b0),.read_address(colour_index),.write_address(8'b0),.we(1'b0),.clk(sys_clk)); \n  always@(posedge vga_clk) begin \n  img_read_address <= next_pixel_addr[18:0]; \n  end \n  assign red = rgb[23:16]; \n  assign green = rgb[15:8]; \n  assign blue = rgb[7:0]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module implements a finite state machine that generates an output byte enable signal and a wait request signal based on the input byte enable, clock, reset, wait request, and write signals. The output byte enable is determined by the input byte enable and write signals, while the wait request is a combination of the input wait request and the write signals.\n\n Module header:\n\nmodule sixteen_bit_byteenable_FSM_which_resides_within_sgdma_rx (byteenable_in,clk,reset_n,waitrequest_in,write_in,byteenable_out,waitrequest_out);\n [/INST]\n", "output": "output [ 1: 0] byteenable_out; \n  output waitrequest_out; \n  input [ 1: 0] byteenable_in; \n  input clk; \n  input reset_n; \n  input waitrequest_in; \n  input write_in; \n  wire [ 1: 0] byteenable_out; \n  wire waitrequest_out; \n  assign byteenable_out = byteenable_in & {2{write_in}}; \n  assign waitrequest_out = waitrequest_in | ((write_in == 1) & (waitrequest_in == 1)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module implements a Fibonacci sequence generator with configurable input and output widths. It has states for initialization, waiting for a request, calculation, and waiting for request fall. It uses a state machine to control the sequence generation based on the input value n and produces the corresponding Fibonacci number as the output result. The module also includes a reset mechanism to initialize the internal registers and outputs.\n\n Module header:\n\nmodule fib #(parameter N_IN = 7,parameter N_OUT = 90) (input wire rst_n,input wire clk,input wire req,input wire [N_IN-1:0] n,output reg ack,output reg [N_OUT-1:0] result);\n [/INST]\n", "output": "localparam \n  INIT = 2'b00, \n  WAIT_REQ = 2'b01, \n  CALC = 2'b10, \n  WAIT_REQ_FALL = 2'b11; \n reg [1:0] state; \n reg [N_IN-1:0] n_reg; \n reg [N_OUT-1:0] n_m1; \n reg [N_OUT-1:0] n_m2; \n reg [N_IN-1:0] cnt; \n always @(posedge clk or negedge rst_n) begin \n  if(~rst_n) begin \n  state <= INIT; \n  n_reg <= 0; \n  n_m1 <= 0; \n  n_m2 <= 0; \n  cnt <= 0; \n  ack <= 0; \n  result <= 0; \n  end else begin \n  case(state) \n  INIT :begin \n  state <= #1 WAIT_REQ; \n  end \n  WAIT_REQ :begin \n  if( req) begin \n  state <= #1 CALC; \n  n_reg <= #1 n; \n  n_m1 <= #1 1; \n  n_m2 <= #1 0; \n  cnt <= #1 0; \n  ack <= #1 0; \n  result <= #1 0; \n  end \n  end \n  CALC :begin \n  if(cnt == (n_reg-1)) begin \n  state <= #1 WAIT_REQ_FALL; \n  result <= #1 n_m1; \n  end else begin \n  n_m1 <= #1 n_m1 + n_m2; \n  n_m2 <= #1 n_m1; \n  cnt <= #1 cnt + 1; \n  end \n  end \n  WAIT_REQ_FALL:begin \n  if(~req) \n  state <= #1 WAIT_REQ; \n  ack <= #1 1; \n  end \n  default :begin \n  state <= 2'bxx; \n  end \n  endcase \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a simple program counter (PC) with a 32-bit output. It maintains four PC registers: pc0, pc1, pc2, and pc3. On each clock pulse, pc0 is updated by incrementing by 4 unless a branch is taken. In that case, pc3 is updated with the sum of pc2 and the branch address (baddr), and pc0 is updated with pc3. The output PC is always driven by pc0. The module effectively updates the PC based on branch conditions and maintains the previous PC values.\n\n Module header:\n\nmodule pc(input clk,output [31:0] pc,input branch,input [31:0] baddr);\n [/INST]\n", "output": "reg branch3 = 1'b0; \n  reg [31:0] pc0 = 32'd0; \n  reg [31:0] pc1 = 32'd0; \n  reg [31:0] pc2 = 32'd0; \n  reg [31:0] pc3 = 32'd0; \n  assign pc = pc0; \n  always @(posedge clk) begin \n  if (branch3) \n  pc0 <= pc3; \n  else \n  pc0 <= pc0 + 4; \n  pc1 <= pc0; \n  pc2 <= pc1; \n  pc3 <= 32'd0; \n  branch3 <= 1'b0; \n  if (branch) begin \n  pc3 <= pc2 + baddr; \n  branch3 <= 1'b1; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a 1024x4 DRAM (Dynamic Random Access Memory). It uses two clocks for write and read operations and enables the clocks with the w_clk_en and r_clk_en inputs. It takes write and read addresses waddr and raddr respectively, as well as the data input d, and outputs the read data q. The module internally processes the data and address signals to match the RAM's data and address width, and maps the input data to the internal data width using the _d signal. It instantiates the DRAM module with mode 2, facilitating its functionality.\n\n Module header:\n\nmodule dram_1024x4(input w_clk,input r_clk,input w_clk_en,input r_clk_en,input we,input [ADDR_WIDTH - 1 : 0] waddr,input [DATA_WIDTH - 1 : 0] d,input re,input [ADDR_WIDTH - 1 : 0] raddr,output [DATA_WIDTH - 1 : 0] q);\n [/INST]\n", "output": "localparam DATA_WIDTH = 4; \n  localparam ADDR_WIDTH = 10; \n  localparam RAM_DATA_WIDTH = 16; \n  localparam RAM_ADDR_WIDTH = 11; \n  wire [RAM_DATA_WIDTH - 1 : 0] _d, _q; \n  wire [RAM_ADDR_WIDTH - 1 : 0] _waddr, _raddr; \n  assign _waddr = { {(RAM_ADDR_WIDTH - ADDR_WIDTH){1'b0}}, {waddr} }; \n  assign _raddr = { {(RAM_ADDR_WIDTH - ADDR_WIDTH){1'b0}}, {raddr} }; \n  genvar i; \n  generate \n  for (i = 0; i < 4; i=i+1) \n  begin \n  assign _d[i * 4 + 0] = 1'b0; \n  assign _d[i * 4 + 1] = d[i]; \n  assign _d[i * 4 + 2] = 1'b0; \n  assign _d[i * 4 + 3] = 1'b0; \n  assign q[i] = _q[i * 4 + 1]; \n  end \n  endgenerate \n dram_#(.MODE(2)) dram_(.w_clk(w_clk),.r_clk(r_clk),.w_clk_en(w_clk_en),.r_clk_en(r_clk_en),.we(we),.waddr(_waddr),.d(_d),.re(re),.raddr(_raddr),.q(_q),.mask(16'b0)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, named \"add_wrap\", takes inputs A and B and produces output Y. The module contains parameters to define the signedness and width of A, B, and Y. Inside the module, it converts the input widths to 48 bits using wires A_48 and B_48, and assigns the result to output wire Y_48. There is also an initial block that checks for signedness and width constraints, setting a fail flag accordingly. Finally, the module instantiates a wrapper module \"\\$__add_wrapper\" and passes the converted inputs and outputs to it. The purpose of this module seems to be to prepare the inputs, perform some checks, and then invoke another module for the actual computation.\n\n Module header:\n\nmodule add_wrap (A, B, Y);\n [/INST]\n", "output": "parameter A_SIGNED = 0; \n parameter B_SIGNED = 0; \n parameter A_WIDTH = 1; \n parameter B_WIDTH = 1; \n parameter Y_WIDTH = 1; \n input [A_WIDTH-1:0] A; \n input [B_WIDTH-1:0] B; \n output [Y_WIDTH-1:0] Y; \n wire [47:0] A_48 = A; \n wire [47:0] B_48 = B; \n wire [47:0] Y_48; \n assign Y = Y_48; \n wire [1023:0] _TECHMAP_DO_ = \"proc; clean\"; \n reg _TECHMAP_FAIL_; \n initial begin \n  _TECHMAP_FAIL_ <= 0; \n  if (A_SIGNED || B_SIGNED) \n  _TECHMAP_FAIL_ <= 1; \n  if (A_WIDTH < 10 && B_WIDTH < 10) \n  _TECHMAP_FAIL_ <= 1; \n end \n \\$__add_wrapper #(.A_SIGNED(A_SIGNED),.B_SIGNED(B_SIGNED),.A_WIDTH(A_WIDTH),.B_WIDTH(B_WIDTH),.Y_WIDTH(Y_WIDTH)) _TECHMAP_REPLACE_ (.A(A_48),.B(B_48),.Y(Y_48)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a dual-port RAM with 36-bit data width, 9-bit address width, and automatic block RAM type. It has two sets of inputs and outputs for port A and port B. The input data for port A is stored in din_a, and the output data for port B is retrieved from do_b[31:0] and do_b[35:32]. The RAMB16_S36_S36 primitive is used to implement the dual-port RAM functionality, with the appropriate connections to the input and output ports, as well as clock and write enable signals.\n\n Module header:\n\nmodule duram(data_a,data_b,wren_a,wren_b,address_a,address_b,clock_a,clock_b,q_a,q_b);\n [/INST]\n", "output": "parameter DATA_WIDTH = 36; \n parameter ADDR_WIDTH = 9; \n parameter BLK_RAM_TYPE = \"AUTO\"; \n parameter ADDR_DEPTH = 2**ADDR_WIDTH; \n input [DATA_WIDTH -1:0] data_a; \n input wren_a; \n input [ADDR_WIDTH -1:0] address_a; \n input clock_a; \n output [DATA_WIDTH -1:0] q_a; \n input [DATA_WIDTH -1:0] data_b; \n input wren_b; \n input [ADDR_WIDTH -1:0] address_b; \n input clock_b; \n output [DATA_WIDTH -1:0] q_b; \n wire [35:0] do_b; \n wire [35:0] din_a; \n assign din_a =data_a; \n assign q_b =do_b; \n RAMB16_S36_S36 U_RAMB16_S36_S36 (.DOA ( ),.DOB (do_b[31:0] ),.DOPA ( ),.DOPB (do_b[35:32] ),.ADDRA (address_a ),.ADDRB (address_b ),.CLKA (clock_a ),.CLKB (clock_b ),.DIA (din_a[31:0] ),.DIB ( ),.DIPA (din_a[35:32] ),.DIPB ( ),.ENA (1'b1 ),.ENB (1'b1 ),.SSRA (1'b0 ),.SSRB (1'b0 ),.WEA (wren_a ),.WEB (1'b0 )); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a communication receiver that operates on a clock signal and a reset input. It takes in data through the port input and processes it to generate an output signal. The module includes logic for managing the write enable, received data, clear, and valid flags. The process is triggered on the rising edge of the clock. When the reset signal is asserted, the module resets various internal registers and sets the valid flag. It shifts the incoming data and updates the received count based on certain conditions. The valid flag controls the write enable, and the received count is reset accordingly.\n\n Module header:\n\nmodule comm_receiver(clk, reset, port, out, write);\n [/INST]\n", "output": "parameter inSize = 6, outSize = 32; \n  input clk, reset; \n  input [inSize-1:0] port; \n  output reg [outSize-1:0] out = 0; \n  output reg write = 0; \n  reg [outSize/inSize:0] received = 0; \n  reg clear = 0; \n  reg valid = 1; \n  always @(posedge clk) begin \n  write = 0; \n  if (reset) begin \n  out <= 0; \n  received <= 0; \n  clear <= 0; \n  valid <= 1; \n  end else if (received < (outSize/inSize + 1)) begin \n  out <= (out << inSize) | port; \n  received <= received+1; \n  end else if (port) begin \n  valid <= 0; \n  end else begin \n  if (valid) \n  write = 1; \n  received <= 0; \n  valid <= 1; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a datapath that performs multiplication and addition operations. It takes in input signals and computes the product of two 16-bit numbers, and performs addition and comparison operations based on control signals. The resulting outputs are the sum, comparison result, and a modified sum based on the control signals. The module also contains internal local parameters and instantiates specific multiplier and register modules to achieve its functionality.\n\n Module header:\n\nmodule udi_inst_pow (input gclk ,input gscanenable ,input [31:0] in_rs ,input [15:0] in_rt ,output [31:0] out_rd ,input udi_ctl_thr_wr ,input [1:0] udi_ctl_sum_mode ,input udi_ctl_res_sel);\n [/INST]\n", "output": "wire [31:0] mult_i_out ; \n  wire [31:0] mult_q_out ; \n  wire [31:0] threshold ; \n  wire [32:0] sum ; \n  wire [31:0] sum_out ; \n  wire comp_res ; \n  localparam CTL_SUM_MODE_NONE = 2'b00 ; \n  localparam CTL_SUM_MODE_SUM = 2'b01 ; \n  localparam CTL_SUM_MODE_SUMSHIFT = 2'b10 ; \n  localparam CTL_SUM_MODE_BYPASS = 2'b11 ; \n  assign sum = mult_i_out + mult_q_out ; \n  assign comp_res = (sum_out > threshold) ? 1'b1 : 1'b0 ; \n  assign out_rd = (udi_ctl_res_sel) ? {30'd0,comp_res} : sum_out ; \n  assign sum_out = (udi_ctl_sum_mode == CTL_SUM_MODE_SUM) ? sum[31:0] : \n  (udi_ctl_sum_mode == CTL_SUM_MODE_SUMSHIFT) ? sum[32:1] : \n  (udi_ctl_sum_mode == CTL_SUM_MODE_BYPASS) ? mult_i_out : 32'd0 ; \n  mvp_cregister_wide #(32) _udi_thr_31_0_(threshold[31:0],gscanenable, udi_ctl_thr_wr, gclk, in_rs); \n mult_16_x_16_res_32 mult_16_x_16_res_32_u1(.clk ( gclk ),.a ( in_rs[31:16] ),.b ( in_rs[31:16] ),.p ( mult_i_out )); \n mult_16_x_16_res_32 mult_16_x_16_res_32_u2(.clk ( gclk ),.a ( in_rt ),.b ( in_rt ),.p ( mult_q_out )); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module, named sll_8, takes a 32-bit input 'a' and a single-bit 'lsb' as inputs, and generates an output 'out' of the same width. It uses generate blocks to perform 8-bit left shifts on the 'a' input and 8-bit left shifts on the 'lsb' input, and then assigns the results to the output 'out' in a concatenative manner.\n\n Module header:\n\nmodule sll_8(a, lsb, out);\n [/INST]\n", "output": "input [31:0] a; \n  input lsb; \n  output[31:0] out; \n  wire [31:0] out; \n  genvar i; \n  generate \n  for(i=8; i<32; i=i+1) begin: shift_eight_loop \n  assign out[i] = a[i-8]; \n  end \n  endgenerate \n  genvar j; \n  generate \n  for(j=0; j<8; j=j+1) begin: shift_eight_sub_loop \n  assign out[j] = lsb; \n  end \n  endgenerate \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a Serializer/Deserializer (SerDes) circuit for high-speed data transmission. The module interfaces with clocks, input and output data, and control signals to serialize and deserialize the data. It includes logic for reset synchronization, clock division, input data delay, and output data timing. The module instantiates specific components like OSERDESE2 for serialization, IDELAYE2 for input data delay, IDELAYCTRL for controlling input delay, and ISERDESE2 for deserialization. The DATA_WIDTH and DATA_RATE parameters are used to configure the SerDes for specific data widths and rates.\n\n Module header:\n\nmodule serdes_test # (parameter DATA_WIDTH = 8,parameter DATA_RATE = \"DDR\") (input wire SYSCLK,input wire REFCLK,input wire CLKDIV,input wire RST,input wire I_DAT,output wire O_DAT,output wire T_DAT,input wire [7:0] INPUTS,output wire [7:0] OUTPUTS);\n [/INST]\n", "output": "wire i_rstdiv; \n reg [3:0] rst_sr; \n initial rst_sr <= 4'hF; \n always @(posedge CLKDIV) \n  if (RST) rst_sr <= 4'hF; \n  else rst_sr <= rst_sr >> 1; \n assign i_rstdiv = rst_sr[0]; \n OSERDESE2 #(.DATA_RATE_OQ (DATA_RATE),.DATA_WIDTH (DATA_WIDTH),.DATA_RATE_TQ ((DATA_RATE == \"DDR\" && DATA_WIDTH == 4) ? \"DDR\" : \"BUF\"),.TRISTATE_WIDTH ((DATA_RATE == \"DDR\" && DATA_WIDTH == 4) ? 4 : 1)) \n oserdes \n (.CLK (SYSCLK),.CLKDIV (CLKDIV),.RST (i_rstdiv),.OCE (1'b1),.D1 (INPUTS[0]),.D2 (INPUTS[1]),.D3 (INPUTS[2]),.D4 (INPUTS[3]),.D5 (INPUTS[4]),.D6 (INPUTS[5]),.D7 (INPUTS[6]),.D8 (INPUTS[7]),.OQ (O_DAT),.TCE (1'b1),.T1 (1'b0),.T2 (1'b0),.T3 (1'b0),.T4 (1'b0),.TQ (T_DAT)); \n wire DDLY; \n IDELAYCTRL idelayctrl (.REFCLK(REFCLK)); \n IDELAYE2 # \n (.IDELAY_TYPE (\"FIXED\"),.DELAY_SRC (\"IDATAIN\"),.IDELAY_VALUE (5'd31)) \n idelay \n (.C (SYSCLK),.CE (1'b1),.LD (1'b1),.INC (1'b1),.IDATAIN (I_DAT),.DATAOUT (DDLY)); \n ISERDESE2 # \n (.DATA_RATE (DATA_RATE),.DATA_WIDTH (DATA_WIDTH),.INTERFACE_TYPE (\"NETWORKING\"),.NUM_CE (2)) \n iserdes \n (.CLK (SYSCLK),.CLKB (SYSCLK),.CLKDIV (CLKDIV),.CE1 (1'b1),.CE2 (1'b1),.RST (i_rstdiv),.DDLY (DDLY),.Q1 (OUTPUTS[7]),.Q2 (OUTPUTS[6]),.Q3 (OUTPUTS[5]),.Q4 (OUTPUTS[4]),.Q5 (OUTPUTS[3]),.Q6 (OUTPUTS[2]),.Q7 (OUTPUTS[1]),.Q8 (OUTPUTS[0])); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a D flip-flop with asynchronous load functionality. It has inputs for clock (clk), data (d), and load (ld), and an output for the stored value (q). The q value is updated on the positive edge of the clock if ld is asserted. Additionally, it includes optional random initialization for q when the RANDOM_INIT macro is defined.\n\n Module header:\n\nmodule dffl_1 ( clk, ld, d, q );\n [/INST]\n", "output": "input clk; \n  input d; \n  input ld; \n  output q; \n  reg q; \n `ifdef RANDOM_INIT \n  initial \n  $random_init(\"q\"); \n `endif \n  always @(posedge clk) begin \n  if (ld) \n  q <= d; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an implementation of an SPI (Serial Peripheral Interface) interface. It supports data transmission and reception with clock and slave select control. The module includes logic for shifting out data, receiving data, and managing the clock signal. It also handles the state machine transitions for idle, transmission, and hold states. The module also includes a clock generation process and logic for managing the SPI clock.\n\n Module header:\n\nmodule spi_interface(send_data,begin_transmission,slave_select,miso,clk,rst,recieved_data,end_transmission,mosi,sclk);\n [/INST]\n", "output": "input [7:0] send_data; \n  input begin_transmission; \n  input slave_select; \n  input miso; \n  input clk; \n  input rst; \n  output [7:0] recieved_data; \n  output end_transmission; \n  output mosi; \n  output sclk; \n  reg [7:0] recieved_data; \n  reg end_transmission; \n  reg mosi; \n  parameter [11:0] SPI_CLK_COUNT_MAX = 12'hFFF; \n  reg [11:0] spi_clk_count; \n  reg sclk_buffer; \n  reg sclk_previous; \n  parameter [3:0] RX_COUNT_MAX = 4'h8; \n  reg [3:0] rx_count; \n  reg [7:0] shift_register; \n  parameter [1:0] RxTxTYPE_idle = 0, \n  RxTxTYPE_rx_tx = 1, \n  RxTxTYPE_hold = 2; \n  reg [1:0] RxTxSTATE; \n  always @(posedge clk) \n  begin: tx_rx_process \n  begin \n  if (rst == 1'b1) \n  begin \n  mosi <= 1'b1; \n  RxTxSTATE <= RxTxTYPE_idle; \n  recieved_data <= {8{1'b0}}; \n  shift_register <= {8{1'b0}}; \n  end \n  else \n  case (RxTxSTATE) \n  RxTxTYPE_idle : \n  begin \n  end_transmission <= 1'b0; \n  if (begin_transmission == 1'b1) \n  begin \n  RxTxSTATE <= RxTxTYPE_rx_tx; \n  rx_count <= {4{1'b0}}; \n  shift_register <= send_data; \n  end \n  end \n  RxTxTYPE_rx_tx : \n  if (rx_count < RX_COUNT_MAX) \n  begin \n  if (sclk_previous == 1'b1 & sclk_buffer == 1'b0) \n  mosi <= shift_register[7]; \n  else if (sclk_previous == 1'b0 & sclk_buffer == 1'b1) \n  begin \n  shift_register[7:1] <= shift_register[6:0]; \n  shift_register[0] <= miso; \n  rx_count <= rx_count + 1'b1; \n  end \n  end \n  else \n  begin \n  RxTxSTATE <= RxTxTYPE_hold; \n  end_transmission <= 1'b1; \n  recieved_data <= shift_register; \n  end \n  RxTxTYPE_hold : \n  begin \n  end_transmission <= 1'b0; \n  if (slave_select == 1'b1) \n  begin \n  mosi <= 1'b1; \n  RxTxSTATE <= RxTxTYPE_idle; \n  end \n  else if (begin_transmission == 1'b1) \n  begin \n  RxTxSTATE <= RxTxTYPE_rx_tx; \n  rx_count <= {4{1'b0}}; \n  shift_register <= send_data; \n  end \n  end \n  endcase \n  end \n  end \n  always @(posedge clk) \n  begin: spi_clk_generation \n  begin \n  if (rst == 1'b1) \n  begin \n  sclk_previous <= 1'b1; \n  sclk_buffer <= 1'b1; \n  spi_clk_count <= {12{1'b0}}; \n  end \n  else if (RxTxSTATE == RxTxTYPE_rx_tx) \n  begin \n  if (spi_clk_count == SPI_CLK_COUNT_MAX) \n  begin \n  sclk_buffer <= (~sclk_buffer); \n  spi_clk_count <= {12{1'b0}}; \n  end \n  else \n  begin \n  sclk_previous <= sclk_buffer; \n  spi_clk_count <= spi_clk_count + 1'b1; \n  end \n  end \n  else \n  sclk_previous <= 1'b1; \n  end \n  end \n  assign sclk = sclk_previous; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a register with a specified size. It takes inputs for clock, reset, data, and write enable, and outputs the data. On a clock edge, if the reset is active, it sets the output data to a default value. Otherwise, if the write enable is active, it updates the output data with the input data.\n\n Module header:\n\nmodule Reg(clock,reset,data_i,writeEn,data_o);\n [/INST]\n", "output": "parameter Size = 8; \n  input wire [('d1) - ('b1):0] clock; \n  input wire [('d1) - ('b1):0] reset; \n  input wire [(Size) - ('b1):0] data_i; \n  input wire [('d1) - ('b1):0] writeEn; \n  output reg [(Size) - ('b1):0] data_o; \n  always @ (posedge clock) begin \n  if (reset) begin \n  data_o <= {Size{1'b0}}; \n  end \n  else begin \n  if (writeEn) begin \n  data_o <= data_i; \n  end \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a synchronous positive edge-triggered D flip-flop (FDRE) with an asynchronous reset. The output is synchronized with the clock and the input signal, and it also has a reset signal. The input signal is passed through a LUT2 (Look-Up Table 2) for initialization, and the output is assigned to the Q_reg signal.\n\n Module header:\n\nmodule decalper_eb_ot_sdeen_pot_pi_dehcac_xnilix_synchronizer_ff (out,\\ngwrdrst.grst.g7serrst.rd_rst_asreg_reg ,in0,clk);\n [/INST]\n", "output": "output out; \n  output \\ngwrdrst.grst.g7serrst.rd_rst_asreg_reg ; \n  input [0:0]in0; \n  input clk; \n  (* async_reg = \"true\" *) (* msgon = \"true\" *) wire Q_reg; \n  wire clk; \n  wire [0:0]in0; \n  wire \\ngwrdrst.grst.g7serrst.rd_rst_asreg_reg ; \n  assign out = Q_reg; \n  (* ASYNC_REG *) \n  (* KEEP = \"yes\" *) \n  (* msgon = \"true\" *) \n FDRE #(.INIT(1'b0)) \n  \\Q_reg_reg[0] \n (.C(clk),.CE(1'b1),.D(in0),.Q(Q_reg),.R(1'b0)); \n LUT2 #(.INIT(4'h2)) \n  \\ngwrdrst.grst.g7serrst.rd_rst_asreg_i_1 \n (.I0(in0),.I1(Q_reg),.O(\\ngwrdrst.grst.g7serrst.rd_rst_asreg_reg )); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, \"system_xlconstant_0_3,\" has a 10-bit output \"dout.\" It instantiates two constants, const0 and const1. It then assigns specific constant values to each bit of the \"dout\" output. Specifically, it sets the bits according to the given constants: dout[9:5] are set to const0, dout[4] is set to const1, and dout[3:0] are set to const0, const1, const0, const0 respectively. Additionally, it connects GND to const0 and VCC to const1.\n\n Module header:\n\nmodule system_xlconstant_0_3 (dout);\n [/INST]\n", "output": "output [9:0]dout; \n  wire \\<const0> ; \n  wire \\<const1> ; \n  assign dout[9] = \\<const0> ; \n  assign dout[8] = \\<const0> ; \n  assign dout[7] = \\<const0> ; \n  assign dout[6] = \\<const0> ; \n  assign dout[5] = \\<const0> ; \n  assign dout[4] = \\<const1> ; \n  assign dout[3] = \\<const0> ; \n  assign dout[2] = \\<const1> ; \n  assign dout[1] = \\<const0> ; \n  assign dout[0] = \\<const0> ; \n  GND GND \n  (.G(\\<const0> )); \n  VCC VCC \n  (.P(\\<const1> )); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe \"hamm_4096x1_512x32\" module is designed to process incoming data for error correction. It contains registers to store input data, validation signals, and control information. The module also includes logic to handle the processing of incoming data and the generation of error correction code (ECC) for the output data.\n\nThe incoming data and control signals are latched into registers on the rising edge of the clock. The incoming data is then passed to an instance of \"hamm_4096x1_1x32\" for ECC generation.\n\nAdditionally, the module contains logic for updating the ECC based on the incoming data, and incrementing the address for ECC generation within a frame. The processed data and control signals are then passed to the output ports of the module.\n\nIn summary, this Verilog module is responsible for processing incoming data, generating error correction code, and providing the processed data along with its associated control signals as the output.\n\n Module header:\n\nmodule hamm_4096x1_512x32 (input wire clk,input wire rst,input wire [31:0] data_i,input wire valid_i,input wire sof_i,input wire eof_i,output wire [31:0] data_o,output wire valid_o,output wire sof_o,output wire eof_o,output wire [23:0] ecc_o);\n [/INST]\n", "output": "reg [31:0] data_r; \n reg valid_r; \n reg sof_r; \n reg eof_r; \n always @(posedge clk) begin \n  data_r <= data_i; \n  valid_r <= valid_i; \n  sof_r <= sof_i; \n  eof_r <= eof_i; \n end \n reg [6:0] addr_r; \n wire [23:0] byte_ecc; \n hamm_4096x1_1x32 hamm_4096x1_1x32 (.data_i ( data_r ),.addr_i ( addr_r ),.ecc_o ( byte_ecc )); \n reg [23:0] ecc_r; \n always @(posedge clk) begin \n  if(rst) begin \n  addr_r <= 0; \n  ecc_r <= 0; \n  end else begin \n  if(valid_r) begin \n  if(sof_r) begin \n  ecc_r <= byte_ecc; \n  addr_r <= 1; \n  end else begin \n  ecc_r <= ecc_r ^ byte_ecc; \n  addr_r <= eof_r ? 0 : addr_r + 1; \n  end \n  end \n  end \n end \n assign data_o = data_r; \n assign valid_o = valid_r; \n assign sof_o = sof_r; \n assign eof_o = eof_r; \n assign ecc_o = eof_r ? ecc_r ^ byte_ecc : 0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a system control unit. It synchronizes and distributes clocks, generates reset signals, and initializes specific registers. The module includes parameterized configurations for reset synchronization, power supply voltage, and ground. It uses various logic elements like SRL16 and DCM to handle clock and reset signals. The module also includes synchronization blocks for debouncing reset signals and generating an asynchronous reset signal. It uses an initial block for initializing the state of specific registers. The module also includes assignments for various output signals like CLK_O, TFT_CLK_O, TFT_CLK_180_O, MSEL_O, and ASYNC_RST. The module follows a sequential logic design with synchronous and asynchronous signal processing.\n\n Module header:\n\nmodule System_Control_Unit (input wire CLK_I,input wire RSTN_I,input wire [7:0] SW_I,output wire CLK_O,output wire TFT_CLK_O,output wire TFT_CLK_180_O,output wire [3:0] MSEL_O,output wire ASYNC_RST);\n [/INST]\n", "output": "parameter integer RST_SYNC_NUM = 100; \n parameter integer RST_DBNC = 10; \n parameter integer RST_SYNC_NUM_LENGTH = $clog2(RST_SYNC_NUM); \n parameter VDD = 1'b1; \n parameter GROUND = 1'b0; \n genvar i; \n wire Start_Up_Rst; \n wire DcmRst; \n reg DcmLckd; \n wire SysConCLK; \n reg [RST_DBNC-1:0] RstDbncQ; \n reg [RST_DBNC-1:0] RstDbncTemp; \n wire intRst; \n reg intfb; \n reg intpllout_xs; \n reg [7:0] int_sw; \n reg [RST_SYNC_NUM-1:0] RstQ; \n reg [RST_SYNC_NUM_LENGTH:0] RstD; \n wire RstDbnc; \n wire int_TFTClk; \n initial \n  begin \n  RstQ[RST_SYNC_NUM-1] = 0; \n  RstQ[RST_SYNC_NUM-2:0] = {RST_SYNC_NUM-1{1'b1}}; \n  RstD[RST_SYNC_NUM_LENGTH:0] = {1'b1,RST_SYNC_NUM[RST_SYNC_NUM_LENGTH-1:0]}; \n  end \n  IBUFG IBUGF_inst \n (.O (SysConCLK),.I (CLK_I)); \n  assign CLK_O = SysConCLK; \n  dcm_TFT9 DCM_inst \n (.CLK_IN1 (SysConCLK),.CLK9 (int_TFTClk),.CLK9_180 (TFT_CLK_180_O),.RESET (DcmRst),.LOCKED (DcmLckd)); \n SRL16 #(.INIT (16'h000F)) \n  SRL16_inst \n (.CLK (SysConCLK),.Q (Start_Up_Rst),.A0 (VDD),.A1 (VDD),.A2 (GROUND),.A3 (GROUND),.D (GROUND)); \n  assign TFT_CLK_O = int_TFTClk; \n  always@(RSTN_I) \n  RstDbncQ[0] = ~RSTN_I; \n  generate \n  for(i=1;i<RST_DBNC;i=i+1) \n  always@(posedge SysConCLK) \n  RstDbncQ[i] <= RstDbncQ[i-1]; \n  endgenerate \n  always@(RstDbncQ[0]) \n  RstDbncTemp[0] = RstDbncQ[0]; \n  generate \n  for(i=1;i<RST_DBNC-1;i=i+1) \n  always@* \n  RstDbncTemp[i] <= RstDbncTemp[i-1] & RstDbncQ[i]; \n  endgenerate \n  assign RstDbnc = RstDbncTemp[RST_DBNC-2] & ~RstDbncQ[RST_DBNC-1]; \n  always@(posedge SysConCLK) \n  if(RstDbnc || RstQ[RST_SYNC_NUM-1]) \n  RstQ <= {RstQ[RST_SYNC_NUM-2:0],RstQ[RST_SYNC_NUM-1]}; \n  assign DcmRst = ~RstQ[RST_SYNC_NUM-2] || ~RstQ[RST_SYNC_NUM-3] || ~RstQ[RST_SYNC_NUM-4] || Start_Up_Rst; \n  assign intRst = ~DcmLckd; \n  always@(posedge SysConCLK) \n  if(intRst) \n  RstD <= {1'b1,RST_SYNC_NUM[RST_SYNC_NUM_LENGTH-1:0]}; \n  else if(RstD[RST_SYNC_NUM_LENGTH]) \n  RstD <= RstD - 1; \n  assign ASYNC_RST = RstQ[RST_SYNC_NUM-1] || RstD[RST_SYNC_NUM_LENGTH]; \n InputSyncV #(.WIDTH (4)) \n  sync_sw \n (.CLK_I (int_TFTClk),.D_I (SW_I[3:0]),.D_O (MSEL_O)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a simple 7-segment display controller. It takes in clock and reset signals, input and data enables, addresses, data write signal, and input data. It also has output data signals for input and output, as well as signals for controlling the 7-segment display. The module cycles through the 7-segment display digits and updates the display content based on the input data and control signals. It uses a counter to control the display refresh rate.\n\n Module header:\n\nmodule mod_sseg(rst, clk, ie, de, iaddr, daddr, drw, din, iout, dout, sseg_an, sseg_display);\n [/INST]\n", "output": "input rst; \n  input clk; \n  input ie,de; \n  input [31:0] iaddr, daddr; \n  input [1:0] drw; \n  input [31:0] din; \n  output [31:0] iout, dout; \n  output reg [3:0] sseg_an; \n  output [7:0] sseg_display; \n  wire [31:0] idata, ddata; \n  assign iout = idata; \n  assign dout = ddata; \n  reg [31:0] sseg; \n  assign idata = 32'h00000000; \n  assign ddata = sseg; \n  parameter CLOCK_FREQ = 25000000; \n  parameter TICKS = CLOCK_FREQ/240; \n  reg [31:0] counter; \n  assign sseg_display = sseg_an == 4'b1110 ? sseg[7:0] : \n  sseg_an == 4'b1101 ? sseg[15:8] : \n  sseg_an == 4'b1011 ? sseg[23:16] : \n  sseg_an == 4'b0111 ? sseg[31:24] : sseg[7:0]; \n  always @(negedge clk) begin \n  if (drw[0] && de && !rst) begin \n  sseg = din; \n  end else if (rst) begin \n  sseg = 32'h00000000; \n  counter = 0; \n  end \n  counter = counter + 1; \n  if (counter == TICKS) begin \n  counter = 0; \n  sseg_an = sseg_an == 4'b1110 ? 4'b1101 : \n  sseg_an == 4'b1101 ? 4'b1011 : \n  sseg_an == 4'b1011 ? 4'b0111 : \n  sseg_an == 4'b0111 ? 4'b1110 : 4'b1110; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module SB_GB is a global buffer that passes the input signal USER_SIGNAL_TO_GLOBAL_BUFFER to the output GLOBAL_BUFFER_OUTPUT without any modification.\n\n Module header:\n\nmodule SB_GB (input USER_SIGNAL_TO_GLOBAL_BUFFER,output GLOBAL_BUFFER_OUTPUT);\n [/INST]\n", "output": "assign GLOBAL_BUFFER_OUTPUT = USER_SIGNAL_TO_GLOBAL_BUFFER; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a carry latch and an AND gate. It has a parameter for the FPGA family and uses an RTL module if the family is \"rtl\", or an FPGA module otherwise. Inside the module, it creates a wire for the inverted input, assigns the inverted input to the wire, and then either directly assigns the output based on the inverted input and CIN for the RTL case, or instantiates an AND2B1L instance and configures it to produce the output based on the inverted input and CIN for the FPGA case.\n\n Module header:\n\nmodule generic_baseblocks_v2_1_0_carry_latch_and # (parameter C_FAMILY = \"virtex6\") (input wire CIN,input wire I,output wire O);\n [/INST]\n", "output": "generate \n  if ( C_FAMILY == \"rtl\" ) begin : USE_RTL \n  assign O = CIN & ~I; \n  end else begin : USE_FPGA \n  wire I_n; \n  assign I_n = ~I; \n  AND2B1L and2b1l_inst \n (.O(O),.DI(CIN),.SRI(I_n)); \n  end \n  endgenerate \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a 32-bit RAM with byte write enable. It has inputs for clock, write enable, address, and data in, and an output for data out. The RAM has a size of 1024 and each column has 8 bits. The module includes an initial block to read memory from a file and updates the RAM based on the write enable signals and input data when the clock signal is asserted. The output data is determined based on the address input.\n\n Module header:\n\nmodule bytewrite_ram_32bits (clk, we, addr, din, dout);\n [/INST]\n", "output": "parameter SIZE = 1024; \n parameter ADDR_WIDTH = 12; \n parameter filename = \"code.hex\"; \n localparam COL_WIDTH = 8; \n localparam NB_COL = 4; \n input clk; \n input [NB_COL-1:0] we; \n input [ADDR_WIDTH-1:0] addr; \n input [NB_COL*COL_WIDTH-1:0] din; \n output [NB_COL*COL_WIDTH-1:0] dout; \n reg [NB_COL*COL_WIDTH-1:0] RAM [SIZE-1:0]; \n  integer _i; \n  wire [ADDR_WIDTH-1:0] addr_dly; \n  reg [NB_COL*COL_WIDTH-1:0] dout_int; \n initial begin \n `ifndef NO_RAM_INIT \n  $readmemh(filename,RAM); \n `endif \n end \n always @(posedge clk) \n  begin \n  dout_int <= RAM[addr]; \n end \n  assign dout = dout_int; \n always @(posedge clk) begin \n  if (we[0]) begin \n  RAM[addr][(0+1)*COL_WIDTH-1:0*COL_WIDTH] <= din[(0+1)*COL_WIDTH-1:0*COL_WIDTH]; \n  end \n end \n always @(posedge clk) begin \n  if (we[1]) \n  RAM[addr][(1+1)*COL_WIDTH-1:1*COL_WIDTH] <= din[(1+1)*COL_WIDTH-1:1*COL_WIDTH]; \n end \n always @(posedge clk) begin \n  if (we[2]) \n  RAM[addr][(2+1)*COL_WIDTH-1:2*COL_WIDTH] <= din[(2+1)*COL_WIDTH-1:2*COL_WIDTH]; \n end \n always @(posedge clk) begin \n  if (we[3]) \n  RAM[addr][(3+1)*COL_WIDTH-1:3*COL_WIDTH] <= din[(3+1)*COL_WIDTH-1:3*COL_WIDTH]; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an I2S to TDM converter, which takes inputs from the I2S interface (rst_i, mck_i, bck_i, lrck_i, dat_i) and generates outputs for the TDM interface (sck_o, fsync_o, dat_o). It includes internal logic for clock synchronization, bit counting, and FIFO management.\n\nThe module uses the input signals to control the internal state and generate the appropriate TDM interface outputs. It also includes logic for synchronization and reset handling. The FIFO management handles the writing and reading of data for the TDM interface.\n\nAdditionally, the module includes a negedge flag for the LRCK signal and handles the synchronization of various clock signals. The bit counter is used for managing the data flow and controlling the write and read operations in the FIFO.\n\nThe output dat_o is generated based on the current state and the contents of the FIFO. The fsync_o output is derived from the bit count.\n\nOverall, this module acts as a bridge between the I2S and TDM interfaces, managing the synchronization and data flow between the two.\n\n Module header:\n\nmodule i2s_to_tdm_comverter(rst_i,mck_i,bck_i,lrck_i,dat_i,sck_o,fsync_o,dat_o);\n [/INST]\n", "output": "input rst_i; \n  input mck_i; \n  input bck_i; \n  input lrck_i; \n  input [3:0] dat_i; \n  output sck_o; \n  output fsync_o; \n  output reg dat_o; \n  reg rst_int; \n  wire rst = rst_i | rst_int; \n  reg [8:0] bit_cnt; \n  wire bank = bit_cnt[8]; \n  wire sck = mck_i; \n  assign sck_o = sck; \n  wire [5:0] inbit_cnt = bit_cnt[7:2]; \n  reg d_lrck_1, d_lrck_2, d_lrck_3, d_lrck_4, d_lrck_5, d_lrck_6; \n  wire lrck_negedge_flag; \n  assign lrck_negedge_flag = (d_lrck_4 ^ d_lrck_6) & ~d_lrck_4; \n  always @ (posedge sck or posedge rst_i) begin \n  if(rst_i) begin \n  d_lrck_1 <= 1'b0; \n  d_lrck_2 <= 1'b0; \n  d_lrck_3 <= 1'b0; \n  d_lrck_5 <= 1'b0; \n  end \n  else begin \n  d_lrck_1 <= lrck_i; \n  d_lrck_2 <= d_lrck_1; \n  d_lrck_3 <= d_lrck_2; \n  d_lrck_5 <= d_lrck_4; \n  end \n  end \n  always @ (negedge sck or posedge rst_i) begin \n  if(rst_i) begin \n  d_lrck_4 <= 1'b0; \n  d_lrck_6 <= 1'b0; \n  end \n  else begin \n  d_lrck_4 <= d_lrck_3; \n  d_lrck_6 <= d_lrck_5; \n  end \n  end \n  always @ (negedge d_lrck_4 or posedge rst_i) begin \n  if(rst_i) begin \n  rst_int <= 1'b1; \n  end \n  else begin \n  if(&bit_cnt[7:0]) begin \n  rst_int <= 1'b0; \n  end \n  else begin \n  rst_int <= 1'b1; \n  end \n  end \n  end \n  always @ (negedge sck or posedge rst) begin \n  if(rst) begin \n  bit_cnt <= 9'b111111111; \n  end \n  else begin \n  bit_cnt <= bit_cnt + 1'b1; \n  end \n  end \n  reg [255:0] fifo_a; \n  reg [255:0] fifo_b; \n  always @ (posedge bck_i or posedge rst) begin \n  if(rst) begin \n  fifo_a <= 256'b0; \n  fifo_b <= 256'b0; \n  end \n  else begin \n  if(!bank) begin \n  fifo_a[255-bit_cnt[7:2]] <= dat_i[0]; \n  fifo_a[191-bit_cnt[7:2]] <= dat_i[1]; \n  fifo_a[127-bit_cnt[7:2]] <= dat_i[2]; \n  fifo_a[63-bit_cnt[7:2]] <= dat_i[3]; \n  end \n  else begin \n  fifo_b[255-bit_cnt[7:2]] <= dat_i[0]; \n  fifo_b[191-bit_cnt[7:2]] <= dat_i[1]; \n  fifo_b[127-bit_cnt[7:2]] <= dat_i[2]; \n  fifo_b[63-bit_cnt[7:2]] <= dat_i[3]; \n  end \n  end \n  end \n  always @ (posedge sck or posedge rst) begin \n  if(rst) begin \n  dat_o <= 1'b0; \n  end \n  else begin \n  if(!bank) begin \n  dat_o <= fifo_b[255-bit_cnt[7:0]]; \n  end \n  else begin \n  dat_o <= fifo_a[255-bit_cnt[7:0]]; \n  end \n  end \n  end \n  assign fsync_o = &bit_cnt[7:0]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module is a test bench for the SPIM module. It instantiates the SPIM module and generates the clock and reset signals, data inputs, write enable signal, and other control signals to test the functionality of the SPIM module. The test bench initializes the signals, waits for specific clock cycles, sets the input data, and control signals to test the behavior of the SPIM module. The module creates the clock signal, inverts it, and also generates the reset signal to test the SPIM module under various conditions.\n\n Module header:\n\nmodule tb_spim;\n [/INST]\n", "output": "reg clk; \n  reg rst; \n  reg [7:0] din; \n  reg wen; \n  reg wdiv; \n  wire rdy; \n  wire SCLK; \n  wire MOSI; \n  wire SSbar; \n spim uut (.clk(clk),.rst(rst),.din(din),.wen(wen),.wdiv(wdiv),.rdy(rdy),.SCLK(SCLK),.MOSI(MOSI),.SSbar(SSbar)); \n  initial begin \n  clk = 0; \n  rst = 0; \n  din = 0; \n  wen = 0; \n  wdiv = 0; \n  rst = 1; \n  #100; \n  rst = 0; \n  din = 0; \n  wdiv = 1; \n  #40; \n  wdiv = 0; \n  #40; \n  din = 8'h55; \n  wen = 1; \n  #40; \n  wen = 0; \n  #5000; \n  din = 8'h45; \n  wen = 1; \n  #40; \n  wen = 0; \n  end \n  always begin \n  #20 clk = ~clk; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a SPI (Serial Peripheral Interface) master that interfaces with an external device using SPI protocol. It includes logic to generate the SPI clock and control the data transfer. The module has inputs for clock, reset, start signal, and data, and outputs for done signal, busy signal, data, and SPI signals. The clock and reset logic generate the SPI clock signal and control the data transfer based on the start signal and the input data. The module ensures proper timing and signaling for SPI data transmission. The SPI MOSI (Master Out Slave In) output is connected to the shift register for data transmission, and the module generates the SPI clock and slave select signals based on the input signals. The module also manages the busy signal to indicate when the SPI transfer is in progress.\n\n Module header:\n\nmodule spi_master (clk_i,rst_i,start_i,done_o,busy_o,data_i,data_o,spi_clk_o,spi_ss_o,spi_mosi_o,spi_miso_i);\n [/INST]\n", "output": "parameter [31:0] CLK_DIV = 32; \n parameter [31:0] TRANSFER_WIDTH = 8; \n input clk_i ; \n input rst_i ; \n input start_i ; \n output done_o ; \n output busy_o ; \n input [(TRANSFER_WIDTH - 1):0] data_i ; \n output [(TRANSFER_WIDTH - 1):0] data_o ; \n output spi_clk_o ; \n output spi_ss_o ; \n output spi_mosi_o ; \n input spi_miso_i ; \n reg running; \n integer cycle_count; \n reg [(TRANSFER_WIDTH - 1):0] shift_reg; \n reg spi_clk_gen; \n reg last_clk_gen; \n integer clk_div_count; \n reg done_o; \n reg spi_ss_o; \n reg spi_clk_o; \n always @ (posedge clk_i or posedge rst_i ) \n begin \n  if (rst_i == 1'b1) \n  begin \n  clk_div_count <= 0; \n  spi_clk_gen <= 1'b0; \n  end \n  else \n  begin \n  if (running == 1'b1) \n  begin \n  if (clk_div_count == (CLK_DIV - 1)) \n  begin \n  spi_clk_gen <= ~(spi_clk_gen); \n  clk_div_count <= 0; \n  end \n  else \n  clk_div_count <= (clk_div_count + 1); \n  end \n  else \n  spi_clk_gen <= 1'b0; \n  end \n end \n always @ (posedge clk_i or posedge rst_i ) \n begin \n  if (rst_i == 1'b1) \n  begin \n  cycle_count <= 0; \n  shift_reg <= {(TRANSFER_WIDTH - 0){1'b0}}; \n  last_clk_gen <= 1'b0; \n  spi_clk_o <= 1'b0; \n  running <= 1'b0; \n  done_o <= 1'b0; \n  spi_ss_o <= 1'b0; \n  end \n  else \n  begin \n  last_clk_gen <= spi_clk_gen; \n  done_o <= 1'b0; \n  if (running == 1'b0) \n  begin \n  if (start_i == 1'b1) \n  begin \n  cycle_count <= 0; \n  shift_reg <= data_i; \n  running <= 1'b1; \n  spi_ss_o <= 1'b1; \n  end \n  end \n  else \n  begin \n  if ((last_clk_gen == 1'b1) && (spi_clk_gen == 1'b0)) \n  begin \n  spi_clk_o <= 1'b0; \n  cycle_count <= (cycle_count + 1); \n  shift_reg <= {shift_reg[(TRANSFER_WIDTH - 2):0],spi_miso_i}; \n  if (cycle_count == (TRANSFER_WIDTH - 1)) \n  begin \n  running <= 1'b0; \n  done_o <= 1'b1; \n  spi_ss_o <= 1'b0; \n  end \n  end \n  else if ((last_clk_gen == 1'b0) & (spi_clk_gen == 1'b1)) \n  begin \n  spi_clk_o <= 1'b1; \n  end \n  end \n  end \n end \n assign spi_mosi_o = shift_reg[(TRANSFER_WIDTH - 1)]; \n assign data_o = shift_reg; \n assign busy_o = ((running == 1'b1) || (start_i == 1'b1)) ? 1'b1 : 1'b0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module \"fpoint_qsys\" implements a fixed-point arithmetic unit with the ability to perform addition, subtraction, and multiplication. It has input ports for clock, clock enable, data signals (dataa and datab), a 2-bit control signal (n), a reset signal, and a start signal. The module also has output ports for a 32-bit result and a completion signal named \"done.\"\n\nInternally, the module includes registers for dataa and datab, a 4-bit counter, and various wires for control signals and intermediate results. It instantiates two submodules, one for multiplication and one for addition/subtraction. The submodules receive the clock, clock enable, and data signals from the main module.\n\nThe module uses an always block to update the dataa and datab registers based on the clock and clock enable signals. It also includes logic for controlling the counter, determining when the operation is complete, and selecting the result based on the control signal \"n.\"\n\nOverall, the \"fpoint_qsys\" module provides a scalable and flexible fixed-point arithmetic unit with the capability to perform multiple operations and handle different data widths.\n\n Module header:\n\nmodule fpoint_qsys (clk,clk_en,dataa,datab,n,reset,start,done,result);\n [/INST]\n", "output": "output done; \n  output [ 31: 0] result; \n  input clk; \n  input clk_en; \n  input [ 31: 0] dataa; \n  input [ 31: 0] datab; \n  input [ 1: 0] n; \n  input reset; \n  input start; \n  wire add_sub; \n  wire [ 3: 0] counter_in; \n  reg [ 3: 0] counter_out; \n  reg [ 31: 0] dataa_regout; \n  reg [ 31: 0] datab_regout; \n  wire done; \n  wire [ 3: 0] load_data; \n  wire local_reset_n; \n  wire [ 31: 0] result; \n  wire [ 31: 0] result_addsub; \n  wire [ 31: 0] result_mult; \n  always @(posedge clk or negedge local_reset_n) \n  begin \n  if (local_reset_n == 0) \n  dataa_regout <= 0; \n  else if (clk_en) \n  dataa_regout <= dataa; \n  end \n  always @(posedge clk or negedge local_reset_n) \n  begin \n  if (local_reset_n == 0) \n  datab_regout <= 0; \n  else if (clk_en) \n  datab_regout <= datab; \n  end \n  fpoint_qsys_mult_single the_fp_mult \n (.aclr (reset),.clk_en (clk_en),.clock (clk),.dataa (dataa_regout),.datab (datab_regout),.result (result_mult)); \n  fpoint_qsys_addsub_single the_fp_addsub \n (.aclr (reset),.add_sub (add_sub),.clk_en (clk_en),.clock (clk),.dataa (dataa_regout),.datab (datab_regout),.result (result_addsub)); \n  always @(posedge clk or negedge local_reset_n) \n  begin \n  if (local_reset_n == 0) \n  counter_out <= 4'd10; \n  else if (clk_en) \n  counter_out <= counter_in; \n  end \n  assign counter_in = (start == 0)? counter_out - 1'b1 : \n  load_data; \n  assign add_sub = n[0]; \n  assign local_reset_n = ~reset; \n  assign done = clk_en & ~|counter_out & ~start; \n  assign load_data = (n == 0)? 10 : \n  (n == 1)? 8 : \n  8; \n  assign result = (n == 0)? result_mult : \n  (n == 1)? result_addsub : \n  result_addsub; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module has one 2-bit output \"out\" that is assigned a constant value of 2.\n\n Module header:\n\nmodule GeneratorUnsigned2(out);\n [/INST]\n", "output": "output wire [1:0] out; \n  assign out = 2; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module represents a UART (Universal Asynchronous Receiver/Transmitter) light receiver with various control and status signals. It includes a shifter register for received data, bit and sampling counters, and logic to handle clock domain crossing and frame detection. The module interfaces with a First In First Out (FIFO) buffer for data storage. It also includes reset logic and signal conditioning for the received data.\n\n Module header:\n\nmodule uart_light_rx_dp #(parameter WORD_SIZE = 8,parameter BC_SIZE = 3,parameter SAMPLING_COUNT = 15,parameter SC_SIZE = 4,parameter FIFO_ADDR_BITS = 5)(input wire reset,input wire clk_peri,input wire clk_rx,input wire rx,output wire [WORD_SIZE-1:0] word_rx,input wire sc_inc,input wire sc_clr,input wire bc_inc,input wire bc_clr,input wire shift,input wire fifo_write_enable,output wire bit_eq_0,output wire sc_halb,output wire sc_full,output wire frame_done,input wire fifo_read_enable,output wire fifo_full,output wire fifo_empty);\n [/INST]\n", "output": "reg rx0, rx1; \n  reg [WORD_SIZE-1:0] shfreg_rx; \n  reg [BC_SIZE:0] bit_counter; \n  reg [SC_SIZE-1:0] sampling_counter; \n  assign bit_eq_0 = (rx1 == 1'b0); \n  assign sc_halb = (sampling_counter == ((SAMPLING_COUNT-1)/2) - 1'b1); \n  assign sc_full = (sampling_counter == SAMPLING_COUNT - 1'b1); \n  assign frame_done = (bit_counter == WORD_SIZE); \n  always @(posedge clk_rx, posedge reset) begin \n  if(reset==1'b1) begin \n  bit_counter <= {(BC_SIZE+1){1'b0}}; \n  sampling_counter <= {(SC_SIZE){1'b0}}; \n  shfreg_rx <= {(WORD_SIZE){1'b0}}; \n  rx0 <= 1'b1; \n  rx1 <= 1'b1; \n  end \n  else begin \n  rx0 <= rx; \n  rx1 <= rx0; \n  if(sc_clr) \n  sampling_counter <= {(SC_SIZE){1'b0}}; \n  else if(sc_inc) \n  sampling_counter <= sampling_counter + 1'b1; \n  if(bc_clr) \n  bit_counter <= {(BC_SIZE+1){1'b0}}; \n  else if(bc_inc) \n  bit_counter <= bit_counter + 1'b1; \n  if(shift) \n  shfreg_rx <= {rx1,shfreg_rx[WORD_SIZE-1:1]}; \n  end \n  end \n  yaf # \n (.DSIZE (WORD_SIZE),.ASIZE (FIFO_ADDR_BITS)) \n  yaf_rx0 \n (.rdata( word_rx ),.wfull( ),.rfull( ),.rwfull( fifo_full ),.wempty( ),.rempty( ),.rwempty( fifo_empty ),.fill( ),.wdata( shfreg_rx[WORD_SIZE-1:0]),.winc( fifo_write_enable ),.wclk( clk_rx ),.wrst_n( ~reset ),.rinc( fifo_read_enable ),.rclk( clk_peri ),.rrst_n ( ~reset ),.rptr_upd( 1'b0 ),.rptr_rest( 1'b0 ),.wptr_upd( 1'b0 ),.wptr_rest( 1'b0 )); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a 7-segment display driver. It takes in a 4-bit input `digit` and a 2-bit input `sel`, and it drives the anode and cathode outputs to display the appropriate digit based on the input values. The `sel` input selects which digit is being displayed, and the `digit` input represents the value to be displayed. The module uses case statements to assign the appropriate anode and cathode values based on the input values.\n\n Module header:\n\nmodule sseg_driver(input wire [ 3 : 0] digit,input wire [ 1 : 0] sel,output reg [ 3 : 0] anode,output reg [ 6 : 0] cathode);\n [/INST]\n", "output": "always @(sel) begin \n  case(sel) \n  2'b00: anode = 4'b1110; \n  2'b01: anode = 4'b1101; \n  2'b10: anode = 4'b1011; \n  2'b11: anode = 4'b0111; \n  endcase \n  end \n  always @(digit) begin \n  case(digit) \n  4'h0: cathode = 7'b0000001; \n  4'h1: cathode = 7'b1001111; \n  4'h2: cathode = 7'b0010010; \n  4'h3: cathode = 7'b0000110; \n  4'h4: cathode = 7'b1001100; \n  4'h5: cathode = 7'b0100100; \n  4'h6: cathode = 7'b0100000; \n  4'h7: cathode = 7'b0001111; \n  4'h8: cathode = 7'b0000000; \n  4'h9: cathode = 7'b0000100; \n  4'ha: cathode = 7'b0001000; \n  4'hb: cathode = 7'b1100000; \n  4'hc: cathode = 7'b0110001; \n  4'hd: cathode = 7'b1000010; \n  4'he: cathode = 7'b0110000; \n  4'hf: cathode = 7'b0111000; \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a scrambler that takes in unscrambled data and scrambles it according to the specified polynomial and seed. It operates on the rising edge of the user clock and uses a delay in assigning the output. The scrambling process involves iterating through each bit of the unscrambled data, performing XOR operations, and updating the polynomial and tempData registers accordingly. The output is the scrambled data, which is delayed by one clock cycle, and the scrambler seed is updated with the new polynomial value. The process is triggered only when data is valid.\n\n Module header:\n\n module aurora_64b66b_25p4G_SCRAMBLER_64B66B # (parameter SCRAMBLER_SEED = 58'h2AA_AAAA_AAAA_AAAA,parameter TX_DATA_WIDTH = 64) (UNSCRAMBLED_DATA_IN,SCRAMBLED_DATA_OUT,DATA_VALID_IN,USER_CLK,SYSTEM_RESET);\n [/INST]\n", "output": "input [0:(TX_DATA_WIDTH-1)] UNSCRAMBLED_DATA_IN; \n  input DATA_VALID_IN; \n  output [(TX_DATA_WIDTH-1):0] SCRAMBLED_DATA_OUT; \n  input USER_CLK; \n  input SYSTEM_RESET; \n  integer i; \n  reg [57:0] poly; \n  reg [57:0] scrambler = SCRAMBLER_SEED; \n  reg [0:(TX_DATA_WIDTH-1)] tempData = {TX_DATA_WIDTH{1'b0}}; \n  reg xorBit; \n  reg [(TX_DATA_WIDTH-1):0] SCRAMBLED_DATA_OUT; \n  always @(scrambler,UNSCRAMBLED_DATA_IN) \n  begin \n  poly = scrambler; \n  for (i=0;i<=(TX_DATA_WIDTH-1);i=i+1) \n  begin \n  xorBit = UNSCRAMBLED_DATA_IN[i] ^ poly[38] ^ poly[57]; \n  poly = {poly[56:0],xorBit}; \n  tempData[i] = xorBit; \n  end \n  end \n always @(posedge USER_CLK) \n begin \n  if (DATA_VALID_IN) \n  begin \n  SCRAMBLED_DATA_OUT <= `DLY tempData; \n  scrambler <= `DLY poly; \n  end \n end \n  endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a synchronizer with parameters for the depth of synchronization (DP) and the width of data (DW). It uses a generate block to create a chain of flip-flops for synchronization. The input data is passed through a series of flip-flops and the synchronized output is assigned to the output port. The reset signal (rst_n) and clock (clk) control the operation of the flip-flops.\n\n Module header:\n\nmodule sirv_gnrl_sync # (parameter DP = 2,parameter DW = 32) (input [DW-1:0] din_a,output [DW-1:0] dout,input rst_n,input clk);\n [/INST]\n", "output": "wire [DW-1:0] sync_dat [DP-1:0]; \n  genvar i; \n  generate \n  for(i=0;i<DP;i=i+1) begin:sync_gen \n  if(i==0) begin:i_is_0 \n  sirv_gnrl_dffr #(DW) sync_dffr(din_a, sync_dat[0], clk, rst_n); \n  end \n  else begin:i_is_not_0 \n  sirv_gnrl_dffr #(DW) sync_dffr(sync_dat[i-1], sync_dat[i], clk, rst_n); \n  end \n  end \n  endgenerate \n  assign dout = sync_dat[DP-1]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `fir_hw_mul_18s_15s_33_3_MAC3S_0` implements a 18x15 bit multiplier with a 33-bit output. The module takes in clock and enable signals, along with two input signals a and b. The output signal p is the product of a and b. Inside the module, a_reg0 and b_reg0 are used to store the input signals a and b respectively. The temporary product signal tmp_product is computed by multiplying a_reg0 and b_reg0. The output buffer buff0 stores the product. The product is updated on the positive edge of the clock when the enable signal ce is asserted.\n\n Module header:\n\n module fir_hw_mul_18s_15s_33_3_MAC3S_0(clk, ce, a, b, p);\n [/INST]\n", "output": "input clk; \n input ce; \n input[18 - 1 : 0] a; \n input[15 - 1 : 0] b; \n output[33 - 1 : 0] p; \n reg signed [18 - 1 : 0] a_reg0; \n reg signed [15 - 1 : 0] b_reg0; \n wire signed [33 - 1 : 0] tmp_product; \n reg signed [33 - 1 : 0] buff0; \n assign p = buff0; \n assign tmp_product = a_reg0 * b_reg0; \n always @ (posedge clk) begin \n  if (ce) begin \n  a_reg0 <= a; \n  b_reg0 <= b; \n  buff0 <= tmp_product; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a buffer gate that can optionally invert the input signal based on the INVERT parameter. The module takes an input signal I and outputs it on signal O, which may be the inverted form of the input if the INVERT parameter is set.\n\n Module header:\n\nmodule BUFGSR(I, O);\n [/INST]\n", "output": "parameter INVERT = 0; \n  input I; \n  output O; \n  assign O = INVERT ? ~I : I; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module v8d4ef5 instantiates a submodule v8d4ef5_vbd6086 and connects its input and output signals. The parameter v5e4a03 is set to the value 'h10000. The input signals ve61673, v7c533e, and vdd729a are connected to the submodule inputs rst, cnt, and clk, respectively. The output signals va1a83a and v712cd1 are connected to the submodule outputs q and ov, respectively. The submodule v8d4ef5_vbd6086 is not provided, but it is assumed to be another Verilog module.\n\n Module header:\n\nmodule v8d4ef5 #(parameter v5e4a03 = 'h10000) (input vdd729a,input ve61673,input v7c533e,output [15:0] va1a83a,output v712cd1);\n [/INST]\n", "output": "localparam p1 = v5e4a03; \n  wire w0; \n  wire w2; \n  wire w3; \n  wire w4; \n  wire [0:15] w5; \n  assign w0 = ve61673; \n  assign w2 = v7c533e; \n  assign w3 = vdd729a; \n  assign v712cd1 = w4; \n  assign va1a83a = w5; \n v8d4ef5_vbd6086 #(.M(p1)) vbd6086 (.rst(w0),.cnt(w2),.clk(w3),.ov(w4),.q(w5)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a branch predictor that takes in a program counter (pc), instruction register (ir), hit signal, and branch target buffer branch address (btb_branch_addr) as inputs. It then utilizes various submodules to decode the instruction and calculate the branch address, and based on the instruction type and hit status, predicts the next instruction address to be executed. The output consists of the predicted branch instruction, predicted address, and other control signals. This module effectively predicts and manages branch instructions in a processor pipeline.\n\n Module header:\n\nmodule branch_predictor #(parameter DATA_WIDTH = 32) (input [DATA_WIDTH-1:0] pc,input [DATA_WIDTH-1:0] ir,input hit,input [DATA_WIDTH-1:0] btb_branch_addr,output IF_branch,output [DATA_WIDTH-1:0] IF_predict_branch,output [DATA_WIDTH-1:0] predict_addr);\n [/INST]\n", "output": "wire [5:0] op; \n  wire [5:0] funct; \n  wire [15:0] imm16; \n  wire [25:0] imm26; \n  wire beq, bne, j, jal, bgtz; \n  wire [DATA_WIDTH-1:0] addr_imm; \n decoder decoder (.instruction(ir),.op(op),.rs(),.rt(),.rd(),.sham(),.funct(funct),.imm16(imm16),.imm26(imm26)); \n instruction_typer typer (.op(op),.funct(funct),.add(),.addi(),.addiu(),.addu(),.s_and(),.andi(),.sll(),.sra(),.srl(),.sub(),.s_or(),.ori(),.s_nor(),.lw(),.sw(),.beq(beq),.bne(bne),.slt(),.slti(),.sltu(),.j(j),.jal(jal),.jr(),.syscall(),.divu(),.mflo(),.lb(),.bgtz(bgtz)); \n address_calculator #(.DATA_WIDTH(DATA_WIDTH)) address_calculator (.pc(pc),.imm16(imm16),.imm26(imm26),.addr_imm(addr_imm),.addr_branch(IF_predict_branch)); \n  assign IF_branch = (beq || bne || bgtz); \n  assign predict_addr = (j || jal) ? addr_imm \n  : hit ? btb_branch_addr \n  : IF_branch ? IF_predict_branch \n  : (pc + 4); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a gated D flip-flop with asynchronous and synchronous controls. It initializes q to 0 and updates q on the clock edge. It sets q to 0 if clr is asserted and to 1 if pre is asserted. If ald is asserted, q is set to adt. If ena and sclr are both asserted, q is set to 0 if sclr is asserted, to adt if sload is asserted, and to d if sload is not asserted. The clk_pre signal is updated with the value of clk.\n\n Module header:\n\nmodule prim_gdff (q, d, clk, ena, clr, pre, ald, adt, sclr, sload );\n [/INST]\n", "output": "input d,clk,ena,clr,pre,ald,adt,sclr,sload; \n  output q; \n  reg q; \n  reg clk_pre; \n  initial q = 1'b0; \n  always@ (clk or clr or pre or ald or adt) \n  begin \n  if (clr == 1'b1) \n  q <= 1'b0; \n  else if (pre == 1'b1) \n  q <= 1'b1; \n  else if (ald == 1'b1) \n  q <= adt; \n  else if ((clk == 1'b1) && (clk_pre == 1'b0)) \n  begin \n  if (ena == 1'b1) \n  begin \n  if (sclr == 1'b1) \n  q <= 1'b0; \n  else if (sload == 1'b1) \n  q <= adt; \n  else \n  q <= d; \n  end \n  end \n  clk_pre <= clk; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module implements phase shifting by updating the phi_1 output based on the phase difference between baseclk and phi_0. It uses a delay parameter and an internal counter to control the update of phi_1. When the phase difference occurs, it sets phi_1 to phi_0 and then decrements the counter until it reaches zero.\n\n Module header:\n\nmodule ag6502_phase_shift(input baseclk, input phi_0, output reg phi_1);\n [/INST]\n", "output": "parameter DELAY = 1; \n  initial phi_1 = 0; \n  integer cnt = 0; \n  always @(posedge baseclk) begin \n  if (phi_0 != phi_1) begin \n  if (!cnt) begin phi_1 <= phi_0; cnt <= DELAY; end \n  else cnt <= cnt - 1; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a counter with configurable width W. It has inputs for clock, reset, load, and enable signals, as well as an input data bus d. The module also has outputs for the count value q, a signal indicating the maximum count reached (max_tick), and a signal indicating the minimum count reached (min_tick). The count value q increments on each clock cycle when the enable signal is asserted, and can be loaded with the input data when the load signal is asserted. The max_tick output is asserted when the count reaches its maximum value (2^W-1), and the min_tick output is asserted when the count reaches its minimum value (0).\n\n Module header:\n\nmodule cont_test #(parameter W=4)(input wire clk,input wire rst,input wire load,input wire enable,input wire [W-1:0] d,output wire max_tick,output wire min_tick,output wire [W-1:0] q);\n [/INST]\n", "output": "reg [W-1:0] count; \n  always @(posedge clk, posedge rst) \n  begin \n  if (rst) \n  count <= 0; \n  else if (enable) \n  begin \n  if (load) \n  begin \n  count <= d; \n  end \n  else \n  count <= count + 1'b1; \n  end \n  end \n  assign q = count; \n  assign max_tick = (count == 2**W-1) ? 1'b1 : 1'b0; \n  assign min_tick = (count == 0) ? 1'b1 : 1'b0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an arithmetic unit that performs addition or subtraction based on the input operator. It uses a multiplexer to select the input KEY_IN as the augend or addend based on the value of slt. The module also handles the calculation of tens and units place for the result, as well as the sign bit. The outputs are the tens place, units place, augend, addend, and the sign result.\n\n Module header:\n\nmodule ADD_SUB(A, B, value_result_tens, value_result_units, sign_result, KEY_IN, clk, reset_n, operator);\n [/INST]\n", "output": "output [3:0] value_result_tens; \n  output [3:0] value_result_units; \n  output [3:0] A; \n  output [3:0] B; \n  output sign_result; \n  input [1:0] operator; \n  input [3:0] KEY_IN; \n  input reset_n; \n  input clk; \n  reg [3:0] next_A, next_B, next_ten, next_unit; \n  reg slt; \n  reg next_sign; \n  reg tmpIn; \n  always @(posedge clk) begin \n  if (!reset_n) begin \n  next_A <= 0; \n  next_B <= 0; \n  next_ten <= 0; \n  next_unit <= 0; \n  next_sign <= 0; \n  slt <= 0; \n  end else begin \n  if (KEY_IN == 4'hA) begin \n  slt <= 0; \n  end else if (KEY_IN == 4'hB) begin \n  slt <= 1; \n  end else begin \n  if (slt == 0) begin \n  next_A <= KEY_IN; \n  end else begin \n  next_B <= KEY_IN; \n  end \n  end \n  if (operator[0] == 0) begin \n  if (A+B >= 10) begin \n  next_ten <= 1; \n  next_unit <= A + B - 10; \n  end else begin \n  next_ten <= 0; \n  next_unit <= A + B; \n  end \n  next_sign <= 0; \n  end else if (operator[1] == 0) begin \n  if (A > B || A == B) begin \n  {next_ten, next_unit} <= A - B; \n  next_sign <= 0; \n  end else begin \n  {next_ten, next_unit} <= B - A; \n  next_sign <= 1; \n  end \n  end else begin \n  {next_ten, next_unit} <= {next_ten, next_unit}; \n  end \n  end \n  end \n  assign A = next_A; \n  assign B = next_B; \n  assign value_result_tens = next_ten; \n  assign value_result_units = next_unit; \n  assign sign_result = next_sign; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an instruction decoder and an integer division and remainder calculation unit for the RV32I PicoRV32 processor. It decodes PCPI (Pico Co-processor Interface) instructions to perform integer division and remainder operations. \n\nThe module has input signals for clock, reset, pcpi_valid, pcpi_insn, pcpi_rs1, and pcpi_rs2; and output signals for pcpi_wr, pcpi_rd, pcpi_wait, and pcpi_ready.\n\nThe module first decodes the PCPI instruction to determine if it corresponds to division, division unsigned, remainder, or remainder unsigned. It then sets up the necessary internal registers for the division and remainder calculation.\n\nDuring each clock cycle, the module performs the division or remainder operation based on the instruction and the input operands. It updates the quotient and remainder registers and sets the pcpi_ready and pcpi_wr signals when the operation is completed.\n\nThe division algorithm uses shift and subtract operations to compute the quotient and remainder. The module handles both signed and unsigned division operations and takes into account the sign of the input operands.\n\n Module header:\n\nmodule picorv32_pcpi_div (input clk, resetn,input pcpi_valid,input [31:0] pcpi_insn,input [31:0] pcpi_rs1,input [31:0] pcpi_rs2,output reg pcpi_wr,output reg [31:0] pcpi_rd,output reg pcpi_wait,output reg pcpi_ready);\n [/INST]\n", "output": "reg instr_div, instr_divu, instr_rem, instr_remu; \n  wire instr_any_div_rem = |{instr_div, instr_divu, instr_rem, instr_remu}; \n  reg pcpi_wait_q; \n  wire start = pcpi_wait && !pcpi_wait_q; \n  always @(posedge clk) begin \n  instr_div <= 0; \n  instr_divu <= 0; \n  instr_rem <= 0; \n  instr_remu <= 0; \n  if (resetn && pcpi_valid && !pcpi_ready && pcpi_insn[6:0] == 7'b0110011 && pcpi_insn[31:25] == 7'b0000001) begin \n  case (pcpi_insn[14:12]) \n  3'b100: instr_div <= 1; \n  3'b101: instr_divu <= 1; \n  3'b110: instr_rem <= 1; \n  3'b111: instr_remu <= 1; \n  endcase \n  end \n  pcpi_wait <= instr_any_div_rem; \n  pcpi_wait_q <= pcpi_wait; \n  end \n  reg [31:0] dividend; \n  reg [62:0] divisor; \n  reg [31:0] quotient; \n  reg [31:0] quotient_msk; \n  reg running; \n  reg outsign; \n  always @(posedge clk) begin \n  pcpi_ready <= 0; \n  pcpi_wr <= 0; \n  pcpi_rd <= 'bx; \n  if (!resetn) begin \n  running <= 0; \n  end else \n  if (start) begin \n  running <= 1; \n  dividend <= (instr_div || instr_rem) && pcpi_rs1[31] ? -pcpi_rs1 : pcpi_rs1; \n  divisor <= ((instr_div || instr_rem) && pcpi_rs2[31] ? -pcpi_rs2 : pcpi_rs2) << 31; \n  outsign <= (instr_div && (pcpi_rs1[31] != pcpi_rs2[31]) && |pcpi_rs2) || (instr_rem && pcpi_rs1[31]); \n  quotient <= 0; \n  quotient_msk <= 1 << 31; \n  end else \n  if (!quotient_msk && running) begin \n  running <= 0; \n  pcpi_ready <= 1; \n  pcpi_wr <= 1; \n  if (instr_div || instr_divu) \n  pcpi_rd <= outsign ? -quotient : quotient; \n  else \n  pcpi_rd <= outsign ? -dividend : dividend; \n  end else begin \n  if (divisor <= dividend) begin \n  dividend <= dividend - divisor; \n  quotient <= quotient | quotient_msk; \n  end \n  divisor <= divisor >> 1; \n  quotient_msk <= quotient_msk >> 1; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `baudtest` simulates the generation of baud and baud8 ticks using the `BaudGen` and `Baud8Gen` modules, respectively. It utilizes a system clock `sys_clk` and generates two outputs `BaudTick` and `Baud8Tick`. The system clock toggles every 18.5 time units. This module provides a basic setup for testing the baud and baud8 generation functionality.\n\n Module header:\n\nmodule baudtest;\n [/INST]\n", "output": "reg sys_clk; \n  wire BaudTick; \n  wire Baud8Tick; \n BaudGen uut (.sys_clk(sys_clk),.BaudTick(BaudTick)); \n Baud8Gen uut8 (.sys_clk(sys_clk),.Baud8Tick(Baud8Tick)); \n  initial begin \n  sys_clk = 0; \n  #100; \n  end \n  always begin \n  #18.5 sys_clk <= !sys_clk; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a N64 read command transmitter. It takes a clock signal, trigger signal, and outputs enable_o and dout. It uses a counterM module to generate a counter signal for cycles and a shiftM module to shift the data. The data output is assigned to dout, and enable_o is derived from the counter empty flag.\n\n Module header:\n\nmodule n64_readcmd_tx(input wire clk_1M,input wire trigger,output wire enable_o,output wire dout);\n [/INST]\n", "output": "wire [33:0] data; \n assign dout = data[33]; \n wire ctr_empty; \n assign enable_o = ~ctr_empty; \n counterM #(.M(34)) \n counter_signal_cycles (.clk(clk_1M),.reset(trigger),.empty(ctr_empty)); \n shiftM #(.M(34), .INI(34'b0001000100010001000100010001011101)) \n shift_signal (.clk(clk_1M),.enable(~ctr_empty),.serin(dout),.data(data)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a 4-to-1 multiplexer, with Sel0 as the selection signal and Data0x0, Data0x1, Data0x2, Data0x3 as input data for the 0th selection, and Data1x0, Data1x1, Data1x2, Data1x3 as input data for the 1st selection. The module outputs Result0, Result1, Result2, Result3 based on the selected input data. If Sel0 is 0, it outputs the 0th set of input data, otherwise, it outputs the 1st set of input data.\n\n Module header:\n\nmodule mux4_1_2(Sel0,Data0x0, Data0x1, Data0x2, Data0x3,Data1x0, Data1x1, Data1x2, Data1x3,Result0, Result1, Result2, Result3);\n [/INST]\n", "output": "input Sel0; \n input Data0x0, Data0x1, Data0x2, Data0x3; \n input Data1x0, Data1x1, Data1x2, Data1x3; \n output Result0, Result1, Result2, Result3; \n assign {Result0, Result1, Result2, Result3} = Sel0 ? {Data1x0, Data1x1, Data1x2, Data1x3} : {Data0x0, Data0x1, Data0x2, Data0x3}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an AC97 transceiver, interfacing between an AC97 bus and an internal system bus. It features synchronized input and output signals, with the input synchronized to the negative edge of the AC97 clock and the output to the AC97 reset and clock. It also includes FIFO logic for buffering and synchronization between the AC97 and system buses. The module assigns values to output ports based on the state of the input signals and the logic of the FIFOs, and operates within the context of reset and clock signals for both the internal system and the AC97 bus.\n\n Module header:\n\nmodule ac97_transceiver(input sys_clk,input sys_rst,input ac97_clk,input ac97_rst_n,input ac97_sin,output reg ac97_sout,output reg ac97_sync,output up_stb,input up_ack,output up_sync,output up_data,output down_ready,input down_stb,input down_sync,input down_data);\n [/INST]\n", "output": "reg ac97_sin_r; \n always @(negedge ac97_clk) ac97_sin_r <= ac97_sin; \n reg ac97_syncfb_r; \n always @(negedge ac97_clk) ac97_syncfb_r <= ac97_sync; \n wire up_empty; \n asfifo #(.data_width(2),.address_width(6)) up_fifo (.data_out({up_sync, up_data}),.empty(up_empty),.read_en(up_ack),.clk_read(sys_clk),.data_in({ac97_syncfb_r, ac97_sin_r}),.full(),.write_en(1'b1),.clk_write(~ac97_clk),.rst(sys_rst)); \n assign up_stb = ~up_empty; \n wire ac97_sync_r; \n always @(negedge ac97_rst_n, posedge ac97_clk) begin \n  if(~ac97_rst_n) \n  ac97_sync <= 1'b0; \n  else \n  ac97_sync <= ac97_sync_r; \n end \n wire ac97_sout_r; \n always @(negedge ac97_rst_n, posedge ac97_clk) begin \n  if(~ac97_rst_n) \n  ac97_sout <= 1'b0; \n  else \n  ac97_sout <= ac97_sout_r; \n end \n wire down_full; \n asfifo #(.data_width(2),.address_width(6)) down_fifo (.data_out({ac97_sync_r, ac97_sout_r}),.empty(),.read_en(1'b1),.clk_read(ac97_clk),.data_in({down_sync, down_data}),.full(down_full),.write_en(down_stb),.clk_write(sys_clk),.rst(sys_rst)); \n assign down_ready = ~down_full; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a simple RAM memory unit with separate input and output ports. It consists of input and output enable signals, input and output data addresses, and read and write control signals. The module uses an inferred RAM instantiation to store and retrieve data based on the input and output addresses and the read/write control signals. The module also includes a reset signal and clock signal to control the memory operations.\n\n Module header:\n\nmodule mod_ram(rst, clk, ie, de, iaddr, daddr, drw, din, iout, dout);\n [/INST]\n", "output": "input rst; \n  input clk; \n  input ie,de; \n  input [31:0] iaddr, daddr; \n  input drw; \n  input [31:0] din; \n  output [31:0] iout, dout; \n  wire [31:0] idata, ddata; \n  assign iout = ie ? idata : 32'hzzzzzzzz; \n  assign dout = de ? ddata : 32'hzzzzzzzz; \n  inferred_ram ram(~clk,~clk,1'b1,1'b1,(drw & de),daddr[12:2],iaddr[12:2],din,ddata,idata); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `ClkDiv_20Hz` takes an input clock signal `CLK` and a reset signal `RST`, and produces two output clock signals `CLKOUT` and `CLKOUTn`. The module implements a clock divider that divides the input clock frequency by 20, generating a 20Hz output clock. It uses a 19-bit counter to count the input clock pulses and toggles the `CLKOUT` signal every time the counter reaches a specific value. The `RST` signal resets the counter and the output clock signal. The `CLKOUTn` signal is the complementary output of `CLKOUT`. This module effectively provides a divided output clock signal with a frequency one-twentieth of the input clock frequency.\n\n Module header:\n\nmodule ClkDiv_20Hz(CLK,RST,CLKOUT,CLKOUTn);\n [/INST]\n", "output": "input CLK; \n  input RST; \n  output CLKOUT; \n  output CLKOUTn; \n  reg CLKOUT = 1'b1; \n  parameter cntEndVal = 19'h493E0; \n  reg [18:0] clkCount = 19'h00000; \n  assign CLKOUTn = ~CLKOUT; \n  always @(posedge CLK) begin \n  if(RST == 1'b1) begin \n  CLKOUT <= 1'b0; \n  clkCount <= 0; \n  end \n  else begin \n  if(clkCount == cntEndVal) begin \n  CLKOUT <= ~CLKOUT; \n  clkCount <= 0; \n  end \n  else begin \n  clkCount <= clkCount + 1'b1; \n  end \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module acl_fp_add_sub_fast_double_altpriority_encoder_q28 takes a 4-bit input data and produces a 2-bit output q. It instantiates two altpriority_encoder modules to process the input data and generate intermediate outputs wire_altpriority_encoder41_q, wire_altpriority_encoder41_zero, and wire_altpriority_encoder42_q. The final output q is then determined based on these intermediate outputs using a combinational logic expression.\n\n Module header:\n\nmodule acl_fp_add_sub_fast_double_altpriority_encoder_q28 (data,q) ;\n [/INST]\n", "output": "input [3:0] data; \n  output [1:0] q; \n  wire [0:0] wire_altpriority_encoder41_q; \n  wire wire_altpriority_encoder41_zero; \n  wire [0:0] wire_altpriority_encoder42_q; \n  acl_fp_add_sub_fast_double_altpriority_encoder_nh8 altpriority_encoder41 \n (.data(data[1:0]),.q(wire_altpriority_encoder41_q),.zero(wire_altpriority_encoder41_zero)); \n  acl_fp_add_sub_fast_double_altpriority_encoder_n28 altpriority_encoder42 \n (.data(data[3:2]),.q(wire_altpriority_encoder42_q)); \n  assign \n  q = {wire_altpriority_encoder41_zero, ((wire_altpriority_encoder41_zero & wire_altpriority_encoder42_q) | ((~ wire_altpriority_encoder41_zero) & wire_altpriority_encoder41_q))}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module is a keyboard driver that processes input data from the keyboard and generates corresponding output signals. It includes a data hold register, data cooked register, and data counter register. The module translates the raw input data into cooked data based on a predefined mapping. The output DAT_O combines the cooked data and the data counter. The ACK signal is asserted when the STB signal is asserted. The data hold register is updated on the rising edge of the ready pulse. The module also implements a case statement to map the raw input data to the corresponding cooked data.\n\n Module header:\n\nmodule Keyboard_driver(clk, reset, ready_pulse, Keyboard_Data, ACK, STB, DAT_O);\n [/INST]\n", "output": "input clk; \n  input reset; \n  input ready_pulse; \n  input [7: 0] Keyboard_Data; \n  input STB; \n  output ACK; \n  output [31: 0] DAT_O; \n  reg [31: 0] data_hold = 0; \n  reg [7: 0] data_cooked; \n  reg [23: 0] data_cnt = 0; \n  reg f0 = 0; \n  assign DAT_O = {data_cooked, data_cnt}; \n  assign ACK = STB; \n  always @(posedge ready_pulse) begin \n  if (Keyboard_Data == 8'hf0) \n  f0 <= 1; \n  else begin \n  if (!f0) begin \n  data_hold <= Keyboard_Data; \n  data_cnt <= data_cnt + 1; \n  end else \n  f0 <= 0; \n  end \n  end \n  always @* begin \n  case(data_hold) \n  8'h16: data_cooked = 49; \n  8'h1E: data_cooked = 50; \n  8'h26: data_cooked = 51; \n  8'h25: data_cooked = 52; \n  8'h2E: data_cooked = 53; \n  8'h36: data_cooked = 54; \n  8'h3D: data_cooked = 55; \n  8'h3E: data_cooked = 56; \n  8'h46: data_cooked = 57; \n  8'h45: data_cooked = 48; \n  8'h4E: data_cooked = 45; \n  8'h55: data_cooked = 43; \n  8'h15: data_cooked = 113; \n  8'h1D: data_cooked = 119; \n  8'h24: data_cooked = 101; \n  8'h2D: data_cooked = 114; \n  8'h2C: data_cooked = 116; \n  8'h35: data_cooked = 121; \n  8'h3C: data_cooked = 117; \n  8'h43: data_cooked = 105; \n  8'h44: data_cooked = 111; \n  8'h4D: data_cooked = 112; \n  8'h54: data_cooked = 91; \n  8'h5B: data_cooked = 93; \n  8'h1C: data_cooked = 97; \n  8'h1B: data_cooked = 115; \n  8'h23: data_cooked = 100; \n  8'h2B: data_cooked = 102; \n  8'h34: data_cooked = 103; \n  8'h33: data_cooked = 104; \n  8'h3B: data_cooked = 106; \n  8'h42: data_cooked = 107; \n  8'h4B: data_cooked = 108; \n  8'h4C: data_cooked = 59; \n  8'h52: data_cooked = 92; \n  8'h1A: data_cooked = 122; \n  8'h22: data_cooked = 120; \n  8'h21: data_cooked = 99; \n  8'h2A: data_cooked = 118; \n  8'h32: data_cooked = 98; \n  8'h31: data_cooked = 110; \n  8'h3A: data_cooked = 109; \n  8'h41: data_cooked = 44; \n  8'h49: data_cooked = 46; \n  8'h4A: data_cooked = 47; \n  8'h29: data_cooked = 32; \n  8'h66: data_cooked = 8; \n  8'h5A: data_cooked = 10; \n  default: data_cooked = 0; \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a 36-bit linear feedback shift register (LFSR) with a parallel load feature. When the enable signal is asserted, the shift register performs a left shift operation, and the output is available on the word signal. The initial value of the shift register is set to 36'hF0F0AA55 when the negative reset signal is active.\n\n Module header:\n\nmodule rw_manager_lfsr36(clk,nrst,ena,word);\n [/INST]\n", "output": "input clk; \n  input nrst; \n  input ena; \n  output reg [35:0] word; \n  always @(posedge clk or negedge nrst) begin \n  if(~nrst) begin \n  word <= 36'hF0F0AA55; \n  end \n  else if(ena) begin \n  word[35] <= word[0]; \n  word[34] <= word[35]; \n  word[33] <= word[34]; \n  word[32] <= word[33]; \n  word[31] <= word[32]; \n  word[30] <= word[31]; \n  word[29] <= word[30]; \n  word[28] <= word[29]; \n  word[27] <= word[28]; \n  word[26] <= word[27]; \n  word[25] <= word[26]; \n  word[24] <= word[25] ^ word[0]; \n  word[23] <= word[24]; \n  word[22] <= word[23]; \n  word[21] <= word[22]; \n  word[20] <= word[21]; \n  word[19] <= word[20]; \n  word[18] <= word[19]; \n  word[17] <= word[18]; \n  word[16] <= word[17]; \n  word[15] <= word[16]; \n  word[14] <= word[15]; \n  word[13] <= word[14]; \n  word[12] <= word[13]; \n  word[11] <= word[12]; \n  word[10] <= word[11]; \n  word[9] <= word[10]; \n  word[8] <= word[9]; \n  word[7] <= word[8]; \n  word[6] <= word[7]; \n  word[5] <= word[6]; \n  word[4] <= word[5]; \n  word[3] <= word[4]; \n  word[2] <= word[3]; \n  word[1] <= word[2]; \n  word[0] <= word[1]; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a CRC-7 (Cyclic Redundancy Check) calculation circuit. It takes a single bit input BITVAL and processes it with the ENABLE, BITSTRB, and CLEAR inputs to generate a 7-bit CRC output. The module continuously updates the CRC value based on the input BITVAL and the control signals, and resets the CRC value when the CLEAR signal is asserted.\n\n Module header:\n\nmodule sd_crc_7(BITVAL, ENABLE, BITSTRB, CLEAR, CRC);\n [/INST]\n", "output": "input BITVAL; \n  input ENABLE; \n  input BITSTRB; \n  input CLEAR; \n  output [6:0] CRC; \n  reg [6:0] CRC; \n  wire inv; \n  assign inv = BITVAL ^ CRC[6]; \n  always @(posedge BITSTRB or posedge CLEAR) begin \n  if (CLEAR) begin \n  CRC <= 0; \n  end \n  else begin \n  if (ENABLE == 1) begin \n  CRC[6] <= CRC[5]; \n  CRC[5] <= CRC[4]; \n  CRC[4] <= CRC[3]; \n  CRC[3] <= CRC[2] ^ inv; \n  CRC[2] <= CRC[1]; \n  CRC[1] <= CRC[0]; \n  CRC[0] <= inv; \n  end \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a floating-point 16-bit multiplier. It takes 4 input signals: clk, rst, arg_0, arg_1, arg_2, and arg_3. It produces a 16-bit output signal ret_0.\n\nThe module contains internal signals s, c, fc, uc, e10, e, underflow, overflow, and infinput for intermediate calculations and status checking.\n\nIt performs computations to determine underflow, overflow, and infinput states based on the input signals. Finally, it assigns the output ret_0 based on the calculated values of s, e, and uc.\n\nThe module is designed to handle floating-point arithmetic and output the appropriate result based on the given inputs.\n\n Module header:\n\nmodule FP16BMulS1Of2(input clk,input rst,input arg_0,input [7:0] arg_1,input [7:0] arg_2,input [8:0] arg_3,output [15:0] ret_0);\n [/INST]\n", "output": "wire s; \n  wire c; \n  wire [6:0] fc; \n  wire [6:0] uc; \n  wire [9:0] e10; \n  wire [7:0] e; \n  wire underflow; \n  wire overflow; \n  wire infinput; \n  assign s = arg_0; \n  assign c = arg_3[8:8]; \n  assign e10 = arg_1 + arg_2 - 127 + c; \n  assign fc = c ? arg_3[7:1] : arg_3[6:0]; \n  assign infinput = (arg_1 == 255) || (arg_2 == 255); \n  assign underflow = e10[9:9]; \n  assign overflow = !underflow && (e10[8:8] || e10[7:0] == 255 || infinput); \n  assign e = underflow ? 0 : (overflow ? 255 : e10[7:0]); \n  assign uc = (underflow || e10[7:0] == 0) ? 0 : fc; \n  assign ret_0 = {s, e, uc}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module `oh_csa32` implements a 32-bit carry-save adder. When configured for ASIC synthesis, it instantiates 32 instances of `asic_csa32` to perform the carry-save addition. Otherwise, it uses bitwise XOR and AND operations to compute the sum and carry outputs.\n\n Module header:\n\nmodule oh_csa32 #(parameter DW = 1) ( input [DW-1:0] in0,input [DW-1:0] in1,input [DW-1:0] in2,output [DW-1:0] s,output [DW-1:0] c);\n [/INST]\n", "output": "`ifdef CFG_ASIC \n  genvar i; \n  for (i=0;i<DW;i=i+1) \n  begin \n asic_csa32 asic_csa32 (.s(s[i]),.c(c[i]),.in2(in2[i]),.in1(in1[i]),.in0(in0[i])); \n  end \n `else \n  assign s[DW-1:0] = in0[DW-1:0] ^ in1[DW-1:0] ^ in2[DW-1:0]; \n  assign c[DW-1:0] = (in0[DW-1:0] & in1[DW-1:0]) | \n  (in1[DW-1:0] & in2[DW-1:0]) | \n  (in2[DW-1:0] & in0[DW-1:0] ); \n `endif \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module acts as a memory multiplexer, selecting between PRG and CHR memory based on read and write signals. It saves the PRG read and write signals to enable memory access. The module sets the memory address, read and write signals for CPU and PPU, and outputs the memory data based on the input signals. The module operates on the positive edge of the clock when the \"ce\" signal is high.\n\n Module header:\n\nmodule MemoryMultiplex(input clk, input ce,input [21:0] prg_addr, input prg_read, input prg_write, input [7:0] prg_din,input [21:0] chr_addr, input chr_read, input chr_write, input [7:0] chr_din,output [21:0] memory_addr,output memory_read_cpu,output memory_read_ppu,output memory_write,output [7:0] memory_dout);\n [/INST]\n", "output": "reg saved_prg_read, saved_prg_write; \n  assign memory_addr = (chr_read || chr_write) ? chr_addr : prg_addr; \n  assign memory_write = (chr_read || chr_write) ? chr_write : saved_prg_write; \n  assign memory_read_ppu = chr_read; \n  assign memory_read_cpu = !(chr_read || chr_write) && (prg_read || saved_prg_read); \n  assign memory_dout = chr_write ? chr_din : prg_din; \n  always @(posedge clk) if (ce) begin \n  if (chr_read || chr_write) begin \n  saved_prg_read <= prg_read || saved_prg_read; \n  saved_prg_write <= prg_write || saved_prg_write; \n  end else begin \n  saved_prg_read <= 0; \n  saved_prg_write <= prg_write; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements clock gating logic. It takes a 12-bit clock signal and two 1-bit clock gating signals as inputs and provides a 7-bit counter value and a 2-bit clock gating output. The module uses several internal wires and clock inversion modules to generate the clock gating signals and counter value based on the input signals. The clock signal is inverted using different clock inversion modules, and their outputs are combined to generate the clock gating signal and counter value.\n\n Module header:\n\nmodule bw_clk_gl_vrt1(c12 ,sctag_in ,sctag_out ,c7 );\n [/INST]\n", "output": "output [1:0] sctag_out ; \n output [7:0] c7 ; \n input [1:0] sctag_in ; \n input c12 ; \n wire [1:0] c11 ; \n wire [3:0] c8 ; \n wire [1:0] c10 ; \n wire [1:0] c9 ; \n assign c8[2] = sctag_in[1] ; \n assign c8[1] = sctag_in[0] ; \n assign sctag_out[1] = c9[1] ; \n assign sctag_out[0] = c9[0] ; \n bw_clk_gclk_inv_r90_224x xc7_1_ (.clkout (c7[1] ),.clkin (c8[0] ) ); \n bw_clk_gclk_inv_r90_256x xc10a_0_ (.clkout (c11[0] ),.clkin (c12 ) ); \n bw_clk_gclk_inv_r90_224x xc7_2_ (.clkout (c7[2] ),.clkin (c8[1] ) ); \n bw_clk_gclk_inv_r90_192x xc8_0_ (.clkout (c8[0] ),.clkin (c9[0] ) ); \n bw_clk_gclk_inv_r90_256x xc10a_1_ (.clkout (c11[1] ),.clkin (c12 ) ); \n bw_clk_gclk_inv_r90_224x xc7_3_ (.clkout (c7[3] ),.clkin (c8[1] ) ); \n bw_clk_gclk_inv_r90_192x xc10b_0_ (.clkout (c10[0] ),.clkin (c11[0] ) ); \n bw_clk_gclk_inv_r90_224x xc7_4_ (.clkout (c7[4] ),.clkin (c8[2] ) ); \n bw_clk_gclk_inv_r90_224x xc9_0_ (.clkout (c9[0] ),.clkin (c10[0] ) ); \n bw_clk_gclk_inv_r90_192x xc10b_1_ (.clkout (c10[1] ),.clkin (c11[1] ) ); \n bw_clk_gclk_inv_r90_224x xc7_5_ (.clkout (c7[5] ),.clkin (c8[2] ) ); \n bw_clk_gclk_inv_r90_224x xc9_1_ (.clkout (c9[1] ),.clkin (c10[1] ) ); \n bw_clk_gclk_inv_r90_192x xc8_3_ (.clkout (c8[3] ),.clkin (c9[1] ) ); \n bw_clk_gclk_inv_r90_224x xc7_6_ (.clkout (c7[6] ),.clkin (c8[3] ) ); \n bw_clk_gclk_inv_r90_224x xc7_7_ (.clkout (c7[7] ),.clkin (c8[3] ) ); \n bw_clk_gclk_inv_r90_224x xc7_0_ (.clkout (c7[0] ),.clkin (c8[0] ) ); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a pulse width modulation (PWM) signal generator for an LED. It uses a clock signal and a prescaler to generate 1ms and 1s signals. The module includes a counter for pulse width calculation, which increments on the 1ms clock signal. It also generates a PWM signal based on the pulse width and LED control logic. The PWM signal drives the LEDs to control their brightness.\n\n Module header:\n\nmodule pwm_led(input wire clk, output wire [7:0] ledb);\n [/INST]\n", "output": "wire clk_1ms; \n wire clk_1s; \n prescaler \n  #(.N(18)) \n T1S (.clk_in(clk),.ena(1'b1),.clk_out(clk_1s)); \n prescaler \n  #(.N(6)) \n T1MS (.clk_in(clk),.ena(1'b1),.clk_out(clk_1ms)); \n reg [7:0] cont = 0; \n always @ (posedge clk_1ms) begin \n  cont <= cont + 1; \n end \n wire [7:0] pulse_width; \n reg [8:0] pulse_width_ud = 0; \n always @ ( posedge clk_1s ) begin \n  pulse_width_ud <= pulse_width_ud + 9'b0_0000_1000; \n end \n wire a = pulse_width_ud[8]; \n assign pulse_width = pulse_width_ud[7:0] ^ {a,a,a,a,a,a,a,a}; \n wire pwm; \n assign pwm = (cont >= pulse_width) ? 0 : 1; \n assign ledb[7:0] = { 8{pwm} }; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a state machine for receiving data from a PS2 mouse. It shifts in data from the ps2_data input and processes it based on ps2_clk_posedge, wait_for_incoming_data, and start_receiving_data inputs. It includes state transitions for idle, wait for data, data in, parity in, and stop in. It also handles data counting, shifting data into a register, and outputting the received data.\n\n Module header:\n\nmodule ps2_mouse_datain (input clk,input reset,input wait_for_incoming_data,input start_receiving_data,input ps2_clk_posedge,input ps2_clk_negedge,input ps2_data,output reg [7:0] received_data,output reg received_data_en);\n [/INST]\n", "output": "localparam PS2_STATE_0_IDLE = 3'h0, \n  PS2_STATE_1_WAIT_FOR_DATA = 3'h1, \n  PS2_STATE_2_DATA_IN = 3'h2, \n  PS2_STATE_3_PARITY_IN = 3'h3, \n  PS2_STATE_4_STOP_IN = 3'h4; \n  reg [3:0] data_count; \n  reg [7:0] data_shift_reg; \n  reg [2:0] ns_ps2_receiver; \n  reg [2:0] s_ps2_receiver; \n  always @(posedge clk) begin \n  if (reset == 1'b1) s_ps2_receiver <= PS2_STATE_0_IDLE; \n  else s_ps2_receiver <= ns_ps2_receiver; \n  end \n  always @(*) begin \n  ns_ps2_receiver = PS2_STATE_0_IDLE; \n  case (s_ps2_receiver) \n  PS2_STATE_0_IDLE: \n  begin \n  if((wait_for_incoming_data == 1'b1) && (received_data_en == 1'b0)) \n  ns_ps2_receiver = PS2_STATE_1_WAIT_FOR_DATA; \n  else if ((start_receiving_data == 1'b1) && (received_data_en == 1'b0)) \n  ns_ps2_receiver = PS2_STATE_2_DATA_IN; \n  else ns_ps2_receiver = PS2_STATE_0_IDLE; \n  end \n  PS2_STATE_1_WAIT_FOR_DATA: \n  begin \n  if((ps2_data == 1'b0) && (ps2_clk_posedge == 1'b1)) \n  ns_ps2_receiver = PS2_STATE_2_DATA_IN; \n  else if (wait_for_incoming_data == 1'b0) \n  ns_ps2_receiver = PS2_STATE_0_IDLE; \n  else \n  ns_ps2_receiver = PS2_STATE_1_WAIT_FOR_DATA; \n  end \n  PS2_STATE_2_DATA_IN: \n  begin \n  if((data_count == 3'h7) && (ps2_clk_posedge == 1'b1)) \n  ns_ps2_receiver = PS2_STATE_3_PARITY_IN; \n  else \n  ns_ps2_receiver = PS2_STATE_2_DATA_IN; \n  end \n  PS2_STATE_3_PARITY_IN: \n  begin \n  if (ps2_clk_posedge == 1'b1) \n  ns_ps2_receiver = PS2_STATE_4_STOP_IN; \n  else \n  ns_ps2_receiver = PS2_STATE_3_PARITY_IN; \n  end \n  PS2_STATE_4_STOP_IN: \n  begin \n  if (ps2_clk_posedge == 1'b1) \n  ns_ps2_receiver = PS2_STATE_0_IDLE; \n  else \n  ns_ps2_receiver = PS2_STATE_4_STOP_IN; \n  end \n  default: \n  begin \n  ns_ps2_receiver = PS2_STATE_0_IDLE; \n  end \n  endcase \n  end \n  always @(posedge clk) begin \n  if (reset == 1'b1) data_count <= 3'h0; \n  else if((s_ps2_receiver == PS2_STATE_2_DATA_IN) && (ps2_clk_posedge == 1'b1)) \n  data_count <= data_count + 3'h1; \n  else if(s_ps2_receiver != PS2_STATE_2_DATA_IN) \n  data_count <= 3'h0; \n  end \n  always @(posedge clk) begin \n  if(reset == 1'b1) data_shift_reg <= 8'h00; \n  else if((s_ps2_receiver == PS2_STATE_2_DATA_IN) && (ps2_clk_posedge == 1'b1)) \n  data_shift_reg <= {ps2_data, data_shift_reg[7:1]}; \n  end \n  always @(posedge clk) begin \n  if(reset == 1'b1) received_data <= 8'h00; \n  else if(s_ps2_receiver == PS2_STATE_4_STOP_IN) \n  received_data <= data_shift_reg; \n  end \n  always @(posedge clk) begin \n  if(reset == 1'b1) received_data_en <= 1'b0; \n  else if((s_ps2_receiver == PS2_STATE_4_STOP_IN) && (ps2_clk_posedge == 1'b1)) \n  received_data_en <= 1'b1; \n  else \n  received_data_en <= 1'b0; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module takes in a 11-bit input di and computes a 5-bit CRC (cyclic redundancy check) output crc_out. The input is split into individual bits and combined to form a 11-bit word d. The constant c is defined as 0b11111. The output q is computed as a function of d and c using bitwise XOR operations. Finally, the complement of q is assigned to crc_out.\n\n Module header:\n\nmodule usb3_crc_cw(input wire [10:0] di,output wire [4:0] crc_out);\n [/INST]\n", "output": "wire [10:0] d = { di[0], di[1], di[2], di[3], di[4], \n  di[5], di[6], di[7], di[8], di[9], \n  di[10] }; \n wire [4:0] c = 5'h1F; \n wire [4:0] q = { ^d[10:9] ^ ^d[6:5] ^ d[3] ^ d[0] ^ c[0] ^ ^c[4:3], \n  d[10] ^ ^d[7:6] ^ d[4] ^ d[1] ^ ^c[1:0] ^ c[4], \n  ^d[10:7] ^ d[6] ^ ^d[3:2] ^ d[0] ^ ^c[4:0], \n  ^d[10:7] ^^ d[4:3] ^ d[1] ^ ^c[4:1], \n  ^d[10:8] ^ ^d[5:4] ^ d[2] ^ ^c[4:2] }; \n assign crc_out = ~q; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a circuit that processes signals using arithmetic and logic operations. It has multiple input and output ports for various signals. The module includes an adder circuit, multiplier circuits, and registers to store intermediate values. The signals are processed based on clock cycles, and the outputs are updated accordingly. The module structure uses control signals to manage the arithmetic and logic operations, and it contains several always blocks to handle the signal processing and register updates.\n\n Module header:\n\nmodule dscg(clock,reset,cos,one,s1,s2,s1_out,s2_out);\n [/INST]\n", "output": "input clock; \n input reset; \n input [`BITS-1:0] cos; \n input [`BITS-1:0] one; \n input [`BITS-1:0] s1; \n input [`BITS-1:0] s2; \n output [`BITS-1:0] s1_out; \n output [`BITS-1:0] s2_out; \n wire [`BITS-1:0] add1; \n wire [`BITS-1:0] x2; \n wire [`BITS-1:0] x3; \n wire [`BITS-1:0] sub5; \n wire [`BITS-1:0] x6; \n wire [`BITS-1:0] x7; \n wire [`BITS-1:0] s1_out; \n wire [`BITS-1:0] s2_out; \n reg [`BITS-1:0] x3_reg1; \n reg [`BITS-1:0] x3_reg2; \n reg [`BITS-1:0] x3_reg3; \n reg [`BITS-1:0] x3_reg4; \n reg [`BITS-1:0] x3_reg5; \n reg [`BITS-1:0] x3_reg6; \n reg [`BITS-1:0] x7_reg1; \n reg [`BITS-1:0] x7_reg2; \n reg [`BITS-1:0] x7_reg3; \n reg [`BITS-1:0] x7_reg4; \n reg [`BITS-1:0] x7_reg5; \n reg [`BITS-1:0] x7_reg6; \n wire [7:0] add1_control; \n fpu_add add1_add \n (.clk(clock),.opa(cos),.opb(one),.out(add1),.control(add1_control)); \n wire [7:0] x2_control; \n fpu_mul x2_mul \n (.clk(clock),.opa(add1),.opb(s2),.out(x2),.control(x2_control)); \n wire [7:0] x3_control; \n fpu_mul x3_mul \n (.clk(clock),.opa(cos),.opb(s1),.out(x3),.control(x3_control)); \n wire [7:0] s1_out_control; \n fpu_add s1_out_add \n (.clk(clock),.opa(x2),.opb(x3_reg6),.out(s1_out),.control(s1_out_control)); \n wire [7:0] sub5_control; \n fpu_add sub5_add \n (.clk(clock),.opa(one),.opb(cos),.out(sub5),.control(sub5_control)); \n wire [7:0] x6_control; \n fpu_mul x6_mul \n (.clk(clock),.opa(sub5),.opb(s1),.out(x6),.control(x6_control)); \n wire [7:0] x7_control; \n fpu_mul x7_mul \n (.clk(clock),.opa(cos),.opb(s2),.out(x7),.control(x7_control)); \n wire [7:0] s2_out_control; \n fpu_add s2_out_add \n (.clk(clock),.opa(x6),.opb(x7_reg6),.out(s2_out),.control(s2_out_control)); \n always @(posedge clock) \n begin \n  x3_reg1 <= x3; \n  x3_reg2 <= x3_reg1; \n  x3_reg3 <= x3_reg2; \n  x3_reg4 <= x3_reg3; \n  x3_reg5 <= x3_reg4; \n  x3_reg6 <= x3_reg5; \n  x7_reg1 <= x7; \n  x7_reg2 <= x7_reg1; \n  x7_reg3 <= x7_reg2; \n  x7_reg4 <= x7_reg3; \n  x7_reg5 <= x7_reg4; \n  x7_reg6 <= x7_reg5; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is designed to perform a 32-bit multiplication. It takes in a clock signal, an enable signal, a negate signal, and two 32-bit data inputs (datA and datB). The module outputs a 64-bit product (product_d4). The inputs are registered and the enable signal is synchronized across multiple clock cycles. The multiplication operation is performed using a sub-module called ssmultiplier_34_34, and the result is stored in the product_d4 output when the enable signal is high. The module also checks the negate signal and stops the simulation if it is set.\n\n Module header:\n\nmodule t_math_synmul_mul (product_d4,clk, enable, negate, datA, datB);\n [/INST]\n", "output": "input clk; \n  input enable; \n  input negate; \n  input [31:0] datA; \n  input [31:0] datB; \n  output reg [64:0] product_d4; \n  reg [33:0] datA_d1r; \n  reg [33:0] datB_d1r; \n  always @ (posedge clk) begin \n  if (enable) begin \n  datA_d1r <= {2'b0,datA}; \n  datB_d1r <= {2'b0,datB}; \n  if (negate) $stop; \n  end \n  end \n  reg en_d1; \n  reg en_d2; \n  reg en_d3; \n  always @ (posedge clk) begin \n  en_d1 <= enable; \n  en_d2 <= en_d1; \n  en_d3 <= en_d2; \n  end \n  wire [63:0] prod_d3; \n smmultiplier_34_34 mul (.OPA(datA_d1r),.OPB(datB_d1r),.RESULT(prod_d3),.clk (clk),.en_d1 (en_d1),.en_d2 (en_d2)); \n  always @ (posedge clk) begin \n  if (en_d3) begin \n  product_d4 <= {1'b0,prod_d3}; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an implementation of an 7-to-1 multiplexer. It selects one of the seven input data streams based on the value of the select signals (sel6 to sel0) and outputs the selected data stream. The width of the input and output data streams is parameterized and can be configured at instantiation.\n\n Module header:\n\nmodule oh_mux7 #(parameter DW = 1 ) (input sel6,input sel5,input sel4,input sel3,input sel2,input sel1,input sel0,input [DW-1:0] in6,input [DW-1:0] in5,input [DW-1:0] in4,input [DW-1:0] in3,input [DW-1:0] in2,input [DW-1:0] in1,input [DW-1:0] in0,output [DW-1:0] out);\n [/INST]\n", "output": "assign out[DW-1:0] = ({(DW){sel0}} & in0[DW-1:0] |{(DW){sel1}} & in1[DW-1:0] |{(DW){sel2}} & in2[DW-1:0] |{(DW){sel3}} & in3[DW-1:0] |{(DW){sel4}} & in4[DW-1:0] |{(DW){sel5}} & in5[DW-1:0] |{(DW){sel6}} & in6[DW-1:0]); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a bypass register. It takes in two sets of input data and settings, and based on the settings, either registers the input data or directly passes it to the output. The output also includes signals indicating the validity of the output data and whether the input data should be stalled.\n\n Module header:\n\nmodule vfabric_bypass_reg2(clock, resetn, i_settings,i_register_settings,i_dataa, i_dataa_valid, o_dataa_stall,i_datab, i_datab_valid, o_datab_stall,o_dataouta, o_dataouta_valid, i_dataouta_stall,o_dataoutb, o_dataoutb_valid, i_dataoutb_stall);\n [/INST]\n", "output": "parameter DATA_WIDTH = 32; \n  input clock; \n  input resetn; \n  input [1:0] i_settings; \n  input [DATA_WIDTH-1:0] i_register_settings; \n  input [DATA_WIDTH-1:0] i_dataa, i_datab; \n  input i_dataa_valid, i_datab_valid; \n  output o_dataa_stall, o_datab_stall; \n  output [DATA_WIDTH-1:0] o_dataouta, o_dataoutb; \n  output o_dataouta_valid, o_dataoutb_valid; \n  input i_dataouta_stall, i_dataoutb_stall; \n  assign o_dataouta = i_settings[0] ? i_register_settings : i_dataa; \n  assign o_dataoutb = i_settings[1] ? i_register_settings : i_datab; \n  assign o_dataouta_valid = i_dataa_valid; \n  assign o_dataoutb_valid = i_datab_valid; \n  assign o_dataa_stall = i_dataouta_stall; \n  assign o_datab_stall = i_dataoutb_stall; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module defines a module with parameters and instantiates an instance of that module. The module takes an input va4102a, performs some operations on it, and assigns the result to the output ve8318d. It also assigns vf54559 to a wire w3 and connects it to the instantiated module vb8adf8. The instantiated module has a clock input, a q output, and a d input. The parameter v71e305 is used to initialize the instantiated module's parameter INI.\n\n Module header:\n\nmodule v1c7dae #(parameter v71e305 = 0) (input va4102a,input vf54559,output ve8318d);\n [/INST]\n", "output": "localparam p2 = v71e305; \n  wire w0; \n  wire w1; \n  wire w3; \n  assign w0 = va4102a; \n  assign ve8318d = w1; \n  assign w3 = vf54559; \n v1c7dae_vb8adf8 #(.INI(p2)) vb8adf8 (.clk(w0),.q(w1),.d(w3)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module converts signals from an FX2 interface to signals for a bus. It uses the input signals to determine the bus address, read and write signals, and controls the CS_FPGA signal. The module also synchronizes the RD_B signal and provides it as BUS_RD, while directly connecting BUS_WR to the WR_B signal.\n\n Module header:\n\nmodule fx2_to_bus #(parameter WIDTH = 16) (input wire [WIDTH-1:0] ADD,input wire RD_B,input wire WR_B,input wire BUS_CLK,output wire [WIDTH-1:0] BUS_ADD,output wire BUS_RD,output wire BUS_WR,output wire CS_FPGA);\n [/INST]\n", "output": "assign BUS_ADD = ADD - 16'h4000; \n assign CS_FPGA = ~ADD[15] & ADD[14]; \n reg RD_B_FF; \n always @(posedge BUS_CLK) begin \n  RD_B_FF <= RD_B; \n end \n assign BUS_RD = ~RD_B & RD_B_FF; \n assign BUS_WR = ~WR_B; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module generates a random time-meet signal based on the input signals. It uses a random sequence and a counter to determine when the random time-meet signal should be asserted. The module also includes functionality to reset and initialize the random sequence and counters, and it updates the random sequence based on the clock and reset signals. Additionally, it handles the incrementing and decrementing of the slot time counter and the random counter based on certain conditions.\n\n Module header:\n\nmodule Ramdon_gen(Reset ,Clk ,Init ,RetryCnt ,Random_time_meet);\n [/INST]\n", "output": "input Reset ; \n input Clk ; \n input Init ; \n input [3:0] RetryCnt ; \n output Random_time_meet; \n reg [9:0] Random_sequence ; \n reg [9:0] Ramdom ; \n reg [9:0] Ramdom_counter ; \n reg [7:0] Slot_time_counter; \n reg Random_time_meet; \n always @ (posedge Clk or posedge Reset) \n  if (Reset) \n  Random_sequence <=0; \n  else \n  Random_sequence <={Random_sequence[8:0],~(Random_sequence[2]^Random_sequence[9])}; \n always @ (RetryCnt or Random_sequence) \n  case (RetryCnt) \n  4'h0 : Ramdom={9'b0,Random_sequence[0]}; \n  4'h1 : Ramdom={8'b0,Random_sequence[1:0]}; \n  4'h2 : Ramdom={7'b0,Random_sequence[2:0]}; \n  4'h3 : Ramdom={6'b0,Random_sequence[3:0]}; \n  4'h4 : Ramdom={5'b0,Random_sequence[4:0]}; \n  4'h5 : Ramdom={4'b0,Random_sequence[5:0]}; \n  4'h6 : Ramdom={3'b0,Random_sequence[6:0]}; \n  4'h7 : Ramdom={2'b0,Random_sequence[7:0]}; \n  4'h8 : Ramdom={1'b0,Random_sequence[8:0]}; \n  4'h9 : Ramdom={ Random_sequence[9:0]}; \n  default : Ramdom={ Random_sequence[9:0]}; \n  endcase \n always @ (posedge Clk or posedge Reset) \n  if (Reset) \n  Slot_time_counter <=0; \n  else if(Init) \n  Slot_time_counter <=0; \n  else if(!Random_time_meet) \n  Slot_time_counter <=Slot_time_counter+1; \n always @ (posedge Clk or posedge Reset) \n  if (Reset) \n  Ramdom_counter <=0; \n  else if (Init) \n  Ramdom_counter <=Ramdom; \n  else if (Ramdom_counter!=0&&Slot_time_counter==255) \n  Ramdom_counter <=Ramdom_counter -1 ; \n always @ (posedge Clk or posedge Reset) \n  if (Reset) \n  Random_time_meet <=1; \n  else if (Init) \n  Random_time_meet <=0; \n  else if (Ramdom_counter==0) \n  Random_time_meet <=1; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements an output buffer for both positive and negative voltage supplies. It consists of various input and output signals such as CLK, D, SCD, SCE, RESET_B, VPWR, VGND, VPB, and VNB. The module uses flip-flops, multiplexers, and conditional statements to handle the input signals and generates the required output signals Q and Q_N. The module also includes logic to handle reset signals and supply voltage detection. Overall, the module serves as a critical component for voltage supply management and signal buffering in a larger digital design.\n\n Module header:\n\nmodule sky130_fd_sc_hd__sdfrbp (Q ,Q_N ,CLK ,D ,SCD ,SCE ,RESET_B,VPWR ,VGND ,VPB ,VNB);\n [/INST]\n", "output": "output Q ; \n  output Q_N ; \n  input CLK ; \n  input D ; \n  input SCD ; \n  input SCE ; \n  input RESET_B; \n  input VPWR ; \n  input VGND ; \n  input VPB ; \n  input VNB ; \n  wire buf_Q ; \n  wire RESET ; \n  wire mux_out ; \n  reg notifier ; \n  wire D_delayed ; \n  wire SCD_delayed ; \n  wire SCE_delayed ; \n  wire RESET_B_delayed; \n  wire CLK_delayed ; \n  wire awake ; \n  wire cond0 ; \n  wire cond1 ; \n  wire cond2 ; \n  wire cond3 ; \n  wire cond4 ; \n  not not0 (RESET , RESET_B_delayed ); \n  sky130_fd_sc_hd__udp_mux_2to1 mux_2to10 (mux_out, D_delayed, SCD_delayed, SCE_delayed ); \n  sky130_fd_sc_hd__udp_dff$PR_pp$PG$N dff0 (buf_Q , mux_out, CLK_delayed, RESET, notifier, VPWR, VGND); \n  assign awake = ( VPWR === 1'b1 ); \n  assign cond0 = ( ( RESET_B_delayed === 1'b1 ) && awake ); \n  assign cond1 = ( ( SCE_delayed === 1'b0 ) && cond0 ); \n  assign cond2 = ( ( SCE_delayed === 1'b1 ) && cond0 ); \n  assign cond3 = ( ( D_delayed !== SCD_delayed ) && cond0 ); \n  assign cond4 = ( ( RESET_B === 1'b1 ) && awake ); \n  buf buf0 (Q , buf_Q ); \n  not not1 (Q_N , buf_Q ); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, DEBUG_AE, is designed to analyze a set of debug input signals and make a decision based on various conditions. It includes input signals such as DBG_IN, READ, WRITE, USER, VIRTUELL, ACC_OK, VADR_R, MMU_Q, and ENBYTE. The module also includes an output signal DBG_HIT.\n\nThe module performs several operations to make a decision based on the input signals. It evaluates various conditions such as virtual address match, write or read match, virtual or real address assignment, page address assignment, and byte enable. It then combines these conditions to produce the DBG_HIT output signal.\n\nOverall, the module acts as a decision-making unit based on the input signals and conditions, ultimately producing the DBG_HIT output signal as a result of its analysis.\n\n Module header:\n\nmodule DEBUG_AE ( DBG_IN, READ, WRITE, USER, VIRTUELL, ACC_OK, VADR_R, MMU_Q, ENBYTE, DBG_HIT );\n [/INST]\n", "output": "input [40:2] DBG_IN; \n  input READ,WRITE; \n  input USER; \n  input VIRTUELL; \n  input ACC_OK; \n  input [31:2] VADR_R; \n  input [19:0] MMU_Q; \n  input [3:0] ENBYTE; \n  output DBG_HIT; \n  wire sd,ud,crd,cwr,vnp; \n  wire make; \n  wire virt_adr,real_adr,page_adr; \n  wire byte_en; \n  assign sd = DBG_IN[40]; \n  assign ud = DBG_IN[39]; \n  assign crd = DBG_IN[38]; \n  assign cwr = DBG_IN[37]; \n  assign vnp = DBG_IN[36]; \n  assign make = ((ud & USER) | (sd & ~USER)) \n  & (VIRTUELL == vnp) \n  & ((cwr & WRITE) | (crd & READ)); \n  assign virt_adr = (MMU_Q == DBG_IN[31:12]); \n  assign real_adr = (VADR_R[31:12] == DBG_IN[31:12]); \n  assign page_adr = (VADR_R[11:2] == DBG_IN[11:2]); \n  assign byte_en = |(ENBYTE & DBG_IN[35:32]); \n  assign DBG_HIT = ACC_OK \n  & make \n  & (VIRTUELL ? virt_adr : real_adr) & page_adr \n  & byte_en; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an I2S audio interface. It generates an audio master clock (audio_mclk) from the bus clock (bus_clk) and controls the audio data capture and playback. It processes the audio data based on the rising and falling edges of the bit clock (audio_bclk), and handles the read and write operations for the audio FIFOs.\n\nThe module contains several internal registers for audio control, clock division, and data processing. It uses these registers to synchronize and process the audio data streams for playback and recording.\n\nThe audio_mclk is generated based on the bus clock, and the module handles the data transfer between the audio DAC and ADC. It also manages the FIFO read and write operations for audio data playback and recording.\n\nOverall, this module serves as an essential component for interfacing with I2S audio devices, providing clocking and data management for audio data transfer.\n\n Module header:\n\nmodule i2s_audio (input bus_clk,input quiesce,input clk_100,output reg audio_mclk,output reg audio_dac,input audio_adc,input audio_bclk,input audio_lrclk,input user_w_audio_wren,input [31:0] user_w_audio_data,output user_w_audio_full,input user_w_audio_open,input user_r_audio_rden,output [31:0] user_r_audio_data,output user_r_audio_empty,output user_r_audio_eof,input user_r_audio_open);\n [/INST]\n", "output": "reg audio_adc_reg; \n  reg audio_bclk_reg; \n  reg audio_lrclk_reg; \n  reg audio_lrclk_reg_d; \n  reg [1:0] clk_div; \n  reg [15:0] play_shreg; \n  reg [1:0] bclk_d; \n  reg fifo_rd_en; \n  wire bclk_rising, bclk_falling; \n  wire [31:0] play_fifo_data; \n  reg [31:0] record_shreg; \n  reg [4:0] record_count; \n  reg write_when_done; \n  reg fifo_wr_en; \n  assign user_r_audio_eof = 0; \n  always @(posedge clk_100) \n  begin \n  clk_div <= clk_div + 1; \n  audio_mclk <= clk_div[1]; \n  end \n  assign bclk_rising = (bclk_d == 2'b01); \n  assign bclk_falling = (bclk_d == 2'b10); \n  always @(posedge bus_clk) \n  begin \n  audio_adc_reg <= audio_adc; \n  audio_bclk_reg <= audio_bclk; \n  audio_lrclk_reg <= audio_lrclk; \n  bclk_d <= { bclk_d, audio_bclk_reg }; \n  if (bclk_rising) \n  audio_lrclk_reg_d <= audio_lrclk_reg; \n  fifo_rd_en <= 0; \n  if (bclk_rising && !audio_lrclk_reg && audio_lrclk_reg_d) \n  play_shreg <= play_fifo_data[31:16]; \n  else if (bclk_rising && audio_lrclk_reg && !audio_lrclk_reg_d) \n  begin \n  play_shreg <= play_fifo_data[15:0]; \n  fifo_rd_en <= 1; \n  end \n  else if (bclk_falling) \n  begin \n  audio_dac <= play_shreg[15]; \n  play_shreg <= { play_shreg, 1'b0 }; \n  end \n  fifo_wr_en <= 0; \n  if (bclk_rising && (record_count != 0)) \n  begin \n  record_shreg <= { record_shreg, audio_adc_reg }; \n  record_count <= record_count - 1; \n  if (record_count == 1) \n  begin \n  fifo_wr_en <= write_when_done; \n  write_when_done <= 0; \n  end \n  end \n  if (bclk_rising && !audio_lrclk_reg && audio_lrclk_reg_d) \n  begin \n  record_count <= 16; \n  write_when_done <= 0; \n  end \n  else if (bclk_rising && audio_lrclk_reg && !audio_lrclk_reg_d) \n  begin \n  record_count <= 16; \n  write_when_done <= 1; \n  end \n  end \n  fifo_32x512 playback_fifo \n (.clk(bus_clk),.srst(!user_w_audio_open),.din(user_w_audio_data),.wr_en(user_w_audio_wren),.rd_en(fifo_rd_en),.dout(play_fifo_data),.full(user_w_audio_full),.empty()); \n  fifo_32x512 record_fifo \n (.clk(bus_clk),.srst(!user_r_audio_open),.din(record_shreg),.wr_en(fifo_wr_en),.rd_en(user_r_audio_rden),.dout(user_r_audio_data),.full(),.empty(user_r_audio_empty)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a combinational and sequential logic circuit for unsigned division. The input signals are clock (clk), enable (ena), z vector (z), and d vector (d). The output signals are q vector (q), s vector (s), div0, and ovf. The module consists of various combinational and sequential blocks to generate the q and s vectors based on the z and d inputs. It also checks for overflow (ovf) and division by zero (div0) conditions. The design uses a set of always blocks triggered by the positive edge of the clock and the enable signal to compute the output values based on the input signals. The division logic is implemented using intermediate registers and functions to generate the q and s vectors. Additionally, it also performs error checking based on the input parameters and provides detailed comments to explain the functionality of each block.\n\n Module header:\n\nmodule div_uu(clk, ena, z, d, q, s, div0, ovf);\n [/INST]\n", "output": "parameter z_width = 16; \n  parameter d_width = z_width /2; \n  input clk; \n  input ena; \n  input [z_width -1:0] z; \n  input [d_width -1:0] d; \n  output [d_width -1:0] q; \n  reg [d_width-1:0] q; \n  output [d_width -1:0] s; \n  reg [d_width-1:0] s; \n  output div0; \n  reg div0; \n  output ovf; \n  reg ovf; \n  function [z_width:0] gen_s; \n  input [z_width:0] si; \n  input [z_width:0] di; \n  begin \n  if(si[z_width]) \n  gen_s = {si[z_width-1:0], 1'b0} + di; \n  else \n  gen_s = {si[z_width-1:0], 1'b0} - di; \n  end \n  endfunction \n  function [d_width-1:0] gen_q; \n  input [d_width-1:0] qi; \n  input [z_width:0] si; \n  begin \n  gen_q = {qi[d_width-2:0], ~si[z_width]}; \n  end \n  endfunction \n  function [d_width-1:0] assign_s; \n  input [z_width:0] si; \n  input [z_width:0] di; \n  reg [z_width:0] tmp; \n  begin \n  if(si[z_width]) \n  tmp = si + di; \n  else \n  tmp = si; \n  assign_s = tmp[z_width-1:z_width-4]; \n  end \n  endfunction \n  reg [d_width-1:0] q_pipe [d_width-1:0]; \n  reg [z_width:0] s_pipe [d_width:0]; \n  reg [z_width:0] d_pipe [d_width:0]; \n  reg [d_width:0] div0_pipe, ovf_pipe; \n  initial \n  begin \n  if(d_width !== z_width / 2) \n  $display(\"div.v parameter error (d_width != z_width/2).\"); \n  end \n  integer n0, n1, n2, n3; \n  always @(d) \n  d_pipe[0] <= {1'b0, d, {(z_width-d_width){1'b0}} }; \n  always @(posedge clk) \n  if(ena) \n  for(n0=1; n0 <= d_width; n0=n0+1) \n  d_pipe[n0] <= #1 d_pipe[n0-1]; \n  always @(z) \n  s_pipe[0] <= z; \n  always @(posedge clk) \n  if(ena) \n  for(n1=1; n1 <= d_width; n1=n1+1) \n  s_pipe[n1] <= #1 gen_s(s_pipe[n1-1], d_pipe[n1-1]); \n  always @(posedge clk) \n  q_pipe[0] <= #1 0; \n  always @(posedge clk) \n  if(ena) \n  for(n2=1; n2 < d_width; n2=n2+1) \n  q_pipe[n2] <= #1 gen_q(q_pipe[n2-1], s_pipe[n2]); \n  always @(z or d) \n  begin \n  ovf_pipe[0] <= !(z[z_width-1:d_width] < d); \n  div0_pipe[0] <= ~|d; \n  end \n  always @(posedge clk) \n  if(ena) \n  for(n3=1; n3 <= d_width; n3=n3+1) \n  begin \n  ovf_pipe[n3] <= #1 ovf_pipe[n3-1]; \n  div0_pipe[n3] <= #1 div0_pipe[n3-1]; \n  end \n  always @(posedge clk) \n  if(ena) \n  ovf <= #1 ovf_pipe[d_width]; \n  always @(posedge clk) \n  if(ena) \n  div0 <= #1 div0_pipe[d_width]; \n  always @(posedge clk) \n  if(ena) \n  q <= #1 gen_q(q_pipe[d_width-1], s_pipe[d_width]); \n  always @(posedge clk) \n  if(ena) \n  s <= #1 assign_s(s_pipe[d_width], d_pipe[d_width]); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module implements a simple register that toggles its value on every rising edge of the clock signal. The value of the register is determined by the input \"value\" at the rising edge of the clock. The output \"result\" is the result of XOR between the internal register \"Internal\" and the clock signal.\n\n Module header:\n\nmodule Generate (clk, value, result);\n [/INST]\n", "output": "input clk; \n  input value; \n  output result; \n  reg Internal; \n  assign result = Internal ^ clk; \n  always @(posedge clk) \n  Internal <= #1 value; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is designed to handle video data fetching and synchronization. It controls the video data fetching process by using signals such as fetch_start, fetch_end, fetch_sync, and video_go. The module also manages the video data storage into a 64-bit register called pic_bits.\n\nIt uses sequential logic to control the various states and counters required for video data handling. The module synchronizes the video data fetching process with the incoming video stream and stores the fetched data into the pic_bits register in a specific order.\n\nOverall, the module ensures that the video data is fetched, synchronized, and stored properly based on the control signals and specific timing conditions.\n\n Module header:\n\nmodule video_fetch(input wire clk,input wire cend,input wire pre_cend,input wire vpix,input wire fetch_start,input wire fetch_end,output reg fetch_sync,input wire [15:0] video_data,input wire video_strobe,output reg video_go,output reg [63:0] pic_bits);\n [/INST]\n", "output": "reg [3:0] fetch_sync_ctr; \n  reg [1:0] fetch_ptr; \n  reg fetch_ptr_clr; \n  reg [15:0] fetch_data [0:3]; \n  always @(posedge clk) \n  if( fetch_start && vpix ) \n  video_go <= 1'b1; \n  else if( fetch_end ) \n  video_go <= 1'b0; \n  always @(posedge clk) if( cend ) \n  begin \n  if( fetch_start ) \n  fetch_sync_ctr <= 0; \n  else \n  fetch_sync_ctr <= fetch_sync_ctr + 1; \n  end \n  always @(posedge clk) \n  if( (fetch_sync_ctr==1) && pre_cend ) \n  fetch_sync <= 1'b1; \n  else \n  fetch_sync <= 1'b0; \n  always @(posedge clk) \n  if( (fetch_sync_ctr==0) && pre_cend ) \n  fetch_ptr_clr <= 1'b1; \n  else \n  fetch_ptr_clr <= 1'b0; \n  always @(posedge clk) \n  if( fetch_ptr_clr ) \n  fetch_ptr <= 0; \n  else if( video_strobe ) \n  fetch_ptr <= fetch_ptr + 1; \n  always @(posedge clk) if( video_strobe ) \n  fetch_data[fetch_ptr] <= video_data; \n  always @(posedge clk) if( fetch_sync ) \n  begin \n  pic_bits[ 7:0 ] <= fetch_data[0][15:8 ]; \n  pic_bits[15:8 ] <= fetch_data[0][ 7:0 ]; \n  pic_bits[23:16] <= fetch_data[1][15:8 ]; \n  pic_bits[31:24] <= fetch_data[1][ 7:0 ]; \n  pic_bits[39:32] <= fetch_data[2][15:8 ]; \n  pic_bits[47:40] <= fetch_data[2][ 7:0 ]; \n  pic_bits[55:48] <= fetch_data[3][15:8 ]; \n  pic_bits[63:56] <= fetch_data[3][ 7:0 ]; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a UART (Universal Asynchronous Receiver/Transmitter) instance with data transmission and reception functionality. It consists of a UART transmitter and receiver, a data dealer, and includes signals for clock, reset, UART RX and TX, UART control, serial transmit data, and data validity. The module utilizes a counter to handle the reset signal and interfaces with various sub-modules to manage data processing and transmission. The UART functionality allows asynchronous serial communication between devices.\n\n Module header:\n\nmodule uart_instance(clk,rst_n,rs232_rx,rs232_tx,data_ok,uart_ctl);\n [/INST]\n", "output": "input clk; \n input rst_n; \n input rs232_rx; \n input [2:0] uart_ctl; \n output rs232_tx; \n output data_ok; \n parameter DELAY_N = 15; \n wire [2:0] uart_ctl; \n wire [7:0] data_in, data_out; \n wire data_in_sign, data_out_sign; \n wire data_valid; \n reg [DELAY_N - 1: 0] rst_cnt; \n wire rst_wire ; \n assign rst_wire = rst_cnt[DELAY_N - 1]; \n always@(posedge clk or negedge rst_n)begin \n  if(!rst_n)begin \n  rst_cnt <= 'h0; \n  end \n  else begin \n  if(~rst_cnt[DELAY_N - 1]) rst_cnt <= rst_cnt + 1'b1; \n  end \n  end \n my_uart_tx8to8 tx_inst (.clk(clk),.rst_n(rst_wire),.uart_ctl(uart_ctl),.data_out(data_out),.data_sign(data_out_sign),.data_valid(data_valid),.rs_tx(rs232_tx)); \n my_uart_rx8to8 rx_inst(.clk(clk),.rst_n(rst_wire),.uart_ctl(uart_ctl),.rs_rx(rs232_rx),.data_in(data_in),.data_sign(data_in_sign)); \n data_deal data_deal (.clk(clk),.rst_n(rst_wire),.data_in(data_in),.data_in_sign(data_in_sign),.data_out(data_out),.data_out_sign(data_out_sign),.data_valid(data_valid),.data_ok(data_ok)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module performs the propagation of NaN (Not a Number) and sign for multiplication operations on floating-point numbers. It takes input control signals, signs, and fractions for two floating-point numbers, and based on whether they are NaN or not, it calculates the sign and fraction of the resulting NaN. The sign of the resulting NaN is calculated based on the signs of the input numbers and whether they are NaN. The fraction of the resulting NaN is determined by the fraction of the NaN inputs. If neither input is NaN, the resulting NaN fraction is set to 0.\n\n Module header:\n\nmodule propagateFloatNaN_mul#(parameter sigWidth = 3) (input [(`floatControlWidth - 1):0] control,input isNaNA,input signA,input [(sigWidth - 2):0] fractA,input isNaNB,input signB,input [(sigWidth - 2):0] fractB,output signNaN,output [(sigWidth - 2):0] fractNaN);\n [/INST]\n", "output": "assign signNaN = isNaNA ? signA : isNaNB ? signB : 1; \n  assign fractNaN = \n  {1'b1, \n  isNaNA ? fractA[(sigWidth - 3):0] \n  : isNaNB ? fractB[(sigWidth - 3):0] : 1'b0}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a simple synchronous D flip-flop with an optional configurable width. On a positive edge of the clock signal, the input data is captured and stored in the flip-flop. When the reset signal is asserted, the output q is reset to 0.\n\n Module header:\n\nmodule flopr #(parameter WIDTH = 8) (input clk, reset,input [WIDTH-1:0] d,output reg [WIDTH-1:0] q);\n [/INST]\n", "output": "always @(posedge clk, posedge reset) \n  if (reset) q <= 0; \n  else q <= d; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module connects an external memory module with a seven-segment display module. It takes in clock, reset, address, and data signals, and outputs signals to control the seven-segment display. The module also assigns the write enable, data, and address signals based on the input data, and instantiates the sevenseg module to control the display.\n\n Module header:\n\nmodule sevensegmm(input clk,input rst,input [31:0] addr_b,input [31:0] data_b_in,input [31:0] data_b_we,output [7:0] seg,output [7:0] an);\n [/INST]\n", "output": "wire [2:0] addr; \n  wire [7:0] data; \n  wire we; \n sevenseg s7 (.clk100mhz(clk),.addr(addr),.data(data),.we(we),.seg(seg), .an(an)); \n  assign we = (addr_b == 65553)?data_b_we:0; \n  assign data = data_b_in[7:0]; \n  assign addr = data_b_in[10:8]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `pcm` contains registers and logic to control data flow and latching based on various input signals. It uses the input signals `CLK_68KCLKB`, `nSDROE`, `SDRMPX`, `nSDPOE`, `SDPMPX`, `SDRAD`, `SDRA_L`, `SDRA_U`, `SDPAD`, `SDPA`, `D`, and outputs `A`.\n\n- The `COUNT` register increments by 1 when `nSDPOE` is asserted.\n- `RDLATCH` and `PDLATCH` are assigned values based on the input signals.\n- Data flow to `SDRAD` and `SDPAD` is controlled by the `nSDROE` and `nSDPOE` signals.\n- The values of `A` are determined based on the status of `nSDPOE`.\n- `RALATCH` and `PALATCH` are latched with different values based on the input signals and edge triggers.\n\n Module header:\n\nmodule pcm(input CLK_68KCLKB,input nSDROE, SDRMPX,input nSDPOE, SDPMPX,inout [7:0] SDRAD,input [9:8] SDRA_L,input [23:20] SDRA_U,inout [7:0] SDPAD,input [11:8] SDPA,input [7:0] D,output [23:0] A);\n [/INST]\n", "output": "reg [1:0] COUNT; \n  reg [7:0] RDLATCH; \n  reg [7:0] PDLATCH; \n  reg [23:0] RALATCH; \n  reg [23:0] PALATCH; \n  always @(posedge CLK_68KCLKB or negedge nSDPOE) \n  begin \n  if (!nSDPOE) \n  COUNT <= 0; \n  else \n  if (!COUNT[1]) COUNT <= COUNT + 1'b1; \n  end \n  assign SDRAD = nSDROE ? 8'bzzzzzzzz : RDLATCH; \n  always @* \n  if (COUNT[1]) RDLATCH <= D; \n  assign SDPAD = nSDPOE ? 8'bzzzzzzzz : PDLATCH; \n  always @* \n  if (!nSDPOE) PDLATCH <= D; \n  assign A = nSDPOE ? RALATCH[23:0] : PALATCH[23:0]; \n  always @(posedge SDRMPX) \n  begin \n  RALATCH[7:0] <= SDRAD; \n  RALATCH[9:8] <= SDRA_L[9:8]; \n  end \n  always @(negedge SDRMPX) \n  begin \n  RALATCH[17:10] <= SDRAD; \n  RALATCH[23:18] <= {SDRA_U[23:20], SDRA_L[9:8]}; \n  end \n  always @(posedge SDPMPX) \n  begin \n  PALATCH[7:0] <= SDPAD; \n  PALATCH[11:8] <= SDPA[11:8]; \n  end \n  always @(negedge SDPMPX) \n  begin \n  PALATCH[19:12] <= SDPAD; \n  PALATCH[23:20] <= SDPA[11:8]; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is used to combine and assign signals from multiple sources. It consolidates various input and output signals from different sources, including module request lines, read lines, data split lines, and other individual signals. The module then assigns the combined signals to specific outputs to ensure proper communication and coordination among the different sources.\n\n Module header:\n\nmodule iobus_2_connect(input wire clk,input wire reset,input wire m_iob_poweron,input wire m_iob_reset,input wire m_datao_clear,input wire m_datao_set,input wire m_cono_clear,input wire m_cono_set,input wire m_iob_fm_datai,input wire m_iob_fm_status,input wire m_rdi_pulse,input wire [3:9] m_ios,input wire [0:35] m_iob_write,output wire [1:7] m_pi_req,output wire [0:35] m_iob_read,output wire m_dr_split,output wire m_rdi_data,output wire s0_iob_poweron,output wire s0_iob_reset,output wire s0_datao_clear,output wire s0_datao_set,output wire s0_cono_clear,output wire s0_cono_set,output wire s0_iob_fm_datai,output wire s0_iob_fm_status,output wire s0_rdi_pulse,output wire [3:9] s0_ios,output wire [0:35] s0_iob_write,input wire [1:7] s0_pi_req,input wire [0:35] s0_iob_read,input wire s0_dr_split,input wire s0_rdi_data,output wire s1_iob_poweron,output wire s1_iob_reset,output wire s1_datao_clear,output wire s1_datao_set,output wire s1_cono_clear,output wire s1_cono_set,output wire s1_iob_fm_datai,output wire s1_iob_fm_status,output wire s1_rdi_pulse,output wire [3:9] s1_ios,output wire [0:35] s1_iob_write,input wire [1:7] s1_pi_req,input wire [0:35] s1_iob_read,input wire s1_dr_split,input wire s1_rdi_data);\n [/INST]\n", "output": "assign m_pi_req = 0 | s0_pi_req | s1_pi_req; \n  assign m_iob_read = m_iob_write | s0_iob_read | s1_iob_read; \n  assign m_dr_split = 0 | s0_dr_split | s1_dr_split; \n  assign m_rdi_data = 0 | s0_rdi_data | s1_rdi_data; \n  assign s0_iob_poweron = m_iob_poweron; \n  assign s0_iob_reset = m_iob_reset; \n  assign s0_datao_clear = m_datao_clear; \n  assign s0_datao_set = m_datao_set; \n  assign s0_cono_clear = m_cono_clear; \n  assign s0_cono_set = m_cono_set; \n  assign s0_iob_fm_datai = m_iob_fm_datai; \n  assign s0_iob_fm_status = m_iob_fm_status; \n  assign s0_rdi_pulse = m_rdi_pulse; \n  assign s0_ios = m_ios; \n  assign s0_iob_write = m_iob_write; \n  assign s1_iob_poweron = m_iob_poweron; \n  assign s1_iob_reset = m_iob_reset; \n  assign s1_datao_clear = m_datao_clear; \n  assign s1_datao_set = m_datao_set; \n  assign s1_cono_clear = m_cono_clear; \n  assign s1_cono_set = m_cono_set; \n  assign s1_iob_fm_datai = m_iob_fm_datai; \n  assign s1_iob_fm_status = m_iob_fm_status; \n  assign s1_rdi_pulse = m_rdi_pulse; \n  assign s1_ios = m_ios; \n  assign s1_iob_write = m_iob_write; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module performs binary to BCD conversion. It takes a binary input and produces a corresponding BCD output. The module uses nested loops to perform the conversion by dividing the binary number into groups of 4 bits and adjusting the BCD values based on the binary values. The BCD output is stored in the reg output 'bcd' of width W+(W-4)/3.\n\n Module header:\n\nmodule bin2bcd #( parameter W = 18) ( input [W-1 :0] bin ,output reg [W+(W-4)/3:0] bcd );\n [/INST]\n", "output": "integer i,j; \n  always @(bin) begin \n  for(i = 0; i <= W+(W-4)/3; i = i+1) bcd[i] = 0; \n  bcd[W-1:0] = bin; \n  for(i = 0; i <= W-4; i = i+1) \n  for(j = 0; j <= i/3; j = j+1) \n  if (bcd[W-i+4*j -: 4] > 4) \n  bcd[W-i+4*j -: 4] = bcd[W-i+4*j -: 4] + 4'd3; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, named Forwarding, implements logic for forwarding data in a pipeline. It takes input signals EX_rs, EX_rt, MEM_rd, WB_rd, MEM_RegWrite, and WB_RegWrite, and outputs signals ForwardA and ForwardB. The module uses combinational logic to determine the values of ForwardA and ForwardB based on the input signals. If certain conditions are met, the module sets ForwardA and ForwardB to specific values, or else, it sets them to a default value. This logic is crucial for preventing data hazards in a pipelined processor architecture.\n\n Module header:\n\nmodule Forwarding (input wire [4:0] EX_rs,input wire [4:0] EX_rt,input wire [4:0] MEM_rd,input wire [4:0] WB_rd,input wire MEM_RegWrite,input wire WB_RegWrite,output reg [1:0] ForwardA,output reg [1:0] ForwardB);\n [/INST]\n", "output": "always @* \n if (WB_RegWrite && WB_rd && (WB_rd == EX_rs) &&((MEM_rd != EX_rs) || (~MEM_RegWrite))) \n  ForwardA = 2'b01; \n  else if (MEM_RegWrite && MEM_rd && (MEM_rd == EX_rs)) \n  ForwardA = 2'b10; \n  else \n  ForwardA = 2'b00; \n  always @* \n if (WB_RegWrite && WB_rd && (WB_rd == EX_rt) &&((MEM_rd != EX_rt) || (~MEM_RegWrite))) \n  ForwardB = 2'b01; \n  else if (MEM_RegWrite && MEM_rd && (MEM_rd == EX_rt)) \n  ForwardB = 2'b10; \n  else \n  ForwardB = 2'b00; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is for a DE0-CV FPGA board and contains various input and output signals for interfacing with different components. It includes clock signal generation, reset signal handling, clock enable logic, clock division, and signal routing for LEDs, hexadecimal displays, DRAM, VGA, PS2, and SD card interfaces. It also utilizes a top-level module called sm_top to manage the clock and reset signals, clock enable, clock division, and register address and data. Additionally, it assigns the LEDR outputs based on the clock signal and the lower 9 bits of the register data, and it uses submodules to drive the hexadecimal displays based on different segments of the register data.\n\n Module header:\n\nmodule de0_cv (input CLOCK2_50,input CLOCK3_50,inout CLOCK4_50,input CLOCK_50,input RESET_N,input [ 3:0] KEY,input [ 9:0] SW,output [ 9:0] LEDR,output [ 6:0] HEX0,output [ 6:0] HEX1,output [ 6:0] HEX2,output [ 6:0] HEX3,output [ 6:0] HEX4,output [ 6:0] HEX5,output [12:0] DRAM_ADDR,output [ 1:0] DRAM_BA,output DRAM_CAS_N,output DRAM_CKE,output DRAM_CLK,output DRAM_CS_N,inout [15:0] DRAM_DQ,output DRAM_LDQM,output DRAM_RAS_N,output DRAM_UDQM,output DRAM_WE_N,output [ 3:0] VGA_B,output [ 3:0] VGA_G,output VGA_HS,output [ 3:0] VGA_R,output VGA_VS,inout PS2_CLK,inout PS2_CLK2,inout PS2_DAT,inout PS2_DAT2,output SD_CLK,inout SD_CMD,inout [ 3:0] SD_DATA,inout [35:0] GPIO_0,inout [35:0] GPIO_1);\n [/INST]\n", "output": "wire clk; \n  wire clkIn = CLOCK_50; \n  wire rst_n = KEY[0] & RESET_N; \n  wire clkEnable = SW [9] | ~KEY[1]; \n  wire [ 3:0 ] clkDevide = SW [8:5]; \n  wire [ 4:0 ] regAddr = SW [4:0]; \n  wire [ 31:0 ] regData; \n  sm_top sm_top \n (.clkIn ( clkIn ),.rst_n ( rst_n ),.clkDevide ( clkDevide ),.clkEnable ( clkEnable ),.clk ( clk ),.regAddr ( regAddr ),.regData ( regData )); \n  assign LEDR[0] = clk; \n  assign LEDR[9:1] = regData[8:0]; \n  wire [ 31:0 ] h7segment = regData; \n  sm_hex_display digit_5 ( h7segment [23:20] , HEX5 [6:0] ); \n  sm_hex_display digit_4 ( h7segment [19:16] , HEX4 [6:0] ); \n  sm_hex_display digit_3 ( h7segment [15:12] , HEX3 [6:0] ); \n  sm_hex_display digit_2 ( h7segment [11: 8] , HEX2 [6:0] ); \n  sm_hex_display digit_1 ( h7segment [ 7: 4] , HEX1 [6:0] ); \n  sm_hex_display digit_0 ( h7segment [ 3: 0] , HEX0 [6:0] ); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes a 24-bit input and converts it to a hexadecimal string. It splits the input into three 8-bit chunks and converts each chunk to a hexadecimal string using sub-modules. The resulting hexadecimal strings are then concatenated to form the 128-bit output.\n\n Module header:\n\nmodule dectohexstr24(input [23:0] in,output [127:0] out);\n [/INST]\n", "output": "assign out[127:48] = \" \"; \n  dectohexstr8 dectohexstr8lo \n (.in(in[7:0]),.out(out[15:0])); \n  dectohexstr8 dectohexstr8mi \n (.in(in[15:8]),.out(out[31:16])); \n  dectohexstr8 dectohexstr8hi \n (.in(in[23:16]),.out(out[47:32])); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a Fibonacci LFSR (Linear Feedback Shift Register) with a 5-bit output. It uses the clock signal and an active low reset signal to generate the LFSR sequence. On reset, the LFSR is initialized to 1111 (in binary). During normal operation, the LFSR output is shifted by one bit each clock cycle, and the new bit at the leftmost position is generated by the XOR of the leftmost and second rightmost bits.\n\n Module header:\n\nmodule fibonacci_lfsr(input clk,input rst_n,output [4:0] data);\n [/INST]\n", "output": "wire feedback = data[4] ^ data[1] ; \n always @(posedge clk or negedge rst_n) \n  if (~rst_n) \n  data <= 4'hf; \n  else \n  data <= {data[2:0], feedback} ; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a simple stimulus module with a 2-bit input data and a single-bit result. The result is assigned based on the data input, and an initial block displays the message \"PASSED\".\n\n Module header:\n\nmodule stim;\n [/INST]\n", "output": "wire [1:0] data; \n  wire result; \n  assign result = data ? 1:0; \n  initial \n  $display(\"PASSED\"); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"quick_spi_soft_testbench\" simulates the behavior of a Serial Peripheral Interface (SPI) device. It includes signals for clock, reset, end_of_transaction, incoming and outgoing data, master-out-slave-in (MOSI), master-in-slave-out (MISO), serial clock (SCLK), slave select (SS), start_transaction, operation, sclk_toggle_count, incoming_data_buffer, and spi_clock_phase. \n\nThe module initially sets the clock and reset signals and then enters an always block to handle the SPI communication. It sets specific initial values for outgoing data, operation, miso, sclk_toggle_count, incoming data buffer, and spi clock phase. The module then checks conditions related to the sclk_toggle_count, operation, and spi clock phase and updates the signals accordingly.\n\nAdditionally, the module instantiates the \"quick_spi_soft\" module and creates an inverted clock signal for 25 cycles using an always block.\n\nOverall, this module models the behavior of an SPI device and handles the necessary logic to simulate the data transfer and clock generation.\n\n Module header:\n\nmodule quick_spi_soft_testbench;\n [/INST]\n", "output": "reg clk; \n reg rst_n; \n wire end_of_transaction; \n wire[7:0] incoming_data; \n reg[15:0] outgoing_data; \n wire mosi; \n reg miso; \n wire sclk; \n wire[1:0] ss_n; \n reg start_transaction; \n reg operation; \n integer sclk_toggle_count; \n reg[8:0] incoming_data_buffer; \n reg spi_clock_phase; \n initial begin \n  clk <= 1'b0; \n  rst_n <= 1'b0; \n  rst_n <= #50 1'b1; \n end \n always @ (posedge clk) begin \n  if(!rst_n) begin \n  outgoing_data <= {8'b00011010, 8'b01101010}; \n  operation <= 1'b0; \n  miso <= 1'b0; \n  sclk_toggle_count <= 0; \n  incoming_data_buffer <= {8'b10010101, 1'b1}; \n  spi_clock_phase <= 1'b1; \n  end \n  else begin \n  if(sclk_toggle_count > 36 && operation == 1'b0) begin \n  if(!spi_clock_phase) begin \n  miso <= incoming_data_buffer[0]; \n  incoming_data_buffer <= incoming_data_buffer >> 1; \n  end \n  end \n  sclk_toggle_count <= sclk_toggle_count + 1; \n  spi_clock_phase <= ~spi_clock_phase; \n  end \n end \n quick_spi_soft spi(.s_axi_aclk(clk),.s_axi_aresetn(rst_n),.mosi(mosi),.miso(miso),.sclk(sclk),.ss_n(ss_n)); \n always #25 clk <= ~clk; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module computes a 24-bit cyclic redundancy check (CRC) for Ethernet frames. It takes a 24-bit input data_in and a 32-bit crc_state as inputs, and produces a 32-bit crc_next output by performing a CRC iteration with the input data_in and the current crc_state.\n\n Module header:\n\nmodule eth_crc_24 (input wire [23:0] data_in,input wire [31:0] crc_state,output wire [31:0] crc_next);\n [/INST]\n", "output": "assign crc_next = crc_iteration( 24, crc_state, { 104'h0, data_in} ); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a finite state machine (FSM) that handles the uploading of DC requests. It has two states: \"dc_req_upload_idle\" and \"dc_req_upload_busy.\" \n\nIn the \"dc_req_upload_idle\" state, it checks if the DC flits request is valid and enables flits input if it is. In the \"dc_req_upload_busy\" state, it checks if the request FIFO is ready and resets the FSM state machine accordingly. \n\nBased on the state, it outputs the flits and control signals. It also handles the logic for incrementing the selection count and resetting various signals during clock cycles. The module uses the clock signal and a reset signal to control its operation.\n\n Module header:\n\nmodule dc_req_upload(clk,rst,dc_flits_req,v_dc_flits_req,req_fifo_rdy,dc_flit_out,v_dc_flit_out,dc_ctrl_out,dc_req_upload_state);\n [/INST]\n", "output": "input clk; \n input rst; \n input [47:0] dc_flits_req; \n input v_dc_flits_req; \n input req_fifo_rdy; \n output [15:0] dc_flit_out; \n output v_dc_flit_out; \n output [1:0] dc_ctrl_out; \n output dc_req_upload_state; \n parameter dc_req_upload_idle=1'b0; \n parameter dc_req_upload_busy=1'b1; \n reg dc_req_state; \n reg [47:0] dc_req_flits; \n reg [1:0] sel_cnt; \n reg v_dc_flit_out; \n reg fsm_rst; \n reg next; \n reg en_flits_in; \n reg inc_cnt; \n assign dc_req_upload_state=dc_req_state; \n always@(*) \n begin \n  v_dc_flit_out=1'b0; \n  inc_cnt=1'b0; \n  fsm_rst=1'b0; \n  en_flits_in=1'b0; \n  next=1'b0; \n  case(dc_req_state) \n  dc_req_upload_idle: \n  begin \n  if(v_dc_flits_req) \n  begin \n  en_flits_in=1'b1; \n  next=1'b1; \n  end \n  end \n  dc_req_upload_busy: \n  begin \n  if(req_fifo_rdy) \n  begin \n  if(sel_cnt==2'b10) \n  fsm_rst=1'b1; \n  inc_cnt=1'b1; \n  v_dc_flit_out=1'b1; \n  end \n  end \n  endcase \n end \n always@(posedge clk) \n begin \n  if(rst||fsm_rst) \n  dc_req_state<=1'b0; \n else if(next) \n  dc_req_state<=1'b1; \n end \n always@(posedge clk) \n begin \n  if(rst||fsm_rst) \n  dc_req_flits<=48'h0000; \n  else if(en_flits_in) \n  dc_req_flits<=dc_flits_req; \n end \n reg [15:0] dc_flit_out; \n reg [1:0] dc_ctrl_out; \n always@(*) \n begin \n  case(sel_cnt) \n  2'b00: \n  begin \n  dc_flit_out=dc_req_flits[47:32]; \n  dc_ctrl_out=2'b01; \n  end \n  2'b01: \n  begin \n  dc_flit_out=dc_req_flits[31:16]; \n  dc_ctrl_out=2'b10; \n  end \n  2'b10: \n  begin \n  dc_flit_out=dc_req_flits[15:0]; \n  dc_ctrl_out=2'b11; \n  end \n  default:begin \n  dc_flit_out=dc_req_flits[47:32]; \n  dc_ctrl_out=2'b00; \n  end \n  endcase \n end \n always@(posedge clk) \n begin \n  if(rst||fsm_rst) \n  sel_cnt<=2'b00; \n  else if(inc_cnt) \n  sel_cnt<=sel_cnt+2'b01; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, named va5ad63, has a parameter named vc5c8ea. The module has an output vbbba94 of 6 bits. It declares a local parameter p0 which is assigned the value of vc5c8ea. It instantiates another module va5ad63_v465065 and passes the parameter VALUE with the value p0. The output w1 is assigned to the output vbbba94.\n\n Module header:\n\nmodule va5ad63 #(parameter vc5c8ea = 0) (output [5:0] vbbba94);\n [/INST]\n", "output": "localparam p0 = vc5c8ea; \n  wire [0:5] w1; \n  assign vbbba94 = w1; \n va5ad63_v465065 #(.VALUE(p0)) v465065 (.k(w1)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a binary to BCD (Binary-Coded Decimal) converter. It takes an 8-bit binary input A and produces three 4-bit BCD outputs ONES, TENS, and HUNDREDS. The module uses a series of 3-bit binary adders (add3 instances) to generate the BCD outputs. The adders take the binary input A and a carry input from the previous stage to produce the BCD outputs. The ONES output corresponds to the ones place, the TENS output corresponds to the tens place, and the HUNDREDS output corresponds to the hundreds place.\n\n Module header:\n\nmodule binary_to_BCD(A,ONES,TENS,HUNDREDS);\n [/INST]\n", "output": "input [7:0] A; \n  output [3:0] ONES, TENS; \n  output [3:0] HUNDREDS; \n  wire [3:0] c1,c2,c3,c4,c5,c6,c7; \n  wire [3:0] d1,d2,d3,d4,d5,d6,d7; \n  assign d1 = {1'b0,A[7:5]}; \n  assign d2 = {c1[2:0],A[4]}; \n  assign d3 = {c2[2:0],A[3]}; \n  assign d4 = {c3[2:0],A[2]}; \n  assign d5 = {c4[2:0],A[1]}; \n  assign d6 = {1'b0,c1[3],c2[3],c3[3]}; \n  assign d7 = {c6[2:0],c4[3]}; \n  add3 m1(d1,c1); \n  add3 m2(d2,c2); \n  add3 m3(d3,c3); \n  add3 m4(d4,c4); \n  add3 m5(d5,c5); \n  add3 m6(d6,c6); \n  add3 m7(d7,c7); \n  assign ONES = {c5[2:0],A[0]}; \n  assign TENS = {c7[2:0],c5[3]}; \n  assign HUNDREDS = {2'b00, c6[3],c7[3]}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a dual-port RAM with a configurable depth and width. It has two sets of input and output ports for simultaneous read and write operations. The module uses two always blocks triggered by the positive edge of the sys_clk to handle write operations for the two sets of input and output ports. The RAM is initialized with zeros, and the do and do2 outputs are assigned the values stored in the RAM at the respective addresses provided in the input signals.\n\n Module header:\n\nmodule tmu2_dpram #(parameter depth = 11,parameter width = 32) (input sys_clk,input [depth-1:0] a,input we,input [width-1:0] di,output reg [width-1:0] do,input [depth-1:0] a2,input we2,input [width-1:0] di2,output reg [width-1:0] do2);\n [/INST]\n", "output": "reg [width-1:0] ram[0:(1 << depth)-1]; \n always @(posedge sys_clk) begin \n  if(we) \n  ram[a] <= di; \n  do <= ram[a]; \n end \n always @(posedge sys_clk) begin \n  if(we2) \n  ram[a2] <= di2; \n  do2 <= ram[a2]; \n end \n integer i; \n initial begin \n  for(i=0;i<(1 << depth);i=i+1) \n  ram[i] = 0; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a clock divider that generates different clock signals for various purposes. It produces clock signals for the LCD and 7-segment display, as well as 1 second, 500 milliseconds, and 1 microsecond timer intervals. The module uses counters to keep track of the time intervals and updates the clock signals accordingly. It resets the timers when they reach their limits and increments them based on the specified intervals. Additionally, it assigns the appropriate clock signals to the LCD and 7-segment display based on the timer intervals.\n\n Module header:\n\nmodule CLK_DIV(clk_LCD, clk_7seg, clk_1s, clk_500ms, clk_1us, clk);\n [/INST]\n", "output": "input clk; \n  output clk_LCD, clk_7seg, clk_1s, clk_500ms, clk_1us; \n  wire clk_LCD, clk_7seg; \n  reg clk_1s, clk_500ms, clk_1us; \n  wire next_clk_1s, next_clk_500ms, next_clk_1us; \n  reg [15:0] num; \n  wire [15:0] next_num; \n  reg [5:0] num1us, next_num1us; \n  reg [25:0] num500ms, next_num500ms; \n  reg [25:0] num1s, next_num1s; \n  always @( posedge clk)begin \n  num <= next_num; \n  num1us <= next_num1us; \n  num500ms <= next_num500ms; \n  num1s <= next_num1s; \n  clk_1s <= next_clk_1s; \n  clk_500ms <= next_clk_500ms; \n  clk_1us <= next_clk_1us; \n  end \n  always @( * )begin \n  if(num1us>=6'd39) \n  next_num1us = 6'd0; \n  else \n  next_num1us = num1us + 6'd1; \n  if(num500ms>=26'd19999999) \n  next_num500ms = 26'd0; \n  else \n  next_num500ms = num500ms + 26'd1; \n  if(num1s>=26'd39999999) \n  next_num1s = 26'd0; \n  else \n  next_num1s = num1s + 26'd1; \n  end \n  assign next_num = num + 16'd1; \n  assign clk_LCD = num[8]; \n  assign clk_7seg = num[15]; \n  assign next_clk_1s = (num1s<26'd20000000) ? 1'd0 : 1'd1; \n  assign next_clk_500ms = (num500ms<26'd10000000) ? 1'd0 : 1'd1; \n  assign next_clk_1us = (num1us<6'd20) ? 1'd0 : 1'd1; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a split transaction memory unit (TMU) with inputs for system clock, reset, and various control signals, and outputs for the busy flag and various control signals. It also has internal registers for storing address and miss data. The module uses a combination of always blocks and assignments to handle pipeline operations and manage the state of the memory unit. The busy flag indicates whether the memory unit is currently processing a transaction.\n\n Module header:\n\nmodule tmu2_split #(parameter cache_depth = 13,parameter fml_depth = 26) (input sys_clk,input sys_rst,output busy,input pipe_stb_i,output pipe_ack_o,input [fml_depth-1-1:0] dadr,input [fml_depth-1:0] tadra,input [fml_depth-1:0] tadrb,input [fml_depth-1:0] tadrc,input [fml_depth-1:0] tadrd,input [5:0] x_frac,input [5:0] y_frac,input miss_a,input miss_b,input miss_c,input miss_d,output reg frag_pipe_stb_o,input frag_pipe_ack_i,output reg [fml_depth-1-1:0] frag_dadr,output [cache_depth-1:0] frag_tadra,output [cache_depth-1:0] frag_tadrb,output [cache_depth-1:0] frag_tadrc,output [cache_depth-1:0] frag_tadrd,output reg [5:0] frag_x_frac,output reg [5:0] frag_y_frac,output frag_miss_a,output frag_miss_b,output frag_miss_c,output frag_miss_d,output reg fetch_pipe_stb_o,input fetch_pipe_ack_i,output [fml_depth-5-1:0] fetch_tadra,output [fml_depth-5-1:0] fetch_tadrb,output [fml_depth-5-1:0] fetch_tadrc,output [fml_depth-5-1:0] fetch_tadrd,output fetch_miss_a,output fetch_miss_b,output fetch_miss_c,output fetch_miss_d);\n [/INST]\n", "output": "reg [fml_depth-1:0] r_tadra; \n reg [fml_depth-1:0] r_tadrb; \n reg [fml_depth-1:0] r_tadrc; \n reg [fml_depth-1:0] r_tadrd; \n reg r_miss_a; \n reg r_miss_b; \n reg r_miss_c; \n reg r_miss_d; \n assign frag_tadra = r_tadra[cache_depth-1:0]; \n assign frag_tadrb = r_tadrb[cache_depth-1:0]; \n assign frag_tadrc = r_tadrc[cache_depth-1:0]; \n assign frag_tadrd = r_tadrd[cache_depth-1:0]; \n assign frag_miss_a = r_miss_a; \n assign frag_miss_b = r_miss_b; \n assign frag_miss_c = r_miss_c; \n assign frag_miss_d = r_miss_d; \n assign fetch_tadra = r_tadra[fml_depth-1:5]; \n assign fetch_tadrb = r_tadrb[fml_depth-1:5]; \n assign fetch_tadrc = r_tadrc[fml_depth-1:5]; \n assign fetch_tadrd = r_tadrd[fml_depth-1:5]; \n assign fetch_miss_a = r_miss_a; \n assign fetch_miss_b = r_miss_b; \n assign fetch_miss_c = r_miss_c; \n assign fetch_miss_d = r_miss_d; \n reg data_valid; \n always @(posedge sys_clk) begin \n  if(sys_rst) begin \n  frag_pipe_stb_o <= 1'b0; \n  fetch_pipe_stb_o <= 1'b0; \n  end else begin \n  if(frag_pipe_ack_i) \n  frag_pipe_stb_o <= 1'b0; \n  if(fetch_pipe_ack_i) \n  fetch_pipe_stb_o <= 1'b0; \n  if(pipe_ack_o) begin \n  frag_pipe_stb_o <= pipe_stb_i; \n  fetch_pipe_stb_o <= pipe_stb_i & (miss_a | miss_b | miss_c | miss_d); \n  frag_dadr <= dadr; \n  r_tadra <= tadra; \n  r_tadrb <= tadrb; \n  r_tadrc <= tadrc; \n  r_tadrd <= tadrd; \n  frag_x_frac <= x_frac; \n  frag_y_frac <= y_frac; \n  r_miss_a <= miss_a; \n  r_miss_b <= miss_b; \n  r_miss_c <= miss_c; \n  r_miss_d <= miss_d; \n  end \n  end \n end \n assign busy = frag_pipe_stb_o | fetch_pipe_stb_o; \n assign pipe_ack_o = (~frag_pipe_stb_o & ~fetch_pipe_stb_o) | (frag_pipe_ack_i & fetch_pipe_ack_i); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, named \"robo\", is designed to control LEDs and servos based on a clock signal and data read from a memory file. It contains a counter for running LED patterns and a memory block to store data. It also implements toggle flag logic, which enables the manipulation of the data and controls the servos based on the toggle flag's state. The module also uses the clock edge to decrement certain counters and to set the LED and servo outputs accordingly.\n\n Module header:\n\nmodule robo (clk,led0, led1, led2, led3, led4, led5, led6, led7,servo0, servo1, servo2, servo3);\n [/INST]\n", "output": "input clk ; \n output reg led0 ; \n output reg led1 ; \n output reg led2 ; \n output reg led3 ; \n output reg led4 ; \n output reg led5 ; \n output reg led6 ; \n output reg led7 ; \n output reg servo0 ; \n output reg servo1 ; \n output reg servo2 ; \n output reg servo3 ; \n reg [31:0] run; \n always @(posedge clk) \n  run <= run + 32'b1; \n reg [63:0] mem [0:255]; \n reg [63:0] data; \n reg [7:0] ptr; \n initial begin \n  $readmemh(\"ram.txt\", mem); \n end \n always @* \n  data = mem[ptr]; \n reg [31:0] tf; \n reg tf_reset; \n reg tf_en; \n always @* \n  tf_reset = (tf === 32'd600); \n always @* \n  tf_en = &run[10:0]; \n always @(posedge clk) \n  if (tf_en) begin \n  if (tf_reset) begin \n  tf <= 32'b0; \n  end else begin \n  tf <= tf + 32'b1; \n  end \n  end \n always @(posedge clk) \n  if (tf_en & tf_reset) \n  ptr <= ptr + 1; \n reg [15:0] t0; \n reg t0_valid; \n always @* \n  t0_valid = |t0; \n always @(posedge clk) \n  if (tf_en) begin \n  if (tf_reset) begin \n  t0 <= data[15:0]; \n  end else begin \n  if (t0_valid) begin \n  t0 <= t0 - 16'b1; \n  end \n  end \n  end \n reg [15:0] t1; \n reg t1_valid; \n always @* \n  t1_valid = |t1; \n always @(posedge clk) \n  if (tf_en) begin \n  if (tf_reset) begin \n  t1 <= data[31:16]; \n  end else begin \n  if (t1_valid) begin \n  t1 <= t1 - 16'b1; \n  end \n  end \n  end \n reg [15:0] t2; \n reg t2_valid; \n always @* \n  t2_valid = |t2; \n always @(posedge clk) \n  if (tf_en) begin \n  if (tf_reset) begin \n  t2 <= data[47:32]; \n  end else begin \n  if (t2_valid) begin \n  t2 <= t2 - 16'b1; \n  end \n  end \n  end \n reg [15:0] t3; \n reg t3_valid; \n always @* \n  t3_valid = |t3; \n always @(posedge clk) \n  if (tf_en) begin \n  if (tf_reset) begin \n  t3 <= data[63:48]; \n  end else begin \n  if (t3_valid) begin \n  t3 <= t3 - 16'b1; \n  end \n  end \n  end \n always @* begin \n  servo0 = t0_valid; \n  servo1 = t1_valid; \n  servo2 = t2_valid; \n  servo3 = t3_valid; \n  led0 = run[24]; \n  led1 = run[25]; \n  led2 = run[26]; \n  led3 = run[27]; \n  led4 = run[28]; \n  led5 = run[29]; \n  led6 = run[30]; \n  led7 = run[31]; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a synchronous FIFO with a parameterizable data width. It consists of a two-element memory to store the input data, along with flags to indicate if the FIFO is full or empty. The module includes logic to handle data input and output requests, as well as to manage the used flag based on input and output acknowledgments. Additionally, the module includes logic to reset the FIFO memory and used flag on the rising edge of the clock or asynchronous reset signal.\n\n Module header:\n\nmodule zl_fifo_2 # (parameter Width = 0) (input clk,input rst_n,input data_in_req,output data_in_ack,input [Width-1:0] data_in,output data_out_req,input data_out_ack,output [Width-1:0] data_out);\n [/INST]\n", "output": "reg [Width-1:0] fifo_mem [0:1]; \n reg [1:0] used; \n wire empty; \n wire full; \n assign empty = (used == 2'b00); \n assign full = (used == 2'b10); \n assign data_out_req = (!empty); \n assign data_in_ack = (!full && data_in_req); \n assign data_out = (full ? fifo_mem[1] : fifo_mem[0]); \n always @(posedge clk or negedge rst_n) begin \n  if(!rst_n) begin \n  used <= 2'b00; \n  end \n  else if(data_in_ack && data_out_ack) begin \n  used <= used; \n  end \n  else if(data_in_ack) begin \n  used <= used + 1'b1; \n  end \n  else if(data_out_ack) begin \n  used <= used - 1'b1; \n  end \n end \n always @(posedge clk or negedge rst_n) begin \n  if(!rst_n) begin \n  fifo_mem[0] <= {Width{1'b0}}; \n  fifo_mem[1] <= {Width{1'b0}}; \n  end \n  else if(data_in_ack) begin \n  fifo_mem[0] <= data_in; \n  fifo_mem[1] <= fifo_mem[0]; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `channel_mux` selects data from one of the four input channels `ch0`, `ch1`, `ch2`, and `ch3` based on the two-bit input `channel`. The selected data is then output as `dataout`. If the input `channel` doesn't match any of the defined cases, the output is set to 0.\n\n Module header:\n\nmodule channel_mux(ch0, ch1, ch2, ch3, channel, dataout);\n [/INST]\n", "output": "input [7:0] ch0; \n  input [7:0] ch1; \n  input [7:0] ch2; \n  input [7:0] ch3; \n  input [1:0] channel; \n  output reg [7:0] dataout; \n  always @(*) begin \n  case(channel) \n  0: \n  dataout <= ch0; \n  1: \n  dataout <= ch1; \n  2: \n  dataout <= ch2; \n  3: \n  dataout <= ch3; \n  default: \n  dataout <= 0; \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a reset circuit. When the rst input is asserted, the r register is set to 0 and the rst_n output is set to 0. Otherwise, on each falling edge of the clk input, the rst_n output is updated according to the logic `{rst_n, r} <= {r, 1'b1}`.\n\n Module header:\n\nmodule jt12_rst(input rst,input clk,output reg rst_n);\n [/INST]\n", "output": "reg r; \n always @(negedge clk) \n  if( rst ) begin \n  r <= 1'b0; \n  rst_n <= 1'b0; \n  end else begin \n  { rst_n, r } <= { r, 1'b1 }; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module generates a heartbeat signal based on the clock input. The heartbeat signal toggles at a frequency determined by the cntr counter, which is reset when the nreset input is low. The module outputs the heartbeat signal.\n\n Module header:\n\nmodule heartbeat(input clk_i,input nreset_i,output heartbeat_o);\n [/INST]\n", "output": "reg [26:0] cntr; \n reg heartbeat; \n assign heartbeat_o = heartbeat; \n always @(posedge clk_i) \n begin \n  if (!nreset_i) \n  begin \n  cntr = 0; \n  heartbeat = 0; \n  end else begin \n  cntr = cntr + 1'b1; \n  if( cntr == 27'd100000000 ) \n  begin \n  cntr = 0; \n  heartbeat = !heartbeat; \n  end \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a multiplexer that selects inputs based on the `flushIDEX` signal. When `flushIDEX` is low, the module outputs the input values. When `flushIDEX` is high, the module sets the outputs to default values. The module has several input and output signals for controlling different parts of a pipeline. The values of the output signals are determined based on the value of `flushIDEX`.\n\n Module header:\n\nmodule flushMUX(flushIDEX,RegDstin,RegWrin,ALUSrc1in,ALUSrc2in,ALUFunin,Signin,MemWrin,MemRdin,MemtoRegin,RegDstout,RegWrout,ALUSrc1out,ALUSrc2out,ALUFunout,Signout,MemWrout,MemRdout,MemtoRegout);\n [/INST]\n", "output": "input flushIDEX; \n input [1:0] RegDstin; \n input RegWrin; \n input ALUSrc1in; \n input ALUSrc2in; \n input [5:0] ALUFunin; \n input Signin; \n input MemWrin; \n input MemRdin; \n input [1:0] MemtoRegin; \n output [1:0] RegDstout; \n reg [1:0] RegDstout; \n output RegWrout; \n reg RegWrout; \n output ALUSrc1out; \n reg ALUSrc1out; \n output ALUSrc2out; \n reg ALUSrc2out; \n output [5:0] ALUFunout; \n reg [5:0] ALUFunout; \n output Signout; \n reg Signout; \n output MemWrout; \n reg MemWrout; \n output MemRdout; \n reg MemRdout; \n output [1:0] MemtoRegout; \n reg [1:0] MemtoRegout; \n always @(*) \n begin \n  if(~flushIDEX) \n  begin \n  RegDstout <= RegDstin; \n  RegWrout <= RegWrin; \n  ALUSrc1out <= ALUSrc1in; \n  ALUSrc2out <= ALUSrc2in; \n  ALUFunout <= ALUFunin; \n  Signout <= Signin; \n  MemWrout <= MemWrin; \n  MemRdout <= MemRdin; \n  MemtoRegout <= MemtoRegin; \n  end \n  else \n  begin \n  RegDstout <= 2'b00; \n  RegWrout <= 0; \n  ALUSrc1out <= 0; \n  ALUSrc2out <= 0; \n  ALUFunout <= 6'h0; \n  Signout <= 0; \n  MemWrout <= 0; \n  MemRdout <= 0; \n  MemtoRegout <= 2'b00; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a master-slave flip-flop with synchronous set/reset and clock enable. When the te input is low, the flip-flop is enabled, allowing data at the input d to be clocked into the flip-flop on the positive edge of the cp input. The output q is the complement of the input data d when te is low, and qn is the complement of q. When te is high, the flip-flop is disabled, and q and qn hold their previous values.\n\n Module header:\n\nmodule ME_FD1E (cp, te, d, q, qn);\n [/INST]\n", "output": "input d, cp, te; \n  output q, qn ; \n  wire load_l; \n  assign load_l = ~te; \n  Mflipflop dff (.out(q), .in(d), .clock(cp), .enable_l(load_l)); \n  assign qn = ~q; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a configurable up counter that counts up to a maximum value defined by the TOTAL_WIDTH parameter. It increments the up_count when the up_clk signal is high and resets it to 0 when the up_rstn signal is low. The module also has a down counter, d_count, which increments when the d_clk signal is high and resets to 0 when d_count_run_m3 and d_count_run_m2 are both 0. The up_d_count output captures the value of d_count when certain conditions are met. The module also handles the synchronization and resetting of various control signals based on the clock and reset signals.\n\n Module header:\n\nmodule up_clock_mon #(parameter TOTAL_WIDTH = 32) (input up_rstn,input up_clk,output reg [TOTAL_WIDTH-1:0] up_d_count,input d_rst,input d_clk);\n [/INST]\n", "output": "reg [15:0] up_count = 'd1; \n  reg up_count_run = 'd0; \n  reg up_count_running_m1 = 'd0; \n  reg up_count_running_m2 = 'd0; \n  reg up_count_running_m3 = 'd0; \n  reg d_count_run_m1 = 'd0; \n  reg d_count_run_m2 = 'd0; \n  reg d_count_run_m3 = 'd0; \n  reg [TOTAL_WIDTH:0] d_count = 'd0; \n  wire up_count_capture_s; \n  wire d_count_reset_s; \n  assign up_count_capture_s = up_count_running_m3 == 1'b1 && up_count_running_m2 == 1'b0; \n  always @(posedge up_clk) begin \n  if (up_rstn == 0) begin \n  up_count_running_m1 <= 1'b0; \n  up_count_running_m2 <= 1'b0; \n  up_count_running_m3 <= 1'b0; \n  end else begin \n  up_count_running_m1 <= d_count_run_m3; \n  up_count_running_m2 <= up_count_running_m1; \n  up_count_running_m3 <= up_count_running_m2; \n  end \n  end \n  always @(posedge up_clk) begin \n  if (up_rstn == 0) begin \n  up_d_count <= 'd0; \n  up_count_run <= 1'b0; \n  end else begin \n  if (up_count_running_m3 == 1'b0) begin \n  up_count_run <= 1'b1; \n  end else if (up_count == 'h00) begin \n  up_count_run <= 1'b0; \n  end \n  if (up_count_capture_s == 1'b1) begin \n  up_d_count <= d_count[TOTAL_WIDTH-1:0]; \n  end else if (up_count == 'h00 && up_count_run != up_count_running_m3) begin \n  up_d_count <= 'h00; \n  end \n  end \n  end \n  always @(posedge up_clk) begin \n  if (up_count_run == 1'b0 && up_count_running_m3 == 1'b0) begin \n  up_count <= 'h01; \n  end else begin \n  up_count <= up_count + 1'b1; \n  end \n  end \n  assign d_count_reset_s = d_count_run_m3 == 1'b0 && d_count_run_m2 == 1'b1; \n  always @(posedge d_clk or posedge d_rst) begin \n  if (d_rst == 1'b1) begin \n  d_count_run_m1 <= 1'b0; \n  d_count_run_m2 <= 1'b0; \n  d_count_run_m3 <= 1'b0; \n  end else begin \n  d_count_run_m1 <= up_count_run; \n  d_count_run_m2 <= d_count_run_m1; \n  d_count_run_m3 <= d_count_run_m2; \n  end \n  end \n  always @(posedge d_clk) begin \n  if (d_count_reset_s == 1'b1) begin \n  d_count <= 'h00; \n  end else if (d_count_run_m3 == 1'b1) begin \n  if (d_count[TOTAL_WIDTH] == 1'b0) begin \n  d_count <= d_count + 1'b1; \n  end else begin \n  d_count <= {TOTAL_WIDTH+1{1'b1}}; \n  end \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a 16-bit floating-point adder/subtracter. It takes in several input signals such as clock, reset, and various 16-bit floating-point values, and produces a 16-bit output. The module performs operations such as checking for leading zeros, adjusting exponents, and determining the output based on the input values. It also checks for underflow and adjusts the output accordingly.\n\n Module header:\n\nmodule FP16BAddSubS4Of5(input clk,input rst,input [14:0] arg_0,input arg_1,input arg_2,input [7:0] arg_3,input arg_4,input arg_5,input arg_6,output [15:0] ret_0);\n [/INST]\n", "output": "wire [15:0] r; \n  wire xs; \n  wire ys; \n  wire [7:0] e; \n  wire [7:0] e_final; \n  wire [8:0] e_l0adjust; \n  wire underflow; \n  wire [7:0] e_adjust; \n  wire neg; \n  wire xn; \n  wire yn; \n  wire [7:0] rr; \n  wire [6:0] r_final; \n  wire [15:0] r8; \n  wire [15:0] r4; \n  wire [15:0] r2; \n  wire [15:0] r1; \n  wire [3:0] l0count; \n  wire s; \n  assign r = arg_0; \n  assign xs = arg_1; \n  assign ys = arg_2; \n  assign e = arg_3; \n  assign neg = arg_4; \n  assign xn = arg_5; \n  assign yn = arg_6; \n  assign s = (xn == yn) ? xs : (yn ? (neg ^ xs): (neg ^ ys)); \n  assign r8 = (r[14:7] == 0) ? {r[6:0], 8'b0} : r; \n  assign r4 = (r8[14:11] == 0) ? {r8[10:0], 4'b0} : r8; \n  assign r2 = (r4[14:13] == 0) ? {r4[12:0], 2'b0} : r4; \n  assign r1 = (r2[14:14] == 0) ? {r2[13:0], 1'b0} : r2; \n  assign l0count = {r[14:7] == 0, r8[14:11] == 0, r4[14:13] == 0, r2[14:14] == 0}; \n  assign rr = (xn == yn) ? r[14:7] : r1; \n  assign e_l0adjust = e - l0count; \n  assign underflow = e_l0adjust[8:8]; \n  assign e_adjust = underflow ? 0 : e_l0adjust[7:0]; \n  assign e_final = (xn == yn) ? e : e_adjust[7:0]; \n  assign r_final = underflow ? 0 : rr[6:0]; \n  assign ret_0 = {s, e_final, r_final}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an evaluation node that performs various computations on input data. It takes in clock and reset signals, along with several 64-bit input values. It multiplies the positive and negative inputs with the upside and downside values, respectively. It then multiplies the results and compares the exercise input with the value hold. \n\nIf the exercise flag is true, it outputs the delayed exercise value, otherwise, it outputs the delayed value hold. This operation is driven by the clock signal.\n\n Module header:\n\nmodule eval_node(clk,nrst,p_up,p_down,v_up,v_down,v_ex,result);\n [/INST]\n", "output": "input clk; \n input nrst; \n input [63:0] p_up; \n input [63:0] p_down; \n input [63:0] v_up; \n input [63:0] v_down; \n input [63:0] v_ex; \n output [63:0] result; \n wire [63:0] upside_value; \n wire [63:0] downside_value; \n wire [63:0] v_hold; \n wire [63:0] v_ex_delayed; \n wire [63:0] v_hold_delayed; \n wire exercise; \n reg [63:0] result; \n fp_mult_v1 upside_mult (.clock ( clk ),.dataa ( p_up ),.datab ( v_up ),.result ( upside_value )); \n fp_mult_v1 downside_mult (.clock ( clk ),.dataa ( p_down ),.datab ( v_down ),.result ( downside_value )); \n fp_add_v1 fp_mult_vhold (.clock ( clk ),.dataa ( upside_value ),.datab ( downside_value ),.result ( v_hold )); \n fp_compare_v1 fp_compare_v1_inst (.clock ( clk ),.dataa ( v_ex ),.datab ( v_hold ),.agb ( exercise )); \n lpm_ff_v1 lpm_ff_v_ex (.clock ( clk ),.data ( v_ex ),.q ( v_ex_delayed )); \n lpm_ff_v1 lpm_ff_v_hold (.clock ( clk ),.data ( v_hold ),.q ( v_hold_delayed )); \n always@(posedge clk) \n begin \n  if( exercise ) result <= v_ex_delayed[63:0]; \n  else result <= v_hold_delayed[63:0]; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes an input arb_select_f and an input octet_idx, and produces several outputs: octet_flag, octet_available, and shifted8_64. The octet_flag is produced by OR-ing every 8 bits of the arb_select_f. The octet_available is the result of OR-ing all bits of the octet_flag. The shifted8_64 output is the result of shifting the octet_flag based on the octet_idx input.\n\n Module header:\n\nmodule x;\n [/INST]\n", "output": "always @(arb_select_f or octet_idx) begin \n  octet_flag[0] = |arb_select_f[ 7: 0]; \n  octet_flag[1] = |arb_select_f[15: 8]; \n  octet_flag[2] = |arb_select_f[23:16]; \n  octet_flag[3] = |arb_select_f[31:24]; \n  octet_flag[4] = |arb_select_f[39:32]; \n  octet_flag[5] = |arb_select_f[47:40]; \n  octet_flag[6] = |arb_select_f[55:48]; \n  octet_flag[7] = |arb_select_f[63:56]; \n  octet_available = |octet_flag; \n  shifted8_64 = barrel_shifter(octet_flag, octet_idx[5:3]); \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module `RCB_FRL_channel_MSG` instantiates two sub-modules `RCB_FRL_CMD_shift_MSG` and `RCB_FRL_CMD_shift_MSG_CON`. The module takes input signals CLK, CLKDIV, RST, and DATA_IN, and outputs fifo_WREN1, RE_SIG, D, CON_P, and CON_N. Inside the module, it assigns `DATA_IN` to `input_reg1_wire` and then passes it to the `CMD_shift_inst` and `CMD_shift_inst2` modules. These sub-modules perform additional processing and generate the outputs CON_P, CON_N, fifo_WREN1, RE_SIG, and D.\n\n Module header:\n\nmodule RCB_FRL_channel_MSG (CLK, CLKDIV, DATA_IN, RST, fifo_WREN1, D, RE_SIG, CON_P, CON_N);\n [/INST]\n", "output": "input CLK, CLKDIV, RST; \n  input [7:0] DATA_IN; \n  output fifo_WREN1, RE_SIG; \n  output [39:0] D; \n  output CON_P, CON_N; \n  wire [7:0] input_reg1_wire, input_reg1_wire_inv; \n  wire CON_P, CON_N; \n  assign input_reg1_wire = DATA_IN; \n  RCB_FRL_CMD_shift_MSG CMD_shift_inst \n (.data_in(input_reg1_wire),.clk(CLKDIV),.enable(~RST),.data_out(),.data_valid(),.data_correct(fifo_WREN1),.data_wrong(RE_SIG),.data_all(D)); \n  RCB_FRL_CMD_shift_MSG_CON CMD_shift_inst2 \n (.data_in(input_reg1_wire),.clk(CLKDIV),.enable(~RST),.CON_P(CON_P),.CON_N(CON_N)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a formal verification module for a cell network. It consists of signals for clock, request, acknowledgement, address, data, and error. The module includes formal assertions for checking request, acknowledgement, error, data, and output data consistency. It also has checks for past valid requests and acknowledgements. The formal assertions ensure the correctness of the cell network's behavior under different conditions.\n\n Module header:\n\nmodule formal_top ();\n [/INST]\n", "output": "wire cn_clk; \n  wire cn_req; \n  wire cn_ack; \n  wire [`ADDRESS_SIZE-1:0] cn_addr; \n  wire [`DATA_SIZE-1:0] cn_data; \n  wire cn_err; \n  wire [`DATA_SIZE-1:0] cn_o_data; \n cellnet_source cn_src_1 (.i_clk(cn_clk),.o_addr(cn_addr),.o_dat(cn_data),.o_req(cn_req),.i_ack(cn_ack)); \n cellnet_sink cn_snk_1 (.i_clk(cn_clk),.i_addr(cn_addr),.i_dat(cn_data),.i_req(cn_req),.o_ack(cn_ack),.o_dat(cn_o_data),.o_err(cn_err)); \n  `ifdef FORMAL \n  initial assert(cn_req == `OFF); \n  initial assert(cn_ack == `OFF); \n  initial assert(cn_err == `OFF); \n  initial assert(cn_data == 0); \n  initial assert(cn_o_data == 0); \n  reg f_past_valid; \n  initial f_past_valid = `OFF; \n  always @(posedge cn_clk) begin \n  f_past_valid <= `ON; \n  end \n  always @(posedge cn_clk) begin \n  if((! cn_req) && (! cn_ack)) begin \n  assert(cn_data == cn_o_data); \n  end \n  if(cn_req && (! cn_ack)) begin \n  end \n  if(cn_req && cn_ack) begin \n  end \n  if((! cn_req) && cn_ack) begin \n  end \n  if(f_past_valid) begin \n  if($past(cn_req) && cn_req) begin \n  assert(cn_data == $past(cn_data)); \n  assert(cn_addr == $past(cn_addr)); \n  end \n  if((! $past(cn_req)) && cn_req) begin \n  assert(cn_o_data == $past(cn_data)); \n  end \n  if((! $past(cn_ack)) && cn_ack) begin \n  assert(cn_o_data == $past(cn_data)); \n  end \n  end \n  end \n  `endif \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a register file with a configurable number of registers. It has input ports for data, read and write addresses, and a clock signal. On a negative clock edge, it writes the data into the specified register, and on a positive clock edge, it reads data from the specified registers and outputs it through the ra and rb ports. The registers are addressed using the addr_a, addr_b, and addr_d inputs.\n\n Module header:\n\nmodule reg_file #(parameter d_width = 32, reg_ct = 32, ra_width = $clog2(reg_ct) ) ( output reg[d_width-1:0] ra, rb,input [d_width-1:0] rd,input [ra_width-1:0] addr_a, addr_b, addr_d,input clk);\n [/INST]\n", "output": "reg [d_width-1:0] regs[reg_ct-1:0]; \n  always @(negedge clk) begin \n  regs[addr_d] <= rd; \n  end \n  always @(posedge clk) begin \n  ra <= regs[addr_a]; \n  rb <= regs[addr_b]; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an Arithmetic Logic Unit (ALU) that performs various operations on two 32-bit inputs a and b based on the 4-bit control signal ctl. It has a 32-bit output out and a zero flag output zero. The ALU performs addition, bitwise AND, bitwise OR, bitwise XOR, subtraction, bitwise inversion, and sets the sign bit and overflow flag based on the input control signal. The overflow flag is determined separately for addition and subtraction operations, and the ALU sets the zero flag if the output is zero. The module uses combinatorial logic to generate the output based on the control signal and input data.\n\n Module header:\n\nmodule alu(input [3:0] ctl,input [31:0] a, b,output reg [31:0] out,output zero);\n [/INST]\n", "output": "wire [31:0] sub_ab; \n  wire [31:0] add_ab; \n  wire oflow_add; \n  wire oflow_sub; \n  wire oflow; \n  wire slt; \n  assign zero = (0 == out); \n  assign sub_ab = a - b; \n  assign add_ab = a + b; \n  assign oflow_add = (a[31] == b[31] && add_ab[31] != a[31]) ? 1 : 0; \n  assign oflow_sub = (a[31] == b[31] && sub_ab[31] != a[31]) ? 1 : 0; \n  assign oflow = (ctl == 4'b0010) ? oflow_add : oflow_sub; \n  assign slt = oflow_sub ? ~(a[31]) : a[31]; \n  always @(*) begin \n  case (ctl) \n  4'b0010: out <= add_ab; \n  4'b0000: out <= a & b; \n  4'b1100: out <= ~(a | b); \n  4'b0001: out <= a | b; \n  4'b0111: out <= {{31{1'b0}}, slt}; \n  4'b0110: out <= sub_ab; \n  4'b1101: out <= a ^ b; \n  default: out <= 0; \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a digital circuit for the PRESENT encryption algorithm. It takes inputs from various switches and buttons, uses them to set the plaintext and key values, and then encrypts the plaintext using the key. The encrypted result is displayed on the seven-segment display. The control signal is derived from the input key and is used to trigger the encryption process.\n\n Module header:\n\nmodule present(input CLOCK_50,input CLOCK2_50,input CLOCK3_50,output [8:0] LEDG,output [17:0] LEDR,input [3:0] KEY,input [17:0] SW,output [6:0] HEX0,output [6:0] HEX1,output [6:0] HEX2,output [6:0] HEX3,output [6:0] HEX4,output [6:0] HEX5,output [6:0] HEX6,output [6:0] HEX7);\n [/INST]\n", "output": "reg [63:0] plaintext; \n reg [79:0] key; \n wire [63:0] plaintext_wrapper; \n wire [79:0] key_wrapper; \n wire [63:0] ciphertext; \n wire control; \n always @* begin \n  if (SW[3] & ~SW[2] & ~SW[1] & ~SW[0]) \n  begin \n  plaintext = 64'h0000000000000000; \n  key = 80'h00000000000000000000; \n  end \n  else if (~SW[3] & SW[2] & ~SW[1] & ~SW[0]) \n  begin \n  plaintext = 64'hFFFFFFFFFFFFFFFF; \n  key = 80'h00000000000000000000; \n  end \n  else if (~SW[3] & ~SW[2] & SW[1] & ~SW[0]) \n  begin \n  plaintext = 64'h0000000000000000; \n  key = 80'hFFFFFFFFFFFFFFFFFFFF; \n  end \n  else if (~SW[3] & ~SW[2] & ~SW[1] & SW[0]) \n  begin \n  plaintext = 64'hFFFFFFFFFFFFFFFF; \n  key = 80'hFFFFFFFFFFFFFFFFFFFF; \n  end \n  else \n  begin \n  plaintext = 'bx; \n  key = 'bx; \n  end \n end \n assign control = ~KEY[0]; \n assign plaintext_wrapper = plaintext; \n assign key_wrapper = key; \n SEG7_LUT_8 display \n (.oSEG0 (HEX0),.oSEG1 (HEX1),.oSEG2 (HEX2),.oSEG3 (HEX3),.oSEG4 (HEX4),.oSEG5 (HEX5),.oSEG6 (HEX6),.oSEG7 (HEX7),.iDIG (~KEY[1] ? ciphertext[63:32] : ciphertext[31:0])); \n PRESENT_ENCRYPT encryption \n (.odat (ciphertext),.idat (plaintext_wrapper),.key (key_wrapper),.load (control),.clk (CLOCK_50)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module l4 takes an 8-bit input and produces an 8-bit output. It instantiates two instances of the module l5, each with different parameters. The inputs to the l5 instances are derived from the input to module l4. The outputs of the l5 instances are added together to generate the output z of module l4.\n\n Module header:\n\nmodule l4 (input [7:0] a, output [7:0] z);\n [/INST]\n", "output": "`INLINE_MODULE \n  wire [7:0] z0 `PUBLIC; wire [7:0] z1 `PUBLIC; \n  wire [7:0] z `PUBLIC; assign z = z0+z1; \n  wire [7:0] a1 = a+8'd1; \n  l5 #(1) u0 (a, z0); l5 #(2) u1 (a1, z1); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a synchronous register with an 8-bit width. It takes inputs for data, write enable, and clock, and outputs the registered data. When the write enable signal is asserted, the input data is loaded into the register on the rising edge of the clock.\n\n Module header:\n\nmodule can_register ( data_in,data_out,we,clk);\n [/INST]\n", "output": "parameter WIDTH = 8; \n input [WIDTH-1:0] data_in; \n input we; \n input clk; \n output [WIDTH-1:0] data_out; \n reg [WIDTH-1:0] data_out; \n always @ (posedge clk) \n begin \n  if (we) \n  data_out<=#1 data_in; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module implements a state machine for USB transmission. It controls the flow of data based on input signals c, d, d_empty, q_req, and d_req. It uses a control register to manage state transitions and generate control signals for data requests and empty signals. The module also handles counting and encoding of the input data for transmission. The state machine transitions through IDLE, READ, STUFF, and DONE states, and generates the necessary control signals for each state.\n\n Module header:\n\nmodule usb_tx_stuff (input c,input d,input d_empty,output d_req,output q,input q_req,output q_empty);\n [/INST]\n", "output": "localparam ST_IDLE = 4'd0; \n localparam ST_READ = 4'd1; \n localparam ST_STUFF = 4'd2; \n localparam ST_DONE = 4'd3; \n localparam SW=4, CW=5; \n reg [CW+SW-1:0] ctrl; \n wire [SW-1:0] state; \n wire [SW-1:0] next_state = ctrl[SW+CW-1:CW]; \n r #(SW) state_r \n (.c(c), .rst(1'b0), .en(1'b1), .d(next_state), .q(state)); \n wire [2:0] ones_count; \n wire [2:0] done_cnt; \n wire done_cnt_rst; \n r #(3) done_cnt_r \n (.c(c), .rst(done_cnt_rst), .en(1'b1), .d(done_cnt+1'b1), .q(done_cnt)); \n always @* begin \n  case (state) \n  ST_IDLE: \n  if (~d_empty) ctrl = { ST_READ , 5'b00000 }; \n  else ctrl = { ST_IDLE , 5'b00000 }; \n  ST_READ: \n  if (d_empty) ctrl = { ST_DONE , 5'b00010 }; \n  else if (q_req) \n  if (ones_count == 3'd5 & d == 1'b1) \n  ctrl = { ST_STUFF, 5'b00110 }; \n  else ctrl = { ST_READ , 5'b00011 }; \n  else ctrl = { ST_READ , 5'b00000 }; \n  ST_STUFF: \n  if (d_empty) ctrl = { ST_DONE , 5'b00011 }; \n  else if (q_req) ctrl = { ST_READ , 5'b00001 }; \n  else ctrl = { ST_STUFF, 5'b00100 }; \n  ST_DONE: \n  if (done_cnt == 3'h7) ctrl = { ST_IDLE , 5'b00000 }; \n  else ctrl = { ST_DONE , 5'b00000 }; \n  default: ctrl = { ST_IDLE , 5'b00000 }; \n  endcase \n end \n assign d_req = ctrl[0]; \n assign done_cnt_rst = ctrl[1]; \n wire supress_empty = ctrl[2]; \n r #(3, 3'd0) ones_count_r \n (.c(c), .rst(state == ST_IDLE | (q_req & d == 1'b0) | state == ST_STUFF),.en(q_req & d == 1'b1),.d(ones_count + 1'b1), .q(ones_count)); \n wire nrzi; \n wire next_nrzi = (state == ST_STUFF) ? ~nrzi : (d ? nrzi : ~nrzi); \n r #(1, 1'b1) nrzi_r \n (.c(c), .rst(state == ST_IDLE), .en(state != ST_IDLE & q_req),.d(next_nrzi), .q(nrzi)); \n assign q = nrzi; \n assign q_empty = d_empty & ~supress_empty; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a RAM with 32-bit real and imaginary input data. It has clock, reset, enable, and start inputs, and ready, real output, and imaginary output signals. The module stores data in real and imaginary registers based on the input address and count. When the enable input is active, the module increments the count and updates the address, and sets the ready and delay signals accordingly. It then outputs the real and imaginary data based on the address.\n\n Module header:\n\nmodule RAM1(CLK,RST,ED,START,DReal,DImag,RDY,DOReal,DOImag);\n [/INST]\n", "output": "parameter total_bits = 32; \n input CLK; \n input RST; \n input ED; \n input START; \n input [total_bits-1:0] DReal; \n input [total_bits-1:0] DImag; \n output reg RDY; \n output [total_bits-1:0] DOReal; \n output [total_bits-1:0] DOImag; \n reg [total_bits-1:0] DATAReal [0:31]; \n reg [total_bits-1:0] DATAImag [0:31]; \n reg [5:0] addr; \n reg [6:0] count; \n reg delay; \n reg flag; \n  always @(posedge CLK) \n  begin \n  if (RST) begin \n  addr<=6'b000000; \n  count<= 7'b0000000; \n  flag<=0; \n  delay<=0; \n  RDY<=1'b0; end \n  else if (START) begin \n  addr<=6'b000000; \n  count<= 7'b0000000; \n  flag<=0; \n  delay<=0; \n  RDY<=1'b0;end \n  else if (ED) begin \n  RDY<=1'b0; \n  if(count<=31) \n  begin \n  DATAReal[{addr[0],addr[4:1]}] <= DReal; \n  DATAImag[{addr[0],addr[4:1]}] <= DImag; \n  end \n  if (count!=127) \n  count<=count+1; \n  if (count==31||count==126) \n  begin \n  RDY<=1'b1; \n  delay<=1'b1; \n  if(flag == 0) begin addr<=0; flag<=1; end \n  else addr<=16; \n  end \n  else \n  if(delay) \n  delay<=0; \n  else \n  addr<=addr+1; \n  end \n  end \n  assign DOReal = DATAReal[addr[4:0]]; \n  assign DOImag = DATAImag[addr[4:0]]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, DRAM_4_OUTPUT_STUB, takes four input signals, DOA, DOB, DOC, and DOD, and assigns them to four output signals, DOA_OUT, DOB_OUT, DOC_OUT, and DOD_OUT, respectively. Each output is directly connected to its corresponding input, without any additional logic or processing.\n\n Module header:\n\nmodule DRAM_4_OUTPUT_STUB(input DOA, DOB, DOC, DOD,output DOA_OUT, DOB_OUT, DOC_OUT, DOD_OUT);\n [/INST]\n", "output": "assign DOA_OUT = DOA; \n  assign DOB_OUT = DOB; \n  assign DOC_OUT = DOC; \n  assign DOD_OUT = DOD; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"sri\" implements a shift register with a configurable DATA_WIDTH. It has inputs for the clock signal, reset signal, input data, sample and shift control signals, and an output for the shifted data. The shift register is implemented using a register \"sr_reg\" of size DATA_WIDTH. The output \"din\" is assigned to the most significant bit of \"sr_reg\". \n\nWhen the synchronous reset `ifdef SYNC_RESET is active, the shift register is cleared to 0 on the positive edge of the clock when the reset signal is asserted. If the synchronous reset is not active, the shift register is cleared to 0 when the negative edge of the reset signal is detected, and then the operations inside the if-else blocks are performed.\n\nIf the \"sample\" input is asserted, the shift register is loaded with the input data \"datai\". If the \"shift\" input is asserted, the shift register \"sr_reg\" shifts its content left by one bit, effectively implementing the shift operation.\n\nIn summary, this module provides a flexible and configurable shift register functionality with synchronous or asynchronous reset options and controllable data loading and shifting operations based on the input control signals.\n\n Module header:\n\nmodule sri #(parameter DATA_WIDTH=16) (input clk,input resetb,input [DATA_WIDTH-1:0] datai,input sample,input shift,output din);\n [/INST]\n", "output": "reg [DATA_WIDTH-1:0] sr_reg; \n  assign din = sr_reg[DATA_WIDTH-1]; \n `ifdef SYNC_RESET \n  always @(posedge clk) begin \n `else \n  always @(posedge clk or negedge resetb) begin \n `endif \n  if(!resetb) begin \n  sr_reg <= 0; \n  end else begin \n  if(sample) begin \n  sr_reg <= datai; \n  end else if(shift) begin \n  sr_reg <= sr_reg << 1; \n  end \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes inputs SDRD0, SDA_L, and SDA_U, and outputs the 11 to 21 bits of MA. It uses SDA_U and SDA_L to determine the value of MA and updates RANGE_0, RANGE_1, RANGE_2, and RANGE_3 based on the values of SDA_L. The value of MA is determined based on the values of SDA_U[15:11] and the inverted values of some bits.\n\n Module header:\n\nmodule zmc(input SDRD0,input [1:0] SDA_L,input [15:8] SDA_U,output [21:11] MA);\n [/INST]\n", "output": "wire BANKSEL = SDA_U[15:8]; \n  reg [7:0] RANGE_0; \n  reg [7:0] RANGE_1; \n  reg [7:0] RANGE_2; \n  reg [7:0] RANGE_3; \n  assign MA = SDA_U[15] ? \n  ~SDA_U[14] ? \n  {RANGE_3, SDA_U[13:11]} : \n  ~SDA_U[13] ? \n  {1'b0, RANGE_2, SDA_U[12:11]} : \n  ~SDA_U[12] ? \n  {2'b00, RANGE_1, SDA_U[11]} : \n  {3'b000, RANGE_0} : \n  {6'b000000, SDA_U[15:11]}; \n  always @(posedge SDRD0) \n  begin \n  case (SDA_L) \n  0: RANGE_0 <= BANKSEL; \n  1: RANGE_1 <= BANKSEL; \n  2: RANGE_2 <= BANKSEL; \n  3: RANGE_3 <= BANKSEL; \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a four-digit seven-segment LED display. It takes input data and digit select signals, and drives the corresponding seven-segment display segments to show the desired numbers. The module also handles error signals related to the data and digit pulse. It uses a multiplexer to select the input data based on the digit select signals, and a separate multiplexer for the decimal point (dp) segment. The output from the multiplexers is then used to drive the seven-segment LED display to show the desired numbers. The module includes a clocked process and a reset control to manage the digit selection.\n\n Module header:\n\nmodule FourDigitSevenSegmentLED(clk,rst_x,i_data3,i_data2,i_data1,i_data0,i_dp3,i_dp2,i_dp1,i_dp0,o_a,o_b,o_c,o_d,o_e,o_f,o_g,o_dp,o_select,o_error);\n [/INST]\n", "output": "input clk; \n  input rst_x; \n  input [3:0] i_data3; \n  input [3:0] i_data2; \n  input [3:0] i_data1; \n  input [3:0] i_data0; \n  input i_dp3; \n  input i_dp2; \n  input i_dp1; \n  input i_dp0; \n  output o_a; \n  output o_b; \n  output o_c; \n  output o_d; \n  output o_e; \n  output o_f; \n  output o_g; \n  output o_dp; \n  output [3:0] o_select; \n  output o_error; \n  wire [3:0] w_data; \n  wire w_data_error; \n  wire w_dp_error; \n  reg [3:0] r_select; \n  assign o_select = r_select; \n  assign o_error = w_data_error | w_dp_error; \n  always @ (posedge clk or negedge rst_x) begin \n  if (!rst_x) begin \n  r_select <= 4'b1110; \n  end else begin \n  r_select <= { r_select[2:0], r_select[3] }; \n  end \n  end \n Multiplexer4 #(.width(4)) mux_data(.i_data0 (i_data0 ),.i_data1 (i_data1 ),.i_data2 (i_data2 ),.i_data3 (i_data3 ),.i_select0(!r_select[0]),.i_select1(!r_select[1]),.i_select2(!r_select[2]),.i_select3(!r_select[3]),.o_data (w_data ),.o_error (w_data_error)); \n Multiplexer4 mux_dp(.i_data0 (i_dp0 ),.i_data1 (i_dp1 ),.i_data2 (i_dp2 ),.i_data3 (i_dp3 ),.i_select0(!r_select[0]),.i_select1(!r_select[1]),.i_select2(!r_select[2]),.i_select3(!r_select[3]),.o_data (o_dp ),.o_error (w_dp_error )); \n SevenSegmentLED led(.i_data (w_data ),.o_a (o_a ),.o_b (o_b ),.o_c (o_c ),.o_d (o_d ),.o_e (o_e ),.o_f (o_f ),.o_g (o_g )); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a raised cosine receive filter. It takes in clock, reset, enable, and complex input data (real and imaginary parts), and outputs the filtered complex data (real and imaginary parts). The module instantiates an FIR decimation module and assigns its output to the module's output ports. The FIR decimation module filters the input data and provides the filtered real and imaginary parts as outputs.\n\n Module header:\n\nmodule Raised_Cosine_Receive_Filter (clk,reset,enb_1_1_1,In1_re,In1_im,Out1_re,Out1_im);\n [/INST]\n", "output": "input clk; \n  input reset; \n  input enb_1_1_1; \n  input signed [15:0] In1_re; \n  input signed [15:0] In1_im; \n  output signed [15:0] Out1_re; \n  output signed [15:0] Out1_im; \n  wire signed [15:0] FIR_Decimation_out1_re; \n  wire signed [15:0] FIR_Decimation_out1_im; \n FIR_Decimation u_FIR_Decimation (.clk(clk),.enb_1_1_1(enb_1_1_1),.reset(reset),.FIR_Decimation_in_re(In1_re),.FIR_Decimation_in_im(In1_im),.FIR_Decimation_out_re(FIR_Decimation_out1_re),.FIR_Decimation_out_im(FIR_Decimation_out1_im)); \n  assign Out1_re = FIR_Decimation_out1_re; \n  assign Out1_im = FIR_Decimation_out1_im; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module is a decoder for writing to specific registers based on the address and write signal. It generates a control signal, `EnableStart`, to indicate the start of the writing process and a 22-bit control signal `EnableRegister` to enable writing to a specific register based on the address and write signal. Each bit of `EnableRegister` corresponds to a specific register and is set to 1 if the corresponding address matches and the write signal is asserted, otherwise, it is set to 0.\n\n Module header:\n\nmodule DecoEscrituraRegistros(Address,Write,EnableStart,EnableRegister);\n [/INST]\n", "output": "input Write; \n  input [8:0] Address; \n  output [21:0] EnableRegister ; \n  output EnableStart; \n  assign EnableStart = (Address==9'h08C) ? 1'b1 : 1'b0 ; \n  assign EnableRegister[0] = (Address==9'h00C)&Write ? 1'b1 : 1'b0 ; \n  assign EnableRegister[1] = (Address==9'h010)&Write ? 1'b1 : 1'b0 ; \n  assign EnableRegister[2] = (Address==9'h014)&Write ? 1'b1 : 1'b0 ; \n  assign EnableRegister[3] = (Address==9'h018)&Write ? 1'b1 : 1'b0 ; \n  assign EnableRegister[4] = (Address==9'h01C)&Write ? 1'b1 : 1'b0 ; \n  assign EnableRegister[5] = (Address==9'h020)&Write ? 1'b1 : 1'b0 ; \n  assign EnableRegister[6] = (Address==9'h024)&Write ? 1'b1 : 1'b0 ; \n  assign EnableRegister[7] = (Address==9'h028)&Write ? 1'b1 : 1'b0 ; \n  assign EnableRegister[8] = (Address==9'h02C)&Write ? 1'b1 : 1'b0 ; \n  assign EnableRegister[9] = (Address==9'h030)&Write ? 1'b1 : 1'b0 ; \n  assign EnableRegister[10] = (Address==9'h034)&Write ? 1'b1 : 1'b0; \n  assign EnableRegister[11] = (Address==9'h038)&Write ? 1'b1 : 1'b0; \n  assign EnableRegister[12] = (Address==9'h03C)&Write ? 1'b1 : 1'b0; \n  assign EnableRegister[13] = (Address==9'h040)&Write ? 1'b1 : 1'b0; \n  assign EnableRegister[14] = (Address==9'h044)&Write ? 1'b1 : 1'b0; \n  assign EnableRegister[15] = (Address==9'h048)&Write ? 1'b1 : 1'b0; \n  assign EnableRegister[16] = (Address==9'h04C)&Write ? 1'b1 : 1'b0; \n  assign EnableRegister[17] = (Address==9'h050)&Write ? 1'b1 : 1'b0; \n  assign EnableRegister[18] = (Address==9'h054)&Write ? 1'b1 : 1'b0; \n  assign EnableRegister[19] = (Address==9'h058)&Write ? 1'b1 : 1'b0; \n  assign EnableRegister[20] = (Address==9'h05C)&Write ? 1'b1 : 1'b0; \n  assign EnableRegister[21] = (Address==9'h060)&Write ? 1'b1 : 1'b0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module instantiates a storage module and initializes the input signals. It then sequences through various combinations of input values and toggles the clock signal. The module effectively tests the behavior of the storage module under different input and clock signal conditions by observing the LED output.\n\n Module header:\n\nmodule TEST;\n [/INST]\n", "output": "reg [5:0] Mem_Addr; \n  reg [1:0] CS; \n  reg Mem_Write; \n  reg Clk; \n  wire [7:0] LED; \n TESTSTORAGE uut (.Mem_Addr(Mem_Addr),.CS(CS),.Mem_Write(Mem_Write),.Clk(Clk),.LED(LED)); \n  initial begin \n  Clk = 0; \n  Mem_Addr = 0; \n  CS = 0; \n  Mem_Write = 0; \n  #10; \n  Mem_Addr = 0; \n  CS = 1; \n  Mem_Write = 0; \n  #10; \n  Mem_Addr = 0; \n  CS = 2; \n  Mem_Write = 0; \n  #10; \n  Mem_Addr = 0; \n  CS = 3; \n  Mem_Write = 0; \n  #10; \n  Mem_Addr = 1; \n  CS = 0; \n  Mem_Write = 0; \n  #10; \n  Mem_Addr = 1; \n  CS = 1; \n  Mem_Write = 0; \n  #10; \n  Mem_Addr = 1; \n  CS = 2; \n  Mem_Write = 0; \n  #10; \n  Mem_Addr = 1; \n  CS = 3; \n  Mem_Write = 0; \n  #10; \n  end \n  always #1 Clk = ~Clk; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module COMPARE compares the input wptr and rptr and assigns the empty output when they are equal. It also calculates the full output based on the comparison. The module uses the parameters DEPTH and ALMOST_FULL to perform these comparisons. Additionally, the module contains an always block that triggers when full or empty changes, and it displays the current values of DEPTH, empty, and full.\n\n Module header:\n\nmodule COMPARE #(parameter DEPTH = 10, ALMOST_FULL = 4 ) (input [DEPTH:0] wptr, rptr,output wire empty, full);\n [/INST]\n", "output": "assign empty = (wptr[DEPTH:0] == rptr[DEPTH:0]); \n  assign full = (wptr[DEPTH] != rptr[DEPTH]) & (wptr[DEPTH-1: ALMOST_FULL] == rptr[DEPTH-1: ALMOST_FULL]); \n  always@(full or empty) begin \n  $display(\"current depth is %0d, current empty is %0d, current full is %0d\", DEPTH, empty, full); \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a digital display controller that takes in address, read/write signals, chip select, clock, reset, and control signals for multiplexing. It has a data register for writing and two separate data registers for reading. The module also interfaces with eight digital display modules to output data based on control signals. The module uses case statements to handle different conditions, such as setting the write data based on the chip select and read/write signals, and selecting the output data based on the address and chip select signals. The module also includes initialization of the write data and output assignment based on the control signals.\n\n Module header:\n\nmodule MAIN(Address, RW, CS, clk, Reset, AB, AN, dig);\n [/INST]\n", "output": "parameter SIZE = 5; \n  parameter LEDSIZE = 8; \n  input clk, Reset; \n  input [SIZE-1:0] Address; \n  input RW, AB; \n  input [1:0] CS; \n  output reg [7:0] dig; \n  output wire [3:0] AN; \n  reg [31:0] W_Data; \n  wire [31:0] R_Data_A, R_Data_B, LED_Data; \n  wire [63:0] Seg; \n  assign LED_Data = AB ? R_Data_A : R_Data_B; \n clock CL (.clock(clk),.AN(AN),.rst(Reset)); \n register instance_name (.clk(clk),.Reset(Reset),.R_Addr_A(Address),.R_Addr_B(Address),.W_Addr(Address),.W_Data(W_Data),.Write_Reg(RW),.R_Data_A(R_Data_A),.R_Data_B(R_Data_B)); \n DIGITAL D1 (.Data(LED_Data[3:0]),.Seg(Seg[7:0])); \n DIGITAL D2 (.Data(LED_Data[7:4]),.Seg(Seg[15:8])); \n DIGITAL D3 (.Data(LED_Data[11:8]),.Seg(Seg[23:16])); \n DIGITAL D4 (.Data(LED_Data[15:12]),.Seg(Seg[31:24])); \n DIGITAL D5 (.Data(LED_Data[19:16]),.Seg(Seg[39:32])); \n DIGITAL D6 (.Data(LED_Data[23:20]),.Seg(Seg[47:40])); \n DIGITAL D7 (.Data(LED_Data[27:24]),.Seg(Seg[55:48])); \n DIGITAL D8 (.Data(LED_Data[31:28]),.Seg(Seg[63:56])); \n  always @(*) \n  begin \n  W_Data=32'h0000_0000; \n  dig <= 8'b01110001; \n  if(RW) \n  begin \n  case(CS) \n  2'b00: W_Data= 32'h1234_5678; \n  2'b01: W_Data= 32'h89AB_CDEF; \n  2'b10: W_Data= 32'h7FFF_FFFF; \n  2'b11: W_Data= 32'hFFFF_FFFF; \n  endcase \n  end \n  else \n  begin \n  if (CS==2'b00) \n  begin \n  case(AN) \n  4'b0111:dig[7:0] <= Seg[7:0]; \n  4'b1011:dig[7:0] <= Seg[15:8]; \n  4'b1101:dig[7:0] <= Seg[23:16]; \n  4'b1110:dig[7:0] <= Seg[31:24]; \n  default: dig[7:0] <= Seg[7:0]; \n  endcase \n  end \n  else \n  begin \n  case(AN) \n  4'b0111:dig[7:0] <= Seg[39:32]; \n  4'b1011:dig[7:0] <= Seg[47:40]; \n  4'b1101:dig[7:0] <= Seg[55:48]; \n  4'b1110:dig[7:0] <= Seg[63:56]; \n  default: dig[7:0] <= Seg[7:0]; \n  endcase \n  end \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an altpriority encoder that takes an 8-bit input data and outputs a 3-bit q. It contains two sub-modules: altpriority_encoder31 and altpriority_encoder32. The altpriority_encoder31 processes the lower 4 bits of the input data and produces a 2-bit output, while the altpriority_encoder32 processes the upper 4 bits and produces another 2-bit output. The module then combines the outputs of the two sub-modules using logical operations to produce the final 3-bit output q.\n\n Module header:\n\nmodule acl_fp_add_altpriority_encoder_v28 (data,q) ;\n [/INST]\n", "output": "input [7:0] data; \n  output [2:0] q; \n  wire [1:0] wire_altpriority_encoder31_q; \n  wire wire_altpriority_encoder31_zero; \n  wire [1:0] wire_altpriority_encoder32_q; \n  acl_fp_add_altpriority_encoder_qh8 altpriority_encoder31 \n (.data(data[3:0]),.q(wire_altpriority_encoder31_q),.zero(wire_altpriority_encoder31_zero)); \n  acl_fp_add_altpriority_encoder_q28 altpriority_encoder32 \n (.data(data[7:4]),.q(wire_altpriority_encoder32_q)); \n  assign \n  q = {wire_altpriority_encoder31_zero, (({2{wire_altpriority_encoder31_zero}} & wire_altpriority_encoder32_q) | ({2{(~ wire_altpriority_encoder31_zero)}} & wire_altpriority_encoder31_q))}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"seqPortAlloc\" takes in a number of flits and a vector of available ports, and allocates the flits to the available ports based on certain conditions. It generates the allocated port vector and an updated available port vector. The module also calculates the number of flits remaining after allocation. The allocation process is carried out in stages and is driven by a series of assignments based on the input conditions and previous allocations. Finally, the allocated port vector, available port vector, and the remaining number of flits are determined and output by the module.\n\n Module header:\n\nmodule seqPortAlloc(numFlit_in,availPortVector_in,ppv,allocatedPortVector,availPortVector_out,numFlit_out);\n [/INST]\n", "output": "input [`PC_INDEX_WIDTH-1:0] numFlit_in; \n  input [`NUM_PORT-2:0] availPortVector_in, ppv; \n  output [`NUM_PORT-2:0] allocatedPortVector, availPortVector_out; \n  output [`PC_INDEX_WIDTH-1:0] numFlit_out; \n  wire [`PC_INDEX_WIDTH-1:0] numFlit [`NUM_PORT-1:0]; \n  wire [`NUM_PORT-2:0] allocatedPortVector_st1, availPortVector_out_st1; \n  wire [`NUM_PORT-2:0] allocatedPortVector_st2, availPortVector_out_st2; \n  assign numFlit[0] = numFlit_in; \n  genvar i; \n  generate \n  for (i=0; i<`NUM_PORT-1; i=i+1) begin : productiveAlloc \n  assign allocatedPortVector_st1[i] = ppv[i] && availPortVector_in[i] && (numFlit[i] <= `NUM_PORT-1); \n  assign numFlit[i+1] = numFlit[i] + allocatedPortVector_st1[i]; \n  assign availPortVector_out_st1[i] = availPortVector_in[i] && ~allocatedPortVector_st1[i]; \n  end \n  endgenerate \n  assign allocatedPortVector_st2[0] = availPortVector_out_st1[0]; \n  assign allocatedPortVector_st2[1] = availPortVector_out_st1[1] && ~availPortVector_out_st1[0]; \n  assign allocatedPortVector_st2[2] = availPortVector_out_st1[2] && ~availPortVector_out_st1[1] && ~availPortVector_out_st1[0]; \n  assign allocatedPortVector_st2[3] = availPortVector_out_st1[3] && ~availPortVector_out_st1[2] && ~availPortVector_out_st1[1] && ~availPortVector_out_st1[0]; \n  assign availPortVector_out_st2 [0] = 1'b0; \n  assign availPortVector_out_st2 [1] = availPortVector_out_st1[0] && availPortVector_out_st1[1]; \n  assign availPortVector_out_st2 [2] = |availPortVector_out_st1[1:0] && availPortVector_out_st1[2]; \n  assign availPortVector_out_st2 [3] = |availPortVector_out_st1[2:0] && availPortVector_out_st1[3]; \n  wire get_port_st1; \n  assign get_port_st1 = |allocatedPortVector_st1; \n  assign allocatedPortVector = (~|ppv || get_port_st1) ? allocatedPortVector_st1 : allocatedPortVector_st2; \n  assign availPortVector_out = (~|ppv || get_port_st1) ? availPortVector_out_st1 : availPortVector_out_st2; \n  assign numFlit_out = (~|ppv || get_port_st1) ? numFlit[`NUM_PORT-1] : numFlit[`NUM_PORT-1] + 1'b1; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements an AXI protocol converter for the address channel. It translates the signals of the slave interface (s_) to those of the master interface (m_) according to the AXI protocol. It handles the conversion of address-related signals like ID, address, length, and burst type. The internal logic includes a translator, a command FSM, and updates the slave ID and length based on the incoming signals. The outputs of this module include various control signals for managing the address translation process such as ready signals, push signals, and burst completion signals.\n\n Module header:\n\nmodule axi_protocol_converter_v2_1_b2s_aw_channel # (parameter integer C_ID_WIDTH = 4,parameter integer C_AXI_ADDR_WIDTH = 32) (input wire clk ,input wire reset ,input wire [C_ID_WIDTH-1:0] s_awid ,input wire [C_AXI_ADDR_WIDTH-1:0] s_awaddr ,input wire [7:0] s_awlen ,input wire [2:0] s_awsize ,input wire [1:0] s_awburst ,input wire s_awvalid ,output wire s_awready ,output wire m_awvalid ,output wire [C_AXI_ADDR_WIDTH-1:0] m_awaddr ,input wire m_awready ,output wire b_push ,output wire [C_ID_WIDTH-1:0] b_awid ,output wire [7:0] b_awlen ,input wire b_full);\n [/INST]\n", "output": "wire next ; \n wire next_pending ; \n wire a_push; \n wire incr_burst; \n reg [C_ID_WIDTH-1:0] s_awid_r; \n reg [7:0] s_awlen_r; \n axi_protocol_converter_v2_1_b2s_cmd_translator # \n (.C_AXI_ADDR_WIDTH ( C_AXI_ADDR_WIDTH )) \n cmd_translator_0 \n (.clk ( clk ) ,.reset ( reset ) ,.s_axaddr ( s_awaddr ) ,.s_axlen ( s_awlen ) ,.s_axsize ( s_awsize ) ,.s_axburst ( s_awburst ) ,.s_axhandshake ( s_awvalid & a_push ) ,.m_axaddr ( m_awaddr ) ,.incr_burst ( incr_burst ) ,.next ( next ) ,.next_pending ( next_pending )); \n axi_protocol_converter_v2_1_b2s_wr_cmd_fsm aw_cmd_fsm_0 \n (.clk ( clk ) ,.reset ( reset ) ,.s_awready ( s_awready ) ,.s_awvalid ( s_awvalid ) ,.m_awvalid ( m_awvalid ) ,.m_awready ( m_awready ) ,.next ( next ) ,.next_pending ( next_pending ) ,.b_push ( b_push ) ,.b_full ( b_full ) ,.a_push ( a_push )); \n assign b_awid = s_awid_r; \n assign b_awlen = s_awlen_r; \n always @(posedge clk) begin \n  s_awid_r <= s_awid ; \n  s_awlen_r <= s_awlen ; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module is a 2-to-1 multiplexer with a configurable bit width. It takes in two inputs, inA and inB, and a select signal, and outputs the selected input on the out signal. The width of the inputs and output is determined by the WIDTH parameter. Inside the module, an always block is sensitive to changes in inA, inB, and select. Depending on the value of select, the output out is assigned the value of inA or inB using a case statement. If select is 0, out is assigned the value of inA, and if select is 1, out is assigned the value of inB. If select has a different value, the default behavior is to assign the value of inA to out.\n\n Module header:\n\nmodule mux2to1 #(parameter WIDTH = 1) (input wire [WIDTH - 1:0] inA,input wire [WIDTH - 1:0] inB,input wire select,output reg [WIDTH - 1:0] out);\n [/INST]\n", "output": "always @(inA, inB, select) begin \n  case(select) \n  0 : out = inA; \n  1 : out = inB; \n  default: out = inA; \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a generic input module with a configurable width, default value, and debug mode. It includes tasks for turning on, off, pushing, and toggling the state, each of which includes the option to display the state change and set the state with a default value. The state is updated based on the input and default value, and a push task includes a delay based on the push delay parameter.\n\n Module header:\n\nmodule generic_input #(parameter IW = 1,parameter PD = 10,parameter DS = 1'b0,parameter DBG = 0)(output wire [ IW-1:0] o);\n [/INST]\n", "output": "reg [ IW-1:0] state = {IW{DS}}; \n assign o = state; \n task on; \n input [ IW-1:0] i; \n begin \n  if (DBG) $display (\"BENCH : %M : %t : changing state from [%b] to [%b].\", $time, state, (DS ? i & state : i | state)); \n  state <= #1 DS ? i & state : i | state; \n end \n endtask \n task off; \n input [ IW-1:0] i; \n begin \n  if (DBG) $display (\"BENCH : %M : %t : changing state from [%b] to [%b].\", $time, state, (DS ? i | state : i & state)); \n  state <= #1 DS ? i | state : i & state; \n end \n endtask \n task push; \n input [ IW-1:0] i; \n begin \n  if (DBG) $display (\"BENCH : %M : %t : changing state from [%b] to [%b].\", $time, state, (i ^ state)); \n  state = #1 i ^ state; \n  #PD; \n  if (DBG) $display (\"BENCH : %M : %t : changing state from [%b] to [%b].\", $time, state, (i ^ state)); \n  state = #1 i ^ state; \n end \n endtask \n task toggle; \n input [ IW-1:0] i; \n begin \n  if (DBG) $display (\"BENCH : %M : %t : changing state from [%b] to [%b].\", $time, state, (i ^ state)); \n  state = #1 i ^ state; \n end \n endtask \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an interface for controlling and interacting with an \"avalanche_entropy_core.\" It includes address definitions and control signals for enabling, and provides access to various internal registers and data. The module handles read and write operations based on the address and control signals such as cs, we, and address. It also interfaces with the avalanche_entropy_core module to exchange data and control signals. The module uses internal signals like tmp_read_data, tmp_error, enable_reg, enable_new, and delta to manage the read and write operations, and also handles the reset condition. Additionally, it implements the logic for setting and updating various registers based on the address and control signals.\n\n Module header:\n\nmodule avalanche_entropy(input wire clk,input wire reset_n,input wire noise,input wire cs,input wire we,input wire [7 : 0] address,input wire [31 : 0] write_data,output wire [31 : 0] read_data,output wire error,input wire discard,input wire test_mode,output wire security_error,output wire entropy_enabled,output wire [31 : 0] entropy_data,output wire entropy_valid,input wire entropy_ack,output wire [7 : 0] debug,input wire debug_update);\n [/INST]\n", "output": "parameter ADDR_NAME0 = 8'h00; \n  parameter ADDR_NAME1 = 8'h01; \n  parameter ADDR_VERSION = 8'h02; \n  parameter ADDR_CTRL = 8'h10; \n  parameter CTRL_ENABLE_BIT = 0; \n  parameter ADDR_STATUS = 8'h11; \n  parameter STATUS_ENABLE_VALID_BIT = 0; \n  parameter ADDR_ENTROPY = 8'h20; \n  parameter ADDR_DELTA = 8'h30; \n  parameter CORE_NAME0 = 32'h6578746e; \n  parameter CORE_NAME1 = 32'h6f697365; \n  parameter CORE_VERSION = 32'h302e3130; \n  reg enable_reg; \n  reg enable_new; \n  reg enable_we; \n  wire [31 : 0] delta; \n  reg [31 : 0] tmp_read_data; \n  reg tmp_error; \n  assign read_data = tmp_read_data; \n  assign error = tmp_error; \n  assign security_error = 0; \n  assign entropy_enabled = enable_reg; \n avalanche_entropy_core core(.clk(clk),.reset_n(reset_n),.noise(noise),.enable(enable_reg),.entropy_data(entropy_data),.entropy_valid(entropy_valid),.entropy_ack(entropy_ack),.delta(delta),.debug(debug),.debug_update(debug_update)); \n  always @ (posedge clk or negedge reset_n) \n  begin \n  if (!reset_n) \n  begin \n  enable_reg <= 1; \n  end \n  else \n  begin \n  if (enable_we) \n  begin \n  enable_reg <= enable_new; \n  end \n  end \n  end \n  always @* \n  begin : api_logic \n  tmp_read_data = 32'h00000000; \n  tmp_error = 1'b0; \n  enable_new = 0; \n  enable_we = 0; \n  if (cs) \n  begin \n  if (we) \n  begin \n  case (address) \n  ADDR_CTRL: \n  begin \n  enable_new = write_data[CTRL_ENABLE_BIT]; \n  enable_we = 1; \n  end \n  default: \n  begin \n  tmp_error = 1; \n  end \n  endcase \n  end \n  else \n  begin \n  case (address) \n  ADDR_NAME0: \n  begin \n  tmp_read_data = CORE_NAME0; \n  end \n  ADDR_NAME1: \n  begin \n  tmp_read_data = CORE_NAME1; \n  end \n  ADDR_VERSION: \n  begin \n  tmp_read_data = CORE_VERSION; \n  end \n  ADDR_CTRL: \n  begin \n  tmp_read_data = {31'h00000000, enable_reg}; \n  end \n  ADDR_STATUS: \n  begin \n  tmp_read_data = {31'h00000000, entropy_valid}; \n  end \n  ADDR_ENTROPY: \n  begin \n  tmp_read_data = entropy_data; \n  end \n  ADDR_DELTA: \n  begin \n  tmp_read_data = delta; \n  end \n  default: \n  begin \n  tmp_error = 1; \n  end \n  endcase \n  end \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"SendP2SBufferTestbench\" initializes and instantiates the DE1_SoC module, using CLOCK_50, LEDR, SW, and KEY as inputs. The parameter \"d\" is set to 20, and the initial block initializes CLOCK_50 to 1, SW to 12, and KEY to 0. The CLOCK_50 is toggled every d/2 clock cycles, and the SW[9] is manipulated at specific intervals. Finally, SW[5:0] is set to various values before the simulation stops.\n\n Module header:\n\nmodule SendP2SBufferTestbench();\n [/INST]\n", "output": "reg CLOCK_50; \n  wire [9:0] LEDR; \n  reg [9:0] SW; \n  reg [3:0] KEY; \n  DE1_SoC dut (CLOCK_50, LEDR, SW, KEY); \n  parameter d = 20; \n  initial begin \n  CLOCK_50 = 1; \n  SW = 12; \n  KEY = 0; \n  end \n  always #(d/2) CLOCK_50 = ~CLOCK_50; \n  initial begin \n  #(d*10); SW[9] = 1; \n  #d; SW[9] = 0; SW[8] = 1; \n  #(d*500); SW[8] = 0; \n  #d SW[5:0] = 64; \n  #d SW[5:0] = 32; \n  #d SW[5:0] = 16; \n  #d SW[5:0] = 8; \n  #d SW[5:0] = 120; \n  $stop; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a block RAM with read and write functionality. It uses two clocks, wr_clk and rd_clk, to control write and read operations. The write enable wr_en, write address wr_addr, and write data wr_data are used to write data into the block RAM. The read address rd_addr is used to specify which data to read, and the output rd_data provides the read data. The block RAM is instantiated using the BRAM_SDP_MACRO module, which includes parameters for the BRAM size, device, data width, and initialization settings. The BRAM_SDP_MACRO_inst instance connects the input and output signals to the block RAM module. The internal signal DO is assigned the value of the read data based on the read address.\n\n Module header:\n\nmodule vga_block_ram (input wr_clk,input wr_en,input [5:0] wr_addr,input [31:0] wr_data,input rd_clk,input [7:0] rd_addr,output [7:0] rd_data);\n [/INST]\n", "output": "wire [31:0] DO; \n  assign rd_data = DO[{rd_addr[1:0], 3'b0}+:8]; \n  BRAM_SDP_MACRO \n #(.BRAM_SIZE(\"9Kb\"),.DEVICE(\"SPARTAN6\"),.WRITE_WIDTH(32),.READ_WIDTH(32),.DO_REG(0),.INIT_FILE(\"NONE\"),.SRVAL(72'b0),.INIT(72'b0)) \n  BRAM_SDP_MACRO_inst \n (.DO(DO),.DI(wr_data),.RDADDR({ 2'b0, rd_addr[7:2] }),.RDCLK(rd_clk),.RDEN(1'b1),.REGCE(REGCE),.RST(1'b0),.WE(4'b1111),.WRADDR({ 2'b0, wr_addr }),.WRCLK(wr_clk),.WREN(wr_en)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `lab6_prev_1` is a PS2 keyboard interface that receives clock and data signals from a PS2 keyboard and outputs various control signals to indicate the type of data received. It also detects the \"Enter\" key press and generates an output signal accordingly.\n\nThe module instantiates a `kbd_ms` module for processing PS2 keyboard data and generating `data_type` and `kbs_tot` signals. It also includes a clock divider to generate a clock signal.\n\nThe module contains registers and wires for various signals such as `m`, `b`, `data_type`, and `is_enter` to control the behavior of the PS2 keyboard interface. It sets the values of `m` and `b` based on the `data_type` and detects the \"Enter\" key press to set `is_enter` accordingly.\n\nThe PS2 clock and data signals are assigned to `JA1` and `JA2` respectively, while other control signals `JA3`, `JA4`, `JA7`, and `JA8` are assigned based on the values of `m`, `b`, and other internal signals.\n\nThe module also includes a reset signal, `reset`, and a clock signal, `clock`, for internal use.\n\n Module header:\n\nmodule lab6_prev_1(input CLK100MHZ,input PS2_CLK,input PS2_DATA,output JA1,JA2,JA3,JA4,JA7,JA8,input CPU_RESETN);\n [/INST]\n", "output": "wire reset; \n wire clock; \n reg [1:0]m,b; \n wire [2:0] data_type; \n wire [7:0] data; \n wire kbs_tot; \n reg is_enter; \n assign JA1= PS2_CLK; \n assign JA2= PS2_DATA; \n assign JA7 =m; \n assign JA4 =b; \n assign JA3= kbs_tot; \n assign JA8=is_enter; \n always @(*) begin \n  if (data_type ==3'b001) begin \n  m=1'b1; \n  b=1'b0; \n  end \n  else if (data_type ==3'b010) begin \n  m=1; \n  b=0; \n  end \n  else if (data_type ==3'b011) begin \n  m=0; \n  b=1; \n  end \n  else if (data_type ==3'b100) begin \n  m=0; \n  b=1; \n  end \n  else begin \n  m=0; \n  b=0; \n  end \n end \n always @(*)begin \n if (data==7'h5A)begin \n is_enter=1; \n end \n else begin \n is_enter=0; \n end \n end \n kbd_ms inst_kbd_ms(.clk (CLK100MHZ),.rst (reset),.kd (PS2_DATA),.kc (PS2_CLK),.new_data (data),.data_type (data_type),.kbs_tot (kbs_tot),.parity_error ()); \n assign reset = ~CPU_RESETN; \n clock_divider inst_clock_divider(.clk(CLK100MHZ),.rst(reset),.clk_div(clock)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module, \"sky130_fd_sc_hdll__sdlclkp,\" implements a clock gating logic for the GCLK output based on several input signals. It contains various logic gates and a D latch to generate the GCLK output. The module also includes delay elements for the input signals and control logic to handle power and ground conditions for proper functionality.\n\n Module header:\n\nmodule sky130_fd_sc_hdll__sdlclkp (GCLK,SCE ,GATE,CLK ,VPWR,VGND,VPB ,VNB);\n [/INST]\n", "output": "output GCLK; \n  input SCE ; \n  input GATE; \n  input CLK ; \n  input VPWR; \n  input VGND; \n  input VPB ; \n  input VNB ; \n  wire m0 ; \n  wire m0n ; \n  wire clkn ; \n  wire CLK_delayed ; \n  wire SCE_delayed ; \n  wire GATE_delayed ; \n  wire SCE_gate_delayed; \n  reg notifier ; \n  wire awake ; \n  wire SCE_awake ; \n  wire GATE_awake ; \n  not not0 (m0n , m0 ); \n  not not1 (clkn , CLK_delayed ); \n  nor nor0 (SCE_gate_delayed, GATE_delayed, SCE_delayed ); \n  sky130_fd_sc_hdll__udp_dlatch$P_pp$PG$N dlatch0 (m0 , SCE_gate_delayed, clkn, notifier, VPWR, VGND); \n  and and0 (GCLK , m0n, CLK_delayed ); \n  assign awake = ( VPWR === 1'b1 ); \n  assign SCE_awake = ( awake & ( GATE_delayed === 1'b0 ) ); \n  assign GATE_awake = ( awake & ( SCE_delayed === 1'b0 ) ); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a 2:1 multiplexer using UDP (User-Defined Primitive). It has two input ports A and B, a select signal S, and an output port O. The select signal S determines whether the output O is connected to input A or B. The output O is computed based on the logic expression ((not A and not S) or (not B and S)).\n\n Module header:\n\nmodule UDP_MUX21(O_, A,B, S);\n [/INST]\n", "output": "output O_; \n input A, B, S; \n  assign O_ = ((~A && ~S) || (~B && S)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module consists of two flip-flops that capture the input signal d at the rising edge of clk1 and capture the value of q1 at the falling edge of clk2, storing it in q2.\n\n Module header:\n\nmodule abc9_test031(input clk1, clk2, d, output reg q1, q2);\n [/INST]\n", "output": "always @(posedge clk1) q1 <= d; \n always @(negedge clk2) q2 <= q1; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"constant_9e0724a33a\" generates a constant output \"op\" with the value 2'b00. The output remains constant and independent of the input signals \"clk\", \"ce\", and \"clr\".\n\n Module header:\n\nmodule constant_9e0724a33a (output [(2 - 1):0] op,input clk,input ce,input clr);\n [/INST]\n", "output": "localparam [(2 - 1):0] const_value = 2'b00; \n  assign op = 2'b00; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes a 14-bit binary input and converts it to four separate BCD (Binary-Coded Decimal) outputs representing ones, tens, hundreds, and thousands. The module uses a series of add3 sub-modules to perform the conversion, and the resulting BCD outputs are assigned to the respective outputs: ones, tens, hundreds, and thousands.\n\n Module header:\n\nmodule binary_to_BCD_fourteen_bit(input [13:0] in,output [3:0] ones,output [3:0] tens,output [3:0] hundreds,output [3:0] thousands);\n [/INST]\n", "output": "wire [3:0] c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,c19,c20,c21,c22,c23,c24,c25; \n wire [3:0] d1,d2,d3,d4,d5,d6,d7,d8,d9,d10,d11,d12,d13,d14,d15,d16,d17,d18,d19,d20,d21,d22,d23,d24,d25; \n assign d1 = {1'b0,in[13:11]}; \n assign d2 = {c1[2:0],in[10]}; \n assign d3 = {c2[2:0],in[9]}; \n assign d4 = {1'b0,c1[3],c2[3],c3[3]}; \n assign d5 = {c3[2:0],in[8]}; \n assign d6 = {c4[2:0],c5[3]}; \n assign d7 = {c5[2:0],in[7]}; \n assign d8 = {c6[2:0],c7[3]}; \n assign d9 = {c7[2:0],in[6]}; \n assign d10 = {1'b0,c4[3],c6[3],c8[3]}; \n assign d11 = {c8[2:0],c9[3]}; \n assign d12 = {c9[2:0],in[5]}; \n assign d13 = {c10[2:0],c11[3]}; \n assign d14 = {c11[2:0],c12[3]}; \n assign d15 = {c12[2:0],in[4]}; \n assign d16 = {c13[2:0],c14[3]}; \n assign d17 = {c14[2:0],c15[3]}; \n assign d18 = {c15[2:0],in[3]}; \n assign d19 = {c16[2:0],c17[3]}; \n assign d20 = {c17[2:0],c18[3]}; \n assign d21 = {c18[2:0],in[2]}; \n assign d22 = {c10[3],c13[3],c16[3],c19[3]}; \n assign d23 = {c19[2:0],c20[3]}; \n assign d24 = {c20[2:0],c21[3]}; \n assign d25 = {c21[2:0],in[1]}; \n add3 m1(d1,c1); \n add3 m2(d2,c2); \n add3 m3(d3,c3); \n add3 m4(d4,c4); \n add3 m5(d5,c5); \n add3 m6(d6,c6); \n add3 m7(d7,c7); \n add3 m8(d8,c8); \n add3 m9(d9,c9); \n add3 m10(d10,c10); \n add3 m11(d11,c11); \n add3 m12(d12,c12); \n add3 m13(d13,c13); \n add3 m14(d14,c14); \n add3 m15(d15,c15); \n add3 m16(d16,c16); \n add3 m17(d17,c17); \n add3 m18(d18,c18); \n add3 m19(d19,c19); \n add3 m20(d20,c20); \n add3 m21(d21,c21); \n add3 m22(d22,c22); \n add3 m23(d23,c23); \n add3 m24(d24,c24); \n add3 m25(d25,c25); \n assign ones = {c25[2:0],in[0]}; \n assign tens = {c24[2:0],c25[3]}; \n assign hundreds = {c23[2:0],c24[3]}; \n assign thousands ={c22[2:0],c23[3]}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a FIFO (First-In-First-Out) memory unit. It has inputs for clock, reset, data in, enable enqueue, dequeue, and clear, as well as outputs for full, data out, and empty. It maintains a register for the output data and an empty register. The module updates the empty register based on the enqueue, dequeue, clear, and reset inputs. The output data is updated on the positive edge of the clock when the enqueue input is asserted. Additionally, it performs error checks for dequeuing from an empty FIFO and enqueuing to a full FIFO.\n\n Module header:\n\nmodule FIFO1(CLK,RST_N,D_IN,ENQ,FULL_N,D_OUT,DEQ,EMPTY_N,CLR);\n [/INST]\n", "output": "parameter width = 1; \n  parameter guarded = 1; \n  input CLK; \n  input RST_N; \n  input [width - 1 : 0] D_IN; \n  input ENQ; \n  input DEQ; \n  input CLR ; \n  output FULL_N; \n  output [width - 1 : 0] D_OUT; \n  output EMPTY_N; \n  reg [width - 1 : 0] D_OUT; \n  reg empty_reg ; \n  assign EMPTY_N = empty_reg ; \n `ifdef BSV_NO_INITIAL_BLOCKS \n `else \n  initial \n  begin \n  D_OUT = {((width + 1)/2) {2'b10}} ; \n  empty_reg = 1'b0 ; \n  end \n `endif \n  assign FULL_N = !empty_reg; \n  always@(posedge CLK ) \n  begin \n  if (!RST_N) \n  begin \n  empty_reg <= `BSV_ASSIGNMENT_DELAY 1'b0; \n  end \n  else \n  begin \n  if (CLR) \n  begin \n  empty_reg <= `BSV_ASSIGNMENT_DELAY 1'b0; \n  end \n  else if (ENQ) \n  begin \n  empty_reg <= `BSV_ASSIGNMENT_DELAY 1'b1; \n  end \n  else if (DEQ) \n  begin \n  empty_reg <= `BSV_ASSIGNMENT_DELAY 1'b0; \n  end \n  end \n  end \n  always@(posedge CLK ) \n  begin \n  begin \n  if (ENQ) \n  D_OUT <= `BSV_ASSIGNMENT_DELAY D_IN; \n  end \n  end \n  always@(posedge CLK) \n  begin: error_checks \n  reg deqerror, enqerror ; \n  deqerror = 0; \n  enqerror = 0; \n  if ( RST_N ) \n  begin \n  if ( ! empty_reg && DEQ ) \n  begin \n  deqerror = 1 ; \n  $display( \"Warning: FIFO1: %m -- Dequeuing from empty fifo\" ) ; \n  end \n  if ( ! FULL_N && ENQ && (!DEQ || guarded) ) \n  begin \n  enqerror = 1 ; \n  $display( \"Warning: FIFO1: %m -- Enqueuing to a full fifo\" ) ; \n  end \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a USB reset detection circuit. It uses a counter (cntr) that decrements on each clock cycle if the se0 signal is active and the usb_rst signal is not asserted. The usb_rst signal is generated when the counter reaches zero. The counter is reset to a value of 480000 when the se0 signal is not active. Additionally, the counter is asynchronously reset to 0 when the reset signal (rst_n) is low.\n\n Module header:\n\nmodule usb_reset_detect(input rst_n,input clk,input se0,output usb_rst);\n [/INST]\n", "output": "reg[18:0] cntr; \n assign usb_rst = cntr == 1'b0; \n always @(posedge clk or negedge rst_n) begin \n  if (!rst_n) begin \n  cntr <= 1'b0; \n  end else begin \n  if (se0) begin \n  if (!usb_rst) \n  cntr <= cntr - 1'b1; \n  end else begin \n  cntr <= 19'd480000; \n  end \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a multiplexer (MUX) with 4 data inputs and 2 select inputs. It selects one of the input data based on the select signal and assigns it to the output. The output is registered, and its value changes in response to changes in the select input. If the select value is not valid, the output is set to 0.\n\n Module header:\n\nmodule mux (in0,in1,in2,in3, sel, out);\n [/INST]\n", "output": "input wire [7:0] in0,in1,in2,in3; \n  input wire [1:0] sel; \n  output reg [7:0] out; \n  always @ (*) \n  begin \n  case (sel) \n  0: out<=in0; \n  1: out<=in1; \n  2: out<=in2; \n  3: out<=in3; \n  default: out<=0; \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, named r_DEVICE_CAPABILITIES_1_HIGH, contains a register reg_0x25 with a width of 8 bits. It has a reset input, a write enable input, an input data bus of width 8 bits, and a clock input. On the positive edge of the clock, the module checks for a reset condition. If reset is asserted, it resets the register to its default value. If reset is not asserted, it checks the write enable signal. If write enable is low, it writes the input data to the register. If write enable is high, it retains the previous value of the register. If the module is not in a reset state, the register is always set to a default value of 8'h00.\n\n Module header:\n\nmodule r_DEVICE_CAPABILITIES_1_HIGH(output reg [7:0] reg_0x25, input wire reset, input wire wenb, input wire [7:0] in_data, input wire clk);\n [/INST]\n", "output": "always@(posedge clk) \n  begin \n  if(reset==0) begin \n  if(wenb==0) \n  reg_0x25<=in_data; \n  else \n  reg_0x25<=reg_0x25; \n  end \n  else \n  reg_0x25<=8'h00; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements an alternative priority encoder for 8-bit input data. It uses two instances of a sub-alternative priority encoder, each handling 4 bits of the input data. The outputs of these two sub-encoders are combined using a bitwise OR operation to produce a 3-bit output q.\n\n Module header:\n\nmodule fp_sub_altpriority_encoder_v28 (data,q) ;\n [/INST]\n", "output": "input [7:0] data; \n  output [2:0] q; \n  wire [1:0] wire_altpriority_encoder39_q; \n  wire wire_altpriority_encoder39_zero; \n  wire [1:0] wire_altpriority_encoder40_q; \n  fp_sub_altpriority_encoder_qh8 altpriority_encoder39 \n (.data(data[3:0]),.q(wire_altpriority_encoder39_q),.zero(wire_altpriority_encoder39_zero)); \n  fp_sub_altpriority_encoder_q28 altpriority_encoder40 \n (.data(data[7:4]),.q(wire_altpriority_encoder40_q)); \n  assign \n  q = {wire_altpriority_encoder39_zero, (({2{wire_altpriority_encoder39_zero}} & wire_altpriority_encoder40_q) | ({2{(~ wire_altpriority_encoder39_zero)}} & wire_altpriority_encoder39_q))}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module generates a stall signal for an NKMD CPU sequence based on the inputs rf_regn_is_zero_i and dcd_repn_i. The stall signal is set when dcd_repn_i is high and rf_regn_is_zero_i is low. It then outputs this stall signal to both if_stop_inc_pc_o and dcd_latch_curr_output_o.\n\n Module header:\n\nmodule nkmd_cpu_seq(input wire rf_regn_is_zero_i,input wire dcd_repn_i,output wire if_stop_inc_pc_o,output wire dcd_latch_curr_output_o);\n [/INST]\n", "output": "wire stall = (dcd_repn_i == 1'b1) && (rf_regn_is_zero_i == 1'b0); \n assign if_stop_inc_pc_o = stall; \n assign dcd_latch_curr_output_o = stall; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a dual-port RAM with byte enables. It contains two ports for reading and writing data, with individual clock and control signals. The module also includes a memory array, registers, and logic to manage data reads, writes, and byte enables. The module supports simultaneous read and write operations, and includes support for byte-wide data writes and reads.\n\n Module header:\n\nmodule ram_dp_be (clka ,cena_i ,oena_i ,wena_i ,addra_i ,dataa_o ,dataa_i ,clkb ,cenb_i ,oenb_i ,wenb_i ,addrb_i ,datab_o ,datab_i);\n [/INST]\n", "output": "parameter Word_Width=32; \n parameter Addr_Width=8; \n localparam Byte_Width=(Word_Width>>3); \n input clka; \n input cena_i; \n input oena_i; \n input [Byte_Width-1:0] wena_i; \n input [Addr_Width-1:0] addra_i; \n input [Word_Width-1:0] dataa_i; \n output [Word_Width-1:0] dataa_o; \n input clkb; \n input cenb_i; \n input oenb_i; \n input [Byte_Width-1:0] wenb_i; \n input [Addr_Width-1:0] addrb_i; \n input [Word_Width-1:0] datab_i; \n output [Word_Width-1:0] datab_o; \n reg [Word_Width-1:0] mem_array[(1<<Addr_Width)-1:0]; \n reg [Word_Width-1:0] dataa_r; \n reg [Word_Width-1:0] datab_r; \n reg [Word_Width-1:0] dataa_w; \n reg [Word_Width-1:0] datab_w; \n wire [Word_Width-1:0] dataa_m; \n wire [Word_Width-1:0] datab_m; \n assign dataa_m = mem_array[addra_i]; \n genvar i; \n generate \n  for (i=0; i<Byte_Width; i=i+1) begin:i_n \n  always@(*) begin \n  dataa_w[(i+1)*8-1:i*8] = wena_i[i] ? dataa_m[(i+1)*8-1:i*8] : dataa_i[(i+1)*8-1:i*8]; \n  end \n  end \n endgenerate \n always @(posedge clka) begin \n  if(!cena_i && !(&wena_i)) \n  mem_array[addra_i] <= dataa_w; \n end \n always @(posedge clka) begin \n  if (!cena_i && wena_i) \n  dataa_r <= mem_array[addra_i]; \n  else \n  dataa_r <= 'bx; \n end \n assign dataa_o = oena_i ? 'bz : dataa_r; \n assign datab_m = mem_array[addrb_i]; \n genvar j; \n generate \n  for (j=0; j<Byte_Width; j=j+1) begin:j_n \n  always@(*) begin \n  datab_w[(j+1)*8-1:j*8] = wenb_i[j] ? datab_m[(j+1)*8-1:j*8] : datab_i[(j+1)*8-1:j*8]; \n  end \n  end \n endgenerate \n always @(posedge clkb) begin \n  if(!cenb_i && !(&wenb_i)) \n  mem_array[addrb_i] <= datab_w; \n end \n always @(posedge clkb) begin \n  if (!cenb_i && wenb_i) \n  datab_r <= mem_array[addrb_i]; \n  else \n  datab_r <= 'bx; \n end \n assign datab_o = oenb_i ? 'bz : datab_r; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a test RAM interface with clock, address, data, chip select (cs_), output enable (oe_), and write enable (we_) inputs. The data output is assigned based on the chip select and output enable signals. The module instantiates a RAM component and connects its clock, address, data, and write enable signals, and assigns the output data.\n\n Module header:\n\nmodule test_ram_if(clk, addr, data, cs_, oe_, we_);\n [/INST]\n", "output": "input clk; \n  input [18:0] addr; \n  inout [7:0] data; \n  input cs_; \n  input oe_; \n  input we_; \n wire [7:0] data_out; \n assign data = (~cs_ & ~oe_) ? data_out : 8'bzzzzzzzz; \n ram_for_test r(.clock(clk), .address(addr), .data(data), .wren(~cs_ & ~we_), .q(data_out)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module named f31_test takes an input \"in\" and negates it to produce the output \"out.\" It also takes a 32-bit input \"vin\" and negates each bit to produce a 32-bit output \"vout.\"\n\n Module header:\n\nmodule f31_test(output out, input in, output [31:0] vout, input [31:0] vin);\n [/INST]\n", "output": "assign out = -in; \n assign vout = -vin; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"altera_up_avalon_video_dma_ctrl_addr_trans\" serves as an address translator for a video direct memory access (DMA) controller. It takes in various control signals, including the clock signal and reset signal, as well as the slave and master addresses, data, and control signals. The module's primary functionality is to perform address translation using a predefined mask. The translated slave and master addresses and data are then routed to their respective outputs. The module also handles the wait request signals for both the slave and master.\n\nThe module consists of a series of assignments that determine the behavior based on the input signals. This includes performing address translation, managing wait requests, and routing the translated addresses and data to the appropriate outputs based on the slave address bit.\n\n Module header:\n\nmodule altera_up_avalon_video_dma_ctrl_addr_trans (clk,reset,slave_address,slave_byteenable,slave_read,slave_write,slave_writedata,master_readdata,master_waitrequest,slave_readdata,slave_waitrequest,master_address,master_byteenable,master_read,master_write,master_writedata);\n [/INST]\n", "output": "parameter ADDRESS_TRANSLATION_MASK = 32'hC0000000; \n input clk; \n input reset; \n input [ 1: 0] slave_address; \n input [ 3: 0] slave_byteenable; \n input slave_read; \n input slave_write; \n input [31: 0] slave_writedata; \n input [31: 0] master_readdata; \n input master_waitrequest; \n output [31: 0] slave_readdata; \n output slave_waitrequest; \n output [ 1: 0] master_address; \n output [ 3: 0] master_byteenable; \n output master_read; \n output master_write; \n output [31: 0] master_writedata; \n assign slave_readdata = (slave_address[1] == 1'b0) ? \n  master_readdata | ADDRESS_TRANSLATION_MASK : \n  master_readdata; \n assign slave_waitrequest = master_waitrequest; \n assign master_address = slave_address; \n assign master_byteenable = slave_byteenable; \n assign master_read = slave_read; \n assign master_write = slave_write; \n assign master_writedata = (slave_address[1] == 1'b0) ? \n  slave_writedata & ~ADDRESS_TRANSLATION_MASK : \n  slave_writedata; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a finite state machine that controls the generation of commands for initializing a DRAM module. It uses a state variable to track the current state of the state machine and updates the controller_command_fifo_in and controller_command_fifo_in_en outputs based on the current state and various input conditions. The state machine progresses through different states such as preparing for read, sending read command, changing page address, reading register, and done, based on input triggers and flags. The module also handles the generation of specific command sequences based on the state and input conditions.\n\n Module header:\n\nmodule initial_dram(reset,clk,trigger_initial_dram,all_Cmd_Available_flag,controller_command_fifo_in,controller_command_fifo_in_en);\n [/INST]\n", "output": "input reset; \n  input clk; \n  input trigger_initial_dram; \n  input all_Cmd_Available_flag; \n  output [COMMAND_WIDTH-1:0] controller_command_fifo_in; \n  output [7:0] controller_command_fifo_in_en; \n  reg [COMMAND_WIDTH-1:0] controller_command_fifo_in; \n  reg [7:0] controller_command_fifo_in_en; \n  reg [2:0]state; \n  reg [CHANNEL_ADDR_WIDTH-1:0]channel_index; \n  reg [7:0] enable; \n  reg [23:0] page_addr; \n  reg [DRAM_ADDR_WIDTH-1:0] dram_addr; \n  parameter PREPARE_FOR_READ =3'b000; \n  parameter SEND_READ_COMMAND =3'b001; \n  parameter CHANGE_PAGE_ADDR =3'b010; \n  parameter READ_REGISTER =3'b011; \n  parameter DONE =3'b100; \n always@(posedge clk or negedge reset ) \n begin \n  if(!reset) \n  begin \n  state <= PREPARE_FOR_READ; \n  page_addr <= BADBLOCK_FLASH_ADDR1; \n  dram_addr <= BAD_BLOCK_INFO_BASE; \n  channel_index <= 3'b0; \n  end \n  else \n  begin \n  case(state) \n  PREPARE_FOR_READ: \n  begin \n  if(trigger_initial_dram) \n  begin \n  case(channel_index) \n  3'b000:enable<=8'b00000001; \n  3'b001:enable<=8'b00000010; \n  3'b010:enable<=8'b00000100; \n  3'b011:enable<=8'b00001000; \n  3'b100:enable<=8'b00010000; \n  3'b101:enable<=8'b00100000; \n  3'b110:enable<=8'b01000000; \n  3'b111:enable<=8'b10000000; \n  endcase \n  state <= SEND_READ_COMMAND; \n  end \n  else \n  state <= PREPARE_FOR_READ; \n  end \n  SEND_READ_COMMAND: \n  begin \n  if(all_Cmd_Available_flag==1'b1) \n  begin \n  controller_command_fifo_in <= {{READ, 1'b0,2'b10,27'b0},{5'b0,channel_index[2:0],page_addr[23:0]},{12'b0,dram_addr[28:12],channel_index[2:0]}, {5'b0,page_addr[23:0],channel_index[2:0]}}; \n  controller_command_fifo_in_en<=enable; \n  channel_index <=channel_index + 1'b1; \n  state <=CHANGE_PAGE_ADDR; \n  end \n  else \n  state <= SEND_READ_COMMAND; \n  end \n  CHANGE_PAGE_ADDR: \n  begin \n  controller_command_fifo_in_en<=8'b00000000; \n  if(channel_index ==3'b000) \n  begin \n  if(page_addr == (BADBLOCK_FLASH_ADDR2)) \n  begin \n  controller_command_fifo_in <= {READ,1'b0,2'b01,27'b0,10'b0,REGISTER_BASE_FLASH,64'hffff_ffff_ffff_ffff}; \n  state <= READ_REGISTER; \n  end \n  else \n  begin \n  page_addr <= page_addr+4'b1_000; \n  dram_addr <= dram_addr+13'b1_0000_0000_0000; \n  state <= PREPARE_FOR_READ; \n  end \n  end \n  else \n  state <= PREPARE_FOR_READ; \n  end \n  READ_REGISTER: \n  begin \n  if(all_Cmd_Available_flag==1'b1) \n  begin \n  controller_command_fifo_in <= {READ,1'b0,2'b01,27'b0,10'b0,REGISTER_BASE_FLASH,64'hffff_ffff_ffff_ffff}; \n  controller_command_fifo_in_en <=8'b00000001; \n  state <=DONE; \n  end \n  else \n  state <= READ_REGISTER; \n  end \n  DONE: \n  begin \n  controller_command_fifo_in_en<=8'b00000000; \n  state <=DONE; \n  end \n  default: \n  state<= PREPARE_FOR_READ; \n  endcase \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements an 8-to-3 priority encoder. The 8-bit input data is encoded into a 3-bit output q based on the highest priority active input. It uses two sub-modules to encode the lower and upper 4 bits of the input data separately, and then combines their outputs to determine the highest priority active input.\n\n Module header:\n\nmodule fpoint_hw_qsys_addsub_single_altpriority_encoder_qha (data,q) ;\n [/INST]\n", "output": "input [7:0] data; \n  output [2:0] q; \n  wire [1:0] wire_altpriority_encoder15_q; \n  wire [1:0] wire_altpriority_encoder16_q; \n  wire wire_altpriority_encoder16_zero; \n  fpoint_hw_qsys_addsub_single_altpriority_encoder_lha altpriority_encoder15 \n (.data(data[3:0]),.q(wire_altpriority_encoder15_q)); \n  fpoint_hw_qsys_addsub_single_altpriority_encoder_l0b altpriority_encoder16 \n (.data(data[7:4]),.q(wire_altpriority_encoder16_q),.zero(wire_altpriority_encoder16_zero)); \n  assign \n  q = {(~ wire_altpriority_encoder16_zero), (({2{wire_altpriority_encoder16_zero}} & wire_altpriority_encoder15_q) | ({2{(~ wire_altpriority_encoder16_zero)}} & wire_altpriority_encoder16_q))}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a write multiplexer that manages the writing of data to specific addresses based on the state of the system and the readiness of the write signals. It utilizes a state machine to control the writing process. The state machine transitions based on the write valid signals and write ready signals. Additionally, it sets the write address, write data, and write last signals for each word based on the current state.\n\n Module header:\n\nmodule wr_mux (input clock,input reset,input [3:0] wri_valid,output [3:0] wri_ready,input [3:0] wri_last,input [63:0] wri_addr_0,input [63:0] wri_addr_1,input [63:0] wri_addr_2,input [63:0] wri_addr_3,input [63:0] wri_data_0,input [63:0] wri_data_1,input [63:0] wri_data_2,input [63:0] wri_data_3,output wro_valid,input wro_ready,output [63:0] wro_addr,output reg [63:0] wro_data,output reg wro_last);\n [/INST]\n", "output": "reg [3:0] state = 0; \n  reg [60:0] wro_addr_s = 0; \n  assign wro_addr = {wro_addr_s, 3'd0}; \n  assign wri_ready[0] = (state == 1) && wro_ready; \n  assign wri_ready[1] = (state == 5) && wro_ready; \n  assign wri_ready[2] = (state == 9) && wro_ready; \n  assign wri_ready[3] = (state == 13) && wro_ready; \n  assign wro_valid = (state[1:0] == 1); \n  always @ (posedge clock) \n  begin \n  if(reset) \n  state <= 4'h0; \n  else \n  begin \n  casex(state) \n  default: state <= wri_valid[0] ? 4'h1 : \n  wri_valid[1] ? 4'h5 : \n  wri_valid[2] ? 4'h9 : \n  wri_valid[3] ? 4'hD : 4'h0; \n  4'bxx01: state <= state + wro_ready; \n  4'h2: state <= ~wri_last[0] ? state : \n  wri_valid[1] ? 4'h5 : \n  wri_valid[2] ? 4'h9 : \n  wri_valid[3] ? 4'hD : \n  wri_valid[0] ? 4'h1 : 4'h0; \n  4'h6: state <= ~wri_last[1] ? state : \n  wri_valid[0] ? 4'h1 : \n  wri_valid[2] ? 4'h9 : \n  wri_valid[3] ? 4'hD : \n  wri_valid[1] ? 4'h5 : 4'h0; \n  4'hA: state <= ~wri_last[2] ? state : \n  wri_valid[3] ? 4'hD : \n  wri_valid[0] ? 4'h1 : \n  wri_valid[1] ? 4'h5 : \n  wri_valid[2] ? 4'h9 : 4'h0; \n  4'hE: state <= ~wri_last[3] ? state : \n  wri_valid[0] ? 4'h1 : \n  wri_valid[1] ? 4'h5 : \n  wri_valid[2] ? 4'h9 : \n  wri_valid[3] ? 4'hD : 4'h0; \n  endcase \n  end \n  case(state[3:2]) \n  0: wro_addr_s <= wri_addr_0[63:3]; \n  1: wro_addr_s <= wri_addr_1[63:3]; \n  2: wro_addr_s <= wri_addr_2[63:3]; \n  3: wro_addr_s <= wri_addr_3[63:3]; \n  endcase \n  case(state[3:2]) \n  0: wro_data <= wri_data_0; \n  1: wro_data <= wri_data_1; \n  2: wro_data <= wri_data_2; \n  3: wro_data <= wri_data_3; \n  endcase \n  case(state[3:2]) \n  0: wro_last <= wri_last[0]; \n  1: wro_last <= wri_last[1]; \n  2: wro_last <= wri_last[2]; \n  3: wro_last <= wri_last[3]; \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a D flip-flop with power and ground domain controls. It includes a D flip-flop instantiation, a buffer instantiation, and a power-aware awake signal assignment. The D flip-flop is sensitive to the delayed clock signal and is driven by the delayed D input, with its output connected to the buffer. Additionally, the module includes power and ground domain inputs and a notifier register to control the power domain. When VPWR is high, the awake signal is asserted.\n\n Module header:\n\nmodule sky130_fd_sc_ls__dfxtp (Q ,CLK ,D ,VPWR,VGND,VPB ,VNB);\n [/INST]\n", "output": "output Q ; \n  input CLK ; \n  input D ; \n  input VPWR; \n  input VGND; \n  input VPB ; \n  input VNB ; \n  wire buf_Q ; \n  reg notifier ; \n  wire D_delayed ; \n  wire CLK_delayed; \n  wire awake ; \n  sky130_fd_sc_ls__udp_dff$P_pp$PG$N dff0 (buf_Q , D_delayed, CLK_delayed, notifier, VPWR, VGND); \n  assign awake = ( VPWR === 1'b1 ); \n  buf buf0 (Q , buf_Q ); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an inverter with a parameterized width. It takes an input data of width lpm_width and outputs the result, which is the bitwise negation of the input data. The module includes a check for the lpm_width parameter to ensure it is greater than 0, and it displays an error message and finishes simulation if the parameter is invalid.\n\n Module header:\n\nmodule lpm_inv (data,result);\n [/INST]\n", "output": "parameter lpm_width = 1; \n  parameter lpm_type = \"lpm_inv\"; \n  parameter lpm_hint = \"UNUSED\"; \n  input [lpm_width-1:0] data; \n  output [lpm_width-1:0] result; \n  reg [lpm_width-1:0] result; \n  initial \n  begin \n  if (lpm_width <= 0) \n  begin \n  $display(\"Value of lpm_width parameter must be greater than 0 (ERROR)\"); \n  $display(\"Time: %0t Instance: %m\", $time); \n  $finish; \n  end \n  end \n  always @(data) \n  result = ~data; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module represents a test environment for an instance of the Integradorv2 module. It initializes input registers a and dt with specific values, and then manipulates the enable, reset, and clock signals to control the operation of the integrator module. The clock signal is toggled every 5 time units. The module waits for 100 time units before enabling the integrator by setting the enable signal to 1 and then de-asserting the reset signal.\n\n Module header:\n\nmodule inter_tst;\n [/INST]\n", "output": "reg [15:0] a; \n  reg [15:0] dt; \n  reg enable; \n  reg rst; \n  reg clk; \n  wire [15:0] v; \n  wire busy; \n Integradorv2 uut (.a(a),.dt(dt),.enable(enable),.rst(rst),.clk(clk),.v(v),.busy(busy)); \n  initial begin \n  a = 16'hAA; \n  dt = 5'd10; \n  enable = 0; \n  rst = 1; \n  clk = 0; \n  #100; \n  enable = 1; \n  rst = 0; \n  end \n  always #5 clk <= !clk; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a representation of an I2C slave device for an EDID EEPROM. It includes logic to control the I2C bus signals, address and data handling, and state machine operations. The module responds to various input signals such as clock, reset, enable, I2C bus signals, and address/data inputs. It also includes an internal address register, data register, and state machine to manage the read and write operations. The implementation is based on the I2C communication protocol and includes the necessary logic to communicate with a master device over the I2C bus.\n\n Module header:\n\nmodule edid_eeprom (input clk_sys_i,input rst_n_i,inout scl_b,inout sda_b,input edid_en_i,input scl_master_i,input sda_master_i,output sda_master_o,input hdmi_p5v_notif_i,output hdmi_hpd_en_o,input [7:0] addr_i,input [7:0] data_i,input wr_i);\n [/INST]\n", "output": "parameter g_size = 128; \n  parameter g_address = 7'h50; \n  reg [7:0] tx_byte='haa; \n  wire [7:0] rx_byte; \n  wire scl_edid_en, scl_edid_in, scl_edid_out; \n  wire sda_edid_en, sda_edid_in, sda_edid_out; \n  assign hdmi_hpd_en_o = 1'b1; \n gc_i2c_slave #(.g_gf_len(1)) \n  U_I2C_Slave \n (.clk_i(clk_sys_i),.rst_n_i(rst_n_i),.scl_i(scl_edid_in),.scl_o(scl_edid_out),.scl_en_o(scl_edid_en),.sda_i(sda_edid_in),.sda_o(sda_edid_out),.sda_en_o(sda_edid_en),.i2c_addr_i(g_address),.ack_i(ack),.tx_byte_i(tx_byte),.rx_byte_o(rx_byte),.i2c_sta_p_o(i2c_start),.i2c_sto_p_o(i2c_stop),.addr_good_p_o(addr_good_p),.r_done_p_o(r_done_p),.w_done_p_o(w_done_p),.op_o(op)); \n  reg [7:0] edid[0:g_size-1]; \n  assign ack = 1; \n  assign tx_byte_i = 0; \n  assign scl_edid_in = edid_en_i ? scl_b : 1'b1; \n  assign sda_edid_in = edid_en_i ? sda_b : 1'b1; \n  assign scl_b = edid_en_i ? (scl_edid_en ? scl_edid_out : 1'bz) : ( scl_master_i ? 1'b0 : 1'bz ); \n  assign sda_b = edid_en_i ? (sda_edid_en ? sda_edid_out : 1'bz) : ( sda_master_i ? 1'b0 : 1'bz ); \n  assign sda_master_o = sda_b; \n  reg [7:0] addr=0; \n  always@(posedge clk_sys_i) \n  if(wr_i) \n  edid[addr_i] <= data_i; \n  else \n  tx_byte <= edid[addr]; \n  always@(posedge clk_sys_i) \n  begin \n  if(!op && r_done_p) \n  addr <= rx_byte; \n  else if (op && w_done_p) \n  addr <= addr + 1; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a Sinc3 filter with a parameterizable oversampling ratio (OSR). It uses shift registers to implement the filter's time-domain difference equation, and accumulates the filter output using two accumulators. The filter's output is updated on each clock cycle when the 'en' input is asserted.\n\n Module header:\n\nmodule sinc3Filter #(parameter OSR = 16) (input clk,input en,input in,output reg signed [3*$clog2(OSR):0] out);\n [/INST]\n", "output": "localparam ACC_UP = $clog2(OSR)-1; \n wire signed [3:0] diff; \n reg [(3*OSR)-1:0] shift; \n reg signed [(3+1*ACC_UP):0] acc1 = 'd0; \n reg signed [(3+2*ACC_UP):0] acc2 = 'd0; \n integer i; \n initial begin \n  shift[0] = 1'b1; \n  for (i=1; i<(3*OSR); i=i+1) shift[i] = ~shift[i-1]; \n  out = 'd0; \n end \n assign diff = in - 3*shift[OSR-1] + 3*shift[2*OSR-1] - shift[3*OSR-1]; \n always @(posedge clk) begin \n  if (en) begin \n  shift <= {shift[3*OSR-2:0], in}; \n  acc1 <= acc1 + diff; \n  acc2 <= acc2 + acc1; \n  out <= out + acc2; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an arbiter that controls access to a shared bus by multiple masters. It manages the command and response signals for an instruction bus and a data bus. The arbiter prioritizes the masters and manages the command and response signals to ensure proper bus access and communication. It also handles reset signals and manages the response pending and target states.\n\n Module header:\n\nmodule MuraxMasterArbiter (input io_iBus_cmd_valid,output reg io_iBus_cmd_ready,input [31:0] io_iBus_cmd_payload_pc,output io_iBus_rsp_ready,output io_iBus_rsp_error,output [31:0] io_iBus_rsp_inst,input io_dBus_cmd_valid,output reg io_dBus_cmd_ready,input io_dBus_cmd_payload_wr,input [31:0] io_dBus_cmd_payload_address,input [31:0] io_dBus_cmd_payload_data,input [1:0] io_dBus_cmd_payload_size,output io_dBus_rsp_ready,output io_dBus_rsp_error,output [31:0] io_dBus_rsp_data,output io_masterBus_cmd_valid,input io_masterBus_cmd_ready,output io_masterBus_cmd_payload_wr,output [31:0] io_masterBus_cmd_payload_address,output [31:0] io_masterBus_cmd_payload_data,output [3:0] io_masterBus_cmd_payload_mask,input io_masterBus_rsp_valid,input [31:0] io_masterBus_rsp_payload_data,input io_mainClk,input resetCtrl_systemReset);\n [/INST]\n", "output": "reg _zz_2; \n  wire _zz_3; \n  reg [3:0] _zz_1; \n  reg rspPending; \n  reg rspTarget; \n  assign io_masterBus_cmd_valid = _zz_2; \n  assign io_masterBus_cmd_payload_wr = _zz_3; \n  always @ (*) begin \n  _zz_2 = (io_iBus_cmd_valid || io_dBus_cmd_valid); \n  io_iBus_cmd_ready = (io_masterBus_cmd_ready && (! io_dBus_cmd_valid)); \n  io_dBus_cmd_ready = io_masterBus_cmd_ready; \n  if((rspPending && (! io_masterBus_rsp_valid)))begin \n  io_iBus_cmd_ready = 1'b0; \n  io_dBus_cmd_ready = 1'b0; \n  _zz_2 = 1'b0; \n  end \n  end \n  assign _zz_3 = (io_dBus_cmd_valid && io_dBus_cmd_payload_wr); \n  assign io_masterBus_cmd_payload_address = (io_dBus_cmd_valid ? io_dBus_cmd_payload_address : io_iBus_cmd_payload_pc); \n  assign io_masterBus_cmd_payload_data = io_dBus_cmd_payload_data; \n  always @ (*) begin \n  case(io_dBus_cmd_payload_size) \n  2'b00 : begin \n  _zz_1 = (4'b0001); \n  end \n  2'b01 : begin \n  _zz_1 = (4'b0011); \n  end \n  default : begin \n  _zz_1 = (4'b1111); \n  end \n  endcase \n  end \n  assign io_masterBus_cmd_payload_mask = (_zz_1 <<< io_dBus_cmd_payload_address[1 : 0]); \n  assign io_iBus_rsp_ready = (io_masterBus_rsp_valid && (! rspTarget)); \n  assign io_iBus_rsp_inst = io_masterBus_rsp_payload_data; \n  assign io_iBus_rsp_error = 1'b0; \n  assign io_dBus_rsp_ready = (io_masterBus_rsp_valid && rspTarget); \n  assign io_dBus_rsp_data = io_masterBus_rsp_payload_data; \n  assign io_dBus_rsp_error = 1'b0; \n  always @ (posedge io_mainClk or posedge resetCtrl_systemReset) begin \n  if (resetCtrl_systemReset) begin \n  rspPending <= 1'b0; \n  rspTarget <= 1'b0; \n  end else begin \n  if(io_masterBus_rsp_valid)begin \n  rspPending <= 1'b0; \n  end \n  if(((_zz_2 && io_masterBus_cmd_ready) && (! _zz_3)))begin \n  rspTarget <= io_dBus_cmd_valid; \n  rspPending <= 1'b1; \n  end \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a top-level wrapper for the FBox_Core module. It contains input and output ports for various signals such as clock, reset, enable signals for server reset requests and responses, and various request and response fields. \n\nThe module connects its input and output signals to the corresponding ports of the FBox_Core module, and also performs some signal assignments and logic operations. For example, it assigns the request fields and enable signals to the corresponding ports of the FBox_Core module, and also assigns the ready and valid signals based on the FBox_Core module's signals. \n\nOverall, the module acts as an interface between the FBox_Core module and the external environment, managing the connections and signal assignments between them.\n\n Module header:\n\nmodule mkFBox_Top(verbosity,CLK,RST_N,EN_server_reset_request_put,RDY_server_reset_request_put,EN_server_reset_response_get,RDY_server_reset_response_get,req_opcode,req_f7,req_rm,req_rs2,req_v1,req_v2,req_v3,EN_req,valid,word_fst,word_snd);\n [/INST]\n", "output": "input [3 : 0] verbosity; \n  input CLK; \n  input RST_N; \n  input EN_server_reset_request_put; \n  output RDY_server_reset_request_put; \n  input EN_server_reset_response_get; \n  output RDY_server_reset_response_get; \n  input [6 : 0] req_opcode; \n  input [6 : 0] req_f7; \n  input [2 : 0] req_rm; \n  input [4 : 0] req_rs2; \n  input [63 : 0] req_v1; \n  input [63 : 0] req_v2; \n  input [63 : 0] req_v3; \n  input EN_req; \n  output valid; \n  output [63 : 0] word_fst; \n  output [4 : 0] word_snd; \n  wire [63 : 0] word_fst; \n  wire [4 : 0] word_snd; \n  wire RDY_server_reset_request_put, RDY_server_reset_response_get, valid; \n  wire [63 : 0] fbox_core$req_v1, \n  fbox_core$req_v2, \n  fbox_core$req_v3, \n  fbox_core$word_fst; \n  wire [6 : 0] fbox_core$req_f7, fbox_core$req_opcode; \n  wire [4 : 0] fbox_core$req_rs2, fbox_core$word_snd; \n  wire [2 : 0] fbox_core$req_rm; \n  wire fbox_core$EN_req, \n  fbox_core$EN_server_reset_request_put, \n  fbox_core$EN_server_reset_response_get, \n  fbox_core$RDY_server_reset_request_put, \n  fbox_core$RDY_server_reset_response_get, \n  fbox_core$valid; \n  wire CAN_FIRE_req, \n  CAN_FIRE_server_reset_request_put, \n  CAN_FIRE_server_reset_response_get, \n  WILL_FIRE_req, \n  WILL_FIRE_server_reset_request_put, \n  WILL_FIRE_server_reset_response_get; \n  assign RDY_server_reset_request_put = \n  fbox_core$RDY_server_reset_request_put ; \n  assign CAN_FIRE_server_reset_request_put = \n  fbox_core$RDY_server_reset_request_put ; \n  assign WILL_FIRE_server_reset_request_put = EN_server_reset_request_put ; \n  assign RDY_server_reset_response_get = \n  fbox_core$RDY_server_reset_response_get ; \n  assign CAN_FIRE_server_reset_response_get = \n  fbox_core$RDY_server_reset_response_get ; \n  assign WILL_FIRE_server_reset_response_get = EN_server_reset_response_get ; \n  assign CAN_FIRE_req = 1'd1 ; \n  assign WILL_FIRE_req = EN_req ; \n  assign valid = fbox_core$valid ; \n  assign word_fst = fbox_core$word_fst ; \n  assign word_snd = fbox_core$word_snd ; \n mkFBox_Core fbox_core(.verbosity(verbosity),.CLK(CLK),.RST_N(RST_N),.req_f7(fbox_core$req_f7),.req_opcode(fbox_core$req_opcode),.req_rm(fbox_core$req_rm),.req_rs2(fbox_core$req_rs2),.req_v1(fbox_core$req_v1),.req_v2(fbox_core$req_v2),.req_v3(fbox_core$req_v3),.EN_server_reset_request_put(fbox_core$EN_server_reset_request_put),.EN_server_reset_response_get(fbox_core$EN_server_reset_response_get),.EN_req(fbox_core$EN_req),.RDY_server_reset_request_put(fbox_core$RDY_server_reset_request_put),.RDY_server_reset_response_get(fbox_core$RDY_server_reset_response_get),.valid(fbox_core$valid),.word_fst(fbox_core$word_fst),.word_snd(fbox_core$word_snd)); \n  assign fbox_core$req_f7 = req_f7 ; \n  assign fbox_core$req_opcode = req_opcode ; \n  assign fbox_core$req_rm = req_rm ; \n  assign fbox_core$req_rs2 = req_rs2 ; \n  assign fbox_core$req_v1 = req_v1 ; \n  assign fbox_core$req_v2 = req_v2 ; \n  assign fbox_core$req_v3 = req_v3 ; \n  assign fbox_core$EN_server_reset_request_put = EN_server_reset_request_put ; \n  assign fbox_core$EN_server_reset_response_get = \n  EN_server_reset_response_get ; \n  assign fbox_core$EN_req = EN_req ; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a pointer register that stores and retrieves LBID (Load Buffer ID) and OFS (Offset) information based on control signals. The module contains storage for LBID and OFS files, and updates them on the rising edge of the clock based on the write enable signal and the specified pointer. When the write enable signal is asserted, the module updates the LBID and OFS files with the specified LBID and OFS values at the specified pointer. Otherwise, it retrieves the LBID and OFS information from the files based on the specified pointers and outputs them. The module also has logic to generate a PC (Program Counter) update request based on the write enable and pointer values.\n\n Module header:\n\nmodule PointerRegister(clk,p0, p1, pw,lbid0, lbid1, lbidw,ofs0, ofs1, ofsw,we, pc_update_req);\n [/INST]\n", "output": "input clk, we; \n  input [5:0] p0, p1, pw; \n  output reg [11:0] lbid0, lbid1; \n  input [11:0] lbidw; \n  output reg [15:0] ofs0, ofs1; \n  input [15:0] ofsw; \n  output pc_update_req; \n  reg [11:0] lbidfile[63:0]; \n  reg [15:0] ofsfile[63:0]; \n  wire [5:0] rwp0; \n  assign pc_update_req = (we == 1 && pw == 6'h3f) ? 1 : 0; \n  assign rwp0 = (we == 1) ? pw : p0; \n  always @ (posedge clk) \n  begin \n  if(we == 1) begin \n  lbidfile[rwp0] <= lbidw; \n  ofsfile[rwp0] <= ofsw; \n  end \n  else begin \n  lbid0 <= lbidfile[rwp0]; \n  ofs0 <= ofsfile[rwp0]; \n  end \n  end \n  always @ (posedge clk) \n  begin \n  lbid1 <= lbidfile[p1]; \n  ofs1 <= ofsfile[p1]; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module implements a finite field reduction operation for the secp256k1 curve. It takes an input rx_a and produces tx_done and tx_a as outputs. The reduction operation involves several registers (cnt, s, s1, k) and internal signals (k11, c1, other, s_minus_p). The reduction process is performed iteratively in a combinational logic block, updating the internal state and producing the output when the reduction is complete. The reduction process involves bitwise and arithmetic operations on specific bit ranges of the input data. The module also handles reset signals to initialize the internal state. When the reduction is complete, it sets tx_done to 1 and outputs the reduced result in tx_a.\n\n Module header:\n\nmodule ff_reduce_secp256k1 (input clk,input reset,input [511:0] rx_a,output reg tx_done,output reg [255:0] tx_a);\n [/INST]\n", "output": "reg [3:0] cnt; \n  reg [259:0] s; \n  reg [32:0] s1; \n  reg [64:0] k; \n  wire [34:0] k11 = {s1, 2'd0} + {s1, 1'd0} + s1; \n  wire [255:0] c1 = rx_a[511:256]; \n  reg [255:0] other; \n  wire [260:0] s_minus_p = s - 256'hFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F; \n  always @ (*) \n  begin \n  if (cnt == 0) \n  other <= {c1[223:0], 32'd0}; \n  else if (cnt == 1) \n  other <= {c1[246:0], 9'd0}; \n  else if (cnt == 2) \n  other <= {c1[247:0], 8'd0}; \n  else if (cnt == 3) \n  other <= {c1[248:0], 7'd0}; \n  else if (cnt == 4) \n  other <= {c1[249:0], 6'd0}; \n  else if (cnt == 5) \n  other <= {c1[251:0], 4'd0}; \n  else if (cnt == 6) \n  other <= c1; \n  else if (cnt == 7) \n  other <= k; \n  else \n  other <= k; \n  end \n  always @ (posedge clk) \n  begin \n  cnt <= cnt + 1; \n  s <= s + other; \n  if (cnt == 8) \n  begin \n  cnt <= cnt; \n  s <= s_minus_p; \n  if (s_minus_p[260] && !tx_done) \n  begin \n  tx_done <= 1'b1; \n  tx_a <= s[255:0]; \n  end \n  end \n  s1 <= c1[255:252] + c1[255:250] + c1[255:249] + c1[255:248] + c1[255:247] + c1[255:224]; \n  k <= {s1, 32'd0} + {k11, 7'd0} + {s1, 6'd0} + {s1, 4'd0} + s1; \n  if (reset) \n  begin \n  cnt <= 0; \n  tx_done <= 1'b0; \n  s <= rx_a[255:0]; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a 4-stage finite impulse response (FIR) filter. It takes in left and right input samples, processes them through the filter, and produces left and right output samples. The coefficients for each stage of the filter are defined using a case statement, and the filter is instantiated using these coefficients. The filter is clocked and reset, and the sample input and output are also included.\n\n Module header:\n\nmodule jt51_fir4 #(parameter data_width=9, output_width=12) (input clk,input rst,input sample,input signed [data_width-1:0] left_in,input signed [data_width-1:0] right_in,output signed [output_width-1:0] left_out,output signed [output_width-1:0] right_out,output sample_out);\n [/INST]\n", "output": "parameter coeff_width=9; \n parameter stages=21; \n parameter addr_width=5; \n parameter acc_extra=1; \n reg signed [coeff_width-1:0] coeff; \n wire [addr_width-1:0] cnt; \n jt51_fir #(.data_width (data_width),.output_width(output_width),.coeff_width (coeff_width),.stages (stages),.addr_width (addr_width),.acc_extra (acc_extra)) i_jt51_fir (.clk (clk ),.rst (rst ),.sample (sample ),.left_in (left_in ),.right_in (right_in ),.left_out (left_out ),.right_out (right_out ),.sample_out(sample_out),.cnt (cnt ),.coeff (coeff )); \n always @(*) \n  case( cnt ) \n  5'd0: coeff = 9'd18; \n  5'd1: coeff = 9'd24; \n  5'd2: coeff = 9'd40; \n  5'd3: coeff = 9'd66; \n  5'd4: coeff = 9'd99; \n  5'd5: coeff = 9'd134; \n  5'd6: coeff = 9'd171; \n  5'd7: coeff = 9'd205; \n  5'd8: coeff = 9'd231; \n  5'd9: coeff = 9'd249; \n  5'd10: coeff = 9'd255; \n  default: coeff = 9'd0; \n  endcase \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module contains a single register 'value1' which is checked for a specific value. If it does not match the expected value, a failure message is displayed; otherwise, a pass message is displayed. The value of 'value1' is always set to the logical AND of two 1-bit values.\n\n Module header:\n\nmodule main ;\n [/INST]\n", "output": "reg [3:0] value1 ; \n initial \n  if(value1 != 4'b1) \n  $display(\"FAILED - 3.1.2B always reg_lvalue = boolean_expression\\n\"); \n  else \n  begin \n  $display(\"PASSED\\n\"); \n  $finish; \n  end \n always value1 <= 1'b1 && 1'b1 ; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an implementation of a USB functional block. It includes various input and output signals such as clock, reset, data signals, control signals, and status signals. The module performs clocked operations based on the rising edge of the clock signal, and includes asynchronous reset logic for some signals. It also interfaces with another module (usbf_utmi_ls) to handle low-speed USB operations. The module implements various USB protocol functionalities such as data transmission and reception, suspend and resume handling, and USB mode and state management.\n\n Module header:\n\nmodule usbf_utmi_if(phy_clk, rst,DataOut, TxValid, TxReady,RxValid, RxActive, RxError, DataIn,XcvSelect, TermSel, SuspendM, LineState,OpMode, usb_vbus,rx_data, rx_valid, rx_active, rx_err,tx_data, tx_valid, tx_valid_last, tx_ready,tx_first,mode_hs, usb_reset, usb_suspend, usb_attached,resume_req, suspend_clr);\n [/INST]\n", "output": "input phy_clk; \n input rst; \n output [7:0] DataOut; \n output reg TxValid; \n input TxReady; \n input [7:0] DataIn; \n input RxValid; \n input RxActive; \n input RxError; \n output XcvSelect; \n output TermSel; \n output SuspendM; \n input [1:0] LineState; \n output [1:0] OpMode; \n input usb_vbus; \n output [7:0] rx_data; \n output rx_valid, rx_active, rx_err; \n input [7:0] tx_data; \n input tx_valid; \n input tx_valid_last; \n output tx_ready; \n input tx_first; \n output mode_hs; \n output usb_reset; \n output usb_suspend; \n output usb_attached; \n input resume_req; \n output suspend_clr; \n reg [7:0] rx_data; \n reg rx_valid, rx_active, rx_err; \n reg [7:0] DataOut; \n reg tx_ready; \n wire drive_k; \n reg drive_k_r; \n `ifdef USBF_ASYNC_RESET \n always @(posedge phy_clk or negedge rst) \n `else \n always @(posedge phy_clk) \n `endif \n  if(rst) rx_valid <= 1'b0; \n  else rx_valid <= RxValid; \n `ifdef USBF_ASYNC_RESET \n always @(posedge phy_clk or negedge rst) \n `else \n always @(posedge phy_clk) \n `endif \n  if(rst) rx_active <= 1'b0; \n  else rx_active <= RxActive; \n `ifdef USBF_ASYNC_RESET \n always @(posedge phy_clk or negedge rst) \n `else \n always @(posedge phy_clk) \n `endif \n  if(rst) rx_err <= 1'b0; \n  else rx_err <= RxError; \n always @(posedge phy_clk) \n  rx_data <= DataIn; \n always @(posedge phy_clk) \n  if(tx_ready || tx_first) DataOut <= tx_data; \n  else \n  if(drive_k) DataOut <= 8'h00; \n always @(posedge phy_clk) \n  tx_ready <= TxReady; \n always @(posedge phy_clk) \n  drive_k_r <= drive_k; \n `ifdef USBF_ASYNC_RESET \n always @(posedge phy_clk or negedge rst) \n `else \n always @(posedge phy_clk) \n `endif \n  if(rst) TxValid <= 1'b0; \n  else \n  TxValid <= tx_valid | drive_k | tx_valid_last | (TxValid & !(tx_ready | drive_k_r)); \n usbf_utmi_ls u0(.clk( phy_clk ),.rst( rst ),.resume_req( resume_req ),.rx_active( rx_active ),.tx_ready( tx_ready ),.drive_k( drive_k ),.XcvSelect( XcvSelect ),.TermSel( TermSel ),.SuspendM( SuspendM ),.LineState( LineState ),.OpMode( OpMode ),.usb_vbus( usb_vbus ),.mode_hs( mode_hs ),.usb_reset( usb_reset ),.usb_suspend( usb_suspend ),.usb_attached( usb_attached ),.suspend_clr( suspend_clr )); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a channelizer FIR compiler instance. It takes various input signals such as clock, reset, and control signals, and provides multiple output signals. The module also involves some signal assignments and instantiates the channelizer FIR compiler v7.2.0. The high-level functionality is to interface with the channelizer FIR compiler and manage the input and output signals for the channelizer operation.\n\n Module header:\n\nmodule xlfir_compiler_19490f93cbd7e22fee0db5c2ec90c7a6 (ce,clk,event_s_config_tlast_missing,event_s_config_tlast_unexpected,event_s_data_tlast_missing,event_s_data_tlast_unexpected,m_axis_data_tdata_path0,m_axis_data_tdata_path1,m_axis_data_tlast,m_axis_data_tready,m_axis_data_tvalid,rst,s_axis_config_tdata_fsel,s_axis_config_tlast,s_axis_config_tready,s_axis_config_tvalid,s_axis_data_tdata_path0,s_axis_data_tdata_path1,s_axis_data_tlast,s_axis_data_tready,s_axis_data_tvalid,src_ce,src_clk);\n [/INST]\n", "output": "input ce; \n input clk; \n output event_s_config_tlast_missing; \n output event_s_config_tlast_unexpected; \n output event_s_data_tlast_missing; \n output event_s_data_tlast_unexpected; \n output[33:0] m_axis_data_tdata_path0; \n output[33:0] m_axis_data_tdata_path1; \n output m_axis_data_tlast; \n input m_axis_data_tready; \n output m_axis_data_tvalid; \n input rst; \n input[3:0] s_axis_config_tdata_fsel; \n input s_axis_config_tlast; \n output s_axis_config_tready; \n input s_axis_config_tvalid; \n input[17:0] s_axis_data_tdata_path0; \n input[17:0] s_axis_data_tdata_path1; \n input s_axis_data_tlast; \n output s_axis_data_tready; \n input s_axis_data_tvalid; \n input src_ce; \n input src_clk; \n wire aresetn_net; \n wire[79:0] m_axis_data_tdata_net; \n wire[7:0] s_axis_config_tdata_net; \n wire[47:0] s_axis_data_tdata_net; \n  assign aresetn_net = rst | (~ ce); \n  assign m_axis_data_tdata_path1 = m_axis_data_tdata_net[73 : 40]; \n  assign m_axis_data_tdata_path0 = m_axis_data_tdata_net[33 : 0]; \n  assign s_axis_config_tdata_net[7 : 4] = 4'b0; \n  assign s_axis_config_tdata_net[3 : 0] = s_axis_config_tdata_fsel; \n  assign s_axis_data_tdata_net[47 : 42] = 6'b0; \n  assign s_axis_data_tdata_net[41 : 24] = s_axis_data_tdata_path1; \n  assign s_axis_data_tdata_net[23 : 18] = 6'b0; \n  assign s_axis_data_tdata_net[17 : 0] = s_axis_data_tdata_path0; \n channelizer_fir_compiler_v7_2_0 channelizer_fir_compiler_v7_2_0_instance(.aclk(clk),.aclken(ce),.aresetn(aresetn_net),.event_s_config_tlast_missing(event_s_config_tlast_missing),.event_s_config_tlast_unexpected(event_s_config_tlast_unexpected),.event_s_data_tlast_missing(event_s_data_tlast_missing),.event_s_data_tlast_unexpected(event_s_data_tlast_unexpected),.m_axis_data_tdata(m_axis_data_tdata_net),.m_axis_data_tlast(m_axis_data_tlast),.m_axis_data_tready(m_axis_data_tready),.m_axis_data_tvalid(m_axis_data_tvalid),.s_axis_config_tdata(s_axis_config_tdata_net),.s_axis_config_tlast(s_axis_config_tlast),.s_axis_config_tready(s_axis_config_tready),.s_axis_config_tvalid(s_axis_config_tvalid),.s_axis_data_tdata(s_axis_data_tdata_net),.s_axis_data_tlast(s_axis_data_tlast),.s_axis_data_tready(s_axis_data_tready),.s_axis_data_tvalid(s_axis_data_tvalid)); \n  endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module named \"bw_io_ic_filter\" has three inputs (topad, vddo) and one output (torcvr). It assigns the value of the \"topad\" input to the \"torcvr\" output. This indicates that the output signal \"torcvr\" directly reflects the value of the \"topad\" input signal.\n\n Module header:\n\nmodule bw_io_ic_filter(torcvr,topad,vddo );\n [/INST]\n", "output": "output torcvr; \n input topad; \n input vddo; \n assign torcvr = topad ; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module MUL_FIX_POINT_FLOAT defines a fixed-point floating-point multiplication module with inputs A and B, and output out. It performs fixed-point floating-point multiplication using bit manipulation. The module includes a parameter for the bit width of the input and output, and defines signals for the multiplication process. It handles sign extension for the input signals and performs the multiplication operation using bit shifting and addition. Finally, it assigns the output signal based on the sign of the multiplication result.\n\n Module header:\n\nmodule MUL_FIX_POINT_FLOAT ( A, B, out );\n [/INST]\n", "output": "parameter width = 16; \n input [width:1] A,B; \n output [width:1] out ; \n genvar i; \n parameter half = width/2; \n parameter half_mask = ((1<<(half+1))-1); \n parameter top_mask = half_mask << (half); \n wire [width:1] A2,B2; \n wire [2*width:1] temp; \n wire [1:1] flag; \n assign flag = A[width] ^ B[width]; \n assign A2 = A[width] ? -A : A; \n assign B2 = B[width] ? -B : B; \n assign temp = (0+ ( (B2[ 1]) ? A2 << ( 1 - 1 ) : 0 )+ ( (B2[ 2]) ? A2 << ( 2 - 1 ) : 0 )+ ( (B2[ 3]) ? A2 << ( 3 - 1 ) : 0 )+ ( (B2[ 4]) ? A2 << ( 4 - 1 ) : 0 )+ ( (B2[ 5]) ? A2 << ( 5 - 1 ) : 0 )+ ( (B2[ 6]) ? A2 << ( 6 - 1 ) : 0 )+ ( (B2[ 7]) ? A2 << ( 7 - 1 ) : 0 )+ ( (B2[ 8]) ? A2 << ( 8 - 1 ) : 0 )+ ( (B2[ 9]) ? A2 << ( 9 - 1 ) : 0 )+ ( (B2[10]) ? A2 << ( 10 - 1 ) : 0 )+ ( (B2[11]) ? A2 << ( 11 - 1 ) : 0 )+ ( (B2[12]) ? A2 << ( 12 - 1 ) : 0 )+ ( (B2[13]) ? A2 << ( 13 - 1 ) : 0 )+ ( (B2[14]) ? A2 << ( 14 - 1 ) : 0 )+ ( (B2[15]) ? A2 << ( 15 - 1 ) : 0 )+ ( (B2[16]) ? A2 << ( 16 - 1 ) : 0 )); \n assign out = flag[1] ? -temp[width+half+1:half+1] : temp[width+half+1:half+1]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `alt_vipvfr131_common_unpack_data` takes in a 128-bit data input and processes it to produce a 24-bit output. It generates a read signal, accepts a stall signal, and outputs a write signal. The module utilizes a width adapter `alt_vipvfr131_common_pulling_width_adapter` and employs clock and reset signals for synchronization. The reset circuit sets the write signal to 0, and the write signal is driven by the enable signal when the stall_out signal is low.\n\n Module header:\n\nmodule alt_vipvfr131_common_unpack_data ( clock,reset,data_in,read,stall_in,data_out,write,stall_out,clear);\n [/INST]\n", "output": "parameter DATA_WIDTH_IN = 128; \n parameter DATA_WIDTH_OUT = 24; \n input clock; \n input reset; \n input [DATA_WIDTH_IN - 1 : 0] data_in; \n output read; \n input stall_in; \n input stall_out; \n output reg write; \n output [DATA_WIDTH_OUT - 1:0] data_out; \n input clear; \n wire need_input; \n wire ena; \n assign ena = ~stall_in; \n assign read = need_input; \n alt_vipvfr131_common_pulling_width_adapter \n #(.IN_WIDTH (DATA_WIDTH_IN),.OUT_WIDTH (DATA_WIDTH_OUT)) \n fu_inst \n ( .clock (clock),.reset (reset),.input_data (data_in),.need_input (need_input),.output_data (data_out),.pull (1'b1),.pull_en (~stall_out),.discard (1'b1),.discard_en (clear),.ena (ena)); \n always @(posedge clock or posedge reset) \n  if (reset) begin \n  write <= 1'b0; \n  end \n  else if (~stall_out) begin \n  write <= ena; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, \"Latch_Index_Pulse,\" implements a latch with an input enable signal. It takes inputs CLK_IN, reset, enb, and In1 and produces the output Out1. It features a delay process triggered by a positive edge of the CLK_IN signal. The output, Delay_out1, changes based on the reset and enb signals. Additionally, it has a switch, Switch_out1, which selects either the input In1 or a constant value based on the Delay_out1 signal. Finally, the module outputs Switch_out1 as Out1.\n\n Module header:\n\nmodule Latch_Index_Pulse (CLK_IN,reset,enb,In1,Out1);\n [/INST]\n", "output": "input CLK_IN; \n  input reset; \n  input enb; \n  input In1; \n  output Out1; \n  wire Constant1_out1; \n  wire Switch_out1; \n  reg Delay_out1; \n  assign Constant1_out1 = 1'b1; \n  always @(posedge CLK_IN) \n  begin : Delay_process \n  if (reset == 1'b1) begin \n  Delay_out1 <= 1'b0; \n  end \n  else if (enb) begin \n  Delay_out1 <= Switch_out1; \n  end \n  end \n assign Switch_out1 = (Delay_out1 == 1'b0 ? In1 :Constant1_out1); \n  assign Out1 = Switch_out1; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `v9a2795` takes a 3-bit input `vdee7c7` and produces 3 outputs `vda577d`, `v3f8943`, and `v64d863`. It instantiates another module `v9a2795_v9a2a06` which processes the input and generates the outputs. The module contains wire declarations and assigns the inputs to the outputs based on certain conditions.\n\n Module header:\n\nmodule v9a2795 (input [2:0] vdee7c7,output vda577d,output v3f8943,output v64d863);\n [/INST]\n", "output": "wire w0; \n  wire w1; \n  wire [0:2] w2; \n  wire w3; \n  assign v3f8943 = w0; \n  assign v64d863 = w1; \n  assign w2 = vdee7c7; \n  assign vda577d = w3; \n v9a2795_v9a2a06 v9a2a06 (.o1(w0),.o0(w1),.i(w2),.o2(w3)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module instantiates a memory system and connects it to input signals such as clock, read enable, write enable, multiple write enables, address, and write data. The module controls the memory system by toggling these input signals at specific time intervals. It simulates various scenarios such as writing and reading data to and from specific memory addresses, setting dirty flags, and testing hit or miss conditions within the memory system.\n\n Module header:\n\nmodule testcache();\n [/INST]\n", "output": "reg clk; \n  reg re, we, we2, we3; \n  reg [31:0] address, writedata; \n  wire [31:0] readdatacache,readmissdata; \n  wire hit, miss, dirty; \n  memory_system DUT(clk, re, we, we2, we3, address, writedata, readdatacache, hit, miss, dirty); \n  always begin \n  clk <= 1; \n  #5; \n  clk <= 0; \n  # 5; \n  end \n  initial begin \n  re <= 1'b0; \n  we <= 1'b1; \n  we2 <= 1'b0; \n  we3 <= 1'b0; \n  address <= 32'h00004012; \n  writedata <= 32'h12345678; \n  #10; \n  we <= 1'b0; \n  #200; \n  we2 <= 1'b1; \n  #5; \n  we2 <= 1'b0; \n  #5; \n  re <= 1'b1; \n  we <= 1'b0; \n  we2 <= 1'b0; \n  we3 <= 1'b0; \n  address <= 32'h00004012; \n  writedata <= 32'hxxxxxxxx; \n  #10; \n  re <= 1'b0; \n  #10; \n  re <= 1'b1; \n  we <= 1'b0; \n  we2 <= 1'b0; \n  we3 <= 1'b0; \n  address <= 32'h00008012; \n  writedata <= 32'hxxxxxxxx; \n  #10; \n  re <= 1'b0; \n  #200; \n  we3 <= 1'b1; \n  #5; \n  we3 <= 1'b0; \n  #20; \n  re <= 1'b0; \n  we <= 1'b1; \n  we2 <= 1'b0; \n  we3 <= 1'b0; \n  address <= 32'h00008011; \n  writedata <= 32'h87654321; \n  #10; \n  we <= 1'b0; \n  #200; \n  re <= 1'b0; \n  we <= 1'b1; \n  we2 <= 1'b0; \n  we3 <= 1'b0; \n  address <= 32'h00008010; \n  writedata <= 32'h01010101; \n  #10; \n  we <= 1'b0; \n  #200; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is designed to set black as transparent in a VGA subsystem. It takes input stream data, start of packet, end of packet, and valid signals, and outputs ready, data, start of packet, end of packet, and valid signals. The module also has a clock and reset input. Inside, it initializes the output stream when reset is asserted and updates the output stream based on the input stream and readiness. The module also includes logic to convert input data based on the color and alpha channel.\n\n Module header:\n\nmodule Computer_System_VGA_Subsystem_Char_Buf_Subsystem_Set_Black_Transparent (clk,reset,stream_in_data,stream_in_startofpacket,stream_in_endofpacket,stream_in_valid,stream_in_ready,stream_out_ready,stream_out_data,stream_out_startofpacket,stream_out_endofpacket,stream_out_valid);\n [/INST]\n", "output": "parameter CW = 29; \n parameter DW = 39; \n parameter COLOR = 30'd0; \n parameter ALPHA = 10'd0; \n input clk; \n input reset; \n input [DW: 0] stream_in_data; \n input stream_in_startofpacket; \n input stream_in_endofpacket; \n input stream_in_valid; \n output stream_in_ready; \n input stream_out_ready; \n output reg [DW: 0] stream_out_data; \n output reg stream_out_startofpacket; \n output reg stream_out_endofpacket; \n output reg stream_out_valid; \n wire [DW: 0] converted_data; \n always @(posedge clk) \n begin \n  if (reset) \n  begin \n  stream_out_data <= 'b0; \n  stream_out_startofpacket <= 1'b0; \n  stream_out_endofpacket <= 1'b0; \n  stream_out_valid <= 1'b0; \n  end \n  else if (stream_out_ready | ~stream_out_valid) \n  begin \n  stream_out_data <= converted_data; \n  stream_out_startofpacket <= stream_in_startofpacket; \n  stream_out_endofpacket <= stream_in_endofpacket; \n  stream_out_valid <= stream_in_valid; \n  end \n end \n assign stream_in_ready = stream_out_ready | ~stream_out_valid; \n assign converted_data = (stream_in_data[CW:0] == COLOR) ? \n  {ALPHA, stream_in_data[CW:0]} : \n  stream_in_data; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a multiplexer for switching data between a GPIO interface and an SDRAM interface based on the write enable signal and the most significant bit of the write address. If the write enable signal is high, the module checks the most significant bit of the write address. If it is high, the module assigns the write data to the GPIO output and sets the output enable signal for the SDRAM. If the most significant bit of the write address is low, the module initializes the GPIO output and assigns the write data to the SDRAM output. If the write enable signal is low, the module initializes the GPIO output and the SDRAM output.\n\n Module header:\n\nmodule mux_sdram #(parameter DATA_WIDTH = 32,parameter ADDR_WIDTH = 32) (input wr_en,input [DATA_WIDTH-1:0] wr_data,input [ADDR_WIDTH-1:0] wr_address,output reg [DATA_WIDTH-1:0] wr_data_gpio,output reg we_gpio,output reg [DATA_WIDTH-1:0] wr_data_sdram,output reg wr_en_sdram);\n [/INST]\n", "output": "always @(*) begin \n  if (wr_en) begin \n  if(wr_address[ADDR_WIDTH-1]==1) begin \n  wr_data_gpio = wr_data; \n  we_gpio =1; \n  wr_en_sdram = 0; \n  wr_data_sdram = {DATA_WIDTH{1'b0}}; \n  end \n  else begin \n  wr_data_gpio = {DATA_WIDTH{1'b0}}; \n  we_gpio = 0; \n  wr_en_sdram = 1; \n  wr_data_sdram = wr_data; \n  end \n  end \n  else begin \n  wr_data_gpio = {DATA_WIDTH{1'b0}}; \n  wr_en_sdram = 0; \n  wr_data_sdram = {DATA_WIDTH{1'b0}}; \n  we_gpio = 0; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module includes a register and a latch, with the register taking in clock, enable, and data inputs to produce an output, and the latch taking in enable and data inputs to produce an output. The module includes logic to toggle the clock and enable signals at specific time intervals, and to increment the data signal. The register and latch are implemented using specific flip-flop and latch modules from the CC_DFlipFlop and CC_DLatch classes, respectively.\n\n Module header:\n\nmodule RegLatchTest;\n [/INST]\n", "output": "reg en, clk; \n  reg [3:0] data; \n  wire [3:0] rout; \n  wire [3:0] lout; \n  CC_DFlipFlop #(4) register(clk, en, data, rout); \n  CC_DLatch #(4) latch(en, data, lout); \n  initial begin \n  en = 0; \n  data = 'b0; \n  clk = 0; \n  end \n  always \n  #1 clk = ~clk; \n  always \n  #4 en = ~en; \n  always \n  #2 data = data + 1; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements an arbitration logic for granting access to shared resources. It uses a 3-bit state machine to handle different request and grant signals. The module responds to various input signals such as crt_req, cpu_rd_req, cpu_wr_req, a_empty, and b_empty to determine the next state and control the grant signals. The state machine transitions between different states to handle the priority-based arbitration for CPU read, CPU write, and CRT requests. The granted signals, crt_gnt, cpu_wr_gnt, and cpu_rd_gnt, are set based on the current state and input conditions, ensuring that only one request is granted at a time based on predefined priority rules.\n\n Module header:\n\nmodule sm_arb (input mem_clk,input hreset_n,input crt_req,input cpu_rd_req,input cpu_wr_req,input a_empty,input b_empty,input a_full_done,input b_full_done,input sync_crt_line_end,output reg crt_gnt,output reg cpu_wr_gnt,output reg cpu_rd_gnt);\n [/INST]\n", "output": "reg [2:0] current_state; \n  reg [2:0] next_state; \n  parameter arb_state0 = 3'd0, \n  arb_state2 = 3'd2, \n  arb_state3 = 3'd3, \n  arb_state4 = 3'd4, \n  arb_state5 = 3'd5, \n  arb_state6 = 3'd6; \n  always @(posedge mem_clk or negedge hreset_n) begin \n  if (!hreset_n) current_state <= arb_state0; \n  else current_state <= next_state; \n  end \n  always @* begin \n  crt_gnt = 1'b0; \n  cpu_wr_gnt = 1'b0; \n  cpu_rd_gnt = 1'b0; \n  case (current_state) \n  arb_state0: begin \n  if (crt_req) next_state = arb_state2; \n  else if (cpu_wr_req) next_state = arb_state3; \n  else if (cpu_rd_req) next_state = arb_state4; \n  else next_state = arb_state0; \n  end \n  arb_state2: begin \n  if (a_empty) next_state = arb_state5; \n  else if (b_empty) next_state = arb_state6; \n  else next_state = arb_state0; \n  end \n  arb_state3: begin \n  cpu_wr_gnt = 1'b1; \n  if (~cpu_wr_req) next_state = arb_state0; \n  else next_state = arb_state3; \n  end \n  arb_state4: begin \n  cpu_rd_gnt = 1'b1; \n  if (~cpu_rd_req) next_state = arb_state0; \n  else next_state = arb_state4; \n  end \n  arb_state5: begin \n  crt_gnt = 1'b1; \n  if (a_full_done | sync_crt_line_end) next_state = arb_state0; \n  else next_state = arb_state5; \n  end \n  arb_state6: begin \n  crt_gnt = 1'b1; \n  if (b_full_done | sync_crt_line_end) next_state = arb_state0; \n  else next_state = arb_state6; \n  end \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"sine\" takes a 21-bit input \"phase\" and produces a 16-bit output \"sine_out\". It contains internal wires and functions for ROM addressing, leap year coefficient, and signed sine computation. The module uses these components to calculate the sine output based on the input phase, and includes instantiation of sin_rom and diff_rom modules to generate the sine and difference outputs.\n\n Module header:\n\nmodule sine (phase,sine_out);\n [/INST]\n", "output": "input wire [20:0] phase; \n  output wire [15:0] sine_out; \n  wire [8:0] rom_adrs; \n  wire [9:0] leap_coeff; \n  wire [15:0] sin_rom_out; \n  wire [15:0] diff_rom_out; \n  wire [25:0] leap_add_p; \n  wire [15:0] leap_add; \n  wire [15:0] signed_sine; \n  function [8:0] adrs_conv; \n  input [8:0] adrs_p; \n  input sel; \n  begin \n  case(sel) \n  0 : adrs_conv = adrs_p; \n  1 : adrs_conv = 9'H1FF - adrs_p; \n  default : adrs_conv = 9'bxxxxxxxxx; \n  endcase \n  end \n  endfunction \n  function [9:0] leap_conv; \n  input [9:0] leap_p; \n  input sel; \n  begin \n  case(sel) \n  0 : leap_conv = leap_p; \n  1 : leap_conv = 10'H2FF - leap_p; \n  default : leap_conv = 10'bxxxxxxxxxx; \n  endcase \n  end \n  endfunction \n  function [15:0] quad3_4; \n  input [15:0] signed_sine; \n  input sel; \n  begin \n  case(sel) \n  0 : quad3_4 = signed_sine >> 1; \n  1 : quad3_4 = ~(signed_sine >> 1) + 1'b1; \n  default : quad3_4 = 16'bxxxxxxxxxxxxxxxx; \n  endcase \n  end \n  endfunction \n  assign leap_add_p = diff_rom_out * leap_coeff; \n  assign leap_add = leap_add_p[25:9]; \n  assign signed_sine = sin_rom_out[15:0] + leap_add[15:0]; \n  assign rom_adrs = adrs_conv(phase[18:10], phase[19]); \n  assign leap_coeff = leap_conv(phase[9:0], phase[19]); \n  assign sine_out = quad3_4(signed_sine, phase[20]); \n sin_rom sin_rom_i(.inadrs(rom_adrs),.outsine(sin_rom_out)); \n diff_rom diff_rom_i(.inadrs(rom_adrs),.outdiff(diff_rom_out)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module, named display_regs, acts as a memory-mapped register file. It has 8-bit input and output ports, with four separate output segments named segment0 to segment3. The module allows writing to each segment independently and reading the selected segment's data to the output port. It operates based on the clock signal and write and read strobes, and it uses a base address for each segment to identify the specific segment being accessed.\n\n Module header:\n\nmodule display_regs (data_out, segment0, segment1, segment2, segment3,clk, reset, port_id, data_in, read_strobe, write_strobe);\n [/INST]\n", "output": "parameter BASE_ADDRESS = 8'h00; \n  input clk; \n  input reset; \n  input [7:0] port_id; \n  input [7:0] data_in; \n  output [7:0] data_out; \n  input read_strobe; \n  input write_strobe; \n  output [7:0] segment0; \n  output [7:0] segment1; \n  output [7:0] segment2; \n  output [7:0] segment3; \n  reg [3:0] segment0 = 4'h0; \n  reg [3:0] segment1 = 4'h0; \n  reg [3:0] segment2 = 4'h0; \n  reg [3:0] segment3 = 4'h0; \n  reg [7:0] data_out = 8'h00; \n  wire segment0_enable = (port_id == (BASE_ADDRESS + 0)); \n  wire segment1_enable = (port_id == (BASE_ADDRESS + 1)); \n  wire segment2_enable = (port_id == (BASE_ADDRESS + 2)); \n  wire segment3_enable = (port_id == (BASE_ADDRESS + 3)); \n  always @(posedge clk) \n  if (write_strobe) begin \n  if (segment0_enable) begin \n  segment0 <= data_in; \n  end \n  if (segment1_enable) begin \n  segment1 <= data_in; \n  end \n  if (segment2_enable) begin \n  segment2 <= data_in; \n  end \n  if (segment3_enable) begin \n  segment3 <= data_in; \n  end \n  end \n  always @(posedge clk) begin \n  if (segment0_enable) begin \n  data_out[3:0] <= segment0[3:0]; \n  end \n  else if (segment1_enable) begin \n  data_out[3:0] <= segment1[3:0]; \n  end \n  else if (segment2_enable) begin \n  data_out[3:0] <= segment2[3:0]; \n  end \n  else if (segment3_enable) begin \n  data_out[3:0] <= segment3[3:0]; \n  end \n  else begin \n  data_out <= 8'h00; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a generic n x n matrix multiplier. It has an input of two n-bit vectors and produces a 2n-bit output. The module uses recursive instantiation for smaller multipliers when n is greater than 2, and calculates the result using additions and concatenations. The module has specific logic for handling the partitioning and multiplication of the input vectors, which allows for efficient parallel processing and recursive decomposition of larger multipliers into smaller multipliers.\n\n Module header:\n\nmodule UDM_nxnB #(parameter W=2) (input wire [W-1:0] in1,input wire [W-1:0] in2,output wire [2*W-1:0] res);\n [/INST]\n", "output": "wire [W/2-1:0] L_in1; \n wire [W/2-1:0] R_in1; \n wire [W/2-1:0] L_in2; \n wire [W/2-1:0] R_in2; \n generate \n  if (W==2) begin : SmallBLOCK \n  wire [2:0] temp_res; \n  UDM_2x2 UDM_2x2 (.in1(in1), .in2(in2), .res(temp_res)); \n  assign res = {1'b0, temp_res}; \n  end else begin : BIGBLOCK \n  assign L_in1 = in1[W-1:W/2]; \n  assign R_in1 = in1[W/2-1:0]; \n  assign L_in2 = in2[W-1:W/2]; \n  assign R_in2 = in2[W/2-1:0]; \n  wire [W-1:0] res_Lin1Lin2; \n  wire [W-1:0] res_Hin1Lin2; \n  wire [W-1:0] res_Lin1Hin2; \n  wire [W-1:0] res_Hin1Hin2; \n  UDM_nxnB #(.W(W/2)) A_LxB_L (.in1(R_in1), .in2(R_in2), .res(res_Lin1Lin2)); \n  UDM_nxnB #(.W(W/2)) A_HxB_L (.in1(L_in1), .in2(R_in2), .res(res_Hin1Lin2)); \n  UDM_nxnB #(.W(W/2)) A_LxB_H (.in1(R_in1), .in2(L_in2), .res(res_Lin1Hin2)); \n  UDM_nxnB #(.W(W/2)) A_HxB_H (.in1(L_in1), .in2(L_in2), .res(res_Hin1Hin2)); \n  assign res = {res_Hin1Hin2, {W{1'b0}}} + {res_Hin1Lin2, {(W/2){1'b0}}} + {res_Lin1Hin2, {(W/2){1'b0}}} + {{W{1'b0}}, res_Lin1Lin2}; \n  end \n endgenerate \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module assigns a constant value of 0 to the output \"op\" when the clock signal \"clk\" and the control enable \"ce\" are active, and when the clear signal \"clr\" is inactive.\n\n Module header:\n\nmodule sysgen_constant_9b3be16c34 (output [(1 - 1):0] op,input clk,input ce,input clr);\n [/INST]\n", "output": "assign op = 1'b0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a stage 1 fetch unit for a processor. It has inputs for clock, reset, stall, and branch-related signals, as well as an input for memory data. The module outputs an instruction register, the next program counter, and a memory address for fetching the next instruction.\n\nThe module contains a 30-bit program counter register, which is initialized to 0 at the start. The next program counter is calculated based on whether a branch is taken or not. The memory address for the next instruction is determined based on the next program counter. The instruction register is simply the memory data input.\n\nThe module's behavior is controlled by a clocked always block that resets the program counter and a \"re\" output when the reset signal is active. Otherwise, when there is no stall, the program counter is updated to the next program counter, and \"re\" is set to 1.\n\n Module header:\n\nmodule stage1_fetch(input clk_i,input rst_i,input stall_i,input take_branch_i,input [29:0] branch_pc_i,output [31:0] ir_o,output [29:0] nextpc_o,output reg re_o,output [29:0] rmemaddr_o,input [31:0] rmemdata_i);\n [/INST]\n", "output": "reg [29:0] pc; \n initial begin \n  pc = 0; \n end \n assign nextpc_o = take_branch_i ? branch_pc_i : pc + 30'b1; \n assign rmemaddr_o = nextpc_o; \n assign ir_o = rmemdata_i; \n always @(posedge clk_i) \n begin \n  re_o = 0; \n  if (rst_i) begin \n  pc <= 30'b111111111111111111111111111111; \n  re_o = 1; \n  end else if (!stall_i) begin \n  pc <= nextpc_o; \n  re_o = 1; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module 'edc_corrector' is designed to perform error detection and correction on input data. It consists of a decoder matrix and an error vector to check for errors in the input data. The 'o_error_detected' signal indicates if any errors are detected, and 'o_uncorrected_error' identifies uncorrected errors. The output data 'o_data' is the result of XORing the error vector with the input data. This module effectively detects and corrects errors in the input data using the decoder matrix and error vector.\n\n Module header:\n\nmodule edc_corrector (input [31:0] i_data,input [7:0] i_syndrome,output [31:0] o_data,output o_error_detected,output o_uncorrected_error);\n [/INST]\n", "output": "wire [7:0] decoder_matrix[0:39]; \n wire [39:0] error_vector; \n generate \n  assign decoder_matrix[39] = 8'b10101000; \n  assign decoder_matrix[38] = 8'b01101000; \n  assign decoder_matrix[37] = 8'b10100100; \n  assign decoder_matrix[36] = 8'b01100100; \n  assign decoder_matrix[35] = 8'b10100010; \n  assign decoder_matrix[34] = 8'b01100010; \n  assign decoder_matrix[33] = 8'b10100001; \n  assign decoder_matrix[32] = 8'b01100001; \n  assign decoder_matrix[31] = 8'b10011000; \n  assign decoder_matrix[30] = 8'b01011000; \n  assign decoder_matrix[29] = 8'b10010100; \n  assign decoder_matrix[28] = 8'b01010100; \n  assign decoder_matrix[27] = 8'b10010010; \n  assign decoder_matrix[26] = 8'b01010010; \n  assign decoder_matrix[25] = 8'b10010001; \n  assign decoder_matrix[24] = 8'b01010001; \n  assign decoder_matrix[23] = 8'b10001010; \n  assign decoder_matrix[22] = 8'b10001001; \n  assign decoder_matrix[21] = 8'b01001010; \n  assign decoder_matrix[20] = 8'b01001001; \n  assign decoder_matrix[19] = 8'b00101010; \n  assign decoder_matrix[18] = 8'b00101001; \n  assign decoder_matrix[17] = 8'b00011010; \n  assign decoder_matrix[16] = 8'b00011001; \n  assign decoder_matrix[15] = 8'b10000110; \n  assign decoder_matrix[14] = 8'b10000101; \n  assign decoder_matrix[13] = 8'b01000110; \n  assign decoder_matrix[12] = 8'b01000101; \n  assign decoder_matrix[11] = 8'b00100110; \n  assign decoder_matrix[10] = 8'b00100101; \n  assign decoder_matrix[9] = 8'b00010110; \n  assign decoder_matrix[8] = 8'b00010101; \n  assign decoder_matrix[7] = 8'b10000000; \n  assign decoder_matrix[6] = 8'b01000000; \n  assign decoder_matrix[5] = 8'b00100000; \n  assign decoder_matrix[4] = 8'b00010000; \n  assign decoder_matrix[3] = 8'b00001000; \n  assign decoder_matrix[2] = 8'b00000100; \n  assign decoder_matrix[1] = 8'b00000010; \n  assign decoder_matrix[0] = 8'b00000001; \n endgenerate \n genvar c; \n generate \n  for (c=0; c<40; c=c+1) begin \n  assign error_vector[c] = decoder_matrix[c] == i_syndrome; \n  end \n endgenerate \n assign o_error_detected = | i_syndrome; \n assign o_uncorrected_error = o_error_detected & (~| error_vector); \n assign o_data = error_vector[39:8] ^ i_data; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a character generator that takes in various control signals such as clk, pixclk, chrcode, chrrow, chrcol, attcode_in, blank_in, hsync_in, vsync_in, and blink_in and generates pixel and attribute code outputs along with blank, horizontal sync, vertical sync, and blink outputs. \n\nThe module utilizes a Character ROM to generate the pixel output based on the character code, row, and column inputs. It also updates the attribute code, blank, horizontal sync, vertical sync, and blink outputs based on the pixclk input. The module contains a mux control register to select between the lower and upper halves of the character ROM based on the most significant bit of the character code.\n\n Module header:\n\nmodule chrgen(clk, pixclk,chrcode, chrrow, chrcol,pixel,attcode_in, blank_in, hsync_in, vsync_in, blink_in,attcode_out, blank_out, hsync_out, vsync_out, blink_out);\n [/INST]\n", "output": "input clk; \n  input pixclk; \n  input [7:0] chrcode; \n  input [3:0] chrrow; \n  input [2:0] chrcol; \n  output pixel; \n  input [7:0] attcode_in; \n  input blank_in; \n  input hsync_in; \n  input vsync_in; \n  input blink_in; \n  output reg [7:0] attcode_out; \n  output reg blank_out; \n  output reg hsync_out; \n  output reg vsync_out; \n  output reg blink_out; \n  wire [13:0] addr; \n  wire [0:0] pixel_lo; \n  wire [0:0] pixel_hi; \n  reg mux_ctrl; \n  assign addr[13:7] = chrcode[6:0]; \n  assign addr[6:3] = chrrow[3:0]; \n  assign addr[2:0] = chrcol[2:0]; \n  assign pixel = (mux_ctrl == 0) ? pixel_lo[0] : pixel_hi[0]; \n RAMB16_S1 character_rom_lo (.DO(pixel_lo),.ADDR(addr),.CLK(clk),.DI(1'b0),.EN(pixclk),.SSR(1'b0),.WE(1'b0)); \n RAMB16_S1 character_rom_hi (.DO(pixel_hi),.ADDR(addr),.CLK(clk),.DI(1'b0),.EN(pixclk),.SSR(1'b0),.WE(1'b0)); \n  always @(posedge clk) begin \n  if (pixclk == 1) begin \n  attcode_out[7:0] <= attcode_in[7:0]; \n  blank_out <= blank_in; \n  hsync_out <= hsync_in; \n  vsync_out <= vsync_in; \n  blink_out <= blink_in; \n  mux_ctrl <= chrcode[7]; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module serves as an interface to access 16 registers, starting from address 3, with the first command register at address 3 and consecutive addresses for the subsequent command registers. The mode register is placed at address 11, the CRC error register at address 14, and the version register at address 15. The module enables writing and reading data to and from the registers based on the select and read/write signals. Additionally, it connects the version register to the BUILD_VERSION variable and updates the mb_reg_output variable based on the interface_from_core_fp signal.\n\n Module header:\n\nmodule x;\n [/INST]\n", "output": "reg [31:0] mb_reg_output; \n  parameter NUMBER_INTERFACE_REGS = 16; \n  parameter MB_REG_START = 3; \n  parameter CMD_REG_0_ADDR = MB_REG_START; \n  parameter CMD_REG_1_ADDR = MB_REG_START+1; \n  parameter CMD_REG_2_ADDR = MB_REG_START+2; \n  parameter CMD_REG_3_ADDR = MB_REG_START+3; \n  parameter CMD_REG_4_ADDR = MB_REG_START+4; \n  parameter CMD_REG_5_ADDR = MB_REG_START+5; \n  parameter CMD_REG_6_ADDR = MB_REG_START+6; \n  parameter CMD_REG_7_ADDR = MB_REG_START+7; \n  parameter CMD_REG_8_ADDR = MB_REG_START+8; \n  parameter CMD_REG_9_ADDR = MB_REG_START+9; \n  parameter CMD_REG_10_ADDR = MB_REG_START+10; \n  parameter MODE_REG_0_ADDR = CMD_REG_8_ADDR; \n  parameter CMD_REG_14_ADDR = 14; \n  parameter CRC_ERROR_REG_ADDR = CMD_REG_14_ADDR; \n  parameter VERSION_REG_ADDR = 15; \n  reg [NUMBER_INTERFACE_REGS-1:MB_REG_START] mb_reg_wr; \n  reg [NUMBER_INTERFACE_REGS-1:MB_REG_START] mb_reg_rd; \n  wire [31:0] mb_reg_out_w [NUMBER_INTERFACE_REGS-1:MB_REG_START]; \n  wire [31:0] interface_from_core_fp; \n  assign \n  mb_reg_out_w[VERSION_REG_ADDR] = BUILD_VERSION; \n  integer mb_loop; \n  always @( interface_from_core_fp or mb_reg_rwn or mb_reg_select) \n  begin: MB_READ_WRITE_SEL_P \n  mb_reg_wr = 'h0; \n  mb_reg_rd = 'h0; \n  mb_reg_output = interface_from_core_fp; \n  for(mb_loop = MB_REG_START; mb_loop < NUMBER_INTERFACE_REGS; mb_loop=mb_loop+1) \n  begin \n  if(mb_reg_select[mb_loop] == 1'b1) \n  begin \n  mb_reg_rd[mb_loop] = mb_reg_select[mb_loop] & mb_reg_rwn; \n  mb_reg_wr[mb_loop] = mb_reg_select[mb_loop] & !mb_reg_rwn; \n  mb_reg_output = mb_reg_out_w[mb_loop]; \n  end \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, named \"registros_salida,\" implements a synchronous register with various control signals and data paths. It operates on the positive edge of the clock signal and handles reset conditions. The module responds to various input signals such as Write_Strobe, Out_Port, Port_ID, rst, and reset to control the outputs Dir, Dato, direccion, contro_listo, contro_lee, contro_escribe, and bandera. The module contains conditional logic that manipulates these signals based on the input conditions and control states.\n\n Module header:\n\nmodule registros_salida(input Write_Strobe,input [7:0] Out_Port,input [7:0] Port_ID,input rst ,input reset,input clk,output reg [7:0] Dir,output reg [7:0] Dato,output reg [3:0] direccion,output reg contro_listo,output reg contro_lee,output reg contro_escribe,output reg [2:0]bandera);\n [/INST]\n", "output": "always @(posedge clk ) \n  if (reset) \n  begin \n  contro_listo<=1'b0; \n  contro_escribe<=1'b0; \n  contro_lee<=1'b0; \n  Dir<=8'b00000000; \n  Dato<=8'b00000000; \n  direccion<=4'b0000; \n  bandera<=3'b0; \n  end \n  else \n  begin \n  if (Write_Strobe) \n  begin \n  case (Port_ID) \n  8'b00000001 : \n  begin \n  if (rst) \n  contro_listo<=1'b0; \n  else \n  begin \n  if (Out_Port==8'b00000001) \n  begin \n  contro_listo<=1'b1; \n  contro_lee<=1'b0; \n  contro_escribe<=1'b0; \n  end \n  else \n  begin \n  contro_listo<=1'b0; \n  contro_lee<=contro_lee; \n  contro_escribe<=contro_escribe; \n  end \n  end \n  end \n  8'b00000010 : \n  begin \n  if (rst) \n  contro_escribe<=1'b0; \n  else \n  begin \n  if (Out_Port==8'b00000001) \n  begin \n  contro_escribe<=1'b1; \n  contro_lee<=1'b0; \n  contro_listo<=1'b0; \n  end \n  else \n  begin \n  contro_escribe<=1'b0; \n  contro_lee<=contro_lee; \n  contro_listo<=contro_listo; \n  end \n  end \n  end \n  8'b00000011 : \n  begin \n  if (rst) \n  contro_lee<=1'b0; \n  else \n  begin \n  if (Out_Port==8'b00000001) \n  begin \n  contro_lee<=1'b1; \n  contro_listo<=1'b0; \n  contro_escribe<=1'b0; \n  end \n  else \n  begin \n  contro_lee<=1'b0; \n  contro_listo<=contro_listo; \n  contro_escribe<=contro_escribe; \n  end end \n  end \n  8'b00000100 : Dato<=Out_Port; \n  8'b00000101 : begin \n  Dir<=Out_Port; \n  if(Out_Port==8'hf1) \n  bandera<=3'b1; \n  else \n  bandera<=3'b0; \n  end \n  8'b00000110 : \n  begin \n  case(Out_Port) \n  8'b00000000: direccion<=4'b0000; \n  8'b00000001: direccion<=4'b0001; \n  8'b00000010: direccion<=4'b0010; \n  8'b00000011: direccion<=4'b0011; \n  8'b00000100: direccion<=4'b0100; \n  8'b00000101: direccion<=4'b0101; \n  8'b00000110: direccion<=4'b0110; \n  8'b00000111: direccion<=4'b0111; \n  8'b00001000: direccion<=4'b1000; \n  default: direccion<=direccion; \n  endcase \n  end \n  default : \n  begin \n  contro_listo<=contro_listo; \n  contro_lee<=contro_lee; \n  contro_escribe<=contro_escribe; \n  direccion<=direccion; \n  Dir<=Dir; \n  Dato<=Dato; \n  bandera<=bandera; \n  end \n  endcase \n  end \n  else \n  if (rst) \n  begin \n  contro_listo<= 1'b0; \n  contro_lee <= 1'b0; \n  contro_escribe<=1'b0; \n  end \n  else \n  begin \n  contro_listo<=contro_listo; \n  contro_lee <=contro_lee; \n  contro_escribe<=contro_escribe; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a serial asynchronous receiver that receives data on the rxd input and extracts the received data, indicating when the data is ready, the end of a packet, and the idle state. The module also includes a state machine to handle the received bits and to detect the timing gaps between packets. The received data is stored in the rxd_data register, which is updated when a full byte of data is received. The module also tracks the bit spacing, counts the gaps between packets, and handles the detection of the end of a packet and the idle state.\n\n Module header:\n\nmodule serial_arx (input clk,input rxd,input baud8tick,output reg [7:0] rxd_data,output reg rxd_data_ready,output reg rxd_endofpacket,output rxd_idle);\n [/INST]\n", "output": "reg [1:0] rxd_sync_inv; \n  always @(posedge clk) if(baud8tick) rxd_sync_inv <= {rxd_sync_inv[0], ~rxd}; \n  reg [1:0] rxd_cnt_inv; \n  reg rxd_bit_inv; \n  always @(posedge clk) \n  if(baud8tick) begin \n  if( rxd_sync_inv[1] && rxd_cnt_inv!=2'b11) rxd_cnt_inv <= rxd_cnt_inv + 2'h1; \n  else \n  if(~rxd_sync_inv[1] && rxd_cnt_inv!=2'b00) rxd_cnt_inv <= rxd_cnt_inv - 2'h1; \n  if(rxd_cnt_inv==2'b00) rxd_bit_inv <= 1'b0; \n  else \n  if(rxd_cnt_inv==2'b11) rxd_bit_inv <= 1'b1; \n  end \n  reg [3:0] state; \n  reg [3:0] bit_spacing; \n  wire next_bit = (bit_spacing==4'd10); \n  always @(posedge clk) \n  if(state==0)bit_spacing <= 4'b0000; \n  else \n  if(baud8tick) bit_spacing <= {bit_spacing[2:0] + 4'b0001} | {bit_spacing[3], 3'b000}; \n  always @(posedge clk) \n  if(baud8tick) \n  case(state) \n  4'b0000: if(rxd_bit_inv)state <= 4'b1000; \n  4'b1000: if(next_bit) state <= 4'b1001; \n  4'b1001: if(next_bit) state <= 4'b1010; \n  4'b1010: if(next_bit) state <= 4'b1011; \n  4'b1011: if(next_bit) state <= 4'b1100; \n  4'b1100: if(next_bit) state <= 4'b1101; \n  4'b1101: if(next_bit) state <= 4'b1110; \n  4'b1110: if(next_bit) state <= 4'b1111; \n  4'b1111: if(next_bit) state <= 4'b0001; \n  4'b0001: if(next_bit) state <= 4'b0000; \n  default: state <= 4'b0000; \n  endcase \n  always @(posedge clk) \n  if(baud8tick && next_bit && state[3]) rxd_data <= {~rxd_bit_inv, rxd_data[7:1]}; \n  always @(posedge clk) \n  begin \n  rxd_data_ready <= (baud8tick && next_bit && state==4'b0001 && ~rxd_bit_inv); \n  end \n  reg [4:0] gap_count; \n  always @(posedge clk) if (state!=0) gap_count<=5'h00; else if(baud8tick & ~gap_count[4]) gap_count <= gap_count + 5'h01; \n  assign rxd_idle = gap_count[4]; \n  always @(posedge clk) rxd_endofpacket <= baud8tick & (gap_count==5'h0F); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe \"stego_decode\" module is designed to decode a steganographic message from an input data stream. It utilizes various signals and registers to process the input data, and generates the decoded message as the output. The module synchronizes and processes the input data based on the clock signal and reset conditions, while also considering the state of certain control signals, such as \"start\". Additionally, it involves arithmetic operations on the input data and intermediate signals to compute the decoded message. The module employs a counter to track the progress of the decoding process and control the output generation. Finally, it instantiates an MDCT module to perform specific operations as part of the decoding process.\n\n Module header:\n\nmodule stego_decode(clk, rst, start, data_in, message, rdy);\n [/INST]\n", "output": "output rdy, message; \n input clk, rst, start; \n input [7:0] data_in; \n wire rdy; \n wire message; \n wire [11:0] dct; \n wire rdy_i; \n reg rdy_i_d1; \n reg rdy_i_d2; \n reg rdy_i_d3; \n reg signed [8:0] Q_1 = {9'd228}; \n reg signed [11:0] dct_signed; \n reg signed [20:0] dct_q_i_0; \n reg signed [20:0] dct_q_i_1; \n reg signed [8:0] dct_q_i_2; \n reg signed [8:0] dct_q_i_3; \n reg signed [8:0] dct_q; \n reg signed data_out; \n reg data_out_rdy; \n reg [5:0] cnt; \n always @(posedge clk) begin \n  if (rst) begin \n  rdy_i_d1 <= 0; \n  rdy_i_d2 <= 0; \n  rdy_i_d3 <= 0; \n  end \n  else begin \n  rdy_i_d1 <= rdy_i; \n  rdy_i_d2 <= rdy_i_d1; \n  rdy_i_d3 <= rdy_i_d2; \n  end \n end \n always @(*) begin \n  dct_q_i_0 = dct_signed*Q_1; \n  dct_q_i_1 = dct_q_i_0[20] == 1 ? ~dct_q_i_0+1 : dct_q_i_0; \n  dct_q_i_2 = dct_q_i_1[11] == 1 ? dct_q_i_1[20:12]+12'd1 : dct_q_i_1[20:12]; \n  dct_q_i_3 = dct_q_i_0[20] == 1 ? ~dct_q_i_2+1 : dct_q_i_2; \n end \n always @(posedge clk) begin \n  if (rst) begin \n  dct_signed <= 0; \n  end \n  else begin \n  if (rdy_i) begin \n  dct_signed <= dct; \n  end \n  end \n end \n always @(posedge clk) begin \n  if (rst) begin \n  dct_q <= 0; \n  end \n  else begin \n  if (rdy_i_d1) begin \n  dct_q <= dct_q_i_3; \n  end \n  end \n end \n always @(posedge clk) begin \n  if (rst) begin \n  cnt <= 0; \n  end \n  else begin \n  if (rdy_i_d2) begin \n  cnt <= cnt + 1; \n  end \n  end \n end \n always @(posedge clk) begin \n  if (rst) begin \n  data_out <= 0; \n  data_out_rdy <= 0; \n  end \n  else begin \n  if (rdy_i_d2) begin \n  if (cnt == 6'd42) begin \n  data_out_rdy <= 1; \n  end \n  else begin \n  data_out_rdy <= 0; \n  end \n  data_out <= (cnt == 6'd42 ? dct_q[0] : 1'b0); \n  end \n  end \n end \n assign message = data_out; \n assign rdy = data_out_rdy; \n MDCT dct_5 (.clk(clk), .rst(rst), .dcti(data_in), .idv(start), .odv(rdy_i), .dcto(dct)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module instantiates either an ITCM or DTCM RAM block based on the configuration. It connects the input and output signals to the RAM module and handles the test mode input. If ITCM RAM is included, it instantiates and connects the ITCM RAM, and if DTCM RAM is included, it instantiates and connects the DTCM RAM. It then assigns the corresponding RAM data output to the module output. The module provides a test mode input to control the RAM functionality.\n\n Module header:\n\nmodule e203_srams(`ifdef E203_HAS_ITCMinput itcm_ram_sd,input itcm_ram_ds,input itcm_ram_ls,input itcm_ram_cs,input itcm_ram_we,input [`E203_ITCM_RAM_AW-1:0] itcm_ram_addr,input [`E203_ITCM_RAM_MW-1:0] itcm_ram_wem,input [`E203_ITCM_RAM_DW-1:0] itcm_ram_din,output [`E203_ITCM_RAM_DW-1:0] itcm_ram_dout,input clk_itcm_ram,input rst_itcm,`endif`ifdef E203_HAS_DTCMinput dtcm_ram_sd,input dtcm_ram_ds,input dtcm_ram_ls,input dtcm_ram_cs,input dtcm_ram_we,input [`E203_DTCM_RAM_AW-1:0] dtcm_ram_addr,input [`E203_DTCM_RAM_MW-1:0] dtcm_ram_wem,input [`E203_DTCM_RAM_DW-1:0] dtcm_ram_din,output [`E203_DTCM_RAM_DW-1:0] dtcm_ram_dout,input clk_dtcm_ram,input rst_dtcm,`endifinput test_mode);\n [/INST]\n", "output": "`ifdef E203_HAS_ITCM \n  wire [`E203_ITCM_RAM_DW-1:0] itcm_ram_dout_pre; \n e203_itcm_ram u_e203_itcm_ram (.sd (itcm_ram_sd),.ds (itcm_ram_ds),.ls (itcm_ram_ls),.cs (itcm_ram_cs ),.we (itcm_ram_we ),.addr (itcm_ram_addr ),.wem (itcm_ram_wem ),.din (itcm_ram_din ),.dout (itcm_ram_dout_pre ),.rst_n(rst_itcm ),.clk (clk_itcm_ram )); \n  assign itcm_ram_dout = itcm_ram_dout_pre; \n  `endif \n  `ifdef E203_HAS_DTCM \n  wire [`E203_DTCM_RAM_DW-1:0] dtcm_ram_dout_pre; \n e203_dtcm_ram u_e203_dtcm_ram (.sd (dtcm_ram_sd),.ds (dtcm_ram_ds),.ls (dtcm_ram_ls),.cs (dtcm_ram_cs ),.we (dtcm_ram_we ),.addr (dtcm_ram_addr ),.wem (dtcm_ram_wem ),.din (dtcm_ram_din ),.dout (dtcm_ram_dout_pre ),.rst_n(rst_dtcm ),.clk (clk_dtcm_ram )); \n  assign dtcm_ram_dout = dtcm_ram_dout_pre; \n  `endif \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module `r_TX_BUF_OBJ3_BYTE_1` is a synchronous register that stores 8 bits of data. It updates the register on the positive edge of the clock signal. When the reset is low and the write enable (wenb) is low, it loads the input data into the register. If the reset is high, it sets the register to 0. If the write enable is high, it maintains the current value of the register.\n\n Module header:\n\nmodule r_TX_BUF_OBJ3_BYTE_1(output reg [7:0] reg_0x5D, input wire reset, input wire wenb, input wire [7:0] in_data, input wire clk);\n [/INST]\n", "output": "always@(posedge clk) \n  begin \n  if(reset==0) begin \n  if(wenb==0) \n  reg_0x5D<=in_data; \n  else \n  reg_0x5D<=reg_0x5D; \n  end \n  else \n  reg_0x5D<=8'h00; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a simple UART transmitter. It takes input data and a valid signal, and outputs the serial transmission on the TX line. The data is written into a dataStore register and then transmitted bit by bit, with proper timing controlled by the writeClock and writeBit registers. The ready output indicates when the module is ready to receive new data.\n\n Module header:\n\nmodule TXMOD(output TX,input CLK,input [7:0] data,input valid,output ready);\n [/INST]\n", "output": "reg TXReg = 1; \n assign TX = TXReg; \n reg [10:0] dataStore = 1536; \n reg writing = 0; \n assign ready = (writing==0); \n reg [13:0] writeClock = 0; \n reg [3:0] writeBit = 0; \n always @(posedge CLK) begin \n  if(writing==0 && valid==1) begin \n  writing <= 1; \n  dataStore[8:1] <= data; \n  writeClock <= UART_PERIOD; \n  writeBit <= 0; \n  TXReg <= dataStore[0]; \n  end else if(writing==1 && writeClock==0 && writeBit==9) begin \n  TXReg <= 1; \n  writing <= 0; \n  end else if(writing==1 && writeClock==0) begin \n  TXReg <= dataStore[writeBit]; \n  writeBit <= writeBit+1; \n  writeClock <= UART_PERIOD; \n  end else if(writing==1) begin \n  TXReg <= dataStore[writeBit]; \n  writeClock <= writeClock - 1; \n  end else begin \n  TXReg <= 1; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a 16x16-bit dual-port RAM with the functionality to read from two addresses and calculate the sum of the read values. It uses a synchronous design with a clock input, and it also has a write enable input to allow for writing data into the RAM. The module maintains an array of 16 signed 16-bit registers, and on the rising edge of the clock, it writes data to the RAM if the write enable signal is asserted. Similarly, it reads data from the specified read addresses and calculates the sum on the rising edge of the clock. The sum calculation involves sign-extension of the input values and then adding them together to produce a 16-bit sum output.\n\n Module header:\n\nmodule ram16_2sum (input clock, input write,input [3:0] wr_addr, input [15:0] wr_data,input [3:0] rd_addr1, input [3:0] rd_addr2,output reg [15:0] sum);\n [/INST]\n", "output": "reg signed [15:0] ram_array [0:15]; \n  reg signed [15:0] a,b; \n  wire signed [16:0] sum_int; \n  always @(posedge clock) \n  if(write) \n  ram_array[wr_addr] <= #1 wr_data; \n  always @(posedge clock) \n  begin \n  a <= #1 ram_array[rd_addr1]; \n  b <= #1 ram_array[rd_addr2]; \n  end \n  assign sum_int = {a[15],a} + {b[15],b}; \n  always @(posedge clock) \n  sum <= #1 sum_int[16:1] + (sum_int[16]&sum_int[0]); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a stopwatch with four 7-segment displays. It includes debouncing logic for the start and stop buttons, and a state machine to control the timing. The state machine generates signals to increment the time counters at different intervals, such as 10 milliseconds, 100 milliseconds, and 1 second. The module also includes a clock gating circuit to control the timing of the state machine. The 7-segment displays are used to show the time in the format of minutes and seconds.\n\n Module header:\n\nmodule stopwatch (input wire clk,input wire rst_n,input wire [1:0] btn_n,output wire [7:0] HEX0,output wire [7:0] HEX1,output wire [7:0] HEX2,output wire [7:0] HEX3);\n [/INST]\n", "output": "wire start_b; \n wire stop_b; \n wire en100hz; \n wire clr; \n wire en; \n wire [3:0] msecqh; \n wire [3:0] msecql; \n wire [3:0] secqh; \n wire [3:0] secql; \n wire ca10msec; \n wire ca100msec; \n wire ca1sec; \n chattering _chattering_start_b \n (.rst_n(rst_n),.clk(clk),.bin_n(btn_n[0]),.bout(start_b)); \n chattering _chattering_stop_b \n (.rst_n(rst_n),.clk(clk),.bin_n(btn_n[1]),.bout(stop_b)); \n divider _divider \n (.rst_n(rst_n),.clk(clk),.en100hz(en100hz)); \n control _control \n (.rst_n(rst_n),.clk(clk),.start_b(start_b),.stop_b(stop_b),.en(en),.clr(clr)); \n cnt10 _10msec \n (.rst_n(rst_n),.clk(en100hz),.en(en),.clr(clr),.q(msecql),.ca(ca10msec)); \n cnt10 _100msec \n (.rst_n(rst_n),.clk(en100hz),.en(ca10msec),.clr(clr),.q(msecqh),.ca(ca100msec)); \n cnt10 _1sec \n (.rst_n(rst_n),.clk(en100hz),.en(ca100msec),.clr(clr),.q(secql),.ca(ca1sec)); \n cnt10 _10sec \n (.rst_n(rst_n),.clk(en100hz),.en(ca1sec),.clr(clr),.q(secqh)); \n seg7dec H0 \n (.din(msecql),.HEX(HEX0[7:1])); \n seg7dec H1 \n (.din(msecqh),.HEX(HEX1[7:1])); \n seg7dec H2 \n (.din(secql),.HEX(HEX2[7:1])); \n seg7dec H3 \n (.din(secqh),.HEX(HEX3[7:1])); \n assign HEX0[0] = 1'b0; \n assign HEX1[0] = 1'b0; \n assign HEX2[0] = 1'b1; \n assign HEX3[0] = 1'b0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a search functionality using 8 comparators. The module compares a 1024-bit input data with a 64-bit key using 8 separate comparator instances. The 8 comparators each compare a 64-bit segment of the input data with the key, and the match signals from the comparators are combined to generate a final match signal. \n\nThe module includes a counter to control the comparison process. The counter cycles through the input data in 64-bit segments and updates the comparator inputs accordingly. When the counter reaches a certain value, it resets and starts over.\n\nThe combinational logic in the module initializes the data inputs for the comparators based on the counter value. When the counter reaches a certain value, the data inputs are assigned segments of the input data. Otherwise, different segments of the input data are assigned to the comparators.\n\nThe module also includes a reset pulse generation block that resets the counter and match signal when a reset signal is detected.\n\nIn summary, this module performs a parallel search operation using 8 comparators to compare segments of the input data with a key, and generates a match signal based on the combined results of the comparators.\n\n Module header:\n\nmodule Search_8Comparators(input clock,input reset,input [1023:0] data,input [63:0] key,output reg match);\n [/INST]\n", "output": "reg [7:0] counter; \n reg [63:0] data1, data2, data3, data4, data5, data6, data7, data8; \n wire match1, match2, match3, match4, match5, match6, match7, match8; \n Comparator c1 \n (.data(data1),.key(key),.match(match1)); \n Comparator c2 \n (.data(data2),.key(key),.match(match2)); \n Comparator c3 \n (.data(data3),.key(key),.match(match3)); \n Comparator c4 \n (.data(data4),.key(key),.match(match4)); \n Comparator c5 \n (.data(data5),.key(key),.match(match5)); \n Comparator c6 \n (.data(data6),.key(key),.match(match6)); \n Comparator c7 \n (.data(data7),.key(key),.match(match7)); \n Comparator c8 \n (.data(data8),.key(key),.match(match8)); \n always @(posedge clock, posedge reset) \n begin \n  if (reset) \n  begin \n  counter <= 0; \n  match <= 0; \n  end \n  else \n  begin \n  if (counter == 120) \n  counter <= 0; \n  else \n  counter <= counter + 1; \n  if (match1 || match2 || match3 || match4) \n  match <= 1; \n  else \n  match <= 0; \n  end \n end \n always @* \n begin \n  if (counter == 120) \n  begin \n  data1 = data[1023-4*counter-:64]; \n  data2 = data[1023-4*counter-:64]; \n  data3 = data[1023-4*counter-:64]; \n  data4 = data[1023-4*counter-:64]; \n  data5 = data[1023-4*counter-:64]; \n  data6 = data[1023-4*counter-:64]; \n  data7 = data[1023-4*counter-:64]; \n  data8 = data[1023-4*counter-:64]; \n  end \n  else \n  begin \n  data1 = data[1023-4*counter-:64]; \n  data2 = data[1022-4*counter-:64]; \n  data3 = data[1021-4*counter-:64]; \n  data4 = data[1020-4*counter-:64]; \n  data5 = data[1019-4*counter-:64]; \n  data6 = data[1018-4*counter-:64]; \n  data7 = data[1017-4*counter-:64]; \n  data8 = data[1016-4*counter-:64]; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a switch debouncer and synchronizer. It synchronizes an asynchronous input signal, debounces it, and generates a synchronized output signal. It uses a state machine to detect transitions and counts to debounce the input signal, and then updates the output signal accordingly. The debouncing time, clock rate, and initial output value are configurable parameters of the module.\n\n Module header:\n\nmodule Switch_Debounce_Synchronizer #(parameter CLK_RATE_HZ = 50000000,parameter DEBOUNCE_TIME = 10000,parameter SIG_OUT_INIT = 1'b0) (input SIG_IN,output reg SIG_OUT,input CLK);\n [/INST]\n", "output": "localparam DBNC_TICKS = DEBOUNCE_TIME / (1000000000.0 / CLK_RATE_HZ); \n  localparam DBNC_COUNT_WIDTH = bit_index(DBNC_TICKS); \n  localparam DBNC_COUNT_LOADVAL = {1'b1, {(DBNC_COUNT_WIDTH){1'b0}}} - DBNC_TICKS; \n  reg [2:0] dbnc_reg; \n  reg [DBNC_COUNT_WIDTH:0] dbnc_count_reg; \n  wire dbnc_transition; \n  wire dbnc_count_done; \n  initial \n  begin \n  dbnc_reg = 3'h0; \n  dbnc_count_reg = DBNC_COUNT_LOADVAL; \n  SIG_OUT = SIG_OUT_INIT; \n  end \n  wire sw_sync; \n  CDC_Input_Synchronizer \n #(.SYNC_REG_LEN( 1 )) \n  sw_synchronizer \n (.ASYNC_IN( SIG_IN ),.SYNC_OUT( sw_sync ),.CLK( CLK )); \n  assign dbnc_transition = dbnc_reg[1] ^ dbnc_reg[0]; \n  always @(posedge CLK) \n  begin \n  dbnc_reg <= { dbnc_reg[1:0], sw_sync }; \n  end \n  assign dbnc_count_done = dbnc_count_reg[DBNC_COUNT_WIDTH]; \n  always @(posedge CLK) \n  begin \n  if (dbnc_transition) \n  dbnc_count_reg <= DBNC_COUNT_LOADVAL; \n  else if (!dbnc_count_done) \n  dbnc_count_reg <= dbnc_count_reg + 1'b1; \n  end \n  always @(posedge CLK) \n  begin \n  if (dbnc_count_done) \n  SIG_OUT <= dbnc_reg[2]; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module generates a reset signal, `reset_n_out`, based on the input clock signal `tx_clk` and an input reset signal `reset_n_in`. The module contains a counter of width 20, `ctr`, and uses it to generate the `reset_n_out` signal. When `reset_n_in` is low, `reset_n_out` is driven low and the counter is reset to 0. When `reset_n_in` is high, the counter increments, and `reset_n_out` is driven high when the counter reaches its maximum value.\n\n Module header:\n\nmodule gen_reset_n(tx_clk,reset_n_in,reset_n_out);\n [/INST]\n", "output": "parameter ctr_width = 20; \n input tx_clk; \n input reset_n_in; \n output reset_n_out; \n reg reset_n_out; \n reg [ctr_width-1:0] ctr; \n always @(posedge tx_clk or negedge reset_n_in) \n begin \n  if (!reset_n_in) \n  begin \n  reset_n_out <= 0; \n  ctr <= 0; \n  end else begin \n  if (ctr == {ctr_width{1'b1}}) \n  begin \n  reset_n_out <= 1'b1; \n  end else begin \n  ctr <= ctr + 1; \n  reset_n_out <= 0; \n  end \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \\$_MUX16_ implements a 16-to-1 multiplexer. The output Y is determined based on the input signals A to V. It selects the input signals based on the control signals S, T, U, and V using conditional operators to create the 16-to-1 MUX functionality.\n\n Module header:\n\nmodule \\$_MUX16_ (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, S, T, U, V, Y);\n [/INST]\n", "output": "input A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, S, T, U, V; \n output Y; \n assign Y = V ? U ? T ? (S ? P : O) : \n  (S ? N : M) : \n  T ? (S ? L : K) : \n  (S ? J : I) : \n  U ? T ? (S ? H : G) : \n  (S ? F : E) : \n  T ? (S ? D : C) : \n  (S ? B : A); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module acl_fp_log_s5_altpriority_encoder_r08 implements an 8-bit priority encoder by breaking the input into two 8-bit parts and using two sub-modules, altpriority_encoder10 and altpriority_encoder11, to encode the priority of the input data. The outputs from these sub-modules are combined to form a 4-bit output q, which represents the highest priority bit position of the input data.\n\n Module header:\n\nmodule acl_fp_log_s5_altpriority_encoder_r08 (data,q) ;\n [/INST]\n", "output": "input [15:0] data; \n  output [3:0] q; \n  wire [2:0] wire_altpriority_encoder10_q; \n  wire [2:0] wire_altpriority_encoder11_q; \n  wire wire_altpriority_encoder11_zero; \n  acl_fp_log_s5_altpriority_encoder_bv7 altpriority_encoder10 \n (.data(data[7:0]),.q(wire_altpriority_encoder10_q)); \n  acl_fp_log_s5_altpriority_encoder_be8 altpriority_encoder11 \n (.data(data[15:8]),.q(wire_altpriority_encoder11_q),.zero(wire_altpriority_encoder11_zero)); \n  assign \n  q = {(~ wire_altpriority_encoder11_zero), (({3{wire_altpriority_encoder11_zero}} & wire_altpriority_encoder10_q) | ({3{(~ wire_altpriority_encoder11_zero)}} & wire_altpriority_encoder11_q))}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a synchronous First-In-First-Out (FIFO) queue with token management and an underlying single clock synchronous FIFO (scfifo) instance. It features read and write functionality, as well as the ability to clear, reset, and manage token positions within the queue. The module also includes logic to handle empty and full queue conditions. The token position is managed based on the write and read operations, and the scfifo is set up with specific parameters for its operation.\n\n Module header:\n\nmodule soft_tbm_queue #(parameter DATA_WIDTH=36) (input clk,input sync,input reset,input write,input read,input clear,input clear_token,output empty,output full,output [3:0]size,input [DATA_WIDTH:0]din,output [DATA_WIDTH:0]dout);\n [/INST]\n", "output": "wire write_int = write && !full; \n  wire read_int = read && !empty; \n  wire [(DATA_WIDTH-1):0]fifo_din; \n  wire [(DATA_WIDTH-1):0]fifo_dout; \n  wire tok_in; \n  wire tok_out; \n  assign {fifo_din, tok_in} = din; \n  assign dout = {fifo_dout, tok_out}; \n  reg [15:0]tok_queue; \n  reg [3:0]tok_pos; \n  always @(posedge clk or posedge reset) \n  begin \n  if (reset) \n  begin \n  tok_queue <= 16'd0; \n  tok_pos <= 4'd15; \n  end \n  else if (sync) \n  begin \n  if (clear) tok_queue <= 16'd0; \n  else if (write_int) \n  begin \n  if (clear_token) tok_queue <= {15'd0, tok_in}; \n  else tok_queue <= {tok_queue[14:0], tok_in}; \n  end \n  else if (clear_token) tok_queue <= 16'd0; \n  if (clear) tok_pos <= 4'd15; \n  else if (write_int && !read_int) tok_pos <= tok_pos + 4'd1; \n  else if (!write_int && read_int) tok_pos <= tok_pos - 4'd1; \n  end \n  end \n  assign tok_out = tok_queue[tok_pos]; \n  scfifo \n #(.add_ram_output_register(\"OFF\"),.intended_device_family(\"Cyclone III\"),.lpm_numwords(16),.lpm_showahead(\"ON\"),.lpm_type(\"scfifo\"),.lpm_width(DATA_WIDTH),.lpm_widthu(4),.overflow_checking(\"OFF\"),.underflow_checking(\"OFF\"),.use_eab(\"ON\")) fifo \n (.aclr (reset),.clock (clk),.data (fifo_din),.rdreq (read_int && sync),.wrreq (write_int && sync),.empty (empty),.full (full),.q (fifo_dout),.sclr (clear),.usedw (size),.almost_full (),.almost_empty ()); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module implements a finite impulse response (FIR) filter with an 8-tap filter for processing 10 input signals. It performs multiplication operations on selected pairs of inputs, and stores the results in intermediate registers based on the control signals i1 and i2. The module has four 16-bit output ports, each associated with a different intermediate register, and the values of these outputs are updated based on the contents of the intermediate registers on the rising edge of the clock signal.\n\n Module header:\n\nmodule cf_fir_3_8_8_3 (clock_c, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, o1, o2, o3, o4);\n [/INST]\n", "output": "input clock_c; \n input i1; \n input i2; \n input [7:0] i3; \n input [7:0] i4; \n input [7:0] i5; \n input [7:0] i6; \n input [7:0] i7; \n input [7:0] i8; \n input [7:0] i9; \n input [7:0] i10; \n output [15:0] o1; \n output [15:0] o2; \n output [15:0] o3; \n output [15:0] o4; \n wire [15:0] n1; \n reg [15:0] n2; \n wire [15:0] n3; \n reg [15:0] n4; \n wire [15:0] n5; \n reg [15:0] n6; \n wire [15:0] n7; \n reg [15:0] n8; \n assign n1 = {8'b00000000, i3} * {8'b00000000, i7}; \n always @ (posedge clock_c) \n begin \n  if (i2 == 1'b1) \n  n2 <= 16'b0000000000000000; \n  else if (i1 == 1'b1) \n  n2 <= n1; \n  if (i2 == 1'b1) \n  n4 <= 16'b0000000000000000; \n  else if (i1 == 1'b1) \n  n4 <= n3; \n  if (i2 == 1'b1) \n  n6 <= 16'b0000000000000000; \n  else if (i1 == 1'b1) \n  n6 <= n5; \n  if (i2 == 1'b1) \n  n8 <= 16'b0000000000000000; \n  else if (i1 == 1'b1) \n  n8 <= n7; \n end \n assign n3 = {8'b00000000, i4} * {8'b00000000, i8}; \n assign n5 = {8'b00000000, i5} * {8'b00000000, i9}; \n assign n7 = {8'b00000000, i6} * {8'b00000000, i10}; \n assign o4 = n8; \n assign o3 = n6; \n assign o2 = n4; \n assign o1 = n2; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module serves as an addresser and data handler for a RAM. It takes in an address, data, read and write modes, and a clock signal, and outputs data from the RAM. The module determines whether it is in read or write mode based on the read and write signals, and controls the corresponding signals to the RAM bank for reading or writing data. The read_write signal is set based on the read and write modes, and then the reading and writing signals are set accordingly to control the RAM bank.\n\n Module header:\n\nmodule RAM_addresser_and_data(input [3:0] address_in,input [3:0] data_in,input read_mode,input write_mode,input clock,output [3:0] data_out,output reg reading,output reg writing);\n [/INST]\n", "output": "reg read_write; \n RAM_ram_bank RAM (.clka(clock),.wea(read_write),.addra(address_in),.dina(data_in),.douta(data_out)); \n  always@(read_mode, write_mode) begin \n  read_write = write_mode & ~read_mode; \n  end \n  always@(read_write) begin \n  if(read_write == 0) begin \n  reading = 1; \n  writing = 0; \n  end \n  else begin \n  reading = 0; \n  writing = 1; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a testbench for a bit control module. It includes signals for clock, reset, enable, read/write, start and stop conditions, as well as I/O control signals. The testbench initializes these signals and then generates clock and frame signals to test the bit control module. The clock and frame signals are initialized and then toggled periodically. The testbench also waits for specific conditions, like the busy signal being false, before proceeding with the test. Overall, this module provides a controlled environment for testing the functionality of the bit control module.\n\n Module header:\n\nmodule bit_ctr2l_tst;\n [/INST]\n", "output": "reg clk; \n  reg clk_frame; \n  reg rst; \n  reg en; \n  reg rw; \n  reg w_bit; \n  reg start_cond; \n  reg stop_cond; \n  wire r_bit; \n  wire busy; \n  wire SCL; \n  wire SDA; \n  reg SDA_in, SDA_out, SDA_oen; \n  assign SDA = SDA_oen? 1'bz : SDA_out; \n bit_ctrl uut (.clk(clk),.clk_frame(clk_frame),.rst(rst),.en(en),.rw(rw),.w_bit(w_bit),.start_cond(start_cond),.stop_cond(stop_cond),.r_bit(r_bit),.busy(busy),.SDA(SDA),.SCL(SCL)); \n  initial begin \n  clk = 0; \n  clk_frame = 0; \n  rst = 1; \n  en = 0; \n  rw = 0; \n  w_bit = 0; \n  start_cond = 0; \n  stop_cond = 0; \n  SDA_oen = 1; \n  #100; \n  rst = 0; \n  #15; \n  en = 1; \n  start_cond = 1; \n  while(!busy) #10; \n  en = 0; \n  start_cond = 0; \n  end \n  always #5 clk = ~clk; \n  always #55 clk_frame = ~clk_frame; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a phase-registered FIFO (First-In-First-Out) memory with 8-bit data width and 1-bit address width. It has input and output ports for control signals and data. The FIFO has separate read and write clocks and includes signals to indicate whether it is empty or full. The module also has logic to handle one-byte mode and to manage the availability of data.\n\n Module header:\n\nmodule ph_reg3 (input h_rst_b,input h_rd,input h_selectData,input h_phi2,input [7:0] p_data,input p_selectData,input p_phi2,input p_rdnw,input one_byte_mode,output [7:0] h_data,output h_data_available,output p_empty,output p_full);\n [/INST]\n", "output": "wire rd_empty; \n  wire rd_full; \n  wire wr_empty; \n  wire wr_full; \n  async_fifo # \n (.D_WIDTH(8),.A_WIDTH(1),.INIT_WADDR(1),.INIT_RADDR(0)) \n  ph_reg3_fifo \n (.rst(!h_rst_b),.wr_clk(p_phi2),.wr_en(p_selectData && !p_rdnw),.wr_data(p_data),.rd_clk(!h_phi2),.rd_en(h_selectData && h_rd),.rd_data(h_data),.rd_empty(rd_empty),.rd_full(rd_full),.wr_empty(wr_empty),.wr_full(wr_full)); \n  assign p_empty = wr_empty; \n  assign p_full = one_byte_mode ? wr_full : !wr_empty; \n  assign h_data_available = one_byte_mode ? !rd_empty : rd_full; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module is a complex error injection module that manipulates various signals based on error types and internal flags. It utilizes clock signals and state machines to control the behavior of its outputs and internal states. The module implements an error delay, error handling, and various error types that impact the behavior of the outputs CLK_OUT and DOUT. The behavior of the module is contingent on multiple conditions including the clock state, reset, error types, and internal flags. The error injection is triggered by an inject_start input and the module resets its state based on the reset signal. Additionally, it instantiates another module called mbus_swapper, which has its own control and output signals.\n\n Module header:\n\nmodule mbus_err_inject(input CLK_FAST,input RESETn,input CLK_IN,output reg CLK_OUT,input DIN,output reg DOUT,input [2:0] ERR_TYPE,input inject_start);\n [/INST]\n", "output": "reg [2:0] err_state; \n reg [2:0] error_type; \n wire int_flag; \n reg swap0_rstn; \n reg clk_ctrl; \n `define ERR_DELAY #500 \n always @ (posedge CLK_FAST or negedge RESETn) \n begin \n  if (~RESETn) \n  begin \n  err_state <= 0; \n  clk_ctrl <= 0; \n  error_type <= 0; \n  end \n  else \n  begin \n  case (err_state) \n  0: \n  begin \n  if (inject_start) \n  err_state <= 1; \n  end \n  1: \n  begin \n  case (ERR_TYPE) \n  0: \n  begin \n  error_type <= 0; \n  if (~CLK_IN) \n  err_state <= 2; \n  end \n  1: \n  begin \n  error_type <= 1; \n  if (~CLK_IN) \n  err_state <= 2; \n  end \n  2: \n  begin \n  error_type <= 0; \n  if (int_flag & (~CLK_IN)) \n  err_state <= 2; \n  end \n  3: \n  begin \n  error_type <= 1; \n  if (int_flag & (~CLK_IN)) \n  err_state <= 2; \n  end \n  4: \n  begin \n  error_type <= 2; \n  if (~CLK_IN) \n  err_state <= 2; \n  end \n  5: \n  begin \n  error_type <= 3; \n  if (~CLK_IN) \n  err_state <= 2; \n  end \n  endcase \n  end \n  2: \n  begin \n  err_state <= 3; \n  case (error_type) \n  0: \n  begin \n  clk_ctrl <= `ERR_DELAY 1; \n  end \n  1: \n  begin \n  clk_ctrl <= `ERR_DELAY 0; \n  end \n  2: \n  begin \n  clk_ctrl <= `ERR_DELAY 0; \n  end \n  3: \n  begin \n  clk_ctrl <= `ERR_DELAY 1; \n  end \n  endcase \n  end \n  3: \n  begin \n  case (error_type) \n  0: \n  begin \n  if (CLK_OUT) \n  begin \n  clk_ctrl <= #100 0; \n  err_state <= 4; \n  end \n  end \n  1: \n  begin \n  if (CLK_IN) \n  begin \n  err_state <= 4; \n  end \n  end \n  2: \n  begin \n  if (~inject_start) \n  err_state <= 0; \n  end \n  3: \n  begin \n  if (~inject_start) \n  err_state <= 0; \n  end \n  endcase \n  end \n  4: \n  begin \n  case (error_type) \n  0: \n  begin \n  if (~CLK_OUT) \n  err_state <= 5; \n  end \n  1: \n  begin \n  if (~CLK_IN) \n  err_state <= 5; \n  end \n  endcase \n  end \n  5: \n  begin \n  if (~inject_start) \n  err_state <= 0; \n  end \n  endcase \n  end \n end \n always @ * \n begin \n  CLK_OUT = CLK_IN; \n  DOUT = DIN; \n  if ((err_state>1)&&(err_state<5)) \n  begin \n  case(error_type) \n  0: \n  begin \n  CLK_OUT = (CLK_IN | clk_ctrl); \n  end \n  1: \n  begin \n  CLK_OUT = (CLK_IN & clk_ctrl); \n  end \n  2: \n  begin \n  CLK_OUT = (CLK_IN & clk_ctrl); \n  end \n  3: \n  begin \n  CLK_OUT = (CLK_IN | clk_ctrl); \n  end \n  endcase \n  end \n end \n mbus_swapper swap0(.CLK(CLK_IN),.RESETn(RESETn),.DATA(DIN),.INT_FLAG_RESETn(swap0_rstn),.LAST_CLK(),.INT_FLAG(int_flag)); \n always @ (posedge CLK_IN or negedge RESETn) \n begin \n  if (~RESETn) \n  swap0_rstn <= 1; \n  else \n  begin \n  if (int_flag) \n  swap0_rstn <= #500 0; \n  else if (~swap0_rstn) \n  swap0_rstn <= #500 1; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module is designed to multiply two numbers, a and b, and produce the result in the output, r. The multiplication result is assigned to r using the expression r = a*b.\n\n Module header:\n\nmodule multb (a,b,r);\n [/INST]\n", "output": "input [`COEFWIDTH-2:0] a; \n input [`DATAWIDTH-2:0] b; \n output [`DATAWIDTH + `COEFWIDTH - 3:0] r; \n assign r = a*b; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module is a dual-port register file with two byte-wide ports. It contains two registers for byte0 and byte1 data, which are selected based on the h_selectData input and the fullness of the registers. The module also handles two-byte mode and outputs the appropriate data and flags for the read and write operations. The registers are updated on the falling edge of the h_phi2 clock or the falling edge of the h_rst_b signal. If h_rst_b is low, both byte0 and byte1 registers are reset to 0; otherwise, they are updated with the new data from the input wires. Additionally, it instantiates two flag modules to manage the write enable and select signals for both byte registers. The p_data output is determined based on the availability of data in the two byte registers and the mode of operation.\n\n Module header:\n\nmodule hp_reg3 (input h_rst_b,input h_we_b,input h_selectData,input h_phi2,input [7:0] h_data,input p_selectData,input p_phi2,input p_rdnw,input one_byte_mode,output [7:0] p_data,output p_data_available,output p_two_bytes_available,output h_full);\n [/INST]\n", "output": "wire [1:0] h_full_w; \n  wire [1:0] p_data_available_w; \n  reg [7:0] byte0_q_r ; \n  reg [7:0] byte1_q_r ; \n  wire [7:0] byte0_d_w ; \n  wire [7:0] byte1_d_w ; \n  assign p_data = ( p_data_available_w[0] ) ? byte0_q_r: byte1_q_r; \n  assign p_two_bytes_available = !(one_byte_mode) & ( &p_data_available_w ); \n  assign byte0_d_w = ( h_selectData & (!h_full_w[0] | one_byte_mode) & !h_we_b ) ? h_data : byte0_q_r; \n  assign byte1_d_w = ( h_selectData & ( h_full_w[0] & !one_byte_mode) & !h_we_b ) ? h_data : byte1_q_r; \n  assign p_data_available = (p_data_available_w[0] & one_byte_mode) | p_data_available_w[1]; \n  assign h_full = ( one_byte_mode ) ? h_full_w[0] : h_full_w[1]; \n hp_flag_m flag_0 (.rst_b(h_rst_b),.p1_rdnw( h_we_b),.p1_select(h_selectData & (!h_full_w[0] | one_byte_mode)),.p1_clk(h_phi2),.p2_select(p_selectData & (p_data_available_w[0] | one_byte_mode)),.p2_rdnw(p_rdnw),.p2_clk(p_phi2),.p2_data_available(p_data_available_w[0]),.p1_full(h_full_w[0])); \n hp_flag_m flag_1 (.rst_b(h_rst_b),.p1_rdnw( h_we_b),.p1_select(h_selectData & (h_full_w[0] & !one_byte_mode)),.p1_clk(h_phi2),.p2_select(p_selectData & (!p_data_available_w[0] & !one_byte_mode)),.p2_rdnw(p_rdnw),.p2_clk(p_phi2),.p2_data_available(p_data_available_w[1]),.p1_full(h_full_w[1])); \n  always @ ( negedge h_phi2 or negedge h_rst_b ) \n  begin \n  if ( ! h_rst_b) \n  begin \n  byte0_q_r <= 8'h0; \n  byte1_q_r <= 8'h0; \n  end \n  else \n  begin \n  byte0_q_r <= byte0_d_w ; \n  byte1_q_r <= byte1_d_w ; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module initializes the signals for clock, reset, mode, and fast. It toggles the clock signal every 15 time units. It assigns the reset and mode signals initial values and the fast signal to a fixed value. Then, after a delay of 100 time units, it changes the value of the reset signal.\n\n Module header:\n\nmodule TEST_FINAL;\n [/INST]\n", "output": "reg CLOCK; \n  reg RESET; \n  reg [2:0] MODE; \n  reg FAST; \n  wire [7:0] LED; \n  always #15 CLOCK = ~CLOCK; \n Top uut (.CLOCK(CLOCK),.RESET(RESET),.MODE(MODE),.LED(LED),.FAST(FAST)); \n  initial begin \n  CLOCK = 0; \n  RESET = 1; \n  MODE = 0; \n  FAST = 1; \n  #100; \n  RESET = 0; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an implementation of the Conway's Game of Life cellular automaton. It takes an input grid of states and applies the rules of the game to calculate the next state of each cell. The output grid of states represents the next generation of the game. The module defines the grid size using parameters WIDTH and HEIGHT. It initializes the boundary cells to zero, and for the inner cells, it calculates the sum of neighboring cell states to determine the next state using the rules of the Game of Life.\n\n Module header:\n\nmodule conway #(parameter WIDTH = 32,parameter HEIGHT = 32)(in_states,out_states);\n [/INST]\n", "output": "input [WIDTH*HEIGHT-1:0] in_states; \n  output [WIDTH*HEIGHT-1:0] out_states; \n  genvar r, c; \n  generate \n  for (c = 0; c < WIDTH; c=c+1) begin \n  assign out_states[c] = 0; \n  assign out_states[(HEIGHT-1)*WIDTH + c] = 0; \n  end \n  for (r = 1; r < HEIGHT-1; r=r+1) begin \n  assign out_states[r * WIDTH] = 0; \n  assign out_states[(r + 1) * WIDTH - 1] = 0; \n  for (c = 1; c < WIDTH-1; c=c+1) begin \n  wire cur_state_i; \n  wire [4:0] sum_i; \n  assign cur_state_i = in_states[r * WIDTH + c]; \n  assign sum_i = in_states[r * WIDTH + c-WIDTH-1] + in_states[r * WIDTH + c-WIDTH] + in_states[r * WIDTH + c-WIDTH+1] + in_states[r * WIDTH + c-1] + in_states[r * WIDTH + c+1] + in_states[r * WIDTH + c+WIDTH-1] + in_states[r * WIDTH + c+WIDTH] + in_states[r * WIDTH + c+WIDTH+1]; \n  wire eq2_i, eq3_i; \n  assign eq2_i = (sum_i == 2); \n  assign eq3_i = (sum_i == 3); \n  wire next_state_i; \n  assign next_state_i = (cur_state_i & (eq2_i | eq3_i)) | (~cur_state_i & eq3_i); \n  assign out_states[r * WIDTH + c] = next_state_i; \n  end \n  end \n  endgenerate \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a counter that operates at different frequencies based on the input clock and reset signals. It uses clock dividers to generate lower frequency signals and a modulo N counter to control the output multiplexing. The module also includes BCD-to-7-segment decoder instances to convert the counter values into a format suitable for display. The module selects and outputs the appropriate BCD values based on the select input.\n\n Module header:\n\nmodule finalcounter(input clk,input rst,input [64:1] dectext,input [1:0] updown,output reg [6:0] OUT,output reg [3:0] EN,input select);\n [/INST]\n", "output": "wire HZ1; \n wire HZ100; \n wire [3:0] out0, out2; \n wire [3:0] out1, out3; \n wire [6:0] bcd0, bcd1, bcd2, bcd3; \n wire [1:0] sel_MUX; \n assign out0 = (updown == 2'b00)? dectext[4:1] : ((updown == 2'b01)? dectext[20:17]: ( ((updown == 2'b10)? dectext[36:33]: ( dectext[52:49]) )) ); \n assign out1 = (updown == 2'b00)? dectext[8:5] : ((updown == 2'b01)? dectext[24:21]: ( ((updown == 2'b01)? dectext[40:37]: (dectext[56:53]) )) ); \n assign out2 = (updown == 2'b00)? dectext[12:9] : ((updown == 2'b01)? dectext[28:25]: (((updown == 2'b01)? dectext[44:41]: (dectext[60:57]) )) ); \n assign out3 = (updown == 2'b00)? dectext[16:13] : ((updown == 2'b01)? dectext[32:29]: (((updown == 2'b01)? dectext[48:45]: (dectext[64:61]) )) ); \n clockdivide2 divider(.clk(clk),.rst(rst),.clkdivided1hz(HZ1), .clkdivided2hz(HZ100)); \n BCD7segment BCD0(out0, select,bcd0); \n BCD7segment BCD1(out1,select,bcd1); \n BCD7segment BCD2(out2,select, bcd2); \n BCD7segment BCD3(out3,select, bcd3); \n moduloNcounter cont(.clk(HZ100),.rst(rst), .Q(sel_MUX), .EN(1), .N(3)); \n always @ * \n begin \n  case(sel_MUX) \n  0: EN = 4'b0111; \n  1: EN = 4'b1011; \n  2: EN = 4'b1101; \n  3: EN = 4'b1110; \n endcase \n end \n always @ * \n begin \n  case(sel_MUX) \n  0: OUT = bcd3; \n  1: OUT = bcd2; \n  2: OUT = bcd1; \n  3: OUT = bcd0; \n  endcase \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes an 18-bit input SW and converts it to a binary-coded decimal (BCD) representation, which is then used to drive seven-segment display decoders for output HEX0 through HEX7. The 7-segment display decoders convert the BCD representation to the corresponding display output for each segment. The output HEX5 is assigned a specific value, and HEX6 and HEX7 are set to high-impedance state.\n\n Module header:\n\nmodule bin2bcd_test(input [17:0] SW ,output [6 :0] HEX0,output [6 :0] HEX1,output [6 :0] HEX2,output [6 :0] HEX3,output [6 :0] HEX4,output [6 :0] HEX5,output [6 :0] HEX6,output [6 :0] HEX7);\n [/INST]\n", "output": "wire [22:0] bcd; \n  bin2bcd #(18) bin2bcd_00 (SW,bcd); \n  bcd7seg bcd7seg_00 ( bcd[3 :0 ] ,HEX0); \n  bcd7seg bcd7seg_01 ( bcd[7 :4 ] ,HEX1); \n  bcd7seg bcd7seg_02 ( bcd[11:8 ] ,HEX2); \n  bcd7seg bcd7seg_03 ( bcd[15:12] ,HEX3); \n  bcd7seg bcd7seg_04 ( bcd[19:16] ,HEX4); \n  bcd7seg bcd7seg_05 ({1'b0,bcd[22:20]},HEX5); \n  assign {HEX6,HEX7}={14{1'bz}}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a latch that captures the input padd on the rising edge of pla_ph1 and holds it until the rising edge of pla_ph2. When dsp_reset is high, both latched_r and out2_r are set to 8'h00. When dsp_reset is low, latched_r is updated with padd and out2_r is updated with latched_r. The output out2_r reflects the latched value when dsp_reset is low.\n\n Module header:\n\nmodule t_dsppla (out2_r,pla_ph1, pla_ph2, dsp_reset, padd);\n [/INST]\n", "output": "input pla_ph1, pla_ph2, dsp_reset; \n  input [7:0] padd; \n  output [7:0] out2_r; \n  wire pla_ph1, pla_ph2, dsp_reset; \n  wire [7:0] padd; \n  reg [7:0] out2_r; \n  reg [7:0] latched_r; \n  always @(posedge pla_ph1 or posedge dsp_reset) begin \n  if (dsp_reset) \n  latched_r <= 8'h00; \n  else \n  latched_r <= padd; \n  end \n  always @(posedge pla_ph2 or posedge dsp_reset) begin \n  if (dsp_reset) \n  out2_r <= 8'h00; \n  else \n  out2_r <= latched_r; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module has two inputs, b and c, and an output y. It uses an always block to calculate the XOR of b and c and assigns the result to y.\n\n Module header:\n\nmodule B(y,b, c);\n [/INST]\n", "output": "input b, c; \n  output reg y; \n  always @(*) begin : myproc \n  y = b ^ c; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a 2-to-1 multiplexer (MUX) that selects either input I0 or I1 based on the value of the select signal S, and assigns the selected input to the output O.\n\n Module header:\n\nmodule MUXF5(output O, input I0, I1, S);\n [/INST]\n", "output": "assign O = S ? I1 : I0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a decoder for ALU operations. It takes inputs funct and aluop, and outputs alucontrol. The module uses a case statement to set the alucontrol signals based on the values of aluop and funct. The output alucontrol is determined according to the specified conditions for each case, with a default case for unmatched inputs.\n\n Module header:\n\nmodule aludec(input [5:0] funct,input [1:0] aluop,output reg [2:0] alucontrol);\n [/INST]\n", "output": "always @( * ) \n  case(aluop) \n  3'b000: alucontrol <= 3'b010; \n  3'b001: alucontrol <= 3'b010; \n  3'b010: case(funct) \n  6'b100000: alucontrol <= 3'b010; \n  6'b100010: alucontrol <= 3'b110; \n  6'b100100: alucontrol <= 3'b000; \n  6'b100101: alucontrol <= 3'b001; \n  6'b101010: alucontrol <= 3'b111; \n  default: alucontrol <= 3'bxxx; \n  endcase \n  default: alucontrol <= 3'bxxx; \n  endcase \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a circuit for streaming data from memory using FIFOs and registers. It coordinates the retrieval of data from memory based on input parameters such as row start, row skip, and number of rows. It includes logic to manage memory requests, row requests, and output buffering. The module also features a counter for managing the current row and uses a combination of registers and FIFOs for data storage and retrieval. Additionally, it generates a done signal based on various conditions being met, indicating the completion of the streaming process.\n\n Module header:\n\nmodule stream_rows (input clk,input rst,output done,input [63:0] num_rows_in,input [63:0] rows_size_in,input [63:0] row_start_in,input [63:0] row_skip_in,output output_empty_out,input output_read_en_in,output [63:0] output_value_out,input row_rq_stall_in,output row_rq_vld_out,output [47:0] row_rq_vadr_out,output row_rs_stall_out,input row_rs_vld_in,input [63:0] row_rs_data_in);\n [/INST]\n", "output": "wire curr_row_done_s; \n  reg [7:0] curr_row_done_hold_s; \n  wire curr_row_read_en_s; \n  wire [63:0] curr_row_data_out_s; \n  wire req_fifo_afull_s; \n  wire req_fifo_empty_s; \n  wire [47:0] row_base_address_s; \n  wire mem_rq_vld_s; \n  wire [47:0] mem_rq_addr_s; \n  wire mem_rq_out_done_s; \n  wire row_fifo_empty_s; \n generic_counter CURR_ROW (.clk (clk),.rst (rst),.done (curr_row_done_s),.start_in (row_start_in),.end_in (num_rows_in),.step_in (row_skip_in),.read_in (curr_row_read_en_s),.count_out (curr_row_data_out_s)); \n  assign curr_row_read_en_s = !rst && !req_fifo_afull_s && !curr_row_done_s; \n  always @(posedge clk) \n  begin \n  curr_row_done_hold_s <= {curr_row_done_hold_s[6:0], curr_row_done_s}; \n  end \n  wire curr_row_read_en_reg; \n  wire [47:0] curr_row_data_out_reg; \n  wire [47:0] curr_row_size_out_reg; \n generic_register_chain #(.DATA_WIDTH (1),.CHAIN_LENGTH (6)) RE_CHAIN (.clk (clk),.rst (rst),.data_in (curr_row_read_en_s),.data_out (curr_row_read_en_reg)); \n generic_register_chain #(.DATA_WIDTH (48),.CHAIN_LENGTH (5)) DATA_CHAIN (.clk (clk),.rst (rst),.data_in (curr_row_data_out_s[47:0]),.data_out (curr_row_data_out_reg)); \n mul_48 ROW_BASE (.clk (clk),.a (curr_row_data_out_reg),.b (rows_size_in[47:0]),.p (row_base_address_s)); \n generic_fifo #(.DATA_WIDTH (48),.DATA_DEPTH (32),.AFULL_POS (12)) REQ_FIFO (.clk (clk),.rst (rst),.afull_out (req_fifo_afull_s),.write_en_in (curr_row_read_en_reg),.data_in ({3'd0, row_base_address_s[47:3]}),.empty_out (req_fifo_empty_s),.read_en_in (mem_rq_vld_s),.data_out (mem_rq_addr_s)); \n  assign mem_rq_vld_s = !req_fifo_empty_s && !row_rq_stall_in; \n outstanding_requests MEM_RQ_OUT (.clk (clk),.rst (rst),.done (mem_rq_out_done_s),.rq_vld_in (mem_rq_vld_s),.rs_vld_in (row_rs_vld_in)); \n  assign row_rq_vld_out = mem_rq_vld_s; \n  assign row_rq_vadr_out = mem_rq_addr_s; \n generic_fifo #(.DATA_WIDTH (64),.DATA_DEPTH (32),.AFULL_POS (24)) ROW_FIFO (.clk (clk),.rst (rst),.afull_out (row_rs_stall_out),.write_en_in (row_rs_vld_in),.data_in (row_rs_data_in),.empty_out (row_fifo_empty_s),.read_en_in (output_read_en_in),.data_out (output_value_out)); \n  assign output_empty_out = row_fifo_empty_s; \n  assign done = (curr_row_done_hold_s == 8'hFF) && req_fifo_empty_s && \n  mem_rq_out_done_s && row_fifo_empty_s; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a 4-digit 7-segment LED display controller. It takes in a clock signal, a clear signal, and 4 inputs representing the data to be displayed on each digit. The module counts the clock ticks, uses the data inputs to determine which digit to display, and generates the corresponding 7-segment display signals. The display cycles through the 4 digits based on the tick count, updating the enable signals and the segments to be displayed. When the clear signal is asserted, the module resets the tick counter.\n\n Module header:\n\nmodule LED_7SEG(input clock, clear,input [3:0] data0, data1, data2, data3,output decimal,output reg [3:0] enable,output reg [6:0] segs);\n [/INST]\n", "output": "reg [19:0] ticks = 0; \n  reg [3:0] digit = 0; \n  assign decimal = 1; \n  always@(posedge clock) \n  if(clear) \n  ticks <= 0; \n  else if (ticks > 800000) \n  ticks <= 0; \n  else \n  ticks <= ticks + 1; \n  always@(*) \n  begin \n  digit = 4'h0; \n  enable = 4'hF; \n  if(ticks < 200000) \n  begin \n  digit = data0; \n  enable[0] = 0; \n  end \n  else if((ticks > 200000) && (ticks < 400000)) \n  begin \n  digit = data1; \n  enable[1] = 0; \n  end \n  else if((ticks > 400000) && (ticks < 600000)) \n  begin \n  digit = data2; \n  enable[2] = 0; \n  end \n  else if((ticks > 600000) && (ticks < 800000)) \n  begin \n  digit = data3; \n  enable[3] = 0; \n  end \n  end \n  always@(*) \n  case(digit) \n  0: segs = 7'b1000000; \n  1: segs = 7'b1111001; \n  2: segs = 7'b0100100; \n  3: segs = 7'b0110000; \n  4: segs = 7'b0011001; \n  5: segs = 7'b0010010; \n  6: segs = 7'b0000010; \n  7: segs = 7'b1111000; \n  8: segs = 7'b0000000; \n  9: segs = 7'b0010000; \n  10: segs = 7'b0001000; \n  11: segs = 7'b0000011; \n  12: segs = 7'b1000110; \n  13: segs = 7'b0100001; \n  14: segs = 7'b0000110; \n  15: segs = 7'b0001110; \n  default: segs = 7'b0110110; \n  endcase \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a synchronizer for the input signal \"x\" using two identical synchronizer instances, \"u1\" and \"u2\". It aims to ensure that the input signal is properly synchronized to the clock signal \"clk\" before being output as \"sync_x\". The module makes use of a logical OR operation to combine the synchronized outputs of the two instances.\n\n Module header:\n\nmodule divg_synchronizer (clk, rst, x, sync_x);\n [/INST]\n", "output": "input clk, rst, x; \n  output sync_x; \n  synchronizer u1 (clk, rst, x, sync_x_1); \n  synchronizer u2 (clk, rst, x, sync_x_2); \n  assign sync_x = sync_x_1 | sync_x_2; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes three input vectors of varying widths and produces one output vector. The input vectors in0, in1, and in2 are used to calculate the output vector dout. The input vectors are converted to signed wires a, b, and c of specific widths, and then mathematical operations are performed on them. The output vector dout is assigned the final result of the operation.\n\n Module header:\n\nmodule hls_contrast_streeOg_DSP48_3(input [9 - 1:0] in0,input [23 - 1:0] in1,input [31 - 1:0] in2,output [32 - 1:0] dout);\n [/INST]\n", "output": "wire signed [25 - 1:0] a; \n wire signed [18 - 1:0] b; \n wire signed [48 - 1:0] c; \n wire signed [43 - 1:0] m; \n wire signed [48 - 1:0] p; \n assign a = $unsigned(in1); \n assign b = $signed(in0); \n assign c = $unsigned(in2); \n assign m = a * b; \n assign p = m + c; \n assign dout = p; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, named EX_MEM, has several input and output ports. The outputs are updated on the positive edge of the clock signal. The outputs are driven by specific input signals, and the initial values of the output registers are set in the initial block. The module essentially serves as a register with controlled outputs, updating its outputs based on the input signals and the clock signal.\n\n Module header:\n\nmodule EX_MEM(input clk,input [1:0] ctlwb_out,input [2:0] ctlm_out,input [31:0] adder_out,input aluzero,input [31:0] aluout,input [31:0] readdat2,input [4:0] muxout,output reg [1:0] wb_ctlout,output reg [2:0] m_ctlout,output reg [31:0] add_result,output reg zero,output reg [31:0] alu_result,output reg [31:0] rdata2out,output reg [4:0] five_bit_muxout);\n [/INST]\n", "output": "initial begin \n  wb_ctlout <= 0; \n  m_ctlout <= 0; \n  add_result <= 0; \n  zero <= 0; \n  alu_result <= 0; \n  rdata2out <= 0; \n  five_bit_muxout <= 0; \n  end \n  always @ (posedge clk) \n  begin \n  wb_ctlout <= ctlwb_out; \n  m_ctlout <= ctlm_out; \n  add_result <= adder_out; \n  zero <= aluzero; \n  alu_result <= aluout; \n  rdata2out <= readdat2; \n  five_bit_muxout <= muxout; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an Enhanced High-speed Reader/Writer Unit with 5 ports. It has 5 sets of read and write ports. The module uses a clock signal and handles write enable signals for each port. The module also has a parameter for the size of the data and a parameter for the reset value. It utilizes a reg for storing data and assigns wires for each read and write port. The module updates the read outputs based on the write inputs when the write enable signals are active, and it uses the clock signal to update the internal register.\n\n Module header:\n\nmodule EHRU_5 (CLK,read_0,write_0,EN_write_0,read_1,write_1,EN_write_1,read_2,write_2,EN_write_2,read_3,write_3,EN_write_3,read_4,write_4,EN_write_4);\n [/INST]\n", "output": "parameter DATA_SZ = 1; \n  parameter RESET_VAL = 0; \n  input CLK; \n  output [DATA_SZ-1:0] read_0; \n  input [DATA_SZ-1:0] write_0; \n  input EN_write_0; \n  output [DATA_SZ-1:0] read_1; \n  input [DATA_SZ-1:0] write_1; \n  input EN_write_1; \n  output [DATA_SZ-1:0] read_2; \n  input [DATA_SZ-1:0] write_2; \n  input EN_write_2; \n  output [DATA_SZ-1:0] read_3; \n  input [DATA_SZ-1:0] write_3; \n  input EN_write_3; \n  output [DATA_SZ-1:0] read_4; \n  input [DATA_SZ-1:0] write_4; \n  input EN_write_4; \n  reg [DATA_SZ-1:0] r; \n  wire [DATA_SZ-1:0] wire_0; \n  wire [DATA_SZ-1:0] wire_1; \n  wire [DATA_SZ-1:0] wire_2; \n  wire [DATA_SZ-1:0] wire_3; \n  wire [DATA_SZ-1:0] wire_4; \n  wire [DATA_SZ-1:0] wire_5; \n  assign wire_0 = r; \n  assign wire_1 = EN_write_0 ? write_0 : wire_0; \n  assign wire_2 = EN_write_1 ? write_1 : wire_1; \n  assign wire_3 = EN_write_2 ? write_2 : wire_2; \n  assign wire_4 = EN_write_3 ? write_3 : wire_3; \n  assign wire_5 = EN_write_4 ? write_4 : wire_4; \n  assign read_0 = wire_0; \n  assign read_1 = wire_1; \n  assign read_2 = wire_2; \n  assign read_3 = wire_3; \n  assign read_4 = wire_4; \n  always @(posedge CLK) begin \n  r <= wire_5; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"multiplier_block\" performs arithmetic and bit-shifting operations on the input data of 32 bits to generate the output data of 32 bits. It includes operations such as left shifts by specific bit counts, subtraction, addition, and bitwise operations. The output \"o_data0\" is assigned the result of the final computation.\n\n Module header:\n\nmodule multiplier_block (i_data0,o_data0);\n [/INST]\n", "output": "input [31:0] i_data0; \n  output [31:0] \n  o_data0; \n  wire [31:0] \n  w1, \n  w1024, \n  w1023, \n  w2048, \n  w3071, \n  w32, \n  w33, \n  w132, \n  w2939, \n  w23512; \n  assign w1 = i_data0; \n  assign w1023 = w1024 - w1; \n  assign w1024 = w1 << 10; \n  assign w132 = w33 << 2; \n  assign w2048 = w1 << 11; \n  assign w23512 = w2939 << 3; \n  assign w2939 = w3071 - w132; \n  assign w3071 = w1023 + w2048; \n  assign w32 = w1 << 5; \n  assign w33 = w1 + w32; \n  assign o_data0 = w23512; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module serves as a pipeline control for various signals. It determines the state of the output signals based on the input signals, clock edges, and a flush signal. At the start, the module sets the output signals to 0. Upon receiving a clock signal, it checks the flush signal to determine whether to maintain the previous state or reset the signals to 0. If a reset is needed, it sets all the output signals to 0. If not, it updates the output signals based on the corresponding input signals from the previous cycle. The module essentially acts as a control unit for handling various pipeline signals.\n\n Module header:\n\nmodule pipeline_control_registers(input clock,input flush_e,input reg_write_d,input [2:0] reg_write_adr_d,input mem_to_reg_d,input mem_write_d,input [7:0] ALU_con_d,input ALU_source2_d,input [15:0] offset_register_d,input [2:0] reg_read_adr1_d,input [2:0] reg_read_adr2_d,output reg reg_write_e,output reg [2:0] reg_write_adr_e,output reg mem_to_reg_e,output reg mem_write_e,output reg [7:0] ALU_con_e,output reg ALU_source2_e,output reg [15:0] offset_register_e,output reg [2:0] reg_read_adr1_e,output reg [2:0] reg_read_adr2_e,output reg reg_write_m,output reg [2:0] reg_write_adr_m,output reg mem_to_reg_m,output reg mem_write_m,output reg reg_write_w,output reg [2:0] reg_write_adr_w,output reg mem_to_reg_w);\n [/INST]\n", "output": "initial begin \n  reg_write_e = 0; \n  reg_write_adr_e = 0; \n  mem_to_reg_e = 0; \n  mem_write_e = 0; \n  ALU_con_e = 0; \n  ALU_source2_e = 0; \n  offset_register_e = 0; \n  reg_read_adr1_e = 0; \n  reg_read_adr2_e = 0; \n  reg_write_m = 0; \n  reg_write_adr_m = 0; \n  mem_to_reg_m = 0; \n  mem_write_m = 0; \n  reg_write_w = 0; \n  reg_write_adr_w = 0; \n  mem_to_reg_w = 0; \n  end \n  always @ (posedge clock) begin \n  case (flush_e) \n  0: begin \n  reg_write_e <= reg_write_d; \n  reg_write_adr_e <= reg_write_adr_d; \n  mem_to_reg_e <= mem_to_reg_d; \n  mem_write_e <= mem_write_d; \n  ALU_con_e <= ALU_con_d; \n  ALU_source2_e <= ALU_source2_d; \n  offset_register_e <= offset_register_d; \n  reg_read_adr1_e <= reg_read_adr1_d; \n  reg_read_adr2_e <= reg_read_adr2_d; \n  end \n  1: begin \n  reg_write_e <= 0; \n  reg_write_adr_e <= 0; \n  mem_to_reg_e <= 0; \n  mem_write_e <= 0; \n  ALU_con_e <= 0; \n  ALU_source2_e <= 0; \n  offset_register_e <= 0; \n  reg_read_adr1_e <= 0; \n  reg_read_adr2_e <= 0; \n  end \n  endcase \n  reg_write_m <= reg_write_e; \n  reg_write_adr_m <= reg_write_adr_e; \n  mem_to_reg_m <= mem_to_reg_e; \n  mem_write_m <= mem_write_e; \n  reg_write_w <= reg_write_m; \n  reg_write_adr_w <= reg_write_adr_m; \n  mem_to_reg_w <= mem_to_reg_m; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes two sets of inputs, a and b, and uses them to perform specific calculations to generate an output o. The input b is used to conditionally select and combine elements of input a to produce intermediate results res1 and res2. These results are then added together to produce res3. Finally, the output o is derived from the upper 5 bits of res3.\n\n Module header:\n\nmodule saa1099_amp_env_mixer (input wire [4:0] a,input wire [3:0] b,output wire [4:0] o);\n [/INST]\n", "output": "wire [6:0] res1 = ((b[0] == 1'b1)? a : 5'h00) + ((b[1] == 1'b1)? {a,1'b0} : 6'h00); \n  wire [8:0] res2 = ((b[2] == 1'b1)? {a,2'b00} : 7'h00) + ((b[3] == 1'b1)? {a,3'b000} : 8'h00); \n  wire [8:0] res3 = res1 + res2; \n  assign o = res3[8:4]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a memory generator that contains a RAM (random access memory) module. The module has clock inputs, enable signals, address inputs, and data inputs for both port A and port B. It also has write enable signals for port A and data outputs for port B. The module includes an initialization primitive for the RAM and instantiates the RAM module. The module is responsible for routing signals to the appropriate ports and connecting them to the RAM module.\n\n Module header:\n\nmodule blk_mem_gen_0_blk_mem_gen_prim_width__parameterized6 (\\doutb[5] ,\\DEVICE_7SERIES.NO_BMM_INFO.SDP.SIMPLE_PRIM18.ram ,\\DEVICE_7SERIES.NO_BMM_INFO.SDP.SIMPLE_PRIM18.ram_0 ,clka,clkb,enb,addra,addrb,dina,wea,addra_16__s_port_,ena,addrb_16__s_port_);\n [/INST]\n", "output": "output [3:0]\\doutb[5] ; \n  output \\DEVICE_7SERIES.NO_BMM_INFO.SDP.SIMPLE_PRIM18.ram ; \n  output \\DEVICE_7SERIES.NO_BMM_INFO.SDP.SIMPLE_PRIM18.ram_0 ; \n  input clka; \n  input clkb; \n  input enb; \n  input [16:0]addra; \n  input [16:0]addrb; \n  input [3:0]dina; \n  input [0:0]wea; \n  input addra_16__s_port_; \n  input ena; \n  input addrb_16__s_port_; \n  wire \\DEVICE_7SERIES.NO_BMM_INFO.SDP.SIMPLE_PRIM18.ram ; \n  wire \\DEVICE_7SERIES.NO_BMM_INFO.SDP.SIMPLE_PRIM18.ram_0 ; \n  wire [16:0]addra; \n  wire addra_16__s_net_1; \n  wire [16:0]addrb; \n  wire addrb_16__s_net_1; \n  wire clka; \n  wire clkb; \n  wire [3:0]dina; \n  wire [3:0]\\doutb[5] ; \n  wire ena; \n  wire enb; \n  wire [0:0]wea; \n  assign addra_16__s_net_1 = addra_16__s_port_; \n  assign addrb_16__s_net_1 = addrb_16__s_port_; \n  blk_mem_gen_0_blk_mem_gen_prim_wrapper_init__parameterized6 \\prim_init.ram \n (.\\DEVICE_7SERIES.NO_BMM_INFO.SDP.SIMPLE_PRIM18.ram_0 (\\DEVICE_7SERIES.NO_BMM_INFO.SDP.SIMPLE_PRIM18.ram ),.\\DEVICE_7SERIES.NO_BMM_INFO.SDP.SIMPLE_PRIM18.ram_1 (\\DEVICE_7SERIES.NO_BMM_INFO.SDP.SIMPLE_PRIM18.ram_0 ),.addra(addra),.addra_16__s_port_(addra_16__s_net_1),.addrb(addrb),.addrb_16__s_port_(addrb_16__s_net_1),.clka(clka),.clkb(clkb),.dina(dina),.\\doutb[5] (\\doutb[5] ),.ena(ena),.enb(enb),.wea(wea)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module encodes hardware interrupt information and generates signals for an external interrupt controller. It includes logic to set the EIC_ShadowSet and EIC_Interrupt signals based on the irqDetected and irqNumber inputs. Additionally, it calculates the EIC_Offset and sets the EIC_Vector based on the EIC_USE_EXPLICIT_VECTOR_OFFSET parameter. The module provides flexibility to handle explicit vector offsets and standard vector generation based on the ifdef condition.\n\n Module header:\n\nmodule handler_params_encoder (input [ 7 : 0 ] irqNumber,input irqDetected,output [ 17 : 1 ] EIC_Offset,output [ 3 : 0 ] EIC_ShadowSet,output [ 7 : 0 ] EIC_Interrupt,output [ 5 : 0 ] EIC_Vector);\n [/INST]\n", "output": "assign EIC_ShadowSet = 4'b0; \n  assign EIC_Interrupt = irqDetected ? irqNumber + 1 : 8'b0; \n  `ifdef EIC_USE_EXPLICIT_VECTOR_OFFSET \n  parameter HANDLER_BASE = 17'h100; \n  parameter HANDLER_SHIFT = 4; \n  assign EIC_Offset = HANDLER_BASE + (irqNumber << HANDLER_SHIFT); \n  assign EIC_Vector = 6'b0; \n  `else \n  assign EIC_Offset = 17'h0; \n  assign EIC_Vector = irqNumber[5:0]; \n  `endif \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module defines a 16x1 dual-port RAM with a word size of 1 and an address width of 4. It has input and output ports for data and write enable signals. The RAM array is implemented using a register, and the module can read and write data based on the specified addresses and write enable signal. The RAM has two ports for simultaneous read and write operations and can be triggered by a clock signal. When the write enable signal is asserted, the module writes data to the RAM based on the input address and data.\n\n Module header:\n\nmodule RAM16X1D (DPO,SPO,A0,A1,A2,A3,D,DPRA0,DPRA1,DPRA2,DPRA3,WCLK,WE);\n [/INST]\n", "output": "parameter dw = 1; \n parameter aw = 4; \n output DPO, SPO; \n input DPRA0, DPRA1, DPRA2, DPRA3; \n input A0, A1, A2, A3; \n input D; \n input WCLK; \n input WE; \n reg [dw-1:0] mem [(1<<aw)-1:0]; \n assign DPO = mem[{DPRA3 , DPRA2 , DPRA1 , DPRA0}][dw-1:0]; \n assign SPO = mem[{A3 , A2 , A1 , A0}][dw-1:0]; \n always @(posedge WCLK) \n  if (WE) \n  mem[{A3 , A2 , A1 , A0}] <= #1 D; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `verr` has an input `clk` and output `vout`. It also declares a register variable `vout`, real variables `start_edge` and `end_edge`, and wires `trigger_en` and `v_value`. The `vout` is initialized to 0. It has an always block triggered on the positive edge of `clk`, which calculates `start_edge` and `end_edge` based on `v_value` when `trigger_en` is asserted. When `trigger_en` is not asserted, the `start_edge` and `end_edge` retain their current values.\n\n Module header:\n\nmodule verr (clk, vout);\n [/INST]\n", "output": "input clk; \n output vout; \n reg vout; \n real start_edge; \n real end_edge; \n wire trigger_en; \n wire [9:0] v_value; \n initial vout = 1'b0; \n always @( posedge clk) \n  begin \n  if (trigger_en) \n  begin \n  start_edge = ( v_value[0] * 1.95) \n  + ( v_value[1] * 3.9 ) \n  + ( v_value[2] * 7.8 ) \n  + ( v_value[3] * 15.6 ) \n  + ( v_value[4] * 31.2 ) \n  + ( v_value[5] * 62.5 ) \n  + ( v_value[6] * 125 ) \n  + ( v_value[7] * 250 ) \n  + ( v_value[8] * 0 ) \n  + ( v_value[9] * 0 ) \n  + 0; \n  end_edge = start_edge + 100; \n  end \n  else \n  begin \n  start_edge <= start_edge; \n  end_edge <= end_edge; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module detects if the input is a signaling NaN (isSigNaN) in a floating-point number represented using the RecFN format. The module checks if the input is NaN by comparing the last 3 bits to '111' and sets isSigNaN to 1 if the input is NaN and the second-to-last bit is 0.\n\n Module header:\n\nmodule isSigNaNRecFN#(parameter expWidth = 3, parameter sigWidth = 3) (input [(expWidth + sigWidth):0] in, output isSigNaN);\n [/INST]\n", "output": "wire isNaN = \n  (in[(expWidth + sigWidth - 1):(expWidth + sigWidth - 3)] == 'b111); \n  assign isSigNaN = isNaN && !in[sigWidth - 2]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a data packet FIFO (first-in, first-out) memory with the ability to store and retrieve packets of data. It includes a RAM to store the data packets and various control signals to manage the input and output of the data.\n\nThe RAM is defined to have a width of 32 bits and a depth of 128. It is organized to handle multiple packets, with the number of packets specified as 4.\n\nThe module features logic to handle packet storage and retrieval, including managing the write and read operations to the RAM. It also supports functionalities such as skipping packets, resetting the RAM, and checking the availability of space in the FIFO.\n\nThe module's functionality is controlled by input signals such as reset, clock, write_enable, read_enable, pkt_complete, and skip_packet. It generates output signals like ram_data_out, have_space, pkt_waiting, isfull, usb_ram_packet_out, and usb_ram_packet_in to manage the state of the FIFO and facilitate data transfer operations.\n\nOverall, this module serves as a hardware FIFO memory buffer with the ability to store and retrieve multiple data packets.\n\n Module header:\n\nmodule data_packet_fifo ( input reset,input clock,input [31:0]ram_data_in,input write_enable,output reg have_space,output reg [31:0]ram_data_out,output reg pkt_waiting,output reg isfull,output reg [1:0]usb_ram_packet_out,output reg [1:0]usb_ram_packet_in,input read_enable,input pkt_complete,input skip_packet) ;\n [/INST]\n", "output": "parameter DATA_WIDTH = 32 ; \n  parameter PKT_DEPTH = 128 ; \n  parameter NUM_PACKETS = 4 ; \n  reg [DATA_WIDTH-1:0] usb_ram [PKT_DEPTH*NUM_PACKETS-1:0] ; \n  reg [6:0] usb_ram_offset_out ; \n  reg [6:0] usb_ram_offset_in ; \n  wire [6-2+NUM_PACKETS:0] usb_ram_aout ; \n  wire [6-2+NUM_PACKETS:0] usb_ram_ain ; \n  assign usb_ram_aout = {usb_ram_packet_out, usb_ram_offset_out} ; \n  assign usb_ram_ain = {usb_ram_packet_in, usb_ram_offset_in} ; \n  always @(usb_ram_ain, usb_ram_aout, isfull) \n  begin \n  if (usb_ram_ain == usb_ram_aout) \n  pkt_waiting <= isfull ; \n  else if (usb_ram_ain > usb_ram_aout) \n  pkt_waiting <= (usb_ram_ain - usb_ram_aout) >= PKT_DEPTH; \n  else \n  pkt_waiting <= (usb_ram_ain + 10'b1000000000 - usb_ram_aout) >= PKT_DEPTH; \n  end \n  always @(usb_ram_ain, usb_ram_aout, isfull) \n  begin \n  if (usb_ram_ain == usb_ram_aout) \n  have_space <= ~isfull; \n  else if (usb_ram_ain > usb_ram_aout) \n  have_space <= ((usb_ram_ain - usb_ram_aout) <= PKT_DEPTH * (NUM_PACKETS - 1))? 1'b1 : 1'b0; \n  else \n  have_space <= (usb_ram_aout - usb_ram_ain) >= PKT_DEPTH; \n  end \n  always @(posedge clock) \n  begin \n  if( write_enable ) \n  begin \n  usb_ram[usb_ram_ain] <= ram_data_in ; \n  end \n  ram_data_out <= usb_ram[usb_ram_aout] ; \n  end \n  always @(posedge clock) \n  begin \n  if( reset ) \n  begin \n  usb_ram_packet_out <= 0 ; \n  usb_ram_offset_out <= 0 ; \n  usb_ram_offset_in <= 0 ; \n  usb_ram_packet_in <= 0 ; \n  isfull <= 0; \n  end \n  else \n  begin \n  if( skip_packet ) \n  begin \n  usb_ram_packet_out <= usb_ram_packet_out + 1 ; \n  usb_ram_offset_out <= 0 ; \n  isfull <= 0; \n  end \n  else if(read_enable) \n  begin \n  if( usb_ram_offset_out == 7'b1111111 ) \n  begin \n  isfull <= 0 ; \n  usb_ram_offset_out <= 0 ; \n  usb_ram_packet_out <= usb_ram_packet_out + 1 ; \n  end \n  else \n  usb_ram_offset_out <= usb_ram_offset_out + 1 ; \n  end \n  if( pkt_complete ) \n  begin \n  usb_ram_packet_in <= usb_ram_packet_in + 1 ; \n  usb_ram_offset_in <= 0 ; \n  if ((usb_ram_packet_in + 2'b1) == usb_ram_packet_out) \n  isfull <= 1 ; \n  end \n  else if( write_enable ) \n  begin \n  if (usb_ram_offset_in == 7'b1111111) \n  usb_ram_offset_in <= 7'b1111111 ; \n  else \n  usb_ram_offset_in <= usb_ram_offset_in + 1 ; \n  end \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"sixbitdiv\" implements a six-bit division operation. It takes a 6-bit dividend and divisor as inputs and produces a 6-bit quotient, 6-bit remainder, and an error signal as outputs. The module uses submodules for six-bit subtraction and NOR gates for comparison operations. It also handles overflow and division by zero conditions. The module performs a series of subtractions and comparisons to calculate the quotient and remainder, and it computes the error signal based on overflow and division by zero conditions.\n\n Module header:\n\nmodule sixbitdiv (dividend, divisor, quotient, remainder, err);\n [/INST]\n", "output": "input[5:0] dividend; \n  input[5:0] divisor; \n  output[5:0] quotient; \n  output[5:0] remainder; \n  output err; \n  wire[5:0] posdividend; \n  wire[5:0] posdivisor; \n  wire[5:0] posquotient; \n  wire[5:0] posremainder; \n  wire[5:0] sub1; \n  wire[5:0] sub2; \n  wire[5:0] sub3; \n  wire[5:0] sub4; \n  wire[5:0] sub5; \n  wire[5:0] sub6; \n  wire[5:0] div1; \n  wire[5:0] div2; \n  wire[5:0] div3; \n  wire[5:0] div4; \n  wire[5:0] div5; \n  wire[5:0] overflow; \n  wire divzero; \n  nor (divzero, divisor[5], divisor[4], divisor[3], divisor[2], divisor[1], divisor[0]); \n  assign posdividend = dividend[5] ? ~(dividend - 1) : dividend; \n  assign posdivisor = divisor[5] ? ~(divisor - 1) : divisor; \n  assign div1 = posdividend; \n  assign posquotient[5] = 0; \n  assign overflow[0] = 0; \n  sixbitsub sb2 (div1, (posdivisor << 4) & 'h1F, sub2, overflow[1]); \n  nor (posquotient[4], sub2[5], overflow[1], posdivisor[5], posdivisor[4], posdivisor[3], posdivisor[2], posdivisor[1]); \n  assign div2 = posquotient[4] ? sub2 : div1; \n  sixbitsub sb3 (div2, (posdivisor << 3) & 'h1F, sub3, overflow[2]); \n  nor (posquotient[3], sub3[5], overflow[2], posdivisor[5], posdivisor[4], posdivisor[3], posdivisor[2]); \n  assign div3 = posquotient[3] ? sub3 : div2; \n  sixbitsub sb4 (div3, (posdivisor << 2) & 'h1F, sub4, overflow[3]); \n  nor (posquotient[2], sub4[5], overflow[3], posdivisor[5], posdivisor[4], posdivisor[3]); \n  assign div4 = posquotient[2] ? sub4 : div3; \n  sixbitsub sb5 (div4, (posdivisor << 1) & 'h1F, sub5, overflow[4]); \n  nor (posquotient[1], sub5[5], overflow[4], posdivisor[5], posdivisor[4]); \n  assign div5 = posquotient[1] ? sub5 : div4; \n  sixbitsub sb6 (div5, (posdivisor) & 'h1F, sub6, overflow[5]); \n  nor (posquotient[0], sub6[5], overflow[5], posdivisor[5]); \n  assign posremainder = posquotient[0] ? sub6 : div5; \n  assign err = |overflow || divzero; \n  assign quotient = (dividend[5] ^ divisor[5]) ? ~posquotient + 1 : posquotient; \n  assign remainder = dividend[5] ? ~posremainder + 1 : posremainder; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a clock signal detector. It includes a counter to detect a specific pattern in the input clock signal. The output \"ready\" signal is asserted when the pattern is detected. The module uses registers to store the current and next counter values, as well as the ready status. The counter increments on each clock cycle and is reset based on the input reset signal. The \"ready\" status is set based on the counter value and the input cclk signal.\n\n Module header:\n\nmodule cclk_detector #(parameter CLK_RATE = 50000000)(input clk,input rst,input cclk,output ready);\n [/INST]\n", "output": "parameter CTR_SIZE = $clog2(CLK_RATE/50000); \n  reg [CTR_SIZE-1:0] ctr_d, ctr_q; \n  reg ready_d, ready_q; \n  assign ready = ready_q; \n  always @(ctr_q or cclk) begin \n  ready_d = 1'b0; \n  if (cclk == 1'b0) begin \n  ctr_d = 1'b0; \n  end else if (ctr_q != {CTR_SIZE{1'b1}}) begin \n  ctr_d = ctr_q + 1'b1; \n  end else begin \n  ctr_d = ctr_q; \n  ready_d = 1'b1; \n  end \n  end \n  always @(posedge clk) begin \n  if (rst) begin \n  ctr_q <= 1'b0; \n  ready_q <= 1'b0; \n  end else begin \n  ctr_q <= ctr_d; \n  ready_q <= ready_d; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"scores\" is designed to handle scoring and display functionality for a game. It includes a scoring system with two 8-bit score registers, scoreA and scoreB, which are updated based on the inputs from multiple BCD counter modules. The module also manages various display-related operations such as scrolling and displaying text, which are controlled by a combination of input signals and internal logic. Additionally, the module includes a scan shift register for controlling the display of pixel data. Overall, the module integrates scoring and display functionality for the game.\n\n Module header:\n\nmodule scores(clk, neglineclk, realx, realy, score_addA, score_addB, score_reset, scoreA, scoreB, score_scan);\n [/INST]\n", "output": "input clk; \n input neglineclk; \n input [9:0] realx, realy; \n input score_addA, score_addB, score_reset; \n output [7:0]scoreA, scoreB; \n output score_scan; \n wire scout1, scout2, scout3, scout4; \n wire [3:0] score0; \n wire [3:0] score1; \n wire [3:0] score2; \n wire [3:0] score3; \n bcdcounterx bcdcounter1(score_reset, score_addA, scout1, score1); \n bcdcounterx bcdcounter2(score_reset, scout1, scout2, score0); \n bcdcounterx bcdcounter3(score_reset, score_addB, scout3, score3); \n bcdcounterx bcdcounter4(score_reset, scout3, scout4, score2); \n reg [7:0] scoreA, scoreB; \n always @(score0 or score1 or score2 or score3) begin \n  scoreA <= {score0,score1}; \n  scoreB <= {score2,score3}; \n end \n parameter XSTART = 640/2-3*8*4; \n parameter YSTART = 6*8; \n reg rscxr; \n wire scxr = rscxr; \n always @(negedge clk) begin \n  if (realx == XSTART) rscxr <= 1; \n  else rscxr <= 0; \n end \n wire newline = !neglineclk; \n wire scyr = realy == YSTART; \n reg [7:0] xwide; \n always @(posedge clk) begin \n  if (scxr) \n  xwide <= 6*8*4; \n  else \n  if (xwide > 0) xwide <= xwide - 1; \n end \n wire display_ax = xwide != 0; \n wire display_ay = realy >= YSTART && realy < YSTART+5*8; \n wire displayactive = display_ax & display_ay & skippy; \n reg skippy; \n always @(posedge clk) begin \n  if (realx == XSTART + 2*8*4) begin \n  skippy <= 0; \n  end else if (realx == XSTART + 4*8*4) begin \n  skippy <= 1; \n  end \n end \n wire [3:0] dummy; \n wire [1:0] bitnumber; \n wire [1:0] textadr; \n unicounter unicounter(clk, scxr, skippy & display_ax, dummy[2:0], bitnumber, textadr); \n wire [2:0] y; \n unicounter ycounter(newline, scyr, display_ay, dummy[2:0], y[1:0], {dummy[0],y[2]}); \n wire [3:0] textd; \n scorecopymux scorecopymux(score0, score1, score2, score3, textadr, textd); \n wire [3:0] pixels; \n charrom charrom(clk, charcode, y, pixels); \n wire [3:0] charcode; \n textramx displaymem(clk, textd, textadr, charcode); \n reg sscan; \n always @(posedge clk) begin \n  sscan <= displayactive & pixels[bitnumber]; \n end \n assign score_scan = sscan; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a Time Division Multiplexed (TDM) LED display controller. It takes in a clock signal, asynchronous reset signal, and button input. It outputs signals to control three seven-segment displays and an LED. It also has internal signals for a fast clock, slow clock, a random bit, control enable, and control asynchronous reset. It instantiates clock divider, linear feedback shift register (LFSR), finite state machine (FSM), binary-coded decimal (BCD) counter, and seven-segment display decoder modules. The LED output is controlled based on the control enable signal.\n\n Module header:\n\nmodule tld(clock, ar, button, a1, b1, c1, d1, e1, f1, g1, a2, b2, c2, d2, e2, f2, g2, a3, b3, c3, d3, e3, f3, g3, led);\n [/INST]\n", "output": "input wire clock, ar, button; \n  output wire a1, b1, c1, d1, e1, f1, g1, a2, b2, c2, d2, e2, f2, g2, a3, b3, c3, d3, e3, f3, g3, led; \n  wire fast_clock, slow_clock, random_bit, ctr_en, ctr_ar; \n  wire [3:0] dig1, dig2, dig3; \n  clock_divider clkdiv ( .clk(clock), .ar(ar), .x(slow_clock), .y(fast_clock)); \n  lfsr shiftreg ( .clk(slow_clock), .ar(ar), .sr( ), .q(random_bit)); \n  ctr_fsm fsm (.clk(fast_clock), .ar(ar), .start(random_bit), .stop(button), .ctr_en(ctr_en), .ctr_ar(ctr_ar)); \n  bcd_ctr bcd (.clk(fast_clock), .en(ctr_en), .ar(ctr_ar), .dig1(dig1), .dig2(dig2), .dig3(dig3)); \n  sevseg_decoder decoder1 (.val(dig1), .a(a1), .b(b1), .c(c1), .d(d1), .e(e1), .f(f1), .g(g1)); \n  sevseg_decoder decoder2 (.val(dig2), .a(a2), .b(b2), .c(c2), .d(d2), .e(e2), .f(f2), .g(g2)); \n  sevseg_decoder decoder3 (.val(dig3), .a(a3), .b(b3), .c(c3), .d(d3), .e(e3), .f(f3), .g(g3)); \n  assign led = ctr_en; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module models a Gigabit Media Independent Interface (GMII) for transmitting and receiving data. It includes logic to handle the transmit data, enable, clock, and error, as well as the receive data, valid, error, and clock signals. The module also instantiates another module called fake_eth_phy and connects its ports to the GMII signals for further processing. Additionally, it uses an input file named rx_packets.dat and handles a reset signal.\n\n Module header:\n\nmodule fake_rgmii_phy #(parameter INPUT_FILE_NAME=\"rx_packets.dat\") (input [3:0] tx_d,input tx_en,input tx_clk,output [3:0] rx_d,output rx_clk,output rx_dv,inout mdc,inout mdio,input reset_n);\n [/INST]\n", "output": "reg [7:0] gmii_tx_d; \n reg gmii_tx_en; \n reg gmii_tx_er; \n wire gmii_tx_clk; \n wire [7:0] gmii_rx_d; \n wire gmii_rx_dv; \n wire gmii_rx_er; \n wire gmii_rx_clk; \n assign gmii_tx_clk = tx_clk; \n wire [3:0] status = {1'b1, 1'b0, 1'b1, 1'b1}; \n always @(posedge gmii_tx_clk) begin \n  gmii_tx_d[3:0] <= tx_d; \n  gmii_tx_en <= tx_en; \n end \n always @(negedge gmii_tx_clk) begin \n  gmii_tx_d[7:4] <= tx_d; \n  gmii_tx_er <= 1'b0; \n end \n assign rx_clk = gmii_rx_clk; \n assign rx_d = gmii_rx_d[3:0]; \n assign rx_dv = gmii_rx_dv; \n wire phy_txclk; \n fake_eth_phy #(.input_file_name(INPUT_FILE_NAME)) fake_phy_0 \n (.rgmii(1'b1), .gmii(1'b0), .rmii(1'b0), .REFCLK(1'b0),.TXD(gmii_tx_d), .TXEN(gmii_tx_en), .GTXCLK(gmii_tx_clk),.TXER(gmii_tx_er), .TXCLK(phy_txclk),.RXCLK(gmii_rx_clk), .RXD(gmii_rx_d), .RXER(gmii_rx_er),.RXDV(gmii_rx_dv), .RESET_N(reset_n),.MDC(mdc), .MDIO(mdio), .force_rxer(1'b0)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module `vaaf5c4` has inputs `v712289` and `v4f6beb`, and outputs `v51eedb` and `v7e4f0f`. It assigns the input `v4f6beb` to the wire `w0`. The output `v7e4f0f` is driven by the wire `w1`. It also assigns the input `v712289` to the wire `w2` and assigns the wire `w4` to the output `v51eedb`. The module instantiates two other modules `vecd30a` and `v51b3c0` with the appropriate connections. The internal wires `w0`, `w1`, `w2`, `w3`, and `w4` are used for internal signal routing within the module.\n\n Module header:\n\nmodule vaaf5c4 (input v712289,input [31:0] v4f6beb,output [31:0] v51eedb,output v7e4f0f);\n [/INST]\n", "output": "wire [0:31] w0; \n  wire w1; \n  wire w2; \n  wire [0:30] w3; \n  wire [0:31] w4; \n  assign w0 = v4f6beb; \n  assign v7e4f0f = w1; \n  assign w2 = v712289; \n  assign v51eedb = w4; \n vecd30a vd4273f (.ve841af(w0),.v8d1a42(w1),.v11ef80(w3)); \n v51b3c0 v9b7810 (.v411a12(w2),.vd40455(w3),.v7d0a31(w4)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module defines a parameterized synchronizer circuit with 4-bit input Q and output D. It uses asynchronous registers to capture the input Q and forwards it to the output D under the control of a clock signal s_aclk. The asynchronous registers have attributes such as initialization values and message control, and they are designed to hold their values under reset conditions. The module uses dedicated flip-flops for each bit of the input, effectively synchronizing the asynchronous input Q to the clock domain of s_aclk for reliable data transfer.\n\n Module header:\n\nmodule system_auto_cc_0_synchronizer_ff__parameterized0 (D,Q,s_aclk,\\ngwrdrst.grst.g7serrst.rd_rst_reg_reg[1] );\n [/INST]\n", "output": "output [3:0]D; \n  input [3:0]Q; \n  input s_aclk; \n  input [0:0]\\ngwrdrst.grst.g7serrst.rd_rst_reg_reg[1] ; \n  wire [3:0]Q; \n  (* async_reg = \"true\" *) (* msgon = \"true\" *) wire [3:0]Q_reg; \n  wire [0:0]\\ngwrdrst.grst.g7serrst.rd_rst_reg_reg[1] ; \n  wire s_aclk; \n  assign D[3:0] = Q_reg; \n  (* ASYNC_REG *) \n  (* KEEP = \"yes\" *) \n  (* msgon = \"true\" *) \n FDCE #(.INIT(1'b0)) \n  \\Q_reg_reg[0] \n (.C(s_aclk),.CE(1'b1),.CLR(\\ngwrdrst.grst.g7serrst.rd_rst_reg_reg[1] ),.D(Q[0]),.Q(Q_reg[0])); \n  (* ASYNC_REG *) \n  (* KEEP = \"yes\" *) \n  (* msgon = \"true\" *) \n FDCE #(.INIT(1'b0)) \n  \\Q_reg_reg[1] \n (.C(s_aclk),.CE(1'b1),.CLR(\\ngwrdrst.grst.g7serrst.rd_rst_reg_reg[1] ),.D(Q[1]),.Q(Q_reg[1])); \n  (* ASYNC_REG *) \n  (* KEEP = \"yes\" *) \n  (* msgon = \"true\" *) \n FDCE #(.INIT(1'b0)) \n  \\Q_reg_reg[2] \n (.C(s_aclk),.CE(1'b1),.CLR(\\ngwrdrst.grst.g7serrst.rd_rst_reg_reg[1] ),.D(Q[2]),.Q(Q_reg[2])); \n  (* ASYNC_REG *) \n  (* KEEP = \"yes\" *) \n  (* msgon = \"true\" *) \n FDCE #(.INIT(1'b0)) \n  \\Q_reg_reg[3] \n (.C(s_aclk),.CE(1'b1),.CLR(\\ngwrdrst.grst.g7serrst.rd_rst_reg_reg[1] ),.D(Q[3]),.Q(Q_reg[3])); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a FIFO buffer with configurable parameters for stack width, height, pointer width, and various stack level thresholds. It has data input and output ports, as well as control signals for writing to and reading from the stack. The module uses clock and reset signals for synchronization and handles the storage and retrieval of data in the stack based on the control signals and stack status. The stack fullness and emptiness are indicated by specific output signals. The module also updates the stack pointers and pointer gap based on the read and write operations and stack status.\n\n Module header:\n\nmodule FIFO_Buffer(Data_out,stack_full,stack_almost_full,stack_half_full,stack_almost_empty,stack_empty,Data_in,write_to_stack,read_from_stack,clk,rst);\n [/INST]\n", "output": "parameter stack_width=32; \n  parameter stack_height=8; \n  parameter stack_ptr_width=3; \n  parameter AE_level=2; \n  parameter AF_level=6; \n  parameter HF_level=4; \n  output [stack_width-1:0] Data_out; \n  output stack_full,stack_almost_full,stack_half_full; \n  output stack_almost_empty,stack_empty; \n  input[stack_width-1:0] Data_in; \n  input write_to_stack,read_from_stack; \n  input clk,rst; \n  reg[stack_ptr_width-1:0] read_ptr,write_ptr; \n  reg[stack_ptr_width:0] ptr_gap; \n  reg[stack_width-1:0] Data_out; \n  reg[stack_width-1:0] stack[stack_height-1:0]; \n  assign stack_full=(ptr_gap==stack_height); \n  assign stack_almost_full=(ptr_gap==AF_level); \n  assign stack_half_full=(ptr_gap==HF_level); \n  assign stack_almost_empty=(ptr_gap==AE_level); \n  assign stack_empty=(ptr_gap==0); \n  always @(posedge clk or posedge rst) \n  if(rst) \n  begin \n  Data_out<=0; \n  read_ptr<=0; \n  write_ptr<=0; \n  ptr_gap<=0; \n  end \n  else \n  if(write_to_stack &&(!stack_full)&&(!read_from_stack)) \n  begin \n  stack[write_ptr]<=Data_in; \n  write_ptr<=write_ptr+1; \n  ptr_gap<=ptr_gap+1; \n  end \n  else if((!write_to_stack)&&(!stack_empty)&&read_from_stack) \n  begin \n  Data_out<=stack[read_ptr]; \n  read_ptr<=read_ptr+1; \n  ptr_gap<=ptr_gap-1; \n  end \n  else if(write_to_stack &&read_from_stack&&stack_empty) \n  begin \n  stack[write_ptr]<=Data_in; \n  write_ptr<=write_ptr+1; \n  ptr_gap<=ptr_gap+1; \n  end \n  else if(write_to_stack &&read_from_stack&&stack_full) \n  begin \n  Data_out<=stack[read_ptr]; \n  read_ptr<=read_ptr+1; \n  ptr_gap<=ptr_gap-1; \n  end \n  else if(write_to_stack&&read_from_stack&&(!stack_full)&&(!stack_empty)) \n  begin \n  Data_out<=stack[read_ptr]; \n  stack[write_ptr]<=Data_in; \n  read_ptr<=read_ptr+1; \n  write_ptr<=write_ptr+1; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements the core functionality of the GCM (Galois/Counter Mode) encryption algorithm. It consists of a state machine that controls the initialization and operation of the AES core for encryption/decryption, the CTR counter for incrementing the nonce, and the GCM hash unit for generating the authentication tag. The module takes in various control signals and data inputs, and provides outputs for the processed data and generated tags. The internal logic manages the state transitions, register updates, and control signal generation based on the input control signals and the current state of the module. The AES core and GCM hash units are instantiated within the module to perform the encryption/decryption and tag generation operations, respectively.\n\n Module header:\n\nmodule gcm_core(input wire clk,input wire reset_n,input wire init,input wire next,input wire done,input wire enc_dec,input wire keylen,input wire [1 : 0] taglen,output wire ready,output wire valid,output wire tag_correct,input wire [255 : 0] key,input wire [127 : 0] nonce,input wire [127 : 0] block_in,output wire [127 : 0] block_out,input wire [127 : 0] tag_in,output wire [127 : 0] tag_out);\n [/INST]\n", "output": "localparam CTRL_IDLE = 3'h0; \n  localparam CTRL_INIT = 3'h1; \n  reg [127 : 0] ctr_reg; \n  reg [127 : 0] ctr_new; \n  reg ctr_we; \n  reg [2 : 0] gcm_ctrl_reg; \n  reg [2 : 0] gcm_ctrl_new; \n  reg gcm_ctrl_we; \n  reg aes_init; \n  reg aes_next; \n  wire aes_encdec; \n  wire aes_ready; \n  wire aes_valid; \n  reg ctr_init; \n  reg ctr_next; \n  reg ghash_init; \n  reg ghash_next; \n  wire ghash_ready; \n  reg [127 : 0] ghash_h0; \n  reg [127 : 0] ghash_x; \n  wire [127 : 0] ghash_y; \n  assign aes_encdec = 1; \n aes_core aes(.clk(clk),.reset_n(reset_n),.encdec(aes_encdec),.init(aes_init),.next(aes_next),.ready(aes_ready),.key(key),.keylen(keylen),.block(block_in),.result(block_out),.result_valid(aes_valid)); \n gcm_ghash ghash(.clk(clk),.reset_n(reset_n),.init(ghash_init),.next(ghash_next),.ready(ghash_ready),.h0(ghash_h0),.x(ghash_x),.y(ghash_y)); \n  always @ (posedge clk) \n  begin : reg_update \n  integer i; \n  if (!reset_n) \n  begin \n  ctr_reg <= 64'h0; \n  gcm_ctrl_reg <= CTRL_IDLE; \n  end \n  else \n  begin \n  if (ctr_we) \n  ctr_reg <= ctr_new; \n  if (gcm_ctrl_we) \n  gcm_ctrl_reg <= gcm_ctrl_new; \n  end \n  end \n  always @* \n  begin : ctr_logic \n  ctr_new = 128'h0; \n  ctr_we = 0; \n  if (ctr_init) \n  begin \n  ctr_new = nonce; \n  ctr_we = 1; \n  end \n  if (ctr_next) \n  begin \n  ctr_new = {ctr_reg[127 : 64], ctr_reg[63 : 0] + 1'b1}; \n  ctr_we = 1; \n  end \n  end \n  always @* \n  begin : gcm_core_ctrl_fsm \n  aes_init = 0; \n  aes_next = 0; \n  ctr_init = 0; \n  ctr_next = 0; \n  gcm_ctrl_new = CTRL_IDLE; \n  gcm_ctrl_we = 0; \n  case (gcm_ctrl_reg) \n  CTRL_IDLE: \n  begin \n  if (init) \n  begin \n  gcm_ctrl_new = CTRL_INIT; \n  gcm_ctrl_we = 1; \n  end \n  end \n  CTRL_INIT: \n  begin \n  gcm_ctrl_new = CTRL_IDLE; \n  gcm_ctrl_we = 1; \n  end \n  default: \n  begin \n  end \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an ADSR (Attack, Decay, Sustain, Release) envelope generator. It takes input signals A, D, S, and R, representing the duration of each stage, and GATE as the trigger signal. The module outputs a 32-bit signal, sout, which represents the envelope shape. The module operates on positive clock edges and transitions between the different envelope stages based on the GATE signal and the current state. \n\n- In the IDLE state, when GATE is high, it transitions to the ATTACK state, and when GATE is low, it remains in the IDLE state.\n- In the ATTACK state, if GATE is high, sout is incremented by A, and it transitions to the DECAY state if the threshold is reached. If GATE is low, it transitions to the RELEASE state.\n- In the DECAY state, if GATE is high, sout is decremented by D until it reaches the SUSTAIN level. If GATE becomes low, it transitions to the RELEASE state.\n- In the SUSTAIN state, if GATE becomes low, it transitions to the RELEASE state.\n- In the RELEASE state, if GATE becomes low, sout is decremented by R until it reaches zero, and it transitions to the IDLE state if GATE becomes high and sout reaches zero.\n\nThe module effectively generates an ADSR envelope waveform based on the input signals and the GATE trigger.\n\n Module header:\n\nmodule adsr32( clk, GATE, A, D, S, R, sout);\n [/INST]\n", "output": "output reg [31:0] sout; \n  input wire clk; \n  input wire GATE; \n  input wire [31:0] A; \n  input wire [31:0] D; \n  input wire [31:0] S; \n  input wire [31:0] R; \n  reg [2:0] state; \n  initial begin \n  state = 3'b000; \n  sout = 0; \n  end \n  parameter IDLE = 3'b000; \n  parameter ATTACK = 3'b001; \n  parameter DECAY = 3'b010; \n  parameter SUSTAIN = 3'b011; \n  parameter RELEASE = 3'b100; \n  always @ ( posedge clk ) \n  begin \n  case ( state ) \n  IDLE: \n  begin \n  state <= ( GATE == 1'b1 ) ? ATTACK : IDLE; \n  end \n  ATTACK: \n  begin \n  if ( GATE == 1'b1 ) begin \n  if ( (sout + A) <= {1'b0,{32{1'b1}}} ) begin \n  sout <= sout + A; \n  end else begin \n  sout <= {32{1'b1}}; \n  end \n  end \n  if ( GATE == 1'b0 ) begin \n  state <= RELEASE; \n  end else begin \n  if ( (sout + A) > {1'b0,{32{1'b1}}} ) begin \n  state <= DECAY; \n  end \n  end \n  end \n  DECAY: \n  begin \n  if ( GATE == 1'b1 ) begin \n  if ((sout-D) > S) begin \n  sout <= sout - D; \n  end else begin \n  sout <= S; \n  end \n  end \n  if ( GATE == 1'b1 ) begin \n  if ( sout == S) begin \n  state <= SUSTAIN; \n  end \n  end else if ( GATE == 1'b0 ) begin \n  state <= RELEASE; \n  end \n  end \n  SUSTAIN: \n  begin \n  if ( GATE == 1'b0 ) state <= RELEASE; \n  end \n  RELEASE: \n  begin \n  if ( GATE == 1'b0 ) begin \n  if ( sout > R ) begin \n  sout <= (sout - R); \n  end else begin \n  sout <= 0; \n  end \n  end else if ( GATE == 1'b1 ) begin \n  sout <= 0; \n  end \n  if ( GATE == 1'b1 ) begin \n  state <= ATTACK; \n  end else begin \n  if ( sout == 0 ) begin \n  state <= IDLE; \n  end \n  end \n  end \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"uProgROM\" implements a program ROM with a specified word width and size. It has input and output ports for clock signals, reset signals, program counters, program data, ROM control signals, and read/write data. The module interfaces with a BRAM pop control instance for read operations. The program ROM provides program data output and handles read and write operations based on input signals. The module uses the BRAM pop control to manage read addresses and data output. The \"uProgROM\" module effectively serves as a memory unit for storing and accessing program data.\n\n Module header:\n\nmodule uProgROM # (parameter ProgWordWidth = 64 ,parameter UProgSize = 256) (iClock ,iReset ,iNewProgCursor ,iNewProgCursorValid ,oProgData ,oProgDataValid ,iProgDataReady ,oROMClock ,oROMReset ,oROMAddr ,oROMRW ,oROMEnable ,oROMWData ,iROMRData);\n [/INST]\n", "output": "input iClock ; \n  input iReset ; \n  input [$clog2(UProgSize) - 1:0] iNewProgCursor ; \n  input iNewProgCursorValid ; \n  output [ProgWordWidth - 1:0] oProgData ; \n  output oProgDataValid ; \n  input iProgDataReady ; \n  output oROMClock ; \n  output oROMReset ; \n  output [$clog2(UProgSize) - 1:0] oROMAddr ; \n  output oROMRW ; \n  output oROMEnable ; \n  output [ProgWordWidth - 1:0] oROMWData ; \n  input [ProgWordWidth - 1:0] iROMRData ; \n  wire [$clog2(UProgSize) - 1:0] wUProgReadAddr ; \n  wire [ProgWordWidth - 1:0] wUProgReadData ; \n  wire wUProgReadSig ; \n  BRAMPopControl \n  # \n (.BRAMAddressWidth ($clog2(UProgSize) ),.DataWidth (ProgWordWidth )) \n  Inst_BRAMPopControl \n (.iClock (iClock ),.iReset (iReset ),.iAddressInput (iNewProgCursor ),.iAddressValid (iNewProgCursorValid),.oDataOut (oProgData ),.oDataValid (oProgDataValid ),.iDataReady (iProgDataReady ),.oMemReadAddress (wUProgReadAddr ),.iMemReadData (wUProgReadData ),.oMemDataReadSig (wUProgReadSig )); \n  assign oROMClock = iClock ; \n  assign oROMReset = iReset ; \n  assign oROMAddr = wUProgReadAddr ; \n  assign oROMRW = 1'b0 ; \n  assign oROMEnable = wUProgReadSig ; \n  assign oROMWData = {(ProgWordWidth){1'b0}} ; \n  assign wUProgReadData = iROMRData ; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module is a 6-bit synchronous counter with additional control signals. It uses an internal 7-bit register to store the current count value and increments it on each clock cycle when the enable signal is asserted. When the count reaches the maximum value specified by the input, it resets the count to zero. The module also outputs the current count value and the next count value, along with a signal indicating when the maximum count is reached.\n\n Module header:\n\nmodule Counter_18(input clock,input reset,input [5:0] io_max,output [5:0] io_out,output [5:0] io_next,input io_enable,output io_done);\n [/INST]\n", "output": "wire reg$_clock; \n  wire reg$_reset; \n  wire [5:0] reg$_io_in; \n  wire [5:0] reg$_io_out; \n  wire reg$_io_enable; \n  wire [6:0] count; \n  wire [7:0] _T_12; \n  wire [6:0] newval; \n  wire [6:0] _GEN_1; \n  wire isMax; \n  wire [6:0] next; \n  wire _T_14; \n FF_47 reg$ (.clock(reg$_clock),.reset(reg$_reset),.io_in(reg$_io_in),.io_out(reg$_io_out),.io_enable(reg$_io_enable)); \n  assign count = {1'h0,reg$_io_out}; \n  assign _T_12 = count + 7'h1; \n  assign newval = _T_12[6:0]; \n  assign _GEN_1 = {{1'd0}, io_max}; \n  assign isMax = newval >= _GEN_1; \n  assign next = isMax ? 7'h0 : newval; \n  assign _T_14 = io_enable & isMax; \n  assign io_out = count[5:0]; \n  assign io_next = next[5:0]; \n  assign io_done = _T_14; \n  assign reg$_io_in = next[5:0]; \n  assign reg$_io_enable = io_enable; \n  assign reg$_clock = clock; \n  assign reg$_reset = reset; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a buffer with a configurable size. It uses a circular buffer structure with head and tail pointers to track data. It has push and pop inputs for writing and reading data, and provides the output data based on the head pointer. The module also outputs whether the buffer is full and its current size. It uses an array of registers to store the buffer data and updates the pointers and size based on the push and pop inputs. The buffer size is configurable and the module automatically handles wraparound of the head and tail pointers.\n\n Module header:\n\nmodule buffer #(parameter buffersize = 8) (input `control_w in,input clk,input rst,output `control_w out,input push,input pop,output full,output [2:0] bsize);\n [/INST]\n", "output": "reg [2:0] head, tail; \n  reg [2:0] size; \n  integer n; \n  reg `control_w rf[buffersize-1:0]; \n  always @ rst begin \n  head <= 0; \n  tail <= 0; \n  size <= 0; \n  for (n = 0; n < 8; n = n + 1) \n  rf[n] <= 0; \n  end \n  assign out = rf[head]; \n  assign full = (size == 7); \n  assign bsize = size; \n  always @ (posedge clk) begin \n  if (push && pop) begin \n  rf[tail] <= in; \n  tail <= tail + 1; \n  head <= head + 1; \n  end \n  else if (push) begin \n  rf[tail] <= in; \n  tail <= tail + 1; \n  size <= size + 1; \n  end \n  else if (pop) begin \n  head <= head + 1; \n  size = size - 1; \n  end \n else; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a USB PHY (physical layer) that handles communication between a USB device and a host. It includes two USB ports, labeled usba and usbb. The module contains a softusb_filter block for each port to handle signal filtering and line state detection. It also has a softusb_tx block to handle USB transmit operations and a softusb_rx block for USB receive operations.\n\nThe module also handles USB disconnect detection for each port, by incrementing a counter when the line state is low, and setting the disconnect output when the counter reaches a certain value.\n\nAdditionally, the module includes logic for managing the speed of the USB ports and signal routing based on various control signals, including generating reset signals and managing the txoe (transmit output enable) signals for each port.\n\n Module header:\n\nmodule softusb_phy(input usb_clk,input usb_rst,output usba_spd,output usba_oe_n,input usba_rcv,inout usba_vp,inout usba_vm,output usbb_spd,output usbb_oe_n,input usbb_rcv,inout usbb_vp,inout usbb_vm,output usba_discon,output usbb_discon,output [1:0] line_state_a,output [1:0] line_state_b,input port_sel_rx,input [1:0] port_sel_tx,input [7:0] tx_data,input tx_valid,output tx_ready,output tx_busy,input [1:0] generate_reset,output [7:0] rx_data,output rx_valid,output rx_active,input tx_low_speed,input [1:0] low_speed,input generate_eop);\n [/INST]\n", "output": "wire vp_s_a; \n wire vm_s_a; \n wire rcv_s_a; \n softusb_filter filter_a(.usb_clk(usb_clk),.rcv(usba_rcv),.vp(usba_vp),.vm(usba_vm),.rcv_s(rcv_s_a),.vp_s(vp_s_a),.vm_s(vm_s_a)); \n assign line_state_a = {vm_s_a, vp_s_a}; \n wire vp_s_b; \n wire vm_s_b; \n wire rcv_s_b; \n softusb_filter filter_b(.usb_clk(usb_clk),.rcv(usbb_rcv),.vp(usbb_vp),.vm(usbb_vm),.rcv_s(rcv_s_b),.vp_s(vp_s_b),.vm_s(vm_s_b)); \n assign line_state_b = {vm_s_b, vp_s_b}; \n wire txp; \n wire txm; \n wire txoe; \n softusb_tx tx(.usb_clk(usb_clk),.usb_rst(usb_rst),.tx_data(tx_data),.tx_valid(tx_valid),.tx_ready(tx_ready),.txp(txp),.txm(txm),.txoe(txoe),.low_speed(tx_low_speed),.generate_eop(generate_eop)); \n assign tx_busy = txoe; \n reg txoe0; \n reg txoe1; \n always @(posedge usb_clk) begin \n  txoe0 <= txoe; \n  txoe1 <= txoe0; \n end \n softusb_rx rx(.usb_clk(usb_clk),.rxreset(txoe1),.rx(port_sel_rx ? rcv_s_b : rcv_s_a),.rxp(port_sel_rx ? vp_s_b : vp_s_a),.rxm(port_sel_rx ? vm_s_b : vm_s_a),.rx_data(rx_data),.rx_valid(rx_valid),.rx_active(rx_active),.low_speed(port_sel_rx ? low_speed[1] : low_speed[0])); \n wire txoe_a = (txoe & port_sel_tx[0])|generate_reset[0]; \n wire txoe_b = (txoe & port_sel_tx[1])|generate_reset[1]; \n assign usba_oe_n = ~txoe_a; \n assign usba_vp = txoe_a ? (generate_reset[0] ? 1'b0 : txp) : 1'bz; \n assign usba_vm = txoe_a ? (generate_reset[0] ? 1'b0 : txm) : 1'bz; \n assign usbb_oe_n = ~txoe_b; \n assign usbb_vp = txoe_b ? (generate_reset[1] ? 1'b0 : txp) : 1'bz; \n assign usbb_vm = txoe_b ? (generate_reset[1] ? 1'b0 : txm) : 1'bz; \n reg [6:0] usba_discon_cnt; \n assign usba_discon = (usba_discon_cnt == 7'd127); \n always @(posedge usb_clk) begin \n  if(usb_rst) \n  usba_discon_cnt <= 7'd0; \n  else begin \n  if(line_state_a != 7'd0) \n  usba_discon_cnt <= 7'd0; \n  else if(~usba_discon) \n  usba_discon_cnt <= usba_discon_cnt + 7'd1; \n  end \n end \n reg [6:0] usbb_discon_cnt; \n assign usbb_discon = (usbb_discon_cnt == 7'd127); \n always @(posedge usb_clk) begin \n  if(usb_rst) \n  usbb_discon_cnt <= 7'd0; \n  else begin \n  if(line_state_b != 2'h0) \n  usbb_discon_cnt <= 7'd0; \n  else if(~usbb_discon) \n  usbb_discon_cnt <= usbb_discon_cnt + 7'd1; \n  end \n end \n assign usba_spd = ~low_speed[0]; \n assign usbb_spd = ~low_speed[1]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module represents a state-based machine with input and output signals, memory storage, and state transitions. It processes instructions from memory and updates the state based on various conditions and signals. The module includes logic for fetching instructions, memory access, branching, and halting based on specific conditions and states. The state transitions are controlled by the clock signal, and the initial setup involves reading memory contents and setting the program counter and state values.\n\n Module header:\n\nmodule sbn (clk, state, PC, a, b);\n [/INST]\n", "output": "parameter fwidth = 8; \n  parameter dwidth = 32; \n  input clk; \n  output [2:0] state; \n  output [fwidth-1:0] PC; \n  output [dwidth-1:0] a, b; \n  parameter iwidth = 4 * fwidth; \n  reg [iwidth-1:0] imem[0:((1<<fwidth)-1)]; \n  reg [dwidth-1:0] dmem[0:((1<<fwidth)-1)]; \n  reg [dwidth-1:0] X, Y; \n  reg [fwidth-1:0] PC; \n  reg [iwidth-1:0] IR; \n  wire [iwidth-1:0] insn; \n  wire [dwidth-1:0] data, asubb; \n  wire [fwidth-1:0] addr, PCp1, A, B, C, D; \n  wire altb, stp; \n  reg [1:0] da; \n  reg [2:0] state, nextstate; \n  parameter S0 = 3'b000; \n  parameter S1 = 3'b001; \n  parameter S2 = 3'b010; \n  parameter S3 = 3'b011; \n  parameter S4 = 3'b100; \n  parameter S5 = 3'b101; \n  parameter S6 = 3'b111; \n  assign insn = imem[PC]; \n  assign data = dmem[addr]; \n  assign a = X; \n  assign b = Y; \n  assign asubb = X - Y; \n  assign altb = asubb[dwidth-1]; \n  assign PCp1 = PC + 1; \n  assign A = IR[(4*fwidth-1):(3*fwidth)]; \n  assign B = IR[(3*fwidth-1):(2*fwidth)]; \n  assign C = IR[(2*fwidth-1):fwidth]; \n  assign D = IR[fwidth-1:0]; \n  assign stp = (C == ~{fwidth{1'b0}}) ? 1 : 0; \n  assign addr = (da == 2'b00) ? A : ((da == 2'b01) ? B : C); \n  integer i; \n  always @ (posedge clk) \n  case (state) \n  S0: begin \n  IR <= insn; \n  da <= 2'b00; \n  end \n  S1: begin \n  X <= data; \n  da <= 2'b01; \n  end \n  S2: begin \n  Y <= data; \n  da <= 2'b10; \n  end \n  S3: dmem[addr] <= asubb; \n  S4: PC <= D; \n  S5: PC <= PCp1; \n  S6: begin \n  $display(\"program caused halt with value %d\\n\",asubb); \n  $display(\"dmem:\"); \n  for (i=0; i<16; i=i+1) \n  $display(\"%d %d\", i, dmem[i]); \n  $finish; \n  end \n  endcase \n  always @ (posedge clk) \n  state <= nextstate; \n  always @ (state or altb or stp) \n  case (state) \n  S0: nextstate = S1; \n  S1: nextstate = S2; \n  S2: if (stp ) nextstate = S6; \n  else nextstate = S3; \n  S3: if (altb) nextstate = S4; \n  else nextstate = S5; \n  default: nextstate = S0; \n  endcase \n  initial begin \n  $readmemh(\"sbn.p\", imem); \n  $readmemh(\"sbn.d\", dmem); \n  PC = 0; \n  state = 0; \n  $display(\"imem:\"); \n  for (i=0; i<32; i=i+1) \n  $display(\"%d %h\", i, imem[i]); \n  $display(\"dmem:\"); \n  for (i=0; i<16; i=i+1) \n  $display(\"%d %d\", i, dmem[i]); \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a Booth Multiplier, which performs signed multiplication of two N-bit numbers. It uses a counter to keep track of the number of cycles, and a series of combinational logic blocks to compute the product. The module also includes logic for resetting and loading data, as well as toggling the valid signal. The module implements a series of combinational logic blocks that use the counter value and input operands to compute the product. The outputs of the module include the product and a valid signal to indicate when the computation is complete.\n\n Module header:\n\nmodule Booth_Multiplier_2x #(parameter N = 16)(input Rst,input Clk,input Ld,input [(N - 1):0] M,input [(N - 1):0] R,output reg Valid,output reg [((2*N) - 1):0] P);\n [/INST]\n", "output": "localparam pNumCycles = ((N + 1)/2); \n reg [4:0] Cntr; \n reg [2:0] Booth; \n reg Guard; \n reg [(N + 1):0] A; \n reg [(N + 1):0] S; \n wire [(N + 1):0] Hi; \n reg [((2*N) + 1):0] Prod; \n always @(posedge Clk) \n begin \n  if(Rst) \n  Cntr <= #1 0; \n  else if(Ld) \n  Cntr <= #1 pNumCycles; \n  else if(|Cntr) \n  Cntr <= #1 (Cntr - 1); \n end \n always @(posedge Clk) \n begin \n  if(Rst) \n  A <= #1 0; \n  else if(Ld) \n  A <= #1 {{2{M[(N - 1)]}}, M}; \n end \n always @(*) Booth <= {Prod[1:0], Guard}; \n assign Hi = Prod[((2*N) + 1):N]; \n always @(*) \n begin \n  case(Booth) \n  3'b000 : S <= Hi; \n  3'b001 : S <= Hi + A; \n  3'b010 : S <= Hi + A; \n  3'b011 : S <= Hi + {A, 1'b0}; \n  3'b100 : S <= Hi - {A, 1'b0}; \n  3'b101 : S <= Hi - A; \n  3'b110 : S <= Hi - A; \n  3'b111 : S <= Hi; \n  endcase \n end \n always @(posedge Clk) \n begin \n  if(Rst) \n  Prod <= #1 0; \n  else if(Ld) \n  Prod <= #1 R; \n  else if(|Cntr) \n  Prod <= #1 {{2{S[(N + 1)]}}, S, Prod[(N - 1):2]}; \n end \n always @(posedge Clk) \n begin \n  if(Rst) \n  Guard <= #1 0; \n  else if(Ld) \n  Guard <= #1 0; \n  else if(|Cntr) \n  Guard <= #1 Prod[1]; \n end \n always @(posedge Clk) \n begin \n  if(Rst) \n  P <= #1 0; \n  else if(Cntr == 1) \n  P <= #1 {S, Prod[(N - 1):2]}; \n end \n always @(posedge Clk) \n begin \n  if(Rst) \n  Valid <= #1 0; \n  else \n  Valid <= #1 (Cntr == 1); \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe `mor1kx_branch_prediction` module is a branch predictor that uses different branch prediction algorithms based on the `FEATURE_BRANCH_PREDICTOR` parameter. It instantiates different branch predictor modules based on the value of `FEATURE_BRANCH_PREDICTOR`, which can be \"SAT_COUNTER\", \"GSHARE\", \"SIMPLE\", or any other value. The output `predicted_flag_o` is generated based on the branch prediction logic specific to each branch predictor type. If an invalid `FEATURE_BRANCH_PREDICTOR` value is provided, an error message is displayed and the simulation is terminated.\n\n Module header:\n\nmodule mor1kx_branch_prediction #(parameter FEATURE_BRANCH_PREDICTOR = \"NONE\",parameter OPTION_OPERAND_WIDTH = 32) (input clk,input rst,input op_bf_i,input op_bnf_i,input [9:0] immjbr_upper_i,input [OPTION_OPERAND_WIDTH - 1:0] brn_pc_i,output predicted_flag_o,input prev_op_brcond_i,input prev_predicted_flag_i,input flag_i,input padv_decode_i,input execute_bf_i,input execute_bnf_i,output branch_mispredict_o);\n [/INST]\n", "output": "assign branch_mispredict_o = prev_op_brcond_i & (flag_i != prev_predicted_flag_i); \n generate \n if (FEATURE_BRANCH_PREDICTOR==\"SAT_COUNTER\") begin : branch_predictor_saturation_counter \n  mor1kx_branch_predictor_saturation_counter \n  mor1kx_branch_predictor_saturation_counter \n (.predicted_flag_o (predicted_flag_o),.clk (clk),.rst (rst),.flag_i (flag_i),.execute_op_bf_i (execute_bf_i),.execute_op_bnf_i (execute_bnf_i),.op_bf_i (op_bf_i),.op_bnf_i (op_bnf_i),.prev_op_brcond_i (prev_op_brcond_i),.padv_decode_i (padv_decode_i),.branch_mispredict_i (branch_mispredict_o)); \n end else if (FEATURE_BRANCH_PREDICTOR==\"GSHARE\") begin : branch_predictor_gshare \n  mor1kx_branch_predictor_gshare \n #(.OPTION_OPERAND_WIDTH(OPTION_OPERAND_WIDTH)) \n  mor1kx_branch_predictor_gshare \n (.predicted_flag_o (predicted_flag_o),.clk (clk),.rst (rst),.flag_i (flag_i),.execute_op_bf_i (execute_bf_i),.execute_op_bnf_i (execute_bnf_i),.op_bf_i (op_bf_i),.brn_pc_i (brn_pc_i),.op_bnf_i (op_bnf_i),.prev_op_brcond_i (prev_op_brcond_i),.padv_decode_i (padv_decode_i),.branch_mispredict_i (branch_mispredict_o)); \n end else if (FEATURE_BRANCH_PREDICTOR==\"SIMPLE\") begin : branch_predictor_simple \n  mor1kx_branch_predictor_simple \n  mor1kx_branch_predictor_simple \n (.predicted_flag_o (predicted_flag_o),.op_bf_i (op_bf_i),.op_bnf_i (op_bnf_i),.immjbr_upper_i (immjbr_upper_i)); \n end else begin \n  initial begin \n  $display(\"Error: FEATURE_PREDICTOR_TYPE, %s, not valid\", FEATURE_BRANCH_PREDICTOR); \n  $finish(); \n  end \n end \n endgenerate \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, named FP_STAT_REG, implements a floating-point unit status register. It takes several input signals including clock, reset, and various control signals, and generates the FPU status register and other control signals as outputs.\n\nThe module includes several internal registers to hold intermediate states and flags to track updates and traps. It also calculates the update and flags based on input signals and updates them accordingly.\n\nThe module also handles the loading of the FSR and setting various bits based on input signals and internal logic.\n\nOverall, the module handles the control and update logic for the FPU status register based on input signals and internal state, and generates the corresponding output signals.\n\n Module header:\n\nmodule FP_STAT_REG ( BCLK, BRESET, LFSR, UP_SP, UP_DP, TT_SP, TT_DP, WREN, WRADR, DIN, FSR, TWREN, FPU_TRAP, SAVE_PC);\n [/INST]\n", "output": "input BCLK; \n  input BRESET; \n  input LFSR; \n  input UP_SP,UP_DP; \n  input [4:0] TT_SP,TT_DP; \n  input WREN; \n  input [5:4] WRADR; \n  input [16:0] DIN; \n  output [31:0] FSR; \n  output TWREN; \n  output reg FPU_TRAP; \n  output SAVE_PC; \n  reg [4:3] trap_d; \n  reg update_d; \n  reg set_rm_d; \n  reg [10:0] set_bits; \n  reg [4:0] flags; \n  reg rm_bit; \n  wire load_fsr; \n  wire update,update_i; \n  wire [4:0] trap; \n  wire uflag,iflag,rmflag; \n  assign load_fsr = LFSR & WREN; \n  assign trap = UP_SP ? TT_SP : TT_DP; \n  assign TWREN = ~((UP_SP & (TT_SP[2:0] != 3'b0)) | (UP_DP & (TT_DP[2:0] != 3'b0))); \n  always @(posedge BCLK or negedge BRESET) \n  if (!BRESET) FPU_TRAP <= 1'b0; \n  else FPU_TRAP <= ~FPU_TRAP & ~TWREN; \n  assign update_i = (UP_SP | UP_DP) & ~FPU_TRAP; \n  always @(posedge BCLK) update_d <= update_i; \n  always @(posedge BCLK) trap_d <= trap[4:3]; \n  always @(posedge BCLK) set_rm_d <= WREN & (WRADR == 2'b10); \n  assign update = update_d & ~FPU_TRAP; \n  assign iflag = (update & trap_d[4]) | flags[4]; \n  assign uflag = (update & trap_d[3]) | flags[3]; \n  assign rmflag = (set_rm_d & ~FPU_TRAP) | rm_bit; \n  always @(posedge BCLK or negedge BRESET) \n  if (!BRESET) flags[4:3] <= 2'b0; \n  else \n  begin \n  if (load_fsr) flags[4:3] <= {DIN[6],DIN[4]}; \n  else \n  if (update) flags[4:3] <= {iflag,uflag}; \n  end \n  always @(posedge BCLK or negedge BRESET) \n  if (!BRESET) flags[2:0] <= 3'b0; \n  else \n  begin \n  if (load_fsr) flags[2:0] <= DIN[2:0]; \n  else \n  if (update_i) flags[2:0] <= trap[2:0]; \n  end \n  always @(posedge BCLK or negedge BRESET) \n  if (!BRESET) rm_bit <= 1'b0; \n  else \n  begin \n  if (load_fsr) rm_bit <= DIN[16]; \n  else \n  if (set_rm_d & ~FPU_TRAP) rm_bit <= 1'b1; \n  end \n  always @(posedge BCLK or negedge BRESET) \n  if (!BRESET) set_bits <= 11'b0; \n  else \n  if (load_fsr) set_bits <= {DIN[15:7],DIN[5],DIN[3]}; \n  assign FSR = {15'h0,rmflag,set_bits[10:2],iflag,set_bits[1],uflag,set_bits[0],flags[2:0]}; \n  assign SAVE_PC = (UP_SP | UP_DP) & ~FPU_TRAP; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements the control logic for a processor. It decodes the instruction and function inputs to generate various control signals for the processor datapath. These control signals include RegDst for selecting the destination register, ALUSrc for choosing the ALU operand, MemtoReg for memory-to-register transfer, RegWrite for enabling register write, MemRead for memory read, MemWrite for memory write, Branch for branch operation, ALUOp for ALU operation, Jump for jump operation, Jr for jump register, and FlushIF for flushing the instruction fetch stage. The module also includes various intermediate control signals for different instruction types, such as RFormat, lw, sw, beq, j, addi, subi, and jr0, which are used to derive the final control signals.\n\n Module header:\n\nmodule ProcessorControl (input [5:0] Inst,input Compare,input [5:0] Fn,output wire [1:0] RegDst,output wire ALUSrc,output wire [1:0] MemtoReg,output wire RegWrite,output wire MemRead,output wire MemWrite,output wire Branch,output wire [1:0] ALUOp,output wire Jump,output wire Jr,output wire FlushIF);\n [/INST]\n", "output": "wire RFormat; \n  wire lw; \n  wire sw; \n  wire beq; \n  wire j; \n  wire addi; \n  wire subi; \n  wire jr0; \n  assign RFormat = &(~Inst[5:0]); \n  assign lw = (&(~Inst[4:2])) & (&(Inst[1:0])) & Inst[5]; \n  assign sw = (&(Inst[1:0])) & Inst[5] & Inst[3] & ~Inst[4] & ~Inst[2]; \n  assign beq = (&(~Inst[5:3])) & (&(~Inst[1:0])) & Inst[2]; \n  assign j = (&(~Inst[5:2])) & Inst[1]; \n  assign addi = (&(~Inst[5:4])) & Inst[3] & (&(~Inst[2:0])); \n  assign subi = (&(~Inst[5:3])) & Inst[2:0]; \n  assign jr0 = RFormat & (&(~Fn[5:4])) & Fn[3] & (&(~Fn[2:0])); \n  assign RegDst[0] = RFormat ; \n  assign RegDst[1] = ( j & Inst[0] ); \n  assign ALUSrc = lw | sw | addi | subi; \n  assign MemtoReg[0] = lw; \n  assign MemtoReg[1] = ( j & Inst[0] ); \n  assign RegWrite = ( RFormat | lw | ( j & Inst[0] ) | addi | subi ) & (~jr0); \n  assign MemRead = lw; \n  assign MemWrite = sw; \n  assign Branch = beq; \n  assign Jump = j; \n  assign Jr = jr0; \n  assign ALUOp[0] = beq | subi; \n  assign ALUOp[1] = RFormat; \n  assign FlushIF = ( (Compare && beq) | j | jr0 ) ? 1'b1 : 1'b0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a 4-state finite state machine with inputs 'ain', clock 'clk', and asynchronous reset 'reset'. The module contains state variables 'state' and 'nextstate' to represent the current and next states. The 'count' variable is used to count up to 15. Based on the current state and 'ain' input, the output 'yout' is updated. The state transitions and output generation are determined by the values of 'ain', 'reset', and the current state.\n\n Module header:\n\nmodule lab5_1_1(input ain,clk,reset,output reg [3:0] count,output reg yout);\n [/INST]\n", "output": "reg [1:0] state,nextstate; \n  parameter S0 = 0,S1 = 1,S2 = 2,S3 = 3; \n  initial \n  begin \n  nextstate = S2; \n  end \n  always @(posedge clk) \n  begin \n  if(reset) \n  begin \n  count = 4'b0000; \n  state = S0; \n  end \n  else \n  begin \n  if(ain) \n  begin \n  if(count == 15) \n  begin \n  count = 0; \n  state = S0; \n  end \n  else \n  begin \n  count = count + 1; \n  state = nextstate; \n  end \n  end \n  end \n  end \n  always @(state or ain or reset) \n  begin \n  yout = 1'b0; \n  case(state) \n  S0: if((~ain) & (~reset)) \n  yout = 1; \n  S1: if(ain & (~reset)) \n  yout = 1; \n  default: yout = 1'b0; \n  endcase \n  end \n  always @(state or ain) \n  begin \n  case(state) \n  S0: \n  begin \n  if(ain) \n  nextstate = S2; \n  else \n  nextstate = S0; \n  end \n  S1: \n  begin \n  if(ain) \n  nextstate = S2; \n  else \n  nextstate = S1; \n  end \n  S2: \n  begin \n  if(ain) \n  nextstate = S3; \n  else \n  nextstate = S2; \n  end \n  S3: \n  begin \n  if(ain) \n  nextstate = S1; \n  else \n  nextstate = S3; \n  end \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a simple positive-edge triggered D flip-flop with asynchronous clear functionality. The output Q is updated with the input D on the negative edge of the clock signal C. Additionally, the D flip-flop includes an asynchronous clear feature through the use of the `SB_DFF_REG` primitive.\n\n Module header:\n\nmodule SB_DFFN (output Q, input C, D);\n [/INST]\n", "output": "`SB_DFF_REG \n  always @(negedge C) \n  Q <= D; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is designed to interface with a JTAG virtual state machine. It includes input and output wires for JTAG signals, as well as control registers for different operations such as select, pop, and key. The module implements shifting and updating of data based on the control signals and JTAG state machine signals. It also handles the population, selection, and keypad operations, updating the key_pad, sel_out, and test_out outputs accordingly. The module captures and shifts data based on the control signals and JTAG state machine signals, and sets the key_rdy flag accordingly. It also assigns the test data output based on the shifted data.\n\n Module header:\n\nmodule vji_dsky(input clk,input [7:0] data_in,output reg [3:0] sel_out,output reg [4:0] key_pad,output key_rdy,output reg test_out);\n [/INST]\n", "output": "wire tdo; \n wire tck; \n wire tdi; \n wire capture_dr; \n wire shift_dr; \n wire update_dr; \n wire update_ir; \n virt_jtag virt_jtag_inst(.tck ( tck ),.tdi ( tdi ),.tdo ( tdo ),.ir_in ( Control_reg ),.ir_out ( 3'b000 ),.virtual_state_cdr ( capture_dr ),.virtual_state_sdr ( shift_dr ),.virtual_state_udr ( update_dr ),.virtual_state_uir ( update_ir )); \n parameter SEL = 3'b001; \n parameter POP = 3'b010; \n parameter KEY = 3'b011; \n parameter NOP = 3'b111; \n reg [7:0] push_in; \n reg [7:0] push_out; \n wire [2:0] Control_reg; \n wire crPOP = (Control_reg == POP); \n wire crSEL = (Control_reg == SEL); \n wire crKEY = (Control_reg == KEY); \n always @(posedge tck) begin \n  if((crSEL | crKEY) && shift_dr) push_in <= {tdi, push_in[7:1]}; \n end \n always @(posedge clk) begin \n  if(crKEY && update_dr) begin \n  key_pad <= push_in[4:0]; \n  end \n  else if(crSEL) begin \n  sel_out <= push_in[3:0]; \n  test_out <= push_in[7]; \n  end \n end \n assign key_rdy = (crKEY && update_dr); \n always @(posedge tck) begin \n  if(crPOP && capture_dr) begin \n  push_out <= data_in; \n  end \n  else if(crPOP && shift_dr) begin \n  push_out <= {push_out[0], push_out[7:1]}; \n  end \n end \n assign tdo = push_out[0]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module defines an 8-bit output reg_0x07 and initializes it to 0. The module continuously assigns the value 8'h00 to reg_0x07.\n\n Module header:\n\nmodule r_USBTYPEC_REV_HIGH(output wire [7:0] reg_0x07);\n [/INST]\n", "output": "assign reg_0x07=8'h00; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a T-flip flop with two clock inputs, clk and clk2, and a data input a. The module has two output registers q and q2 which are updated on the rising edges of clk and clk2 respectively with the value of input a. The parameter WIDTH is used to specify the bit width of the flip flop.\n\n Module header:\n\nmodule t_clk_flop (q, q2,clk, clk2, a);\n [/INST]\n", "output": "parameter WIDTH=8; \n  input clk; \n  input clk2; \n  input [(WIDTH-1):0] a; \n  output [(WIDTH-1):0] q; \n  output [(WIDTH-1):0] q2; \n  reg [(WIDTH-1):0] q; \n  reg [(WIDTH-1):0] q2; \n  always @ (posedge clk) q<=a; \n  always @ (posedge clk2) q2<=a; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module is a digital system that integrates multiple components including a CPU, a display for showing numbers, and buttons for input. It involves a control logic unit that selects different input sources based on the switch settings. The CPU component receives clock and reset signals, and outputs various control signals and data signals for the system. The Print module interfaces with the display to show numbers, and the Button module receives input from a button and generates a clock signal.\n\nThe main functionality involves the selection of different data sources based on the switch settings, and displaying the selected data on the display. This selection is done through a combinational logic block that interprets the switch settings and configures the system to display the appropriate data, which could be PC and PCNext values, read data from registers, ALU results, or write data.\n\n Module header:\n\nmodule Basys3(input [1:0] switch,input mclk,input btnClk,input reset,output wire [7:0] display,output wire [3:0] an);\n [/INST]\n", "output": "reg [15:0] tmp[0:3]; \n  reg [15:0] num; \n  wire clk; \n  wire [31:0] pc, pcNext; \n  wire [31:0] instruction; \n  wire [31:26] op; \n  wire [25:21] rs; \n  wire [20:16] rt; \n  wire [15:11] rd; \n  wire [10:6] sa; \n  wire [15:0] imm; \n  wire [25:0] address; \n  wire [31:0] readData1, readData2, writeData, aluResult, memData; \n  assign op = instruction[31:26]; \n  assign rs = instruction[25:21]; \n  assign rt = instruction[20:16]; \n  assign rd = instruction[15:11]; \n  assign sa = instruction[10:6]; \n  assign imm = instruction[15:0]; \n  assign address = instruction[25:0]; \n CPU cpu(.clk(clk),.reset(reset),.pcAddressOutNext(pcNext),.pcAddressOut(pc),.imDataOut(instruction),.rfReadData1(readData1),.rfReadData2(readData2),.rfWriteData(writeData),.aluResult(aluResult),.dmDataOut(memData)); \n Print print(.mclk(mclk),.num(num),.display(display),.an(an)); \n Button btn(.mclk(mclk),.in(btnClk),.out(clk)); \n  always@(switch or pcNext or pc or instruction or readData1 or readData2 or aluResult or writeData) begin \n  case (switch) \n  2'B00: num = { pc[7:0], pcNext[7:0] }; \n  2'B01: num = { 3'B0, instruction[25:21], readData1[7:0] }; \n  2'B10: num = { 3'B0, instruction[20:16], readData2[7:0] }; \n  2'B11: num = { aluResult[7:0], writeData[7:0] }; \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements an I2C test scenario. It includes a clock input, a slave wait signal, a clock counter input, a command input, a stop command output, and a counter output. The module generates a stop command based on the input signals, and updates a counter based on the clock input. The stop command is generated when the clock is enabled, and the counter is decremented when the clock is not enabled.\n\n Module header:\n\nmodule i2c_test02(clk, slave_wait, clk_cnt, cmd, cmd_stop, cnt);\n [/INST]\n", "output": "input clk, slave_wait, clk_cnt; \n  input cmd; \n  output reg cmd_stop; \n  reg clk_en; \n  output reg [15:0] cnt; \n  always @(posedge clk) \n  if (~|cnt) \n  if (~slave_wait) \n  begin \n  cnt <= #1 clk_cnt; \n  clk_en <= #1 1'b1; \n  end \n  else \n  begin \n  cnt <= #1 cnt; \n  clk_en <= #1 1'b0; \n  end \n  else \n  begin \n  cnt <= #1 cnt - 16'h1; \n  clk_en <= #1 1'b0; \n  end \n  always @(posedge clk) \n  if (clk_en) \n  cmd_stop <= #1 cmd; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module is a testbench that instantiates synchronous and color generators. It also initializes signals and assigns fake data to specific addresses based on addr_row. It toggles the clock signal and sets the reset signal. This testbench models the behavior of the synchronous and color generators by stimulating their inputs and observing their outputs.\n\n Module header:\n\nmodule sync_gen_tb;\n [/INST]\n", "output": "reg clk; \n reg rst; \n wire h_sync, v_sync, gfx_clk; \n wire[9:0] x,y; \n wire[3:0] r,g,b; \n wire[4:0] addr_row; \n reg[0:13] d; \n wire[0:13] fake[0:3]; \n assign fake[0] = 14'b00001100010001; \n assign fake[1] = 14'b00011100010011; \n assign fake[2] = 14'b11110000010001; \n assign fake[3] = 14'b11000000011001; \n sync_gen sg(clk, h_sync, v_sync, gfx_clk, x, y, rst); \n colour_gen cg(gfx_clk, x, y, d, addr_row, r, g, b, rst); \n initial begin \n  rst = 1; \n  clk <= 1; \n  #10 rst <= 0; \n end \n always @(posedge clk) \n begin \n  d <= fake[addr_row]; \n end \n always begin \n  #5 clk = !clk; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, named \"axis_trigger\", implements an axis trigger with configurable data width and signed/unsigned data comparison. It uses a registered integer comparison to check for a trigger condition, and generates a comparison block based on the signed/unsigned configuration. It updates the comparison result on the positive edge of the clock, and sets the trigger flag based on the validity of the input data and the polarity configuration. The module also sets the ready signal for the output data to high.\n\n Module header:\n\nmodule axis_trigger # (parameter integer AXIS_TDATA_WIDTH = 32,parameter AXIS_TDATA_SIGNED = \"FALSE\") (input wire aclk,input wire pol_data,input wire [AXIS_TDATA_WIDTH-1:0] msk_data,input wire [AXIS_TDATA_WIDTH-1:0] lvl_data,output wire trg_flag,output wire s_axis_tready,input wire [AXIS_TDATA_WIDTH-1:0] s_axis_tdata,input wire s_axis_tvalid);\n [/INST]\n", "output": "reg [1:0] int_comp_reg; \n  wire int_comp_wire; \n  generate \n  if(AXIS_TDATA_SIGNED == \"TRUE\") \n  begin : SIGNED \n  assign int_comp_wire = $signed(s_axis_tdata & msk_data) >= $signed(lvl_data); \n  end \n  else \n  begin : UNSIGNED \n  assign int_comp_wire = (s_axis_tdata & msk_data) >= lvl_data; \n  end \n  endgenerate \n  always @(posedge aclk) \n  begin \n  if(s_axis_tvalid) \n  begin \n  int_comp_reg <= {int_comp_reg[0], int_comp_wire}; \n  end \n  end \n  assign s_axis_tready = 1'b1; \n  assign trg_flag = s_axis_tvalid & (pol_data ^ int_comp_reg[0]) & (pol_data ^ ~int_comp_reg[1]); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a 4-bit ripple carry adder. It takes two 4-bit inputs A and B, as well as a carry-in C0, and generates a 4-bit output F and a carry-out C4. The module uses four instances of a full adder (FA) and four instances of a 2-input logic gate (Gi) and a 2-input parity generator (Pi) to perform the addition. The carry-out from each full adder is combined with the input and intermediate carries to compute the final carry-out C4.\n\n Module header:\n\nmodule MAIN(A, B, C0, F, C4);\n [/INST]\n", "output": "parameter SIZE = 4; \n  input [SIZE-1: 0] A, B; \n  input C0; \n  output [SIZE-1: 0] F; \n  output C4; \n  wire C1, C2, C3; \n  wire G0, G1, G2, G3; \n  wire P0, P1, P2, P3; \n  Gi G_0(A[0], B[0], G0); \n  Gi G_1(A[1], B[1], G1); \n  Gi G_2(A[2], B[2], G2); \n  Gi G_3(A[3], B[3], G3); \n  Pi P_0(A[0], B[0], P0); \n  Pi P_1(A[1], B[1], P1); \n  Pi P_2(A[2], B[2], P2); \n  Pi P_3(A[3], B[3], P3); \n  FA FA1(A[0], B[0], C0, F[0]); \n  FA FA2(A[1], B[1], C1, F[1]); \n  FA FA3(A[2], B[2], C2, F[2]); \n  FA FA4(A[3], B[3], C3, F[3]); \n  assign C1 = G0 | P0&C0; \n  assign C2 = G1 | P1&G0 | P1&P0&C0; \n  assign C3 = G2 | P2&G1 | P2&P1&G0 | P2&P1&P0&C0; \n  assign C4 = G3 | P3&G2 | P3&P2&G1 | P3&P2&P1&G0 | P3&P2&P1&P0&C0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an encoder with two 4-bit inputs and a 2-bit output. It contains two internal encoders, acl_fp_log_s5_double_altpriority_encoder_3v7 and acl_fp_log_s5_double_altpriority_encoder_3e8. The output q is calculated using logical operations on the outputs of these internal encoders. The output q is a concatenation of the negation of wire_altpriority_encoder22_zero and the result of a conditional logical operation on wire_altpriority_encoder22_zero, wire_altpriority_encoder21_q, and wire_altpriority_encoder22_q.\n\n Module header:\n\nmodule acl_fp_log_s5_double_altpriority_encoder_6v7 (data,q) ;\n [/INST]\n", "output": "input [3:0] data; \n  output [1:0] q; \n  wire [0:0] wire_altpriority_encoder21_q; \n  wire [0:0] wire_altpriority_encoder22_q; \n  wire wire_altpriority_encoder22_zero; \n  acl_fp_log_s5_double_altpriority_encoder_3v7 altpriority_encoder21 \n (.data(data[1:0]),.q(wire_altpriority_encoder21_q)); \n  acl_fp_log_s5_double_altpriority_encoder_3e8 altpriority_encoder22 \n (.data(data[3:2]),.q(wire_altpriority_encoder22_q),.zero(wire_altpriority_encoder22_zero)); \n  assign \n  q = {(~ wire_altpriority_encoder22_zero), ((wire_altpriority_encoder22_zero & wire_altpriority_encoder21_q) | ((~ wire_altpriority_encoder22_zero) & wire_altpriority_encoder22_q))}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a combinational logic using a SOP (Sum of Products) table. It takes an input A of width WIDTH and outputs Y. It iterates through the table of depth DEPTH and width WIDTH, and based on the values in TABLE and A, determines the output Y. If the condition for match is satisfied, Y is set to 1.\n\n Module header:\n\nmodule \\$sop (A, Y);\n [/INST]\n", "output": "parameter WIDTH = 0; \n parameter DEPTH = 0; \n parameter TABLE = 0; \n input [WIDTH-1:0] A; \n output reg Y; \n integer i, j; \n reg match; \n always @* begin \n  Y = 0; \n  for (i = 0; i < DEPTH; i=i+1) begin \n  match = 1; \n  for (j = 0; j < WIDTH; j=j+1) begin \n  if (TABLE[2*WIDTH*i + 2*j + 0] && A[j]) match = 0; \n  if (TABLE[2*WIDTH*i + 2*j + 1] && !A[j]) match = 0; \n  end \n  if (match) Y = 1; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is designed for writing data into a memory device. It takes various inputs such as counters, modes, and finish signals and generates write enable signals and write data and address outputs. The module increments the write address on each write operation and resets it when a finish signal is received. The write enable signal is generated based on specific conditions involving the block count and counter values. The write data is determined based on the counter value, with different modes selected for different counts.\n\n Module header:\n\nmodule mode_write(clk ,rstn ,cnt ,blockcnt ,bestmode ,bestmode16 ,bestmode32 ,finish ,md_we ,md_waddr ,md_wdata);\n [/INST]\n", "output": "input rstn; \n  input clk; \n  input [5:0] cnt; \n  input [6:0] blockcnt; \n  input [5:0] bestmode; \n  input [5:0] bestmode16; \n  input [5:0] bestmode32; \n  input finish; \n  output md_we; \n  output [5:0] md_wdata; \n  output [6:0] md_waddr; \n  reg md_we; \n  reg [5:0] md_wdata; \n  reg [6:0] md_waddr; \n always@(posedge clk or negedge rstn) \n  if(!rstn) \n  md_waddr <= 7'd0; \n  else if(md_we) \n  md_waddr <= md_waddr + 1'b1; \n  else if(finish) \n  md_waddr <= 7'd0; \n always@(posedge clk or negedge rstn) \n  if(!rstn) \n  md_we <= 1'b0; \n else if(((blockcnt>7'd1)&&(cnt==6'd11))||((blockcnt[1:0]==2'b01)&&(cnt==6'd12)&&(blockcnt!=7'd1))||((blockcnt[3:0]==4'b0001)&&(cnt==6'd13)&&(blockcnt!=7'd1))) \n  md_we <= 1'b1; \n  else \n  md_we <= 1'b0; \n always@(posedge clk or negedge rstn) \n  if(!rstn) \n  md_wdata <= 'd0; \n  else if(cnt=='d11) \n  md_wdata <= bestmode; \n  else if(cnt=='d12) \n  md_wdata <= bestmode16; \n  else if(cnt=='d13) \n  md_wdata <= bestmode32; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a fast double-alt priority encoder. It takes an 8-bit input data and produces a 3-bit output q. It internally uses two instances of an alt priority encoder to process the lower and upper 4 bits of the input data. The outputs of the two encoders are combined using logical operators to generate the final output q.\n\n Module header:\n\nmodule acl_fp_add_sub_fast_double_altpriority_encoder_v28 (data,q) ;\n [/INST]\n", "output": "input [7:0] data; \n  output [2:0] q; \n  wire [1:0] wire_altpriority_encoder39_q; \n  wire wire_altpriority_encoder39_zero; \n  wire [1:0] wire_altpriority_encoder40_q; \n  acl_fp_add_sub_fast_double_altpriority_encoder_qh8 altpriority_encoder39 \n (.data(data[3:0]),.q(wire_altpriority_encoder39_q),.zero(wire_altpriority_encoder39_zero)); \n  acl_fp_add_sub_fast_double_altpriority_encoder_q28 altpriority_encoder40 \n (.data(data[7:4]),.q(wire_altpriority_encoder40_q)); \n  assign \n  q = {wire_altpriority_encoder39_zero, (({2{wire_altpriority_encoder39_zero}} & wire_altpriority_encoder40_q) | ({2{(~ wire_altpriority_encoder39_zero)}} & wire_altpriority_encoder39_q))}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a memory controller that interfaces with a memory module and provides data to the user. It has parameters for memory size and data, and it contains a state machine that monitors the address input to determine if the data is ready. The module also uses a memory module 'im' to fetch the data based on the provided address. Once the data is ready, it is passed to the output port. The module also includes logic to handle cases when the address remains the same and to manage the ready signal based on the state of the memory.\n\n Module header:\n\nmodule im_slow(input wire clk,input wire [31:0] addr,output wire rdy,output wire [31:0] data);\n [/INST]\n", "output": "parameter NMEM = 128; \n  parameter IM_DATA = \"im_data.txt\"; \n  parameter MEM_SIZE = 128; \n  parameter ND = 3; \n  wire [31:0] raw_data; \n  im #(.NMEM(NMEM), .IM_DATA(IM_DATA)) \n  im1(.clk(clk), .addr(addr), .data(raw_data)); \n  reg [31:0] last_addr; \n  wire cur_equal; \n  assign cur_equal = (last_addr == addr) ? 1'b1 : 1'b0; \n  reg [ND-1:0] next_equals; \n  wire [ND-1:0] equals; \n  assign equals = {next_equals[ND-2:0], cur_equal}; \n  always @(posedge clk) begin \n  last_addr <= addr; \n  next_equals <= equals; \n  end \n  assign rdy = (&equals) ? 1'b1 : 1'b0; \n  assign data = (rdy) ? raw_data : {32{1'b0}}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, Mmux3d, implements a 3-input multiplexer with a parameterized bit width. It selects one of the three input data based on the control signals s0, s1, and s2, and assigns the selected data to the output register 'out'. If the control signals do not match any of the specified cases, the output is assigned to '65'hx'.\n\n Module header:\n\nmodule Mmux3d (out, in0, s0, in1, s1, in2, s2);\n [/INST]\n", "output": "parameter bits = 32; \n output [bits-1:0] out; \n input [bits-1:0] in0, in1, in2; \n input s0, s1, s2; \n  reg [bits-1:0] out; \n  always @ (s0 or s1 or s2 or in0 or in1 or in2) begin \n  case ({s2, s1, s0}) \n  3'b001: out = in0; \n  3'b010: out = in1; \n  3'b100: out = in2; \n  default: out = 65'hx; \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"sh_reg_1\" is a synchronous register that updates its output \"dout_1\" on the rising edge of the clock signal \"clk\" when the \"wen\" input is high. When \"wen\" is asserted, the input \"din_1\" is loaded into the register to update the output \"dout_1\".\n\n Module header:\n\nmodule sh_reg_1 (clk, wen, din_1, dout_1);\n [/INST]\n", "output": "input clk; \n  input wen; \n  input[8 - 1:0] din_1; \n  output[8 - 1:0] dout_1; \n  reg[8 - 1:0] dout_1; \n  always @(posedge clk) \n  begin \n  if (wen == 1'b1) \n  begin \n  dout_1 <= din_1 ; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes a 4-bit binary input and converts it to the corresponding 7-segment display encoding. The encoding is determined using a case statement based on the input value. The 7-segment display outputs (o_Segment_A to o_Segment_G) are assigned based on the resulting 7-bit hex encoding. The hex encoding for each input value is updated on the positive edge of the input clock.\n\n Module header:\n\nmodule bin_to_disp (input i_Clk,input [3:0] i_Binary_Num,output o_Segment_A,output o_Segment_B,output o_Segment_C,output o_Segment_D,output o_Segment_E,output o_Segment_F,output o_Segment_G);\n [/INST]\n", "output": "reg [6:0] r_Hex_Encoding = 7'h00; \n  always @(posedge i_Clk) \n  begin \n  case (i_Binary_Num) \n  4'b0000: r_Hex_Encoding <= 7'h7E; \n  4'b0001: r_Hex_Encoding <= 7'h30; \n  4'b0010: r_Hex_Encoding <= 7'h6D; \n  4'b0011: r_Hex_Encoding <= 7'h79; \n  4'b0100: r_Hex_Encoding <= 7'h33; \n  4'b0101: r_Hex_Encoding <= 7'h5B; \n  4'b0110: r_Hex_Encoding <= 7'h5F; \n  4'b0111: r_Hex_Encoding <= 7'h70; \n  4'b1000: r_Hex_Encoding <= 7'h7F; \n  4'b1001: r_Hex_Encoding <= 7'h7B; \n  4'b1010: r_Hex_Encoding <= 7'h77; \n  4'b1011: r_Hex_Encoding <= 7'h1F; \n  4'b1100: r_Hex_Encoding <= 7'h4E; \n  4'b1101: r_Hex_Encoding <= 7'h3D; \n  4'b1110: r_Hex_Encoding <= 7'h4F; \n  4'b1111: r_Hex_Encoding <= 7'h47; \n  endcase \n  end \n  assign o_Segment_A = r_Hex_Encoding[6]; \n  assign o_Segment_B = r_Hex_Encoding[5]; \n  assign o_Segment_C = r_Hex_Encoding[4]; \n  assign o_Segment_D = r_Hex_Encoding[3]; \n  assign o_Segment_E = r_Hex_Encoding[2]; \n  assign o_Segment_F = r_Hex_Encoding[1]; \n  assign o_Segment_G = r_Hex_Encoding[0]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a holding function where the output y retains its value if the ready input is high, and updates to the value of input x if the ready input is low. The update occurs on the rising edge of the clock signal.\n\n Module header:\n\nmodule Hold(input clock,input ready,input x,output reg y);\n [/INST]\n", "output": "always @(posedge clock) \n  y <= ready ? y | x : 0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a logic function that assigns an output y based on the input a using a case statement. When the input matches specific patterns, the output y is set to corresponding values. If the input does not match any specified patterns, the default value 4 is assigned to y.\n\n Module header:\n\nmodule default_cases(a, y);\n [/INST]\n", "output": "input [2:0] a; \n output reg [3:0] y; \n always @* begin \n  case (a) \n  3'b000, 3'b111: y <= 0; \n  default: y <= 4; \n  3'b001: y <= 1; \n  3'b010: y <= 2; \n  3'b100: y <= 3; \n  endcase \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `f5_test` takes four inputs `i0`, `i1`, `i2`, `i3` and two select signals `s1` and `s0`. It performs a logical operation on these inputs based on the select signals to compute the output `out`. The logical operation is a combination of AND and OR operations based on the select signals and inputs, and the result is assigned to the output `out`.\n\n Module header:\n\nmodule f5_test(out, i0, i1, i2, i3, s1, s0);\n [/INST]\n", "output": "output out; \n input i0, i1, i2, i3; \n input s1, s0; \n assign out = (~s1 & s0 & i0) | \n  (~s1 & s0 & i1) | \n  (s1 & ~s0 & i2) | \n  (s1 & s0 & i3); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `cls_spi_tb` instantiates a testbench for the `cls_spi` module. It initializes and toggles the clock signal, deactivates the reset signal after a delay, and assigns a value to the data register. The testbench monitors the ss, mosi, and miso signals.\n\n Module header:\n\nmodule cls_spi_tb;\n [/INST]\n", "output": "reg clock; \n  reg reset; \n  reg [31:0] data; \n  reg miso; \n  wire ss; \n  wire mosi; \n  wire sclk; \n cls_spi uut (.clock(clock),.reset(reset),.data(data),.ss(ss),.mosi(mosi),.miso(miso),.sclk(sclk)); \n  initial begin \n  clock = 0; \n  reset = 1; \n  data = 32'h89ABCDEF; \n  miso = 0; \n  #100 reset = 0; \n  end \n  always begin \n  #10 clock = !clock; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `rs232_send` is designed to send data over an RS232 communication channel. It includes a clock input, output for transmission (TX), and inputs for five LEDs. Internally, it has a buffer register, counters, and logic to handle the data and transmission.\n\nThe module uses the clock to manage the timing of data transmission. It increments counters for cycles, bits, and bytes. It also generates a data byte based on the state of the LED inputs. The bit counter controls the output data bit to be transmitted, and this data bit is assigned to the TX output.\n\nThe module's functionality is to synchronize the transmission of data with the clock signal and generate the appropriate data bit for transmission based on the LED inputs and the state of the byte, bit, and cycle counters.\n\n Module header:\n\nmodule rs232_send #(parameter integer PERIOD = 10) (input clk,output TX,input LED1,input LED2,input LED3,input LED4,input LED5);\n [/INST]\n", "output": "reg [7:0] buffer; \n  reg buffer_valid; \n  reg [$clog2(PERIOD):0] cycle_cnt = 0; \n  reg [4:0] bit_cnt = 0; \n  reg [5:0] byte_cnt = 60; \n  always @(posedge clk) begin \n  cycle_cnt <= cycle_cnt + 1; \n  if (cycle_cnt == PERIOD-1) begin \n  cycle_cnt <= 0; \n  bit_cnt <= bit_cnt + 1; \n  if (bit_cnt == 10) begin \n  bit_cnt <= 0; \n  byte_cnt <= byte_cnt + 1; \n  end \n  end \n  end \n  reg [7:0] data_byte; \n  reg data_bit; \n  always @* begin \n  data_byte = 'bx; \n  case (byte_cnt) \n  0: data_byte <= \"\\r\"; \n  1: data_byte <= LED1 ? \"*\" : \"-\"; \n  2: data_byte <= LED2 ? \"*\" : \"-\"; \n  3: data_byte <= LED3 ? \"*\" : \"-\"; \n  4: data_byte <= LED4 ? \"*\" : \"-\"; \n  5: data_byte <= LED5 ? \"*\" : \"-\"; \n  endcase \n  end \n  always @(posedge clk) begin \n  data_bit = 'bx; \n  case (bit_cnt) \n  0: data_bit <= 0; \n  1: data_bit <= data_byte[0]; \n  2: data_bit <= data_byte[1]; \n  3: data_bit <= data_byte[2]; \n  4: data_bit <= data_byte[3]; \n  5: data_bit <= data_byte[4]; \n  6: data_bit <= data_byte[5]; \n  7: data_bit <= data_byte[6]; \n  8: data_bit <= data_byte[7]; \n  9: data_bit <= 1; \n  10: data_bit <= 1; \n  endcase \n  if (byte_cnt > 5) begin \n  data_bit <= 1; \n  end \n  end \n  assign TX = data_bit; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, called DMem, represents a simple data memory module. It includes read and write functionality. The module has a memory array 'mem' and a register 'data_r' for storing data. When the write signal 'wr' is asserted, the module writes data into the memory based on the 'mode' and 'add' inputs. When the read signal 'rd' is asserted, the module reads data from the memory into 'data_r' based on the 'mode' and 'add' inputs and sets the 'rd_st' flag.\n\nThe module initializes the memory contents with data from a file upon a negative edge of the 'rst_n' signal. Optionally, it includes functionality to print the memory contents to a file.\n\n Module header:\n\nmodule DMem(input wire rst_n,input wire [`WIDTH - 1:0] add,inout wire [`WIDTH - 1:0] data,input wire wr,input wire rd,output reg rd_st,input wire [1:0] mode`ifdef TRACE_MEM,input wire Print`endif);\n [/INST]\n", "output": "reg [7:0] mem [0:`WIDTH - 1]; \n  reg [`WIDTH - 1:0] data_r; \n  assign data = (rd == 1)? data_r : 32'bZ; \n  always @(posedge wr) begin \n  case (mode) \n  0: begin \n  {mem[add], mem[add+1], mem[add+2], mem[add+3]} = data; \n  end \n  1: begin \n  {mem[add], mem[add+1]} = data[15:0]; \n  end \n  2: begin \n  mem[add] = data[7:0]; \n  end \n  endcase \n  end \n  always @(posedge rd) begin \n  rd_st = 0; \n  case (mode) \n  0: begin \n  data_r = {mem[add], mem[add+1], mem[add+2], mem[add+3]}; \n  rd_st = 1; \n  end \n  1: begin \n  data_r = {16'b0 ,mem[add], mem[add+1]}; \n  rd_st = 1; \n  end \n  2: begin \n  data_r = {24'b0, mem[add]}; \n  rd_st = 1; \n  end \n  endcase \n  end \n  always @(negedge rst_n) begin \n  $readmemh(\"data.hex\", mem, 0, 20); \n  end \n `ifdef TRACE_MEM \n  always @(posedge Print) begin \n  $writememh(\"data.hex\", mem, 0, 20); \n  end \n `endif \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module performs bitwise operations on the inputs a, b, c, and d, and produces three outputs out0, out2, and out1. The output out0 is the result of a bitwise AND operation between a_in and b_in when c_in is 1, and is set to 00 when c_in is 0. The output out2 is the value of temp_a, which is produced by a submodule that processes the input a_in. The output out1 is the result of a bitwise AND operation between c_in and d_in. The outputs are updated on the rising edge of the clock signal and are synchronized with a reset signal.\n\n Module header:\n\nmodule bm_if_common(clock,reset_n,a_in,b_in,c_in,d_in,out0,out2,out1);\n [/INST]\n", "output": "input clock; \n input reset_n; \n input [`BITS-1:0] a_in; \n input [`BITS-1:0] b_in; \n input c_in; \n input d_in; \n output [`BITS-1:0] out0; \n output [`BITS-1:0] out2; \n output out1; \n reg [`BITS-1:0] out0; \n reg [`BITS-1:0] out2; \n reg out1; \n wire [`BITS-1:0] temp_a; \n wire [`BITS-1:0] temp_b; \n wire temp_c; \n wire temp_d; \n a top_a(clock, a_in, temp_a); \n always @(posedge clock) \n begin \n  if (c_in == 1'b0) \n  begin \n  out0 <= 2'b00; \n  out1 <= 1'b0; \n  end \n  else \n  begin \n  out0 <= a_in & b_in; \n  out1 <= c_in & d_in; \n  end \n  out2 <= temp_a; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a memory instance called \"StroppedMemory\" with specific configurations such as MFILE0 and MFILE1 file names, and a LOGWORDBYTE size of 3. The module includes a state machine that transitions through different states, performs read and write operations, and checks for errors in the memory access. The module also includes a test state to verify the functionality of the memory, and it displays a \"TEST PASSED\" message if the test is successful or a \"TEST FAILED\" message if there is an error. The simulation exits after displaying the appropriate message.\n\n Module header:\n\nmodule sub_test_BitMemory();\n [/INST]\n", "output": "localparam LOGWORD = 6; \n  localparam WORD = (1<<LOGWORD); \n  localparam READ = 0; \n  localparam WRITE = 1; \n  localparam DISABLE = 0; \n  localparam ENABLE = 1; \n  localparam LOGBYTE = 3; \n  wire [WORD-1:0] bit_dout; \n  reg [WORD-1:0] bit_din; \n  reg [WORD+LOGBYTE-1:0] bit_address; \n  reg [LOGWORD-1:0] bit_size; \n  reg bit_read_write; \n  reg bit_enable; \n  reg reset; \n  reg clk; \n  localparam TEST_MAX_ACCESS = 64; \n  reg [WORD-1:0] test_expect; \n  reg [WORD-1:0] test_hold; \n  reg [WORD-1:0] test_state; \n  reg test_error; \n  initial begin \n  test_state = 1; \n  reset = 1; clk = 0; #5; \n  reset = 1; clk = 1; #5; \n  reset = 1; clk = 0; #4; \n  reset = 0; clk = 0; #1; \n  while(1) begin \n  reset = 0; clk = 1; #5; \n  reset = 0; clk = 0; #4; \n  test_state = test_state + 1; \n  #1; \n  end \n  end \n  always @(*) begin \n  bit_din <= 0; \n  bit_address <= $clog2(test_state)*(test_state-1) - (1<<$clog2(test_state)) + 1; \n  bit_size <= $clog2(test_state)-1; \n  bit_read_write <= READ; \n  bit_enable <= ENABLE; \n  end \n  always @(posedge clk) begin \n  test_hold <= test_state; \n  test_expect <= test_hold; \n  #1; \n  if(($clog2(test_state) > 0) && (test_expect !== bit_dout)) begin \n $display(\"ERROR: Input:(bit_address:%d bit_size:%d) => Actual:(bit_dout:%x) Expected(test_expect:%x)\",bit_address,bit_size,bit_dout,test_expect); \n  end \n  if(reset) begin \n  test_error <= 0; \n  end \n  else begin \n  test_error <= test_error | (($clog2(test_state) > 0) && (test_expect !== bit_dout)) ; \n  end \n  if(test_state == TEST_MAX_ACCESS) begin \n  if(test_error) begin \n  $display(\"TEST FAILED\"); \n  $exit(-1); \n  end \n  else begin \n  $display(\"TEST PASSED\"); \n  $finish(); \n  end \n  end \n  end \n StroppedMemory #(.MFILE0 (\"bitmem0.hex\" ),.MFILE1 (\"bitmem1.hex\" ),.LOGWORDBYTE (3 )) \n i_stroppedmemory (.bit_dout (bit_dout ),.bit_din (bit_din ),.bit_address (bit_address ),.bit_size (bit_size ),.bit_read_write (bit_read_write ),.bit_enable (bit_enable ),.reset (reset ),.clk (clk )); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module implements a counter with the ability to increment or decrement based on the input signals. It also incorporates logic to handle underflow and overflow conditions. The count value is updated on the positive edge of the clock signal and is reset when the reset signal is asserted. The count can be increased or decreased based on the value of the inc_dec_b input, and the enable signal determines whether the counter is active. If an overflow or underflow condition is detected, the count value is set accordingly.\n\n Module header:\n\nmodule cmm_errman_cnt_nfl_en (count,index,inc_dec_b,enable,rst,clk);\n [/INST]\n", "output": "output count; \n  input index; \n  input inc_dec_b; \n  input enable; \n  input rst; \n  input clk; \n  parameter FFD = 1; \n  reg reg_cnt; \n  reg reg_extra; \n  reg reg_inc_dec_b; \n  reg reg_uflow; \n  wire cnt; \n  wire oflow; \n  wire uflow; \n  always @(posedge clk or posedge rst) \n  begin \n  if (rst) {reg_extra, reg_cnt} <= #FFD 2'b00; \n  else if (~enable) {reg_extra, reg_cnt} <= #FFD 2'b00; \n  else if (inc_dec_b) {reg_extra, reg_cnt} <= #FFD cnt + index; \n  else {reg_extra, reg_cnt} <= #FFD cnt - index; \n  end \n  assign cnt = oflow ? 1'b1 : (uflow ? 1'b0 : reg_cnt); \n  always @(posedge clk or posedge rst) \n  begin \n  if (rst) reg_inc_dec_b <= #FFD 1'b0; \n  else reg_inc_dec_b <= #FFD inc_dec_b; \n  end \n  assign oflow = reg_extra & reg_inc_dec_b; \n  always @(posedge clk or posedge rst) \n  begin \n  if (rst) \n  reg_uflow <= 1'b0; \n  else \n  reg_uflow <= #FFD ~count & index & ~inc_dec_b; \n  end \n  assign uflow = reg_uflow; \n  reg reg_count; \n  always @(posedge clk or posedge rst) \n  begin \n  if (rst) reg_count <= #FFD 1'b0; \n  else if (~enable) reg_count <= #FFD 1'b0; \n  else if (oflow) reg_count <= #FFD 1'b1; \n  else if (uflow) reg_count <= #FFD 1'b0; \n  else reg_count <= #FFD cnt; \n  end \n  assign count = reg_count; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a finite state machine that handles write and read operations for a Block RAM (BRAM) interface. The state machine is controlled by signals such as wbs_clk_i, reset_n, wbs_cyc_i, wbs_stb_i, wbs_we_i, wbs_adr_i, wbs_dat_i, wb_ack, and wb_done. It includes states for reset, idle, write, read, and delay. The module handles data writes, reads, and acknowledgements and includes logic to manage caching and modified flags. Additionally, it synchronizes input signals and implements a 3-stage synchronizer for various control signals. The module also performs address calculations and implements logic to handle different write and read operations based on the input signals.\n\n Module header:\n\nmodule ftl_wbs (input wire clk_50,input wire reset_n,input wire wbs_clk_i,input wire [31:0] wbs_adr_i,output wire [31:0] wbs_dat_o,input wire [31:0] wbs_dat_i,input wire [3:0] wbs_sel_i,input wire wbs_cyc_i,input wire wbs_stb_i,input wire wbs_we_i,output wire wbs_ack_o,output wire bram_wbs_clk,output wire [15:0] bram_wbs_addr,output reg bram_wbs_wren,output reg [31:0] bram_wbs_data,input wire [31:0] bram_wbs_q,input wire logical_init_done,output reg wb_read,output reg wb_write,output reg [9:0] wb_block,input wire wb_ack,input wire wb_done);\n [/INST]\n", "output": "assign bram_wbs_clk = wbs_clk_i; \n assign bram_wbs_addr = (wbs_adr_i % NAND_BLOCK_SIZE) / 4; \n assign wbs_ack_o = wbs_ack & wbs_stb_i; \n assign wbs_dat_o = bram_wbs_q; \n reg wbs_ack; \n reg wbs_stb_i_1; \n reg wb_done_s_1; \n wire reset_s; \n wire logical_init_done_s; \n wire wb_ack_s; \n wire wb_done_s; \n synch_3 a(reset_n, reset_s, wbs_clk_i); \n synch_3 b(logical_init_done, logical_init_done_s, wbs_clk_i); \n synch_3 c(wb_ack, wb_ack_s, wbs_clk_i); \n synch_3 d(wb_done, wb_done_s, wbs_clk_i); \n wire [9:0] req_block = wbs_adr_i / NAND_BLOCK_SIZE; \n reg [9:0] req_block_latch; \n reg [9:0] cached_block; \n reg modified; \n reg [3:0] state; \n wire ftl_valid = wbs_adr_i >= 32'h200000; \n parameter [3:0] ST_RESET = 'd0, \n  ST_IDLE = 'd1, \n  ST_READ = 'd2, \n  ST_WRITE = 'd3, \n  ST_IDLE_WAIT = 'd5, \n  ST_READ_DELAY = 'd6; \n always @(posedge wbs_clk_i) begin \n  wbs_ack <= 0; \n  wbs_stb_i_1 <= wbs_stb_i; \n  wb_done_s_1 <= wb_done_s; \n  wb_read <= 0; \n  wb_write <= 0; \n  bram_wbs_wren <= 0; \n  case(state) \n  ST_RESET: begin \n  cached_block <= -1; \n  modified <= 0; \n  if(logical_init_done_s) state <= ST_IDLE; \n  end \n  ST_IDLE: begin \n  if(wbs_cyc_i & wbs_stb_i & ~wbs_stb_i_1 & ftl_valid) begin \n  if(wbs_we_i) begin \n  if((cached_block == req_block) && modified) begin \n  bram_wbs_data <= wbs_dat_i; \n  bram_wbs_wren <= 1; \n  wbs_ack <= 1; \n  end else begin \n  state <= ST_WRITE; \n  req_block_latch <= req_block; \n  end \n  end else begin \n  if(cached_block == req_block) begin \n  state <= ST_READ_DELAY; \n  end else begin \n  state <= ST_READ; \n  req_block_latch <= req_block; \n  end \n  end \n  end \n  end \n  ST_IDLE_WAIT: begin \n  wbs_stb_i_1 <= 0; \n  if(~wb_ack_s) state <= ST_IDLE; \n  end \n  ST_WRITE: begin \n  modified <= 1; \n  wb_block <= req_block_latch; \n  wb_write <= 1; \n  if(wb_done_s & ~wb_done_s_1) begin \n  cached_block <= req_block_latch; \n  state <= ST_IDLE_WAIT; \n  end \n  end \n  ST_READ: begin \n  modified <= 0; \n  wb_block <= req_block_latch; \n  wb_read <= 1; \n  if(wb_done_s & ~wb_done_s_1) begin \n  cached_block <= req_block_latch; \n  state <= ST_IDLE_WAIT; \n  end \n  end \n  ST_READ_DELAY: begin \n  wbs_ack <= 1; \n  state <= ST_IDLE; \n  end \n  endcase \n  if(~reset_s) begin \n  state <= ST_RESET; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module converts an 8-bit binary input into Binary-Coded Decimal (BCD) output. It utilizes a combination of bit concatenation and add3 components to generate the BCD output. The ones, tens, and hundreds outputs represent the BCD representation of the input value. The internal signals c1 to c7 represent intermediate BCD digits. The add3 components serve as pulse width modulators and shift registers to manipulate the BCD representation.\n\n Module header:\n\nmodule binary_to_BCD_eight_bit(input [7:0] in,output [3:0] ones,output [3:0] tens,output [1:0] hundreds);\n [/INST]\n", "output": "wire [3:0] c1,c2,c3,c4,c5,c6,c7; \n wire [3:0] d1,d2,d3,d4,d5,d6,d7; \n assign d1 = {1'b0,in[7:5]}; \n assign d2 = {c1[2:0],in[4]}; \n assign d3 = {c2[2:0],in[3]}; \n assign d4 = {1'b0,c1[3],c2[3],c3[3]}; \n assign d5 = {c3[2:0],in[2]}; \n assign d6 = {c4[2:0],c5[3]}; \n assign d7 = {c5[2:0],in[1]}; \n add3 m1(d1,c1); \n add3 m2(d2,c2); \n add3 m3(d3,c3); \n add3 m4(d4,c4); \n add3 m5(d5,c5); \n add3 m6(d6,c6); \n add3 m7(d7,c7); \n assign ones = {c7[2:0],in[0]}; \n assign tens = {c6[2:0],c7[3]}; \n assign hundreds = {c4[3],c6[3]}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module is an HDMI interface that processes input video signals and generates corresponding output signals. It includes logic to synchronize and transform the input signals for transmission. The module interfaces with the HDMI input and output modules and uses various registers and assignments to manipulate the signals. It includes components for processing pixel clock, synchronization, and color data to create the appropriate output for transmission.\n\n Module header:\n\nmodule tb_hdmi();\n [/INST]\n", "output": "wire rx_pclk; \n wire rx_de; \n wire rx_hsync; \n wire rx_vsync; \n wire [7:0] rx_red; \n wire [7:0] rx_green; \n wire [7:0] rx_blue; \n wire tx_de; \n wire tx_hsync; \n wire tx_vsync; \n wire [7:0] tx_red; \n wire [7:0] tx_green; \n wire [7:0] tx_blue; \n hdmi_in file_input (.hdmi_clk(rx_pclk),.hdmi_de(rx_de),.hdmi_hs(rx_hsync),.hdmi_vs(rx_vsync),.hdmi_r(rx_red),.hdmi_g(rx_green),.hdmi_b(rx_blue)); \n  wire [7:0] lut_blue; \n  wire [7:0] lut_red; \n  wire [7:0] lut_green; \n BINARYZACJA lut_r (.a(rx_red),.clk(rx_pclk),.qspo(lut_red)); \n BINARYZACJA lut_g (.a(rx_green),.clk(rx_pclk),.qspo(lut_green)); \n BINARYZACJA lut_b (.a(rx_blue),.clk(rx_pclk),.qspo(lut_blue)); \n reg lut_de = 0; \n reg lut_hsync = 0; \n reg lut_vsync = 0; \n always @(posedge rx_pclk) \n begin \n  lut_de <= rx_de; \n  lut_hsync <= rx_hsync; \n  lut_vsync <= rx_vsync; \n end \n  assign tx_de = lut_de; \n  assign tx_hsync = lut_hsync; \n  assign tx_vsync = lut_vsync; \n  assign tx_blue = lut_blue & lut_green & lut_red; \n  assign tx_green = lut_blue & lut_green & lut_red; \n  assign tx_red = lut_blue & lut_green & lut_red; \n hdmi_out file_output (.hdmi_clk(rx_pclk),.hdmi_vs(tx_vsync),.hdmi_de(tx_de),.hdmi_data({8'b0,tx_red,tx_green,tx_blue})); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module declares an output port \"tr_data\" of 36 bits and assigns it a constant value of 0.\n\n Module header:\n\nmodule nios_dut_nios2_gen2_0_cpu_nios2_oci_pib (tr_data);\n [/INST]\n", "output": "output [ 35: 0] tr_data; \n  wire [ 35: 0] tr_data; \n  assign tr_data = 0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module implements an inverter, where the output Y is the logical negation of the input A.\n\n Module header:\n\nmodule INV (input A,output Y);\n [/INST]\n", "output": "assign Y = !A; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module named logic_0 assigns the output \"a\" to logic 0. It simply sets the output \"a\" to 0 without any dependency on clock signal or other inputs.\n\n Module header:\n\nmodule logic_0(output a);\n [/INST]\n", "output": "assign a = 0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, named WBDevIntercon, is an interconnection module for a CPU and various devices. It includes address decoding for different devices based on the input CPU address. It also sets the STB (strobe) and WE (write enable) signals for the CPU and the devices. It combines data from the different devices and outputs it to the CPU. The module also handles the ACK (acknowledge) signals from the devices and provides the appropriate ACK signal to the CPU.\n\n Module header:\n\nmodule WBDevIntercon (output [7:0] cpu_dat_o,output cpu_ack_o,input [7:0] cpu_dat_i,input cpu_we_i,input [7:0] cpu_adr_i,input cpu_cyc_i,input cpu_stb_i,input [7:0] rs2_dat_i,input rs2_ack_i,output [7:0] rs2_dat_o,output rs2_we_o,output [0:0] rs2_adr_o,output rs2_stb_o,input [7:0] ad_dat_i,input ad_ack_i,output [7:0] ad_dat_o,output ad_we_o,output [0:0] ad_adr_o,output ad_stb_o,input [7:0] tmr_dat_i,input tmr_ack_i,output [7:0] tmr_dat_o,output tmr_we_o,output [2:0] tmr_adr_o,output tmr_stb_o,input [7:0] t16_dat_i,input t16_ack_i,output [7:0] t16_dat_o,output t16_we_o,output [0:0] t16_adr_o,output t16_stb_o,input wb_clk_i,input wb_rst_i);\n [/INST]\n", "output": "wire rs2_ss; \n wire ad_ss; \n wire tmr_ss; \n wire t16_ss; \n wire [7:0] adr; \n assign adr=cpu_adr_i; \n assign rs2_ss=adr[7:6]==2'b00; \n assign ad_ss=adr[7:6]==2'b01; \n assign tmr_ss=adr[7:6]==2'b10; \n assign t16_ss=adr[7:6]==2'b11; \n assign rs2_adr_o=adr[0:0]; \n assign ad_adr_o=adr[0:0]; \n assign tmr_adr_o=adr[2:0]; \n assign t16_adr_o=adr[0:0]; \n wire stb_m2s; \n wire we_m2s; \n wire ack_s2m; \n wire [7:0] dat_m2s; \n wire [7:0] dat_s2m; \n assign stb_m2s=cpu_stb_i; \n assign rs2_stb_o=rs2_ss & stb_m2s; \n assign ad_stb_o=ad_ss & stb_m2s; \n assign tmr_stb_o=tmr_ss & stb_m2s; \n assign t16_stb_o=t16_ss & stb_m2s; \n assign we_m2s=cpu_we_i; \n assign rs2_we_o=we_m2s; \n assign ad_we_o=we_m2s; \n assign tmr_we_o=we_m2s; \n assign t16_we_o=we_m2s; \n assign ack_s2m=rs2_ack_i | ad_ack_i | tmr_ack_i | t16_ack_i; \n assign cpu_ack_o=ack_s2m; \n assign dat_m2s=cpu_dat_i; \n assign rs2_dat_o=dat_m2s; \n assign ad_dat_o=dat_m2s; \n assign tmr_dat_o=dat_m2s; \n assign t16_dat_o=dat_m2s; \n assign dat_s2m=(rs2_dat_i & {8{rs2_ss}}) | (ad_dat_i & {8{ad_ss}}) | (tmr_dat_i & {8{tmr_ss}}) | (t16_dat_i & {8{t16_ss}}); \n assign cpu_dat_o=dat_s2m; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module implements a velocity control function that takes three signed 18-bit inputs (in0, in1, in2) and produces a single signed 18-bit output (out0). It uses a two-stage comparison to select the maximum value among the inputs, and the result is driven to the output.\n\n Module header:\n\nmodule velocityControlHdl_MinMax1 (in0,in1,in2,out0);\n [/INST]\n", "output": "input signed [17:0] in0; \n  input signed [17:0] in1; \n  input signed [17:0] in2; \n  output signed [17:0] out0; \n  wire signed [17:0] MinMax1_muxout [0:2]; \n  wire signed [17:0] MinMax1_stage1_val [0:1]; \n  wire signed [17:0] MinMax1_stage2_val; \n  assign MinMax1_muxout[0] = in0; \n  assign MinMax1_muxout[1] = in1; \n  assign MinMax1_muxout[2] = in2; \n assign MinMax1_stage1_val[0] = (MinMax1_muxout[0] >= MinMax1_muxout[1] ? MinMax1_muxout[0] :MinMax1_muxout[1]); \n  assign MinMax1_stage1_val[1] = MinMax1_muxout[2]; \n assign MinMax1_stage2_val = (MinMax1_stage1_val[0] >= MinMax1_stage1_val[1] ? MinMax1_stage1_val[0] :MinMax1_stage1_val[1]); \n  assign out0 = MinMax1_stage2_val; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes input signals ebi_cs2_s_io and ebi_cs3_s_io and assigns them to the output signals p_mix_ebi_cs2_s_io_go and p_mix_ebi_cs3_s_io_go, respectively. The module also instantiates two submodule instances, vgch_suba and vgch_subb. The output signal p_mix_ebi_cs2_s_io_go is connected directly to the input signal ebi_cs3_s_io, and the output signal p_mix_ebi_cs3_s_io_go is not directly connected to any input signal within this module.\n\n Module header:\n\nmodule vgch_core (p_mix_ebi_cs2_s_io_go,p_mix_ebi_cs3_s_io_go);\n [/INST]\n", "output": "output p_mix_ebi_cs2_s_io_go; \n  output p_mix_ebi_cs3_s_io_go; \n  wire p_mix_ebi_cs2_s_io_go; \n  wire p_mix_ebi_cs3_s_io_go; \n  wire ebi_cs2_s_io; \n  wire ebi_cs3_s_io; \n  assign p_mix_ebi_cs2_s_io_go = ebi_cs2_s_io; \n  assign p_mix_ebi_cs3_s_io_go = ebi_cs3_s_io; \n vgch_suba vgch_suba_i (); \n vgch_subb vgch_subb_i (.ebi_cs3_s_io_go(ebi_cs3_s_io),.p_mix_ebi_cs2_s_io_go(ebi_cs2_s_io)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a state machine for transmitting characters over a UART interface. It uses control signals such as Start, Reset, tx_full, uartClock, and a parameterized RAMAddress to manage the transmission process. The module also handles special characters like newline and carriage return and updates the RAMAddress and specialCharacter accordingly. The state transitions and control logic are driven by the clock signal.\n\n Module header:\n\nmodule SendChars(NumberOfChars, Clock, Reset, Start, tx_full, uartClock, RAMAddress, Transmitting, write_to_uart);\n [/INST]\n", "output": "input [5:0] NumberOfChars; \n  input Clock, Reset, Start, tx_full, uartClock; \n  output reg [5:0] RAMAddress; \n  output reg Transmitting, write_to_uart; \n  reg [1:0] specialCharacter; \n  parameter [5:0] newline = 6'd32; \n  parameter [5:0] carriagereturn = 6'd33; \n  always @ (posedge Clock) \n  if (Reset == 1) begin write_to_uart <= 1'b0; RAMAddress <= 6'd0; specialCharacter <= 2'd0; Transmitting <= 1'b0; end \n  else if (Start == 1'b1 && Transmitting == 1'b0) begin Transmitting <= 1'b1; write_to_uart <= 1; end \n  else case ({tx_full, Transmitting, uartClock, specialCharacter}) \n  5'b01100: begin \n  write_to_uart <= 1; \n  if (RAMAddress+2>NumberOfChars) begin RAMAddress <= newline; specialCharacter <= 2'd1; end \n  else RAMAddress <= RAMAddress + 1'b1; \n  end \n  5'b01101: begin \n  write_to_uart <= 1; \n  RAMAddress <= carriagereturn; \n  specialCharacter <= 2'd2; \n  end \n  5'b01110: begin \n  write_to_uart <= 0; \n  Transmitting <= 1'b0; \n  RAMAddress <= 6'd0; \n  specialCharacter <= 2'd0; \n  end \n  default: begin \n  write_to_uart <= 1'b0; \n  end \n  endcase \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, axi_traffic_gen_v2_0_7_static_cmdgen, is a configurable static command generator for AXI interfaces. The module supports different data widths and system modes through parameters. It generates memory write and read commands based on the input control signals, data, and address. The module also handles system initialization and test modes, and supports different data widths through generate blocks. The outputs cmd_out_mw, cmd_out_mr, and cmd_data are assigned based on the system mode and data width configurations. Additionally, the module includes control signals for system initialization and test modes, and manages the system initialization enable and command enable based on the ROM address.\n\n Module header:\n\nmodule axi_traffic_gen_v2_0_7_static_cmdgen # (parameter C_ATG_STATIC_ADDRESS = 32'h12A0_0000,parameter C_M_AXI_DATA_WIDTH = 32 ,parameter C_ATG_MIF_ADDR_BITS = 4 ,parameter C_ATG_STATIC_LENGTH = 3,parameter C_ATG_SYSTEM_INIT = 0,parameter C_ATG_SYSTEM_TEST = 0) (input Clk ,input rst_l ,input static_ctl_en ,input [7:0] static_len ,input [9:0] rom_addr_ptr_ff,input [31:0] rom_addr ,input [31:0] rom_data ,output [127:0] cmd_out_mw ,output [C_M_AXI_DATA_WIDTH-1:0] cmd_data ,output [127:0] cmd_out_mr);\n [/INST]\n", "output": "wire [2:0] size; \n generate if(C_M_AXI_DATA_WIDTH == 32 ) begin : M_SISE32 \n  assign size = 3'b010; \n end \n endgenerate \n generate if(C_M_AXI_DATA_WIDTH == 64 ) begin : M_SISE64 \n  assign size = 3'b011; \n end \n endgenerate \n generate if(C_M_AXI_DATA_WIDTH == 128 ) begin : M_SISE128 \n  assign size = 3'b100; \n end \n endgenerate \n generate if(C_M_AXI_DATA_WIDTH == 256 ) begin : M_SISE256 \n  assign size = 3'b101; \n end \n endgenerate \n generate if(C_M_AXI_DATA_WIDTH == 512 ) begin : M_SISE512 \n  assign size = 3'b110; \n end \n endgenerate \n wire [5:0] id = 6'h0; \n wire [1:0] burst = 2'b01; \n reg [7:0] len = 8'h0; \n always @(posedge Clk) begin \n  len[7:0] <= (rst_l) ? static_len[7:0] : C_ATG_STATIC_LENGTH; \n end \n generate if(C_ATG_SYSTEM_INIT == 0 &&C_ATG_SYSTEM_TEST == 0 ) begin : STATIC_MODE_ON \n assign cmd_out_mw = { \n  32'h0, \n  32'h0, \n  static_ctl_en,7'h0,3'b010,id,size,burst,2'b00,len, \n  C_ATG_STATIC_ADDRESS \n  }; \n assign cmd_out_mr = { \n  32'h0, \n  32'h0, \n  static_ctl_en,7'h0,3'b010,id,size,burst,2'b00,len, \n  C_ATG_STATIC_ADDRESS \n  }; \n assign cmd_data[C_M_AXI_DATA_WIDTH-1:0] = { \n  64'hCAFE5AFE_C001CAFE, \n  64'hCAFE1AFE_C001DAFE, \n  64'hCAFE2AFE_C001EAFE, \n  64'hCAFE3AFE_C001FAFE \n  }; \n end \n endgenerate \n wire system_init_en; \n wire system_init_cnt_en; \n wire system_init_cmd_en; \n assign system_init_cnt_en = (rom_addr_ptr_ff[C_ATG_MIF_ADDR_BITS] != 1'b1); \n assign system_init_cmd_en = ~(&rom_addr); \n assign system_init_en = system_init_cnt_en && system_init_cmd_en; \n generate if(C_ATG_SYSTEM_INIT == 1 || C_ATG_SYSTEM_TEST == 1 ) begin : SYSTEM_INIT_TEST_MODE_ON \n assign cmd_out_mw = { \n  32'h0, \n  32'h0, \n  system_init_en,7'h0,3'b010,id,size,burst,2'b00,8'h0, \n  rom_addr[31:0] \n  }; \n assign cmd_data[C_M_AXI_DATA_WIDTH-1:0] = rom_data[31:0]; \n end \n endgenerate \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"axis_snapshot\" is a synchronizer that captures incoming data on the s_axis_tdata input and outputs it on the data output. It also manages the ready signals for the AXI-Stream interface. The module includes combinational logic for synchronizing data, as well as logic for managing the enable and done signals. It also has conditional blocks to handle cases where the module is always ready or if it is blocking. The module uses internal registers to capture and update the data and control signals based on the input conditions.\n\n Module header:\n\nmodule axis_snapshot # (parameter integer AXIS_TDATA_WIDTH = 32,parameter ALWAYS_READY = \"TRUE\") (input wire aclk,input wire aresetn,input wire [AXIS_TDATA_WIDTH-1:0] s_axis_tdata,input wire s_axis_tvalid,output wire s_axis_tready,input wire m_axis_tready,output wire [AXIS_TDATA_WIDTH-1:0] data);\n [/INST]\n", "output": "reg [AXIS_TDATA_WIDTH-1:0] int_data_reg,int_data_reg_next; \n reg int_enbl_reg, int_enbl_next, int_done, int_done_next; \n always @(posedge aclk) \n  begin \n  if(~aresetn) \n  begin \n  int_data_reg <= {(AXIS_TDATA_WIDTH-1){1'b0}}; \n  int_enbl_reg <= 1'b0; \n  int_done <= 1'b0; \n  end \n  else \n  begin \n  int_enbl_reg <= int_enbl_next; \n  int_data_reg <= int_data_reg_next; \n  int_done <= int_done_next; \n  end \n  end \n always @* \n  begin \n  int_data_reg_next = int_data_reg; \n  int_enbl_next = int_enbl_reg; \n  int_done_next = int_done; \n  if(~int_enbl_reg & ~ int_done) \n  begin \n  int_enbl_next = 1'b1; \n  end \n  if(int_enbl_reg & s_axis_tvalid) \n  begin \n  int_data_reg_next = s_axis_tdata; \n  int_done_next = 1'b1; \n  int_enbl_next = 1'b0; \n  end \n  end \n  generate \n  if(ALWAYS_READY == \"TRUE\") \n  begin : READY \n  assign s_axis_tready = 1'b1; \n  end \n  else \n  begin : BLOCKING \n  assign s_axis_tready = m_axis_tready; \n  end \n  endgenerate \n  assign data = int_data_reg; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module T is comprised of two instances of module S - s0 and s4. It takes an 8-bit input 'in' and produces a 32-bit output 'out'. The 'out' is generated by assigning the upper 8 bits of 'out' directly from the s0 module, and the next 8 bits are assigned by a bitwise XOR operation between the previous 8 bits of 'out' and the lower 8 bits from the s4 module.\n\n Module header:\n\nmodule T (clk, in, out);\n [/INST]\n", "output": "input clk; \n  input [7:0] in; \n  output [31:0] out; \n  S \n  s0 (clk, in, out[31:24]); \n  assign out[23:16] = out[31:24]; \n  xS \n  s4 (clk, in, out[7:0]); \n  assign out[15:8] = out[23:16] ^ out[7:0]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `servo_moving_test` implements a state machine to control the `pwm_angle` output based on the `clk` and `rst_n` inputs. It initializes the state and counter variables and uses a case statement to transition between two states (`S0` and `S1`). The state machine adjusts the `pwm_angle` in increments or decrements based on the `flag` variable and the `STEP` parameter. The state machine also uses a counter to control state transitions and the `flag` to determine the direction of the `pwm_angle` adjustment.\n\n Module header:\n\nmodule servo_moving_test(clk,rst_n,pwm_angle);\n [/INST]\n", "output": "input clk,rst_n; \n output reg [15:0] pwm_angle; \n reg [7:0] counter; \n reg [3:0] state; \n reg flag; \n parameter S0=4'd0,S1=4'd1; \n parameter STEP=20; \n always @ (posedge clk or negedge rst_n) \n if(!rst_n) \n  begin \n  counter <= 0; \n  state <= S0; \n  flag <= 1; \n  pwm_angle <= 1500; \n  end \n else \n  begin \n  case(state) \n  S0: begin \n  if( counter < 5 ) begin \n  counter <= 0; \n  state <= S1; \n  end \n  else begin \n  counter <= counter + 1; \n  state <= S0; \n  end \n  end \n  S1: begin \n  state <= S0; \n  if(flag) begin \n  if(pwm_angle <= (2400 - STEP)) begin \n  pwm_angle <= pwm_angle + STEP; \n  end \n  else begin \n  pwm_angle <= pwm_angle; \n  flag = 0; \n  end \n  end \n  else begin \n  if(pwm_angle >= (600 + STEP)) begin \n  pwm_angle <= pwm_angle - STEP; \n  end \n  else begin \n  pwm_angle <= pwm_angle; \n  flag = 1; \n  end \n  end \n  end \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an instance of a DDR (double data rate) flip-flop. It takes in a clock signal, an enable signal, and a data input, and it has two data outputs. On the positive edge of the clock, the input data is loaded into q1, and on the negative edge of the clock, the input data is loaded into q2. The module then outputs q1 and q2.\n\n Module header:\n\nmodule oh_iddr #(parameter DW = 1) (input clk,input ce,input [DW-1:0] din,output reg [DW-1:0] q1,output reg [DW-1:0] q2);\n [/INST]\n", "output": "reg [DW-1:0] q1_sl; \n  reg [DW-1:0] q2_sh; \n  always @ (posedge clk) \n  if(ce) \n  q1_sl[DW-1:0] <= din[DW-1:0]; \n  always @ (negedge clk) \n  q2_sh[DW-1:0] <= din[DW-1:0]; \n  always @ (posedge clk) \n  begin \n  q1[DW-1:0] <= q1_sl[DW-1:0]; \n  q2[DW-1:0] <= q2_sh[DW-1:0]; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a 40x7 bit RAM that operates with a clock and reset signal. It has inputs for the address, data input, write enable, clock, and reset, and outputs the data output. The RAM is implemented using a register array called Data. When the reset signal is high, the Data array is initialized with specific values. When the write enable is high, the module writes the input data to the specified address in the Data array. The output Dout is assigned the value stored at the specified address in the Data array.\n\n Module header:\n\nmodule RAM40x7bits(Address, Din, Clock, Reset, WriteEnabled, Dout);\n [/INST]\n", "output": "input [5:0] Address; \n  input [6:0] Din; \n  input Reset; \n  input Clock, WriteEnabled; \n  output [6:0] Dout; \n  reg [6:0] Data [39:0]; \n  always@(posedge Clock or posedge Reset) \n  if (Reset == 1) begin \n  Data[0] <= \"E\"; \n  Data[1] <= \"C\"; \n  Data[2] <= \"E\"; \n  Data[3] <= \"3\"; \n  Data[4] <= \"3\"; \n  Data[5] <= \"3\"; \n  Data[6] <= \" \"; \n  Data[7] <= \"F\"; \n  Data[8] <= \"a\"; \n  Data[9] <= \"l\"; \n  Data[10] <= \"l\"; \n  Data[11] <= \" \"; \n  Data[12] <= \"2\"; \n  Data[13] <= \"0\"; \n  Data[14] <= \"1\"; \n  Data[15] <= \"5\"; \n  Data[16] <= \" \"; \n  Data[17] <= \"D\"; \n  Data[18] <= \"i\"; \n  Data[19] <= \"g\"; \n  Data[20] <= \"i\"; \n  Data[21] <= \"t\"; \n  Data[22] <= \"a\"; \n  Data[23] <= \"l\"; \n  Data[24] <= \" \"; \n  Data[25] <= \"S\"; \n  Data[26] <= \"y\"; \n  Data[27] <= \"s\"; \n  Data[28] <= \"t\"; \n  Data[29] <= \"e\"; \n  Data[30] <= \"m\"; \n  Data[31] <= \"s\"; \n  Data[32] <= \"\\n\"; \n  Data[33] <= \"\\r\"; \n  end \n  else if (WriteEnabled == 1) Data[Address] <= Din; \n  assign Dout = Data[Address]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"system_auto_cc_0_synchronizer_ff__parameterized5\" is a parameterized flip-flop-based synchronizer. It includes an asynchronous reset and four flip-flops to synchronize the input signal \"D\" to the clock signal \"m_aclk.\" The synchronized output \"out\" is derived from the synchronized flip-flop outputs \"Q_reg.\" The asynchronous reset signal \"AR\" is used to clear the flip-flops.\n\nThe module implements four FDCE (Flip-flop with Asynchronous Reset) instances, each of which synchronizes a corresponding bit of the input signal \"D\" to the clock signal. These flip-flops are parameterized with an initial value of 0. Additionally, a LUT2 (Look-Up Table with 2 inputs) instance combines the synchronized flip-flop outputs to generate the synchronized output \"out.\"\n\nThe module includes several attributes and comments related to message enable, asynchronous register, and keeping specific parameters. These attributes and comments provide information for design constraints and messages during synthesis.\n\nIn summary, the Verilog module is designed to synchronize an input signal to a clock signal using flip-flops with asynchronous reset and generate the synchronized output \"out\" based on the synchronized flip-flop outputs.\n\n Module header:\n\nmodule system_auto_cc_0_synchronizer_ff__parameterized5 (out,D,\\Q_reg_reg[3]_0 ,m_aclk,AR);\n [/INST]\n", "output": "output [3:0]out; \n  output [0:0]D; \n  input [3:0]\\Q_reg_reg[3]_0 ; \n  input m_aclk; \n  input [0:0]AR; \n  wire [0:0]AR; \n  wire [0:0]D; \n  (* async_reg = \"true\" *) (* msgon = \"true\" *) wire [3:0]Q_reg; \n  wire [3:0]\\Q_reg_reg[3]_0 ; \n  wire m_aclk; \n  assign out[3:0] = Q_reg; \n  (* ASYNC_REG *) \n  (* KEEP = \"yes\" *) \n  (* msgon = \"true\" *) \n FDCE #(.INIT(1'b0)) \n  \\Q_reg_reg[0] \n (.C(m_aclk),.CE(1'b1),.CLR(AR),.D(\\Q_reg_reg[3]_0 [0]),.Q(Q_reg[0])); \n  (* ASYNC_REG *) \n  (* KEEP = \"yes\" *) \n  (* msgon = \"true\" *) \n FDCE #(.INIT(1'b0)) \n  \\Q_reg_reg[1] \n (.C(m_aclk),.CE(1'b1),.CLR(AR),.D(\\Q_reg_reg[3]_0 [1]),.Q(Q_reg[1])); \n  (* ASYNC_REG *) \n  (* KEEP = \"yes\" *) \n  (* msgon = \"true\" *) \n FDCE #(.INIT(1'b0)) \n  \\Q_reg_reg[2] \n (.C(m_aclk),.CE(1'b1),.CLR(AR),.D(\\Q_reg_reg[3]_0 [2]),.Q(Q_reg[2])); \n  (* ASYNC_REG *) \n  (* KEEP = \"yes\" *) \n  (* msgon = \"true\" *) \n FDCE #(.INIT(1'b0)) \n  \\Q_reg_reg[3] \n (.C(m_aclk),.CE(1'b1),.CLR(AR),.D(\\Q_reg_reg[3]_0 [3]),.Q(Q_reg[3])); \n LUT2 #(.INIT(4'h6)) \n  \\gnxpm_cdc.rd_pntr_bin[2]_i_1__1 \n (.I0(Q_reg[2]),.I1(Q_reg[3]),.O(D)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a simple synchronous sequential circuit. It consists of two registers, reg1 and reg2, which are updated on the rising edge of the clock signal. When the reset signal is asserted, both registers are reset to 0. Otherwise, reg1 is loaded with the input 'in' while reg2 receives the previous value of reg1. The output 'out' is assigned 1 if the concatenation of reg2 and reg1 is equal to 2'b01, otherwise it is assigned 0.\n\n Module header:\n\nmodule func6(clk, reset, in, out);\n [/INST]\n", "output": "input clk, reset, in; \n  output out; \n  reg reg1, reg2; \n  always @ (posedge clk) \n  if (reset) \n  begin \n  reg1 <= 0; reg2 <= 0; \n  end \n  else \n  begin \n  reg2 <= reg1; reg1 <= in; \n  end \n  assign out = {reg2,reg1}==2'b01 ? 1 : 0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a UART receiver stimulus source. It receives inputs such as the baud divisor, clock signals, reset signals, and received data signals. It also has internal registers and wires to control the stimulus data transmission and pick up pulses. It interfaces with a UART transmitter and a character source ROM module. The module operates based on the clock and reset signals to control the transmission of stimulus data.\n\n Module header:\n\nmodule uart_rx_stimulus_source (baud_divisor,clk,clk_en,reset_n,rx_char_ready,rxd,source_rxd);\n [/INST]\n", "output": "output source_rxd; \n  input [ 8: 0] baud_divisor; \n  input clk; \n  input clk_en; \n  input reset_n; \n  input rx_char_ready; \n  input rxd; \n  reg [ 7: 0] d1_stim_data; \n  reg delayed_unxrx_char_readyxx0; \n  wire do_send_stim_data; \n  wire new_rom_pulse; \n  wire pickup_pulse; \n  wire safe; \n  wire source_rxd; \n  wire [ 7: 0] stim_data; \n  wire unused_empty; \n  wire unused_overrun; \n  wire unused_ready; \n  uart_tx stimulus_transmitter \n (.baud_divisor (baud_divisor),.begintransfer (do_send_stim_data),.clk (clk),.clk_en (clk_en),.do_force_break (1'b0),.reset_n (reset_n),.status_wr_strobe (1'b0),.tx_data (d1_stim_data),.tx_overrun (unused_overrun),.tx_ready (unused_ready),.tx_shift_empty (unused_empty),.tx_wr_strobe (1'b1),.txd (source_rxd)); \n  always @(posedge clk or negedge reset_n) \n  begin \n  if (reset_n == 0) \n  d1_stim_data <= 0; \n  else if (do_send_stim_data) \n  d1_stim_data <= stim_data; \n  end \n  uart_rx_stimulus_source_character_source_rom_module uart_rx_stimulus_source_character_source_rom \n (.clk (clk),.incr_addr (do_send_stim_data),.new_rom (new_rom_pulse),.q (stim_data),.reset_n (reset_n),.safe (safe)); \n  always @(posedge clk or negedge reset_n) \n  begin \n  if (reset_n == 0) \n  delayed_unxrx_char_readyxx0 <= 0; \n  else if (clk_en) \n  delayed_unxrx_char_readyxx0 <= rx_char_ready; \n  end \n  assign pickup_pulse = ~(rx_char_ready) & (delayed_unxrx_char_readyxx0); \n  assign do_send_stim_data = (pickup_pulse || new_rom_pulse) && safe; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements an HDMI interface for video output. It takes in clock signals with frequencies of 125 MHz and 25 MHz, horizontal and vertical synchronization signals, active signal for HDMI output, RGB signal, and outputs TMDS and TMDSB signals for transmitting video data. Additionally, it takes in HDMI CEC and Hot Plug Detect signals, and outputs an HDMI output enable signal. The module contains an instantiation of the `system_zybo_hdmi_0_0_zybo_hdmi` module and connects the input and output signals accordingly. The `hdmi_out_en` signal is assigned a constant value of 1. The `tmds` and `tmdsb` output signals have a slew rate set to \"SLOW\" to control signal transitions. The module also includes a VCC power supply and sets pull-up/pull-down resistors for the HDMI output enable signal.\n\n Module header:\n\nmodule system_zybo_hdmi_0_0 (clk_125,clk_25,hsync,vsync,active,rgb,tmds,tmdsb,hdmi_cec,hdmi_hpd,hdmi_out_en);\n [/INST]\n", "output": "input clk_125; \n  input clk_25; \n  input hsync; \n  input vsync; \n  input active; \n  input [23:0]rgb; \n  output [3:0]tmds; \n  output [3:0]tmdsb; \n  input hdmi_cec; \n  input hdmi_hpd; \n  output hdmi_out_en; \n  wire \\<const1> ; \n  wire active; \n  wire clk_125; \n  wire clk_25; \n  wire hsync; \n  wire [23:0]rgb; \n  (* SLEW = \"SLOW\" *) wire [3:0]tmds; \n  (* SLEW = \"SLOW\" *) wire [3:0]tmdsb; \n  wire vsync; \n  assign hdmi_out_en = \\<const1> ; \n  system_zybo_hdmi_0_0_zybo_hdmi U0 \n (.active(active),.clk_125(clk_125),.clk_25(clk_25),.hsync(hsync),.rgb(rgb),.tmds(tmds),.tmdsb(tmdsb),.vsync(vsync)); \n  VCC VCC \n  (.P(\\<const1> )); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module appears to be a structural design, where various components (instances of other modules) are connected together. The module instantiates multiple instances of other modules, makes interconnections among them, and assigns the outputs of some instances to the module outputs. The primary functionality seems to be the instantiation and interconnection of the sub-modules.\n\n Module header:\n\nmodule v370cd6 (input v6dda25,input [3:0] v2856c0,input vccca56,output [3:0] v7891f9);\n [/INST]\n", "output": "wire w0; \n  wire w1; \n  wire w2; \n  wire w3; \n  wire w4; \n  wire w5; \n  wire [0:3] w6; \n  wire [0:3] w7; \n  wire w8; \n  wire w9; \n  wire w10; \n  wire w11; \n  wire w12; \n  wire w13; \n  wire w14; \n  wire w15; \n  wire w16; \n  wire w17; \n  assign w6 = v2856c0; \n  assign v7891f9 = w7; \n  assign w10 = v6dda25; \n  assign w11 = v6dda25; \n  assign w12 = v6dda25; \n  assign w13 = v6dda25; \n  assign w14 = vccca56; \n  assign w15 = vccca56; \n  assign w16 = vccca56; \n  assign w17 = vccca56; \n  assign w11 = w10; \n  assign w12 = w10; \n  assign w12 = w11; \n  assign w13 = w10; \n  assign w13 = w11; \n  assign w13 = w12; \n  assign w15 = w14; \n  assign w16 = w14; \n  assign w16 = w15; \n  assign w17 = w14; \n  assign w17 = w15; \n  assign w17 = w16; \n v22cb98 v1ba30c (.v27dec4(w0),.v4642b6(w2),.ve4a668(w12),.vd793aa(w16)); \n v22cb98 v38f79d (.v27dec4(w1),.v4642b6(w3),.ve4a668(w13),.vd793aa(w17)); \n v22cb98 v009467 (.v27dec4(w4),.v4642b6(w5),.ve4a668(w11),.vd793aa(w15)); \n vc4f23a vf2e2c0 (.v3f8943(w0),.v64d863(w1),.vda577d(w4),.v985fcb(w6),.v4f1fd3(w8)); \n v84f0a1 v947047 (.vee8a83(w2),.v03aaf0(w3),.vf8041d(w5),.v11bca5(w7),.vd84a57(w9)); \n v22cb98 v3a0f4c (.v27dec4(w8),.v4642b6(w9),.ve4a668(w10),.vd793aa(w14)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a D flip-flop with set and reset functionality. The output q is updated on the positive edge of the clock signal or the positive edge of the asynchronous reset signal. If the reset signal is asserted, q is set to the inverted value of d (d^d), otherwise, q is set to the value of d.\n\n Module header:\n\nmodule dffsr1(clk, arst, d, q);\n [/INST]\n", "output": "input clk, arst, d; \n output reg q; \n always @(posedge clk, posedge arst) begin \n  if (arst) \n  q <= d^d; \n  else \n  q <= d; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe `auddma_engine` module implements an audio Direct Memory Access (DMA) engine. It includes parameters for audio data, registers for storing audio channel data, and logic for managing DMA operations.\n\nThe module interfaces with a clock signal and various input and output signals. It has logic for setting and checking different control signals, such as `audlcena` and `audlcsel`, based on input conditions.\n\nThe module contains registers and wires to store and manipulate audio data, manage DMA operations, and determine the audio channel for data transfer. The module also has logic for updating and assigning the DMA output based on the audio DMA signals and the audio channel.\n\nAdditionally, the module has a case structure to handle different channel operations and a parameterized output for the `reg_address_out` signal based on the selected audio data.\n\nIn summary, the `auddma_engine` module is responsible for controlling audio DMA operations, managing audio channel data, and handling audio data transfers based on specified conditions.\n\n Module header:\n\nmodule auddma_engine (input clk,output dma,input [3:0] audio_dmal,input [3:0] audio_dmas,input [8:0] hpos,input [8:1] reg_address_in,output reg [8:1] reg_address_out,input [15:0] data_in,output [20:1] address_out);\n [/INST]\n", "output": "parameter AUD0DAT = 9'h0AA; \n parameter AUD1DAT = 9'h0BA; \n parameter AUD2DAT = 9'h0CA; \n parameter AUD3DAT = 9'h0DA; \n wire audlcena; \n wire [1:0] audlcsel; \n reg [20:16] audlch [3:0]; \n reg [15:1] audlcl [3:0]; \n wire [20:1] audlcout; \n reg [20:1] audpt [3:0]; \n wire [20:1] audptout; \n reg [1:0] channel; \n reg dmal; \n reg dmas; \n assign audlcena = ~reg_address_in[8] & reg_address_in[7] & (reg_address_in[6]^reg_address_in[5]) & ~reg_address_in[3] & ~reg_address_in[2]; \n assign audlcsel = {~reg_address_in[5],reg_address_in[4]}; \n always @(posedge clk) \n  if (audlcena & ~reg_address_in[1]) \n  audlch[audlcsel] <= data_in[4:0]; \n always @(posedge clk) \n  if (audlcena & reg_address_in[1]) \n  audlcl[audlcsel] <= data_in[15:1]; \n assign audlcout = {audlch[channel],audlcl[channel]}; \n always @(hpos or audio_dmal) \n  case (hpos) \n  9'b0001_0010_1 : dmal = audio_dmal[0]; \n  9'b0001_0100_1 : dmal = audio_dmal[1]; \n  9'b0001_0110_1 : dmal = audio_dmal[2]; \n  9'b0001_1000_1 : dmal = audio_dmal[3]; \n  default : dmal = 0; \n  endcase \n assign dma = dmal; \n always @(hpos or audio_dmas) \n  case (hpos) \n  9'b0001_0010_1 : dmas = audio_dmas[0]; \n  9'b0001_0100_1 : dmas = audio_dmas[1]; \n  9'b0001_0110_1 : dmas = audio_dmas[2]; \n  9'b0001_1000_1 : dmas = audio_dmas[3]; \n  default : dmas = 0; \n  endcase \n always @(hpos) \n  case (hpos[3:2]) \n  2'b01 : channel = 0; \n  2'b10 : channel = 1; \n  2'b11 : channel = 2; \n  2'b00 : channel = 3; \n  endcase \n assign address_out[20:1] = audptout[20:1]; \n always @(posedge clk) \n  if (dmal) \n  audpt[channel] <= dmas ? audlcout[20:1] : audptout[20:1] + 1'b1; \n assign audptout[20:1] = audpt[channel]; \n always @(channel) \n  case (channel) \n  0 : reg_address_out[8:1] = AUD0DAT[8:1]; \n  1 : reg_address_out[8:1] = AUD1DAT[8:1]; \n  2 : reg_address_out[8:1] = AUD2DAT[8:1]; \n  3 : reg_address_out[8:1] = AUD3DAT[8:1]; \n  endcase \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes two inputs, in1 and in2, and merges them to produce the output out. It assigns the 4 most significant bits of in1 to the corresponding bits of the output, and the 26 least significant bits of in2 to the corresponding bits of the output. Additionally, it sets the 2 least significant bits of the output to '00'. The module also defines a wire named useless_inputs, which is the logical OR of the inverted in1 and in2.\n\n Module header:\n\nmodule merge26lo(in2, in1, out);\n [/INST]\n", "output": "input [31:0] in1; \n input [25:0] in2; \n output [31:0] out; \n assign out [31:28] = in1 [31:28]; \n assign out [27:2] = in2 [25:0]; \n assign out [1:0] = 2'b00; \n wire useless_inputs; \n assign useless_inputs = |in1 & |in2; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, RCB_FRL_STATUS_IN, is responsible for generating signals such as reset, fifo full, training done, and status error based on input signals and internal registers. It utilizes a shift register to process the input status signal and resolve ambiguity, and includes logic to set the output signals based on the shift register's state. Additionally, the module contains a state machine that tracks the status of the shift register and updates the output signals accordingly. Finally, it sets the status error flag based on the error count.\n\n Module header:\n\nmodule RCB_FRL_STATUS_IN(input CLK,input MODULE_RST,output reg RESET,output reg FIFO_FULL,output reg TRAINING_DONE,input STATUS,output reg status_error);\n [/INST]\n", "output": "reg IDLE_RESET; \n  reg IDLE_FLAG; \n  reg ambiguity; \n  reg [2:0] error_cnt; \n  reg [7:0] shift_reg; \n  parameter RST = 2'b00; \n  parameter FULL = 2'b01; \n  parameter DONE = 2'b10; \n  parameter IDLE = 2'b11; \n  reg [1:0] INT_SAT; \n  always @ ( negedge CLK ) begin \n  if ( MODULE_RST == 1'b1 ) begin \n  shift_reg <= 8'h00; \n  end \n  else begin \n  shift_reg <= {shift_reg[6:0], STATUS}; \n  end \n  end \n  always @ ( negedge CLK ) begin \n  ambiguity <= 1'b0; \n  if ( shift_reg == 8'h55 | shift_reg == 8'hAA) begin \n  INT_SAT <= RST; \n  end \n  else if ( shift_reg == 8'hF0 | shift_reg == 8'h87 | shift_reg == 8'hC3 | shift_reg == 8'hE1 | shift_reg == 8'h78 | shift_reg == 8'h3C | shift_reg == 8'h1E | shift_reg == 8'h0F ) begin \n  INT_SAT <= FULL; \n  end \n  else if ( shift_reg == 8'h33 | shift_reg == 8'h66 | shift_reg == 8'hCC | shift_reg == 8'h99 ) begin \n  INT_SAT <= DONE; \n  end \n  else if ( shift_reg == 8'h00) begin \n  INT_SAT <= IDLE; \n  end \n  else begin \n  INT_SAT <= INT_SAT; \n  ambiguity <= 1'b1; \n  end \n  end \n  always@ (negedge CLK) begin \n  if (MODULE_RST) begin \n  error_cnt <= 3'b000; \n  end else if(ambiguity) begin \n  if (error_cnt != 3'b111) \n  error_cnt <= error_cnt + 3'b001; \n  else \n  error_cnt <= error_cnt; \n  end else begin \n  error_cnt <= 3'b000; \n  end \n  end \n  always@ (negedge CLK) begin \n  status_error <= (error_cnt == 3'b111) ? 1'b1 : 1'b0; \n  end \n  always @ (posedge CLK) begin \n  if ( MODULE_RST == 1'b1 ) begin \n  RESET <= 1'b0; \n  TRAINING_DONE <= 1'b0; \n  FIFO_FULL <= 1'b0; \n  IDLE_RESET <= 0; \n  IDLE_FLAG <= 0; \n  end \n  else if ( INT_SAT == RST) begin \n  RESET <= 1'b1; \n  TRAINING_DONE <= 1'b0; \n  FIFO_FULL <= 1'b0; \n  IDLE_RESET <= 0; \n  IDLE_FLAG <= 0; \n  end \n  else if ( INT_SAT == DONE ) begin \n  TRAINING_DONE <= 1'b1; \n  FIFO_FULL <= 1'b0; \n  RESET <= 1'b0; \n  IDLE_RESET <= 0; \n  IDLE_FLAG <= 0; \n  end \n  else if ( INT_SAT == FULL ) begin \n  RESET <= 1'b0; \n  FIFO_FULL <= 1'b1; \n  TRAINING_DONE <= 1'b1; \n  IDLE_RESET <= 0; \n  IDLE_FLAG <= 0; \n  end \n  else if ( INT_SAT == IDLE ) begin \n  if(IDLE_FLAG == 0) \n  begin \n  IDLE_FLAG <= 1; \n  IDLE_RESET <= 1; \n  end \n  else \n  begin \n  IDLE_RESET <= 0; \n  end \n  RESET <= 1'b0; \n  FIFO_FULL <= 1'b0; \n  TRAINING_DONE <= 1'b0; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module simulates a display controller for a video display. It includes a display timing controller and a clock signal inverter. The module takes in clock and reset signals, horizontal and vertical positions, and generates horizontal and vertical synchronization signals, as well as horizontal and vertical blanking signals. The clock signal inverter inverts the clock signal every 10 time units. Upon initialization, the reset signal is toggled after 100 time units and then reset back to 0 after 200 time units.\n\n Module header:\n\nmodule DisplayController_Test;\n [/INST]\n", "output": "reg clk; \n  reg reset; \n  wire [`VIDEO_COUNT_WIDTH-1:0] h_pos; \n  wire [`VIDEO_COUNT_WIDTH-1:0] v_pos; \n  wire hsync; \n  wire vsync; \n  wire hblank; \n  wire vblank; \n DisplayController display_controller(.clk(clk),.reset(reset),.h_pos(h_pos),.v_pos(v_pos)); \n DisplayTiming display_timing(.h_pos(h_pos), .v_pos(v_pos),.h_sync(hsync), .v_sync(vsync),.h_blank(hblank), .v_blank(vblank)); \n  initial begin \n  clk = 0; \n  reset = 0; \n  #100 reset = 1; \n  #200 reset = 0; \n  end \n  always \n  #10 clk = !clk; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a video synchronization circuit that generates pixel clock, vertical synchronization (V_SYNC), horizontal synchronization (H_SYNC), and composite synchronization (C_SYNC) signals. It uses parameters to define pixel and synchronization signal durations, counts the number of pixels per line and number of lines per frame, and manages the pixel and synchronization signal edges. The module also increments the horizontal and vertical counters based on the pixel clock and resets them when the period is reached. The V_SYNC and H_SYNC signals are then generated based on the counters and the defined synchronization signal edges. Finally, the C_SYNC signal is created as the combination of the H_SYNC and V_SYNC signals.\n\n Module header:\n\nmodule VideoSync(input CLOCK,output PIXEL_CLOCK,output V_SYNC,output H_SYNC,output C_SYNC,output reg [8:0] H_COUNTER,output reg [8:0] V_COUNTER);\n [/INST]\n", "output": "parameter H_PIXELS = 320; \n  parameter H_FP_DURATION = 4; \n  parameter H_SYNC_DURATION = 48; \n  parameter H_BP_DURATION = 28; \n  parameter V_PIXELS = 240; \n  parameter V_FP_DURATION = 1; \n  parameter V_SYNC_DURATION = 15; \n  parameter V_BP_DURATION = 4; \n  parameter H_FP_EDGE = H_FP_DURATION; \n  parameter H_SYNC_EDGE = H_FP_EDGE + H_SYNC_DURATION; \n  parameter H_BP_EDGE = H_SYNC_EDGE + H_BP_DURATION; \n  parameter H_PERIOD = H_BP_EDGE + H_PIXELS; \n  parameter V_FP_EDGE = V_FP_DURATION; \n  parameter V_SYNC_EDGE = V_FP_EDGE + V_SYNC_DURATION; \n  parameter V_BP_EDGE = V_SYNC_EDGE + V_BP_DURATION; \n  parameter V_PERIOD = V_BP_EDGE + V_PIXELS; \n  reg [3:0] clock_divider = 0; \n  always @(posedge CLOCK) begin \n  clock_divider <= clock_divider + 1; \n  end \n  assign PIXEL_CLOCK = clock_divider[3]; \n  always @(posedge PIXEL_CLOCK) begin \n  H_COUNTER <= H_COUNTER + 1; \n  if(H_COUNTER == H_PERIOD - 1) begin \n  H_COUNTER <= 0; \n  V_COUNTER <= V_COUNTER + 1; \n  end \n  if(V_COUNTER == V_PERIOD - 1) begin \n  V_COUNTER <= 0; \n  H_COUNTER <= 0; \n  end \n  end \n  assign V_SYNC = (V_COUNTER < V_FP_EDGE || V_COUNTER > V_SYNC_EDGE); \n  assign H_SYNC = (H_COUNTER < H_FP_EDGE || H_COUNTER > H_SYNC_EDGE); \n  assign C_SYNC = !(H_SYNC ^ V_SYNC); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements logic operations on the inputs rs1_data and rs2_data. It performs AND, OR, and XOR operations based on control signals isand, isor, and isxor, respectively. The result is selected using the control signal pass_rs2_data and is stored in logic_out. Additionally, the module includes logic for buffering input data and performing operations based on the value of ifu_exu_sethi_inst_e and inv_logic.\n\n Module header:\n\nmodule sparc_exu_alulogic (logic_out,rs1_data, rs2_data, isand, isor, isxor, pass_rs2_data, inv_logic,ifu_exu_sethi_inst_e);\n [/INST]\n", "output": "input [63:0] rs1_data; \n input [63:0] rs2_data; \n input isand; \n input isor; \n input isxor; \n input pass_rs2_data; \n input inv_logic; \n  input ifu_exu_sethi_inst_e; \n output [63:0] logic_out; \n wire [63:0] rs1_data_bf1; \n wire [63:0] rs2_data_bf1; \n  wire [63:0] mov_data; \n wire [63:0] result_and; \n wire [63:0] result_or; \n wire [63:0] result_xor; \n wire [63:0] rs2_xor_invert; \n mux4ds #(64) logic_mux(.dout(logic_out[63:0]),.in0(result_and[63:0]),.in1(result_or[63:0]),.in2(result_xor[63:0]),.in3(mov_data[63:0]),.sel0(isand),.sel1(isor),.sel2(isxor),.sel3(pass_rs2_data)); \n dp_buffer #(64) rs1_data_buf(.dout(rs1_data_bf1[63:0]), .in(rs1_data[63:0])); \n dp_buffer #(64) rs2_data_buf(.dout(rs2_data_bf1[63:0]), .in(rs2_data[63:0])); \n  assign mov_data[63:32] = rs2_data_bf1[63:32] & {32{~ifu_exu_sethi_inst_e}}; \n  dp_buffer #(32) rs2_data_buf2(.dout(mov_data[31:0]), .in(rs2_data_bf1[31:0])); \n assign rs2_xor_invert[63:0] = rs2_data_bf1[63:0] ^ {64{inv_logic}}; \n assign result_and = rs1_data_bf1 & rs2_xor_invert; \n assign result_or = rs1_data_bf1 | rs2_xor_invert; \n assign result_xor = rs1_data_bf1 ^ rs2_xor_invert; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a broadcast filter that utilizes a time counter and a broadcast counter to determine whether to drop a broadcast based on certain conditions. It includes registers for time_counter, broadcast_counter, and broadcast_drop. The time_counter and broadcast_counter are incremented based on the clock signal and reset condition. The broadcast_drop signal is set based on the broadcast_filter_en input and the comparison of broadcast_counter with the broadcast_bucket_depth. If these conditions are met, the broadcast_drop signal is set to 1; otherwise, it is reset to 0.\n\n Module header:\n\nmodule Broadcast_filter (Reset ,Clk ,broadcast_ptr ,broadcast_drop ,broadcast_filter_en ,broadcast_bucket_depth ,broadcast_bucket_interval);\n [/INST]\n", "output": "input Reset ; \n input Clk ; \n input broadcast_ptr ; \n output broadcast_drop ; \n input broadcast_filter_en ; \n input [15:0] broadcast_bucket_depth ; \n input [15:0] broadcast_bucket_interval ; \n reg [15:0] time_counter ; \n reg [15:0] broadcast_counter ; \n reg broadcast_drop ; \n always @ (posedge Clk or posedge Reset) \n  if (Reset) \n  time_counter <=0; \n  else if (time_counter==broadcast_bucket_interval) \n  time_counter <=0; \n  else \n  time_counter <=time_counter+1; \n always @ (posedge Clk or posedge Reset) \n  if (Reset) \n  broadcast_counter <=0; \n  else if (time_counter==broadcast_bucket_interval) \n  broadcast_counter <=0; \n  else if (broadcast_ptr&&broadcast_counter!=broadcast_bucket_depth) \n  broadcast_counter <=broadcast_counter+1; \n always @ (posedge Clk or posedge Reset) \n  if (Reset) \n  broadcast_drop <=0; \n  else if(broadcast_filter_en&&broadcast_counter==broadcast_bucket_depth) \n  broadcast_drop <=1; \n  else \n  broadcast_drop <=0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an asynchronous FIFO read path. It includes logic to control the reading of data from a FIFO. The module has inputs for clock, reset, and read request, and outputs for data availability, data validity, and the data output. It also interfaces with RAM for reading data. The module uses registers, wires, and logic blocks to manage the read pointer, data availability, and data validity. It includes Gray code conversion, synchronization logic, and control signals to manage the reading of data from the FIFO.\n\n Module header:\n\nmodule async_fifo_rdpath (clk, reset,read_req, data_avail,data_valid, data_out,ram_rdenb, ram_rdaddr, ram_rddata,stable_wrptr, stable_rdptr);\n [/INST]\n", "output": "parameter ASYNC_FIFO_MAXINDEX = 3; \n parameter ASYNC_FIFO_MAXDATA = 31; \n input clk, reset; \n input read_req; \n output data_avail, data_valid; \n output [ASYNC_FIFO_MAXDATA:0] data_out; \n output ram_rdenb; \n output [ASYNC_FIFO_MAXINDEX:0] ram_rdaddr; \n input [ASYNC_FIFO_MAXDATA:0] ram_rddata; \n input [ASYNC_FIFO_MAXINDEX+1:0] stable_wrptr; \n output [ASYNC_FIFO_MAXINDEX+1:0] stable_rdptr; \n localparam WIDTH = ASYNC_FIFO_MAXINDEX+2; \n reg [ASYNC_FIFO_MAXINDEX+1:0] stable_rdptr, next_stable_rdptr; \n reg [ASYNC_FIFO_MAXINDEX+1:0] wrptr, next_wrptr; \n reg data_avail, next_data_avail; \n reg data_valid, next_data_valid; \n reg [ASYNC_FIFO_MAXINDEX+1:0] rdptr, next_rdptr; \n reg [ASYNC_FIFO_MAXDATA:0] data_out, next_data_out; \n wire ram_rdenb = data_avail; \n reg [ASYNC_FIFO_MAXINDEX:0] ram_rdaddr; \n wire [ASYNC_FIFO_MAXINDEX+1:0] rdptr_plus1 = rdptr+1'b1; \n wire [ASYNC_FIFO_MAXINDEX+1:0] gray_wrptr; \n full_synchronizer #(WIDTH) sync_gray_wrptr (clk, reset, stable_wrptr, gray_wrptr); \n initial \n begin \n  stable_rdptr = 0; \n  wrptr = 0; \n end \n always @ (posedge clk or posedge reset) \n begin \n  if (reset) \n  begin \n  stable_rdptr = 0; \n  wrptr = 0; \n  end \n  else \n  begin \n  stable_rdptr = next_stable_rdptr; \n  wrptr = next_wrptr; \n  end \n end \n always @(*) \n begin \n  #1; \n  next_stable_rdptr = bin2gray(rdptr); \n  next_wrptr = gray2bin(gray_wrptr); \n end \n initial \n begin \n  rdptr = 0; \n  data_avail = 1'b0; \n  data_valid = 1'b0; \n end \n always @ (posedge clk or posedge reset) \n begin \n  if (reset) \n  begin \n  rdptr = 0; \n  data_avail = 1'b0; \n  data_valid = 1'b0; \n  end \n  else \n  begin \n  rdptr = next_rdptr; \n  data_avail = next_data_avail; \n  data_valid = next_data_valid; \n  end \n end \n always @ (posedge clk) data_out = next_data_out; \n always @(*) \n begin \n  #1; \n  next_rdptr = rdptr; \n  next_data_out = {(ASYNC_FIFO_MAXDATA+1){data_avail}} & ram_rddata; \n  next_data_valid = 1'b0; \n  if (read_req && data_avail) \n  begin \n  next_data_valid = 1'b1; \n  next_rdptr = rdptr_plus1; \n  end \n  next_data_avail = (next_wrptr != next_rdptr); \n  ram_rdaddr = next_rdptr[ASYNC_FIFO_MAXINDEX:0]; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a 4-bit multiplier that takes in a 4-bit multiplier (iMultiplicador) and an 8-bit multiplicand (iMultiplicando) and outputs the 8-bit product (oResult). The module uses a case statement to handle 16 different cases for the multiplier values ranging from 0 to 15. Each case computes the product based on the value of iMultiplicador and assigns it to oResult. The case statement includes different shift and addition operations to perform the multiplication based on the multiplier value.\n\n Module header:\n\nmodule multiplicador4bits(input wire [3:0] iMultiplicador,input wire [7:0] iMultiplicando,output reg [7:0] oResult );\n [/INST]\n", "output": "always @(*) \n case(iMultiplicador) \n  0:oResult=0; \n  1:oResult=iMultiplicando; \n  2:oResult=iMultiplicando<<1; \n  3:oResult=(iMultiplicando<<1) +iMultiplicando; \n  4:oResult=(iMultiplicando<<2); \n  5:oResult=(iMultiplicando<<2)+iMultiplicando; \n  6:oResult=(iMultiplicando<<2)+(iMultiplicando<<1); \n  7:oResult=(iMultiplicando<<2)+(iMultiplicando<<1)+iMultiplicando; \n  8:oResult=iMultiplicando<<3; \n  9:oResult=(iMultiplicando<<3)+iMultiplicando; \n  10:oResult=(iMultiplicando<<3)+(iMultiplicando<<1); \n  11:oResult=(iMultiplicando<<3)+(iMultiplicando<<1)+iMultiplicando; \n  12:oResult=(iMultiplicando<<3)+(iMultiplicando<<2); \n  13:oResult=(iMultiplicando<<3)+(iMultiplicando<<2)+ iMultiplicando; \n  14:oResult=(iMultiplicando<<3)+(iMultiplicando<<2)+ (iMultiplicando<<1); \n  15:oResult=(iMultiplicando<<3)+(iMultiplicando<<2)+ (iMultiplicando<<1) + iMultiplicando; \n endcase \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements an axis pulse generator. It uses a counter to control the timing of the input and output data streams. The counter is reset when aresetn is low, and it is incremented or decremented based on the input and output data validity signals. The module also sets the ready and valid signals for the input and output data streams based on the counter value.\n\n Module header:\n\nmodule axis_pulse_generator (input wire aclk,input wire aresetn,output wire s_axis_tready,input wire [63:0] s_axis_tdata,input wire s_axis_tvalid,input wire m_axis_tready,output wire [15:0] m_axis_tdata,output wire m_axis_tvalid);\n [/INST]\n", "output": "reg [31:0] int_cntr_reg, int_cntr_next; \n  wire int_enbl_wire, int_tready_wire, int_tvalid_wire; \n  assign int_enbl_wire = |int_cntr_reg; \n  assign int_tready_wire = ~int_enbl_wire; \n  assign int_tvalid_wire = int_tready_wire & s_axis_tvalid; \n  always @(posedge aclk) \n  begin \n  if(~aresetn) \n  begin \n  int_cntr_reg <= 32'd0; \n  end \n  else \n  begin \n  int_cntr_reg <= int_cntr_next; \n  end \n  end \n  always @* \n  begin \n  int_cntr_next = int_cntr_reg; \n  if(int_tvalid_wire) \n  begin \n  int_cntr_next = s_axis_tdata[63:32]; \n  end \n  if(int_enbl_wire) \n  begin \n  int_cntr_next = int_cntr_reg - 1'b1; \n  end \n  end \n  assign s_axis_tready = int_tready_wire; \n  assign m_axis_tdata = s_axis_tdata[15:0]; \n  assign m_axis_tvalid = int_tvalid_wire; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a dual-port RAM with parameters for depth and width. It has separate read and write ports, allowing simultaneous read and write operations. The module stores data in a 2D array of registers called \"ram\" with the specified depth and width. The module includes logic to handle read and write operations based on the input signals ra, re, wa, we, and provides the output data on rd. It initializes the memory contents to 0. The module operates on the positive edge of the system clock signal.\n\n Module header:\n\nmodule tmu2_dpram #(parameter depth = 11,parameter width = 32) (input sys_clk,input [depth-1:0] ra,input re,output [width-1:0] rd,input [depth-1:0] wa,input we,input [width-1:0] wd);\n [/INST]\n", "output": "reg [width-1:0] ram[0:(1 << depth)-1]; \n reg [depth-1:0] rar; \n always @(posedge sys_clk) begin \n  if(re) \n  rar <= ra; \n  if(we) \n  ram[wa] <= wd; \n end \n assign rd = ram[rar]; \n integer i; \n initial begin \n  for(i=0;i<(1 << depth);i=i+1) \n  ram[i] = 0; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module synchronizes an input data signal to the clock domain, ensuring reliable data capture on the rising edge of the clock. It includes a reset signal to initialize the output data to 0 when asserted. The output data is updated on the rising edge of the clock with the synchronized input data.\n\n Module header:\n\nmodule kernel_reset_clk_50_domain_synch_module (clk,data_in,reset_n,data_out);\n [/INST]\n", "output": "output data_out; \n  input clk; \n  input data_in; \n  input reset_n; \n  reg data_in_d1 ; \n  reg data_out ; \n  always @(posedge clk or negedge reset_n) \n  begin \n  if (reset_n == 0) \n  data_in_d1 <= 0; \n  else \n  data_in_d1 <= data_in; \n  end \n  always @(posedge clk or negedge reset_n) \n  begin \n  if (reset_n == 0) \n  data_out <= 0; \n  else \n  data_out <= data_in_d1; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, `mix_columns`, takes a 32-bit input `mix_in` and generates two 32-bit outputs `mix_out_enc` and `mix_out_dec`. \n\nIt involves various internal signals and functions to perform the AES MixColumns transformation. The input is divided into four words, each of 8 bits. The module contains functions `aes_mult_02` and `aes_mult_04` to perform multiplication in the AES MixColumns algorithm.\n\nThe input words are manipulated using shifts and XOR operations, and the outputs are generated based on the results of these operations. The internal signals `col`, `sum_p`, and `y` store intermediate results, and the final outputs `mix_out_enc` and `mix_out_dec` are produced based on these intermediate values and the results of the multiplication functions.\n\nThe module follows the AES MixColumns algorithm to transform the input and produce the encrypted and decrypted outputs.\n\n Module header:\n\nmodule mix_columns (output [31:0] mix_out_enc,output [31:0] mix_out_dec,input [31:0] mix_in);\n [/INST]\n", "output": "localparam integer SIZE = 32; \n localparam integer WORD_SIZE = 8; \n localparam integer NUM_WORDS = 4; \n wire [WORD_SIZE - 1 : 0] col [0 : NUM_WORDS - 1]; \n wire [WORD_SIZE - 1 : 0] sum_p[0 : NUM_WORDS - 1]; \n wire [WORD_SIZE - 1 : 0] y [0 : NUM_WORDS - 2]; \n function [7:0] aes_mult_02; \n  input [7:0] data_in; \n  begin \n  aes_mult_02 = (data_in << 1) ^ {8{data_in[7]}} & 8'h1b; \n  end \n endfunction \n function [7:0] aes_mult_04; \n  input [7:0] data_in; \n  begin \n  aes_mult_04 = ((data_in << 2) ^ {8{data_in[6]}} & 8'h1b) ^ {8{data_in[7]}} & 8'h36; \n  end \n endfunction \n generate \n  genvar i; \n  for(i = 0 ; i < NUM_WORDS; i = i + 1) \n  begin:WBT \n  assign col[i] = mix_in[WORD_SIZE*(i + 1) - 1: WORD_SIZE*i]; \n  end \n endgenerate \n generate \n  genvar j; \n  for(j = 0; j < NUM_WORDS; j = j + 1) \n  begin:DMCO \n  assign sum_p[j] = col[(j + 1)%NUM_WORDS] ^ col[(j + 2)%NUM_WORDS] ^ col[(j + 3)%NUM_WORDS]; \n  assign mix_out_enc[ WORD_SIZE*(j + 1) - 1 : WORD_SIZE*j] = aes_mult_02(col[j] ^ col[(j + NUM_WORDS - 1)%NUM_WORDS]) ^ sum_p[j]; \n  end \n endgenerate \n assign y[0] = aes_mult_04(col[2] ^ col[0]); \n assign y[1] = aes_mult_04(col[3] ^ col[1]); \n assign y[2] = aes_mult_02( y[1] ^ y[0]); \n assign mix_out_dec = mix_out_enc ^ {2{y[2] ^ y[1], y[2] ^ y[0]}}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an arbiter for handling two requests on an AXI bus. It uses a state machine to prioritize and service the incoming requests based on their quality of service (QoS) and other signals. The module tracks the requests, addresses, bytes, and data valid signals for both requests and uses a state machine to manage the arbitration process. The state machine transitions between waiting for requests, servicing one request, and handling data valid signals. The module ensures that the requests are prioritized based on their QoS values and that the data is correctly forwarded based on the data valid signals.\n\n Module header:\n\nmodule processing_system7_bfm_v2_0_arb_rd(rstn,sw_clk,qos1,qos2,prt_req1,prt_req2,prt_bytes1,prt_bytes2,prt_addr1,prt_addr2,prt_data1,prt_data2,prt_dv1,prt_dv2,prt_req,prt_qos,prt_addr,prt_bytes,prt_data,prt_dv);\n [/INST]\n", "output": "input rstn, sw_clk; \n input [axi_qos_width-1:0] qos1,qos2; \n input prt_req1, prt_req2; \n input [addr_width-1:0] prt_addr1, prt_addr2; \n input [max_burst_bytes_width:0] prt_bytes1, prt_bytes2; \n output reg prt_dv1, prt_dv2; \n output reg [max_burst_bits-1:0] prt_data1,prt_data2; \n output reg prt_req; \n output reg [axi_qos_width-1:0] prt_qos; \n output reg [addr_width-1:0] prt_addr; \n output reg [max_burst_bytes_width:0] prt_bytes; \n input [max_burst_bits-1:0] prt_data; \n input prt_dv; \n parameter wait_req = 2'b00, serv_req1 = 2'b01, serv_req2 = 2'b10,wait_dv_low = 2'b11; \n reg [1:0] state; \n always@(posedge sw_clk or negedge rstn) \n begin \n if(!rstn) begin \n  state = wait_req; \n  prt_req = 1'b0; \n  prt_dv1 = 1'b0; \n  prt_dv2 = 1'b0; \n  prt_qos = 0; \n end else begin \n  case(state) \n  wait_req:begin \n  state = wait_req; \n  prt_dv1 = 1'b0; \n  prt_dv2 = 1'b0; \n  prt_req = 0; \n  if(prt_req1 && !prt_req2) begin \n  state = serv_req1; \n  prt_req = 1; \n  prt_qos = qos1; \n  prt_addr = prt_addr1; \n  prt_bytes = prt_bytes1; \n  end else if(!prt_req1 && prt_req2) begin \n  state = serv_req2; \n  prt_req = 1; \n  prt_qos = qos2; \n  prt_addr = prt_addr2; \n  prt_bytes = prt_bytes2; \n  end else if(prt_req1 && prt_req2) begin \n  if(qos1 > qos2) begin \n  prt_req = 1; \n  prt_qos = qos1; \n  prt_addr = prt_addr1; \n  prt_bytes = prt_bytes1; \n  state = serv_req1; \n  end else if(qos1 < qos2) begin \n  prt_req = 1; \n  prt_addr = prt_addr2; \n  prt_qos = qos2; \n  prt_bytes = prt_bytes2; \n  state = serv_req2; \n  end else begin \n  prt_req = 1; \n  prt_qos = qos1; \n  prt_addr = prt_addr1; \n  prt_bytes = prt_bytes1; \n  state = serv_req1; \n  end \n  end \n  end \n  serv_req1:begin \n  state = serv_req1; \n  prt_dv2 = 1'b0; \n  if(prt_dv) begin \n  prt_dv1 = 1'b1; \n  prt_data1 = prt_data; \n  prt_req = 0; \n  if(prt_req2) begin \n  prt_req = 1; \n  prt_qos = qos2; \n  prt_addr = prt_addr2; \n  prt_bytes = prt_bytes2; \n  state = serv_req2; \n  end else begin \n  state = wait_dv_low; \n  end \n  end \n  end \n  serv_req2:begin \n  state = serv_req2; \n  prt_dv1 = 1'b0; \n  if(prt_dv) begin \n  prt_dv2 = 1'b1; \n  prt_data2 = prt_data; \n  prt_req = 0; \n  if(prt_req1) begin \n  prt_req = 1; \n  prt_qos = qos1; \n  prt_addr = prt_addr1; \n  prt_bytes = prt_bytes1; \n  state = serv_req1; \n  end else begin \n  state = wait_dv_low; \n  end \n  end \n  end \n  wait_dv_low:begin \n  prt_dv1 = 1'b0; \n  prt_dv2 = 1'b0; \n  state = wait_dv_low; \n  if(!prt_dv) \n  state = wait_req; \n  end \n  endcase \n end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module serves as a basic interface for a device, providing access to device identification information, GPIO inputs, and GPIO outputs. It responds to commands based on the slave address and read/write requests, and updates the device ID, GPIO inputs, and GPIO outputs accordingly. The module also includes a reset function that initializes the device ID and GPIO registers.\n\n Module header:\n\nmodule ece453(clk,reset,slave_address,slave_read,slave_write,slave_readdata,slave_writedata,slave_byteenable,gpio_inputs,gpio_outputs,irq_out);\n [/INST]\n", "output": "input clk; \n  input reset; \n  input [3:0] slave_address; \n  input slave_read; \n  input slave_write; \n  output wire [31:0] slave_readdata; \n  input [31:0] slave_writedata; \n  input [3:0] slave_byteenable; \n  input [31:0] gpio_inputs; \n  output [31:0] gpio_outputs; \n  output wire irq_out; \n  reg [31:0] dev_id_r; \n  reg [31:0] gpio_in_r; \n  reg [31:0] gpio_out_r; \n  wire [31:0] gpio_in; \n  wire [31:0] gpio_out; \n  assign slave_readdata = ( (slave_address == DEV_ID_ADDR ) && slave_read ) ? dev_id_r : \n  ( (slave_address == GPIO_IN_ADDR ) && slave_read ) ? gpio_in_r : \n  ( (slave_address == GPIO_OUT_ADDR ) && slave_read ) ? gpio_out_r : 32'h00000000; \n  assign irq_out = 0; \n  assign gpio_outputs = gpio_out_r; \n  assign gpio_in = gpio_inputs; \n  assign gpio_out = ( (slave_address == GPIO_OUT_ADDR ) && slave_write ) ? slave_writedata : gpio_out_r; \n  always @ (posedge clk or posedge reset) \n  begin \n  if (reset == 1) \n  begin \n  dev_id_r <= 32'hECE45300; \n  gpio_in_r <= 32'h00000000; \n  gpio_out_r <= 32'h00000000; \n  end \n  else \n  begin \n  dev_id_r <= 32'hECE45300; \n  gpio_in_r <= gpio_in; \n  gpio_out_r <= gpio_out; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a pseudorandom number generator that produces a 64-bit random number based on a linear feedback shift register (LFSR). The module uses a 31-bit state variable to generate the random bits and updates the state on each clock cycle when the ce signal is asserted. The state is initialized to zero on reset, and the random bits are generated by performing an XOR operation on specific bits of the state. The output signal rand is updated with the generated random bits.\n\n Module header:\n\nmodule memtest_prng64(input clk,input rst,input ce,output reg [63:0] rand);\n [/INST]\n", "output": "reg [30:0] state; \n reg o; \n integer i; \n always @(posedge clk) begin \n  if(rst) begin \n  state = 31'd0; \n  rand = 64'd0; \n  end else if(ce) begin \n  for(i=0;i<64;i=i+1) begin \n  o = ~(state[30] ^ state[27]); \n  rand[i] = o; \n  state = {state[29:0], o}; \n  end \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a finite state machine (FSM) that handles four requests and grants them based on the priority. The module has inputs for the clock, reset, and four request signals, and outputs for the four grant signals.\n\nThe FSM has four states: IDLE, GNT0, GNT1, and GNT2. The module uses a case statement to transition between states based on the requests and resets the grants accordingly. When a request is received, the FSM transitions to the corresponding grant state and sets the grant signal to 1. When the request is de-asserted, the FSM transitions back to the IDLE state and resets the grant signal to 0.\n\nThe module is sensitive to the clock edge and updates the state and grant signals accordingly. When the reset is asserted, all grant signals are set to 0, and the FSM transitions to the IDLE state.\n\n Module header:\n\nmodule fsm_full(clock ,reset ,req_0 ,req_1 ,req_2 ,req_3 ,gnt_0 ,gnt_1 ,gnt_2 ,gnt_3);\n [/INST]\n", "output": "input clock ; \n input reset ; \n input req_0 ; \n input req_1 ; \n input req_2 ; \n input req_3 ; \n output gnt_0 ; \n output gnt_1 ; \n output gnt_2 ; \n output gnt_3 ; \n reg gnt_0 ; \n reg gnt_1 ; \n reg gnt_2 ; \n reg gnt_3 ; \n parameter [2:0] IDLE = 3'b000; \n parameter [2:0] GNT0 = 3'b001; \n parameter [2:0] GNT1 = 3'b010; \n parameter [2:0] GNT2 = 3'b011; \n parameter [2:0] GNT3 = 3'b100; \n reg [2:0] state, next_state; \n always @ (state or req_0 or req_1 or req_2 or req_3) \n begin \n  next_state = 0; \n  case(state) \n  IDLE : if (req_0 == 1'b1) begin \n  next_state = GNT0; \n  end else if (req_1 == 1'b1) begin \n  next_state= GNT1; \n  end else if (req_2 == 1'b1) begin \n  next_state= GNT2; \n  end else if (req_3 == 1'b1) begin \n  next_state= GNT3; \n  end else begin \n  next_state = IDLE; \n  end \n  GNT0 : if (req_0 == 1'b0) begin \n  next_state = IDLE; \n  end else begin \n  next_state = GNT0; \n  end \n  GNT1 : if (req_1 == 1'b0) begin \n  next_state = IDLE; \n  end else begin \n  next_state = GNT1; \n  end \n  GNT2 : if (req_2 == 1'b0) begin \n  next_state = IDLE; \n  end else begin \n  next_state = GNT2; \n  end \n  GNT3 : if (req_3 == 1'b0) begin \n  next_state = IDLE; \n  end else begin \n  next_state = GNT3; \n  end \n  default : next_state = IDLE; \n  endcase \n end \n always @ (posedge clock) \n begin : OUTPUT_LOGIC \n  if (reset) begin \n  gnt_0 <= 1'b0; \n  gnt_1 <= 1'b0; \n  gnt_2 <= 1'b0; \n  gnt_3 <= 1'b0; \n  state <= IDLE; \n  end else begin \n  state <= next_state; \n  case(state) \n  IDLE : begin \n  gnt_0 <= 1'b0; \n  gnt_1 <= 1'b0; \n  gnt_2 <= 1'b0; \n  gnt_3 <= 1'b0; \n  end \n  GNT0 : begin \n  gnt_0 <= 1'b1; \n  end \n  GNT1 : begin \n  gnt_1 <= 1'b1; \n  end \n  GNT2 : begin \n  gnt_2 <= 1'b1; \n  end \n  GNT3 : begin \n  gnt_3 <= 1'b1; \n  end \n  default : begin \n  state <= IDLE; \n  end \n  endcase \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module simply assigns the input padin to the output padout and the input oe to the output oe. It essentially acts as a passthrough for these signals without any modification.\n\n Module header:\n\nmodule PADOUT (output padout, input padin, input oe);\n [/INST]\n", "output": "assign padout = padin; \n  assign oe = oe; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module performs addition on two 48-bit vectors. It instantiates two addChan modules named inner0_0 and inner1_0, and concatenates their outputs to form the 64-bit process_output. The INSTANCE_NAME parameter is set to \"INST\" and used to name the inner modules. The input process_input is split into two 32-bit parts and fed into the inner modules. The resulting outputs are combined to form the process_output.\n\n Module header:\n\nmodule map_addChan_W2_H1(input CLK, input process_CE, input [47:0] process_input, output [63:0] process_output);\n [/INST]\n", "output": "parameter INSTANCE_NAME=\"INST\"; \n  wire [31:0] inner0_0_process_output; \n  wire [31:0] inner1_0_process_output; \n  assign process_output = {inner1_0_process_output,inner0_0_process_output}; \n  addChan #(.INSTANCE_NAME({INSTANCE_NAME,\"_inner0_0\"})) inner0_0(.CLK(CLK), .process_CE(process_CE), .inp(({process_input[23:0]})), .process_output(inner0_0_process_output)); \n  addChan #(.INSTANCE_NAME({INSTANCE_NAME,\"_inner1_0\"})) inner1_0(.CLK(CLK), .process_CE(process_CE), .inp(({process_input[47:24]})), .process_output(inner1_0_process_output)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a converter for an AXI protocol. It generates command byte addresses and handles the incrementing of addresses and length counts based on the AXI protocol signals. The module also manages the pending requests based on the protocol and handshake signals. Additionally, it includes logic to handle the reset condition.\n\n Module header:\n\nmodule axi_protocol_converter_v2_1_b2s_incr_cmd # (parameter integer C_AXI_ADDR_WIDTH = 32) (input wire clk ,input wire reset ,input wire [C_AXI_ADDR_WIDTH-1:0] axaddr ,input wire [7:0] axlen ,input wire [2:0] axsize ,input wire axhandshake ,output wire [C_AXI_ADDR_WIDTH-1:0] cmd_byte_addr ,input wire next ,output reg next_pending);\n [/INST]\n", "output": "reg sel_first; \n reg [11:0] axaddr_incr; \n reg [8:0] axlen_cnt; \n reg next_pending_r; \n wire [3:0] axsize_shift; \n wire [11:0] axsize_mask; \n localparam L_AXI_ADDR_LOW_BIT = (C_AXI_ADDR_WIDTH >= 12) ? 12 : 11; \n generate \n  if (C_AXI_ADDR_WIDTH > 12) begin : ADDR_GT_4K \n  assign cmd_byte_addr = (sel_first) ? axaddr : {axaddr[C_AXI_ADDR_WIDTH-1:L_AXI_ADDR_LOW_BIT],axaddr_incr[11:0]}; \n  end else begin : ADDR_4K \n  assign cmd_byte_addr = (sel_first) ? axaddr : axaddr_incr[11:0]; \n  end \n endgenerate \n assign axsize_shift = (1 << axsize[1:0]); \n assign axsize_mask = ~(axsize_shift - 1'b1); \n always @(posedge clk) begin \n  if (sel_first) begin \n  if(~next) begin \n  axaddr_incr <= axaddr[11:0] & axsize_mask; \n  end else begin \n  axaddr_incr <= (axaddr[11:0] & axsize_mask) + axsize_shift; \n  end \n  end else if (next) begin \n  axaddr_incr <= axaddr_incr + axsize_shift; \n  end \n end \n always @(posedge clk) begin \n  if (axhandshake)begin \n  axlen_cnt <= axlen; \n  next_pending_r <= (axlen >= 1); \n  end else if (next) begin \n  if (axlen_cnt > 1) begin \n  axlen_cnt <= axlen_cnt - 1; \n  next_pending_r <= ((axlen_cnt - 1) >= 1); \n  end else begin \n  axlen_cnt <= 9'd0; \n  next_pending_r <= 1'b0; \n  end \n  end \n end \n always @( * ) begin \n  if (axhandshake)begin \n  next_pending = (axlen >= 1); \n  end else if (next) begin \n  if (axlen_cnt > 1) begin \n  next_pending = ((axlen_cnt - 1) >= 1); \n  end else begin \n  next_pending = 1'b0; \n  end \n  end else begin \n  next_pending = next_pending_r; \n  end \n end \n always @(posedge clk) begin \n  if (reset | axhandshake) begin \n  sel_first <= 1'b1; \n  end else if (next) begin \n  sel_first <= 1'b0; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a pseudo-random number generator (PRNG) called Xoroshiro128plus. It has inputs for clock, reset, enable, memory valid, memory instruction, memory write strobe, memory write data, and memory address. The module also has an output for memory read data. Inside the module, there are registers for the clock signal, a ready flag, and a 32-bit output q from the PRNG.\n\nThe module instantiates the Xoroshiro128plus PRNG and controls its operation based on the clock signal, reset, enable, and memory valid conditions. On a specific clock edge, the module updates the ready flag and the internal clock signal for the PRNG. It also updates the output q with the PRNG's generated value.\n\nFinally, the module assigns the memory read data to the output of the PRNG when enable is true, and sets it to zero otherwise. It also sets the memory ready signal to indicate when the memory is ready to accept the data based on the PRNG operation.\n\nIn summary, this module acts as a controller for the Xoroshiro128plus PRNG, managing its clock and ready signals, and providing the generated random numbers to the memory when enabled.\n\n Module header:\n\nmodule prng (input wire clk,input wire resetn,input wire enable,input wire mem_valid,output wire mem_ready,input wire mem_instr,input wire [3:0] mem_wstrb,input wire [31:0] mem_wdata,input wire [31:0] mem_addr,output wire [31:0] mem_rdata);\n [/INST]\n", "output": "wire [63:0] prng_out; \n  reg prng_clk; \n  reg rdy; \n  reg [31:0] q; \n xoroshiro128plus prng(.resn(resetn),.clk(prng_clk),.out(prng_out)); \n  always @(negedge clk) begin \n  if (!resetn) begin \n  rdy <= 0; \n  prng_clk <= 0; \n  end else if (mem_valid & enable) begin \n  prng_clk <= 1; \n  rdy <= 1; \n  end else begin \n  prng_clk <= 0; \n  rdy <= 0; \n  end \n  q <= prng_out; \n  end \n  assign mem_rdata = enable ? q : 32'b0; \n  assign mem_ready = enable ? rdy : 1'b0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a level-sensitive latch with set and reset features. When the clear (clr) signal is asserted, the output q is set to 0. When the preset (pre) signal is asserted, the output q is set to 1. If neither of these signals are asserted and the enable (en) signal is high, the output q follows the input d.\n\n Module header:\n\nmodule my_latchsre (input d,clk,en,clr,pre,output reg q);\n [/INST]\n", "output": "always @* \n  if (clr) q <= 1'b0; \n  else if (pre) q <= 1'b1; \n  else if (en) q <= d; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an FPU (Floating Point Unit) output control module. It takes various inputs including signals related to floating-point arithmetic operations and control signals, and generates multiple output signals including request threads, destination ready signals, and a complex request queue. The module also includes asynchronous and synchronous reset signals, flip-flops for storing intermediate signals, and logic to select specific bits from input signals based on control signals. The module's behavior is synchronized with a clock signal and can be reset asynchronously.\n\n Module header:\n\nmodule fpu_out_ctl (d8stg_fdiv_in,m6stg_fmul_in,a6stg_fadd_in,div_id_out_in,m6stg_id_in,add_id_out_in,arst_l,grst_l,rclk,fp_cpx_req_cq,req_thread,dest_rdy,add_dest_rdy,mul_dest_rdy,div_dest_rdy,se,si,so);\n [/INST]\n", "output": "input d8stg_fdiv_in; \n input m6stg_fmul_in; \n input a6stg_fadd_in; \n input [9:0] div_id_out_in; \n input [9:0] m6stg_id_in; \n input [9:0] add_id_out_in; \n input arst_l; \n input grst_l; \n input rclk; \n output [7:0] fp_cpx_req_cq; \n output [1:0] req_thread; \n output [2:0] dest_rdy; \n output add_dest_rdy; \n output mul_dest_rdy; \n output div_dest_rdy; \n input se; \n input si; \n output so; \n wire reset; \n wire add_req_in; \n wire add_req_step; \n wire add_req; \n wire div_req_sel; \n wire mul_req_sel; \n wire add_req_sel; \n wire [9:0] out_id; \n wire [7:0] fp_cpx_req_cq; \n wire [1:0] req_thread; \n wire [2:0] dest_rdy_in; \n wire [2:0] dest_rdy; \n wire add_dest_rdy; \n wire mul_dest_rdy; \n wire div_dest_rdy; \n dffrl_async #(1) dffrl_out_ctl (.din (grst_l),.clk (rclk),.rst_l(arst_l),.q (out_ctl_rst_l),.se (se),.si (),.so ()); \n assign reset= (!out_ctl_rst_l); \n assign add_req_in= (!add_req); \n assign add_req_step= add_req_sel || mul_req_sel; \n dffre #(1) i_add_req (.din (add_req_in),.en (add_req_step),.rst (reset),.clk (rclk),.q (add_req),.se (se),.si (),.so ()); \n assign div_req_sel= d8stg_fdiv_in; \n assign mul_req_sel= m6stg_fmul_in \n  && ((!add_req) || (!a6stg_fadd_in)) \n  && (!div_req_sel); \n assign add_req_sel= a6stg_fadd_in \n  && (add_req || (!m6stg_fmul_in)) \n  && (!div_req_sel); \n assign out_id[9:0]= ({10{div_req_sel}}& div_id_out_in[9:0]) \n | ({10{mul_req_sel}}& m6stg_id_in[9:0]) \n | ({10{add_req_sel}}& add_id_out_in[9:0]); \n dff #(8) i_fp_cpx_req_cq (.din (out_id[9:2]),.clk (rclk),.q (fp_cpx_req_cq[7:0]),.se (se),.si (),.so ()); \n dff #(2) i_req_thread (.din (out_id[1:0]),.clk (rclk),.q (req_thread[1:0]),.se (se),.si (),.so ()); \n assign dest_rdy_in[2:0]= {div_req_sel, mul_req_sel, add_req_sel}; \n dff #(3) i_dest_rdy (.din (dest_rdy_in[2:0]),.clk (rclk),.q (dest_rdy[2:0]),.se (se),.si (),.so ()); \n dff i_add_dest_rdy (.din (add_req_sel),.clk (rclk),.q (add_dest_rdy),.se (se),.si (),.so ()); \n dff i_mul_dest_rdy (.din (mul_req_sel),.clk (rclk),.q (mul_dest_rdy),.se (se),.si (),.so ()); \n dff i_div_dest_rdy (.din (div_req_sel),.clk (rclk),.q (div_dest_rdy),.se (se),.si (),.so ()); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module `emesh_rdalign` takes a 64-bit input data stream and aligns it based on the address and data mode inputs to produce a 64-bit aligned output. It includes logic for selecting and enabling specific bytes from the input data stream and muxing them based on the address input. The aligned data is then output through the `data_out` port. The module primarily uses bitwise operations to manipulate the input data and create the aligned output.\n\n Module header:\n\nmodule emesh_rdalign (data_out,addr, datamode, data_in);\n [/INST]\n", "output": "input [2:0] addr; \n  input [1:0] datamode; \n  input [63:0] data_in; \n  output [63:0] data_out; \n  wire [3:0] byte0_sel; \n  wire [31:0] data_mux; \n  wire [31:0] data_aligned; \n  wire byte1_sel1; \n  wire byte1_sel0; \n  wire byte2_en; \n  wire byte3_en; \n  assign data_mux[31:0] = addr[2] ? data_in[63:32] : \n  data_in[31:0]; \n  assign byte0_sel[3] = addr[1:0]==2'b11; \n  assign byte0_sel[2] = addr[1:0]==2'b10; \n  assign byte0_sel[1] = addr[1:0]==2'b01; \n  assign byte0_sel[0] = addr[1:0]==2'b00; \n  assign byte1_sel1 = datamode[1:0]==2'b01 & addr[1:0]==2'b10; \n  assign byte1_sel0 = (datamode[1:0]==2'b01 & addr[1:0]==2'b00) | \n  datamode[1:0]==2'b10 | \n  datamode[1:0]==2'b11; \n  assign byte2_en = datamode[1:0]==2'b10 | \n  datamode[1:0]==2'b11; \n  assign byte3_en = datamode[1:0]==2'b10 | \n  datamode[1:0]==2'b11; \n  assign data_aligned[7:0] = {(8){byte0_sel[3]}} & data_mux[31:24] | \n  {(8){byte0_sel[2]}} & data_mux[23:16] | \n  {(8){byte0_sel[1]}} & data_mux[15:8] | \n  {(8){byte0_sel[0]}} & data_mux[7:0]; \n  assign data_aligned[15:8] = {(8){byte1_sel1}} & data_mux[31:24] | \n  {(8){byte1_sel0}} & data_mux[15:8]; \n  assign data_aligned[23:16] = {(8){byte2_en}} & data_mux[23:16]; \n  assign data_aligned[31:24] = {(8){byte3_en}} & data_mux[31:24]; \n  assign data_out[31:0] = data_aligned[31:0]; \n  assign data_out[63:32] = data_in[63:32]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `romsel` selects one of sixteen inputs based on a 4-bit selector input. The output `d_o` is assigned the value of one of the inputs (`d0_i` to `d15_i`) based on the value of `selector_i`. If none of the conditions are met, `d_o` is assigned the value of `d0_i`.\n\n Module header:\n\nmodule romsel(input [3:0] selector_i,output [7:0] d_o,input [7:0] d0_i,input [7:0] d1_i,input [7:0] d2_i,input [7:0] d3_i,input [7:0] d4_i,input [7:0] d5_i,input [7:0] d6_i,input [7:0] d7_i,input [7:0] d8_i,input [7:0] d9_i,input [7:0] d10_i,input [7:0] d11_i,input [7:0] d12_i,input [7:0] d13_i,input [7:0] d14_i,input [7:0] d15_i);\n [/INST]\n", "output": "assign d_o = \n  (selector_i == 4'd1) ? d1_i : \n  (selector_i == 4'd2) ? d2_i : \n  (selector_i == 4'd3) ? d3_i : \n  (selector_i == 4'd4) ? d4_i : \n  (selector_i == 4'd5) ? d5_i : \n  (selector_i == 4'd6) ? d6_i : \n  (selector_i == 4'd7) ? d7_i : \n  (selector_i == 4'd8) ? d8_i : \n  (selector_i == 4'd9) ? d9_i : \n  (selector_i == 4'd10) ? d10_i : \n  (selector_i == 4'd11) ? d11_i : \n  (selector_i == 4'd12) ? d12_i : \n  (selector_i == 4'd13) ? d13_i : \n  (selector_i == 4'd14) ? d14_i : \n  (selector_i == 4'd15) ? d15_i : \n  d0_i; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an implementation of a Digital Clock Manager (DCM) for an FPGA. It takes an input clock signal and generates multiple phased clock outputs, including a 2X clock output and its 180-degree out-of-phase counterpart. It also includes a reset input and a locked output signal. The DCM_SP module is used to configure the DCM's parameters, such as clock division, multiplication, phase shift, and duty cycle correction. The FPGASPDCM instance is responsible for generating the phased clock outputs based on the input clock signal. Finally, the module includes a buffer for the clock signal.\n\n Module header:\n\nmodule FPGADCM(clock,reset,locked,clock_o0,clock_o90,clock_o180,clock_o270,clock_o2x,clock_o2x180);\n [/INST]\n", "output": "input wire [('b1) - ('b1):0] clock; \n  input wire [('b1) - ('b1):0] reset; \n  output wire [('b1) - ('b1):0] locked; \n  output wire [('b1) - ('b1):0] clock_o0; \n  output wire [('b1) - ('b1):0] clock_o90; \n  output wire [('b1) - ('b1):0] clock_o180; \n  output wire [('b1) - ('b1):0] clock_o270; \n  output wire [('b1) - ('b1):0] clock_o2x; \n  output wire [('b1) - ('b1):0] clock_o2x180; \n  wire FPGABUFG_o; \n  wire FPGASPDCM_CLK0; \n  assign clock_o0 = FPGASPDCM_CLK0; \n DCM_SP #(.CLKDV_DIVIDE(2.0),.CLKFX_DIVIDE(1),.CLKFX_MULTIPLY(4),.CLKIN_DIVIDE_BY_2(\"FALSE\"),.CLKIN_PERIOD(0.0),.CLKOUT_PHASE_SHIFT(\"NONE\"),.CLK_FEEDBACK(\"1X\"),.DESKEW_ADJUST(\"SYSTEM_SYNCHRONOUS\"),.DLL_FREQUENCY_MODE(\"LOW\"),.DUTY_CYCLE_CORRECTION(\"TRUE\"),.PHASE_SHIFT(0),.STARTUP_WAIT(\"FALSE\")) \n FPGASPDCM (.CLKIN(clock),.CLKFB(FPGABUFG_o),.RST(reset),.DSSEN(0),.PSINCDEC(0),.PSEN(0),.PSCLK(0),.LOCKED(locked),.CLK0(FPGASPDCM_CLK0),.CLK90(clock_o90),.CLK180(clock_o180),.CLK270(clock_o270),.CLK2X(clock_o2x),.CLK2X180(clock_o2x180)); \n  BUFG \n FPGABUFG (.I(FPGASPDCM_CLK0),.O(FPGABUFG_o)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes a 16-bit input and assigns it to a wire w0. It then assigns the lower 8 bits of w0 to the output vef5eee, and the lower 8 bits of another wire w2 to the output vd3ef3b. The module instantiates another module v306ca3_v9a2a06 and connects w0 to its input, and w1 and w2 to its outputs.\n\n Module header:\n\nmodule v306ca3 (input [15:0] v91b9c1,output [7:0] vef5eee,output [7:0] vd3ef3b);\n [/INST]\n", "output": "wire [0:15] w0; \n  wire [0:7] w1; \n  wire [0:7] w2; \n  assign w0 = v91b9c1; \n  assign vef5eee = w1; \n  assign vd3ef3b = w2; \n v306ca3_v9a2a06 v9a2a06 (.i(w0),.o1(w1),.o0(w2)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes a 4-bit input v and produces a 1-bit output z along with a 4-bit output bcd. The input v is passed through a comparator and a lab2_circuitA_dataflow module, the output of which is used as the select signal for four 2-to-1 Mux gates. The output z is directly connected to the flag output of the comparator. The four Mux gates select between the input bits and the corresponding bits of the circuit_v output based on the flag signal and store the results in the bcd output.\n\n Module header:\n\nmodule lab2_2_2_1_partA(input [3:0] v,output z,output [3:0] bcd);\n [/INST]\n", "output": "wire flag; \n  wire [2:0] circuit_v; \n  comparator_dataflow CMP (.in(v), .flag(flag)); \n  lab2_circuitA_dataflow CIR (.in_v2_0(v[2:0]), .out_v2_0(circuit_v)); \n  assign z = flag; \n  mux_2_to_1_gate ZERO (.x(v[0]), .y(circuit_v[0]), .s(flag), .m(bcd[0])); \n  mux_2_to_1_gate ONE (.x(v[1]), .y(circuit_v[1]), .s(flag), .m(bcd[1])); \n  mux_2_to_1_gate TWO (.x(v[2]), .y(circuit_v[2]), .s(flag), .m(bcd[2])); \n  mux_2_to_1_gate THREE (.x(v[3]), .y(0), .s(flag), .m(bcd[3])); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a clock divider that generates a divided clock signal (CLOCK) from the input clock signal (CLK). It utilizes a counter to divide the input clock signal and generates an enable signal (CE) to indicate when the divided clock signal is active. The DIVISOR parameter determines the division ratio.\n\nThe module uses synchronous logic with a reset (RESET) input to initialize the counter and ensure proper behavior during reset conditions. It consists of several always blocks that handle the counter, enable signal, and clock signal generation based on the input clock and reset signals.\n\nWhen RESET is asserted, the module initializes the counter and sets the output signals to their reset states. When RESET is not asserted, the module increments the counter and toggles the CLOCK signal based on the counter value to generate the divided clock signal. The CE signal is used to indicate when the divided clock signal is active.\n\nOverall, the module provides a configurable clock divider functionality with proper handling of reset conditions to ensure reliable operation.\n\n Module header:\n\nmodule clock_divider #(parameter DIVISOR = 40000000) (input wire CLK,input wire RESET,output reg CE,output reg CLOCK);\n [/INST]\n", "output": "integer counter_ce; \n initial counter_ce = 0; \n integer counter_clk; \n initial counter_clk = 0; \n initial CLOCK = 1'b0; \n initial CE = 1'b0; \n always @(posedge CLK or posedge RESET) \n  begin \n  if (RESET == 1'b1) \n  begin \n  CE <= 1'b0; \n  end \n  else \n  begin \n  if (counter_ce == 0) \n  begin \n  CE <= 1'b1; \n  end \n  else \n  begin \n  CE <= 1'b0; \n  end \n  end \n  end \n always @(posedge CLK or posedge RESET) \n  begin \n  if (RESET == 1'b1) \n  begin \n  counter_ce <= 0; \n  end \n  else \n  begin \n  if (counter_ce == (DIVISOR - 1)) \n  counter_ce <= 0; \n  else \n  counter_ce <= counter_ce + 1; \n  end \n  end \n always @(posedge CLK or posedge RESET) \n  begin \n  if (RESET == 1'b1) \n  begin \n  CLOCK <= 1'b0; \n  end \n  else \n  begin \n  if (counter_clk == 0) \n  begin \n  CLOCK <= ~CLOCK; \n  end \n  else \n  begin \n  CLOCK <= CLOCK; \n  end \n  end \n  end \n always @(posedge CLK or posedge RESET) \n  begin \n  if (RESET == 1'b1) \n  begin \n  counter_clk <= 0; \n  end \n  else \n  begin \n  if (counter_clk == ((DIVISOR >> 1) - 1)) \n  counter_clk <= 0; \n  else \n  counter_clk <= counter_clk + 1; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes two input signals A and B, and outputs the result of a bitwise AND operation between A and B as G.\n\n Module header:\n\nmodule Gi(input A, input B, output G);\n [/INST]\n", "output": "assign G = A&B; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a flip-flop with synchronous reset and set features. It takes in clock (CLK), data (D), slave enable (SCD and SCE), and reset (RESET_B) signals and outputs the quantum bit Q. The module also includes a series of internal signals and logic gates for handling clock and data signals, as well as a 2-to-1 multiplexer and a D flip-flop with power and ground supply connections. The module's functionality is governed by the behavior of these internal signals and gates, as well as the interactions between the input signals and the flip-flop logic.\n\n Module header:\n\nmodule sky130_fd_sc_hvl__sdfrtp (Q ,CLK ,D ,SCD ,SCE ,RESET_B);\n [/INST]\n", "output": "output Q ; \n  input CLK ; \n  input D ; \n  input SCD ; \n  input SCE ; \n  input RESET_B; \n  supply1 VPWR; \n  supply0 VGND; \n  supply1 VPB ; \n  supply0 VNB ; \n  wire buf_Q ; \n  wire RESET ; \n  wire mux_out ; \n  reg notifier ; \n  wire cond0 ; \n  wire cond1 ; \n  wire cond2 ; \n  wire cond3 ; \n  wire D_delayed ; \n  wire SCD_delayed ; \n  wire SCE_delayed ; \n  wire RESET_B_delayed; \n  wire CLK_delayed ; \n  not not0 (RESET , RESET_B_delayed ); \n  sky130_fd_sc_hvl__udp_mux_2to1 mux_2to10 (mux_out, D_delayed, SCD_delayed, SCE_delayed ); \n  sky130_fd_sc_hvl__udp_dff$PR_pp$PG$N dff0 (buf_Q , mux_out, CLK_delayed, RESET, notifier, VPWR, VGND); \n  assign cond0 = ( RESET_B_delayed === 1'b1 ); \n  assign cond1 = ( ( SCE_delayed === 1'b0 ) & cond0 ); \n  assign cond2 = ( ( SCE_delayed === 1'b1 ) & cond0 ); \n  assign cond3 = ( ( D_delayed !== SCD_delayed ) & cond0 ); \n  buf buf0 (Q , buf_Q ); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module performs an 8-bit addition operation by bitwise adding the two 8-bit input vectors and assigning the result to the output vector.\n\n Module header:\n\nmodule add8(input wire [7:0] input0,input wire [7:0] input1,output wire [7:0] out);\n [/INST]\n", "output": "assign out = input0 + input1; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a button debouncer. When the button input is pressed, it waits for a delay period before setting the clean output to 1, indicating a stable button press. If the button is released before the delay, the clean output is set to 0. The delay period is determined by the delay parameter. The module uses a delay_count register to keep track of the delay and resets it when the button is released.\n\n Module header:\n\nmodule debouncer(clk, button, clean);\n [/INST]\n", "output": "input clk, button; \n output reg clean; \n parameter delay = 25'h16E3600; \n reg [24:0] delay_count; \n always@(posedge clk) \n  if (button==1) begin \n  if (delay_count==delay) begin \n  delay_count=delay_count+1'b1; \n  clean=1; \n  end else begin \n  if(delay_count==10'b11111_11111) begin \n  clean=0; \n  delay_count=10'b11111_11111; \n  end else begin \n  delay_count=delay_count+1'b1; \n  clean=0; \n  end \n  end \n  end else begin \n  delay_count=0; \n  clean=0; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, named XXOR1, has four input ports A, B, GIN, and PHI, and one output port SUM. It calculates the output SUM using XOR gates, which involves the inputs A, B, and GIN, along with an inversion and a final XOR operation with GIN.\n\n Module header:\n\nmodule XXOR1 ( A, B, GIN, PHI, SUM );\n [/INST]\n", "output": "input A; \n input B; \n input GIN; \n input PHI; \n output SUM; \n  assign SUM = ( ~ (A ^ B)) ^ GIN; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, named nextReg, contains a parameterized counter that counts the occurrences of a positive edge on the input X. It has a depth parameter to specify the counting limit. The output Y is asserted when the count reaches the specified depth. The counter can be reset, and it includes an active signal that allows counting only when active is asserted.\n\n Module header:\n\nmodule nextReg(X, Y, reset, clk);\n [/INST]\n", "output": "parameter depth=2, logDepth=1; \n  output Y; \n  input X; \n  input clk, reset; \n  reg [logDepth:0] count; \n  reg active; \n  assign Y = (count == depth) ? 1 : 0; \n  always @ (posedge clk) begin \n  if (reset == 1) begin \n  count <= 0; \n  active <= 0; \n  end \n  else if (X == 1) begin \n  active <= 1; \n  count <= 1; \n  end \n  else if (count == depth) begin \n  count <= 0; \n  active <= 0; \n  end \n  else if (active) \n  count <= count+1; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a background painter for a video game system. It processes input signals like clock, enable, and various data inputs to update the playfield and background layers. The module utilizes a case statement to handle different cycles and updates the playfield and background pipes based on the input data. It also updates the current name table and attribute table based on the input VRAM data and cycles. The output of the module includes the name table and a 4-bit pixel output based on the playfield and background pipes.\n\n Module header:\n\nmodule BgPainter(input clk, input ce,input enable,input [2:0] cycle,input [2:0] fine_x_scroll,input [14:0] loopy,output [7:0] name_table,input [7:0] vram_data,output [3:0] pixel);\n [/INST]\n", "output": "reg [15:0] playfield_pipe_1; \n  reg [15:0] playfield_pipe_2; \n  reg [8:0] playfield_pipe_3; \n  reg [8:0] playfield_pipe_4; \n  reg [7:0] current_name_table; \n  reg [1:0] current_attribute_table; \n  reg [7:0] bg0; \n  wire [7:0] bg1 = vram_data; \n  initial begin \n  playfield_pipe_1 = 0; \n  playfield_pipe_2 = 0; \n  playfield_pipe_3 = 0; \n  playfield_pipe_4 = 0; \n  current_name_table = 0; \n  current_attribute_table = 0; \n  bg0 = 0; \n  end \n  always @(posedge clk) if (ce) begin \n  case (cycle[2:0]) \n  1: current_name_table <= vram_data; \n  3: current_attribute_table <= (!loopy[1] && !loopy[6]) ? vram_data[1:0] : \n  ( loopy[1] && !loopy[6]) ? vram_data[3:2] : \n  (!loopy[1] && loopy[6]) ? vram_data[5:4] : \n  vram_data[7:6]; \n  5: bg0 <= vram_data; \n  endcase \n  if (enable) begin \n  playfield_pipe_1[14:0] <= playfield_pipe_1[15:1]; \n  playfield_pipe_2[14:0] <= playfield_pipe_2[15:1]; \n  playfield_pipe_3[7:0] <= playfield_pipe_3[8:1]; \n  playfield_pipe_4[7:0] <= playfield_pipe_4[8:1]; \n  if (cycle[2:0] == 7) begin \n  playfield_pipe_1[15:8] <= {bg0[0], bg0[1], bg0[2], bg0[3], bg0[4], bg0[5], bg0[6], bg0[7]}; \n  playfield_pipe_2[15:8] <= {bg1[0], bg1[1], bg1[2], bg1[3], bg1[4], bg1[5], bg1[6], bg1[7]}; \n  playfield_pipe_3[8] <= current_attribute_table[0]; \n  playfield_pipe_4[8] <= current_attribute_table[1]; \n  end \n  end \n  end \n  assign name_table = current_name_table; \n  wire [3:0] i = {1'b0, fine_x_scroll}; \n  assign pixel = {playfield_pipe_4[i], playfield_pipe_3[i], \n  playfield_pipe_2[i], playfield_pipe_1[i]}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module serves as a wrapper for a seven-segment display. It includes a binary-to-seven-segment decoder and handles the selection of specific segments based on the input pcval and enable signal. The module continuously updates the segment select signal based on the clock and enable, while also updating the pcpart based on the segsel using a case statement.\n\n Module header:\n\nmodule seven_seg_wrapper(output [6:0] segdisplay,output [3:0] segselect,input [15:0] pcval,input clock,input enable);\n [/INST]\n", "output": "reg[3:0] segsel = 4'b1110; \n  reg[3:0] pcpart = 4'b0000; \n  bin_to_seven_seg seg_1(.S(segdisplay), .D(pcpart)); \n  always @(*) \n  begin \n  pcpart <= 4'b0000; \n  case(segsel) \n  4'b1110: pcpart <= pcval[3:0]; \n  4'b1101: pcpart <= pcval[7:4]; \n  4'b1011: pcpart <= pcval[11:8]; \n  4'b0111: pcpart <= pcval[15:12]; \n  default: pcpart <= 4'b0000; \n  endcase \n  end \n  always @(posedge clock) \n  begin \n  if (enable) begin \n  segsel <= {segsel[0],segsel[3:1]}; \n  end \n  end \n  assign segselect = segsel; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe \"cameraReader_sim\" module is a state machine that processes input signals from a camera, such as vsync, hsync, and data. It generates an output data_out and control signals wrreq and wrclk. The state machine progresses through different states based on the input signals, and updates the pixel counter and wait counters accordingly. The wrclk1 signal is used as an internal clock signal for state transitions. The module resets its internal counters and state when the reset_n signal is low and progresses through the states based on the vsync and hsync signals to manage the pixel_counter and data_out.\n\n Module header:\n\nmodule cameraReader_sim (input clk,input reset_n,output refclk,input pclk,input [7:0] data,input vsync,input hsync,output [15:0] data_out,output wire wrreq,output wire wrclk);\n [/INST]\n", "output": "reg wrclk1 = 0; \n always@(negedge clk) \n wrclk1 <= ~wrclk1; \n reg [19:0] pixel_counter; \n reg [9:0] wait_counter_hs; \n reg [19:0] wait_counter_vs; \n reg [1:0] state = 0; \n assign wrclk = clk; \n assign wrreq = state == 2'b01 ? wrclk1 : 1'b0; \n assign data_out = pixel_counter % 640; \n always@(posedge wrclk1) \n begin \n if(reset_n == 1'b0) \n  begin \n  pixel_counter <= 0; \n  wait_counter_vs <= 0; \n  wait_counter_hs <= 0; \n  end \n  else \n  begin \n  case(state) \n  2'b00: \n  begin \n  if(wait_counter_vs == 15679) \n  begin \n  wait_counter_vs <= 0; \n  state <= 2'b01; \n  pixel_counter <= pixel_counter + 1; \n  end \n  else \n  wait_counter_vs <= wait_counter_vs + 1; \n  end \n  2'b01: \n  begin \n  if(pixel_counter % 640 == 0) \n  begin \n  if(pixel_counter == 640*480) \n  begin \n  pixel_counter <= 0; \n  state <= 2'b11; \n  end \n  else \n  state <= 2'b10; \n  end \n  else \n  pixel_counter <= pixel_counter + 1; \n  end \n  2'b10: \n  begin \n  if(wait_counter_hs == 144) \n  begin \n  wait_counter_hs <= 0; \n  state <= 2'b01; \n  pixel_counter <= pixel_counter + 1; \n  end \n  else \n  wait_counter_hs <= wait_counter_hs + 1; \n  end \n  2'b11: \n  begin \n  if(wait_counter_vs == 7839) \n  begin \n  wait_counter_vs <= 0; \n  state <= 2'b00; \n  end \n  else \n  wait_counter_vs <= wait_counter_vs + 1; \n  end \n  endcase \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an interface logic for a Wishbone bus. It receives various signals such as clock, reset, report, warning, error, compare, report register, warning register, error register, expected register, measured register, index, data, and write memory. \n\nIt processes these signals to detect rising edges for new report and new compare signals. It updates string memory and test string with new data and performs comparison operations. Additionally, it contains simulation-specific memory for storing strings and test comparisons. When synthesized, the simulation-specific code will be excluded due to the conditional compilation directive.\n\n Module header:\n\nmodule fw_interface_logic (wb_clk_i, wb_rst_i, new_report, new_warning, new_error,new_compare, report_reg, warning_reg, error_reg, expected_reg,measured_reg, index, data, write_mem);\n [/INST]\n", "output": "input wire wb_clk_i; \n  input wire wb_rst_i; \n  input wire new_report; \n  input wire new_warning; \n  input wire new_error; \n  input wire new_compare; \n  input wire [31:0] report_reg; \n  input wire [31:0] warning_reg; \n  input wire [31:0] error_reg; \n  input wire [31:0] expected_reg; \n  input wire [31:0] measured_reg; \n  input wire [5:0] index; \n  input wire [7:0] data; \n  input wire write_mem; \n `ifdef SIMULATION \n  reg [7:0] string_mem[8*64:0]; \n  always @(posedge wb_clk_i) \n  if (write_mem) begin \n  string_mem[index] <= data; \n  end \n  wire new_report_rising; \n edge_detection new_report_edge(.rising(new_report_rising),.failling(),.clk_i(wb_clk_i),.rst_i(wb_rst_i),.signal(new_report)); \n  integer i; \n  reg [8*64:0] test_string; \n  always @ (posedge new_report_rising) begin \n  i = 0; \n  test_string = 0; \n  while (string_mem[i] != 8'h0) begin \n  #1 test_string = {test_string[8*29:0], string_mem[i]}; \n  #1 string_mem[i] = 0; \n  #1 i = i + 1; \n  end \n  `TEST_COMPARE(test_string,0,0); \n  end \n  wire new_compare_rising; \n edge_detection new_compare_edge(.rising(new_compare_rising),.failling(),.clk_i(wb_clk_i),.rst_i(wb_rst_i),.signal(new_compare)); \n  always @ (posedge new_compare_rising) begin \n  i = 0; \n  test_string = 0; \n  while (string_mem[i] != 8'h0) begin \n  #1 test_string = {test_string[8*29:0], string_mem[i]}; \n  #1 string_mem[i] = 0; \n  #1 i = i + 1; \n  end \n  `TEST_COMPARE(test_string,expected_reg,measured_reg); \n  end \n `endif \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a 2-input NOR gate. The output is the negation of the logical OR of the two input signals.\n\n Module header:\n\nmodule f7_TECH_NOR2(input [1:0] in, output out);\n [/INST]\n", "output": "assign out = ~(|in); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a finite state machine with two states, A and B, controlled by the inputs j and k. The output out is assigned based on the current state. The module updates its state on the positive edge of the clock signal and the active reset signal areset.\n\n Module header:\n\nmodule cf_ddsv_intp_1 (clk,data_a,data_b,scale_a,scale_b,data_s0,data_s1);\n [/INST]\n", "output": "input clk; \n  input [15:0] data_a; \n  input [15:0] data_b; \n  input [15:0] scale_a; \n  input [15:0] scale_b; \n  output [15:0] data_s0; \n  output [15:0] data_s1; \n  reg [15:0] data_a_delay = 'd0; \n  reg [15:0] data_p = 'd0; \n  reg [15:0] data_s0 = 'd0; \n  reg [15:0] data_s1 = 'd0; \n  wire [15:0] data_a_p_s; \n  wire [15:0] data_b_p_s; \n  wire [15:0] data_a_delay_s; \n  always @(posedge clk) begin \n  data_a_delay <= data_a_delay_s; \n  data_p <= data_a_p_s + data_b_p_s; \n  data_s0 <= data_a_delay; \n  data_s1 <= data_p; \n  end \n cf_muls #(.DELAY_DATA_WIDTH(16)) i_mul_a (.clk (clk),.data_a (data_a),.data_b (scale_a),.data_p (data_a_p_s),.ddata_in (data_a),.ddata_out (data_a_delay_s)); \n cf_muls #(.DELAY_DATA_WIDTH(1)) i_mul_b (.clk (clk),.data_a (data_b),.data_b (scale_b),.data_p (data_b_p_s),.ddata_in (1'b0),.ddata_out ()); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module implements a combinatorial logic circuit that calculates the minimum distance and value based on the inputs g_input and e_input. It uses various internal components such as a distance calculation block, a comparator, and multiplexers to perform the required operations. The output o is the minimum value calculated from the inputs.\n\n Module header:\n\nmodule first_nns_comb # (parameter W = 15,parameter N = 32) (g_input,e_input,o);\n [/INST]\n", "output": "function integer log2; \n  input [31:0] value; \n  reg [31:0] temp; \n  begin \n  temp = value; \n  for (log2=0; temp>0; log2=log2+1) \n  temp = temp>>1; \n  end \n  endfunction \n  localparam LOGW = log2(W); \n  input [W-1:0] g_input; \n  input [W*N-1:0] e_input; \n  output [W-1:0] o; \n  wire [W-1:0] DBi[N-1:0]; \n  wire [LOGW-1:0] dist[N-1:0]; \n  wire [W-1:0] min_val[N-1:0]; \n  wire [LOGW-1:0] min_dist[N-1:0]; \n  wire gt_dist[N-1:1]; \n  genvar i; \n  generate \n  for (i=0;i<N;i=i+1) \n  begin:D_ASN \n  assign DBi[i] = e_input[W*(i+1)-1:W*i]; \n  end \n  endgenerate \n  generate \n  for (i=0;i<N;i=i+1) \n  begin:dist_inst \n  COUNT \n #(.N(W)) \n  COUNT_ \n (.A(g_input ^ DBi[i]),.S(dist[i])); \n  end \n  endgenerate \n  assign min_val[0] = DBi[0]; \n  assign min_dist[0] = dist[0]; \n  generate \n  for (i=1;i<N;i=i+1) \n  begin:comp_inst \n  COMP \n #(.N(LOGW)) \n  COMP_ \n (.A(min_dist[i-1]),.B(dist[i]),.O(gt_dist[i])); \n  end \n  endgenerate \n  generate \n  for (i=1;i<N;i=i+1) \n  begin:mux_inst \n  MUX \n #(.N(W)) \n  MUX_1 \n (.A(DBi[i]),.B(min_val[i-1]),.S(gt_dist[i]),.O(min_val[i])); \n  MUX \n #(.N(LOGW)) \n  MUX_2 \n (.A(dist[i]),.B(min_dist[i-1]),.S(gt_dist[i]),.O(min_dist[i])); \n  end \n  endgenerate \n  assign o = min_val[N-1]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is responsible for synchronizing and handling interrupt signals. It includes logic for differentiating between master and slave operation modes. In master mode, it synchronizes external, software, timer, and debug interrupt signals using flip-flops. In slave mode, it directly assigns the input interrupt signals to the output interrupt signals. The specific synchronization and assignment operations vary based on the mode of operation specified by the MASTER parameter.\n\n Module header:\n\nmodule e203_irq_sync #(parameter MASTER = 1) (input clk,input rst_n,input ext_irq_a,input sft_irq_a,input tmr_irq_a,input dbg_irq_a,output ext_irq_r,output sft_irq_r,output tmr_irq_r,output dbg_irq_r);\n [/INST]\n", "output": "generate \n  if(MASTER == 1) begin:master_gen \n  `ifndef E203_HAS_LOCKSTEP \n  `ifdef E203_IRQ_NEED_SYNC \n sirv_gnrl_sync # (.DP(`E203_ASYNC_FF_LEVELS),.DW(1)) u_dbg_irq_sync(.din_a (dbg_irq_a),.dout (dbg_irq_r),.clk (clk ),.rst_n (rst_n)); \n sirv_gnrl_sync # (.DP(`E203_ASYNC_FF_LEVELS),.DW(1)) u_ext_irq_sync(.din_a (ext_irq_a),.dout (ext_irq_r),.clk (clk ),.rst_n (rst_n)); \n sirv_gnrl_sync # (.DP(`E203_ASYNC_FF_LEVELS),.DW(1)) u_sft_irq_sync(.din_a (sft_irq_a),.dout (sft_irq_r),.clk (clk ),.rst_n (rst_n)); \n sirv_gnrl_sync # (.DP(`E203_ASYNC_FF_LEVELS),.DW(1)) u_tmr_irq_sync(.din_a (tmr_irq_a),.dout (tmr_irq_r),.clk (clk ),.rst_n (rst_n)); \n  `else \n  assign ext_irq_r = ext_irq_a; \n  assign sft_irq_r = sft_irq_a; \n  assign tmr_irq_r = tmr_irq_a; \n  assign dbg_irq_r = dbg_irq_a; \n  `endif \n  `endif \n  end \n  else begin:slave_gen \n  assign ext_irq_r = ext_irq_a; \n  assign sft_irq_r = sft_irq_a; \n  assign tmr_irq_r = tmr_irq_a; \n  assign dbg_irq_r = dbg_irq_a; \n  end \n endgenerate \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a UART (Universal Asynchronous Receiver-Transmitter) controller that communicates with a NIOS II processor. It provides functionality to transmit and receive data through the serial interface. The module instantiates sub-modules for transmit and receive functionality, and also includes registers for controlling various aspects of UART communication, such as baud rate, break detection, and error status. It also provides outputs for signaling when data is available, IRQ (Interrupt Request), ready for data, and the transmit data line. The module operates based on input signals such as clock, reset, data to be transmitted, and control signals for reading and writing data.\n\n Module header:\n\nmodule nios_solo_uart_0 (address,begintransfer,chipselect,clk,read_n,reset_n,rxd,write_n,writedata,dataavailable,irq,readdata,readyfordata,txd);\n [/INST]\n", "output": "output dataavailable; \n  output irq; \n  output [ 15: 0] readdata; \n  output readyfordata; \n  output txd; \n  input [ 2: 0] address; \n  input begintransfer; \n  input chipselect; \n  input clk; \n  input read_n; \n  input reset_n; \n  input rxd; \n  input write_n; \n  input [ 15: 0] writedata; \n  wire [ 9: 0] baud_divisor; \n  wire break_detect; \n  wire clk_en; \n  wire dataavailable; \n  wire do_force_break; \n  wire framing_error; \n  wire irq; \n  wire parity_error; \n  wire [ 15: 0] readdata; \n  wire readyfordata; \n  wire rx_char_ready; \n  wire [ 7: 0] rx_data; \n  wire rx_overrun; \n  wire rx_rd_strobe; \n  wire status_wr_strobe; \n  wire [ 7: 0] tx_data; \n  wire tx_overrun; \n  wire tx_ready; \n  wire tx_shift_empty; \n  wire tx_wr_strobe; \n  wire txd; \n  assign clk_en = 1; \n  nios_solo_uart_0_tx the_nios_solo_uart_0_tx \n (.baud_divisor (baud_divisor),.begintransfer (begintransfer),.clk (clk),.clk_en (clk_en),.do_force_break (do_force_break),.reset_n (reset_n),.status_wr_strobe (status_wr_strobe),.tx_data (tx_data),.tx_overrun (tx_overrun),.tx_ready (tx_ready),.tx_shift_empty (tx_shift_empty),.tx_wr_strobe (tx_wr_strobe),.txd (txd)); \n  nios_solo_uart_0_rx the_nios_solo_uart_0_rx \n (.baud_divisor (baud_divisor),.begintransfer (begintransfer),.break_detect (break_detect),.clk (clk),.clk_en (clk_en),.framing_error (framing_error),.parity_error (parity_error),.reset_n (reset_n),.rx_char_ready (rx_char_ready),.rx_data (rx_data),.rx_overrun (rx_overrun),.rx_rd_strobe (rx_rd_strobe),.rxd (rxd),.status_wr_strobe (status_wr_strobe)); \n  nios_solo_uart_0_regs the_nios_solo_uart_0_regs \n (.address (address),.baud_divisor (baud_divisor),.break_detect (break_detect),.chipselect (chipselect),.clk (clk),.clk_en (clk_en),.dataavailable (dataavailable),.do_force_break (do_force_break),.framing_error (framing_error),.irq (irq),.parity_error (parity_error),.read_n (read_n),.readdata (readdata),.readyfordata (readyfordata),.reset_n (reset_n),.rx_char_ready (rx_char_ready),.rx_data (rx_data),.rx_overrun (rx_overrun),.rx_rd_strobe (rx_rd_strobe),.status_wr_strobe (status_wr_strobe),.tx_data (tx_data),.tx_overrun (tx_overrun),.tx_ready (tx_ready),.tx_shift_empty (tx_shift_empty),.tx_wr_strobe (tx_wr_strobe),.write_n (write_n),.writedata (writedata)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module represents a simple CPU with various components such as registers, ALU, PC, and gates. It uses the input signals I and inM, as well as clock and reset signals to perform operations and produce outputs like outM, writeM, addressM, and pc. The module is designed to manipulate and transfer data between different components of the CPU based on the specified control signals.\n\n Module header:\n\nmodule CPU(input[15:0] inM, I, input clock, reset, output[15:0] outM, output writeM, output[14:0] addressM, pc);\n [/INST]\n", "output": "wire[15:0] Ain, Aout, AorM, ALUout, Dout, pcOut, addressMOut; \n  Or g1(ng, zr, ngzr); \n  Not g2(ngzr, g); \n  And g3(ng, I[2], passLT); \n  And g4(zr, I[1], passEQ); \n  And g5(g, I[0], passGT); \n  Or g6(passLT, passEQ, passLE); \n  Or g7(passLE, passGT, pass); \n  And g8(I[15], pass, PCload); \n  Mux16 g9(Aout, inM, I[12], AorM); \n  ALU alu(Dout, AorM, I[11], I[10], I[9], I[8], I[7], I[6], ALUout, zr, ng); \n  PC pc1(Aout, clock, PCload, 1'b1, reset, pcOut); \n  assign pc = pcOut[14:0]; \n  Not g10(I[15], Atype); \n  And g11(I[15], I[5], AluToA); \n  Or g12(Atype, AluToA, Aload); \n  Mux16 g13(I, ALUout, AluToA, Ain); \n  Register A(Ain, clock, Aload, Aout); \n  And g14(I[15], I[4], Dload); \n  Register D(ALUout, clock, Dload, Dout); \n  assign addressM = Aout[14:0]; \n  And g16(I[15], I[3], writeM); \n  And16 g17(ALUout, ALUout, outM); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a pipelined address generator that processes input coordinates and generates output addresses for a texture buffer. It uses the sys_clk as the clock signal and sys_rst as the reset signal. The module has multiple stages, each generating a different set of output addresses and fraction parts based on the input coordinates. It utilizes a pipeline with enable and acknowledge signals to control the flow of data. The module also includes a busy output signal to indicate when it is actively processing data.\n\n Module header:\n\nmodule tmu2_adrgen #(parameter fml_depth = 26) (input sys_clk,input sys_rst,output busy,input pipe_stb_i,output pipe_ack_o,input [10:0] dx_c,input [10:0] dy_c,input [16:0] tx_c,input [16:0] ty_c,input [fml_depth-1-1:0] dst_fbuf,input [10:0] dst_hres,input [fml_depth-1-1:0] tex_fbuf,input [10:0] tex_hres,output pipe_stb_o,input pipe_ack_i,output [fml_depth-1-1:0] dadr,output [fml_depth-1-1:0] tadra,output [fml_depth-1-1:0] tadrb,output [fml_depth-1-1:0] tadrc,output [fml_depth-1-1:0] tadrd,output [5:0] x_frac,output [5:0] y_frac);\n [/INST]\n", "output": "wire pipe_en; \n reg valid_1; \n reg [fml_depth-1-1:0] dadr_1; \n reg [fml_depth-1-1:0] tadra_1; \n reg [5:0] x_frac_1; \n reg [5:0] y_frac_1; \n reg valid_2; \n reg [fml_depth-1-1:0] dadr_2; \n reg [fml_depth-1-1:0] tadra_2; \n reg [5:0] x_frac_2; \n reg [5:0] y_frac_2; \n reg valid_3; \n reg [fml_depth-1-1:0] dadr_3; \n reg [fml_depth-1-1:0] tadra_3; \n reg [fml_depth-1-1:0] tadrb_3; \n reg [fml_depth-1-1:0] tadrc_3; \n reg [fml_depth-1-1:0] tadrd_3; \n reg [5:0] x_frac_3; \n reg [5:0] y_frac_3; \n always @(posedge sys_clk) begin \n  if(sys_rst) begin \n  valid_1 <= 1'b0; \n  valid_2 <= 1'b0; \n  valid_3 <= 1'b0; \n  end else if(pipe_en) begin \n  valid_1 <= pipe_stb_i; \n  dadr_1 <= dst_fbuf + dst_hres*dy_c + dx_c; \n  tadra_1 <= tex_fbuf + tex_hres*ty_c[16:6] + tx_c[16:6]; \n  x_frac_1 <= tx_c[5:0]; \n  y_frac_1 <= ty_c[5:0]; \n  valid_2 <= valid_1; \n  dadr_2 <= dadr_1; \n  tadra_2 <= tadra_1; \n  x_frac_2 <= x_frac_1; \n  y_frac_2 <= y_frac_1; \n  valid_3 <= valid_2; \n  dadr_3 <= dadr_2; \n  tadra_3 <= tadra_2; \n  tadrb_3 <= tadra_2 + 1'd1; \n  tadrc_3 <= tadra_2 + tex_hres; \n  tadrd_3 <= tadra_2 + tex_hres + 1'd1; \n  x_frac_3 <= x_frac_2; \n  y_frac_3 <= y_frac_2; \n  end \n end \n assign pipe_stb_o = valid_3; \n assign dadr = dadr_3; \n assign tadra = tadra_3; \n assign tadrb = tadrb_3; \n assign tadrc = tadrc_3; \n assign tadrd = tadrd_3; \n assign x_frac = x_frac_3; \n assign y_frac = y_frac_3; \n assign pipe_en = ~valid_3 | pipe_ack_i; \n assign pipe_ack_o = ~valid_3 | pipe_ack_i; \n assign busy = valid_1 | valid_2 | valid_3; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a stack distribution memory generator that takes in various control signals and data inputs. It generates stack pointers and data pointers, as well as QDPO and QSPO outputs. The module also includes resets and set reset signals for QDPO and QSPO. The design also features a constant signal 'const0' and a GND signal. Additionally, it instantiates another module called Stack_dist_mem_gen_v8_0_9_synth with the necessary input connections.\n\n Module header:\n\nmodule Stack_dist_mem_gen_v8_0_9 (a,d,dpra,clk,we,i_ce,qspo_ce,qdpo_ce,qdpo_clk,qspo_rst,qdpo_rst,qspo_srst,qdpo_srst,spo,dpo,qspo,qdpo);\n [/INST]\n", "output": "input [9:0]a; \n  input [15:0]d; \n  input [9:0]dpra; \n  input clk; \n  input we; \n  input i_ce; \n  input qspo_ce; \n  input qdpo_ce; \n  input qdpo_clk; \n  input qspo_rst; \n  input qdpo_rst; \n  input qspo_srst; \n  input qdpo_srst; \n  output [15:0]spo; \n  output [15:0]dpo; \n  output [15:0]qspo; \n  output [15:0]qdpo; \n  wire \\<const0> ; \n  wire [9:0]a; \n  wire clk; \n  wire [15:0]d; \n  wire [15:0]spo; \n  wire we; \n  assign dpo[15] = \\<const0> ; \n  assign dpo[14] = \\<const0> ; \n  assign dpo[13] = \\<const0> ; \n  assign dpo[12] = \\<const0> ; \n  assign dpo[11] = \\<const0> ; \n  assign dpo[10] = \\<const0> ; \n  assign dpo[9] = \\<const0> ; \n  assign dpo[8] = \\<const0> ; \n  assign dpo[7] = \\<const0> ; \n  assign dpo[6] = \\<const0> ; \n  assign dpo[5] = \\<const0> ; \n  assign dpo[4] = \\<const0> ; \n  assign dpo[3] = \\<const0> ; \n  assign dpo[2] = \\<const0> ; \n  assign dpo[1] = \\<const0> ; \n  assign dpo[0] = \\<const0> ; \n  assign qdpo[15] = \\<const0> ; \n  assign qdpo[14] = \\<const0> ; \n  assign qdpo[13] = \\<const0> ; \n  assign qdpo[12] = \\<const0> ; \n  assign qdpo[11] = \\<const0> ; \n  assign qdpo[10] = \\<const0> ; \n  assign qdpo[9] = \\<const0> ; \n  assign qdpo[8] = \\<const0> ; \n  assign qdpo[7] = \\<const0> ; \n  assign qdpo[6] = \\<const0> ; \n  assign qdpo[5] = \\<const0> ; \n  assign qdpo[4] = \\<const0> ; \n  assign qdpo[3] = \\<const0> ; \n  assign qdpo[2] = \\<const0> ; \n  assign qdpo[1] = \\<const0> ; \n  assign qdpo[0] = \\<const0> ; \n  assign qspo[15] = \\<const0> ; \n  assign qspo[14] = \\<const0> ; \n  assign qspo[13] = \\<const0> ; \n  assign qspo[12] = \\<const0> ; \n  assign qspo[11] = \\<const0> ; \n  assign qspo[10] = \\<const0> ; \n  assign qspo[9] = \\<const0> ; \n  assign qspo[8] = \\<const0> ; \n  assign qspo[7] = \\<const0> ; \n  assign qspo[6] = \\<const0> ; \n  assign qspo[5] = \\<const0> ; \n  assign qspo[4] = \\<const0> ; \n  assign qspo[3] = \\<const0> ; \n  assign qspo[2] = \\<const0> ; \n  assign qspo[1] = \\<const0> ; \n  assign qspo[0] = \\<const0> ; \n  GND GND \n  (.G(\\<const0> )); \n  Stack_dist_mem_gen_v8_0_9_synth \\synth_options.dist_mem_inst \n (.a(a),.clk(clk),.d(d),.spo(spo),.we(we)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a terminal interface with multiple input and output parameters. It has a data output wire (dout), a data input wire (din), an address input wire (address), a size input wire (size), a read/write input wire (read_write), an enable input wire (enable), an interrupt output wire (interrupt), a reset input wire (reset), and a clock input wire (clk). The data output (dout) and interrupt are initially assigned a value of 0.\n\n Module header:\n\nmodule Terminal(dout,din,address,size,read_write,enable,interrupt,reset,clk);\n [/INST]\n", "output": "output wire [WORD-1:0] dout; \n  input wire [WORD-1:0] din; \n  input wire [WORD-1:0] address; \n  input wire [LOGWORDBYTE-1:0] size; \n  input wire read_write; \n  input wire enable; \n  output wire interrupt; \n  input reset; \n  input clk; \n  assign dout = 0; \n  assign interrupt = 0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module named Top_test instantiates another module called Top, connecting the inputs and outputs. It simulates a computer system by setting up clock and reset signals, along with keyboard clock and data signals. The keyboard signals are toggled to simulate input, and the clock signal is inverted every 10 time units. This module primarily serves as a testbench for the Top module.\n\n Module header:\n\nmodule Top_test;\n [/INST]\n", "output": "reg clk; \n  reg reset; \n  reg kbd_clk, kbd_data; \n  wire [7:0] Segment; \n  wire [3:0] AN; \n Top uut (.clk(clk),.reset(reset),.Segment(Segment),.kbd_clk(kbd_clk),.kbd_data(kbd_data),.AN(AN)); \n  initial begin \n  clk = 0; \n  reset = 1; \n  #100; \n  reset = 0; \n  #50 kbd_clk = 1; \n  kbd_data = 0; \n  #50 kbd_clk = 0; \n  #50 kbd_clk = 1; \n  kbd_data = 0; \n  #50 kbd_clk = 0; \n  #50 kbd_clk = 1; \n  kbd_data = 1; \n  #50 kbd_clk = 0; \n  #50 kbd_clk = 1; \n  kbd_data = 0; \n  #50 kbd_clk = 0; \n  #50 kbd_clk = 1; \n  kbd_data = 1; \n  #50 kbd_clk = 0; \n  #50 kbd_clk = 1; \n  kbd_data = 1; \n  #50 kbd_clk = 0; \n  #50 kbd_clk = 1; \n  kbd_data = 1; \n  #50 kbd_clk = 0; \n  #50 kbd_clk = 1; \n  kbd_data = 0; \n  #50 kbd_clk = 0; \n  #50 kbd_clk = 1; \n  kbd_data = 0; \n  #50 kbd_clk = 0; \n  #50 kbd_clk = 1; \n  kbd_data = 0; \n  #50 kbd_clk = 0; \n  #50 kbd_clk = 1; \n  kbd_data = 0; \n  #50 kbd_clk = 0; \n  end \n  always begin \n  #10 clk = ~clk; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a 32-bit reciprocal operation. It calculates the reciprocal of the input by performing a series of multiplications, additions, and bitwise operations. The module consists of various wires and components such as multipliers and adders to compute the reciprocal. The final result is stored in the output signal out.\n\n Module header:\n\nmodule reciprocal (in, out);\n [/INST]\n", "output": "input [31:0] in; \n  output [31:0] out; \n  assign out[31] = in[31]; \n  assign out[22:0] = N2[22:0]; \n  assign out[30:23] = (D==9'b100000000)? 9'h102 - in[30:23] : 9'h101 - in[30:23]; \n  wire [31:0] D; \n  assign D = {1'b0, 8'h80, in[22:0]}; \n  wire [31:0] C1; \n  assign C1 = 32'h4034B4B5; \n  wire [31:0] C2; \n  assign C2 = 32'h3FF0F0F1; \n  wire [31:0] C3; \n  assign C3 = 32'h40000000; \n  wire [31:0] N0; \n  wire [31:0] N1; \n  wire [31:0] N2; \n  wire [31:0] S0_2D_out; \n  wire [31:0] S1_DN0_out; \n  wire [31:0] S1_2min_DN0_out; \n  wire [31:0] S2_DN1_out; \n  wire [31:0] S2_2minDN1_out; \n  wire [31:0] S0_N0_in; \n  assign S0_N0_in = {~S0_2D_out[31], S0_2D_out[30:0]}; \n  multiplier S0_2D \n (.a(C2),.b(D),.out(S0_2D_out)); \n  adder S0_N0 \n (.a(C1),.b(S0_N0_in),.out(N0)); \n  multiplier S1_DN0 \n (.a(D),.b(N0),.out(S1_DN0_out)); \n  adder S1_2minDN0 \n (.a(C3),.b({~S1_DN0_out[31], S1_DN0_out[30:0]}),.out(S1_2min_DN0_out)); \n  multiplier S1_N1 \n (.a(N0),.b(S1_2min_DN0_out),.out(N1)); \n  multiplier S2_DN1 \n (.a(D),.b(N1),.out(S2_DN1_out)); \n  adder S2_2minDN1 \n (.a(C3),.b({~S2_DN1_out[31], S2_DN1_out[30:0]}),.out(S2_2minDN1_out)); \n  multiplier S2_N2 \n (.a(N1),.b(S2_2minDN1_out),.out(N2)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `MemoryController` is a memory controller that interfaces with memory and controls data read and write operations. It manages the memory address, clock, output enable, write enable, and various control signals. It contains a state machine to coordinate the read and write cycles and ensures proper data transfer. The module also handles the busy signal to indicate ongoing operations and manages the data flow between the memory and the data bus. It has specific logic to handle read and write operations and interacts with the memory chip select and address lines. The module ensures proper timing and data integrity during read and write cycles.\n\n Module header:\n\nmodule MemoryController(input clk,input read_a,input read_b,input write,input [23:0] addr,input [7:0] din,output reg [7:0] dout_a,output reg [7:0] dout_b,output reg busy,output reg MemOE,output reg MemWR,output MemAdv,output MemClk,output reg RamCS,output RamCRE,output reg RamUB,output reg RamLB,output reg [22:0] MemAdr,inout [15:0] MemDB);\n [/INST]\n", "output": "assign MemAdv = 0; \n  assign MemClk = 0; \n  assign RamCRE = 0; \n  reg [7:0] data_to_write; \n  assign MemDB = MemOE ? {data_to_write, data_to_write} : 16'bz; \n  reg [1:0] cycles; \n  reg r_read_a; \n  always @(posedge clk) begin \n  if (!busy) begin \n  if (read_a || read_b || write) begin \n  MemAdr <= addr[23:1]; \n  RamUB <= !(addr[0] != 0); \n  RamLB <= !(addr[0] == 0); \n  RamCS <= 0; \n  MemWR <= !(write != 0); \n  MemOE <= !(write == 0); \n  busy <= 1; \n  data_to_write <= din; \n  cycles <= 0; \n  r_read_a <= read_a; \n  end else begin \n  MemOE <= 1; \n  MemWR <= 1; \n  RamCS <= 1; \n  RamUB <= 1; \n  RamLB <= 1; \n  busy <= 0; \n  cycles <= 0; \n  end \n  end else begin \n  if (cycles == 2) begin \n  if (!MemOE) begin \n  if (r_read_a) dout_a <= RamUB ? MemDB[7:0] : MemDB[15:8]; \n  else dout_b <= RamUB ? MemDB[7:0] : MemDB[15:8]; \n  end \n  MemOE <= 1; \n  MemWR <= 1; \n  RamCS <= 1; \n  RamUB <= 1; \n  RamLB <= 1; \n  busy <= 0; \n  cycles <= 0; \n  end else begin \n  cycles <= cycles + 1; \n  end \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a velocity control module for controlling DQ currents. It takes in various input signals such as current commands, measured currents, and proportional and integral gains. It computes the current error for both the direct and quadrature components, and then uses two instances of a control module to calculate the direct and quadrature voltages. The direct and quadrature voltages are then output as the final results. The module operates based on the input clock signal and reset signals, and computes the control outputs using the current errors and gains.\n\n Module header:\n\nmodule velocityControlHdl_Control_DQ_Currents (CLK_IN,reset,enb_1_2000_0,Reset_1,q_current_command,d_current_measured,q_current_measured,param_current_p_gain,param_current_i_gain,d_voltage,q_voltage);\n [/INST]\n", "output": "input CLK_IN; \n  input reset; \n  input enb_1_2000_0; \n  input Reset_1; \n  input signed [17:0] q_current_command; \n  input signed [17:0] d_current_measured; \n  input signed [17:0] q_current_measured; \n  input signed [17:0] param_current_p_gain; \n  input signed [17:0] param_current_i_gain; \n  output signed [17:0] d_voltage; \n  output signed [17:0] q_voltage; \n  wire signed [17:0] d_current_command_1; \n  wire signed [18:0] D_Error_sub_cast; \n  wire signed [18:0] D_Error_sub_cast_1; \n  wire signed [18:0] D_Error_sub_temp; \n  wire signed [17:0] d_current_error; \n  wire signed [17:0] direct_voltage; \n  wire signed [18:0] Q_Error_sub_cast; \n  wire signed [18:0] Q_Error_sub_cast_1; \n  wire signed [18:0] Q_Error_sub_temp; \n  wire signed [17:0] q_current_error; \n  wire signed [17:0] quadrature_voltage; \n  assign d_current_command_1 = 18'sb000000000000000000; \n  assign D_Error_sub_cast = d_current_command_1; \n  assign D_Error_sub_cast_1 = d_current_measured; \n  assign D_Error_sub_temp = D_Error_sub_cast - D_Error_sub_cast_1; \n  assign d_current_error = D_Error_sub_temp[18:1]; \n velocityControlHdl_Control_Current u_Control_Current (.CLK_IN(CLK_IN),.reset(reset),.enb_1_2000_0(enb_1_2000_0),.Reest(Reset_1),.Err(d_current_error),.param_current_p_gain(param_current_p_gain),.param_current_i_gain(param_current_i_gain),.Out(direct_voltage)); \n  assign d_voltage = direct_voltage; \n  assign Q_Error_sub_cast = q_current_command; \n  assign Q_Error_sub_cast_1 = q_current_measured; \n  assign Q_Error_sub_temp = Q_Error_sub_cast - Q_Error_sub_cast_1; \n  assign q_current_error = Q_Error_sub_temp[18:1]; \n velocityControlHdl_Control_Current1 u_Control_Current1 (.CLK_IN(CLK_IN),.reset(reset),.enb_1_2000_0(enb_1_2000_0),.Reest(Reset_1),.Err(q_current_error),.param_current_p_gain(param_current_p_gain),.param_current_i_gain(param_current_i_gain),.Out(quadrature_voltage)); \n  assign q_voltage = quadrature_voltage; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a level-sensitive D-latch with synchronous clear functionality. When the nSET input is asserted, the module behaves as a D-latch, with the output nQ following the input D whenever the clock nCLK is low. When nSET is deasserted, the nQ output is forced low. The module has an initialization parameter INIT, which sets the initial value of nQ to be 1'bx.\n\n Module header:\n\nmodule GP_DLATCHSI(input D, input nCLK, input nSET, output reg nQ);\n [/INST]\n", "output": "parameter [0:0] INIT = 1'bx; \n  initial nQ = INIT; \n  always @(*) begin \n  if(!nSET) \n  nQ <= 1'b0; \n  else if(!nCLK) \n  nQ <= ~D; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a testbench for a design module called simple_test_3. It defines input and output signals such as clk, rst, wide_input_bus, decrementA, dual_countA, cntA_en, decrementB, dual_countB, cntB_en, and selected_out. The testbench initializes these signals and instantiates the simple_test_3 module to test its functionality. It also includes an always block that triggers on the positive edge of the clk signal, where it increments the value of i and checks if it's less than 50. If so, it may display certain values in hexadecimal format, and when i reaches 50, the simulation ends.\n\n Module header:\n\nmodule st3_testbench (clk, rst);\n [/INST]\n", "output": "input clk; \n  input rst; \n  logic clk; \n  logic rst; \n  logic [8*16-1:0] wide_input_bus; \n  logic decrementA; \n  logic dual_countA; \n  logic cntA_en; \n  logic decrementB; \n  logic dual_countB; \n  logic cntB_en; \n  logic [47:0] selected_out; \n  integer i; \n  initial begin \n  decrementA = 1'b0; \n  dual_countA = 1'b0; \n  cntA_en = 1'b1; \n  decrementB = 1'b0; \n  dual_countB = 1'b0; \n  cntB_en = 1'b1; \n  wide_input_bus = {8'hf5, \n  8'hef, \n  8'hd5, \n  8'hc5, \n  8'hb5, \n  8'ha5, \n  8'h95, \n  8'h85, \n  8'ha7, \n  8'ha6, \n  8'ha5, \n  8'ha4, \n  8'ha3, \n  8'ha2, \n  8'ha1, \n  8'ha0}; \n  i = 0; \n  end \n  simple_test_3 \n  simple_test_3_i \n (.selected_out (selected_out[47:0]),.wide_input_bus (wide_input_bus[8*16-1:0]),.rst (rst),.clk (clk),.decrementA (decrementA),.dual_countA (dual_countA),.cntA_en (cntA_en),.decrementB (decrementB),.dual_countB (dual_countB),.cntB_en (cntB_en)); \n  always @(posedge clk) begin \n  if (i < 50) begin \n `ifdef TEST_VERBOSE \n $display(\"%x\", simple_test_3_i.cntA_reg ,\"%x\",simple_test_3_i.cntB_reg ,\" \", \"%x\", selected_out); \n `endif \n  i <= i + 1; \n  end \n  else begin \n  $finish(); \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module connects two submodules, uut_1_bytep and uut_1_bitp, to process and transform input data. The uut_1_bytep module processes the input data and passes it to the uut_1_bitp module. The output ports res_o, exp_o, obs_o, and val_o are assigned to the corresponding outputs of the uut_1_bitp module. The inputs to the submodules are connected to the inputs of the top module. The top module essentially acts as a bridge between the two submodules, processing the input and passing it to the appropriate submodule for further processing before forwarding the final results to the output ports.\n\n Module header:\n\nmodule uut_1_top (output wire [31:0] res_o,output wire [31:0] exp_o,output wire [31:0] obs_o,output wire val_o,input wire [7:0] data_i,input wire sof_i,input wire eof_i,input wire bstb_i,input wire bclk_i,input wire pclk_i);\n [/INST]\n", "output": "reg [31:0] bytep_data; \n  reg bytep_sof; \n  reg [31:0] bitp_res; \n  reg [31:0] bitp_exp; \n  reg [31:0] bitp_obs; \n  reg bitp_val; \n  uut_1_bytep i_bytep \n (.data_o(bytep_data[31:0]),.sof_o(bytep_sof),.data_i(data_i[7:0]),.sof_i(sof_i),.pclk_i(pclk_i)); \n  uut_1_bitp i_bitp \n (.res_o(bitp_res[31:0]),.exp_o(bitp_exp[31:0]),.obs_o(bitp_obs[31:0]),.val_o(bitp_val),.data_i(bytep_data[31:0]),.sof_i(bytep_sof),.eof_i(eof_i),.bstb_i(bstb_i),.bclk_i(bclk_i)); \n  always @ (*) begin \n  res_o[31:0] = bitp_res[31:0]; \n  exp_o[31:0] = bitp_exp[31:0]; \n  obs_o[31:0] = bitp_obs[31:0]; \n  val_o = bitp_val; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a synchronous FIFO (First-In-First-Out) memory for a USB application. It includes logic for writing data into the FIFO, reading data from the FIFO, and checking if the FIFO is full or empty. The module uses clock and reset signals to control the memory operations and enforces certain conditions for writing and reading data to and from the FIFO. The module contains internal logic for managing memory addresses and data, and provides outputs to indicate the status of the FIFO (full or empty).\n\n Module header:\n\nmodule usb_fifo_rcv #(parameter ADDR_WIDTH=4,parameter WDATA_WIDTH=0,parameter RDATA_WIDTH=0) (input clk,input rst0_async,input rst0_sync,input wr_en,input[(1<<WDATA_WIDTH)-1:0] wr_data,input rd_en,output[(1<<RDATA_WIDTH)-1:0] rd_data,output fifo_full,output fifo_empty);\n [/INST]\n", "output": "localparam FIFO_LENGTH= 1<<ADDR_WIDTH; \n  reg[FIFO_LENGTH-1:0] mem; \n  reg wr_shift; \n  reg[ADDR_WIDTH:WDATA_WIDTH] wr_addr_no2bytes; \n  reg[ADDR_WIDTH:WDATA_WIDTH] wr_addr; \n  reg[ADDR_WIDTH:RDATA_WIDTH] rd_addr; \n  generate \n  genvar k; \n  for(k=0; k<(1<<RDATA_WIDTH); k=k+1) \n  begin:loopk \n assign rd_data[k]= mem[ (rd_addr[ADDR_WIDTH-1:RDATA_WIDTH]<<RDATA_WIDTH)+k ]; \n  end \n  if(WDATA_WIDTH>RDATA_WIDTH) \n  begin \n  assign fifo_full= wr_addr[ADDR_WIDTH]!=rd_addr[ADDR_WIDTH] & \n  wr_addr[ADDR_WIDTH-1:WDATA_WIDTH]== \n  rd_addr[ADDR_WIDTH-1:WDATA_WIDTH] ? 1'b1 : 1'b0; \n  assign fifo_empty= wr_addr_no2bytes[ADDR_WIDTH:WDATA_WIDTH]== \n  rd_addr[ADDR_WIDTH:WDATA_WIDTH] ? 1'b1 : 1'b0; \n  end \n  else \n  begin \n  assign fifo_full= wr_addr[ADDR_WIDTH]!=rd_addr[ADDR_WIDTH] & \n  wr_addr[ADDR_WIDTH-1:RDATA_WIDTH]== \n  rd_addr[ADDR_WIDTH-1:RDATA_WIDTH] ? 1'b1 : 1'b0; \n  assign fifo_empty= wr_addr_no2bytes[ADDR_WIDTH:RDATA_WIDTH]== \n  rd_addr[ADDR_WIDTH:RDATA_WIDTH] ? 1'b1 : 1'b0; \n  end \n  endgenerate \n  always @(posedge clk, negedge rst0_async) \n  begin \n  if(!rst0_async) \n  begin \n  wr_shift<=1'b0; \n  wr_addr_no2bytes<={(ADDR_WIDTH-WDATA_WIDTH+1){1'b0}}; \n  wr_addr<={(ADDR_WIDTH-WDATA_WIDTH+1){1'b0}}; \n  rd_addr<={(ADDR_WIDTH-RDATA_WIDTH+1){1'b0}}; \n  end \n  else \n  begin \n  if(!rst0_sync) \n  begin \n  wr_shift<=1'b0; \n  wr_addr_no2bytes<={(ADDR_WIDTH-WDATA_WIDTH+1){1'b0}}; \n  wr_addr<={(ADDR_WIDTH-WDATA_WIDTH+1){1'b0}}; \n  rd_addr<={(ADDR_WIDTH-RDATA_WIDTH+1){1'b0}}; \n  end \n  else \n  begin \n  wr_shift<= wr_en & !fifo_full & wr_addr[3:0]==4'd15 ? 1'b1 : \n  wr_shift; \n  wr_addr_no2bytes<= wr_shift & wr_en & \n  !fifo_full ? wr_addr_no2bytes+1'b1: \n  wr_addr_no2bytes; \n  wr_addr<= wr_en & !fifo_full ? wr_addr+1'b1 : wr_addr; \n  rd_addr<= rd_en & !fifo_empty ? rd_addr+1'b1 : rd_addr; \n  end \n  end \n  end \n  generate \n  genvar i,j; \n  for(i=0; i<(FIFO_LENGTH>>WDATA_WIDTH); i=i+1) \n  begin:loopi \n  for(j=i*(1<<WDATA_WIDTH) ; j<(i+1)*(1<<WDATA_WIDTH) ; j=j+1) \n  begin:loopj \n  always @(posedge clk, negedge rst0_async) \n  if(!rst0_async) \n  mem[j]<=1'b0; \n  else \n  mem[j]<= wr_addr[ADDR_WIDTH-1:WDATA_WIDTH]==i & \n  !fifo_full & wr_en ? wr_data[j%(1<<WDATA_WIDTH)] : \n  mem[j]; \n  end \n  end \n  endgenerate \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a 48-96 ROM bank that uses a 5-bit address input to select a 24-bit data output. The module utilizes a 24-bit register to store the selected data. It updates the data register on the positive edge of the clock signal based on the input address. The module contains a case statement to decode the address and assign the corresponding data values. If the address does not match any of the defined cases, the default output value is zero.\n\n Module header:\n\nmodule rom_firbank_48_96(input wire clk,input wire [4:0] addr,output wire [23:0] data);\n [/INST]\n", "output": "reg [23:0] data_ff; \n assign data = data_ff; \n always @(posedge clk) begin \n  case(addr) \n  0: data_ff <= 24'h164B2D; \n  1: data_ff <= 24'hF5BAE8; \n  2: data_ff <= 24'h0633AB; \n  3: data_ff <= 24'hFC29F9; \n  4: data_ff <= 24'h0242A4; \n  5: data_ff <= 24'hFEC9C7; \n  6: data_ff <= 24'h008EDD; \n  7: data_ff <= 24'hFFCE7B; \n  8: data_ff <= 24'h0005BB; \n  9: data_ff <= 24'h00091C; \n  10: data_ff <= 24'hFFF5DC; \n  11: data_ff <= 24'h0006AF; \n  12: data_ff <= 24'hFFFCC4; \n  13: data_ff <= 24'h000124; \n  14: data_ff <= 24'hFFFFC3; \n  15: data_ff <= 24'h000004; \n  16: data_ff <= 24'h35A6A3; \n  17: data_ff <= 24'hF90C13; \n  18: data_ff <= 24'h01922A; \n  19: data_ff <= 24'h005211; \n  20: data_ff <= 24'hFEFDCB; \n  21: data_ff <= 24'h011F4C; \n  22: data_ff <= 24'hFF0A15; \n  23: data_ff <= 24'h00B389; \n  24: data_ff <= 24'hFF8D35; \n  25: data_ff <= 24'h00406C; \n  26: data_ff <= 24'hFFE0A7; \n  27: data_ff <= 24'h000CDE; \n  28: data_ff <= 24'hFFFBC5; \n  29: data_ff <= 24'h0000FE; \n  30: data_ff <= 24'hFFFFE3; \n  31: data_ff <= 24'hFFFFFF; \n  default: data_ff <= 0; \n  endcase \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a round-robin arbiter for managing access to multiple devices. It takes requests from multiple devices and determines the next device to be granted access based on a round-robin scheduling policy and the availability of the devices. The module consists of a priority encoder that determines the availability of each device and a set of forwarders that handle the request-response forwarding mechanism. The generated loop constructs the forwarding paths between devices. The output \"next\" wire indicates the next device to be granted access based on the priority and availability of the devices.\n\n Module header:\n\nmodule rr_arbiter(reqs,prev,next);\n [/INST]\n", "output": "parameter DEVNUM=4; \n  input wire [DEVNUM-1:0] reqs; \n  input wire [DEVNUM-1:0] prev; \n  output wire [DEVNUM-1:0] next; \n  genvar i; \n  wire [DEVNUM-1:0] loop; \n  wire [DEVNUM-1:0] next_arb; \n  generate \n  for(i=0;i<DEVNUM;i=i+1) \n  begin : gen_forwarders \n  if( i==0 ) \n rr_fwd forwarder( .prev(prev[i]),.req(reqs[i]),.next(next_arb[i]),.loop_in(loop[DEVNUM-1]),.loop_out(loop[i]) ); \n  else \n rr_fwd forwarder( .prev(prev[i]),.req(reqs[i]),.next(next_arb[i]),.loop_in(loop[i-1]),.loop_out(loop[i]) ); \n  end \n  endgenerate \n  wire [DEVNUM-1:0] next_empty; \n  generate \n  for(i=0;i<DEVNUM;i=i+1) \n  begin : pri_enc \n  if( i==0 ) \n  begin : pri_zero \n  assign next_empty[0] = reqs[0]; \n  end \n  else \n  begin : pri_nonzero \n  assign next_empty[i] = reqs[i] & ( ~|reqs[i-1:0] ); \n  end \n  end \n  endgenerate \n  assign next = ( prev ) ? next_arb : next_empty; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module `convolution` performs complex multiplication between inputs `a` and `b`, and computes the real and imaginary parts of the output `outr` and `outi`. The inputs are 16-bit values, and the outputs are 18-bit values to accommodate the multiplication result. The module extracts the real and imaginary parts of the inputs, performs the multiplication, and computes the real and imaginary parts of the output based on the complex multiplication formula. The module uses wire variables to separate the real and imaginary parts before performing the computations.\n\n Module header:\n\nmodule convolution(outr,outi,a,b);\n [/INST]\n", "output": "input [15:0] a, b; \n  output [17:0] outr, outi; \n  wire signed [7:0] a_rea, a_ima, b_rea, b_ima; \n  assign a_rea = a[15:8]; assign a_ima = a[7:0]; \n  assign b_rea = b[15:8]; assign b_ima = b[7:0]; \n  assign outr = a_rea*b_rea - a_ima*b_ima; \n  assign outi = a_rea*b_ima + a_ima*b_rea; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module defines a parameterized D-latch with set and clear functionality. It takes inputs for enable (EN), set (SET), clear (CLR), and data (D), and outputs the latch value (Q). The behavior is determined based on the polarity of the enable, set, and clear inputs. Inside the generate block, individual bits of the latch are updated based on the set, clear, and data inputs, and the enable signal.\n\n Module header:\n\nmodule \\$dlatchsr (EN, SET, CLR, D, Q);\n [/INST]\n", "output": "parameter WIDTH = 0; \n parameter EN_POLARITY = 1'b1; \n parameter SET_POLARITY = 1'b1; \n parameter CLR_POLARITY = 1'b1; \n input EN; \n input [WIDTH-1:0] SET, CLR, D; \n output reg [WIDTH-1:0] Q; \n wire pos_en = EN == EN_POLARITY; \n wire [WIDTH-1:0] pos_set = SET_POLARITY ? SET : ~SET; \n wire [WIDTH-1:0] pos_clr = CLR_POLARITY ? CLR : ~CLR; \n genvar i; \n generate \n  for (i = 0; i < WIDTH; i = i+1) begin:bitslices \n  always @* \n  if (pos_clr[i]) \n  Q[i] = 0; \n  else if (pos_set[i]) \n  Q[i] = 1; \n  else if (pos_en) \n  Q[i] = D[i]; \n  end \n endgenerate \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes a 32-bit input 'd' and directly assigns it to the output 'q'. It essentially acts as a pass-through, where the input is immediately propagated to the output without any processing.\n\n Module header:\n\nmodule nop(d,q);\n [/INST]\n", "output": "input [31:0] d; \n output [31:0] q; \n  assign q=d; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a stimulus module for a CIC (cascaded integrator-comb) decimator. It initializes and controls the signals used in the decimation process, including the DSP clock signal, rate signal, ready signal, data output, and strobe signal. It also configures the reset, data input, and write enable signals at specific time intervals using the DSP clock period. The module sets the initial values for the signals and then manipulates them based on the DSP clock period to control the decimation process.\n\n Module header:\n\nmodule cic_decim_stimulus;\n [/INST]\n", "output": "parameter DSPCLK_PERIOD = 1000.0/128.0; \n  reg sclr; \n  wire nd; \n  reg reset; \n  reg dspclk; \n  reg rate_we; \n  reg [11:0] din; \n  reg [12:0] rate; \n  wire rfd; \n  wire rdy; \n  wire [15:0] dout; \n  reg [1:0] strobe_nd; \n  always @(posedge dspclk) \n  begin \n  if(reset) strobe_nd <= 4'h0; \n  else strobe_nd <= strobe_nd + 4'h1; \n  end \n  assign nd = strobe_nd == 0; \n cic_decim uut (.sclr(sclr | reset),.rfd(rfd),.rdy(rdy),.nd(nd),.clk(dspclk),.rate_we(rate_we),.dout(dout),.din(din),.rate(rate)); \n  initial begin \n  sclr = 0; \n  dspclk = 1; \n  rate_we = 0; \n  din = 12'h010; \n  rate = 12'h4; \n  #100 reset = 1; \n  #(DSPCLK_PERIOD*4)reset = 0; \n  #(DSPCLK_PERIOD) rate_we = 1; \n  #(DSPCLK_PERIOD) rate_we = 0; \n  #(DSPCLK_PERIOD*120) sclr = 1; \n  #(DSPCLK_PERIOD) sclr = 0; \n  #(DSPCLK_PERIOD*64) rate_we = 1; \n  #(DSPCLK_PERIOD) rate_we = 0; \n  #(DSPCLK_PERIOD*75) rate_we = 1; \n  #(DSPCLK_PERIOD) rate_we = 0; \n  end \n always @(dspclk) \n  #(DSPCLK_PERIOD / 2.0) dspclk<= !dspclk; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module FourToSeven takes a 4-bit input ByteIn and generates a 7-bit output SegOut, based on the inputs Enable and Polarity. When Enable is high, it uses a case statement to determine the appropriate 7-bit output based on the value of ByteIn. If Polarity is low, it inverts the SegBuf before assigning it to SegOut.\n\n Module header:\n\nmodule FourToSeven (ByteIn,Enable,Polarity,SegOut);\n [/INST]\n", "output": "input [3:0] ByteIn; \n input Enable; \n input Polarity; \n output [6:0] SegOut; \n reg [6:0] SegOut; \n always @(Polarity, ByteIn, Enable) begin: FOURTOSEVEN_COMB \n  reg [7-1:0] SegBuf; \n  SegBuf = 7'h0; \n  if ((Enable == 1)) begin \n  case (ByteIn) \n  0: SegBuf = 63; \n  1: SegBuf = 6; \n  2: SegBuf = 91; \n  3: SegBuf = 79; \n  4: SegBuf = 102; \n  5: SegBuf = 109; \n  6: SegBuf = 125; \n  7: SegBuf = 7; \n  8: SegBuf = 127; \n  9: SegBuf = 111; \n  10: SegBuf = 119; \n  11: SegBuf = 124; \n  12: SegBuf = 57; \n  13: SegBuf = 94; \n  14: SegBuf = 121; \n  default: SegBuf = 113; \n  endcase \n  end \n  if ((Polarity == 0)) begin \n  SegBuf = (~SegBuf); \n  end \n  SegOut = SegBuf; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a memory unit that stores and retrieves data. It has an 8-bit input 'in' and output 'out' for data transfer, and an address input 'address' to specify the memory location to read from or write to. The 'write' input signal controls whether the module performs a write operation. It also has a clock input 'clk' and a reset input 'reset' to initialize the memory. The module also includes a test wire 'testWire' for testing purposes.\n\nThe memory unit is implemented using an array of 256 8-bit registers named 'mem'. The module initializes the memory contents to specific values when the 'reset' input is low. The memory values are hard-coded for specific addresses when the reset signal is low. When the 'write' signal is low, the module stores the input data 'in' into the memory location specified by the 'address' input.\n\nAdditionally, the module includes a combinatorial assignment that assigns the value stored in memory address 7 to the 'testWire' output. The memory is read on the negative edge of the clock, and the value stored at the addressed location is output to the 'out' signal.\n\n Module header:\n\nmodule memory2(reset,address,in,out,write,clk, testWire);\n [/INST]\n", "output": "input [7:0] in; \n input clk,write,reset; \n input [14:0] address; \n output reg [7:0] out; \n output wire [7:0] testWire; \n reg [7:0] mem [0:255]; \n integer i; \n assign testWire = mem[7]; \n always @(negedge clk) \n begin \n out = mem[address]; \n if(reset== 1'b0) \n begin \n for(i=0;i<256;i=i+1) \n mem [i] = 0; \n mem[0] = 8'b10010010; \n mem[1] = 8'b01100100; \n mem[2] = 8'b00010110; \n mem[3] = 8'b01110111; \n mem[4] = 8'b00101111; \n mem[5] = 8'b00000010; \n mem[26] =8'b11000001; \n mem[31] = 8'b01001000; \n mem[33] = 8'b11100001; \n end \n if(write ==1'b0) \n begin \n  mem[address] <= in; \n end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module f2_test takes a 2-bit input in and a select signal and uses the select signal to choose between the individual bits of the input, assigning the selected bit to the output.\n\n Module header:\n\nmodule f2_test(input [1:0] in, input select, output reg out);\n [/INST]\n", "output": "always @( in or select) \n  case (select) \n  0: out = in[0]; \n  1: out = in[1]; \n  endcase \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an encoder that generates phase A, phase B, home, index, and LED output signals based on the frequency clock, reset, and enable signals. The module includes registers for phase A, phase B, home, index, and LED. It also has a counter and a 100 Hz output. The module uses conditional logic to update the count, toggle the 100 Hz output, and control the phase A, phase B, home, and index signals based on the clock and reset signals. The functionality is driven by the state transitions and conditional logic based on the frequency clock, reset, and enable signals to generate the desired outputs.\n\n Module header:\n\nmodule enc(rst_n, freq_clk, enable, pha, phb, home, index, led);\n [/INST]\n", "output": "input rst_n; \n input freq_clk; \n input enable; \n output pha; \n output phb; \n output home; \n output index; \n output led; \n reg pha_reg; \n reg phb_reg; \n reg home_reg; \n reg index_reg; \n reg[7:0] pha_count; \n reg led; \n reg [31:0] count_reg; \n reg out_100hz; \n always @(posedge freq_clk or negedge rst_n) begin \n  if (!rst_n) begin \n  count_reg <= 0; \n  out_100hz <= 0; \n  count_reg <= 0; \n  out_100hz <= 0; \n  end \n  else if (enable) \n  begin \n  if (count_reg < 249999) begin \n  count_reg <= count_reg + 1; \n  end else begin \n  count_reg <= 0; \n  out_100hz <= ~out_100hz; \n  end \n  end \n end \n always @ (posedge out_100hz or negedge rst_n) \n begin \n  if (!rst_n) \n  begin \n  pha_count <= 8'd12; \n  led <= 1'b0; \n  end \n  else if (out_100hz) \n  begin \n  led <= ~led; \n  case (pha_count) \n  8'd1: pha_count <= 8'd2; \n  8'd2: pha_count <= 8'd3; \n  8'd3: pha_count <= 8'd4; \n  8'd4: pha_count <= 8'd5; \n  8'd5: pha_count <= 8'd6; \n  8'd6: pha_count <= 8'd7; \n  8'd7: pha_count <= 8'd8; \n  8'd8: pha_count <= 8'd9; \n  8'd9: pha_count <= 8'd10; \n  8'd10: pha_count <= 8'd11; \n  8'd11: pha_count <= 8'd12; \n  8'd12: pha_count <= 8'd0; \n  8'd0: pha_count <= 8'd1; \n  endcase \n  end \n end \n always @ (posedge out_100hz or negedge rst_n) \n begin \n  if (!rst_n) \n  begin \n  pha_reg <= 1'b1; \n  end \n  else if (out_100hz) \n  begin \n  case (pha_reg) \n  1'd1: \n  begin \n  pha_reg <= 1'd0; \n  phb_reg <= 1'd1; \n  end \n  1'd0: \n  begin \n  pha_reg <= 1'd1; \n  phb_reg <= 1'd0; \n  end \n  endcase \n  end \n end \n assign pha = pha_reg; \n assign phb = phb_reg; \n always @ (posedge out_100hz or negedge rst_n) \n begin \n  if (!rst_n) \n  begin \n  home_reg <= 1'b0; \n  end \n  else if (out_100hz) \n  begin \n  case (pha_count) \n  8'd12: home_reg <= 1'd1; \n  default: home_reg <= 1'd0; \n  endcase \n  end \n end \n assign home = home_reg; \n always @ (posedge out_100hz or negedge rst_n) \n begin \n  if (!rst_n) \n  begin \n  index_reg <= 1'b0; \n  end \n  else if (out_100hz) \n  begin \n  case (pha_count) \n  8'd12: index_reg <= 1'd1; \n  default: index_reg <= 1'd0; \n  endcase \n  end \n end \n assign index = index_reg; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module `jp` implements a simple memory-mapped register that handles inputs and outputs for two joypads. It has a clock signal, reset signal, write signal, address input, and data input/output. It includes two separate states for joypad 1 and joypad 2. The module checks for new addresses and processes the data based on the address and write enable signal. It also has a built-in mechanism for handling write operations and updates the joypad states based on the input data and write enable signal.\n\n Module header:\n\nmodule jp(input clk,input rst,input i_wr,input [15:0] i_addr,input i_din,output reg [7:0] o_dout,input [7:0] i_jp1_state,input [7:0] i_jp2_state);\n [/INST]\n", "output": "localparam [15:0] JOYPAD1_MMR_ADDR = 16'h4016; \n localparam [15:0] JOYPAD2_MMR_ADDR = 16'h4017; \n reg [15:0] r_prev_addr; \n wire w_new_addr; \n reg r_wrote_1_flag; \n reg [8:0] r_jp1_state; \n reg [8:0] r_jp2_state; \n assign w_new_addr = (r_prev_addr != i_addr); \n always @ (posedge clk) begin \n  if (rst) begin \n  o_dout <= 0; \n  r_prev_addr <= 0; \n  r_wrote_1_flag <= 0; \n  r_jp1_state <= 0; \n  r_jp2_state <= 0; \n  end \n  else begin \n  if (i_addr[15:1] == JOYPAD1_MMR_ADDR[15:1]) begin \n  o_dout <= { 7'h00, ((i_addr[0]) ? r_jp2_state[0] : r_jp1_state[0]) }; \n  if (w_new_addr) begin \n  if (i_wr && !i_addr[0]) begin \n  if (!r_wrote_1_flag) begin \n  if (i_din == 1'b1) begin \n  r_wrote_1_flag <= 1; \n  end \n  end \n  else begin \n  if (i_din == 1'b0) begin \n  r_wrote_1_flag <= 0; \n  r_jp1_state <= {i_jp1_state, 1'b0}; \n  r_jp2_state <= {i_jp2_state, 1'b0}; \n  end \n  end \n  end \n  else if (!i_wr && !i_addr[0]) begin \n  r_jp1_state <= {1'b1, r_jp1_state[8:1]}; \n  end \n  else if (!i_wr && i_addr[0]) begin \n  r_jp2_state <= {1'b1, r_jp2_state[8:1]}; \n  end \n  end \n  end \n  r_prev_addr <= i_addr; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module represents the second stage of the RISC-V processor's debug pointer. It includes various inputs such as debug bus signals, clock input, and scan chain control signals, and outputs the l2_dbgbus_out and enable_01 signals. The module uses flip-flops to synchronize and store the values of the debug bus signals and the enable signal, while also utilizing multiplexers to select the appropriate debug bus values. The enable_01 signal is stored in a flip-flop and its previous value is calculated using the debug bus signals. The l2_dbgbus_out signal is similarly stored in flip-flops after being multiplexed and synchronized. Additionally, the module instantiates another module to handle scan chain logic.\n\n Module header:\n\nmodule sc_0_1_dbg_rptr(l2_dbgbus_out, enable_01, so,dbgbus_b0, dbgbus_b1, rclk, si, se);\n [/INST]\n", "output": "output [39:0] l2_dbgbus_out ; \n  output enable_01; \n  input [40:0] dbgbus_b0; \n  input [40:0] dbgbus_b1; \n  input rclk; \n  input si, se; \n  output so; \n  wire [39:0] l2_dbgbus_out_prev ; \n  wire enable_01_prev; \n  wire int_scanout; \n  bw_u1_scanlg_2x so_lockup(.so(so), .sd(int_scanout), .ck(rclk), .se(se)); \n mux2ds #(20) mux_dbgmuxb01_row0 (.dout (l2_dbgbus_out_prev[19:0]),.in0(dbgbus_b0[19:0]),.in1(dbgbus_b1[19:0]),.sel0(dbgbus_b0[40]),.sel1(~dbgbus_b0[40])); \n dff_s #(20) ff_dbgmuxb01_row0 (.q(l2_dbgbus_out[19:0]),.din(l2_dbgbus_out_prev[19:0]),.clk(rclk), .se(1'b0), .si(), .so() ); \n mux2ds #(20) mux_dbgmuxb01_row1 (.dout (l2_dbgbus_out_prev[39:20]),.in0(dbgbus_b0[39:20]),.in1(dbgbus_b1[39:20]),.sel0(dbgbus_b0[40]),.sel1(~dbgbus_b0[40])); \n dff_s #(20) ff_dbgmuxb01_row1 (.q(l2_dbgbus_out[39:20]),.din(l2_dbgbus_out_prev[39:20]),.clk(rclk), .se(1'b0), .si(), .so() ); \n  assign enable_01_prev = dbgbus_b0[40] | dbgbus_b1[40] ; \n dff_s #(1) ff_valid (.q(enable_01),.din(enable_01_prev),.clk(rclk), .se(1'b0), .si(), .so() ); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a buffer with multiplexed outputs for the PCXDP interface. It takes grant, hold, select, and shift signals as inputs for two PCXDP instances and provides corresponding outputs for these signals. The outputs are assigned based on the input signals for each PCXDP instance.\n\n Module header:\n\nmodule pcx_buf_pm_even(arbpc0_pcxdp_grant_pa, arbpc0_pcxdp_q0_hold_pa_l,arbpc0_pcxdp_qsel0_pa, arbpc0_pcxdp_qsel1_pa_l,arbpc0_pcxdp_shift_px, arbpc2_pcxdp_grant_pa,arbpc2_pcxdp_q0_hold_pa_l, arbpc2_pcxdp_qsel0_pa,arbpc2_pcxdp_qsel1_pa_l, arbpc2_pcxdp_shift_px,arbpc0_pcxdp_grant_arbbf_pa, arbpc0_pcxdp_q0_hold_arbbf_pa_l,arbpc0_pcxdp_qsel0_arbbf_pa, arbpc0_pcxdp_qsel1_arbbf_pa_l,arbpc0_pcxdp_shift_arbbf_px, arbpc2_pcxdp_grant_arbbf_pa,arbpc2_pcxdp_q0_hold_arbbf_pa_l, arbpc2_pcxdp_qsel0_arbbf_pa,arbpc2_pcxdp_qsel1_arbbf_pa_l, arbpc2_pcxdp_shift_arbbf_px);\n [/INST]\n", "output": "output arbpc0_pcxdp_grant_pa ; \n  output arbpc0_pcxdp_q0_hold_pa_l ; \n  output arbpc0_pcxdp_qsel0_pa ; \n  output arbpc0_pcxdp_qsel1_pa_l ; \n  output arbpc0_pcxdp_shift_px ; \n  output arbpc2_pcxdp_grant_pa ; \n  output arbpc2_pcxdp_q0_hold_pa_l ; \n  output arbpc2_pcxdp_qsel0_pa ; \n  output arbpc2_pcxdp_qsel1_pa_l ; \n  output arbpc2_pcxdp_shift_px ; \n  input arbpc0_pcxdp_grant_arbbf_pa; \n  input arbpc0_pcxdp_q0_hold_arbbf_pa_l; \n  input arbpc0_pcxdp_qsel0_arbbf_pa; \n  input arbpc0_pcxdp_qsel1_arbbf_pa_l; \n  input arbpc0_pcxdp_shift_arbbf_px; \n  input arbpc2_pcxdp_grant_arbbf_pa; \n  input arbpc2_pcxdp_q0_hold_arbbf_pa_l; \n  input arbpc2_pcxdp_qsel0_arbbf_pa; \n  input arbpc2_pcxdp_qsel1_arbbf_pa_l; \n  input arbpc2_pcxdp_shift_arbbf_px; \n  assign arbpc0_pcxdp_grant_pa = arbpc0_pcxdp_grant_arbbf_pa; \n  assign arbpc0_pcxdp_q0_hold_pa_l = arbpc0_pcxdp_q0_hold_arbbf_pa_l; \n  assign arbpc0_pcxdp_qsel0_pa = arbpc0_pcxdp_qsel0_arbbf_pa; \n  assign arbpc0_pcxdp_qsel1_pa_l = arbpc0_pcxdp_qsel1_arbbf_pa_l; \n  assign arbpc0_pcxdp_shift_px = arbpc0_pcxdp_shift_arbbf_px; \n  assign arbpc2_pcxdp_grant_pa = arbpc2_pcxdp_grant_arbbf_pa; \n  assign arbpc2_pcxdp_q0_hold_pa_l = arbpc2_pcxdp_q0_hold_arbbf_pa_l; \n  assign arbpc2_pcxdp_qsel0_pa = arbpc2_pcxdp_qsel0_arbbf_pa; \n  assign arbpc2_pcxdp_qsel1_pa_l = arbpc2_pcxdp_qsel1_arbbf_pa_l; \n  assign arbpc2_pcxdp_shift_px = arbpc2_pcxdp_shift_arbbf_px; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"power_trig\" is designed to perform various operations based on the input signals and produce specific output signals. It includes a setting register, a 2-port RAM module, and multiple combinational and sequential logic blocks.\n\nThe module's functionality includes assigning values to various registers and wires based on clock edges, reset, enable, and other input conditions. The module also includes instantiations of a 2-port RAM module and a MULT18X18S module to perform specific operations on the input data.\n\nOverall, the module processes the input signals and triggers the generation of specific output signals based on the specified conditions and operations.\n\n Module header:\n\nmodule power_trig #(parameter WIDTH = 24,parameter BASE = 0) (input clock,input reset,input clear,input enable,input set_stb, input [7:0] set_addr, input [31:0] set_data,input [WIDTH-1:0] frontend_i,input [WIDTH-1:0] frontend_q,output [WIDTH-1:0] ddc_in_i,output [WIDTH-1:0] ddc_in_q,input [31:0] ddc_out_sample,input ddc_out_strobe,output ddc_out_enable,output [31:0] bb_sample,output bb_strobe);\n [/INST]\n", "output": "assign ddc_in_i = frontend_i; \n  assign ddc_in_q = frontend_q; \n  assign ddc_out_enable = enable; \n  reg [8:0] wr_addr; \n  wire [8:0] rd_addr; \n  reg triggered, triggerable; \n  wire trigger; \n  wire [31:0] delayed_sample; \n  wire [31:0] thresh; \n  setting_reg #(.my_addr(BASE+0)) sr_0 \n (.clk(clk),.rst(reset),.strobe(set_stb),.addr(set_addr),.in(set_data),.out(thresh),.changed()); \n  assign rd_addr = wr_addr + 1; \n  ram_2port #(.DWIDTH(32),.AWIDTH(9)) delay_line \n (.clka(clk),.ena(1),.wea(ddc_out_strobe),.addra(wr_addr),.dia(ddc_out_sample),.doa(),.clkb(clk),.enb(ddc_out_strobe),.web(1'b0),.addrb(rd_addr),.dib(32'hFFFF),.dob(delayed_sample)); \n  always @(posedge clock) \n  if(reset | ~enable) \n  wr_addr <= 0; \n  else \n  if(ddc_out_strobe) \n  wr_addr <= wr_addr + 1; \n  always @(posedge clock) \n  if(reset | ~enable) \n  triggerable <= 0; \n  else if(wr_addr == 9'h1FF) \n  triggerable <= 1; \n  reg stb_d1, stb_d2; \n  always @(posedge clock) stb_d1 <= ddc_out_strobe; \n  always @(posedge clock) stb_d2 <= stb_d1; \n  assign bb_sample = delayed_sample; \n  assign bb_strobe = stb_d1 & triggered; \n  wire [17:0] mult_in = stb_d1 ? { ddc_out_sample[15],ddc_out_sample[15:0], 1'b0 } : \n  { ddc_out_sample[31], ddc_out_sample[31:16], 1'b0 }; \n  wire [35:0] prod; \n  reg [31:0] sum; \n  MULT18X18S mult (.P(prod), .A(mult_in), .B(mult_in), .C(clock), .CE(ddc_out_strobe | stb_d1), .R(reset) ); \n  always @(posedge clock) \n  if(stb_d1) \n  sum <= prod[35:4]; \n  else if(stb_d2) \n  sum <= sum + prod[35:4]; \n  always @(posedge clock) \n  if(reset | ~enable | ~triggerable) \n  triggered <= 0; \n  else if(trigger) \n  triggered <= 1; \n  assign trigger = (sum > thresh); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes inputs Rt_out, Mem_addr_in, and IR, and produces the output Mem_data_shift using a series of MUXes. The module manipulates the input Rt_out using the control signals generated from the IR input to perform left and right shifts, and then outputs the shifted result as Mem_data_shift.\n\n Module header:\n\nmodule Register_ShiftOutput(input [31:0] Rt_out,input [1:0] Mem_addr_in,input [31:26] IR,output [31:0] Mem_data_shift);\n [/INST]\n", "output": "wire [2:0] Rt_out_shift_ctr; \n wire [31:0] Rt_out_l,Rt_out_r,Rt_out_shift; \n assign Rt_out_shift_ctr[2] = (IR[31])&(!IR[30])&(IR[29])&(((!IR[28])&(IR[27])) | ((IR[27])&(!IR[26])) ); \n assign Rt_out_shift_ctr[1] = (IR[31])&(!IR[30])&(IR[29])&(((!IR[28])&(!IR[27])&(IR[26])) | ((IR[28])&(IR[27])&(!IR[26]))); \n assign Rt_out_shift_ctr[0] = (IR[31])&(!IR[30])&(IR[29])&(!IR[28])&(IR[27])&(!IR[26]); \n MUX4_1 mux4_1_0(Mem_addr_in[1:0],Rt_out[31:24],8'b0,8'b0,8'b0,Rt_out_l[31:24]); \n MUX4_1 mux4_1_1(Mem_addr_in[1:0],Rt_out[23:16],Rt_out[31:24],8'b0,8'b0,Rt_out_l[23:16]); \n MUX4_1 mux4_1_2(Mem_addr_in[1:0],Rt_out[15:8],Rt_out[23:16],Rt_out[31:24],8'b0,Rt_out_l[15:8]); \n MUX4_1 mux4_1_3(Mem_addr_in[1:0],Rt_out[7:0],Rt_out[15:8],Rt_out[23:16],Rt_out[31:24],Rt_out_l[7:0]); \n MUX4_1 mux4_1_4(Mem_addr_in[1:0],Rt_out[7:0],Rt_out[15:8],Rt_out[23:16],Rt_out[31:24],Rt_out_r[31:24]); \n MUX4_1 mux4_1_5(Mem_addr_in[1:0],8'b0,Rt_out[7:0],Rt_out[15:8],Rt_out[23:16],Rt_out_r[23:16]); \n MUX4_1 mux4_1_6(Mem_addr_in[1:0],8'b0,8'b0,Rt_out[7:0],Rt_out[15:8],Rt_out_r[15:8]); \n MUX4_1 mux4_1_7(Mem_addr_in[1:0],8'b0,8'b0,8'b0,Rt_out[7:0],Rt_out_r[7:0]); \n MUX8_1 mux8_1_0(Rt_out_shift_ctr[2:0],Rt_out[7:0],8'b0,Rt_out[15:8],8'b0,Rt_out_l[31:24],Rt_out_l[31:24],Rt_out_r[31:24],8'b0,Mem_data_shift[31:24]); \n MUX8_1 mux8_1_1(Rt_out_shift_ctr[2:0],Rt_out[7:0],8'b0,Rt_out[7:0],8'b0,Rt_out_l[23:16],Rt_out_l[23:16],Rt_out_r[23:16],8'b0,Mem_data_shift[23:16]); \n MUX8_1 mux8_1_2(Rt_out_shift_ctr[2:0],Rt_out[7:0],8'b0,Rt_out[15:8],8'b0,Rt_out_l[15:8],Rt_out_l[15:8],Rt_out_r[15:8],8'b0,Mem_data_shift[15:8]); \n MUX8_1 mux8_1_3(Rt_out_shift_ctr[2:0],Rt_out[7:0],8'b0,Rt_out[7:0],8'b0,Rt_out_l[7:0],Rt_out_l[7:0],Rt_out_r[7:0],8'b0,Mem_data_shift[7:0]); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a SPI slave with inputs for chip select (nCS), clock (CLK), and MOSI, and an output for MISO. The module contains memory to store 8-bit data and uses a 4-bit state variable to control the SPI communication. It interfaces with an SPI frontend module to handle the communication protocol. When nCS transitions to a high state, the module resets the state. When data is valid and nCS is low, the module processes the received data based on the current state. It updates the address, performs read or write operations to the memory, and outputs relevant information.\n\n Module header:\n\nmodule SPIslave(nCS, CLK, MOSI, MISO);\n [/INST]\n", "output": "input nCS; \n  input CLK; \n  input MOSI; \n  output MISO; \n  reg [7:0] inbyte; \n  wire [7:0] outbyte; \n  wire out_valid; \n  reg [7:0] mem[0:65535]; \n  reg [3:0] state; \n  reg [15:0] adr; \n SPIfrontend front(nCS, CLK, MOSI, MISO,inbyte, outbyte, out_valid); \n  always @(posedge nCS) begin \n  state<=0; \n  end \n  always @(posedge out_valid) if (!nCS) begin \n  $display(\"Received %d\", outbyte); \n  case (state) \n  0: begin \n  adr[7:0]<=outbyte; state<=1; \n  end \n  1: begin \n  adr[15:8]<=outbyte; state<=2; \n  end \n  2: begin \n  if (outbyte) begin \n  state<=3; \n  end else begin \n  $display(\"Reading location 0x%x, which contains 0x%x\", adr, mem[adr]); \n  inbyte<=mem[adr]; \n  state<=4; \n  end \n  end \n  3: begin \n  mem[adr]<=outbyte; \n  $display(\"Writing location 0x%x with 0x%x\", adr, outbyte); \n  state<=0; \n  end \n  4: begin \n  state<=0; \n  end \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a D flip-flop with set and reset functionality. When the reset signal is active, the output is set to 0. When the reset signal is inactive and the enable signal is active, the output is updated with the input value on the positive edge of the clock signal.\n\n Module header:\n\nmodule dff_sr(in, enable, clock, reset, out);\n [/INST]\n", "output": "input in, enable, clock, reset; \n  output out; \n  reg out; \n  always @ (posedge clock or posedge reset) begin \n  if (reset) begin \n  out <= 1'b0; \n  end \n  else if (enable) begin \n  out <= in; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a top-level design that interfaces with various input and output ports such as switches, push buttons, LEDs, and a serial communication interface. It also interacts with other submodules like `demo_clk` and `top_pss`. It generates control signals for the submodule based on the user inputs, such as switch settings and button presses, and provides the necessary data and control signals for serial communication. It also generates various LED status indicators based on internal counters and the state of the submodules. Overall, this top-level module acts as a coordinator for the entire design, handling user interactions and interfacing with lower-level modules.\n\n Module header:\n\nmodule demo_top(FPGA_SYSTEMACE_CLOCK,SW_0, SW_1, SW_2, SW_3,PB_ENTER, PB_UP, PB_DOWN, PB_LEFT, PB_RIGHT,LED_0, LED_1, LED_2, LED_3,RS232_TX_DATA, RS232_RX_DATA);\n [/INST]\n", "output": "input FPGA_SYSTEMACE_CLOCK; \n input SW_0; \n input SW_1; \n input SW_2; \n input SW_3; \n input PB_ENTER; \n input PB_UP; \n input PB_DOWN; \n input PB_LEFT; \n input PB_RIGHT; \n output LED_0; \n output LED_1; \n output LED_2; \n output LED_3; \n input RS232_RX_DATA; \n output RS232_TX_DATA; \n wire dsu_sram_we; \n wire [31:0] iimx_adr_o; \n wire iimx_rqt_o; \n wire [31:0] iimx_dat_i; \n wire iimx_ack_i; \n wire iimx_rty_i; \n wire iimx_err_i; \n wire [31:0] iimx_adr_i; \n wire [31:0] dimx_adr_o; \n wire dimx_rqt_o; \n wire dimx_we_o; \n wire [3:0] dimx_sel_o; \n wire [31:0] dimx_dat_o; \n wire [31:0] dimx_dat_i; \n wire dimx_ack_i; \n wire dimx_err_i; \n demo_clk demo_clk (.CLK_IN(FPGA_SYSTEMACE_CLOCK),.RST(1'b0),.CLK1X(clk32M),.CLK2X(clk),.LOCK(dcm_lock)); \n assign rst = !PB_ENTER; \n reg [26:0] clk_counter; \n always @(posedge clk or posedge rst) begin \n  if(rst) \n  clk_counter <= 27'd0; \n  else \n  clk_counter <= clk_counter + 27'd1; \n end \n wire iimx_rqt_status; \n wire iimx_rsp_status; \n wire dimx_rqt_status; \n wire dimx_rsp_status; \n assign iimx_rqt_status = (|iimx_adr_o) & iimx_rqt_o; \n assign dimx_rqt_status = (|dimx_adr_o) & dimx_rqt_o; \n assign iimx_rsp_status = (|iimx_dat_i) & iimx_ack_i; \n assign dimx_rsp_status = ((|dimx_dat_i) | dimx_we_o) & dimx_ack_i; \n assign pushed = !(PB_UP & PB_DOWN & PB_LEFT & PB_RIGHT); \n reg [9:0] num_burn_word; \n always @(posedge clk or posedge rst) begin \n  if(rst) \n  num_burn_word <= 10'd0; \n  else if (dsu_sram_we) \n  num_burn_word <= num_burn_word + 10'd1; \n end \n assign dsu_rst = pushed; \n assign dsu_burn_enable = SW_3; \n assign LED0_light = clk_counter[26] & !rst & SW_0; \n assign LED1_light = iimx_rqt_status | dimx_rqt_status & SW_1; \n assign LED2_light = iimx_rsp_status | dimx_rsp_status & SW_2; \n assign LED3_light = |num_burn_word; \n assign LED_0 = ! LED0_light; \n assign LED_1 = ! LED1_light; \n assign LED_2 = ! LED2_light; \n assign LED_3 = ! LED3_light; \n top_pss sys_top_pss(.clk(clk),.rst(rst),.dsu_rst(dsu_rst),.dsu_burn_enable(dsu_burn_enable),.dsu_sram_we(dsu_sram_we),.txd(RS232_TX_DATA),.rxd(RS232_RX_DATA),.iimx_adr_o(iimx_adr_o),.iimx_rqt_o(iimx_rqt_o),.iimx_rty_i(iimx_rty_i),.iimx_ack_i(iimx_ack_i),.iimx_err_i(iimx_err_i),.iimx_dat_i(iimx_dat_i),.iimx_adr_i(iimx_adr_i),.dimx_adr_o(dimx_adr_o),.dimx_rqt_o(dimx_rqt_o),.dimx_we_o(dimx_we_o),.dimx_sel_o(dimx_sel_o),.dimx_dat_o(dimx_dat_o),.dimx_dat_i(dimx_dat_i),.dimx_ack_i(dimx_ack_i),.dimx_err_i(dimx_err_i)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, named norflash32, is designed to interface with a Nor flash memory device. It has input and output ports for system clock, reset, address, data, write burst control signals, and an acknowledgment signal. The module includes a 4-bit counter and logic for setting the flash address based on the write burst address, and updating the write data output based on the flash data. The counter is incremented on each valid write burst and is used to generate the write burst acknowledgment signal. When the counter reaches its maximum value, the write burst is ended.\n\n Module header:\n\nmodule norflash32 #(parameter adr_width = 21) (input sys_clk,input sys_rst,input [31:0] wb_adr_i,output reg [31:0] wb_dat_o,input wb_stb_i,input wb_cyc_i,output reg wb_ack_o,output reg [adr_width-1:0] flash_adr,input [31:0] flash_d);\n [/INST]\n", "output": "always @(posedge sys_clk) begin \n  if(wb_cyc_i & wb_stb_i) \n  flash_adr <= wb_adr_i[adr_width+1:2]; \n  wb_dat_o <= flash_d; \n end \n reg [3:0] counter; \n always @(posedge sys_clk) begin \n  if(sys_rst) \n  counter <= 4'd1; \n  else begin \n  if(wb_cyc_i & wb_stb_i) \n  counter <= counter + 4'd1; \n  wb_ack_o <= &counter; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `nrzi_4b5b_decoder` takes a 4-bit input and decodes it to a 3-bit output, along with an error flag. It is synchronous, updating the output on the positive edge of the `clk80` input or a positive edge of the `reset` signal.\n\nThe module includes an input register `d`, an inverse flag `inv`, and output registers `dout` and `error`. When the `reset` signal is asserted, it resets the registers and sets the initial values for `dout`, `error`, and `inv`.\n\nDuring normal operation, if the `enable` input is high, the input register `d` is set based on the value of the `din` input and the inverse flag. Then, based on the value of `d`, the module selects the output value and sets the error flag accordingly. If the `din` input does not match any expected value, the error flag is set to indicate an error.\n\nThe module essentially performs a decoding operation based on the input and sets the output and error flags accordingly.\n\n Module header:\n\nmodule nrzi_4b5b_decoder (input clk80,input reset,input enable,input [4:0]din,output reg [3:0]dout,output reg error);\n [/INST]\n", "output": "reg [4:0]d; \n  reg inv; \n  always @(posedge clk80 or posedge reset) \n  begin \n  if (reset) \n  begin \n  d <= 5'b00000; \n  inv <= 0; \n  dout <= 4'b1010; \n  error <= 0; \n  end \n  else \n  begin if (enable) \n  d <= inv ? din : ~din; \n  inv <= din[0]; \n  case (d) \n  5'b01011: {dout,error} <= 5'b0000_0; \n  5'b10001: {dout,error} <= 5'b0001_0; \n  5'b00111: {dout,error} <= 5'b0010_0; \n  5'b00110: {dout,error} <= 5'b0011_0; \n  5'b10011: {dout,error} <= 5'b0100_0; \n  5'b10010: {dout,error} <= 5'b0101_0; \n  5'b10100: {dout,error} <= 5'b0110_0; \n  5'b10101: {dout,error} <= 5'b0111_0; \n  5'b00011: {dout,error} <= 5'b1000_0; \n  5'b00010: {dout,error} <= 5'b1001_0; \n  5'b00100: {dout,error} <= 5'b1010_0; \n  5'b00000: {dout,error} <= 5'b1010_0; \n  5'b00101: {dout,error} <= 5'b1011_0; \n  5'b01100: {dout,error} <= 5'b1100_0; \n  5'b01101: {dout,error} <= 5'b1101_0; \n  5'b01000: {dout,error} <= 5'b1110_0; \n  5'b01001: {dout,error} <= 5'b1111_0; \n  default: {dout,error} <= 5'b1010_1; \n  endcase \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a 4-to-1 multiplexer with a 3-bit input (type) to select one of the four 16-bit input signals (z0, z1, z2, z3). The 2-bit input (rot) determines which of the 16-bit outputs (block_t, block_z, block_s, block_j, block_l, block_o, block_i) is passed through to the output signal (block) based on the value of the type input. The output is calculated based on the selected type and rot inputs and the corresponding block signal. The module uses several sub-modules, each implementing a truth table to select the output signal based on the value of rot.\n\n Module header:\n\nmodule JIZLOTS_sel(input[2:0] type, input[1:0] rot, output reg[0:15] block);\n [/INST]\n", "output": "wire[0:15] block_t, block_z, block_s, block_j, block_l, block_o, block_i; \n T_sel t(rot, block_t); \n Z_sel z(rot, block_z); \n S_sel s(rot, block_s); \n J_sel j(rot, block_j); \n L_sel l(rot, block_l); \n O_sel o(rot, block_o); \n I_sel i(rot, block_i); \n always @* \n begin \n  case(type) \n  0: block = block_t; \n  1: block = block_z; \n  2: block = block_s; \n  3: block = block_j; \n  4: block = block_l; \n  5: block = block_o; \n  6: block = block_i; \n  default: block = 0; \n  endcase \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"MAIN\" interfaces with the system clock and various VGA components. It includes a clock generator, timing generation, color bars generation, and video output components. The module outputs signals for VGA synchronization, color data, and blanking, and also controls LEDs. The color bars generator creates test patterns for the VGA output. Overall, the module facilitates the generation of VGA signals for displaying images on a monitor.\n\n Module header:\n\nmodule MAIN (SYSTEM_CLOCK,LED,VGA_HSYNCH,VGA_VSYNCH,VGA_OUT_RED,VGA_OUT_GREEN,VGA_OUT_BLUE);\n [/INST]\n", "output": "input SYSTEM_CLOCK; \n output [7:0] LED; \n output VGA_HSYNCH; \n output VGA_VSYNCH; \n output VGA_OUT_RED; \n output VGA_OUT_GREEN; \n output VGA_OUT_BLUE; \n wire system_clock_buffered; \n wire pixel_clock; \n wire reset; \n wire vga_red_data; \n wire vga_green_data; \n wire vga_blue_data; \n wire h_synch; \n wire v_synch; \n wire blank; \n wire [10:0] pixel_count; \n wire [9:0] line_count; \n assign LED[0] = 0; \n assign LED[1] = 1; \n assign LED[2] = 0; \n assign LED[3] = 1; \n assign LED[4] = 0; \n assign LED[5] = 1; \n assign LED[6] = 0; \n assign LED[7] = 1; \n CLOCK_GEN CLOCK_GEN \n (SYSTEM_CLOCK,system_clock_buffered,pixel_clock,reset); \n SVGA_TIMING_GENERATION SVGA_TIMING_GENERATION \n (pixel_clock,reset,h_synch,v_synch,blank,pixel_count,line_count); \n COLOR_BARS COLOR_BARS \n (pixel_clock,reset,pixel_count,line_count,vga_red_data,vga_green_data,vga_blue_data); \n VIDEO_OUT VIDEO_OUT \n (pixel_clock,reset,vga_red_data,vga_green_data,vga_blue_data,h_synch,v_synch,blank,VGA_HSYNCH,VGA_VSYNCH,VGA_OUT_RED,VGA_OUT_GREEN,VGA_OUT_BLUE); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a hardware multiplier that calculates the product of two input operands a and b. It operates on a clock signal and an enable signal, and stores the result in the output register p when the enable signal is asserted. The product is calculated using the assign statement and the result is stored in the register on the rising edge of the clock when the enable signal is active.\n\n Module header:\n\nmodule nfa_accept_samples_generic_hw_mul_16ns_8ns_24_2_MAC2S_0(clk, ce, a, b, p);\n [/INST]\n", "output": "input clk; \n input ce; \n input[16 - 1 : 0] a; \n input[8 - 1 : 0] b; \n output[24 - 1 : 0] p; \n reg[24 - 1 : 0] p; \n wire [24 - 1 : 0] tmp_product; \n assign tmp_product = a * b; \n always @ (posedge clk) begin \n  if (ce) begin \n  p <= tmp_product; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a data rate conversion and buffering circuit. It takes input data at a certain rate, and outputs the data at double that rate. The module includes read and write pointers, read and write data registers, and logic to handle data rate conversion. The circuit also features buffering capabilities using two sets of registers for storing input data and outputting it at the higher data rate. The module also includes logic to handle data enable signals and resets for proper operation.\n\n Module header:\n\nmodule rx_gear #(parameter GWIDTH = 14) (input wire clk_250 ,input wire clk_125 ,input wire rst_n ,input wire drate_enable,input wire [GWIDTH-1:0] data_in ,output wire [GWIDTH*2-1:0] data_out);\n [/INST]\n", "output": "reg [1:0] wr_pntr ; \n reg [1:0] rd_pntr ; \n reg wr_en ; \n reg [GWIDTH-1:0] rd_data0 ; \n reg [GWIDTH-1:0] rd_data1 ; \n integer i ; \n integer j ; \n reg [GWIDTH-1:0] rf_0[0:3] ; \n reg [GWIDTH-1:0] rf_1[0:3] ; \n reg drate_f0 ; \n reg drate_f1 ; \n reg drate_s0; \n reg rd_enable; \n reg[1:0] rd_cnt; \n always @(posedge clk_250, negedge rst_n) begin \n  if (!rst_n) begin \n  drate_f0 <= 1'b0; \n  drate_f1 <= 1'b0; \n  end \n  else begin \n  drate_f0 <= drate_enable; \n  drate_f1 <= drate_f0; \n  end \n end \n always @(posedge clk_125, negedge rst_n) begin \n  if (!rst_n) \n  drate_s0 <= 1'b0; \n  else \n  drate_s0 <= drate_enable; \n end \n always @(posedge clk_250, negedge rst_n) begin \n  if (!rst_n) \n  wr_pntr <= 2'b00; \n  else if (wr_en & drate_f1) \n  wr_pntr <= wr_pntr + 2'b01; \n  else \n  wr_pntr <= wr_pntr; \n end \n always @(posedge clk_250, negedge rst_n) begin \n  if (!rst_n) \n  wr_en <= 1'b0; \n  else if(~drate_f1) \n  wr_en <= 1'b0; \n  else \n  wr_en <= ~wr_en; \n end \n always @(posedge clk_125, negedge rst_n) begin \n  if (!rst_n) \n  rd_pntr <= 2'b10; \n  else if(drate_s0) \n  rd_pntr <= rd_pntr + 2'b01; \n  else \n  rd_pntr <= rd_pntr; \n end \n assign data_out = {rd_data0,rd_data1}; \n always @(posedge clk_250, negedge rst_n) begin \n  if (!rst_n) \n  for (i=0;i<=3;i=i+1) begin \n  rf_0[i] <= 0; \n  end \n  else if (!wr_en) \n  rf_0[wr_pntr] <= data_in ; \n end \n always @(posedge clk_125, negedge rst_n) begin \n  if (!rst_n) \n  rd_data0 <= 14'b00000000000010; \n  else begin \n  if(rd_enable) \n  rd_data0 <= rf_0[rd_pntr] ; \n  else \n  rd_data0 <= 14'b00000000000010; \n  end \n end \n always @(posedge clk_250, negedge rst_n) begin \n  if (!rst_n) \n  for (j=0;j<=3;j=j+1) begin \n  rf_1[j] <= 0; \n  end \n  else if (wr_en) \n  rf_1[wr_pntr] <= data_in ; \n end \n always @(posedge clk_125, negedge rst_n) begin \n  if (!rst_n) \n  rd_data1 <= 14'b00000000000010; \n  else begin \n  if(rd_enable) \n  rd_data1 <= rf_1[rd_pntr] ; \n  else \n  rd_data1 <= 14'b00000000000010; \n  end \n end \n always @(posedge clk_125, negedge rst_n) begin \n  if (!rst_n) begin \n  rd_cnt <= 2'b00; \n  rd_enable <= 1'b0; \n  end \n  else begin \n  if(drate_s0) \n  rd_cnt <= rd_cnt + 2'b01; \n  else \n  rd_cnt <= 2'b00; \n  if(~drate_s0) \n  rd_enable <= 1'b0; \n  else if(rd_cnt == 2'b11) \n  rd_enable <= 1'b1; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes in three inputs and assigns values to three outputs based on the value of the input 'kind'. The outputs valA, valB, and valC are assigned different combinations of the input values valX, valY, and valI based on the value of 'kind'. If 'kind' is 2'b00, the outputs are assigned based on the values of valX, valY, and valI. If 'kind' is 2'b01, the outputs are assigned based on the values of valX, valI, and valY. If 'kind' is 2'b10, the outputs are assigned based on the values of valI, valX, and valY. If 'kind' is 2'b11, the outputs are assigned specific values.\n\n Module header:\n\nmodule Shuf(input[1:0] kind, input signed[31:0] valX, valY, valI,output reg signed[31:0] valA, valB, valC);\n [/INST]\n", "output": "always @* case (kind) \n  2'b00: {valA,valB,valC} = {valX ,valY,valI}; \n  2'b01: {valA,valB,valC} = {valX ,valI,valY}; \n  2'b10: {valA,valB,valC} = {valI ,valX,valY}; \n  2'b11: {valA,valB,valC} = {32'h0,valX,valI}; \n  endcase \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, named \"system_controller,\" serves as a clock and reset controller for a digital system. It takes the inputs clk_i and rst_i and generates the outputs clk, rst, and nrst. The module includes conditional instantiation based on the XILINX condition.\n\nWhen the XILINX condition is met, the module uses an IBUF component to buffer the input clock signal. Otherwise, it directly assigns the input clock to the output clk. The reset logic initializes a 5-bit reset count, and the rst output is the logical OR of all the bits in the reset count, while the nrst output is the inverse of the rst output.\n\nThe reset count is updated on each rising edge of the input clock when the reset signal is not asserted. If the reset signal is asserted, the reset count is set to 1.\n\n Module header:\n\nmodule system_controller (clk, rst, nrst,clk_i, rst_i);\n [/INST]\n", "output": "input wire clk_i; \n  input wire rst_i; \n  output wire clk; \n  output wire rst; \n  output wire nrst; \n `ifdef XILINX \n  wire clk_ibuf; \n  IBUF xclk_ibufg(.I(clk_i), .O(clk_ibuf)); \n `else \n  assign clk = clk_i; \n  reg [4:0] reset_count =0; \n  assign rst = |reset_count; \n  assign nrst = ~rst; \n  always @(posedge clk_i or posedge rst_i) \n  if (rst_i) begin \n  reset_count <= 1; \n  end else begin \n  if (reset_count) \n  reset_count <= reset_count + 1; \n  end \n `endif \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `int_ctrl` is designed to handle interrupts and outputs the interrupt number and a control signal. It operates on a clock signal and a reset signal, and the input `io_int_i` represents the interrupt signals. The `io_int_o` output indicates whether the interrupt is active or not. The `int_num_o` output corresponds to the interrupt number.\n\nUpon reset, the `io_int_o` and `int_num_o` are initialized. Upon a clock edge, if the reset is not active, the module checks the input interrupt signals and sets the output control signal accordingly. If the interrupt signal is active, it sets `io_int_o` to 1 and determines the interrupt number based on the input interrupt signals.\n\nFor each bit of `io_int_i`, the module sets the corresponding bit of `int_num_o` based on the position of the active interrupt signal. This allows the module to effectively handle and respond to interrupt requests.\n\n Module header:\n\nmodule int_ctrl(input wire clk_i,input wire rst_i,input wire [`IO_INT_N-1:0] io_int_i,output reg io_int_o,output reg [`N-1:0] int_num_o);\n [/INST]\n", "output": "initial begin \n  io_int_o <= 1'b0; \n  int_num_o <= `N'h0; \n  end \n  always @(posedge clk_i) begin \n  if (rst_i) begin \n  io_int_o <= 1'b0; \n  int_num_o <= `N'h0; \n  end \n  else if (!io_int_o && io_int_i != `IO_INT_N'h0) begin \n  io_int_o <= 1'b1; \n  if (io_int_i[0]) \n  int_num_o <= `N'h0; \n  else if (io_int_i[1]) \n  int_num_o <= `N'h1; \n  else if (io_int_i[2]) \n  int_num_o <= `N'h2; \n  else if (io_int_i[3]) \n  int_num_o <= `N'h3; \n  else if (io_int_i[4]) \n  int_num_o <= `N'h4; \n  else if (io_int_i[5]) \n  int_num_o <= `N'h5; \n  else if (io_int_i[6]) \n  int_num_o <= `N'h6; \n  else if (io_int_i[7]) \n  int_num_o <= `N'h7; \n  else if (io_int_i[8]) \n  int_num_o <= `N'h8; \n  else if (io_int_i[9]) \n  int_num_o <= `N'h9; \n  else if (io_int_i[10]) \n  int_num_o <= `N'ha; \n  else if (io_int_i[11]) \n  int_num_o <= `N'hb; \n  else if (io_int_i[12]) \n  int_num_o <= `N'hc; \n  else if (io_int_i[13]) \n  int_num_o <= `N'hd; \n  else if (io_int_i[14]) \n  int_num_o <= `N'he; \n  else if (io_int_i[15]) \n  int_num_o <= `N'hf; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a dual-port RAM with separate read and write ports. The module has clock, data, read address, write address, and write enable inputs, along with an output register. The RAM has two separate write enable inputs for the two ports. The module instantiates a dual-port RAM component with the specified inputs and connects the data and output ports accordingly. When the write enable input is asserted, the data input is written into the RAM at the specified write address. When the read address is specified, the corresponding data is output through the q output port.\n\n Module header:\n\n module dual2 (clk, data, rdaddress, wraddress , wren, q);\n [/INST]\n", "output": "input clk; \n input[17:0] data; \n input [15:0] rdaddress; \n input [15:0] wraddress; \n input wren; \n output [17:0] q; \n wire const_zero; \n wire [17:0] const_zero_data; \n wire [17:0] dont_care_out; \n assign const_zero = 1'b0; \n assign const_zero_data = 18'b000000000000000000; \n assign dont_care_out = 18'b000000000000000000; \n dual_port_ram dpram1(.clk (clk),.we1(wren),.we2(const_zero),.data1(data),.data2(const_zero_data),.out1(dont_care_out),.out2 (q),.addr1(wraddress),.addr2(rdaddress)); \n  endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a QPSK demodulator for baseband signals. It consists of threshold comparisons for in-phase and quadrature components, a decision lookup table, and a hard decision output. The in-phase and quadrature components are compared to a threshold, and the results are used to address a lookup table to make a hard decision. The hard decision output is then assigned to the module output.\n\n Module header:\n\nmodule QPSK_Demodulator_Baseband (in0_re,in0_im,out0);\n [/INST]\n", "output": "input signed [15:0] in0_re; \n  input signed [15:0] in0_im; \n  output [1:0] out0; \n  wire inphase_lt_zero; \n  wire inphase_eq_zero; \n  wire quadrature_lt_zero; \n  wire quadrature_eq_zero; \n  wire [3:0] decisionLUTaddr; \n  wire [1:0] DirectLookupTable_1 [0:15]; \n  wire [1:0] hardDecision; \n assign inphase_lt_zero = (in0_re < 16'sb0000000000000000 ? 1'b1 :1'b0); \n assign inphase_eq_zero = (in0_re == 16'sb0000000000000000 ? 1'b1 :1'b0); \n assign quadrature_lt_zero = (in0_im < 16'sb0000000000000000 ? 1'b1 :1'b0); \n assign quadrature_eq_zero = (in0_im == 16'sb0000000000000000 ? 1'b1 :1'b0); \n  assign decisionLUTaddr = {inphase_lt_zero, inphase_eq_zero, quadrature_lt_zero, quadrature_eq_zero}; \n  assign DirectLookupTable_1[0] = 2'b00; \n  assign DirectLookupTable_1[1] = 2'b00; \n  assign DirectLookupTable_1[2] = 2'b10; \n  assign DirectLookupTable_1[3] = 2'b00; \n  assign DirectLookupTable_1[4] = 2'b01; \n  assign DirectLookupTable_1[5] = 2'b00; \n  assign DirectLookupTable_1[6] = 2'b10; \n  assign DirectLookupTable_1[7] = 2'b00; \n  assign DirectLookupTable_1[8] = 2'b01; \n  assign DirectLookupTable_1[9] = 2'b11; \n  assign DirectLookupTable_1[10] = 2'b11; \n  assign DirectLookupTable_1[11] = 2'b00; \n  assign DirectLookupTable_1[12] = 2'b00; \n  assign DirectLookupTable_1[13] = 2'b00; \n  assign DirectLookupTable_1[14] = 2'b00; \n  assign DirectLookupTable_1[15] = 2'b00; \n  assign hardDecision = DirectLookupTable_1[decisionLUTaddr]; \n  assign out0 = hardDecision; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module initializes and controls the testbench for the mpemu_scale module. It reads test data from memory, sets the clock frequency, and monitors the outputs to ensure they match expected values after specific intervals. The module uses a clock signal to drive the sequential logic elements and monitors the output using display statements and assertions.\n\n Module header:\n\nmodule mpemu_scale_t;\n [/INST]\n", "output": "`define DATALEN 32 \n reg [31:0] testdata_a [`DATALEN-1:0]; \n reg [31:0] testdata_b [`DATALEN-1:0]; \n reg [31:0] testdata_p [`DATALEN-1:0]; \n reg clk; \n reg [23:0] mpcand_i; \n reg [31:0] scale_i; \n wire [31:0] mprod_o; \n mpemu_scale uut(.clk(clk),.mpcand_i(mpcand_i), .scale_i(scale_i),.mprod_o(mprod_o)); \n parameter TCLK = 41.0; \n integer i; \n initial begin \n  $dumpfile(\"mpemu_scale_t.lxt\"); \n  $dumpvars(0, mpemu_scale_t); \n  $readmemh(\"testdata/gen/mp_scale_a.hex\", testdata_a); \n  $readmemh(\"testdata/gen/mp_scale_b.hex\", testdata_b); \n  $readmemh(\"testdata/gen/mp_scale_p.hex\", testdata_p); \n  clk = 1'b0; \n  #TCLK; \n  mpcand_i = 24'h123456; \n  scale_i = 32'h01_000000; \n  #TCLK; \n  mpcand_i = 24'h123456; \n  scale_i = 32'h02_000000; \n  #TCLK; \n  mpcand_i = 24'hffffff; \n  scale_i = 32'h01_000000; \n  #TCLK; \n  for (i = 0; i < `DATALEN; i = i + 1) begin \n  mpcand_i = testdata_a[i]; \n  scale_i = testdata_b[i]; \n  #TCLK; \n  end \n  #(TCLK*8); \n  $finish(2); \n end \n always #(TCLK/2) clk = ~clk; \n integer i2; \n always begin \n  #(TCLK*7); \n  $display(\"%h should be %h\", mprod_o, 32'h00123456); \n  #TCLK; \n  $display(\"%h should be %h\", mprod_o, 32'h002468ac); \n  #TCLK; \n  $display(\"%h should be %h\", mprod_o, 32'hffffffff); \n  #TCLK; \n  for (i2 = 0; i2 < `DATALEN; i2 = i2 + 1) begin \n  $display(\"%h should be %h\", mprod_o, testdata_p[i2]); \n  #TCLK; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a non-exclusive select logic based on the inputs x, y, a, b, c, d, and e. The output o is determined by the value of x, with a default value of a. If y is 0, the output o is set to d, and if y is 1, the output o is set to e.\n\n Module header:\n\nmodule case_nonexclusive_select (input wire [1:0] x, y,input wire a, b, c, d, e,output reg o);\n [/INST]\n", "output": "always @* begin \n  case (x) \n  0: o = b; \n  2: o = b; \n  1: o = c; \n  default: begin \n  o = a; \n  if (y == 0) o = d; \n  if (y == 1) o = e; \n  end \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module is a data multiplexer that selects between two 8-bit input buses based on a 2-bit selector input. If the selector is `01`, the output is `Din1`; if the selector is `02`, the output is `Din2`; otherwise, the output is `8'b1`.\n\n Module header:\n\nmodule data_multiplexer(input [1:0] selector,input [7:0] Din1,input [7:0] Din2,output [7:0] Dout);\n [/INST]\n", "output": "assign Dout = (selector == 2'd01) ? Din1 : \n  (selector == 2'd02) ? Din2 : \n  8'b1; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `TERASIC_ADC_READ` represents an ADC controller interfacing with an ADC_READ module. It utilizes clock and reset signals to control read and write operations. When the chip is selected for reading, it outputs the read data. Similarly, when the chip is selected for writing, it initiates the write operation based on the input data. The module also instantiates an ADC_READ module for further functionality.\n\n Module header:\n\nmodule TERASIC_ADC_READ(clk,reset_n,s_chipselect,s_read,s_readdata,s_write,s_writedata,SPI_CLK,SPI_CS_n,SPI_IN,SPI_OUT);\n [/INST]\n", "output": "input clk; \n input reset_n; \n input s_chipselect; \n input s_read; \n output reg [15:0] s_readdata; \n input s_write; \n input [15:0] s_writedata; \n output SPI_CLK; \n output SPI_CS_n; \n input SPI_IN; \n output SPI_OUT; \n reg Start; \n wire Done; \n wire [11:0] Data; \n reg [2:0] Channel; \n always @ (posedge clk or negedge reset_n) \n begin \n  if (~reset_n) \n  s_readdata <= 0; \n  else if (s_chipselect & s_read) \n  s_readdata <= {Done,3'b000,Data}; \n end \n always @ (posedge clk or negedge reset_n) \n begin \n  if (~reset_n) \n  Start <= 1'b0; \n  else if (s_chipselect & s_write) \n  begin \n  Start <= s_writedata[15]; \n  if (s_writedata[15]) \n  Channel <= s_writedata[2:0]; \n  end \n end \n ADC_READ ADC_READ_Inst(.clk(clk),.reset_n(reset_n),.Channel(Channel),.Data(Data),.Start(Start),.Done(Done),.oDIN(SPI_OUT),.oCS_n(SPI_CS_n),.oSCLK(SPI_CLK),.iDOUT(SPI_IN)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module serves as an IO adapter for PS/2 devices. It processes clock and data signals for two PS/2 devices and includes inputs and outputs for clock and data signals for a mouse and a keyboard. The module assigns the receive clock and data signals for each device and sets the output and transmit signals for the clock and data lines. Additionally, it ensures the proper functionality of clock and data signals for both PS/2 devices.\n\n Module header:\n\nmodule dual_ps2_ioadapter (ps2_clk_rx_1,ps2_clk_rx_2,ps2_clk_tx_1,ps2_clk_tx_2,ps2_d_rx_1,ps2_d_rx_2,ps2_d_tx_1,ps2_d_tx_2,ps2_mouse_clk_I,ps2_mouse_clk_O,ps2_mouse_clk_T,ps2_mouse_data_I,ps2_mouse_data_O,ps2_mouse_data_T,ps2_keyb_clk_I,ps2_keyb_clk_O,ps2_keyb_clk_T,ps2_keyb_data_I,ps2_keyb_data_O,ps2_keyb_data_T);\n [/INST]\n", "output": "output ps2_clk_rx_1; \n  output ps2_clk_rx_2; \n  input ps2_clk_tx_1; \n  input ps2_clk_tx_2; \n  output ps2_d_rx_1; \n  output ps2_d_rx_2; \n  input ps2_d_tx_1; \n  input ps2_d_tx_2; \n  input ps2_mouse_clk_I; \n  output ps2_mouse_clk_O; \n  output ps2_mouse_clk_T; \n  input ps2_mouse_data_I; \n  output ps2_mouse_data_O; \n  output ps2_mouse_data_T; \n  input ps2_keyb_clk_I; \n  output ps2_keyb_clk_O; \n  output ps2_keyb_clk_T; \n  input ps2_keyb_data_I; \n  output ps2_keyb_data_O; \n  output ps2_keyb_data_T; \n  assign ps2_clk_rx_1 = ps2_mouse_clk_I; \n  assign ps2_clk_rx_2 = ps2_keyb_clk_I; \n  assign ps2_d_rx_1 = ps2_mouse_data_I; \n  assign ps2_d_rx_2 = ps2_keyb_data_I; \n  assign ps2_mouse_clk_O = 1'b0; \n  assign ps2_mouse_clk_T = ~ps2_clk_tx_1; \n  assign ps2_mouse_data_O = 1'b0; \n  assign ps2_mouse_data_T = ~ps2_d_tx_1; \n  assign ps2_keyb_clk_O = 1'b0; \n  assign ps2_keyb_clk_T = ~ps2_clk_tx_2; \n  assign ps2_keyb_data_O = 1'b0; \n  assign ps2_keyb_data_T = ~ps2_d_tx_2; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module instantiates a Digital Clock Manager (DCM) with various parameters for clock generation and manipulation. It generates multiple clock signals (CLK0, CLK180, CLK270, CLK2X, CLK2X180, CLK90, CLKDV, CLKFX, CLKFX180, LOCKED, PSDONE, STATUS) based on the input clock (CLKIN) and control signals (CLKFB, DSSEN, PSCLK, PSEN, PSINCDEC, RST). The module also contains clock multiplier and divider instances to generate the desired clock frequencies based on the input parameters. It also includes logic to handle startup wait, phase shift, and duty cycle correction.\n\n Module header:\n\nmodule DCM #(parameter CLKFX_MULTIPLY = 4,parameter CLKFX_DIVIDE = 1,parameter CLKDV_DIVIDE = 2,parameter CLKIN_PERIOD = 10,parameter CLK_FEEDBACK = 0,parameter CLKOUT_PHASE_SHIFT = 0,parameter CLKIN_DIVIDE_BY_2 = \"FALSE\",parameter DESKEW_ADJUST = \"SYSTEM_SYNCHRONOUS\",parameter DFS_FREQUENCY_MODE = \"LOW\",parameter DLL_FREQUENCY_MODE = \"LOW\",parameter DUTY_CYCLE_CORRECTION = \"TRUE\",parameter FACTORY_JF = 16'hC080,parameter PHASE_SHIFT = 0,parameter STARTUP_WAIT = \"TRUE\") (CLK0,CLK180,CLK270,CLK2X,CLK2X180,CLK90,CLKDV,CLKFX,CLKFX180,LOCKED,PSDONE,STATUS,CLKFB,CLKIN,DSSEN,PSCLK,PSEN,PSINCDEC,RST);\n [/INST]\n", "output": "input wire CLKFB, CLKIN, DSSEN; \n input wire PSCLK, PSEN, PSINCDEC, RST; \n output wire CLKDV, CLKFX, CLKFX180, LOCKED, PSDONE; \n output wire CLK0, CLK180, CLK270, CLK2X, CLK2X180, CLK90; \n output wire [7:0] STATUS; \n assign STATUS = 0; \n assign CLK0 = CLKIN; \n assign CLK180 = ~CLKIN; \n assign CLK270 = ~CLK90; \n assign CLK2X180 = ~CLK2X; \n assign CLKFX180 = ~CLKFX; \n wire resetb = ~RST; \n wire clk2x; \n clock_multiplier #(.MULTIPLIER(2)) i_clock_multiplier_two(.CLK(CLKIN),.CLOCK(clk2x)); \n reg clk90; \n reg [1:0] cnt; \n always @(posedge clk2x or negedge clk2x or negedge resetb) begin \n  if (!resetb) begin \n  clk90 <= 0; \n  cnt <= 0; \n  end else begin \n  cnt <= cnt + 1; \n  if (!cnt[0]) clk90 <= ~clk90; \n  end \n end \n assign CLK2X = clk2x; \n assign CLK90 = clk90; \n generate \n  if (CLKFX_MULTIPLY==2 && CLKFX_DIVIDE==1) begin \n  assign CLKFX = clk2x; \n  end else begin \n  wire CLKINM; \n  clock_multiplier #( .MULTIPLIER(CLKFX_MULTIPLY) ) i_clock_multiplier(.CLK(CLKIN),.CLOCK(CLKINM)); \n  clock_divider_sim #(.DIVISOR(CLKFX_DIVIDE)) i_clock_divisor_rx (.CLK(CLKINM), .CLOCK(CLKFX)); \n  end \n endgenerate \n clock_divider_sim #(.DIVISOR(CLKDV_DIVIDE)) i_clock_divisor_dv (.CLK(CLKIN),.CLOCK(CLKDV)); \n assign LOCKED = 1'b1; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module named testmul performs multiplication of two 32-bit inputs, data_a and data_b. It also includes a sign bit for the multiplication. The result is an output vector data_c of 64 bits, and the sign of the multiplication is output as well. The module initializes data_a and data_b to specific values and then continuously increments data_b.\n\n Module header:\n\nmodule testmul;\n [/INST]\n", "output": "reg [31:0] data_a; \n  reg [31:0] data_b; \n  reg sign; \n  wire [63:0] data_c; \n mul uut (.data_c(data_c),.data_a(data_a),.data_b(data_b),.sign(sign)); \n  initial begin \n  data_a = 0; \n  data_b = 0; \n  sign = 1; \n  #100; \n  end \n  initial begin \n  forever #20 data_b = data_b + 1; \n  end \n  always begin \n  #200 data_a = 32'hffff0001; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"packTupleArrays_table__0x059d9250\" takes in a clock signal, process control enable signal, and a 336-bit input data. It then processes the input data and generates a 336-bit output data. The input data is split into two 168-bit parts, and each part is further divided into 21 8-bit sub-parts. The module then interleaves the sub-parts from the two halves of the input to produce the output. The output is formed by alternating the 8-bit sub-parts from the two halves, resulting in a rearranged 336-bit output.\n\n Module header:\n\nmodule packTupleArrays_table__0x059d9250(input CLK, input process_CE, input [335:0] process_input, output [335:0] process_output);\n [/INST]\n", "output": "parameter INSTANCE_NAME=\"INST\"; \n  wire [167:0] unnamedcast1357USEDMULTIPLEcast;assign unnamedcast1357USEDMULTIPLEcast = (process_input[167:0]); \n  wire [167:0] unnamedcast1361USEDMULTIPLEcast;assign unnamedcast1361USEDMULTIPLEcast = (process_input[335:168]); \n  assign process_output = {{({unnamedcast1361USEDMULTIPLEcast[167:160]}),({unnamedcast1357USEDMULTIPLEcast[167:160]})},{({unnamedcast1361USEDMULTIPLEcast[159:152]}),({unnamedcast1357USEDMULTIPLEcast[159:152]})},{({unnamedcast1361USEDMULTIPLEcast[151:144]}),({unnamedcast1357USEDMULTIPLEcast[151:144]})},{({unnamedcast1361USEDMULTIPLEcast[143:136]}),({unnamedcast1357USEDMULTIPLEcast[143:136]})},{({unnamedcast1361USEDMULTIPLEcast[135:128]}),({unnamedcast1357USEDMULTIPLEcast[135:128]})},{({unnamedcast1361USEDMULTIPLEcast[127:120]}),({unnamedcast1357USEDMULTIPLEcast[127:120]})},{({unnamedcast1361USEDMULTIPLEcast[119:112]}),({unnamedcast1357USEDMULTIPLEcast[119:112]})},{({unnamedcast1361USEDMULTIPLEcast[111:104]}),({unnamedcast1357USEDMULTIPLEcast[111:104]})},{({unnamedcast1361USEDMULTIPLEcast[103:96]}),({unnamedcast1357USEDMULTIPLEcast[103:96]})},{({unnamedcast1361USEDMULTIPLEcast[95:88]}),({unnamedcast1357USEDMULTIPLEcast[95:88]})},{({unnamedcast1361USEDMULTIPLEcast[87:80]}),({unnamedcast1357USEDMULTIPLEcast[87:80]})},{({unnamedcast1361USEDMULTIPLEcast[79:72]}),({unnamedcast1357USEDMULTIPLEcast[79:72]})},{({unnamedcast1361USEDMULTIPLEcast[71:64]}),({unnamedcast1357USEDMULTIPLEcast[71:64]})},{({unnamedcast1361USEDMULTIPLEcast[63:56]}),({unnamedcast1357USEDMULTIPLEcast[63:56]})},{({unnamedcast1361USEDMULTIPLEcast[55:48]}),({unnamedcast1357USEDMULTIPLEcast[55:48]})},{({unnamedcast1361USEDMULTIPLEcast[47:40]}),({unnamedcast1357USEDMULTIPLEcast[47:40]})},{({unnamedcast1361USEDMULTIPLEcast[39:32]}),({unnamedcast1357USEDMULTIPLEcast[39:32]})},{({unnamedcast1361USEDMULTIPLEcast[31:24]}),({unnamedcast1357USEDMULTIPLEcast[31:24]})},{({unnamedcast1361USEDMULTIPLEcast[23:16]}),({unnamedcast1357USEDMULTIPLEcast[23:16]})},{({unnamedcast1361USEDMULTIPLEcast[15:8]}),({unnamedcast1357USEDMULTIPLEcast[15:8]})},{({unnamedcast1361USEDMULTIPLEcast[7:0]}),({unnamedcast1357USEDMULTIPLEcast[7:0]})}}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module performs a logical OR operation between the input vconst and b, and assigns the result to the output q. The output q is a registered output.\n\n Module header:\n\nmodule ta (input vconst,input b,output reg q);\n [/INST]\n", "output": "always @ (b or vconst) begin \n  q = vconst | b; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module represents a simple program counter (PC) circuit. It uses a clock input to update the PC output. The PC is initialized to 0 and is incremented by 4 every clock cycle. The module contains a single instantiation of the program_counter module with connections to the clock and the PC outputs. The clock signal toggles every 10 time units.\n\n Module header:\n\nmodule test_pc;\n [/INST]\n", "output": "reg clk; \n  reg [31:0] pc_next; \n  wire [31:0] pc_now; \n program_counter uut (.clk(clk),.pc_next(pc_next),.pc_now(pc_now)); \n  initial begin \n  clk = 0; \n  pc_next = 0; \n  #100; \n  end \n  always @* pc_next <= pc_now + 4; \n  always #10 clk = ~clk; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a bidirectional XOR memory with multiple ports. It contains internal registers for the write input, address, and data. The memory uses a simple dual-port RAM for each port. The module also calculates an intermediate value based on the XOR operation of the internal query registers and applies it to the data. The output values are then assigned based on the intermediate values and the internal query registers.\n\n Module header:\n\nmodule bidirectional_xor_memory(clk, wr, addr, d, q);\n [/INST]\n", "output": "parameter PORTS = 4; \n parameter DEPTH = 512; \n parameter WIDTH = 64; \n parameter LOG2_DEPTH = log2(DEPTH - 1); \n input clk; \n input [0:PORTS - 1] wr; \n input [PORTS * LOG2_DEPTH - 1:0] addr; \n input [PORTS * WIDTH - 1:0] d; \n output [PORTS * WIDTH - 1:0] q; \n reg [0:PORTS - 1] wr_r; \n reg [LOG2_DEPTH - 1:0] addr_r [0:PORTS - 1]; \n reg [WIDTH - 1:0] d_r [0:PORTS - 1]; \n integer i; \n always @(posedge clk) begin \n  wr_r <= wr; \n  for(i = 0; i < PORTS; i = i + 1) begin \n  addr_r[i] = addr[(i + 1) * LOG2_DEPTH - 1 -:LOG2_DEPTH]; \n  d_r[i] = d[(i + 1) * WIDTH - 1 -:WIDTH]; \n  end \n end \n reg [WIDTH - 1:0] d_internal [0:PORTS - 1]; \n wire [WIDTH - 1:0] q_internal [0:PORTS - 1][0:PORTS - 1]; \n genvar g0, g1; \n generate for(g0 = 0; g0 < PORTS; g0 = g0 + 1) \n for(g1 = 0; g1 < PORTS; g1 = g1 + 1) \n  simple_dual_port_ram #(WIDTH, DEPTH) g_ram(clk, wr_r[g0], addr_r[g0], d_internal[g0], addr[(g1 + 1) * LOG2_DEPTH - 1 -:LOG2_DEPTH], q_internal[g0][g1]); \n endgenerate \n reg [WIDTH - 1:0] intermediate_value [0:PORTS - 1]; \n integer i, j; \n always @* begin \n  for(i = 0; i < PORTS; i = i + 1) begin \n  intermediate_value[i] = 0; \n  for(j = 0; j < PORTS; j = j + 1) begin \n  if(i != j) \n  intermediate_value[i] = intermediate_value[i] ^ q_internal[j][i]; \n  end \n  d_internal[i] = intermediate_value[i] ^ d_r[i]; \n  end \n end \n generate for(g0 = 0; g0 < PORTS; g0 = g0 + 1) \n  assign q[(g0 + 1) * WIDTH - 1 -: WIDTH] = intermediate_value[g0] ^ q_internal[g0][g0]; \n endgenerate \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `shift_reg` is a finite state machine that processes incoming data `rx` and generates `shifted_bus` output based on a predefined state transition logic. The module contains four states: idle, reading, finished, and finished_and_waiting. The state transition is determined by the input `rx` and the content of the shift register `bitShiftReg`. The module also sets `finished_rx` to 1 when the state is finished and resets it to 0 otherwise. The `baud_clk` signal drives the state transitions, and the `rst` signal resets the module to its initial state.\n\n Module header:\n\nmodule shift_reg(input rx,output reg[(reg_length-1):0] shifted_bus,output reg finished_rx,input rst,input baud_clk);\n [/INST]\n", "output": "parameter reg_length = 150; \n  initial finished_rx = 0; \n  parameter idle = 2'b00, reading = 2'b01, finished = 2'b10, finished_and_waiting = 2'b11; \n  reg[1:0] current_state, next_state; \n  reg [(reg_length-1):0] bitShiftReg = {reg_length{1'b1}}; \n  always @(posedge baud_clk or posedge rst) begin \n  if(rst) begin \n  bitShiftReg <= {reg_length{1'b1}}; \n  current_state <= idle; \n  end \n  else begin \n  current_state <= next_state; \n  bitShiftReg <= {bitShiftReg[(reg_length-2):0],rx}; \n  end \n  end \n  always @(rx or bitShiftReg or current_state) begin \n  case(current_state) \n  idle: begin \n  if(rx == 1) \n  next_state <= idle; \n  else \n  next_state <= reading; \n  end \n  reading: begin \n  if(bitShiftReg[6:0] == {7{1'b1}}) \n  next_state <= finished; \n  else \n  next_state <= reading; \n  end \n  finished: begin \n  next_state<= finished_and_waiting; \n  end \n  default: begin \n  next_state<=idle; \n  end \n  endcase \n  end \n  always @ (current_state) begin \n  if(current_state == finished) \n  finished_rx <= 1; \n  else \n  finished_rx <= 0; \n  end \n  always @ (posedge finished_rx or posedge rst) begin \n  if(rst) \n  shifted_bus <= {reg_length{1'b1}}; \n  else \n  shifted_bus <= bitShiftReg; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module takes in a serial input 'ser' and, on each rising edge of the clock 'clk', shifts the input into a register 'par_reg' by one bit. The module then outputs the parallel data 'par' which consists of the previous 'par_reg' value and the current 'ser' input. This effectively converts the serial input to parallel data.\n\n Module header:\n\nmodule ser_to_par #(parameter W=8) (input clk , input ser,output[W-1:0] par);\n [/INST]\n", "output": "reg[W-2:0] par_reg = 0; \n  always @(posedge clk) begin \n  par_reg <= {par_reg[W-3:0], ser}; \n  end \n  assign par = {par_reg, ser}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a SPI multi-transfer controller with a state machine. It has input and output signals for clock, reset, start, busy, new_data, tx_data, rx_data, start_spi, done, and chip_select. The module includes a 2-entry transmit data table and a 2-entry receive data table. The state machine has 5 states: IDLE, STARTING, DELAY, RUNNING, and DONE. The module operates in a loop where it initializes the state and other signals and then transitions through the states based on the input and output signals. It handles SPI transactions and manages the data transfer process.\n\n Module header:\n\nmodule spi_multi_transfer(clk,rst,start,busy,new_data,tx_data,rx_data,start_spi,done,chip_select);\n [/INST]\n", "output": "parameter TRANSFER_COUNT = 2; \n input clk, rst, start, busy, new_data; \n input[7:0] rx_data; \n output[7:0] tx_data; \n output reg start_spi, done, chip_select; \n reg[7:0] tx_table[TRANSFER_COUNT-1:0]; \n reg[7:0] rx_table[TRANSFER_COUNT-1:0]; \n localparam IDLE = 3'd0, STARTING = 3'd1, DELAY = 3'd2, \n  RUNNING = 3'd3, DONE = 3'd4; \n reg[2:0] state; \n reg[31:0] index; \n reg i; \n always @(posedge clk) begin \n  if(rst) begin \n  index <= 32'b0; \n  state <= IDLE; \n  done <= 1'b0; \n  start_spi <= 1'b0; \n  chip_select <= 1'b1; \n  rx_table[0] <= 8'b0; \n  rx_table[1] <= 8'b0; \n  tx_table[0] <= 8'b1111000; \n  tx_table[1] <= 8'b1111000; \n  end else begin \n  case(state) \n  IDLE: begin \n  index <= 32'b0; \n  chip_select <= 1'b1; \n  if(start) begin \n  state <= STARTING; \n  end \n  end \n  STARTING: begin \n  done <= 1'b0; \n  start_spi <= 1'b1; \n  chip_select <= 1'b0; \n  state <= DELAY; \n  end \n  DELAY: begin \n  state <= RUNNING; \n  start_spi <= 1'b0; \n  end \n  RUNNING: begin \n  if ((!busy) && new_data) begin \n  rx_table[index] <= rx_data; \n  index <= index + 1; \n  if(index == TRANSFER_COUNT) begin \n  done <= 1'b1; \n  state <= DONE; \n  end else begin \n  state <= STARTING; \n  start_spi <= 1'b1; \n  end \n  end \n  end \n  DONE: begin \n  state <= IDLE; \n  end \n  default: begin \n  state <= IDLE; \n  end \n  endcase \n  end \n end \n assign tx_data = tx_table[index]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module named LiftHandshake_WaitOnInput_PadSeq_uint8_W640_H480_L4_R4_B1_Top1_T22 instantiates two submodules, WaitOnInput_PadSeq_uint8_W640_H480_L4_R4_B1_Top1_T22 and ShiftRegister_1_CEtrue_TY1, to handle input processing and validation of the output. It checks for valid bit values in the input and output signals and raises a warning if an X value is detected. The process_output is assigned based on the output of the submodule, and the ready signal is controlled by a combination of downstream ready and internal ready signals. The module uses the clock signal to trigger specific checks for valid bit values in the input and output signals. If X values are detected, it displays a warning message.\n\n Module header:\n\nmodule LiftHandshake_WaitOnInput_PadSeq_uint8_W640_H480_L4_R4_B1_Top1_T22(input CLK, input ready_downstream, output ready, input reset, input [16:0] process_input, output [16:0] process_output);\n [/INST]\n", "output": "parameter INSTANCE_NAME=\"INST\"; \n parameter OUTPUT_COUNT=0; \n parameter INPUT_COUNT=0; \n  wire inner_WaitOnInput_PadSeq_uint8_W640_H480_L4_R4_B1_Top1_T22_ready; \n  assign ready = {(inner_WaitOnInput_PadSeq_uint8_W640_H480_L4_R4_B1_Top1_T22_ready&&ready_downstream)}; \n  wire unnamedbinop343USEDMULTIPLEbinop;assign unnamedbinop343USEDMULTIPLEbinop = {(reset||ready_downstream)}; \n  wire unnamedunary344USEDMULTIPLEunary;assign unnamedunary344USEDMULTIPLEunary = {(~reset)}; \n  wire [16:0] inner_WaitOnInput_PadSeq_uint8_W640_H480_L4_R4_B1_Top1_T22_process_output; \n  wire validBitDelay_WaitOnInput_PadSeq_uint8_W640_H480_L4_R4_B1_Top1_T22_pushPop_out; \n  wire [16:0] unnamedtuple376USEDMULTIPLEtuple;assign unnamedtuple376USEDMULTIPLEtuple = {{((inner_WaitOnInput_PadSeq_uint8_W640_H480_L4_R4_B1_Top1_T22_process_output[16])&&validBitDelay_WaitOnInput_PadSeq_uint8_W640_H480_L4_R4_B1_Top1_T22_pushPop_out)},(inner_WaitOnInput_PadSeq_uint8_W640_H480_L4_R4_B1_Top1_T22_process_output[15:0])}; \n  always @(posedge CLK) begin if({(~{((unnamedtuple376USEDMULTIPLEtuple[16])===1'bx)})} == 1'b0 && (1'd1)==1'b1) begin $display(\"%s: LiftHandshake: output valid bit should not be X!\",INSTANCE_NAME); end end \n  always @(posedge CLK) begin if({(~{((process_input[16])===1'bx)})} == 1'b0 && (1'd1)==1'b1) begin $display(\"%s: LiftHandshake: input valid bit should not be X!\",INSTANCE_NAME); end end \n  assign process_output = unnamedtuple376USEDMULTIPLEtuple; \n  WaitOnInput_PadSeq_uint8_W640_H480_L4_R4_B1_Top1_T22 #(.INSTANCE_NAME({INSTANCE_NAME,\"_inner_WaitOnInput_PadSeq_uint8_W640_H480_L4_R4_B1_Top1_T22\"})) inner_WaitOnInput_PadSeq_uint8_W640_H480_L4_R4_B1_Top1_T22(.CLK(CLK), .ready(inner_WaitOnInput_PadSeq_uint8_W640_H480_L4_R4_B1_Top1_T22_ready), .reset(reset), .CE(unnamedbinop343USEDMULTIPLEbinop), .process_valid(unnamedunary344USEDMULTIPLEunary), .process_input(process_input), .process_output(inner_WaitOnInput_PadSeq_uint8_W640_H480_L4_R4_B1_Top1_T22_process_output)); \n  ShiftRegister_1_CEtrue_TY1 #(.INSTANCE_NAME({INSTANCE_NAME,\"_validBitDelay_WaitOnInput_PadSeq_uint8_W640_H480_L4_R4_B1_Top1_T22\"})) validBitDelay_WaitOnInput_PadSeq_uint8_W640_H480_L4_R4_B1_Top1_T22(.CLK(CLK), .pushPop_valid(unnamedunary344USEDMULTIPLEunary), .CE(unnamedbinop343USEDMULTIPLEbinop), .sr_input((1'd1)), .pushPop_out(validBitDelay_WaitOnInput_PadSeq_uint8_W640_H480_L4_R4_B1_Top1_T22_pushPop_out), .reset(reset)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, named PIO_TO_CTRL, contains two always blocks triggered by the positive edge of the clk signal. The module maintains a trn_pending register and a cfg_turnoff_ok register. When not in reset state (rst_n asserted), the trn_pending register is updated based on the req_compl and compl_done inputs. Similarly, the cfg_turnoff_ok register is updated based on the cfg_to_turnoff and trn_pending signals. The TCQ parameter specifies the delay for register updates.\n\n Module header:\n\nmodule PIO_TO_CTRL #(parameter TCQ = 1) (input clk,input rst_n,input req_compl,input compl_done,input cfg_to_turnoff,output reg cfg_turnoff_ok);\n [/INST]\n", "output": "reg trn_pending; \n  always @ ( posedge clk ) begin \n  if (!rst_n ) \n  begin \n  trn_pending <= #TCQ 0; \n  end \n  else \n  begin \n  if (!trn_pending && req_compl) \n  trn_pending <= #TCQ 1'b1; \n  else if (compl_done) \n  trn_pending <= #TCQ 1'b0; \n  end \n  end \n  always @ ( posedge clk ) begin \n  if (!rst_n ) \n  begin \n  cfg_turnoff_ok <= #TCQ 1'b0; \n  end \n  else \n  begin \n  if ( cfg_to_turnoff && !trn_pending) \n  cfg_turnoff_ok <= #TCQ 1'b1; \n  else \n  cfg_turnoff_ok <= #TCQ 1'b0; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module 'square_root32_element' is a combinational logic circuit that squares a 16-bit input and generates a 17-bit output. It also includes a D flip-flop block that synchronizes input data and request signals with the clock signal. The module handles reset signals and data busy states to ensure proper operation. Additionally, it generates output signals for data validity, parity, and the squared input data. The logic is implemented using if-else branches and always blocks to handle various conditions and operations.\n\n Module header:\n\nmodule square_root32_element #(parameter P_IN_N = 4,parameter P_DFF = 1)(input wire iCLOCK,input wire inRESET,input wire iDATA_REQ,output wire oDATA_BUSY,input wire [P_IN_N/2-1:0] iDATA_P,input wire [31:0] iDATA_I,output wire oDATA_VALID,input wire iDATA_BUSY,output wire [P_IN_N/2-1:0] oDATA_P,output wire [31:0] oDATA_I);\n [/INST]\n", "output": "function [P_IN_N/2-1:0] func_cell_gen; \n  input [P_IN_N/2-1:0] func_data_p; \n  input [31:0] func_data_i; \n  reg [P_IN_N-1:0] func_pri_data; \n  begin \n  func_pri_data = func_data_p * func_data_p; \n  if(func_data_i[31:32-P_IN_N] >= func_pri_data)begin \n  func_cell_gen = func_data_p; \n  end \n  else begin \n  func_cell_gen = {func_data_p[P_IN_N/2-1:1], 1'b0}; \n  end \n  end \n  endfunction \n  generate \n  if(P_DFF)begin \n  reg b_buffer_req; \n  reg [P_IN_N/2-1:0] b_buffer_p; \n  reg [31:0] b_buffer_i; \n  always@(posedge iCLOCK or negedge inRESET)begin \n  if(!inRESET)begin \n  b_buffer_req <= 1'b0; \n  end \n  else if(iDATA_BUSY)begin \n  b_buffer_req <= b_buffer_req; \n  end \n  else begin \n  b_buffer_req <= iDATA_REQ; \n  end \n  end \n  always@(posedge iCLOCK or negedge inRESET)begin \n  if(!inRESET)begin \n  b_buffer_p <= {P_IN_N/2{1'b0}}; \n  end \n  else if(iDATA_BUSY)begin \n  b_buffer_p <= b_buffer_p; \n  end \n  else begin \n  b_buffer_p <= func_cell_gen(iDATA_P, iDATA_I); \n  end \n  end \n  always@(posedge iCLOCK or negedge inRESET)begin \n  if(!inRESET)begin \n  b_buffer_i <= 32'h0; \n  end \n  else if(iDATA_BUSY)begin \n  b_buffer_i <= b_buffer_i; \n  end \n  else begin \n  b_buffer_i <= iDATA_I; \n  end \n  end \n  assign oDATA_VALID = b_buffer_req; \n  assign oDATA_P = b_buffer_p; \n  assign oDATA_I = b_buffer_i; \n  end \n  else begin \n  assign oDATA_VALID = iDATA_REQ; \n  assign oDATA_P = func_cell_gen(iDATA_P, iDATA_I); \n  assign oDATA_I = iDATA_I; \n  end \n  endgenerate \n  assign oDATA_BUSY = iDATA_BUSY; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements an ADPCM (Adaptive Differential Pulse Code Modulation) compression algorithm. The module takes in input data and channel enable signals, and produces a signed 16-bit PCM output. It uses a series of registers and calculations to process the input data and generate the compressed output. The algorithm involves steps such as data manipulation, sign comparison, conditional assignments, and step value adjustments. The module also includes reset and clock handling to initialize and update the internal registers. Overall, this module performs ADPCM compression on the input data to produce the output PCM signal.\n\n Module header:\n\nmodule jt10_adpcm_comb(input rst_n,input clk,input cen,input [3:0] data,input chon,output signed [15:0] pcm);\n [/INST]\n", "output": "localparam stepw = 15; \n reg signed [15:0] x1, x2, x3, x4, x5, x6; \n reg [stepw-1:0] step1, step2, step6; \n reg [stepw+1:0] step3, step4, step5; \n assign pcm = x2; \n reg [18:0] d2l; \n reg [15:0] d3,d4; \n reg [3:0] d1,d2; \n reg sign2, sign3, sign4, sign5; \n reg [7:0] step_val; \n reg [22:0] step2l; \n reg chon2, chon3, chon4, chon5; \n reg signEqu4, signEqu5; \n reg [3:0] data1,data2; \n always @( * ) \n  if( ! rst_n ) begin \n  x2 = 'd0; step2 = 'd127; \n  x3 = 'd0; step3 = 'd127; \n  x4 = 'd0; step4 = 'd127; \n  x5 = 'd0; step5 = 'd127; \n  x6 = 'd0; step6 = 'd127; \n  d2 = 'd0; d3 = 'd0; d4 = 'd0; \n  sign2 = 'b0; \n  sign3 = 'b0; \n  sign4 = 'b0; sign5 = 'b0; \n  chon2 = 'b0; chon3 = 'b0; chon4 = 'b0; chon5 = 1'b0; \n  end else begin \n  d2 = d1; \n  sign2 = data1[3]; \n  data2 = data1; \n  x2 = x1; \n  step2 = step1; \n  chon2 = chon; \n  casez( d2[3:1] ) \n  3'b0_??: step_val = 8'd57; \n  3'b1_00: step_val = 8'd77; \n  3'b1_01: step_val = 8'd102; \n  3'b1_10: step_val = 8'd128; \n  3'b1_11: step_val = 8'd153; \n  endcase \n  d2l = d2 * step2; \n  step2l = step_val * step2; \n  d3 = d2l[18:3]; \n  sign3 = sign2; \n  x3 = x2; \n  step3 = step2l[22:6]; \n  chon3 = chon2; \n  d4 = sign3 ? ~d3+16'b1 : d3; \n  sign4 = sign3; \n  signEqu4 = sign3 == x3[15]; \n  x4 = x3; \n  step4 = step3; \n  chon4 = chon3; \n  x5 = x4+d4; \n  sign5 = sign4; \n  signEqu5 = signEqu4; \n  step5 = step4; \n  chon5 = chon4; \n  if( chon5 ) begin \n  if( signEqu5 && (sign5!=x5[15]) ) \n  x6 = sign5 ? 16'h8000 : 16'h7FFF; \n  else \n  x6 = x5; \n  if( step5 < 127 ) \n  step6 = 15'd127; \n  else if( step5 > 24576 ) \n  step6 = 15'd24576; \n  else \n  step6 = step5[14:0]; \n  end else begin \n  x6 = 'd0; \n  step6 = 'd127; \n  end \n  end \n always @(posedge clk or negedge rst_n) \n  if( ! rst_n ) begin \n  x1 <= 'd0; step1 <= 'd127; \n  d1 <= 'd0; data1 <= 'd0; \n  end else if(cen) begin \n  d1 <= {data[2:0],1'b1}; \n  x1 <= x6; \n  step1 <= step6; \n  data1 <= data; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is designed to interface with a PCIe device. It has input and output ports to communicate configuration data. The module synchronizes the input control and status signals with the clock, and also handles reset functionality. When the module is not in reset state, it updates the output configuration address, control, and status signals based on the input values, while also respecting the write enable signals.\n\n Module header:\n\nmodule altpcie_tl_cfg_pipe (input clk,input srst,output reg [ 3:0] o_tl_cfg_add,output reg [31:0] o_tl_cfg_ctl,output reg o_tl_cfg_ctl_wr,output reg [52:0] o_tl_cfg_sts,output reg o_tl_cfg_sts_wr,input [ 3:0] i_tl_cfg_add,input [31:0] i_tl_cfg_ctl,input i_tl_cfg_ctl_wr,input [52:0] i_tl_cfg_sts,input i_tl_cfg_sts_wr);\n [/INST]\n", "output": "reg sts_wr_r,sts_wr_rr; \n  reg ctl_wr_r,ctl_wr_rr; \n  always @ (posedge clk) \n  begin \n  if (srst) \n  begin \n  o_tl_cfg_add <= 4'h0; \n  o_tl_cfg_ctl <= {32{1'b0}}; \n  o_tl_cfg_ctl_wr <= {1{1'b0}}; \n  o_tl_cfg_sts <= {53{1'b0}}; \n  o_tl_cfg_sts_wr <= {1{1'b0}}; \n  end \n  else \n  begin \n  sts_wr_r <= i_tl_cfg_sts_wr; \n  sts_wr_rr <= sts_wr_r; \n  o_tl_cfg_sts_wr <= sts_wr_rr; \n  if (o_tl_cfg_sts_wr != sts_wr_rr) \n  o_tl_cfg_sts <= i_tl_cfg_sts; \n  ctl_wr_r <= i_tl_cfg_ctl_wr; \n  ctl_wr_rr <= ctl_wr_r; \n  o_tl_cfg_ctl_wr <= ctl_wr_rr; \n  if (o_tl_cfg_ctl_wr != ctl_wr_rr) \n  begin \n  o_tl_cfg_add <= i_tl_cfg_add; \n  o_tl_cfg_ctl <= i_tl_cfg_ctl; \n  end \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a Trigger Logic Unit (TLU) model. It includes a trigger signal logic, a state machine, a veto signal, and a trigger ID register. The trigger signal is based on a random event, while the state machine transitions between a wait state, trigger state, and read ID state based on certain conditions. The veto signal is determined by the current state and the TLU_CLOCK signal. The module also updates the trigger ID register based on the trigger signal and TLU_CLOCK. The TLU_TRIGGER output is based on the state and the trigger ID register, and TLU_RESET is always set to 0.\n\n Module header:\n\nmodule tlu_model (input wire SYS_CLK, SYS_RST, TLU_CLOCK, TLU_BUSY, ENABLE,output wire TLU_TRIGGER, TLU_RESET);\n [/INST]\n", "output": "reg [14:0] TRIG_ID; \n reg TRIG; \n wire VETO; \n integer seed; \n initial \n  seed = 0; \n always@(posedge SYS_CLK) begin \n  if(SYS_RST) \n  TRIG <= 0; \n  else if($random(seed) % 100 == 10 && !VETO && ENABLE) \n  TRIG <= 1; \n  else \n  TRIG <= 0; \n end \n always@(posedge SYS_CLK) begin \n  if(SYS_RST) \n  TRIG_ID <= 0; \n  else if(TRIG) \n  TRIG_ID <= TRIG_ID + 1; \n end \n localparam WAIT_STATE = 0, TRIG_STATE = 1, READ_ID_STATE = 2; \n reg [1:0] state, state_next; \n always@(posedge SYS_CLK) \n  if(SYS_RST) \n  state <= WAIT_STATE; \n  else \n  state <= state_next; \n always@(*) begin \n  state_next = state; \n  case(state) \n  WAIT_STATE: \n  if(TRIG) \n  state_next = TRIG_STATE; \n  TRIG_STATE: \n  if(TLU_BUSY) \n  state_next = READ_ID_STATE; \n  READ_ID_STATE: \n  if(!TLU_BUSY) \n  state_next = WAIT_STATE; \n  default : state_next = WAIT_STATE; \n  endcase \n end \n assign VETO = (state != WAIT_STATE) || (state == WAIT_STATE && TLU_CLOCK == 1'b1); \n reg [15:0] TRIG_ID_SR; \n initial TRIG_ID_SR = 0; \n always@(posedge TLU_CLOCK or posedge TRIG) \n  if(TRIG) \n  TRIG_ID_SR <= {TRIG_ID, 1'b0}; \n  else \n  TRIG_ID_SR <= {1'b0, TRIG_ID_SR[15:1]}; \n assign TLU_TRIGGER = (state == TRIG_STATE) | (TRIG_ID_SR[0] & TLU_BUSY); \n assign TLU_RESET = 0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an implementation of a Serial Peripheral Interface (SPI) controller with parameterized clock frequency and chip select length. It takes in clock, reset, control write/read signals, control address, control write data, and MOSI input. It outputs control read data, control done, chip select, and SCLK. The module processes the input signals to control the SPI communication protocol and perform data transfers. It includes state machines and logic to handle control register writes, reads, and SPI data transmission based on the clock and control signals. The module manages the SPI state, clock polarity, clock phase, and prescale counter to ensure proper SPI communication. The SPI controller operates by toggling the clock and manipulating the chip select, MOSI, and MISO signals according to the SPI protocol.\n\n Module header:\n\nmodule spi #(parameter integer CLOCK_FREQ_HZ = 0,parameter integer CS_LENGTH = 32) (input clk,input resetn,input ctrl_wr,input ctrl_rd,input [ 7:0] ctrl_addr,input [31:0] ctrl_wdat,output reg [31:0] ctrl_rdat,output reg ctrl_done,output [CS_LENGTH-1:0] cs,output mosi,input miso,output sclk);\n [/INST]\n", "output": "wire spi_miso; \n  reg spi_mosi, spi_sclk; \n  reg [CS_LENGTH-1:0] spi_cs; \n  reg mode_cpol; \n  reg mode_cpha; \n  reg [7:0] prescale_cnt; \n  reg [7:0] prescale_cfg; \n  reg [7:0] spi_data; \n  reg [4:0] spi_state; \n  assign sclk = spi_sclk ^ ~mode_cpol; \n  assign cs = spi_cs; \n  assign spi_miso = miso; \n  assign mosi = spi_mosi; \n  always @(posedge clk) begin \n  ctrl_rdat <= 'bx; \n  ctrl_done <= 0; \n  if (!resetn) begin \n  spi_mosi <= 0; \n  spi_sclk <= 1; \n  spi_cs <= ~0; \n  mode_cpol <= 1; \n  mode_cpha <= 1; \n  prescale_cnt <= 0; \n  prescale_cfg <= 4; \n  spi_state <= 0; \n  end else \n  if (!ctrl_done) begin \n  if (ctrl_wr) begin \n  ctrl_done <= 1; \n  if (ctrl_addr == 'h00) prescale_cfg <= ctrl_wdat; \n  if (ctrl_addr == 'h04) begin \n  spi_cs <= ctrl_wdat; \n  ctrl_done <= prescale_cnt == prescale_cfg; \n  prescale_cnt <= prescale_cnt == prescale_cfg ? 0 : prescale_cnt + 1; \n  end \n  if (ctrl_addr == 'h08) begin \n  if (!prescale_cnt) begin \n  if (spi_state == 0) begin \n  spi_data <= ctrl_wdat; \n  spi_mosi <= ctrl_wdat[7]; \n  end else begin \n  if (spi_state[0]) \n  spi_data <= {spi_data, spi_miso}; \n  else if (spi_state < 16) \n  spi_mosi <= spi_data[7]; \n  end \n  end \n  spi_sclk <= spi_state[0] ^ ~mode_cpha; \n  ctrl_done <= spi_state == (mode_cpha ? 15 : 16) && prescale_cnt == prescale_cfg; \n  spi_state <= prescale_cnt == prescale_cfg ? (spi_state[4] ? 0 : spi_state + 1) : spi_state; \n  if (mode_cpha) spi_state[4] <= 0; \n  prescale_cnt <= prescale_cnt == prescale_cfg ? 0 : prescale_cnt + 1; \n  end \n  if (ctrl_addr == 'h0c) begin \n  {mode_cpol, mode_cpha} <= ctrl_wdat; \n  ctrl_done <= prescale_cnt == prescale_cfg; \n  prescale_cnt <= prescale_cnt == prescale_cfg ? 0 : prescale_cnt + 1; \n  end \n  end \n  if (ctrl_rd) begin \n  ctrl_done <= 1; \n  if (ctrl_addr == 'h00) ctrl_rdat <= prescale_cfg; \n  if (ctrl_addr == 'h04) ctrl_rdat <= spi_cs; \n  if (ctrl_addr == 'h08) ctrl_rdat <= spi_data; \n  if (ctrl_addr == 'h0c) ctrl_rdat <= {mode_cpol, mode_cpha}; \n  end \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a noise generation circuit. It consists of two Linear Feedback Shift Registers (LFSRs) that are clocked and updated based on input signals. The first LFSR outputs a noise signal, which is assigned to the output of the module. The second LFSR generates a feedback signal used to update the first LFSR. Additionally, the module includes logic to mix the noise signal with other inputs and produces the mixed output. The circuit can be reset and updated based on various control signals and conditions.\n\n Module header:\n\nmodule jt51_noise(input rst,input clk,input cen,input [ 4:0] cycles,input [ 4:0] nfrq,input [ 9:0] eg,input op31_no,output out,output reg [11:0] mix);\n [/INST]\n", "output": "reg update, nfrq_met; \n reg [ 4:0] cnt; \n reg [15:0] lfsr; \n reg last_lfsr0; \n wire all1, fb; \n wire mix_sgn; \n assign out = lfsr[0]; \n always @(posedge clk, posedge rst) begin \n  if( rst ) begin \n  cnt <= 5'b0; \n  end else if(cen) begin \n  if( &cycles[3:0] ) begin \n  cnt <= update ? 5'd0 : (cnt+5'd1); \n  end \n  update <= nfrq_met; \n  nfrq_met <= ~nfrq == cnt; \n  end \n end \n assign fb = update ? ~((all1 & ~last_lfsr0) | (lfsr[2]^last_lfsr0)) \n  : ~lfsr[0]; \n assign all1 = &lfsr; \n always @(posedge clk, posedge rst) begin \n  if( rst ) begin \n  lfsr <= 16'hffff; \n  last_lfsr0 <= 1'b0; \n  end else if(cen) begin \n  lfsr <= { fb, lfsr[15:1] }; \n  if(update) last_lfsr0 <= ~lfsr[0]; \n  end \n end \n assign mix_sgn = ~out; \n always @(posedge clk, posedge rst) begin \n  if( rst ) begin \n  mix <= 12'd0; \n  end else if( op31_no && cen ) begin \n  mix <= { mix_sgn, eg[9:2] ^ {8{out}}, {3{mix_sgn}} }; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"comparator9\" takes a 5-bit input \"V\" and produces a single-bit output \"z\". The output \"z\" is the result of a bitwise operation that performs OR between the most significant bit of \"V\" and the result of another OR operation involving specific combinations of the other bits.\n\n Module header:\n\nmodule comparator9 (V, z);\n [/INST]\n", "output": "input [4:0] V; \n  output z; \n  assign z = V[4] | ((V[3] & V[2]) | (V[3] & V[1])); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module defines a 4-to-1 multiplexer with 32-bit inputs and output. It selects one of the four 32-bit input signals (S0, S1, S2, S3) based on the 2-bit selection signal (Sel) and assigns the selected input to the output. The output signal is derived using a case statement based on the selection signal, and it ends with the termination of the module definition.\n\n Module header:\n\nmodule MUX4_1_32bit(Sel,S0,S1,S2,S3,out);\n [/INST]\n", "output": "input [1:0] Sel; \n input [31:0] S0,S1,S2,S3; \n output [31:0]out; \n assign out = (Sel[1]?(Sel[0]?S3:S2) : (Sel[0]?S1:S0)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a simple constant generator. It has an 8-bit output 'op' which is hardwired to the constant value 00000001. The value remains constant and does not change over time, regardless of the inputs clk, ce, and clr.\n\n Module header:\n\nmodule sysgen_constant_828adcadae (output [(8 - 1):0] op,input clk,input ce,input clr);\n [/INST]\n", "output": "assign op = 8'b00000001; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, Datapath_Unit, represents a simple data path unit. It contains registers AR and BR for storing data, and an output register CR. The module's functionality includes comparing the value of AR with 0 to set AR_lt_0 and AR_gt_0 flags, and performing arithmetic operations on the data based on control signals. Specifically, the module performs loading of AR and BR, division and multiplication operations, and clearing of the CR register. The control signals Div_AR_x2_CR, Mul_BR_x2_CR, and Clr_CR determine which operation to execute, and the clock signal clk triggers the operations.\n\n Module header:\n\nmodule Datapath_Unit(output reg signed[15:0] CR, output reg AR_gt_0, AR_lt_0,input [15:0] Data_AR, Data_BR,input Ld_AR_BR, Div_AR_x2_CR, Mul_BR_x2_CR, Clr_CR, clk);\n [/INST]\n", "output": "reg signed [15:0] AR; \n  reg signed [15:0] BR; \n  always @(AR) begin \n  AR_lt_0 = (AR < 0); \n  AR_gt_0 = (AR > 0); \n  end \n  always @(negedge clk) begin \n  if (Ld_AR_BR) begin \n  AR = Data_AR; \n  BR = Data_BR; \n  end else if (Div_AR_x2_CR) begin \n  CR = AR / 2; \n  end else if (Mul_BR_x2_CR) begin \n  CR = BR * 2; \n  end else if (Clr_CR) begin \n  CR = 0; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is part of a pipeline stage in a processor design. It captures the state of various control signals such as register destination, write enable, ALU sources, ALU function, sign extension, memory write/read, memory-to-register, shift amount, source registers, target register, destination register, and various data buses. The module updates these signals on the positive edge of the clock if there is no data hazard. The control signals are derived from the input instruction and other control signals. If there is a data hazard, the control signals remain unchanged.\n\n Module header:\n\nmodule IDEXreg(clk,instructionin,datahazard,DatabusAin,DatabusBin,immin,PCplusin,RegDstin,RegWrin,ALUSrc1in,ALUSrc2in,ALUFunin,Signin,MemWrin,MemRdin,MemtoRegin,RegDstout,RegWrout,ALUSrc1out,ALUSrc2out,ALUFunout,Signout,MemWrout,MemRdout,MemtoRegout,shamt,Rsout,Rtout,Rdout,DatabusAout,DatabusBout,immout,PCplusout);\n [/INST]\n", "output": "input clk; \n input [31:0] instructionin; \n input datahazard; \n input [31:0] DatabusAin; \n input [31:0] DatabusBin; \n input [31:0] immin; \n input [31:0] PCplusin; \n input [1:0] RegDstin; \n input RegWrin; \n input ALUSrc1in; \n input ALUSrc2in; \n input [5:0] ALUFunin; \n input Signin; \n input MemWrin; \n input MemRdin; \n input [1:0] MemtoRegin; \n output [1:0] RegDstout; \n reg [1:0] RegDstout; \n output RegWrout; \n reg RegWrout; \n output ALUSrc1out; \n reg ALUSrc1out; \n output ALUSrc2out; \n reg ALUSrc2out; \n output [5:0] ALUFunout; \n reg [5:0] ALUFunout; \n output Signout; \n reg Signout; \n output MemWrout; \n reg MemWrout; \n output MemRdout; \n reg MemRdout; \n output [1:0] MemtoRegout; \n reg [1:0] MemtoRegout; \n output [4:0] shamt; \n reg [4:0] shamt; \n output [4:0] Rsout; \n reg [4:0] Rsout; \n output [4:0] Rtout; \n reg [4:0] Rtout; \n output [4:0] Rdout; \n reg [4:0] Rdout; \n output [31:0] DatabusAout; \n reg [31:0] DatabusAout; \n output [31:0] DatabusBout; \n reg [31:0] DatabusBout; \n output [31:0] immout; \n reg [31:0] immout; \n output [31:0] PCplusout; \n reg [31:0] PCplusout; \n always @(posedge clk) \n begin \n  if(~datahazard) \n  begin \n  RegDstout <= RegDstin; \n  RegWrout <= RegWrin; \n  ALUSrc1out <= ALUSrc1in; \n  ALUSrc2out <= ALUSrc2in; \n  ALUFunout <= ALUFunin; \n  Signout <= Signin; \n  MemWrout <= MemWrin; \n  MemRdout <= MemRdin; \n  MemtoRegout <= MemtoRegin; \n  shamt <= instructionin[10:6]; \n  Rsout <= instructionin[25:21]; \n  Rtout <= instructionin[20:16]; \n  if(RegDstin == 2'b00) Rdout <= instructionin[15:11]; \n  else if(RegDstin == 2'b01) Rdout <= instructionin[20:16]; \n  else if(RegDstin == 2'b10) Rdout <= 5'h1f; \n  else Rdout <= 5'h1a; \n  DatabusAout <= DatabusAin; \n  DatabusBout <= DatabusBin; \n  immout <= immin; \n  PCplusout <= PCplusin; \n  end \n  else; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a PS/2 keyboard controller. It interfaces with a PS/2 keyboard to receive data and converts the key codes to ASCII. It contains a state machine that handles the reception and processing of key codes. The module also includes sub-modules for PS/2 data reception and key code identification. The module keeps track of the current key code and handles transitions between states based on the received data and system inputs. The key code is then converted to ASCII and outputted.\n\n Module header:\n\nmodule controlador_teclado_ps2 (input wire clk, reset,input wire ps2data, ps2clk,input wire [7:0] port_id,input wire read_strobe,output wire [7:0] ascii_code);\n [/INST]\n", "output": "wire [10:0] dout; \n wire rx_done_tick; \n wire gotten_code_flag; \n wire [7:0] key_code; \n reg [7:0] key_code_reg, key_code_next; \n reg [1:0] state_current, state_next; \n localparam [1:0] hold_key_code = 2'b0, read_key_code = 2'b01, reset_key_code = 2'b10; \n receptor_teclado_ps2 instancia_receptor_teclado_ps2 \n (.clk(clk),.reset(reset),.ps2data(ps2data),.ps2clk(ps2clk),.rx_en(1'b1),.rx_done_tick(rx_done_tick),.dout(dout)); \n identificador_teclas instancia_identificador_teclas \n (.clk(clk),.reset(reset),.rx_done_tick(rx_done_tick),.dout(dout[8:1]),.gotten_code_flag(gotten_code_flag)); \n keycode_to_ascii instancia_keycode_to_ascii \n (.key_code(key_code),.ascii_code(ascii_code)); \n always@(posedge clk) \n begin \n  if(reset) begin \n  key_code_reg <= 8'b0; \n  state_current <= hold_key_code; \n  end \n  else begin \n  key_code_reg <= key_code_next; \n  state_current <= state_next; \n  end \n end \n always@* \n  begin \n  case(state_current) \n  hold_key_code: \n  begin \n  key_code_next = key_code_reg; \n  if(gotten_code_flag) state_next = read_key_code; \n  else state_next = state_current; \n  end \n  read_key_code: \n  begin \n  key_code_next = dout[8:1]; \n  if(port_id == 8'h02 && read_strobe == 1) state_next = reset_key_code; \n  else state_next = state_current; \n  end \n  reset_key_code: \n  begin \n  key_code_next = 8'b0; \n  state_next = hold_key_code; \n  end \n  default: \n  begin \n  key_code_next = key_code_reg; \n  state_next = state_current; \n  end \n  endcase \n  end \n assign key_code = key_code_reg; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an instance of a channelizer. It interfaces with various input and output signals including clocks, resets, data signals, ready and valid signals, and event signals. It also incorporates a reset signal net, assigns values to various internal nets, and instantiates a sub-module called \"channelizer_512_xfft_v9_0_0.\" The submodule connects to the input and output ports of the main module, performing the actual channelization functionality.\n\n Module header:\n\nmodule xlfast_fourier_transform_6b5aa7edf1f6dd08250b04d840f6bbbc (ce,clk,event_data_in_channel_halt,event_data_out_channel_halt,event_frame_started,event_status_channel_halt,event_tlast_missing,event_tlast_unexpected,m_axis_data_tdata_xn_im_0,m_axis_data_tdata_xn_re_0,m_axis_data_tlast,m_axis_data_tready,m_axis_data_tvalid,rst,s_axis_config_tdata_fwd_inv,s_axis_config_tready,s_axis_config_tvalid,s_axis_data_tdata_xn_im_0,s_axis_data_tdata_xn_re_0,s_axis_data_tlast,s_axis_data_tready,s_axis_data_tvalid);\n [/INST]\n", "output": "input ce; \n input clk; \n output event_data_in_channel_halt; \n output event_data_out_channel_halt; \n output event_frame_started; \n output event_status_channel_halt; \n output event_tlast_missing; \n output event_tlast_unexpected; \n output[25:0] m_axis_data_tdata_xn_im_0; \n output[25:0] m_axis_data_tdata_xn_re_0; \n output m_axis_data_tlast; \n input m_axis_data_tready; \n output m_axis_data_tvalid; \n input rst; \n input[0:0] s_axis_config_tdata_fwd_inv; \n output s_axis_config_tready; \n input s_axis_config_tvalid; \n input[15:0] s_axis_data_tdata_xn_im_0; \n input[15:0] s_axis_data_tdata_xn_re_0; \n input s_axis_data_tlast; \n output s_axis_data_tready; \n input s_axis_data_tvalid; \n wire aresetn_net; \n wire[63:0] m_axis_data_tdata_net; \n wire[7:0] s_axis_config_tdata_net; \n wire[31:0] s_axis_data_tdata_net; \n  assign aresetn_net = rst | (~ ce); \n  assign m_axis_data_tdata_xn_im_0 = m_axis_data_tdata_net[57 : 32]; \n  assign m_axis_data_tdata_xn_re_0 = m_axis_data_tdata_net[25 : 0]; \n  assign s_axis_config_tdata_net[7 : 1] = 7'b0; \n  assign s_axis_config_tdata_net[0 : 0] = s_axis_config_tdata_fwd_inv; \n  assign s_axis_data_tdata_net[31 : 16] = s_axis_data_tdata_xn_im_0; \n  assign s_axis_data_tdata_net[15 : 0] = s_axis_data_tdata_xn_re_0; \n channelizer_512_xfft_v9_0_0 channelizer_512_xfft_v9_0_0_instance(.aclk(clk),.aclken(ce),.aresetn(aresetn_net),.event_data_in_channel_halt(event_data_in_channel_halt),.event_data_out_channel_halt(event_data_out_channel_halt),.event_frame_started(event_frame_started),.event_status_channel_halt(event_status_channel_halt),.event_tlast_missing(event_tlast_missing),.event_tlast_unexpected(event_tlast_unexpected),.m_axis_data_tdata(m_axis_data_tdata_net),.m_axis_data_tlast(m_axis_data_tlast),.m_axis_data_tready(m_axis_data_tready),.m_axis_data_tvalid(m_axis_data_tvalid),.s_axis_config_tdata(s_axis_config_tdata_net),.s_axis_config_tready(s_axis_config_tready),.s_axis_config_tvalid(s_axis_config_tvalid),.s_axis_data_tdata(s_axis_data_tdata_net),.s_axis_data_tlast(s_axis_data_tlast),.s_axis_data_tready(s_axis_data_tready),.s_axis_data_tvalid(s_axis_data_tvalid)); \n  endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module is a system that acts as a slave endpoint and consists of various submodules. It includes input and output ports such as CLK100MHZ, CPU_RESETN, JA1, JA2, AN, CA, CB, CC, CD, CE, CF, CG, DP, and LED. The module initializes several wires and instantiates submodules like uart_basic, UART_RX_CTRL, ALU_and_display, and TX_control_slave. It controls the flow of data and communication between these submodules, facilitating the operation of the entire system. The wires and submodules enable the processing and transmission of data, as well as the implementation of specific control signals.\n\n Module header:\n\nmodule Slave_Endpoint(input CLK100MHZ,input CPU_RESETN,input JA1,output JA2,output [7:0] AN,output CA,CB,CC,CD,CE,CF,CG,DP,output [3:0] LED);\n [/INST]\n", "output": "wire reset; \n  wire [7:0] rx_data; \n  wire rx_ready; \n  wire tx_start; \n  wire [7:0] tx_data; \n  wire [15:0] operando_1 , operando_2; \n  wire [2:0] ALU_ctrl; \n  wire trigger; \n  wire [15:0] resultado; \n  assign reset = ~CPU_RESETN; \n uart_basic uart_basic_inst (.clk(CLK100MHZ),.reset(reset),.rx(JA1),.rx_data(rx_data),.rx_ready(rx_ready),.tx(JA2),.tx_start(tx_start),.tx_data(tx_data),.tx_busy()); \n UART_RX_CTRL UART_RX_CTRL_inst(.clock (CLK100MHZ),.reset (reset),.rx_ready (rx_ready),.rx_data (rx_data),.operando_1 (operando_1),.operando_2 (operando_2),.ALU_ctrl (ALU_ctrl),.trigger (trigger),.alu_cmd_leds (LED [3:0])); \n ALU_and_display ALU_and_display_inst(.clock (CLK100MHZ),.reset (reset),.anodos (AN[7:0]),.segmentos({CA,CB,CC,CD,CE,CF,CG,DP}),.operando_1 (operando_1),.operando_2 (operando_2),.control (ALU_ctrl),.resultado (resultado)); \n TX_control_slave TX_control_slave_inst(.clock (CLK100MHZ),.reset (reset),.trigger (trigger),.dataIn16 (resultado),.tx_data (tx_data),.tx_start (tx_start),.busy ()); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module simulates a basic CPU. It includes signals for clock, reset, program counter, state machine, instructions, registers (op, rs, rt, rd, sa, imm), and memory address. The module assigns these signals based on the input instruction. It instantiates a CPU module and toggles the clock signal. Upon initialization, it sets the initial values for the clock and reset signals.\n\n Module header:\n\nmodule CPUSim();\n [/INST]\n", "output": "reg clk; \n  reg reset; \n  wire [31:0] pc, pcNext; \n  wire [2:0] state; \n  wire [31:0] instruction; \n  wire [31:26] op; \n  wire [25:21] rs; \n  wire [20:16] rt; \n  wire [15:11] rd; \n  wire [10:6] sa; \n  wire [15:0] imm; \n  wire [25:0] address; \n  wire [31:0] readData1, readData2, writeData, aluResult, memData; \n  assign op = instruction[31:26]; \n  assign rs = instruction[25:21]; \n  assign rt = instruction[20:16]; \n  assign rd = instruction[15:11]; \n  assign sa = instruction[10:6]; \n  assign imm = instruction[15:0]; \n  assign address = instruction[25:0]; \n CPU cpu(.clk(clk),.reset(reset),.state(state),.pcAddressOutNext(pcNext),.pcAddressOut(pc),.imDataOut(instruction),.rfReadData1(readData1),.rfReadData2(readData2),.dbdrDataOut(writeData),.aluResult(aluResult),.dmDataOut(memData)); \n  always #15 clk = ~clk; \n  initial begin \n  clk = 0; \n  reset = 0; \n  #45 \n  reset = 1; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module is a controller for interfacing with a synchronous SRAM. It takes input signals such as clock, reset, data, address, write enable, and select signals, and provides outputs for data, address, write enable, clock enable, and acknowledgment. It internally manages state transitions and addresses the SRAM for read and write operations. The module includes a temporary register for write data, clock signal for the SRAM, and flags for loading data from the SRAM. The outputs are generated based on the input signals and internal state transitions.\n\n Module header:\n\nmodule zbt_cntrl (`ifdef DEBUGoutput reg [2:0] cnt,output op,`endifinput wb_clk_i,input wb_rst_i,input [15:0] wb_dat_i,output reg [15:0] wb_dat_o,input [19:1] wb_adr_i,input wb_we_i,input [ 1:0] wb_sel_i,input wb_stb_i,input wb_cyc_i,output reg wb_ack_o,output sram_clk_,output reg [20:0] sram_addr_,inout [31:0] sram_data_,output reg sram_we_n_,output reg [ 3:0] sram_bw_,output reg sram_cen_,output sram_adv_ld_n_);\n [/INST]\n", "output": "reg [31:0] wr; \n  wire nload; \n `ifndef DEBUG \n  reg [ 2:0] cnt; \n  wire op; \n `endif \n  assign op = wb_stb_i & wb_cyc_i; \n  assign nload = (|cnt || wb_ack_o); \n  assign sram_clk_ = wb_clk_i; \n  assign sram_adv_ld_n_ = 1'b0; \n  assign sram_data_ = (op && wb_we_i) ? wr : 32'hzzzzzzzz; \n  always @(posedge wb_clk_i) \n  cnt <= wb_rst_i ? 3'b0 \n  : { cnt[1:0], nload ? 1'b0 : op }; \n  always @(posedge wb_clk_i) \n  wb_ack_o <= wb_rst_i ? 1'b0 : (wb_ack_o ? op : cnt[2]); \n  always @(posedge wb_clk_i) \n wb_dat_o <= cnt[2] ? (wb_adr_i[1] ? sram_data_[31:16]: sram_data_[15:0]) : wb_dat_o; \n  always @(posedge wb_clk_i) \n  sram_addr_ <= op ? { 3'b0, wb_adr_i[19:2] } : sram_addr_; \n  always @(posedge wb_clk_i) \n  sram_we_n_ <= wb_we_i ? (nload ? 1'b1 : !op) : 1'b1; \n  always @(posedge wb_clk_i) \n  sram_bw_ <= wb_adr_i[1] ? { ~wb_sel_i, 2'b11 } \n  : { 2'b11, ~wb_sel_i }; \n  always @(posedge wb_clk_i) \n  sram_cen_ <= wb_rst_i ? 1'b1 : !op; \n  always @(posedge wb_clk_i) \n wr <= op ? (wb_adr_i[1] ? { wb_dat_i, 16'h0 }: { 16'h0, wb_dat_i }) : wr; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module f3_TECH_NAND2 takes a 2-bit input signal and outputs the result of a NAND operation on the input bits. The input bits are first bitwise AND-ed together, and the result is then inverted using the NOT operator to produce the final output.\n\n Module header:\n\nmodule f3_TECH_NAND2(input [1:0] in, output out);\n [/INST]\n", "output": "assign out = ~(&in); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `alu32` takes two 32-bit inputs, `data1` and `data2`, and a 3-bit control signal `ctrl`. It also has a clock input `clk` and outputs a carry `oCarry`, a zero flag `oZero`, and the result `out`. The module is instantiated in the `alu32_tb` testbench. The testbench applies various inputs to `data1`, `data2`, and `ctrl` and toggles the clock to test different arithmetic and logic operations within the `alu32` module, checking for correct carry and zero flag behavior.\n\n Module header:\n\nmodule alu32_tb();\n [/INST]\n", "output": "reg [31:0] data1; \n reg [31:0] data2; \n reg [2:0] ctrl; \n reg clk; \n wire oCarry; \n wire oZero; \n wire [31:0]out; \n alu32 uut(.data1(data1),.data2(data2),.ctrl(ctrl),.clk(clk),.oCarry(oCarry),.oZero(oZero),.out(out)); \n always begin \n #50 clk = 1'b1; \n #50 clk = 1'b0; \n end \n initial begin \n  data1 = 32'b11111111_11111111_11111111_11111111; \n  data2 = 32'b11111111_11111111_11111111_11111111; \n  ctrl = 3'b000; \n  #100; \n  data1 = 32'b11111111_11111111_11111111_11111111; \n  data2 = 32'b00000000_00000000_00000000_00000001; \n  ctrl = 3'b000; \n  #100; \n  data1 = 32'b11111111_11111111_11111111_11111111; \n  data2 = 32'b11111111_11111111_11111111_11111111; \n  ctrl = 3'b001; \n  #100; \n  data1 = 32'b11111111_11111111_11111111_11111111; \n  data2 = 32'b00000000_00000000_00000000_00000001; \n  ctrl = 3'b001; \n  #100; \n  data1 = 32'b00000000_00000000_00000000_00000000; \n  data2 = 32'b00000000_00000000_00000000_00000000; \n  ctrl = 3'b001; \n  #100; \n  data1 = 32'b11111111_11111111_11111111_11111111; \n  data2 = 32'b11111111_11111111_11111111_11111111; \n  ctrl = 3'b010; \n  #100; \n  data1 = 32'b11111111_11111111_11111111_11111111; \n  data2 = 32'b00000000_00001000_00000000_00000000; \n  ctrl = 3'b010; \n  #100; \n  data1 = 32'b11111111_11111111_11111111_11111111; \n  data2 = 32'b11111111_11111111_11111111_11111111; \n  ctrl = 3'b011; \n  #100; \n  data1 = 32'b11111111_11111111_11111111_11111111; \n  data2 = 32'b00000000_00000000_00000000_00000000; \n  ctrl = 3'b011; \n  #100; \n  data1 = 32'b11111111_11111111_11111111_11111111; \n  data2 = 32'b11111111_11111111_11111111_11111111; \n  ctrl = 3'b100; \n  #100; \n  data1 = 32'b11111111_11111111_11111111_11111110; \n  data2 = 32'b00000000_00000000_00000000_00000000; \n  ctrl = 3'b100; \n  #100; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a state machine for configuring a PLL ADF4158. It uses a state machine with four states to load data into the PLL registers, as well as decrements the bit and register counters. The module updates the state and control signals based on the current state, and the bit and register counters. It uses specific data patterns to set the PLL registers. The module also drives the `writeData` and `loadEnable` outputs to configure the PLL. Additionally, the `pll_clk` output is driven by the input clock signal.\n\n Module header:\n\nmodule PLL_ADF4158(input clk,input reset_n,output reg writeData,output reg loadEnable,output pll_clk);\n [/INST]\n", "output": "localparam s0 = 2'b00; \n  localparam s1 = 2'b01; \n  localparam s2 = 2'b10; \n  localparam s3 = 2'b11; \n  localparam num_registers_to_set = 8; \n  reg [31:0] writeDataArray [num_registers_to_set - 1:0]; \n  reg [31:0] current_register; \n  reg [1:0] nextState, state; \n  reg [4:0] bit_counter; \n  reg [2:0] register_counter; \n  reg dec_register_counter, dec_bit_counter; \n  assign pll_clk = clk; \n  initial begin \n  state = s0; \n  bit_counter = 31; \n  register_counter = num_registers_to_set - 1; \n  dec_register_counter = 0; \n  dec_bit_counter = 0; \n  loadEnable = 0; \n  writeDataArray[0] = 32'b1_0000_000011000110_000000000000_000; \n  writeDataArray[1] = 32'b0000_0000000000000_000000000000_001; \n  writeDataArray[2] = 32'b000_0_1111_0_1_1_0_00001_000000000001_010; \n  writeDataArray[3] = 32'b0000000000000000_1_0_00_01_0_0_0_0_0_0_0_011; \n  writeDataArray[4] = 32'b0_00000_0_11_00_11_000000000001_0000_100; \n  writeDataArray[5] = 32'b00_0_0_00_0_0_0_0000_0010010101110010_101; \n  writeDataArray[6] = 32'b00000000_0_00000011011010110000_110; \n  writeDataArray[7] = 32'b0000_0000_0000_0000_0000_0000_0000_0_111; \n  end \n  always @ (negedge clk) begin \n  if(!reset_n) begin \n  state <= s0; \n  end \n  else begin \n  state <= nextState; \n  end \n  end \n  always @(negedge clk) begin \n  if(dec_register_counter == 1) begin \n  register_counter <= register_counter - 1; \n  end \n  if(dec_bit_counter == 1) begin \n  bit_counter <= bit_counter - 1; \n  end \n  end \n  always @ * begin \n  dec_bit_counter = 0; \n  dec_register_counter = 0; \n  loadEnable = 0; \n  current_register = writeDataArray[register_counter]; \n  writeData = current_register[bit_counter]; \n  case(state) \n  s0: begin \n  dec_bit_counter = 1; \n  nextState = s1; \n  end \n  s1: begin \n  if(bit_counter == 0) begin \n  nextState = s2; \n  end else begin \n  nextState = s1; \n  dec_bit_counter = 1; \n  end \n  end \n  s2: begin \n  loadEnable = 1; \n  if(register_counter != 0) begin \n  nextState = s0; \n  dec_register_counter = 1; \n  dec_bit_counter = 1; \n  end else begin \n  nextState = s3; \n  end \n  end \n  s3: begin \n  nextState = s3; \n  end \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module is a First-In-First-Out (FIFO) buffer with a width of 16 bits and a depth of 1024. It has input ports for data, write request, and read request, as well as clock signals for writing and reading operations. There is also an asynchronous clear signal. \n\nThe module maintains two pointers for reading and writing data into the memory array. It updates the pointers based on the write and read requests and the respective clock signals. The module also handles the conditions for buffer fullness and emptiness.\n\nIn case of a read request, the module either has a register or wire for the output data, depending on the conditional compilation check. \n\nOverall, the module manages the read and write operations in a FIFO manner and handles the buffer fullness and emptiness conditions.\n\n Module header:\n\nmodule fifo( data, wrreq, rdreq, rdclk, wrclk, aclr, q,rdfull, rdempty, rdusedw, wrfull, wrempty, wrusedw);\n [/INST]\n", "output": "parameter width = 16; \n  parameter depth = 1024; \n  parameter addr_bits = 10; \n  input [width-1:0] data; \n  input wrreq; \n  input rdreq; \n  input rdclk; \n  input wrclk; \n  input aclr; \n  output [width-1:0] q; \n  output rdfull; \n  output rdempty; \n  output reg [addr_bits-1:0] rdusedw; \n  output wrfull; \n  output wrempty; \n  output reg [addr_bits-1:0] wrusedw; \n  reg [width-1:0] mem [0:depth-1]; \n  reg [addr_bits-1:0] rdptr; \n  reg [addr_bits-1:0] wrptr; \n `ifdef rd_req \n  reg [width-1:0] q; \n `else \n  wire [width-1:0] q; \n `endif \n  integer i; \n  always @( aclr) \n  begin \n  wrptr <= #1 0; \n  rdptr <= #1 0; \n  for(i=0;i<depth;i=i+1) \n  mem[i] <= #1 0; \n  end \n  always @(posedge wrclk) \n  if(wrreq) \n  begin \n  wrptr <= #1 wrptr+1; \n  mem[wrptr] <= #1 data; \n  end \n  always @(posedge rdclk) \n  if(rdreq) \n  begin \n  rdptr <= #1 rdptr+1; \n `ifdef rd_req \n  q <= #1 mem[rdptr]; \n `endif \n  end \n `ifdef rd_req \n `else \n  assign q = mem[rdptr]; \n `endif \n  always @(posedge wrclk) \n  wrusedw <= #1 wrptr - rdptr; \n  always @(posedge rdclk) \n  rdusedw <= #1 wrptr - rdptr; \n  assign wrempty = (wrusedw == 0); \n  assign wrfull = (wrusedw == depth-1); \n  assign rdempty = (rdusedw == 0); \n  assign rdfull = (rdusedw == depth-1); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a testbench for a module called \"dc_req_upload.\" It instantiates the dc_req_upload module and drives its inputs. It also monitors the outputs and logs the flit information to a file. The testbench generates the clock signal, initializes the signals, and controls the sequence of events by toggling the signals and checking the outputs at each step. It also includes a log file to record the simulation results.\n\n Module header:\n\nmodule tb_dc_req_upload();\n [/INST]\n", "output": "reg clk; \n reg rst; \n reg [47:0] dc_flits_req; \n reg v_dc_flits_req; \n reg req_fifo_rdy; \n wire [15:0] dc_flit_out; \n wire v_dc_flit_out; \n wire dc_req_upload_state; \n dc_req_upload uut (.clk(clk),.rst(rst),.dc_flits_req(dc_flits_req),.v_dc_flits_req(v_dc_flits_req),.req_fifo_rdy(req_fifo_rdy),.dc_flit_out(dc_flit_out),.v_dc_flit_out(v_dc_flit_out),.dc_req_upload_state(dc_req_upload_state)); \n integer log_file; \n  initial begin \n  clk=1'b0; \n  rst=1'b0; \n  dc_flits_req=48'h000000000000; \n  v_dc_flits_req=1'b0; \n  req_fifo_rdy=1'b0; \n  log_file=$fopen(\"log_tb_arbiter_req_upload\"); \n  end \n  always #20 clk=~clk; \n  `define clk_step #40; \n  initial begin \n  $display(\"(%t) Initializing...\", $time); \n  $fdisplay(log_file, \"(%t) Initializing...\", $time); \n  rst=1; \n  `clk_step \n  rst=0; \n  `clk_step \n  dc_flits_req=48'h123456789abc; \n  v_dc_flits_req=1'b1; \n  `clk_step \n  req_fifo_rdy=1'b0; \n  $display(\"(%t),the flit from dc_req_upload is %h and v_dc_flit_out is %b \",$time,dc_flit_out,v_dc_flit_out); \n  $fdisplay(log_file,\"(%t),the flit from dc_req_upload is %h and v_dc_flit_out is %b \",$time,dc_flit_out,v_dc_flit_out); \n  `clk_step \n  v_dc_flits_req=1'b0; \n  req_fifo_rdy=1'b1; \n  $display(\"(%t),the flit from dc_req_upload is %h and v_dc_flit_out is %b \",$time,dc_flit_out,v_dc_flit_out); \n  $fdisplay(log_file,\"(%t),the flit from dc_req_upload is %h and v_dc_flit_out is %b \",$time,dc_flit_out,v_dc_flit_out); \n  `clk_step \n  req_fifo_rdy=1'b1; \n  $display(\"(%t),the flit from dc_req_upload is %h and v_dc_flit_out is %b \",$time,dc_flit_out,v_dc_flit_out); \n  $fdisplay(log_file,\"(%t),the flit from dc_req_upload is %h and v_dc_flit_out is %b \",$time,dc_flit_out,v_dc_flit_out); \n  `clk_step \n  dc_flits_req=48'h2016c0de0330; \n  v_dc_flits_req=1'b1; \n  req_fifo_rdy=1'b0; \n  $display(\"(%t),the flit from dc_req_upload is %h and v_dc_flit_out is %b \",$time,dc_flit_out,v_dc_flit_out); \n  $fdisplay(log_file,\"(%t),the flit from dc_req_upload is %h and v_dc_flit_out is %b \",$time,dc_flit_out,v_dc_flit_out); \n  `clk_step \n  req_fifo_rdy=1'b1; \n  $display(\"(%t),the flit from dc_req_upload is %h and v_dc_flit_out is %b \",$time,dc_flit_out,v_dc_flit_out); \n  $fdisplay(log_file,\"(%t),the flit from dc_req_upload is %h and v_dc_flit_out is %b \",$time,dc_flit_out,v_dc_flit_out); \n  `clk_step \n  `clk_step \n  req_fifo_rdy=1'b1; \n  `clk_step \n  req_fifo_rdy=1'b1; \n  `clk_step \n  req_fifo_rdy=1'b0; \n  `clk_step \n  req_fifo_rdy=1'b1; \n  `clk_step \n  req_fifo_rdy=1'b1; \n  `clk_step \n  `clk_step \n  $stop; \n  end \n  endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a circuit to generate the \"for\" equivalent equations. It has two always blocks, each utilizing the \"for\" loop to assign values to the variables based on the input 'in' and control the flow of the logic. The module uses reg and input declarations to define the variables and inputs for the circuit. The for loop within the always block is used to control the assignment of values to the variables 'a', 'b', and 'c' based on the input 'in'. The \"for\" loop is used to iterate and assign values to the variables within the specified conditions.\n\n Module header:\n\nmodule foreqn (in);\n [/INST]\n", "output": "input [1:0] in; \n  reg a,b; \n  reg [1:0] c; \n  always for ({a,c[0]} = in; a < 1'b1; {b,c[1]} = in) begin \n  end \n  always for ({a,c[in]} = 0; a < 1'b1; {b,c[in]} = 2'b10) begin \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, eth_fifo_8, implements an Ethernet FIFO with full-duplex capabilities. It interfaces with the TX and RX sides of an Ethernet transceiver. The module includes control signals such as tx_enable, tx_ack, tx_collision, tx_retransmit, rx_enable, tx_reset, rx_reset, and various other inputs and outputs to handle the transmission and reception of Ethernet frames. Additionally, the module contains two instances of a client FIFO module, one for the TX side and one for the RX side, to manage the data flow and status of the FIFOs. The TX FIFO client uses the tx_ll_* signals to interface with the TX FIFO module, while the RX FIFO client uses the rx_ll_* signals to interface with the RX FIFO module.\n\n Module header:\n\nmodule eth_fifo_8 (tx_clk,tx_reset,tx_enable,tx_data,tx_data_valid,tx_ack,tx_underrun,tx_collision,tx_retransmit,tx_ll_clock,tx_ll_reset,tx_ll_data_in,tx_ll_sof_in_n,tx_ll_eof_in_n,tx_ll_src_rdy_in_n,tx_ll_dst_rdy_out_n,tx_fifo_status,tx_overflow,rx_clk,rx_reset,rx_enable,rx_data,rx_data_valid,rx_good_frame,rx_bad_frame,rx_overflow,rx_ll_clock,rx_ll_reset,rx_ll_data_out,rx_ll_sof_out_n,rx_ll_eof_out_n,rx_ll_src_rdy_out_n,rx_ll_dst_rdy_in_n,rx_fifo_status);\n [/INST]\n", "output": "parameter FULL_DUPLEX_ONLY = 0; \n  input tx_clk; \n  input tx_reset; \n  input tx_enable; \n  output [7:0] tx_data; \n  output tx_data_valid; \n  input tx_ack; \n  output tx_underrun; \n  input tx_collision; \n  input tx_retransmit; \n  input tx_ll_clock; \n  input tx_ll_reset; \n  input [7:0] tx_ll_data_in; \n  input tx_ll_sof_in_n; \n  input tx_ll_eof_in_n; \n  input tx_ll_src_rdy_in_n; \n  output tx_ll_dst_rdy_out_n; \n  output [3:0] tx_fifo_status; \n  output tx_overflow; \n  input rx_clk; \n  input rx_reset; \n  input rx_enable; \n  input [7:0] rx_data; \n  input rx_data_valid; \n  input rx_good_frame; \n  input rx_bad_frame; \n  output rx_overflow; \n  input rx_ll_clock; \n  input rx_ll_reset; \n  output [7:0] rx_ll_data_out; \n  output rx_ll_sof_out_n; \n  output rx_ll_eof_out_n; \n  output rx_ll_src_rdy_out_n; \n  input rx_ll_dst_rdy_in_n; \n  output [3:0] rx_fifo_status; \n  assign tx_underrun = 1'b0; \n tx_client_fifo_8 #(.FULL_DUPLEX_ONLY (FULL_DUPLEX_ONLY)) \n tx_fifo_i (.rd_clk (tx_clk),.rd_sreset (tx_reset),.rd_enable (tx_enable),.tx_data (tx_data),.tx_data_valid (tx_data_valid),.tx_ack (tx_ack),.tx_collision (tx_collision),.tx_retransmit (tx_retransmit),.overflow (tx_overflow),.wr_clk (tx_ll_clock),.wr_sreset (tx_ll_reset),.wr_data (tx_ll_data_in),.wr_sof_n (tx_ll_sof_in_n),.wr_eof_n (tx_ll_eof_in_n),.wr_src_rdy_n (tx_ll_src_rdy_in_n),.wr_dst_rdy_n (tx_ll_dst_rdy_out_n),.wr_fifo_status (tx_fifo_status)); \n rx_client_fifo_8 rx_fifo_i (.wr_clk (rx_clk),.wr_enable (rx_enable),.wr_sreset (rx_reset),.rx_data (rx_data),.rx_data_valid (rx_data_valid),.rx_good_frame (rx_good_frame),.rx_bad_frame (rx_bad_frame),.overflow (rx_overflow),.rd_clk (rx_ll_clock),.rd_sreset (rx_ll_reset),.rd_data_out (rx_ll_data_out),.rd_sof_n (rx_ll_sof_out_n),.rd_eof_n (rx_ll_eof_out_n),.rd_src_rdy_n (rx_ll_src_rdy_out_n),.rd_dst_rdy_n (rx_ll_dst_rdy_in_n),.rx_fifo_status (rx_fifo_status)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, \"BranchAdder,\" takes two 32-bit input values, pc_plus_four, and extended_times_four, and generates a 32-bit output, branch_address, which is the sum of the two input values.\n\n Module header:\n\nmodule BranchAdder (input wire [31:0] pc_plus_four,input wire [31:0] extended_times_four,output wire [31:0] branch_address);\n [/INST]\n", "output": "assign branch_address = pc_plus_four + extended_times_four; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a 16x8 dual-port RAM with synchronous read and write operations. The module has two 4-bit address inputs A and DPRA, an 8-bit data input D, and control signals WCLK and WE. When the write enable signal WE is asserted on the rising edge of the clock WCLK, the data at address A is updated with the input D. The module also has two 8-bit data outputs, DPO and SPO, which provide the data at addresses DPRA and A, respectively.\n\n Module header:\n\nmodule RAM16X8D_regs(output [7:0]DPO,output [7:0]SPO,input [3:0]A,input [7:0]D,input [3:0]DPRA,input WCLK,input WE);\n [/INST]\n", "output": "reg [7:0]data[15:0]; \n  assign DPO = data[DPRA]; \n  assign SPO = data[A]; \n  always @(posedge WCLK) \n  if(WE) data[A] <= D; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a register file that allows for reading from and writing to 31 registers. It has read and write ports and a clock input for synchronous operation. The module updates the registers on the rising edge of the clock when a write request is made. Additionally, it reads data from the specified read addresses and assigns it to the corresponding output ports. If the read address is 0, the module outputs 32'h0000_0000.\n\n Module header:\n\nmodule ada_reg_file(input clk,input [4:0] read_addr_a,input [4:0] read_addr_b,input [4:0] write_addr,input [31:0] write_data,input we,output [31:0] read_data_a,output [31:0] read_data_b);\n [/INST]\n", "output": "reg [31:0] registers [1:31]; \n  always @(posedge clk) begin \n  if (write_addr != 0) \n  registers[write_addr] <= (we) ? write_data : registers[write_addr]; \n  end \n  assign read_data_a = (read_addr_a == 5'b0) ? 32'h0000_0000 : registers[read_addr_a]; \n  assign read_data_b = (read_addr_b == 5'b0) ? 32'h0000_0000 : registers[read_addr_b]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a GPIO controller. It handles input and output operations for general-purpose input and output (GPIO) pins. It has input and output ports for data, control signals, and the actual GPIO signals. The module can read data from specific addresses and write data to GPIO pins based on control signals and data input. It also allows for setting the direction (input or output) of each GPIO pin. The module incorporates logic for handling resets and updates to the GPIO values. It functions as an interface between the processor and the GPIO pins.\n\n Module header:\n\nmodule mod_gpio(rst, clk, ie, de, iaddr, daddr, drw, din, iout, dout, gpio);\n [/INST]\n", "output": "input rst; \n  input clk; \n  input ie,de; \n  input [31:0] iaddr, daddr; \n  input [1:0] drw; \n  input [31:0] din; \n  output [31:0] iout, dout; \n  inout [15:0] gpio; \n  wire [31:0] idata, ddata; \n  assign iout = idata; \n  assign dout = ddata; \n  reg [15:0] direction = 16'h0000; \n  reg [7:0] gpio_a, gpio_b; \n  assign idata = 32'h00000000; \n  assign ddata = (daddr == 32'h00000000) ? {16'h0000, direction} : \n  (daddr == 32'h00000004) ? {24'h000000, gpio[7:0]} : \n  (daddr == 32'h00000008) ? {24'h000000, gpio[15:8]} : 0; \n  assign gpio[0] = (direction[0]) ? gpio_a[0] : 1'bz; \n  assign gpio[1] = (direction[1]) ? gpio_a[1] : 1'bz; \n  assign gpio[2] = (direction[2]) ? gpio_a[2] : 1'bz; \n  assign gpio[3] = (direction[3]) ? gpio_a[3] : 1'bz; \n  assign gpio[4] = (direction[4]) ? gpio_a[4] : 1'bz; \n  assign gpio[5] = (direction[5]) ? gpio_a[5] : 1'bz; \n  assign gpio[6] = (direction[6]) ? gpio_a[6] : 1'bz; \n  assign gpio[7] = (direction[7]) ? gpio_a[7] : 1'bz; \n  assign gpio[8] = (direction[8]) ? gpio_b[0] : 1'bz; \n  assign gpio[9] = (direction[9]) ? gpio_b[1] : 1'bz; \n  assign gpio[10] = (direction[10]) ? gpio_b[2] : 1'bz; \n  assign gpio[11] = (direction[11]) ? gpio_b[3] : 1'bz; \n  assign gpio[12] = (direction[12]) ? gpio_b[4] : 1'bz; \n  assign gpio[13] = (direction[13]) ? gpio_b[5] : 1'bz; \n  assign gpio[14] = (direction[14]) ? gpio_b[6] : 1'bz; \n  assign gpio[15] = (direction[15]) ? gpio_b[7] : 1'bz; \n  always @(negedge clk) begin \n  if (drw[0] && de && !rst) begin \n  if (daddr == 32'h00000000) \n  direction <= din[15:0]; \n  else if (daddr == 32'h00000004) \n  gpio_a <= din[7:0]; \n  else if (daddr == 32'h00000008) \n  gpio_b <= din[7:0]; \n  end else if (rst) begin \n  gpio_a <= 8'h00; \n  gpio_b <= 8'h00; \n  direction <= 16'h0000; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module represents an input pad for power management. It assigns the input `P_PAD` to the output `P_CORE` and connects various input and output pads for different power management functions, including voltage supplies and body connections. The module essentially acts as an interface for managing power-related signals within an integrated circuit design.\n\n Module header:\n\nmodule sky130_fd_io__top_power_lvc_wpad ( P_PAD, AMUXBUS_A, AMUXBUS_B, P_CORE, BDY2_B2B, DRN_LVC1, DRN_LVC2, OGC_LVC, SRC_BDY_LVC1, SRC_BDY_LVC2, VSSA, VDDA, VSWITCH, VDDIO_Q, VCCHIB, VDDIO, VCCD, VSSIO, VSSD, VSSIO_Q);\n [/INST]\n", "output": "inout P_PAD; \n inout AMUXBUS_A; \n inout AMUXBUS_B; \n inout SRC_BDY_LVC1; \n inout SRC_BDY_LVC2; \n inout OGC_LVC; \n inout DRN_LVC1; \n inout BDY2_B2B; \n inout DRN_LVC2; \n inout P_CORE; \n inout VDDIO; \n inout VDDIO_Q; \n inout VDDA; \n inout VCCD; \n inout VSWITCH; \n inout VCCHIB; \n inout VSSA; \n inout VSSD; \n inout VSSIO_Q; \n inout VSSIO; \n assign P_CORE = P_PAD; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module is a part of the ChaCha20-Poly1305 encryption algorithm. It consists of several registers and control signals to perform the Poly1305 authentication part of the algorithm. The module includes registers for the round, sector, and accumulator values, as well as control registers for the Poly1305 algorithm. It uses the provided signals to initialize, process, and control the Poly1305 algorithm. The module also handles the encryption and decryption of data using the Poly1305 algorithm.\n\n Module header:\n\nmodule chacha20_poly1305_p1305(input wire clk,input wire reset_n,input wire init,input wire next,input wire done,input wire [255 : 0] key,output wire [127 : 0] tag);\n [/INST]\n", "output": "localparam R_CLAMP = 128'h0ffffffc0ffffffc0ffffffc0fffffff; \n  localparam POLY1305 = 129'h3fffffffffffffffffffffffffffffffb; \n  reg [127 : 0] r_reg; \n  reg [127 : 0] r_new; \n  reg r_we; \n  reg [127 : 0] s_reg; \n  reg [127 : 0] s_new; \n  reg s_we; \n  reg [255 : 0] acc_reg; \n  reg [255 : 0] acc_new; \n  reg acc_we; \n  reg [2 : 0] p1305_ctrl_reg; \n  reg [2 : 0] p1305_ctrl_new; \n  reg p1305_ctrl_we; \n  always @ (posedge clk) \n  begin \n  if (!reset_n) \n  begin \n  r_reg <= 128'h0; \n  s_reg <= 128'h0; \n  acc_reg <= 256'h0; \n  p1305_ctrl_reg <= CTRL_IDLE; \n  end \n  else \n  begin \n  if (r_we) \n  r_reg <= r_new; \n  if (s_we) \n  s_reg <= s_new; \n  if (acc_we) \n  acc_reg <= acc_new; \n  if (p1305_ctrl_we) \n  p1305_ctrl_reg <= p1305_ctrl_new; \n  end \n  end \n  always @* \n  begin : poly1305_dp \n  reg [512 : 0] block; \n  acc_new = 256'h0; \n  acc_we = 0; \n  r_new = data_out[255 : 128] & R_CLAMP; \n  r_we = 0; \n  s_new = data_out[127 : 000]; \n  s_we = 0; \n  if (poly1305_init) \n  begin \n  r_we = 1; \n  s_we = 1; \n  acc_we = 1; \n  end \n  if (poly1305_next) \n  begin \n  if (encdec) \n  block = {1'h1, data_out}; \n  else \n  block = {1'h1, data_in}; \n  acc_new = ((acc_reg + block) * r_reg) % POLY1305; \n  acc_we = 1; \n  end \n  end \n  always @* \n  begin : p1305_ctrl \n  p1305_ctrl_new = CTRL_IDLE; \n  p1305_ctrl_we = 0; \n  case (p1305_ctrl_reg) \n  CTRL_IDLE: \n  begin \n  end \n  default: \n  begin \n  end \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a Wishbone bus arbiter for coordinating data transfers among multiple masters and a single slave. It uses a round-robin arbitration scheme to grant access to the masters. The arbiter prioritizes and selects the active master, determines the address, data, and control signals for the selected master, and routes the corresponding signals to the slave. The module also handles acknowledgment, error, and retry signals to ensure proper communication between the masters and the slave.\n\n Module header:\n\nmodule wb_arbiter #(parameter dw = 32,parameter aw = 32,parameter num_masters = 2) (input wb_clk_i,input wb_rst_i,input [num_masters*aw-1:0] wbm_adr_i,input [num_masters*dw-1:0] wbm_dat_i,input [num_masters*4-1:0] wbm_sel_i,input [num_masters-1:0] wbm_we_i,input [num_masters-1:0] wbm_cyc_i,input [num_masters-1:0] wbm_stb_i,input [num_masters*3-1:0] wbm_cti_i,input [num_masters*2-1:0] wbm_bte_i,output [num_masters*dw-1:0] wbm_dat_o,output [num_masters-1:0] wbm_ack_o,output [num_masters-1:0] wbm_err_o,output [num_masters-1:0] wbm_rty_o,output [aw-1:0] wbs_adr_o,output [dw-1:0] wbs_dat_o,output [3:0] wbs_sel_o,output wbs_we_o,output wbs_cyc_o,output wbs_stb_o,output [2:0] wbs_cti_o,output [1:0] wbs_bte_o,input [dw-1:0] wbs_dat_i,input wbs_ack_i,input wbs_err_i,input wbs_rty_i);\n [/INST]\n", "output": "localparam master_sel_bits = num_masters > 1 ? `clog2(num_masters) : 1; \n  wire [num_masters-1:0] grant; \n  wire [master_sel_bits-1:0] master_sel; \n  wire active; \n  arbiter \n  #(.NUM_PORTS (num_masters)) \n  arbiter0 \n (.clk (wb_clk_i),.rst (wb_rst_i),.request (wbm_cyc_i),.grant (grant),.active (active)); \n  assign master_sel = ff1(grant, num_masters); \n  assign wbs_adr_o = wbm_adr_i[master_sel*aw+:aw]; \n  assign wbs_dat_o = wbm_dat_i[master_sel*dw+:dw]; \n  assign wbs_sel_o = wbm_sel_i[master_sel*4+:4]; \n  assign wbs_we_o = wbm_we_i [master_sel]; \n  assign wbs_cyc_o = wbm_cyc_i[master_sel] & active; \n  assign wbs_stb_o = wbm_stb_i[master_sel]; \n  assign wbs_cti_o = wbm_cti_i[master_sel*3+:3]; \n  assign wbs_bte_o = wbm_bte_i[master_sel*2+:2]; \n  assign wbm_dat_o = {num_masters{wbs_dat_i}}; \n  assign wbm_ack_o = ((wbs_ack_i & active) << master_sel); \n  assign wbm_err_o = ((wbs_err_i & active) << master_sel); \n  assign wbm_rty_o = ((wbs_rty_i & active) << master_sel); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a simple interface for a 32-bit Wishbone bus. It has inputs for reset signal, clock signal, data input, write enable, byte select, and strobe, and outputs for data output, acknowledge, and port output. The module updates an internal register based on the input signals and provides the updated register value as output. It also provides the acknowledge signal based on the strobe input.\n\n Module header:\n\nmodule wb_output_pins32 (wb_rst_i, wb_clk_i, wb_dat_i, wb_dat_o,wb_we_i, wb_sel_i, wb_stb_i, wb_ack_o, wb_cyc_i,port_output);\n [/INST]\n", "output": "input wb_rst_i; \n  input wb_clk_i; \n  input wire [31:0] wb_dat_i; \n  output wire [31:0] wb_dat_o; \n  input wb_we_i; \n  input wire [3:0] wb_sel_i; \n  input wb_stb_i; \n  output wb_ack_o; \n  input wb_cyc_i; \n  output wire [31:0] port_output; \n  reg [31:0] internal_reg; \n  always @(posedge wb_clk_i) \n  if(wb_rst_i) \n  internal_reg <= #1 32'b0; \n  else \n  begin \n  if(wb_stb_i & wb_we_i & wb_sel_i[0]) \n  internal_reg[7:0] <= #1 wb_dat_i[7:0]; \n  if(wb_stb_i & wb_we_i & wb_sel_i[1]) \n  internal_reg[15:8] <= #1 wb_dat_i[15:8]; \n  if(wb_stb_i & wb_we_i & wb_sel_i[2]) \n  internal_reg[23:16] <= #1 wb_dat_i[23:16]; \n  if(wb_stb_i & wb_we_i & wb_sel_i[3]) \n  internal_reg[31:24] <= #1 wb_dat_i[31:24]; \n  end \n  assign wb_dat_o = internal_reg; \n  assign port_output = internal_reg; \n  assign wb_ack_o = wb_stb_i; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module represents a grid-based game logic. It includes a grid of blocks, a counter, and various logic to manipulate the grid based on input signals such as clock, reset, and enable. The module shifts and manipulates the grid based on the input signals and updates the grid and other outputs accordingly. It also includes logic for overlaying rows on the graphics clock signal. Overall, the module implements the game grid's behavior and updates it based on the input signals.\n\n Module header:\n\nmodule grid(input clk, input gfx_clk, input[4:0] row, input[3:0] col, input[2:0] type, input[1:0] rot,output reg[0:13] d, output reg[0:13] d_vga, input[4:0] addr_row, input[4:0] addr_row_vga,input en, output reg[2:0] n_lines, input rst, output ready);\n [/INST]\n", "output": "reg[0:13] grid[0:19]; \n reg[2:0] count; \n wire[0:15] block; \n wire[0:13] block_row[0:3]; \n assign block_row[0] = {block[0:3], 10'b0000000000}; \n assign block_row[1] = {block[4:7], 10'b0000000000}; \n assign block_row[2] = {block[8:11], 10'b0000000000}; \n assign block_row[3] = {block[12:15], 10'b0000000000}; \n assign ready = count == 4; \n JIZLOTS_sel write(type, rot, block); \n reg[4:0] i; \n always @(posedge clk) \n begin \n  i = 0; \n  if(en == 1) begin \n  for(i = 0; i < 4; i = i+5'd1) begin \n  if(col != 15) \n  grid[row+i] <= (block_row[i] >> col) | grid[row+i]; \n  else \n  grid[row+i] <= (block_row[i] << 1) | grid[row+i]; \n  end \n  end \n  if(count < 4) begin \n  if(grid[row+count] == 14'b11111111111111) begin \n  n_lines <= n_lines + 3'd1; \n  for(i = 5'd20; i > 0; i = i-5'd1) \n  if(i-1 <= row+count) \n  if(i-1 > 0) \n  grid[i-5'd1] <= grid[i-5'd2]; \n  else \n  grid[i-5'd1] <= 0; \n  end \n  end \n  if(en) \n  n_lines <= 0; \n  if(rst) begin \n  for(i = 0; i < 20; i = i+5'd1) \n  grid[i] <= 0; \n  n_lines <= 0; \n  end \n end \n always @(posedge clk) \n begin \n  if(en) \n  count <= 0; \n  if(count < 5) \n  count <= count+3'd1; \n  if(rst) begin \n  count <= 3'd5; \n  end \n end \n always @(posedge clk) \n  d <= grid[addr_row]; \n wire[0:13] row_overlay = col != 15 ? (block_row[addr_row_vga-row] >> col) : (block_row[addr_row_vga-row] << 1); \n always @(posedge gfx_clk) \n begin \n  if(addr_row_vga >= row && addr_row_vga < row+4) \n  d_vga <= grid[addr_row_vga] | row_overlay; \n  else \n  d_vga <= grid[addr_row_vga]; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, named mult_add, performs a multiplication and addition operation. It takes three 32-bit inputs A, B, and C, and has two 32-bit outputs, mult_result and add_result. The module utilizes floating-point multiplication and addition operations to compute the results. The module contains registers to store the multiplication and addition results, as well as wires for intermediate computations. The multiplication result is right-shifted by 2 bits and stored in dummy_wire. The floating-point multiplication and addition operations are triggered by the positive edge of the clk input. The final multiplication and addition results are then assigned to the mult_result and add_result outputs, respectively.\n\n Module header:\n\nmodule mult_add (clk, A, B, C, mult_result, add_result);\n [/INST]\n", "output": "input clk; \n input [32-1:0] A, B, C; \n output [32-1:0] mult_result, add_result; \n reg [32-1:0] mult_result; \n reg [32-1:0] add_result; \n wire [32-1:0] mult_comp_result; \n reg [32-1:0] add_a, add_b; \n wire [32-1:0] addition_result; \n wire [31:0] dummy_wire; \n assign dummy_wire = mult_comp_result>>2'b10; \n wire [4:0]dummy_wire_2; \n fpmul MUL(.clk(clk), .a(A), .b(B), .y_out(mult_comp_result), .control(2'b00), .flags(dummy_wire_2)); \n fpu_add ADD(.clock(clk), .a1(C), .b1(dummy_wire), .sum(addition_result)); \n always @ (posedge clk) \n begin \n  add_result <= addition_result; \n  mult_result <= mult_comp_result[31:0]; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a testbench for the sdm_adc_data_aurora_recv module. It initializes and toggles the clock and user clock signals, as well as the reset signal. It also manages the axi_rx_tdata and axi_rx_tvalid signals. When the reset is active, it sets the initial values for the counters and data. When the reset is not active, it increments the counters and data according to specific conditions. Finally, it resets the axi_rx_tvalid signal under certain conditions.\n\n Module header:\n\nmodule sdm_adc_data_aurora_recv_tb #(parameter NCH_ADC = 20,parameter ADC_CYC = 20,parameter NCH_SDM = 19,parameter SDM_CYC = 4) ();\n [/INST]\n", "output": "reg reset; \n  reg clk; \n  wire [511:0] dout; \n  wire dout_valid; \n  reg user_clk; \n  reg [63:0] axi_rx_tdata; \n  reg axi_rx_tvalid; \n  wire fifo_full; \n  sdm_adc_data_aurora_recv \n #(.NCH_ADC(NCH_ADC),.ADC_CYC(ADC_CYC),.NCH_SDM(NCH_SDM),.SDM_CYC(SDM_CYC)) \n  sdm_adc_data_aurora_recv_tb_inst \n (.RESET(reset),.CLK(clk),.USER_CLK(user_clk),.M_AXI_RX_TDATA(axi_rx_tdata),.M_AXI_RX_TVALID(axi_rx_tvalid),.DOUT(dout),.DOUT_VALID(dout_valid),.FIFO_FULL(fifo_full)); \n  initial begin \n  clk = 0; \n  reset = 0; \n  #16 reset = 1; \n  #36 reset = 0; \n  end \n  always #5 clk = ~clk; \n  initial begin \n  user_clk = 0; \n  end \n  always #2.5 user_clk = ~user_clk; \n  reg [4:0] cnt, cnt1; \n  always @ (posedge user_clk or posedge reset) begin \n  if (reset) begin \n  cnt <= 4; \n  cnt1 <= 0; \n  axi_rx_tdata <= 64'h0123456789abcdef; \n  axi_rx_tvalid <= 0; \n  end \n  else begin \n  cnt1 <= cnt1 + 1; \n  if (axi_rx_tvalid) begin \n  cnt <= cnt + 1; \n  axi_rx_tdata <= axi_rx_tdata + 1; \n  axi_rx_tdata[63] <= 1'b0; \n  if (cnt == 8) begin \n  axi_rx_tdata[63] <= 1'b1; \n  cnt <= 0; \n  end \n  end \n  axi_rx_tvalid <= 1; \n  if (cnt1 == 0) begin \n  axi_rx_tvalid <= 0; \n  end \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a hub core with a specified number of slave units. It interfaces with these slave units through new nonces and slave nonces signals. The module maintains a port counter and a new nonces flag to manage the communication with the slave units. When the hash clock signal toggles, the module updates the new nonces flag and shifts the slave nonces data based on the port counter. It also controls the serial send signal and maintains a golden nonce output based on the shifted slave nonces.\n\n Module header:\n\nmodule hub_core (hash_clk, new_nonces, golden_nonce, serial_send, serial_busy, slave_nonces);\n [/INST]\n", "output": "parameter SLAVES = 2; \n  input hash_clk; \n  input [SLAVES-1:0] new_nonces; \n  input [SLAVES*32-1:0] slave_nonces; \n  output [31:0] golden_nonce; \n  output serial_send; \n  input serial_busy; \n  reg serial_send_reg; \n  assign serial_send = serial_send_reg; \n  reg [SLAVES-1:0] new_nonces_flag = 0; \n  reg [$clog2(SLAVES)+1:0] port_counter = 0; \n  reg [SLAVES*32-1:0] slave_nonces_shifted; \n  assign golden_nonce = slave_nonces_shifted[31:0]; \n  reg [SLAVES-1:0] clear_nonces; \n  always @(posedge hash_clk) \n  begin \n  new_nonces_flag <= (new_nonces_flag & ~clear_nonces) | new_nonces; \n  if (port_counter == SLAVES-1) \n  port_counter <= 0; \n  else \n  port_counter <= port_counter + 1; \n  if (!serial_busy && new_nonces_flag[port_counter]) \n  begin \n  slave_nonces_shifted <= slave_nonces >> port_counter*32; \n  serial_send_reg <= 1; \n  clear_nonces[port_counter] <= 1; \n  end \n  else \n  begin \n  serial_send_reg <= 0; \n  clear_nonces <= 0; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module uut_1_bytep takes input data and a start-of-frame signal and processes them using internal registers and wire assignments. It stores the input data and start-of-frame signal in internal registers, and then outputs the processed data and the start-of-frame signal. The output data is a concatenation of the processed data from the internal registers. The processing is synchronized to the positive edge of the pclk_i signal.\n\n Module header:\n\nmodule uut_1_bytep (output wire [31:0] data_o,output wire sof_o,input wire [7:0] data_i,input wire sof_i,input wire pclk_i);\n [/INST]\n", "output": "reg [7:0] data_z1; \n  reg sof_z1; \n  reg [7:0] data_z2; \n  reg sof_z2; \n  reg [7:0] data_z3; \n  reg sof_z3; \n  reg [7:0] data_z4; \n  reg sof_z4; \n  always @ (posedge pclk_i) begin \n  data_z1[7:0] <= data_i[7:0]; \n  sof_z1 <= sof_i; \n  data_z2[7:0] <= data_z1[7:0]; \n  sof_z2 <= sof_z1; \n  data_z3[7:0] <= data_z2[7:0]; \n  sof_z3 <= sof_z2; \n  data_z4[7:0] <= data_z3[7:0]; \n  sof_z4 <= sof_z3; \n  end \n  always @ (*) \n  begin \n  data_o[31:0] = {data_z4[7:0], data_z3[7:0], data_z2[7:0], data_z1[7:0]}; \n  sof_o = sof_z4; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a 16x16 multiplier using Look-Up Tables (LUTs) to perform the multiplication in parallel. The input wires A and B each have 16 bits, and the output wire Result holds the 32-bit product. The LUTs are instantiated for each pair of bits in the B input, and the 16-bit products are stored in wResInt1 to wResInt8. These intermediate results are then concatenated and added together to produce the final 32-bit product assigned to the Result output wire.\n\n Module header:\n\nmodule Mult16x16 (input wire [15:0] A,input wire [15:0] B,output wire [31:0] Result);\n [/INST]\n", "output": "wire [17:0] wResInt1,wResInt2,wResInt3,wResInt4,wResInt5,wResInt6,wResInt7,wResInt8; \n LUT # ( 16 ) LUT1 \n (.A(A),.B(B[1:0]),.Result(wResInt1)); \n LUT # ( 16 ) LUT2 \n (.A(A),.B(B[3:2]),.Result(wResInt2)); \n LUT # ( 16 ) LUT3 \n (.A(A),.B(B[5:4]),.Result(wResInt3)); \n LUT # ( 16 ) LUT4 \n (.A(A),.B(B[7:6]),.Result(wResInt4)); \n LUT # ( 16 ) LUT5 \n (.A(A),.B(B[9:8]),.Result(wResInt5)); \n LUT # ( 16 ) LUT6 \n (.A(A),.B(B[11:10]),.Result(wResInt6)); \n LUT # ( 16 ) LUT7 \n (.A(A),.B(B[13:12]),.Result(wResInt7)); \n LUT # ( 16 ) LUT8 \n (.A(A),.B(B[15:14]),.Result(wResInt8)); \n assign Result = ({wResInt8, 14'b0} + {2'b0, wResInt7, 12'b0}+ {4'b0, wResInt6, 10'b0} + {6'b0, wResInt5, 8'b0}+ {8'b0, wResInt4, 6'b0} + {8'b0, wResInt3, 4'b0}+ {10'b0, wResInt2, 2'b0} + {14'b0, wResInt1}); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"flow_ctrl\" implements a flow control mechanism for data transmission. It includes features such as XOFF and XON generation, pause quanta handling, and delay logic for various signals. The module uses registers to store delayed versions of input signals and uses these to control the generation of XOFF and XON signals, as well as to apply pause quanta for data transmission. The module also manages the reset and clock signals to ensure proper operation of the flow control mechanism.\n\n Module header:\n\nmodule flow_ctrl (Reset ,Clk ,tx_pause_en ,xoff_cpu ,xon_cpu ,pause_quanta ,pause_quanta_val ,pause_apply ,pause_quanta_sub ,xoff_gen ,xoff_gen_complete ,xon_gen ,xon_gen_complete);\n [/INST]\n", "output": "input Reset ; \n input Clk ; \n input tx_pause_en ; \n input xoff_cpu ; \n input xon_cpu ; \n input [15:0] pause_quanta ; \n input pause_quanta_val ; \n output pause_apply ; \n input pause_quanta_sub ; \n output xoff_gen ; \n input xoff_gen_complete ; \n output xon_gen ; \n input xon_gen_complete ; \n reg xoff_cpu_dl1 ; \n reg xoff_cpu_dl2 ; \n reg xon_cpu_dl1 ; \n reg xon_cpu_dl2 ; \n reg [15:0] pause_quanta_dl1 ; \n reg pause_quanta_val_dl1 ; \n reg pause_quanta_val_dl2 ; \n reg pause_apply ; \n reg xoff_gen ; \n reg xon_gen ; \n reg [15:0] pause_quanta_counter ; \n reg tx_pause_en_dl1 ; \n reg tx_pause_en_dl2 ; \n always @ (posedge Clk or posedge Reset) \n  if (Reset) \n  begin \n  xoff_cpu_dl1 <=0; \n  xoff_cpu_dl2 <=0; \n  end \n  else \n  begin \n  xoff_cpu_dl1 <=xoff_cpu; \n  xoff_cpu_dl2 <=xoff_cpu_dl1; \n  end \n always @ (posedge Clk or posedge Reset) \n  if (Reset) \n  begin \n  xon_cpu_dl1 <=0; \n  xon_cpu_dl2 <=0; \n  end \n  else \n  begin \n  xon_cpu_dl1 <=xon_cpu; \n  xon_cpu_dl2 <=xon_cpu_dl1; \n  end \n always @ (posedge Clk or posedge Reset) \n  if (Reset) \n  begin \n  pause_quanta_dl1 <=0; \n  end \n  else \n  begin \n  pause_quanta_dl1 <=pause_quanta; \n  end \n always @ (posedge Clk or posedge Reset) \n  if (Reset) \n  begin \n  pause_quanta_val_dl1 <=0; \n  pause_quanta_val_dl2 <=0; \n  end \n  else \n  begin \n  pause_quanta_val_dl1 <=pause_quanta_val; \n  pause_quanta_val_dl2 <=pause_quanta_val_dl1; \n  end \n always @ (posedge Clk or posedge Reset) \n  if (Reset) \n  begin \n  tx_pause_en_dl1 <=0; \n  tx_pause_en_dl2 <=0; \n  end \n  else \n  begin \n  tx_pause_en_dl1 <=tx_pause_en; \n  tx_pause_en_dl2 <=tx_pause_en_dl1; \n  end \n always @ (posedge Clk or posedge Reset) \n  if (Reset) \n  xoff_gen <=0; \n  else if (xoff_gen_complete) \n  xoff_gen <=0; \n  else if (xoff_cpu_dl1&&!xoff_cpu_dl2) \n  xoff_gen <=1; \n always @ (posedge Clk or posedge Reset) \n  if (Reset) \n  xon_gen <=0; \n  else if (xon_gen_complete) \n  xon_gen <=0; \n  else if (xon_cpu_dl1&&!xon_cpu_dl2) \n  xon_gen <=1; \n always @ (posedge Clk or posedge Reset) \n  if (Reset) \n  pause_quanta_counter <=0; \n  else if(pause_quanta_val_dl1&&!pause_quanta_val_dl2) \n  pause_quanta_counter <=pause_quanta_dl1; \n  else if(pause_quanta_sub&&pause_quanta_counter!=0) \n  pause_quanta_counter <=pause_quanta_counter-1; \n always @ (posedge Clk or posedge Reset) \n  if (Reset) \n  pause_apply <=0; \n  else if(pause_quanta_counter==0) \n  pause_apply <=0; \n  else if (tx_pause_en_dl2) \n  pause_apply <=1; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a synchronous ROM (Read-Only Memory) with configurable address and data widths. It stores data in a memory array and outputs the data corresponding to the input address when both the read enable (ren) and the chip enable (cen) signals are asserted. The data from the ROM is available on the src_data output. The memory is initialized from a file specified by `ROM_FILE` using the $readmemh() function. The ROM uses the \"M9K\" memory style for implementation, and it resets the data output to zero at the beginning.\n\n Module header:\n\nmodule sp_rom #(parameter ADDRESS_WIDTH = 16,parameter DATA_WIDTH = 16)(clk,address,data,ren,cen);\n [/INST]\n", "output": "input clk; \n input [ADDRESS_WIDTH-1:0] sink_address; \n output [DATA_WIDTH-1:0] src_data; \n input sink_ren, sink_cen; \n (* romstyle = \"M9K\" *) reg [DATA_WIDTH-1:0] mem [0:(2**ADDRESS_WIDTH)-1] ; \n reg [DATA_WIDTH-1:0] src_data; \n reg [8*40:1] infile; \n initial \n begin \n  $readmemh(`ROM_FILE, mem); \n  data = {DATA_WIDTH{1'b0}}; \n end \n always @ (posedge clk) \n begin \n  if (cen && ren) \n  data <= mem[address]; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a 2K character RAM for a VDU. It has inputs for clock, reset, write enable, address, and write data, as well as an output for read data. The module contains a memory array, an address register, and an always block that updates the memory based on the write enable signal and stores the address in the address register. The read data is assigned based on the address register. Additionally, the memory is initialized with data from a file called \"buff_rom.dat\" during simulation.\n\n Module header:\n\nmodule vdu_ram_2k_char (input clk,input rst,input we,input [10:0] addr,output [ 7:0] rdata,input [ 7:0] wdata);\n [/INST]\n", "output": "reg [ 7:0] mem[0:2047]; \n  reg [10:0] addr_reg; \n  always @(posedge clk) \n  begin \n  if (we) mem[addr] <= wdata; \n  addr_reg <= addr; \n  end \n  assign rdata = mem[addr_reg]; \n  initial $readmemh(\"buff_rom.dat\", mem); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a Wishbone master module that initiates read and write transactions on a bus. It utilizes a state machine to handle the various stages of the transactions. The module is parameterized and contains registers to store data and control signals. It initializes data and control signals on reset and transitions between states based on the state machine logic. The module also checks for acknowledgments and compares data. If an error is detected, it stops the simulation.\n\n Module header:\n\nmodule wb_master #(parameter BASE_ADDRESS = 0,parameter DATA_WIDTH = 16,parameter ADDR_WIDTH = 16,parameter DATA_COUNT = 16,parameter AU_IN_DATA = 1)(input clk,input rst,input start,output reg done,output reg cyc_o,output reg stb_o,input ack_i,output reg we_o,output reg [DATA_WIDTH-1:0] dat_o,input [DATA_WIDTH-1:0] dat_i,output reg [ADDR_WIDTH-1:0] adr_o);\n [/INST]\n", "output": "reg [DATA_WIDTH-1:0] dat [0:DATA_COUNT-1]; \n  reg [3:0] iterator; \n  reg start_old; \n  reg [2:0] state; \n  parameter [2:0] \n  S_WAIT_START = 3'd0, \n  S_WRITE_INIT = 3'd1, \n  S_WAIT_WRITE_ACK = 3'd2, \n  S_READ_INIT = 3'd3, \n  S_WAIT_READ_ACK = 3'd4; \n  always @(posedge clk or posedge rst) begin \n  if(rst == 1'b0) begin \n  dat[0] = 32'h00000000; \n  dat[1] = 32'h10001111; \n  dat[2] = 32'h20002222; \n  dat[3] = 32'h30003333; \n  dat[4] = 32'h40004444; \n  dat[5] = 32'h50005555; \n  dat[6] = 32'h60006666; \n  dat[7] = 32'h70007777; \n  dat[8] = 32'h80008888; \n  dat[9] = 32'h90009999; \n  dat[10] = 32'hA000AAAA; \n  dat[11] = 32'hB000BBBB; \n  dat[12] = 32'hC000CCCC; \n  dat[13] = 32'hD000DDDD; \n  dat[14] = 32'hE000EEEE; \n  dat[15] = 32'hF000FFFF; \n  state <= S_WAIT_START; \n  dat_o <= 0; \n  cyc_o <= 0; \n  stb_o <= 0; \n  we_o <= 0; \n  done <= 0; \n  iterator <= 0; \n  adr_o <= 0; \n  start_old <= 0; \n  end \n  else begin \n  start_old <= start; \n  if (state == S_WAIT_START) begin \n  if (start == 1'b0 && start_old == 1'b1) begin \n  state <= S_WRITE_INIT; \n  done <= 0; \n  iterator <= 0; \n  end \n  end \n  else if (state == S_WRITE_INIT) begin \n  cyc_o <= 1; \n  stb_o <= 1; \n  we_o <= 1; \n  dat_o <= dat[iterator]; \n  adr_o <= ( iterator * AU_IN_DATA ) + BASE_ADDRESS; \n  state <= S_WAIT_WRITE_ACK; \n  end \n  else if(state == S_WAIT_WRITE_ACK) begin \n  if (ack_i == 1'b1) begin \n  cyc_o <= 0; \n  stb_o <= 0; \n  we_o <= 0; \n  state <= S_READ_INIT; \n  end \n  end \n  else if(state == S_READ_INIT) begin \n  cyc_o <= 1; \n  stb_o <= 1; \n  we_o <= 0; \n  state <= S_WAIT_READ_ACK; \n  end \n  else if(state == S_WAIT_READ_ACK) begin \n  if (ack_i == 1'b1) begin \n  cyc_o <= 0; \n  stb_o <= 0; \n  we_o <= 0; \n  if (dat[iterator] != dat_i) begin \n  $display(\"ERROR: Wrong answer from slave: %X\", dat_i); \n  $stop; \n  end \n  if (iterator == DATA_COUNT-1) begin \n  done <= 1; \n  state <= S_WAIT_START; \n  end \n  else begin \n  iterator <= iterator + 1; \n  state <= S_WRITE_INIT; \n  end \n  end \n  end \n  else \n  $display(\"ERROR: Unkown state: %d\", state); \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, called ad_dds, generates Direct Digital Synthesis (DDS) data based on the inputs provided. It takes in a clock signal and various parameters for DDS phase, scale, and format. The DDS data is combined from two branches, and the module produces a 16-bit output. The DDS data generation is synchronized with the clock signal. The module uses internal registers to store DDS data and scale values. It instantiates two sub-modules, ad_dds_1, for generating DDS data from the phase and scale inputs.\n\n Module header:\n\nmodule ad_dds (clk,dds_format,dds_phase_0,dds_scale_0,dds_phase_1,dds_scale_1,dds_data);\n [/INST]\n", "output": "input clk; \n  input dds_format; \n  input [15:0] dds_phase_0; \n  input [15:0] dds_scale_0; \n  input [15:0] dds_phase_1; \n  input [15:0] dds_scale_1; \n  output [15:0] dds_data; \n  reg [15:0] dds_data_int = 'd0; \n  reg [15:0] dds_data = 'd0; \n  reg [15:0] dds_scale_0_r = 'd0; \n  reg [15:0] dds_scale_1_r = 'd0; \n  wire [15:0] dds_data_0_s; \n  wire [15:0] dds_data_1_s; \n  always @(posedge clk) begin \n  dds_data_int <= dds_data_0_s + dds_data_1_s; \n  dds_data[15:15] <= dds_data_int[15] ^ dds_format; \n  dds_data[14: 0] <= dds_data_int[14:0]; \n  end \n  always @(posedge clk) begin \n  dds_scale_0_r <= dds_scale_0; \n  dds_scale_1_r <= dds_scale_1; \n  end \n ad_dds_1 i_dds_1_0 (.clk (clk),.angle (dds_phase_0),.scale (dds_scale_0_r),.dds_data (dds_data_0_s)); \n ad_dds_1 i_dds_1_1 (.clk (clk),.angle (dds_phase_1),.scale (dds_scale_1_r),.dds_data (dds_data_1_s)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a simple delay element with an asynchronous reset. It has input ports d, en, rst, clk, ce, and clr, as well as output port q. The module contains a single flip-flop (op_mem_0_8_24) that stores the input signal d. The flip-flop is controlled by the enable signal en and can be asynchronously reset using the rst signal. The output q is directly connected to the flip-flop output. This module is designed to introduce a delay to the input signal d and can be reset asynchronously or controlled by the enable signal.\n\n Module header:\n\nmodule sysgen_delay_52cccd8896 (input [(1 - 1):0] d,input [(1 - 1):0] en,input [(1 - 1):0] rst,output [(1 - 1):0] q,input clk,input ce,input clr);\n [/INST]\n", "output": "wire d_1_22; \n  wire en_1_25; \n  wire rst_1_29; \n  wire op_mem_0_8_24_next; \n  reg op_mem_0_8_24 = 1'b0; \n  wire op_mem_0_8_24_rst; \n  wire op_mem_0_8_24_en; \n  localparam [(1 - 1):0] const_value = 1'b1; \n  reg op_mem_0_join_10_5; \n  reg op_mem_0_join_10_5_en; \n  reg op_mem_0_join_10_5_rst; \n  assign d_1_22 = d; \n  assign en_1_25 = en; \n  assign rst_1_29 = rst; \n  always @(posedge clk) \n  begin:proc_op_mem_0_8_24 \n  if (((ce == 1'b1) && (op_mem_0_8_24_rst == 1'b1))) \n  begin \n  op_mem_0_8_24 <= 1'b0; \n  end \n  else if (((ce == 1'b1) && (op_mem_0_8_24_en == 1'b1))) \n  begin \n  op_mem_0_8_24 <= op_mem_0_8_24_next; \n  end \n  end \n  always @(d_1_22 or en_1_25 or rst_1_29) \n  begin:proc_if_10_5 \n  if (rst_1_29) \n  begin \n  op_mem_0_join_10_5_rst = 1'b1; \n  end \n  else if (en_1_25) \n  begin \n  op_mem_0_join_10_5_rst = 1'b0; \n  end \n  else \n  begin \n  op_mem_0_join_10_5_rst = 1'b0; \n  end \n  if (en_1_25) \n  begin \n  op_mem_0_join_10_5_en = 1'b1; \n  end \n  else \n  begin \n  op_mem_0_join_10_5_en = 1'b0; \n  end \n  op_mem_0_join_10_5 = d_1_22; \n  end \n  assign op_mem_0_8_24_next = d_1_22; \n  assign op_mem_0_8_24_rst = op_mem_0_join_10_5_rst; \n  assign op_mem_0_8_24_en = op_mem_0_join_10_5_en; \n  assign q = op_mem_0_8_24; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module, SystemClockUnit, implements clock generation and locking using a DCM_SP module. It takes an input clock, CLK_IN1, and generates two output clocks, CLK_OUT1 and CLKFX. The DCM_SP module configures clock multiplication and phase shifting based on the input clock. The LOCKED output indicates whether the generated clock is locked. It uses clock buffers to drive the output clocks.\n\n Module header:\n\nmodule SystemClockUnit (input CLK_IN1,output CLK_OUT1,output LOCKED);\n [/INST]\n", "output": "IBUFG clkin1_buf \n (.O (clkin1),.I (CLK_IN1)); \n  wire psdone_unused; \n  wire locked_int; \n  wire [7:0] status_int; \n  wire clkfb; \n  wire clk0; \n  wire clkfx; \n  DCM_SP \n #(.CLKDV_DIVIDE (2.000),.CLKFX_DIVIDE (20),.CLKFX_MULTIPLY (13),.CLKIN_DIVIDE_BY_2 (\"FALSE\"),.CLKIN_PERIOD (10.0),.CLKOUT_PHASE_SHIFT (\"NONE\"),.CLK_FEEDBACK (\"1X\"),.DESKEW_ADJUST (\"SYSTEM_SYNCHRONOUS\"),.PHASE_SHIFT (0),.STARTUP_WAIT (\"FALSE\")) \n  dcm_sp_inst \n (.CLKIN (clkin1),.CLKFB (clkfb),.CLK0 (clk0),.CLK90 (),.CLK180 (),.CLK270 (),.CLK2X (),.CLK2X180 (),.CLKFX (clkfx),.CLKFX180 (),.CLKDV (),.PSCLK (1'b0),.PSEN (1'b0),.PSINCDEC (1'b0),.PSDONE (),.LOCKED (locked_int),.STATUS (status_int),.RST (1'b0),.DSSEN (1'b0)); \n  assign LOCKED = locked_int; \n  BUFG clkf_buf \n (.O (clkfb),.I (clk0)); \n  BUFG clkout1_buf \n (.O (CLK_OUT1),.I (clkfx)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a branch hazard detector for a processor. It takes several inputs related to the status of the processor's pipeline stages and outputs signals to indicate if a branch instruction should cause a pipeline flush in the decode stage (branch_flushD) or the execute stage (branch_flushE). The module uses these inputs to make decisions based on the conditions that would necessitate a branch flush.\n\n Module header:\n\nmodule branch_hazard_detector (input [4:0] ID_rs,input [4:0] ID_rt,input EX_regwe,input [4:0] EX_RW,input MEM_ramtoreg,input [4:0] MEM_RW,input ID_jmp_need_reg,input ID_jmp_reg,input ID_misprediction,output branch_flushD,output branch_flushE);\n [/INST]\n", "output": "assign branch_flushD = ID_jmp_reg || ID_misprediction; \n  assign branch_flushE = (ID_jmp_need_reg && EX_regwe && EX_RW != 0 && (EX_RW == ID_rs || EX_RW == ID_rt)) \n  || (ID_jmp_need_reg && MEM_ramtoreg && MEM_RW != 0 && (MEM_RW == ID_rs || MEM_RW == ID_rt)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `aluparam` is a parameterized arithmetic logic unit (ALU) that performs bitwise arithmetic and logic operations on two input vectors A and B. It produces a result Y of the same size as the inputs and sets a 16-bit flag register based on the result. It includes multiple bit-wise operations like AND, OR, XOR, and a full-adder for addition. The module is parameterized to handle different input vector sizes, and it utilizes generate loops to create multiple instances of the submodules such as multiplexers and full adders. The module also includes a flag generation logic based on the ALU operation result.\n\n Module header:\n\nmodule aluparam #( parameter BITSIZE = 16) ( output [BITSIZE-1:0] Y,output [15:0] flags,input [BITSIZE-1:0] A,input [BITSIZE-1:0] B,input [3:0] sel);\n [/INST]\n", "output": "wire [BITSIZE-1:0] src1; \n  wire [BITSIZE-1:0] src2; \n  wire [BITSIZE-1:0] Sout; \n  wire [BITSIZE-1:0] Cout; \n  wire [BITSIZE-1:0] Cin; \n  wire [BITSIZE-2:0] Ors; \n  wire ofint; \n  assign src1 = A; \n  and(flags[0], Cout[BITSIZE-1], !sel[3], sel[2], !sel[1], !sel[0]); \n  assign flags[1] = 1'b0; \n  and lowflag(flags[2], !Cout[BITSIZE-1], !sel[3], sel[2], !sel[1], sel[0]); \n  assign flags[4:3] = 2'b00; \n  xor overflow_flag(ofint, Cout[BITSIZE-1], Cin[BITSIZE-1]); \n  and(flags[5], ofint, !sel[3], sel[2], !sel[1]); \n  not zero_flag(flags[6], Ors[BITSIZE-2]); \n  assign flags[7] = Y[BITSIZE-1]; \n  assign flags[15:8] = 8'b0000_0000; \n  genvar c; \n  generate \n  for (c=0; c < BITSIZE; c=c+1) begin : GEN_SRC2_MUX \n muxparam #(.WIDTH(2), .BITSIZE(1)) src2_mux (.y(src2[c]),.a({!B[c],B[c]}),.sel(sel[0])); \n  end \n  endgenerate \n  genvar d; \n  generate \n  for (d=0; d < BITSIZE; d=d+1) begin : GEN_FULL_ADDERS \n fulladder1bit full_adders(.S(Sout[d]),.Cout(Cout[d]),.A(src1[d]),.B(src2[d]),.Cin(Cin[d])); \n  end \n  endgenerate \n  or or_ripple_init(Ors[0], Y[0], Y[1]); \n  genvar g; \n  generate \n  for (g=1; g < BITSIZE-1; g=g+1) begin : GEN_ZERO_FLAG \n  or or_ripple(Ors[g], Y[g+1], Ors[g-1]); \n  end \n  endgenerate \n muxparam #(.WIDTH(4), .BITSIZE(1)) carry_mux (.y(Cin[0]),.a({B[0], sel[0], 1'b1, 1'b0}),.sel(sel[2:1])); \n  genvar e; \n  generate \n  for (e=1; e < BITSIZE; e=e+1) begin : GEN_CARRY_MUX \n muxparam #(.WIDTH(4), .BITSIZE(1)) carry_mux (.y(Cin[e]),.a({B[e], Cout[e-1], 1'b1, 1'b0}),.sel(sel[2:1])); \n  end \n  endgenerate \n  genvar f; \n  generate \n  for (f=0; f < BITSIZE; f=f+1) begin : GEN_OUT_MUX \n muxparam #(.WIDTH(2), .BITSIZE(1)) out_mux (.y(Y[f]),.a({Cout[f],Sout[f]}),.sel(sel[3])); \n  end \n  endgenerate \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is designed to perform a 16-bit addition or subtraction operation. It takes in two 16-bit operands, a control signal for addition or subtraction, and outputs the two operands, as well as flags for the negative sign of each operand. The module also computes intermediate signals such as the sign bits of the operands, swaps the operands based on a comparison, and computes the final result and sign flags. The inputs are processed to determine the operation to be performed and the sign of the operands, and the outputs are then computed based on the results of these operations.\n\n Module header:\n\nmodule FP16BAddSubS0Of5(input clk,input rst,input [15:0] arg_0,input [15:0] arg_1,input arg_2,output [15:0] ret_0,output [15:0] ret_1,output ret_2,output ret_3);\n [/INST]\n", "output": "wire [15:0] x; \n  wire [15:0] y; \n  wire is_sub; \n  wire ys; \n  wire yys; \n  wire [15:0] yy; \n  wire diff_sign; \n  wire [7:0] xe; \n  wire [7:0] ye; \n  wire swap; \n  wire neg_lhs; \n  wire neg_rhs; \n  wire [15:0] lhs; \n  wire [15:0] rhs; \n  assign x = arg_0; \n  assign y = arg_1; \n  assign is_sub = arg_2; \n  assign ys = y[15]; \n  assign yys = is_sub ? ~ys : ys; \n  assign yy = {yys, y[14:0]}; \n  assign xe = x[14:7]; \n  assign ye = y[14:7]; \n  assign diff_sign = x[15] ^ yy[15]; \n  assign swap = xe < ye; \n  assign lhs = swap ? yy : x; \n  assign rhs = swap ? x : yy; \n  assign neg_lhs = diff_sign ? lhs[15] : 0; \n  assign neg_rhs = diff_sign ? rhs[15] : 0; \n  assign ret_0 = lhs; \n  assign ret_1 = rhs; \n  assign ret_2 = neg_lhs; \n  assign ret_3 = neg_rhs; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module represents a peripheral audio interface. It includes various inputs and outputs for communication with an external audio device. The module features a microfono instance and an address decoder to manage different operations based on the address input. It also incorporates an enable register and a microphone selection register.\n\nThe module activates its internal enable signal based on the address and control inputs. This enables the microphone data to be processed based on the specific operation indicated by the address input. The module also communicates with the microphone to handle full duplex and empty conditions and responds accordingly to read and write operations.\n\nAdditionally, the module controls the LED response, master clock output, and microphone left/right selection, and the microphone data input and output. It follows a specific protocol and timing defined by the external audio interface.\n\n Module header:\n\nmodule peripheral_audio(clk , rst , d_in , cs,wr,rd , addr, d_out, mclk, ledres, micLRSel,micData );\n [/INST]\n", "output": "input clk; \n  input rst; \n  input [15:0] d_in; \n  input cs; \n  input wr; \n  input rd; \n  input [3:0]addr; \n  output reg [15:0]d_out; \n  output ledres; \n  output mclk; \n  output micLRSel; \n  input micData; \n  wire doutmic; \n  wire full; \n  wire empty; \n  reg enable; \n reg [2:0] s; \n microfono mic(.reset(rst),.clk(clk),.micLRSel(micLRSel),.empty(empty),.mclk(mclk),.micData(micData),.ledres(ledres),.enable(enable),.full(full)); \n always @(*) begin \n case (addr) \n 4'h0:begin s = (cs && wr) ? 3'b001 : 3'b000 ;end \n 4'h2:begin s = (cs && rd) ? 3'b010 : 3'b000 ;end \n 4'h4:begin s = (cs && rd) ? 3'b100 : 3'b000 ;end \n 4'h8:begin s = (cs && rd) ? 3'b111 : 3'b000 ;end \n default:begin s=3'b000 ; end \n endcase \n end \n always @(negedge clk) begin \n if (s[0]==1) begin \n  enable=1; \n end \n else begin \n  enable=0; \n end \n end \n always @(negedge clk) begin \n case (s) \n 3'b010: d_out[0]= full; \n 3'b100: d_out[0]= empty; \n 3'b111: d_out[0]= dout; \n default: d_out=0; \n endcase \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a 4-input Look-Up Table (LUT) with a specified LUT function stored in lut_function. The inputs din0, din1, din2, and din3 are connected to wires dataa_w, datab_w, datac_w, and datad_w, respectively. The LUT function is implemented in the lut_data function, which uses the inputs to perform a specific lookup and generate the output. The combout_rt registers the output of the LUT function. The module then uses this output to generate the final output dout using a combinational logic block.\n\n Module header:\n\nmodule LUT4 (output dout,input din0, din1, din2, din3);\n [/INST]\n", "output": "parameter [15:0] lut_function = 16'hFFFF; \n reg combout_rt; \n wire dataa_w; \n wire datab_w; \n wire datac_w; \n wire datad_w; \n assign dataa_w = din0; \n assign datab_w = din1; \n assign datac_w = din2; \n assign datad_w = din3; \n function lut_data; \n input [15:0] mask; \n input dataa, datab, datac, datad; \n reg [7:0] s3; \n reg [3:0] s2; \n reg [1:0] s1; \n  begin \n  s3 = datad ? mask[15:8] : mask[7:0]; \n  s2 = datac ? s3[7:4] : s3[3:0]; \n  s1 = datab ? s2[3:2] : s2[1:0]; \n  lut_data = dataa ? s1[1] : s1[0]; \n  end \n endfunction \n always @(dataa_w or datab_w or datac_w or datad_w) begin \n combout_rt = lut_data(lut_function, dataa_w, datab_w,datac_w, datad_w); \n end \n assign dout = combout_rt & 1'b1; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements an alternative priority encoder for 16-bit input data. It includes two sub-modules for encoding the lower and upper 8 bits of the input data. The outputs from these sub-modules are then combined using logical operations to form the final output q. The design prioritizes non-zero outputs from the upper 8-bit encoder over the lower 8-bit encoder.\n\n Module header:\n\nmodule acl_fp_uitofp_altpriority_encoder_r08 (data,q) ;\n [/INST]\n", "output": "input [15:0] data; \n  output [3:0] q; \n  wire [2:0] wire_altpriority_encoder21_q; \n  wire [2:0] wire_altpriority_encoder22_q; \n  wire wire_altpriority_encoder22_zero; \n  acl_fp_uitofp_altpriority_encoder_bv7 altpriority_encoder21 \n (.data(data[7:0]),.q(wire_altpriority_encoder21_q)); \n  acl_fp_uitofp_altpriority_encoder_be8 altpriority_encoder22 \n (.data(data[15:8]),.q(wire_altpriority_encoder22_q),.zero(wire_altpriority_encoder22_zero)); \n  assign \n  q = {(~ wire_altpriority_encoder22_zero), (({3{wire_altpriority_encoder22_zero}} & wire_altpriority_encoder21_q) | ({3{(~ wire_altpriority_encoder22_zero)}} & wire_altpriority_encoder22_q))}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module defines three counters c1, c2, and c3, and a cycle counter. The cycle counter increments with each clock cycle. When the cycle counter is less than 2, c1_data, c2_data, and c3_data are reset. When the cycle counter is equal to 2, the resets are de-asserted. When the cycle counter is equal to 3, it checks if the value of c1_data is 12345. When the cycle counter reaches 20, it prints the values of c1_data, c2_data, and c3_data, and checks if they have the expected values. If any of the checks fail, the simulation stops. If all checks pass, the simulation finishes.\n\n Module header:\n\nmodule t (clk);\n [/INST]\n", "output": "input clk; \n  integer cyc=1; \n  counter_io c1_data(); \n  counter_io c2_data(); \n  counter_io c3_data(); \n counter_ansi c1 (.clkm(clk),.c_data(c1_data),.i_value(4'h1)); \n counter_ansi c2 (.clkm(clk),.c_data(c2_data),.i_value(4'h2)); \n `ifdef VERILATOR counter_ansi `else counter_nansi `endif \n c3 (.clkm(clk),.c_data(c3_data),.i_value(4'h3)); \n  initial begin \n  c1_data.value = 4'h4; \n  c2_data.value = 4'h5; \n  c3_data.value = 4'h6; \n  end \n  always @ (posedge clk) begin \n  cyc <= cyc + 1; \n  if (cyc<2) begin \n  c1_data.reset <= 1; \n  c2_data.reset <= 1; \n  c3_data.reset <= 1; \n  end \n  if (cyc==2) begin \n  c1_data.reset <= 0; \n  c2_data.reset <= 0; \n  c3_data.reset <= 0; \n  end \n  if (cyc==3) begin \n  if (c1_data.get_lcl() != 12345) $stop; \n  end \n  if (cyc==20) begin \n $write(\"[%0t] c1 cyc%0d: c1 %0x %0x c2 %0x %0x c3 %0x %0x\\n\", $time, cyc,c1_data.value, c1_data.reset,c2_data.value, c2_data.reset,c3_data.value, c3_data.reset); \n  if (c1_data.value != 2) $stop; \n  if (c2_data.value != 3) $stop; \n  if (c3_data.value != 4) $stop; \n  $write(\"*-* All Finished *-*\\n\"); \n  $finish; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module `comp` implements a comparator with branching logic. It takes two 32-bit inputs `dinA` and `dinB`, an instruction `ins`, a comparison flag `compare`, and outputs a branching signal `branch`. The module decodes the `ins` instruction to determine the type of comparison to perform and then evaluates the inputs to set the branching signal based on the comparison result. It handles comparisons for equality, inequality, greater than zero, less than or equal to zero, and signed comparisons based on a selector.\n\n Module header:\n\nmodule comp(dinA, dinB, ins, compare, branch);\n [/INST]\n", "output": "input [31:0] dinA; \n  input [31:0] dinB; \n  input [31:0] ins; \n  input compare; \n  output reg branch; \n  wire [5:0] op; \n  wire [4:0] sel; \n  assign sel = ins[20:16]; \n  assign op = ins[31:26]; \n  parameter BEQ = 6'b000100, \n  BNE = 6'b000101, \n  BGTZ = 6'b000111, \n  BLEZ = 6'b000110, \n  BGEZ_BLTZ = 6'b000001; \n  parameter SEL0 = 5'b00000, \n  SEL1 = 5'b00001; \n  always @ ( compare or dinA or dinB ) begin \n  if (compare) begin \n  case (op) \n  BEQ: begin \n  if (dinA == dinB) begin \n  branch = 1; \n  end else branch = 0; \n  end \n  BNE: begin \n  if (dinA != dinB) begin \n  branch = 1; \n  end else branch = 0; \n  end \n  BGTZ: begin \n  if ($signed(dinA) > 0) begin \n  branch = 1; \n  end else branch = 0; \n  end \n  BLEZ: begin \n  if ($signed(dinA) <= 0) begin \n  branch = 1; \n  end else branch = 0; \n  end \n  BGEZ_BLTZ: begin \n  case (sel) \n  SEL0: if ($signed(dinA) < 0) begin \n  branch = 1; \n  end else branch = 0; \n  SEL1: if ($signed(dinA) >= 0) begin \n  branch = 1; \n  end else branch = 0; \n  endcase \n  end \n  default: branch = 0; \n  endcase \n  end else branch = 0; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements an alternate priority encoder. It takes an 8-bit input 'data' and outputs a 3-bit vector 'q'. It consists of two priority encoders (altpriority_encoder10 and altpriority_encoder11) that handle the lower and upper 4 bits of the input respectively. The final output 'q' is determined by combining the outputs of these two encoders and a zero bit, using bitwise operations and concatenation.\n\n Module header:\n\nmodule int_to_fp_altpriority_encoder_bv7 (data,q) ;\n [/INST]\n", "output": "input [7:0] data; \n  output [2:0] q; \n  wire [1:0] wire_altpriority_encoder10_q; \n  wire [1:0] wire_altpriority_encoder11_q; \n  wire wire_altpriority_encoder11_zero; \n  int_to_fp_altpriority_encoder_6v7 altpriority_encoder10 \n (.data(data[3:0]),.q(wire_altpriority_encoder10_q)); \n  int_to_fp_altpriority_encoder_6e8 altpriority_encoder11 \n (.data(data[7:4]),.q(wire_altpriority_encoder11_q),.zero(wire_altpriority_encoder11_zero)); \n  assign \n  q = {(~ wire_altpriority_encoder11_zero), (({2{wire_altpriority_encoder11_zero}} & wire_altpriority_encoder10_q) | ({2{(~ wire_altpriority_encoder11_zero)}} & wire_altpriority_encoder11_q))}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module serves as a receiver with synchronized data and control signals. The `receiver` module takes in clock signal `clk`, reset signal `rst`, data `data`, and strobe signal `stb`, and provides synchronized output data `data_out`, acknowledge signal `ack`, and valid signal `valid`. The module instantiates a synchronizer to synchronize the `stb` signal. It then uses various flops and registers to synchronize and process the input data and control signals. The `ack` and `valid` signals are generated based on the synchronized control signals.\n\n Module header:\n\nmodule receiver (clk, rst, data, stb, data_out, ack, valid);\n [/INST]\n", "output": "input clk, rst, stb; \n  input [`DATA_BITS-1:0] data; \n  output [`DATA_BITS-1:0] data_out; \n  output ack, valid; \n  wire [`DATA_BITS-1:0] data_rec; \n  wire stb_selected; \n  `ifdef USE_RECEIVER_SYNCHRONIZER \n  synchronizer sync1 (clk, rst, stb, stb_sync); \n  assign stb_selected = stb_sync; \n  `else \n  assign stb_selected = stb; \n  `endif \n  myflop reg5 (clk, rst, stb_selected, ack, 1'b1); \n  myregister reg1 (clk, rst, data, data_rec, newdata); \n  assign data_out = data_rec; \n  myflop reg3 (clk, rst, stb_selected, stb_latched, 1'b1); \n  assign newdata = stb_selected & !stb_latched; \n  myflop reg4 (clk, rst, newdata, valid, 1'b1); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an input clock buffer that takes an input clock signal and generates two output clock signals, CLK_OUT1 and CLK_OUT2. It also provides a locked output signal indicating whether the DCM_SP module has locked to the input clock. The module utilizes a DCM_SP module for clock domain crossing and clock synthesis. The DCM_SP module takes the input clock signal, applies clock multiplication and division, and outputs the resulting clock signals. The module also includes buffers for the output clock signals.\n\n Module header:\n\nmodule in_dcm (input CLK_IN1,output CLK_OUT1,output CLK_OUT2,input RESET,output LOCKED);\n [/INST]\n", "output": "IBUFG clkin1_buf \n (.O (clkin1),.I (CLK_IN1)); \n  wire psdone_unused; \n  wire locked_int; \n  wire [7:0] status_int; \n  wire clkfb; \n  wire clk2x; \n  wire clkfx; \n  DCM_SP \n #(.CLKDV_DIVIDE (2.000),.CLKFX_DIVIDE (2),.CLKFX_MULTIPLY (5),.CLKIN_DIVIDE_BY_2 (\"FALSE\"),.CLKIN_PERIOD (20.833),.CLKOUT_PHASE_SHIFT (\"NONE\"),.CLK_FEEDBACK (\"2X\"),.DESKEW_ADJUST (\"SYSTEM_SYNCHRONOUS\"),.PHASE_SHIFT (0),.STARTUP_WAIT (\"FALSE\")) \n  dcm_sp_inst \n (.CLKIN (clkin1),.CLKFB (clkfb),.CLK0 (),.CLK90 (),.CLK180 (),.CLK270 (),.CLK2X (clk2x),.CLK2X180 (),.CLKFX (clkfx),.CLKFX180 (),.CLKDV (),.PSCLK (1'b0),.PSEN (1'b0),.PSINCDEC (1'b0),.PSDONE (),.LOCKED (locked_int),.STATUS (status_int),.RST (RESET),.DSSEN (1'b0)); \n  assign LOCKED = locked_int; \n  assign clkfb = CLK_OUT1; \n  BUFG clkout1_buf \n (.O (CLK_OUT1),.I (clk2x)); \n  BUFG clkout2_buf \n (.O (CLK_OUT2),.I (clkfx)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, named bSbox, implements a specific transformation process on the input A and provides the resulting output Q. The module involves various intermediate signals like R1-R9 and T1-T9, which are derived from different bitwise operations on the input A. The module also includes an instantiation of a GF_INV_8 module for further processing. The final output Q is computed by performing bitwise operations on these intermediate signals to derive the values for Q[7:0].\n\n Module header:\n\nmodule bSbox ( A, Q );\n [/INST]\n", "output": "input [7:0] A; \n  output [7:0] Q; \n  wire [7:0] B, C; \n  wire R1, R2, R3, R4, R5, R6, R7, R8, R9; \n  wire T1, T2, T3, T4, T5, T6, T7, T8, T9; \n  assign R1 = A[7] ^ A[5] ; \n  assign R2 = A[7] ^ A[4] ; \n  assign R3 = A[6] ^ A[0] ; \n  assign R4 = A[5] ^ R3 ; \n  assign R5 = A[4] ^ R4 ; \n  assign R6 = A[3] ^ A[0] ; \n  assign R7 = A[2] ^ R1 ; \n  assign R8 = A[1] ^ R3 ; \n  assign R9 = A[3] ^ R8 ; \n  assign B[7] = R7 ^ R8 ; \n  assign B[6] = R5 ; \n  assign B[5] = A[1] ^ R4 ; \n  assign B[4] = R1 ^ R3 ; \n  assign B[3] = A[1] ^ R2 ^ R6 ; \n  assign B[2] = A[0] ; \n  assign B[1] = R4 ; \n  assign B[0] = A[2] ^ R9 ; \n  GF_INV_8 inv( B, C ); \n  assign T1 = C[7] ^ C[3] ; \n  assign T2 = C[6] ^ C[4] ; \n  assign T3 = C[6] ^ C[0] ; \n  assign T4 = C[5] ^ C[3] ; \n  assign T5 = C[5] ^ T1 ; \n  assign T6 = C[5] ^ C[1] ; \n  assign T7 = C[4] ^ T6 ; \n  assign T8 = C[2] ^ T4 ; \n  assign T9 = C[1] ^ T2 ; \n  assign Q[7] = T4 ; \n  assign Q[6] = ~T1 ; \n  assign Q[5] = ~T3 ; \n  assign Q[4] = T5 ; \n  assign Q[3] = T2 ^ T5 ; \n  assign Q[2] = T3 ^ T8 ; \n  assign Q[1] = ~T7 ; \n  assign Q[0] = ~T9 ; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module is a UART transmitter with configurable parameters for baud rate divisor, baud divisor width, and word width. It utilizes a state machine with three states - idle, synchronize, and transmit - to control the transmission process. The data to be transmitted is stored in a register and sent out based on the baud rate and transmitter enable signal. The module also manages the selection of the transmitter, input acknowledgment, and the transmitter enable signal. The busy signal indicates whether the module is actively transmitting data.\n\n Module header:\n\nmodule uart_tx #(parameter BAUD_DIV=2,parameter BAUD_DIV_WIDTH=8,parameter W=8) (input c,input [W-1:0] in,input in_en,output in_ack,output out,output busy);\n [/INST]\n", "output": "wire tx_r_en, tx_sel; \n wire [W+1:0] tx; \n r #(W+2) tx_r \n (.c(c), .en(tx_r_en), .rst(1'b0), .q(tx),.d(tx_sel ? {1'b1, in, 1'b0} : {1'b0, tx[W+1:1]})); \n wire [BAUD_DIV_WIDTH-1:0] baud_div_count; \n r #(BAUD_DIV_WIDTH) baud_div_count_r \n (.c(c), .en(1'b1), .rst(baud_div_count == BAUD_DIV-1),.d(baud_div_count + 1'b1), .q(baud_div_count)); \n wire tx_edge = ~|baud_div_count; \n localparam CW = 4; \n localparam SW = 3; \n localparam ST_IDLE = 3'd0; \n localparam ST_SYNC = 3'd1; \n localparam ST_TX = 3'd2; \n reg [CW+SW-1:0] ctrl; \n wire [SW-1:0] state; \n wire [SW-1:0] next_state = ctrl[CW+SW-1:CW]; \n r #(SW) state_r(.c(c), .d(next_state), .rst(1'b0), .en(1'b1), .q(state)); \n always @* begin \n  case (state) \n  ST_IDLE: \n  if (in_en) ctrl = {ST_SYNC , 4'b0111}; \n  else ctrl = {ST_IDLE , 4'b0000}; \n  ST_SYNC: \n  if (tx_edge) ctrl = {ST_TX , 4'b0000}; \n  else ctrl = {ST_SYNC , 4'b0000}; \n  ST_TX: \n  if (tx_edge) \n  if (~|tx[W+1:1]) ctrl = {ST_IDLE, 4'b1001}; \n  else ctrl = {ST_TX, 4'b1001}; \n  else ctrl = {ST_TX, 4'b1000}; \n  default: ctrl = {ST_IDLE , 4'b0000}; \n  endcase \n end \n assign tx_r_en = ctrl[0]; \n assign in_ack = ctrl[1]; \n assign tx_sel = ctrl[2]; \n assign out = ctrl[3] ? tx[0] : 1'b1; \n assign busy = (state != ST_IDLE); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an I2S controller that generates I2S clock and mclock signals based on the input clock, clock divider, and reset signals. It includes an I2S memory controller and an I2S writer module. The clocked always blocks toggle the I2S clock and mclock signals based on the clock and mclock counts, respectively. The audio data request and acknowledgement signals are used to interface with the I2S memory controller and writer. Additionally, it initializes various registers and wires for controlling the I2S signals and interfacing with other modules.\n\n Module header:\n\nmodule i2s_controller (input rst,input clk,input enable,input post_fifo_wave_en,input [31:0] clock_divider,output [23:0] wfifo_size,output [1:0] wfifo_ready,input [1:0] wfifo_activate,input wfifo_strobe,input [31:0] wfifo_data,output reg i2s_mclock,output reg i2s_clock,output i2s_data,output i2s_lr);\n [/INST]\n", "output": "`define DEFAULT_MCLOCK_DIVISOR `CLOCK_RATE / (`AUDIO_RATE) / 256 \n reg [31:0] clock_count = 0; \n reg [31:0] mclock_count = 0; \n wire audio_data_request; \n wire audio_data_ack; \n wire [23:0] audio_data; \n wire audio_lr_bit; \n i2s_mem_controller mcontroller (.rst (rst ),.clk (clk ),.enable (enable ),.post_fifo_wave_en (post_fifo_wave_en ),.i2s_clock (i2s_clock ),.wfifo_size (wfifo_size ),.wfifo_ready (wfifo_ready ),.wfifo_activate (wfifo_activate ),.wfifo_strobe (wfifo_strobe ),.wfifo_data (wfifo_data ),.audio_data_request (audio_data_request ),.audio_data_ack (audio_data_ack ),.audio_data (audio_data ),.audio_lr_bit (audio_lr_bit )); \n i2s_writer writer (.rst (rst ),.clk (clk ),.enable (enable ),.starved (starved ),.i2s_clock (i2s_clock ),.audio_data_request (audio_data_request ),.audio_data_ack (audio_data_ack ),.audio_data (audio_data ),.audio_lr_bit (audio_lr_bit ),.i2s_data (i2s_data ),.i2s_lr (i2s_lr )); \n `define DEFAULT_MCLOCK_DIVISOR 1 \n always @(posedge clk) begin \n  if (rst) begin \n  i2s_clock <= 0; \n  clock_count <= 0; \n  end \n  if (clock_count >= clock_divider) begin \n  i2s_clock <= ~i2s_clock; \n  clock_count <= 0; \n  end \n  else begin \n  clock_count <= clock_count + 1; \n  end \n end \n always @(posedge clk) begin \n  if (mclock_count >= `DEFAULT_MCLOCK_DIVISOR) begin \n  i2s_mclock <= ~i2s_mclock; \n  mclock_count <= 0; \n  end \n  else begin \n  mclock_count <= mclock_count + 1; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module generates an output clock signal with a frequency of 60Hz. It uses a 20-bit counter (CNT) that increments on each clock cycle, and when the counter reaches the value 833,333, the output clock is asserted and the counter is reset. If the counter is not at the target value, it is incremented by 1 on each clock cycle.\n\n Module header:\n\nmodule clk60hz(input wire clk,output wire outclk);\n [/INST]\n", "output": "reg [19:0] cnt = 0; \n  assign outclk = cnt == 833333; \n  always @(posedge clk) \n  if(outclk) \n  cnt <= 0; \n  else \n  cnt <= cnt + 20'b1; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a simple input buffer (IBUF) for handling input and output signals. The IBUF has an output o and input i, and an additional input ibar. The output o is directly connected to the input i, while the module passes the input ibar through to the output ibar without altering it.\n\n Module header:\n\nmodule twentynm_io_ibuf (output o, input i, input ibar);\n [/INST]\n", "output": "assign ibar = ibar; \n  assign o = i; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a dual-port asynchronous FIFO with a data width of 18 bits and an address width of 11 bits. It has separate clock and enable signals for writing and reading operations. The module has input and output ports for data, empty, full, read enable, write enable, read clock, write clock, and clear. The module uses two instances of a FIFO16 module to handle the upper and lower 9 bits of the 18-bit data. The Data_out port combines the outputs of the two FIFO16 instances. The Empty_out and Full_out ports reflect the state of the FIFO. The module controls the reading and writing of data based on the fullness and emptiness of the FIFO and the Clear_in signal.\n\n Module header:\n\nmodule vgafb_asfifo #(parameter DATA_WIDTH = 18,parameter ADDRESS_WIDTH = 11) (output [17:0] Data_out,output Empty_out,input ReadEn_in,input RClk,input [17:0] Data_in,output Full_out,input WriteEn_in,input WClk,input Clear_in);\n [/INST]\n", "output": "wire full; \n wire empty; \n FIFO16 #(.DATA_WIDTH(9),.FIRST_WORD_FALL_THROUGH(\"TRUE\")) fifo_lo (.ALMOSTEMPTY(),.ALMOSTFULL(),.DO(Data_out[7:0]),.DOP(Data_out[8]),.EMPTY(empty),.FULL(full),.RDCOUNT(),.RDERR(),.WRCOUNT(),.WRERR(),.DI(Data_in[7:0]),.DIP(Data_in[8]),.RDCLK(RClk),.RDEN(ReadEn_in & ~empty & ~Clear_in),.RST(Clear_in),.WRCLK(WClk),.WREN(WriteEn_in & ~full & ~Clear_in)); \n assign Empty_out = empty; \n assign Full_out = full; \n FIFO16 #(.DATA_WIDTH(9),.FIRST_WORD_FALL_THROUGH(\"TRUE\")) fifo_hi (.ALMOSTEMPTY(),.ALMOSTFULL(),.DO(Data_out[16:9]),.DOP(Data_out[17]),.EMPTY(),.FULL(),.RDCOUNT(),.RDERR(),.WRCOUNT(),.WRERR(),.DI(Data_in[16:9]),.DIP(Data_in[17]),.RDCLK(RClk),.RDEN(ReadEn_in & ~empty & ~Clear_in),.RST(Clear_in),.WRCLK(WClk),.WREN(WriteEn_in & ~full & ~Clear_in)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"soc_design_Sys_Timer\" implements a timer with various features such as counter control, period setting, interrupt generation, and status reading. It includes registers for control, counter, and read data, and uses clock, reset, write, and chip select signals for operation. The module also generates an interrupt based on the control register and timeout event, and allows for period and control register write operations. The timer behavior is controlled by clock and reset signals, and its status can be read through the readdata output.\n\n Module header:\n\nmodule soc_design_Sys_Timer (address,chipselect,clk,reset_n,write_n,writedata,irq,readdata);\n [/INST]\n", "output": "output irq; \n  output [ 15: 0] readdata; \n  input [ 2: 0] address; \n  input chipselect; \n  input clk; \n  input reset_n; \n  input write_n; \n  input [ 15: 0] writedata; \n  wire clk_en; \n  wire control_interrupt_enable; \n  reg control_register; \n  wire control_wr_strobe; \n  reg counter_is_running; \n  wire counter_is_zero; \n  wire [ 16: 0] counter_load_value; \n  reg delayed_unxcounter_is_zeroxx0; \n  wire do_start_counter; \n  wire do_stop_counter; \n  reg force_reload; \n  reg [ 16: 0] internal_counter; \n  wire irq; \n  wire period_h_wr_strobe; \n  wire period_l_wr_strobe; \n  wire [ 15: 0] read_mux_out; \n  reg [ 15: 0] readdata; \n  wire status_wr_strobe; \n  wire timeout_event; \n  reg timeout_occurred; \n  assign clk_en = 1; \n  always @(posedge clk or negedge reset_n) \n  begin \n  if (reset_n == 0) \n  internal_counter <= 17'h1869F; \n  else if (counter_is_running || force_reload) \n  if (counter_is_zero || force_reload) \n  internal_counter <= counter_load_value; \n  else \n  internal_counter <= internal_counter - 1; \n  end \n  assign counter_is_zero = internal_counter == 0; \n  assign counter_load_value = 17'h1869F; \n  always @(posedge clk or negedge reset_n) \n  begin \n  if (reset_n == 0) \n  force_reload <= 0; \n  else if (clk_en) \n  force_reload <= period_h_wr_strobe || period_l_wr_strobe; \n  end \n  assign do_start_counter = 1; \n  assign do_stop_counter = 0; \n  always @(posedge clk or negedge reset_n) \n  begin \n  if (reset_n == 0) \n  counter_is_running <= 1'b0; \n  else if (clk_en) \n  if (do_start_counter) \n  counter_is_running <= -1; \n  else if (do_stop_counter) \n  counter_is_running <= 0; \n  end \n  always @(posedge clk or negedge reset_n) \n  begin \n  if (reset_n == 0) \n  delayed_unxcounter_is_zeroxx0 <= 0; \n  else if (clk_en) \n  delayed_unxcounter_is_zeroxx0 <= counter_is_zero; \n  end \n  assign timeout_event = (counter_is_zero) & ~(delayed_unxcounter_is_zeroxx0); \n  always @(posedge clk or negedge reset_n) \n  begin \n  if (reset_n == 0) \n  timeout_occurred <= 0; \n  else if (clk_en) \n  if (status_wr_strobe) \n  timeout_occurred <= 0; \n  else if (timeout_event) \n  timeout_occurred <= -1; \n  end \n  assign irq = timeout_occurred && control_interrupt_enable; \n  assign read_mux_out = ({16 {(address == 1)}} & control_register) | \n ({16 {(address == 0)}} & {counter_is_running,timeout_occurred}); \n  always @(posedge clk or negedge reset_n) \n  begin \n  if (reset_n == 0) \n  readdata <= 0; \n  else if (clk_en) \n  readdata <= read_mux_out; \n  end \n  assign period_l_wr_strobe = chipselect && ~write_n && (address == 2); \n  assign period_h_wr_strobe = chipselect && ~write_n && (address == 3); \n  assign control_wr_strobe = chipselect && ~write_n && (address == 1); \n  always @(posedge clk or negedge reset_n) \n  begin \n  if (reset_n == 0) \n  control_register <= 0; \n  else if (control_wr_strobe) \n  control_register <= writedata[0]; \n  end \n  assign control_interrupt_enable = control_register; \n  assign status_wr_strobe = chipselect && ~write_n && (address == 0); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module is for generating VGA timing signals. It uses a horizontal and vertical counter to generate hsync and vsync signals. The module also checks the counters to determine when the video signal should be valid. Additionally, it includes a video enable signal (vidon) that indicates when the video signal should be displayed on the screen.\n\n Module header:\n\nmodule vga_640_480_stripes(input wire clk,input wire clr,output reg hsync,output reg vsync,output reg [9:0] hc,output reg [9:0] vc,output reg vidon);\n [/INST]\n", "output": "parameter hpixels = 10'b1100100000, \n  vlines = 10'b1000001001, \n  hbp = 10'b0010010000, \n  hfp = 10'b1100010000, \n  vbp = 10'b0000011111, \n  vfp = 10'b0111111111; \n  reg vsenable; \n  always @(posedge clk or posedge clr) \n  begin \n  if(clr==1) \n  hc<=0; \n  else \n  begin \n  if(hc==hpixels-1) \n  begin \n  hc<=0; \n  vsenable <=1; \n  end \n  else \n  begin \n  hc<=hc+1; \n  vsenable <= 0; \n  end \n  end \n  end \n  always @ (*) \n  begin \n  if(hc<96) \n  hsync=0; \n  else \n  hsync=1; \n  end \n  always @ (posedge clk or posedge clr) \n  begin \n  if(clr==1) \n  vc<=0; \n  else \n  if(vsenable==1) \n  begin \n  if(vc==vlines-1) \n  vc<=0; \n  else \n  vc<=vc+1; \n  end \n  end \n  always @(*) \n  begin \n  if(vc<2) \n  vsync=0; \n  else \n  vsync=1; \n  end \n  always@(*) \n  begin \n  if((hc<hfp)&&(hc>hbp)&&(vc<vfp)&&(vc>vbp)) \n  vidon = 1; \n  else \n  vidon = 0; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a decoder that takes input signals cae_inst and cae_data and produces various outputs based on the decoded values. It decodes different fields of the cae_inst input to determine the values of inst_val, inst_caep, inst_aeg_wr, inst_aeg_rd, inst_aeg_idx, and err_unimpl. The module uses combinational logic to decode the cae_inst input and assigns the decoded values to the respective outputs. The decoding is done based on specific bit patterns within the cae_inst input and cae_inst_vld signal. The module employs case statements to select the appropriate decoding logic for different bit patterns and conditions, and sets the output signals accordingly.\n\n Module header:\n\nmodule instdec (input [31:0] cae_inst,input [63:0] cae_data,input cae_inst_vld,output inst_val,output [4:0] inst_caep,output inst_aeg_wr,output inst_aeg_rd,output [17:0] inst_aeg_idx,output err_unimpl);\n [/INST]\n", "output": "reg c_val, c_aeg_wr, c_aeg_rd, c_unimpl; \n  reg [4:0] c_caep; \n  reg [17:0] c_aeg_idx; \n  always @* begin \n  c_val = 'b0; \n  c_caep = 'b0; \n  c_aeg_wr = 'b0; \n  c_aeg_rd = 'b0; \n  c_aeg_idx = 'b0; \n  c_unimpl = 'b0; \n  casex (cae_inst[28:24]) \n  5'b1101?: begin \n  case (cae_inst[24:18]) \n  7'h40: begin \n  c_aeg_idx = cae_inst[17:0]; \n  c_aeg_wr = cae_inst_vld; \n  end \n  7'h68: begin \n  c_aeg_idx = cae_data[17:0]; \n  c_aeg_rd = cae_inst_vld; \n  end \n  7'h70: begin \n  c_aeg_idx = {6'b0, cae_inst[17:6]}; \n  c_aeg_rd = cae_inst_vld; \n  end \n  default: c_unimpl = cae_inst_vld; \n  endcase \n  end \n  5'b11100: begin \n  case (cae_inst[23:18]) \n  6'h18: begin \n  c_aeg_idx = {6'b0, cae_inst[17:12], cae_inst[5:0]}; \n  c_aeg_wr = cae_inst_vld; \n  end \n  6'h20: begin \n  c_aeg_idx = {6'b0, cae_inst[17:12], cae_inst[5:0]}; \n  c_aeg_wr = cae_inst_vld; \n  end \n  default: c_unimpl = cae_inst_vld; \n  endcase \n  end \n  5'b11101: begin \n  case (cae_inst[23:18]) \n  6'h1c: begin \n  c_aeg_idx = {6'b0, cae_inst[17:6]}; \n  c_aeg_rd = cae_inst_vld; \n  end \n  default: c_unimpl = cae_inst_vld; \n  endcase \n  end \n  5'b11110: begin \n  c_caep = cae_inst[22:18]; \n  c_val = cae_inst_vld & cae_inst[23]; \n  c_unimpl = cae_inst_vld & !cae_inst[23]; \n  end \n  default: c_unimpl = cae_inst_vld; \n  endcase \n  end \n  assign inst_val = c_val; \n  assign inst_caep = c_caep; \n  assign inst_aeg_wr = c_aeg_wr; \n  assign inst_aeg_rd = c_aeg_rd; \n  assign inst_aeg_idx = c_aeg_idx; \n  assign err_unimpl = c_unimpl; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a bypass register that selects between two inputs based on the value of the i_settings input. The i_datain input is chosen if i_settings is low, and the i_register_settings input is chosen if i_settings is high. The o_dataout_valid output is the same as the i_datain_valid input, and the o_datain_stall output is the same as the i_dataout_stall input.\n\n Module header:\n\nmodule vfabric_bypass_reg(clock, resetn,i_settings,i_register_settings,i_datain, i_datain_valid, o_datain_stall,o_dataout, o_dataout_valid, i_dataout_stall);\n [/INST]\n", "output": "parameter DATA_WIDTH = 32; \n  input clock; \n  input resetn; \n  input i_settings; \n  input [DATA_WIDTH-1:0] i_register_settings; \n  input [DATA_WIDTH-1:0] i_datain; \n  input i_datain_valid; \n  output o_datain_stall; \n  output [DATA_WIDTH-1:0] o_dataout; \n  output o_dataout_valid; \n  input i_dataout_stall; \n  assign o_dataout = i_settings ? i_register_settings : i_datain; \n  assign o_dataout_valid = i_datain_valid; \n  assign o_datain_stall = i_dataout_stall; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a simple buffer that passes the input signal 'a' to the output 'q'. It effectively acts as a wire, where the output 'q' simply reflects the value of the input 'a'.\n\n Module header:\n\nmodule mbuf (input a,output q);\n [/INST]\n", "output": "assign q = a; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is designed to implement a bullet in a game. It takes in various inputs such as the position of the bullet, the trigger signal, and the timer. It utilizes registers to update the position of the bullet and to determine whether the bullet is over the specified boundaries. The 'bullet' output is set based on certain conditions involving the position and movement of the bullet.\n\n Module header:\n\nmodule bullet(input clk,input rst,input [10:0] x,input [10:0] y,input [10:0] poX,input [10:0] poY,input trigger,input timer,input d,output reg bullet);\n [/INST]\n", "output": "parameter w = 4; \n parameter s = 4; \n reg [10:0] nowX, nowY; \n reg start; \n reg over; \n always@(posedge clk ,posedge rst) \n begin \n  if(rst)start<=0; \n  else if(trigger)start<=1; \n  else start<=start; \n end \n always@(posedge clk, posedge rst) \n begin \n  if(rst) over <= 0; \n  else begin \n  if(d) begin \n  if(start && nowX > 904) over <= 1; \n  else over <= over; \n  end \n  else begin \n  if(start && nowX < 104 && nowX>0) over <= 1; \n  else over <= over; \n  end \n  end \n end \n always@(posedge clk, posedge rst) \n begin \n  if(rst) nowX <= 0; \n  else begin \n  if(trigger) nowX <= poX; \n  else if(timer) begin \n  if(start) nowX <= (d)? nowX+w : nowX-w; \n  else nowX <= nowX; \n  end \n  else nowX <= nowX; \n  end \n end \n always@(posedge clk, posedge rst) \n begin \n  if(rst) nowY <= 0; \n  else begin \n  if(trigger) nowY <= poY; \n  else nowY <= nowY; \n  end \n end \n always@(posedge clk, posedge rst) \n begin \n  if(rst) bullet <= 0; \n  else begin \n  if(over) bullet <= 0; \n  else if(d &&start && x < nowX+w+36 && x > nowX+36 && y < nowY+w+20 && y > nowY+20) bullet <= 1; \n  else if(!d && start && x < nowX+w && x > nowX && y < nowY+w+20 && y > nowY+20) bullet <= 1; \n  else bullet <= 0; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a 3-digit seven-segment display controller. It takes four inputs: clk, rst_n, inp0, inp1, inp2, and outputs a 7-bit pattern for a 7-segment display. The module cycles through inp0, inp1, and inp2 inputs every 1000 clock cycles and drives the corresponding 7-segment patterns to the out_wire. The output_select signal is used to select which input to display on the seven-segment display. The module also has a counter to keep track of the clock cycles and a case statement to assign the appropriate 7-bit pattern to the out signal based on the input value.\n\n Module header:\n\nmodule mySevenSegment(input clk,input rst_n,input [3:0] inp0,input [3:0] inp1,input [3:0] inp2,output [6:0] out_wire,output reg [2:0] output_select);\n [/INST]\n", "output": "reg [6:0] out; \n  integer output_select_loop; \n  reg[3:0] inp; \n  integer counter; \n  assign out_wire = ~out; \n  always @(posedge clk or negedge rst_n) \n  begin \n  if (~rst_n) \n  begin \n  out <= 7'b0; \n  output_select<=3'b110; \n  counter<=0; \n  end \n  else \n  begin \n  counter<= counter + 1; \n  if (counter == 1000) \n  begin \n  counter <= 0; \n  case(output_select) \n  3'b110: \n  begin \n  output_select<= 3'b101; \n  inp<= inp1; \n  end \n  3'b101: \n  begin \n  output_select<= 3'b011; \n  inp<= inp2; \n  end \n  3'b011: \n  begin \n  output_select<= 3'b110; \n  inp<= inp0; \n  end \n  endcase \n  end \n  case (inp) \n  4'd0:out <= 7'b1111110; \n  4'd1:out <= 7'b0110000; \n  4'd2:out <= 7'b1101101; \n  4'd3:out <= 7'b1111001; \n  4'd4:out <= 7'b0110011; \n  4'd5:out <= 7'b1011011; \n  4'd6:out <= 7'b1011111; \n  4'd7:out <= 7'b1110000; \n  4'd8:out <= 7'b1111111; \n  4'd9:out <= 7'b1111011; \n  endcase \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module is a clock domain crossing and clock frequency division system, including a PLL (Phase-Locked Loop) component. It takes an input clock and reset, and four data channels, and produces various output clocks, serial data, and test outputs. It uses a PLL to generate a 20 MHz clock from the input clock, and also provides additional clock outputs. The system includes internal signals for locking status and feedback. The PLL component within the module is configured with specific clock dividers, phase compensation, and jitter settings. The system synchronizes these clock domains and performs clock frequency division to generate the desired clock signals. Additionally, it manages the reset based on the locking status, and assigns the locked signal based on the internal locking status.\n\n Module header:\n\nmodule root(clk, rstn, datain_ch0, datain_ch1, datain_ch2, datain_ch3, serialout, clk20, locked, testout0, testout1, testout2, testout3);\n [/INST]\n", "output": "input clk; \n  input rstn; \n  input datain_ch0; \n  input datain_ch1; \n  input datain_ch2; \n  input datain_ch3; \n  output clk20; \n  output locked; \n  output serialout; \n  output testout0; \n  output testout1; \n  output testout2; \n  output testout3; \n  wire fbouttofbin; \n  wire clk100; \n  wire rstn_int; \n  wire locked_int; \n  wire CLKOUT2; \n  wire CLKOUT3; \n  wire CLKOUT4; \n  wire CLKOUT5; \n system sys0(.clk(clk100),.rstn(rstn_int),.datain_ch0(datain_ch0),.datain_ch1(datain_ch1),.datain_ch2(datain_ch2),.datain_ch3(datain_ch3),.serialout(serialout),.testout0(testout0),.testout1(testout1),.testout2(testout2),.testout3(testout3)); \n PLL_BASE #(.BANDWIDTH(\"OPTIMIZED\"),.CLKFBOUT_MULT(12),.CLKFBOUT_PHASE(0.0),.CLKIN_PERIOD(20.000),.CLKOUT0_DIVIDE(6),.CLKOUT0_DUTY_CYCLE(0.5),.CLKOUT0_PHASE(0.0),.CLKOUT1_DIVIDE(30),.CLKOUT1_DUTY_CYCLE(0.5),.CLKOUT1_PHASE(0.0),.CLKOUT2_DIVIDE(1),.CLKOUT2_DUTY_CYCLE(0.5),.CLKOUT2_PHASE(0.0),.CLKOUT3_DIVIDE(1),.CLKOUT3_DUTY_CYCLE(0.5),.CLKOUT3_PHASE(0.0),.CLKOUT4_DIVIDE(1),.CLKOUT4_DUTY_CYCLE(0.5),.CLKOUT4_PHASE(0.0),.CLKOUT5_DIVIDE(1),.CLKOUT5_DUTY_CYCLE(0.5),.CLKOUT5_PHASE(0.0),.COMPENSATION(\"SYSTEM_SYNCHRONOUS\"),.DIVCLK_DIVIDE(1),.REF_JITTER(0.100)) PLL_BASE_inst (.CLKFBOUT(fbouttofbin),.CLKOUT0(clk100),.CLKOUT1(clk20),.CLKOUT2(CLKOUT2),.CLKOUT3(CLKOUT3),.CLKOUT4(CLKOUT4),.CLKOUT5(CLKOUT5),.LOCKED(locked_int),.CLKFBIN(fbouttofbin),.CLKIN(clk),.RST(~rstn)); \n  assign locked = locked_int; \n  assign rstn_int = rstn & locked_int; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module has three ports: out_0r as input, and out_0a and out_0d as outputs. It instantiates a GND cell and assigns out_0a to the value of input out_0r, while out_0d is assigned to a constant ground value.\n\n Module header:\n\nmodule BrzConstant_1_0 (out_0r, out_0a, out_0d);\n [/INST]\n", "output": "input out_0r; \n  output out_0a; \n  output out_0d; \n  wire gnd; \n  GND gnd_cell_instance (gnd); \n  assign out_0a = out_0r; \n  assign out_0d = gnd; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a branch predictor, implementing a gshare predictor with a FSM (finite state machine). It uses the history of branch outcomes to predict the next branch. The module has inputs for clock, reset, various control signals, and branch addresses. The predicted_flag_o output indicates the predicted outcome of the branch. The module updates its internal state based on the branch outcomes and uses this state to make predictions. It also updates the branch history based on the branch outcomes and the history. The FSM has four states: strongly not taken, weakly not taken, weakly taken, and strongly taken. The module also includes logic for handling reset, updating the history, and handling different branch outcomes to update the state accordingly.\n\n Module header:\n\nmodule mor1kx_branch_predictor_gshare #(parameter GSHARE_BITS_NUM = 10,parameter OPTION_OPERAND_WIDTH = 32) (input clk,input rst,output predicted_flag_o,input execute_op_bf_i,input execute_op_bnf_i,input op_bf_i,input op_bnf_i,input padv_decode_i,input flag_i,input prev_op_brcond_i,input branch_mispredict_i,input [OPTION_OPERAND_WIDTH-1:0] brn_pc_i);\n [/INST]\n", "output": "localparam [1:0] \n  STATE_STRONGLY_NOT_TAKEN = 2'b00, \n  STATE_WEAKLY_NOT_TAKEN = 2'b01, \n  STATE_WEAKLY_TAKEN = 2'b10, \n  STATE_STRONGLY_TAKEN = 2'b11; \n  localparam FSM_NUM = 2 ** GSHARE_BITS_NUM; \n  integer i = 0; \n  reg [1:0] state [0:FSM_NUM]; \n  reg [GSHARE_BITS_NUM:0] brn_hist_reg = 0; \n  reg [GSHARE_BITS_NUM - 1:0] prev_idx = 0; \n  wire [GSHARE_BITS_NUM - 1:0] state_index = brn_hist_reg[GSHARE_BITS_NUM - 1:0] ^ brn_pc_i[GSHARE_BITS_NUM + 1:2]; \n  assign predicted_flag_o = (state[state_index][1] && op_bf_i) || \n  (!state[state_index][1] && op_bnf_i); \n  wire brn_taken = (execute_op_bf_i && flag_i) || (execute_op_bnf_i && !flag_i); \n  always @(posedge clk) begin \n  if (rst) begin \n  brn_hist_reg <= 0; \n  prev_idx <= 0; \n  for(i = 0; i < FSM_NUM; i = i + 1) begin \n  state[i] = STATE_WEAKLY_TAKEN; \n  end \n  end else begin \n  if (op_bf_i || op_bnf_i) begin \n  prev_idx <= state_index; \n  end \n  if (prev_op_brcond_i && padv_decode_i) begin \n  brn_hist_reg <= {brn_hist_reg[GSHARE_BITS_NUM - 1 : 0], brn_taken}; \n  if (!brn_taken) begin \n  case (state[prev_idx]) \n  STATE_STRONGLY_TAKEN: \n  state[prev_idx] <= STATE_WEAKLY_TAKEN; \n  STATE_WEAKLY_TAKEN: \n  state[prev_idx] <= STATE_WEAKLY_NOT_TAKEN; \n  STATE_WEAKLY_NOT_TAKEN: \n  state[prev_idx] <= STATE_STRONGLY_NOT_TAKEN; \n  STATE_STRONGLY_NOT_TAKEN: \n  state[prev_idx] <= STATE_STRONGLY_NOT_TAKEN; \n  endcase \n  end else begin \n  case (state[prev_idx]) \n  STATE_STRONGLY_NOT_TAKEN: \n  state[prev_idx] <= STATE_WEAKLY_NOT_TAKEN; \n  STATE_WEAKLY_NOT_TAKEN: \n  state[prev_idx] <= STATE_WEAKLY_TAKEN; \n  STATE_WEAKLY_TAKEN: \n  state[prev_idx] <= STATE_STRONGLY_TAKEN; \n  STATE_STRONGLY_TAKEN: \n  state[prev_idx] <= STATE_STRONGLY_TAKEN; \n  endcase \n  end \n  end \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module `n64_vinfo_ext` takes in synchronization signals `Sync_pre` and `Sync_cur`, and control signals `VCLK`, `nVDSYNC`, `nRST`, and outputs `vinfo_o`. It has internal logic to detect edges in the sync signals and update internal registers `FrameID`, `n64_480i`, `line_cnt`, and `palmode` based on the detected sync edges. The `vinfo_o` output is assigned a concatenation of the `palmode` and `n64_480i` registers.\n\n Module header:\n\nmodule n64_vinfo_ext(VCLK,nVDSYNC,nRST,Sync_pre,Sync_cur,vinfo_o);\n [/INST]\n", "output": "input VCLK; \n input nVDSYNC; \n input nRST; \n input [3:0] Sync_pre; \n input [3:0] Sync_cur; \n output [1:0] vinfo_o; \n wire posedge_nVSYNC = !Sync_pre[3] & Sync_cur[3]; \n wire negedge_nVSYNC = Sync_pre[3] & !Sync_cur[3]; \n wire posedge_nHSYNC = !Sync_pre[1] & Sync_cur[1]; \n wire negedge_nHSYNC = Sync_pre[1] & !Sync_cur[1]; \n reg FrameID = 1'b0; \n reg n64_480i = 1'b1; \n always @(posedge VCLK or negedge nRST) \n  if (!nRST) begin \n  FrameID <= 1'b0; \n  n64_480i <= 1'b1; \n  end else if (!nVDSYNC) begin \n  if (negedge_nVSYNC) begin \n  if (negedge_nHSYNC) begin \n  n64_480i <= ~FrameID; \n  FrameID <= 1'b1; \n  end else begin \n  n64_480i <= FrameID; \n  FrameID <= 1'b0; \n  end \n  end \n  end \n reg [1:0] line_cnt = 2'b00; \n reg palmode = 1'b0; \n always @(posedge VCLK or negedge nRST) \n  if (!nRST) begin \n  line_cnt <= 2'b00; \n  palmode <= 1'b0; \n  end else if (!nVDSYNC) begin \n  if(posedge_nVSYNC) begin \n  line_cnt <= 2'b00; \n  palmode <= ~line_cnt[1]; \n  end else if(posedge_nHSYNC) \n  line_cnt <= line_cnt + 1'b1; \n  end \n assign vinfo_o = {palmode,n64_480i}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes two 32-bit input signals, sti_data, and dly_sti_data, along with clock and write enable signals. It processes the input data to create an internal wire, use_sti_data, by concatenating and alternating bits from sti_data and dly_sti_data. The module then instantiates two instances of the trigterm_32bit module to process the lower and upper 32 bits of use_sti_data, producing output signals, doutlo and dout. Finally, the module combines the hit signals from the lower and upper trigterm modules using a bitwise OR operation to produce the final output, hit.\n\n Module header:\n\nmodule trigterm_edge (input wire [31:0] sti_data,input wire [31:0] dly_sti_data,input wire clk,input wire wrenb,input wire din,output wire hit);\n [/INST]\n", "output": "wire [63:0] use_sti_data = { \n  dly_sti_data[31:30], sti_data[31:30], \n  dly_sti_data[29:28], sti_data[29:28], \n  dly_sti_data[27:26], sti_data[27:26], \n  dly_sti_data[25:24], sti_data[25:24], \n  dly_sti_data[23:22], sti_data[23:22], \n  dly_sti_data[21:20], sti_data[21:20], \n  dly_sti_data[19:18], sti_data[19:18], \n  dly_sti_data[17:16], sti_data[17:16], \n  dly_sti_data[15:14], sti_data[15:14], \n  dly_sti_data[13:12], sti_data[13:12], \n  dly_sti_data[11:10], sti_data[11:10], \n  dly_sti_data[ 9: 8], sti_data[ 9: 8], \n  dly_sti_data[ 7: 6], sti_data[ 7: 6], \n  dly_sti_data[ 5: 4], sti_data[ 5: 4], \n  dly_sti_data[ 3: 2], sti_data[ 3: 2], \n  dly_sti_data[ 1: 0], sti_data[ 1: 0]}; \n wire [7:0] lohit, hihit; \n trigterm_32bit loword (use_sti_data[31: 0], clk, wrenb, din, doutlo, lohit); \n trigterm_32bit hiword (use_sti_data[63:32], clk, wrenb, doutlo, dout, hihit); \n assign hit = |{hihit,lohit}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is designed to output a constant value. It includes an output port 'op', and inputs for the clock signal, clock enable, and clear. It defines a local constant 'const_value' with the value 1. The 'op' output is then assigned the constant value of 1.\n\n Module header:\n\nmodule constant_9cf45430cd (output [(1 - 1):0] op,input clk,input ce,input clr);\n [/INST]\n", "output": "localparam [(1 - 1):0] const_value = 1'b1; \n  assign op = 1'b1; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a simple input/output controller with a timer and various data registers. It features an internal timer that can be configured through the input signals and provides output data based on the control signals and the state of the timer. The module also handles LED outputs, 7-segment display outputs, and RGB outputs. The module has a reset signal to initialize the internal registers and the timer. The timer generates an interrupt request signal, and the module can respond to read and write operations to access various internal registers and control the outputs based on the input signals.\n\n Module header:\n\nmodule simpleio (input wire clk,input wire rst,input wire [3:0] AD,input wire [7:0] DI,output reg [7:0] DO,input wire rw,input wire cs,output wire irq,input wire clk_in,output reg [7:0] leds,output reg [7:0] led7hi,output reg [7:0] led7lo,output reg [2:0] rgb1,output reg [2:0] rgb2,input wire [3:0] switches,input wire [3:0] keys);\n [/INST]\n", "output": "reg [23:0] timer_cnt; \n  reg [23:0] timer_prescaler; \n  reg [7:0] timer_mode; \n  reg timer_eq_flag; \n  assign irq = timer_mode[7] & timer_mode[6]; \n  always @ (posedge clk_in) begin \n  if (rst) begin \n  timer_cnt <= 0; \n  timer_eq_flag <= 0; \n  end else begin \n  if (timer_mode[0]) begin \n  if (timer_cnt == timer_prescaler) begin \n  timer_eq_flag <= 1; \n  timer_cnt <= 0; \n  end else begin \n  timer_cnt <= timer_cnt + 1'b1; \n  if (timer_mode[7]) timer_eq_flag <= 0; \n  end \n  end \n  end \n  end \n  always @ (posedge clk) begin \n  if (rst) begin \n  leds <= 8'b11111111; \n  rgb1 <= 8'b111; \n  rgb2 <= 8'b111; \n  led7hi <= 0; \n  led7lo <= 0; \n  timer_mode <= 0; \n  timer_prescaler <= 0; \n  end else begin \n  if (timer_eq_flag) timer_mode[7] <= 1; \n  if (cs) begin \n  if (rw) begin \n  case (AD[3:0]) \n  4'b0000: DO <= ~leds; \n  4'b0001: DO <= led7hi; \n  4'b0010: DO <= led7lo; \n  4'b0011: begin \n  DO[6:4] <= ~rgb1; \n  DO[2:0] <= ~rgb2; \n  end \n  4'b0100: DO <= {switches, ~keys}; \n  4'b1000: begin \n  DO <= timer_mode; \n  timer_mode[7] <= 0; \n  end \n  4'b1001: DO <= timer_mode[0]?timer_cnt[23:16]:timer_prescaler[23:16]; \n  4'b1010: DO <= timer_mode[0]?timer_cnt[15:8]:timer_prescaler[15:8]; \n  4'b1011: DO <= timer_mode[0]?timer_cnt[7:0]:timer_prescaler[7:0]; \n  endcase \n  end else begin \n  case (AD[3:0]) \n  4'b0000: leds <= ~DI; \n  4'b0001: led7hi <= DI; \n  4'b0010: led7lo <= DI; \n  4'b0011: begin \n  rgb1 <= ~DI[6:4]; \n  rgb2 <= ~DI[2:0]; \n  end \n  4'b1000: timer_mode[6:0] <= DI[6:0]; \n  4'b1001: timer_prescaler[23:16] <= DI; \n  4'b1010: timer_prescaler[15:8] <= DI; \n  4'b1011: timer_prescaler[7:0] <= DI; \n  endcase \n  end \n  end \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a logic function called agnus_blitter_minterm, which takes inputs lf, ain, bin, and cin, and outputs out. It computes eight minterms mt0 through mt7 based on the inputs and a given truth table for each minterm, and then combines the minterms to produce the output using bitwise OR operations.\n\n Module header:\n\nmodule agnus_blitter_minterm (input [7:0] lf,input [15:0] ain,input [15:0] bin,input [15:0] cin,output [15:0] out);\n [/INST]\n", "output": "reg [15:0] mt0; \n reg [15:0] mt1; \n reg [15:0] mt2; \n reg [15:0] mt3; \n reg [15:0] mt4; \n reg [15:0] mt5; \n reg [15:0] mt6; \n reg [15:0] mt7; \n integer j; \n always @(ain or bin or cin or lf) \n  for (j=15; j>=0; j=j-1) \n  begin \n  mt0[j] = ~ain[j] & ~bin[j] & ~cin[j] & lf[0]; \n  mt1[j] = ~ain[j] & ~bin[j] & cin[j] & lf[1]; \n  mt2[j] = ~ain[j] & bin[j] & ~cin[j] & lf[2]; \n  mt3[j] = ~ain[j] & bin[j] & cin[j] & lf[3]; \n  mt4[j] = ain[j] & ~bin[j] & ~cin[j] & lf[4]; \n  mt5[j] = ain[j] & ~bin[j] & cin[j] & lf[5]; \n  mt6[j] = ain[j] & bin[j] & ~cin[j] & lf[6]; \n  mt7[j] = ain[j] & bin[j] & cin[j] & lf[7]; \n  end \n assign out = mt0 | mt1 | mt2 | mt3 | mt4 | mt5 | mt6 | mt7; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module monitors changes in the input signals ABLK_PG, ABLK_RESETn, ABLK_EN, ABLK_CONFIG_0, and ABLK_CONFIG_1. Whenever any of these inputs change, the module displays a colorized message indicating the change. The colorized messages are displayed for each input signal individually, showing the updated value of the input signal.\n\n Module header:\n\nmodule ablk (ABLK_PG,ABLK_RESETn,ABLK_EN,ABLK_CONFIG_0,ABLK_CONFIG_1);\n [/INST]\n", "output": "input ABLK_PG; \n  input ABLK_RESETn; \n  input ABLK_EN; \n  input [3:0] ABLK_CONFIG_0; \n  input [3:0] ABLK_CONFIG_1; \n  always @(ABLK_PG) begin \n  $write(\"%c[1;34m\",27); \n  $display(\"ablk Input ABLK_PG Has been changed to:%x\", ABLK_PG); \n  $write(\"%c[0m\",27); \n  end \n  always @(ABLK_RESETn) begin \n  $write(\"%c[1;34m\",27); \n  $display(\"ablk Input ABLK_RESETn Has been changed to:%x\", ABLK_RESETn); \n  $write(\"%c[0m\",27); \n  end \n  always @(ABLK_EN) begin \n  $write(\"%c[1;34m\",27); \n  $display(\"ablk Input ABLK_EN Has been changed to:%x\", ABLK_EN); \n  $write(\"%c[0m\",27); \n  end \n  always @(ABLK_CONFIG_0) begin \n  $write(\"%c[1;34m\",27); \n  $display(\"ablk Input ABLK_CONFIG_0 Has been changed to:%x\", ABLK_CONFIG_0); \n  $write(\"%c[0m\",27); \n  end \n  always @(ABLK_CONFIG_1) begin \n  $write(\"%c[1;34m\",27); \n  $display(\"ablk Input ABLK_CONFIG_1 Has been changed to:%x\", ABLK_CONFIG_1); \n  $write(\"%c[0m\",27); \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements an LED output fader. It uses PWM signals and a fade timer to control the brightness of the LED. The module selects the LED channel based on the brightness level and PWM signals, and fades the LED's brightness based on the fade timer. The LED's full-on state is also considered in controlling the LED's brightness. The module continuously updates the LED's brightness and channel selection based on the input signals and internal timers.\n\n Module header:\n\nmodule CLS_LED_Output_Fader (input LED_FULL_ON,input [6:0] PWM_CHANNEL_SIGS,input PWM_TIMER_TICK,input FADE_TIMER_TICK,output reg LEDR,input CLK);\n [/INST]\n", "output": "reg [2:0] led_mux_select; \n  reg [2:0] led_brightness_reg; \n  initial \n  begin \n  LEDR <= 1'b0; \n  led_mux_select <= 3'h0; \n  led_brightness_reg <= 3'h0; \n  end \n  always @(posedge CLK) \n  begin \n  if (LED_FULL_ON) \n  led_brightness_reg <= 3'h7; \n  else if ((FADE_TIMER_TICK == 1) && (led_brightness_reg != 3'h0)) \n  led_brightness_reg <= led_brightness_reg - 1'b1; \n  else if (FADE_TIMER_TICK) \n  led_brightness_reg <= 3'h0; \n  end \n  always @(posedge CLK) \n  begin \n  if(PWM_TIMER_TICK) \n  led_mux_select <= led_brightness_reg; \n  end \n  always @(posedge CLK) \n  begin \n  case (led_mux_select) \n  3'b000: LEDR <= 1'b0; \n  3'b001: LEDR <= PWM_CHANNEL_SIGS[0]; \n  3'b010: LEDR <= PWM_CHANNEL_SIGS[1]; \n  3'b011: LEDR <= PWM_CHANNEL_SIGS[2]; \n  3'b100: LEDR <= PWM_CHANNEL_SIGS[3]; \n  3'b101: LEDR <= PWM_CHANNEL_SIGS[4]; \n  3'b110: LEDR <= PWM_CHANNEL_SIGS[5]; \n  3'b111: LEDR <= PWM_CHANNEL_SIGS[6]; \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module represents a DDR3 memory model with read and write functionality. It includes an internal memory array, and the inputs consist of data to be written, read addresses, read and write clocks, and write enable signals. The output q provides the data read from the memory. The module updates the read address when rdaddress changes, and it writes data to the memory array when wren is asserted on the positive edge of the write clock wrclock.\n\n Module header:\n\nmodule ddr3_int_full_mem_model_ram_module (data,rdaddress,rdclken,wraddress,wrclock,wren,q);\n [/INST]\n", "output": "output [ 63: 0] q; \n  input [ 63: 0] data; \n  input [ 25: 0] rdaddress; \n  input rdclken; \n  input [ 25: 0] wraddress; \n  input wrclock; \n  input wren; \n  reg [ 63: 0] mem_array [67108863: 0]; \n  wire [ 63: 0] q; \n  reg [ 25: 0] read_address; \n  always @(rdaddress) \n  begin \n  read_address = rdaddress; \n  end \n  assign q = mem_array[read_address]; \n  always @(posedge wrclock) \n  begin \n  if (wren) \n  mem_array[wraddress] <= data; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a SPI (Serial Peripheral Interface) master, which facilitates communication with multiple slave devices over a serial bus. It operates with an 8-bit byte size. The module includes state machines to manage data transfer and handles the sending and receiving of data with the slave devices. It also controls the slave select signals and manages the synchronization of data with the clock. The module is resettable and includes error handling for unknown states.\n\n Module header:\n\nmodule spi_master(input data_in,output clk_out,output reg data_out,output reg slave_select1_out,output reg slave_select2_out,output reg slave_select3_out,input clk_in,input rst_in);\n [/INST]\n", "output": "localparam BYTE_SIZE = 8; \n  localparam BYTE_INDEX_SIZE = $clog2(BYTE_SIZE); \n  reg [BYTE_SIZE-1:0] data_recv; \n  reg [BYTE_SIZE-1:0] data_send; \n  reg [BYTE_INDEX_SIZE-1:0] send_iterator; \n  reg [BYTE_INDEX_SIZE-1:0] recv_iterator; \n  reg [1:0] state; \n  parameter [1:0] \n  S_WAIT = 2'd0, \n  S_TRANSFER = 2'd1, \n  S_DEASSERT = 2'd2; \n  assign clk_out = clk_in; \n  always @(posedge clk_in or posedge rst_in) begin \n  if(rst_in == 1'b1) begin \n  state <= S_WAIT; \n  data_recv <= 0; \n  data_send <= 8'h55; \n  data_out <= 1'bz; \n  send_iterator <= 0; \n  recv_iterator <= 0; \n  slave_select1_out <= 1; \n  slave_select2_out <= 1; \n  slave_select3_out <= 1; \n  end \n  else begin \n  if (state == S_WAIT) begin \n  slave_select1_out <= 0; \n  state <= S_TRANSFER; \n  end \n  else if (state == S_TRANSFER) begin \n  data_out <= data_send[send_iterator]; \n  if (send_iterator > 0 && recv_iterator < BYTE_SIZE-1) begin \n  data_recv[recv_iterator] <= data_in; \n  recv_iterator = recv_iterator +1; \n  end \n  if (recv_iterator >= BYTE_SIZE-1) begin \n  state <= S_DEASSERT; \n  end \n  else \n  send_iterator <= send_iterator + 1; \n  end \n  else if (state == S_DEASSERT) begin \n  data_recv[BYTE_SIZE-1] <= data_in; \n  state <= S_WAIT; \n  slave_select1_out <= 1; \n  data_out <= 1'bz; \n  send_iterator <= 0; \n  recv_iterator <= 0; \n  @(posedge clk_in); \n  end \n  else \n  $display(\"ERROR: Unkown state: %d\", state); \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a 3-port register file with dual-port RAM functionality. It contains input and output ports for the register file, address and data ports, and control signals. The module uses a synchronous process to handle BRAM and overlay enable signals and data inputs, and it assigns the appropriate data to the output ports based on the control signals. Additionally, it includes a clock-based process to handle specific conditions and generate an error flag for a stray pulse.\n\n Module header:\n\nmodule pfpu_regf(input sys_clk,input sys_rst,output reg ifb,output [31:0] a,output [31:0] b,input [31:0] r,input w_en,input [6:0] a_addr,input [6:0] b_addr,input [6:0] w_addr,input c_en,input [6:0] c_addr,output [31:0] c_do,input [31:0] c_di,input c_w_en,input [31:0] r0,input [31:0] r1,output err_stray);\n [/INST]\n", "output": "wire [6:0] p1_a; \n wire [31:0] p1_d; \n wire [6:0] p2_a; \n wire [31:0] p2_d; \n wire p3_en; \n wire [6:0] p3_a; \n wire [31:0] p3_d; \n pfpu_tpram tpram(.sys_clk(sys_clk),.p1_a(p1_a),.p1_d(p1_d),.p2_a(p2_a),.p2_d(p2_d),.p3_en(p3_en),.p3_a(p3_a),.p3_d(p3_d)); \n assign p1_a = c_en ? c_addr : a_addr; \n reg p1_bram_en; \n reg p1_overlay_en; \n reg [31:0] p1_overlay; \n always @(posedge sys_clk) begin \n  p1_bram_en <= 1'b0; \n  p1_overlay_en <= 1'b1; \n  if(p1_a == 7'd0) p1_overlay <= r0; \n  else if(p1_a == 7'd1) p1_overlay <= r1; \n  else begin \n  p1_bram_en <= 1'b1; \n  p1_overlay_en <= 1'b0; \n  p1_overlay <= 32'bx; \n  end \n end \n assign a = ({32{p1_bram_en}} & p1_d)|({32{p1_overlay_en}} & p1_overlay); \n assign c_do = a; \n assign p2_a = b_addr; \n reg p2_bram_en; \n reg p2_overlay_en; \n reg [31:0] p2_overlay; \n always @(posedge sys_clk) begin \n  p2_bram_en <= 1'b0; \n  p2_overlay_en <= 1'b1; \n  if(p2_a == 7'd0) p2_overlay <= r0; \n  else if(p2_a == 7'd1) p2_overlay <= r1; \n  else begin \n  p2_bram_en <= 1'b1; \n  p2_overlay_en <= 1'b0; \n  p2_overlay <= 32'bx; \n  end \n end \n assign b = ({32{p2_bram_en}} & p2_d)|({32{p2_overlay_en}} & p2_overlay); \n assign p3_en = c_en ? c_w_en : w_en; \n assign p3_a = c_en ? c_addr : w_addr; \n assign p3_d = c_en ? c_di : r; \n always @(posedge sys_clk) begin \n  if(p3_en) begin \n  if(p3_a == 7'd2) \n  ifb <= p3_d != 32'd0; \n  end \n end \n assign err_stray = p3_en & (p3_a == 7'd0); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a Hamming decoder that takes a 7-bit input H and outputs a 4-bit decoded value D. The Hamming code is used to compute each bit of the decoded output based on the input H. The decoded bits D[3:0] are computed using the specified Hamming code equations for error detection and correction.\n\n Module header:\n\nmodule NewHammingDecoder(H, D);\n [/INST]\n", "output": "input [6:0] H; \n  output [3:0] D; \n  assign D[3] = (H[6]^H[5]^H[4]^H[2])&(H[6]^H[5]^H[3]^H[1])&(H[6]^H[4]^H[3]^H[0]) ? ~H[6] : H[6]; \n  assign D[2] = (H[6]^H[5]^H[4]^H[2])&(H[6]^H[5]^H[3]^H[1])&!(H[6]^H[4]^H[3]^H[0]) ? ~H[5] : H[5]; \n  assign D[1] = (H[6]^H[5]^H[4]^H[2])&!(H[6]^H[5]^H[3]^H[1])&(H[6]^H[4]^H[3]^H[0]) ? ~H[4] : H[4]; \n  assign D[0] = !(H[6]^H[5]^H[4]^H[2])&(H[6]^H[5]^H[3]^H[1])&(H[6]^H[4]^H[3]^H[0]) ? ~H[3] : H[3]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module \"extender\" takes a 16-bit immediate value and extends it to a 32-bit output by sign-extending the immediate value. It also has an input \"unsigned_value\" and an output \"extended\". The immediate value's sign bit is extended to fill the higher bits of the 32-bit output. The logic is implemented through the use of logical assignments and a NOR gate.\n\n Module header:\n\nmodule extender ( immediate, unsigned_value, extended );\n [/INST]\n", "output": "input [15:0] immediate; \n  output [31:0] extended; \n  input unsigned_value; \n  wire \\extended[31] , \\immediate[15] , \\immediate[14] , \\immediate[13] , \n  \\immediate[12] , \\immediate[11] , \\immediate[10] , \\immediate[9] , \n  \\immediate[8] , \\immediate[7] , \\immediate[6] , \\immediate[5] , \n  \\immediate[4] , \\immediate[3] , \\immediate[2] , \\immediate[1] , \n  \\immediate[0] ; \n  assign extended[16] = \\extended[31] ; \n  assign extended[17] = \\extended[31] ; \n  assign extended[18] = \\extended[31] ; \n  assign extended[19] = \\extended[31] ; \n  assign extended[20] = \\extended[31] ; \n  assign extended[21] = \\extended[31] ; \n  assign extended[22] = \\extended[31] ; \n  assign extended[23] = \\extended[31] ; \n  assign extended[24] = \\extended[31] ; \n  assign extended[25] = \\extended[31] ; \n  assign extended[26] = \\extended[31] ; \n  assign extended[27] = \\extended[31] ; \n  assign extended[28] = \\extended[31] ; \n  assign extended[29] = \\extended[31] ; \n  assign extended[30] = \\extended[31] ; \n  assign extended[31] = \\extended[31] ; \n  assign extended[15] = \\immediate[15] ; \n  assign \\immediate[15] = immediate[15]; \n  assign extended[14] = \\immediate[14] ; \n  assign \\immediate[14] = immediate[14]; \n  assign extended[13] = \\immediate[13] ; \n  assign \\immediate[13] = immediate[13]; \n  assign extended[12] = \\immediate[12] ; \n  assign \\immediate[12] = immediate[12]; \n  assign extended[11] = \\immediate[11] ; \n  assign \\immediate[11] = immediate[11]; \n  assign extended[10] = \\immediate[10] ; \n  assign \\immediate[10] = immediate[10]; \n  assign extended[9] = \\immediate[9] ; \n  assign \\immediate[9] = immediate[9]; \n  assign extended[8] = \\immediate[8] ; \n  assign \\immediate[8] = immediate[8]; \n  assign extended[7] = \\immediate[7] ; \n  assign \\immediate[7] = immediate[7]; \n  assign extended[6] = \\immediate[6] ; \n  assign \\immediate[6] = immediate[6]; \n  assign extended[5] = \\immediate[5] ; \n  assign \\immediate[5] = immediate[5]; \n  assign extended[4] = \\immediate[4] ; \n  assign \\immediate[4] = immediate[4]; \n  assign extended[3] = \\immediate[3] ; \n  assign \\immediate[3] = immediate[3]; \n  assign extended[2] = \\immediate[2] ; \n  assign \\immediate[2] = immediate[2]; \n  assign extended[1] = \\immediate[1] ; \n  assign \\immediate[1] = immediate[1]; \n  assign extended[0] = \\immediate[0] ; \n  assign \\immediate[0] = immediate[0]; \n HS65_LL_NOR2AX3 U2 ( .A(\\immediate[15] ), .B(unsigned_value), .Z(\\extended[31] ) ); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a quadrature decoder with phase generation and LED control. It takes in a reset signal, frequency clock, enable signal, and outputs phase A, phase B, index, and LED control. The module uses registers and logic to generate the phase signals, count pulses, and control the LED based on the input clock and signals. The module also includes logic to handle the reset and enable signals, and to generate the index signal based on the phase count.\n\n Module header:\n\nmodule qdec(rst_n, freq_clk, enable, pha, phb,index, led);\n [/INST]\n", "output": "input rst_n; \n input freq_clk; \n input enable; \n output pha; \n output phb; \n output index; \n output led; \n reg pha_reg; \n reg phb_reg; \n reg index_reg; \n reg[7:0] pha_count; \n reg led; \n reg [31:0] count_reg; \n reg out_200hz; \n always @(posedge freq_clk or negedge rst_n) begin \n  if (!rst_n) begin \n  count_reg <= 0; \n  out_200hz <= 0; \n  count_reg <= 0; \n  out_200hz <= 0; \n  end \n  else if (enable) \n  begin \n  if (count_reg < 124999) begin \n  count_reg <= count_reg + 1; \n  end else begin \n  count_reg <= 0; \n  out_200hz <= ~out_200hz; \n  end \n  end \n end \n always @ (posedge out_200hz or negedge rst_n) \n begin \n  if (!rst_n) \n  begin \n  pha_count <= 8'd0; \n  led <= 1'b0; \n  end \n  else if (out_200hz) \n  begin \n  led <= ~led; \n  if(pha_count>8'd24) \n  pha_count <= 8'd0; \n  else \n  pha_count <= pha_count + 8'd1; \n  end \n end \n reg[1:0] Phase90_Count; \n always @ (posedge out_200hz or negedge rst_n) \n begin \n  if (!rst_n) \n  begin \n  Phase90_Count <= 2'b0; \n  end \n  else if (out_200hz) \n  begin \n  case (Phase90_Count) \n  2'd0: \n  begin \n  pha_reg <= 1'd1; \n  phb_reg <= 1'd1; \n  Phase90_Count <= Phase90_Count + 2'd1; \n  end \n  2'd1: \n  begin \n  Phase90_Count <= Phase90_Count + 2'd1; \n  end \n  2'd2: \n  begin \n  pha_reg <= 1'd0; \n  phb_reg <= 1'd0; \n  Phase90_Count <= Phase90_Count + 2'd1; \n  end \n  2'd3: \n  begin \n  Phase90_Count <= 2'd0; \n  end \n  endcase \n  end \n end \n assign pha = pha_reg; \n assign phb = phb_reg; \n always @ (posedge out_200hz or negedge rst_n) \n begin \n  if (!rst_n) \n  begin \n  index_reg <= 1'b0; \n  end \n  else if (out_200hz) \n  begin \n  case (pha_count) \n  8'd23: index_reg <= 1'd1; \n  8'd24: index_reg <= 1'd1; \n  default: index_reg <= 1'd0; \n  endcase \n  end \n end \n assign index = index_reg; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, \"controllerHdl_Rotor_Acceleration_To_Velocity,\" takes inputs CLK_IN, reset, enb_1_2000_0, Reset_1, and Vel_Target, and outputs the signed 32-bit value RV. It instantiates two internal modules, \"controllerHdl_Set_Acceleration\" and \"controllerHdl_Reset_Delay_block.\" It calculates a gain value and performs various bit manipulations, additions, and conditional selections to determine the output RV based on the input signals. The module effectively processes the input signals to compute the rotor velocity output.\n\n Module header:\n\nmodule controllerHdl_Rotor_Acceleration_To_Velocity (CLK_IN,reset,enb_1_2000_0,Reset_1,Vel_Target,RV);\n [/INST]\n", "output": "input CLK_IN; \n  input reset; \n  input enb_1_2000_0; \n  input Reset_1; \n  input signed [17:0] Vel_Target; \n  output signed [31:0] RV; \n  wire signed [31:0] Reset_Delay_out1; \n  wire signed [17:0] Set_Acceleration_out1; \n  wire signed [35:0] Gain_out1; \n  wire signed [31:0] Convert_out1; \n  wire signed [32:0] Sum_add_cast; \n  wire signed [32:0] Sum_add_cast_1; \n  wire signed [32:0] Sum_add_temp; \n  wire signed [31:0] Sum_out1; \n controllerHdl_Set_Acceleration u_Set_Acceleration (.CLK_IN(CLK_IN),.reset(reset),.enb_1_2000_0(enb_1_2000_0),.v_target(Vel_Target),.v_current(Reset_Delay_out1),.a(Set_Acceleration_out1)); \n  assign Gain_out1 = 85899 * Set_Acceleration_out1; \n  assign Convert_out1 = {{15{Gain_out1[35]}}, Gain_out1[35:19]}; \n  assign Sum_add_cast = Convert_out1; \n  assign Sum_add_cast_1 = Reset_Delay_out1; \n  assign Sum_add_temp = Sum_add_cast + Sum_add_cast_1; \n assign Sum_out1 = ((Sum_add_temp[32] == 1'b0) && (Sum_add_temp[31] != 1'b0) ? 32'sb01111111111111111111111111111111 :((Sum_add_temp[32] == 1'b1) && (Sum_add_temp[31] != 1'b1) ? 32'sb10000000000000000000000000000000 :$signed(Sum_add_temp[31:0]))); \n controllerHdl_Reset_Delay_block u_Reset_Delay (.CLK_IN(CLK_IN),.reset(reset),.enb_1_2000_0(enb_1_2000_0),.Reset_1(Reset_1),.In(Sum_out1),.Out(Reset_Delay_out1)); \n  assign RV = Reset_Delay_out1; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module defines a 9-bit multiplier. It takes two 24-bit inputs, dataa, and datab, and produces a 48-bit output result, which is the result of the multiplication of the inputs. The module uses wires to manipulate the inputs and results, and assigns the result of the multiplication to the output.\n\n Module header:\n\nmodule mult_9rr (dataa,datab,result) ;\n [/INST]\n", "output": "input [23:0] dataa; \n  input [23:0] datab; \n  output [47:0] result; \n  wire [23:0] dataa_wire; \n  wire [23:0] datab_wire; \n  wire [47:0] result_wire; \n  assign dataa_wire = dataa; \n  assign datab_wire = datab; \n  assign result_wire = dataa_wire * datab_wire; \n  assign result = ({result_wire[47:0]}); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a multiplexer that selects between two input ports, default_port and alt_port, based on the value of the switch input. The selected port is then assigned to the output port.\n\n Module header:\n\nmodule sw_mux (port_out,default_port,alt_port,switch);\n [/INST]\n", "output": "output port_out; \n  input default_port; \n  input alt_port; \n  input switch; \n  assign port_out = switch ? alt_port : default_port; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe given Verilog module implements a state machine that controls the twinkling of lights. The module takes a clock signal, a reset signal, and a step signal as input and produces a 3-bit signal to control the twinkling intensity. Inside the module, it uses an LFSR3 (Linear Feedback Shift Register) to generate a \"go\" signal for the state machine.\n\nThe state machine has two states, 0 and 1, and it transitions between these states based on the \"go\" signal. When the state is 0, the intensity of the twinkling lights is incremented, and when it reaches the maximum intensity, the state transitions to 1. In state 1, the intensity is decremented, and when it reaches the minimum intensity, the state transitions back to 0.\n\nThe module uses a direction variable to control the intensity increment and decrement, and it uses the step signal to perform these updates. The state machine is synchronized with the clock signal, and the intensity and direction are updated based on the step signal and the current state.\n\nOverall, this Verilog module effectively creates a state machine that controls the twinkling of lights based on the input clock, reset, and step signals, and produces the corresponding 3-bit signal to control the twinkling intensity.\n\n Module header:\n\nmodule twinkler(input clk,input rst,input step,output [2:0] signal);\n [/INST]\n", "output": "wire go; \n  lfsr3 rng(.clk(clk), .step(step), .rst(rst), .value(go)); \n  reg [2:0] intensity = 0; \n  assign signal = intensity; \n  reg direction = 0; \n  reg state; initial state = 0; \n  always @ (posedge clk) begin \n  case (state) \n  0: if (go) state <= 1; \n  1: begin \n  case (direction) \n  0: begin \n  if (step) begin \n  intensity <= intensity + 1; \n  if (intensity == 3'b110) direction <= 1; \n  end \n  end \n  1: begin \n  if (step) begin \n  intensity <= intensity - 1; \n  if (intensity == 3'b001) begin \n  direction <= 0; \n  state <= 0; \n  end \n  end \n  end \n  endcase \n  end \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module performs vector addition by concatenating the input vectors i1 and i0 to produce an 8-bit output vector o. Each 6-bit input vector i1 and 2-bit input vector i0 are combined to form the 8-bit output vector o.\n\n Module header:\n\nmodule v2ae6c6_v9a2a06 (input [5:0] i1,input [1:0] i0,output [7:0] o);\n [/INST]\n", "output": "assign o = {i1, i0}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module performs multiplication and scaling of two 2-bit inputs A and B. It calculates intermediate signals t, p, and q based on the input signals, and then combines p and q to form the output Y. The module uses logical operations to perform the multiplication and scaling.\n\n Module header:\n\nmodule GF_MULS_SCL_2 ( A, ab, B, cd, Y );\n [/INST]\n", "output": "input [1:0] A; \n  input ab; \n  input [1:0] B; \n  input cd; \n  output [1:0] Y; \n  wire t, p, q; \n  assign t = ~(A[0] & B[0]); \n  assign p = (~(ab & cd)) ^ t; \n  assign q = (~(A[1] & B[1])) ^ t; \n  assign Y = { p, q }; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a time counter that counts seconds, minutes, and hours. It increments the counters based on the 100Hz clock and has a clear signal to reset the counters. The module uses little-endian counters for each time unit, and most-significant-bit counters to handle the carry between the units. The counters are updated based on the clock signal and an enable signal, which is determined by the carry logic between the counters. The lit_lsb, lit_msb, sec_lsb, sec_msb, min_lsb, and min_msb outputs display the current count values for the seconds, minutes, and hours.\n\n Module header:\n\nmodule time_cnt(input ce,input clk_100hz,input clr,output [3:0] lit_lsb,output [3:0] lit_msb,output [3:0] sec_lsb,output [3:0] sec_msb,output [3:0] min_lsb,output [3:0] min_msb);\n [/INST]\n", "output": "reg [3:0] lit_lsb_cnt; \n  reg [3:0] lit_msb_cnt; \n  reg [3:0] sec_lsb_cnt; \n  reg [3:0] sec_msb_cnt; \n  reg [3:0] min_lsb_cnt; \n  reg [3:0] min_msb_cnt; \n  wire up; \n  assign up = 1; \n  wire enable, tc_1up, tc_2up, tc_3up, tc_4up, tc_5up; \n  wire tc_1dn, tc_2dn, tc_3dn, tc_4dn, tc_5dn; \n  assign tc_1up = (up && (lit_lsb_cnt == 4'd9)); \n  assign tc_2up = (up && (lit_msb_cnt == 4'd9)); \n  assign tc_3up = (up && (sec_lsb_cnt == 4'd9)); \n  assign tc_4up = (up && (sec_msb_cnt == 4'd5)); \n  assign tc_5up = (up && (min_lsb_cnt == 4'd9)); \n  assign tc_6up = (up && (min_msb_cnt == 4'd5)); \n  assign enable = ~(tc_1up && tc_2up && tc_3up && tc_4up && tc_5up && tc_6up)&& ce; \n  always @(posedge clk_100hz or posedge clr) \n  begin \n  if (clr) \n  lit_lsb_cnt <= 0; \n  else if (enable) \n  if (up) \n  if (lit_lsb_cnt == 4'd9) \n  lit_lsb_cnt <= 4'd0; \n  else lit_lsb_cnt <= lit_lsb_cnt + 1; \n  end \n  always @(posedge clk_100hz or posedge clr) \n  begin \n  if (clr) \n  lit_msb_cnt <= 0; \n  else if (enable) \n  if (tc_1up) \n  if (lit_msb_cnt == 4'd9) \n  lit_msb_cnt <= 4'd0; \n  else lit_msb_cnt <= lit_msb_cnt + 1; \n  end \n  always @(posedge clk_100hz or posedge clr) \n  begin \n  if (clr) \n  sec_lsb_cnt <= 0; \n  else if (enable) \n  if (tc_1up && tc_2up) \n  if (sec_lsb_cnt == 4'd9) \n  sec_lsb_cnt <= 4'd0; \n  else sec_lsb_cnt <= sec_lsb_cnt + 1; \n  end \n  always @(posedge clk_100hz or posedge clr) \n  begin \n  if (clr) \n  sec_msb_cnt <= 0; \n  else if (enable) \n  if (tc_1up && tc_2up && tc_3up) \n  if (sec_msb_cnt == 4'd5) \n  sec_msb_cnt <= 4'd0; \n  else sec_msb_cnt <= sec_msb_cnt + 1; \n  end \n  always @(posedge clk_100hz or posedge clr) \n  begin \n  if (clr) \n  min_lsb_cnt <= 0; \n  else if (enable) \n  if (tc_1up && tc_2up && tc_3up && tc_4up) \n  if (min_lsb_cnt == 4'd9) \n  min_lsb_cnt <= 4'd0; \n  else min_lsb_cnt <= min_lsb_cnt + 1; \n  end \n  always @(posedge clk_100hz or posedge clr) \n  begin \n  if (clr) \n  min_msb_cnt <= 0; \n  else if (enable) \n  if (tc_1up && tc_2up && tc_3up && tc_4up && tc_5up) \n  if (min_msb_cnt == 4'd5) \n  min_msb_cnt <= 4'd0; \n  else min_msb_cnt <= min_msb_cnt + 1; \n  end \n  assign lit_lsb = lit_lsb_cnt; \n  assign lit_msb = lit_msb_cnt; \n  assign sec_lsb = sec_lsb_cnt; \n  assign sec_msb = sec_msb_cnt; \n  assign min_lsb = min_lsb_cnt; \n  assign min_msb = min_msb_cnt; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, named \"f17_test\", serves as a testbench. It takes various inputs, including in1, in2, vin1, vin2, vin3, and vin4, and assigns them to specific bit ranges. Then, it computes logical AND and OR operations on some of these inputs and assigns the results to the outputs, out, vout, and vout1. The module essentially provides a framework for testing logical operations on the given inputs.\n\n Module header:\n\nmodule f17_test(in1, in2, vin1, vin2, out, vout, vin3, vin4, vout1 );\n [/INST]\n", "output": "input in1, in2; \n input [1:0] vin1; \n input [3:0] vin2; \n input [1:0] vin3; \n input [3:0] vin4; \n output vout, vout1; \n output out; \n assign out = in1 && in2; \n assign vout = vin1 && vin2; \n assign vout1 = vin3 || vin4; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a loadable counter with configurable parameters. The counter increments by a specified step value when the EN input is true, and it loads a new value from the DIN input when the EN is false. The counter is reset to 0 when the RST input is asserted. The DONE output indicates when the counter reaches the final value.\n\n Module header:\n\nmodule counter_loadable (CLK,EN,RST,DIN,DONE,COUNT);\n [/INST]\n", "output": "parameter n=4, \n  start=0, \n  final=8, \n  step=1; \n  input CLK; \n  input RST; \n  input EN; \n  input [n-1:0] DIN; \n  output DONE; \n  output [n-1:0] COUNT; \n  reg [n-1:0] COUNT; \n  always @ (posedge CLK or posedge RST) \n  begin \n  if (RST) \n  #5 COUNT = DIN; \n  else if (EN) \n  #5 COUNT = COUNT + step; \n  end \n  assign DONE = (COUNT == final); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `mig_7series_v4_0_axi_mc_wrap_cmd` is a controller for managing memory access commands. It utilizes the input signals to generate the appropriate command byte address and handle the sequence of memory access operations. The module's functionality includes generating the command byte address, managing the burst length, addressing, and handling the handshake signals to control the memory access sequence. It also handles the reset and next signals to ensure proper command sequencing. The module's output signals provide information about the next pending operation and whether certain conditions should be ignored or considered.\n\n Module header:\n\nmodule mig_7series_v4_0_axi_mc_wrap_cmd # (parameter integer C_AXI_ADDR_WIDTH = 32,parameter integer C_MC_ADDR_WIDTH = 30,parameter integer C_MC_BURST_LEN = 1,parameter integer C_DATA_WIDTH = 32,parameter integer C_AXSIZE = 2,parameter integer C_MC_RD_INST = 0) (input wire clk ,input wire reset ,input wire [C_AXI_ADDR_WIDTH-1:0] axaddr ,input wire [7:0] axlen ,input wire [2:0] axsize ,input wire axhandshake ,output wire [C_AXI_ADDR_WIDTH-1:0] cmd_byte_addr ,output wire ignore_begin ,output wire ignore_end ,input wire next ,output wire next_pending);\n [/INST]\n", "output": "localparam P_AXLEN_WIDTH = 4; \n reg sel_first_r; \n reg [3:0] axlen_cnt; \n reg [3:0] int_addr; \n reg int_next_pending_r; \n wire sel_first; \n wire [3:0] axlen_i; \n wire [3:0] axlen_cnt_i; \n wire [3:0] axlen_cnt_t; \n wire [3:0] axlen_cnt_p; \n wire addr_offset; \n wire [C_AXI_ADDR_WIDTH-1:0] axaddr_wrap; \n wire [3:0] int_addr_t; \n wire [3:0] int_addr_p; \n wire [3:0] int_addr_t_inc; \n wire int_next_pending; \n wire extra_cmd; \n assign cmd_byte_addr = axaddr_wrap; \n assign axlen_i = axlen[3:0]; \n assign axaddr_wrap = {axaddr[C_AXI_ADDR_WIDTH-1:C_AXSIZE+4], int_addr_t[3:0], axaddr[C_AXSIZE-1:0]}; \n generate \n  if(C_MC_BURST_LEN == 1) begin \n  assign addr_offset = 1'b0; \n  assign int_addr_t = axhandshake ? (axaddr[C_AXSIZE+: 4]) : int_addr; \n  end else begin \n  assign addr_offset = axaddr[C_AXSIZE]; \n  if(C_MC_RD_INST == 0) \n  assign int_addr_t = int_addr; \n  else \n  assign int_addr_t = axhandshake ? (axaddr[C_AXSIZE+: 4]) : int_addr; \n  end \n endgenerate \n assign int_addr_t_inc = int_addr_t + C_MC_BURST_LEN; \n assign int_addr_p = ((int_addr_t & ~axlen_i) | (int_addr_t_inc & axlen_i)); \n always @(posedge clk) begin \n  if(reset) \n  int_addr <= 4'h0; \n  else if (axhandshake & ~next) \n  int_addr <= (axaddr[C_AXSIZE+: 4]); \n  else if(next) \n  int_addr <= int_addr_p; \n end \n assign axlen_cnt_i = (C_MC_BURST_LEN == 1) ? axlen_i : (axlen_i >> 1); \n assign axlen_cnt_t = axhandshake ? axlen_cnt_i : axlen_cnt; \n assign axlen_cnt_p = (axlen_cnt_t - 1'b1); \n always @(posedge clk) begin \n  if(reset) \n  axlen_cnt <= 4'hf; \n  else if (axhandshake & ~next) \n  axlen_cnt <= axlen_cnt_i; \n  else if(next) \n  axlen_cnt <= axlen_cnt_p; \n end \n assign extra_cmd = addr_offset; \n assign next_pending = extra_cmd ? int_next_pending_r : int_next_pending; \n assign int_next_pending = |axlen_cnt_t; \n always @(posedge clk) begin \n  if(reset) \n  int_next_pending_r <= 1'b1; \n  else if(extra_cmd & next) \n  int_next_pending_r <= int_next_pending; \n end \n assign ignore_begin = sel_first ? addr_offset : 1'b0; \n assign ignore_end = next_pending ? 1'b0 : addr_offset; \n assign sel_first = (axhandshake | sel_first_r); \n always @(posedge clk) begin \n  if (reset) \n  sel_first_r <= 1'b0; \n  else if(axhandshake & ~next) \n  sel_first_r <= 1'b1; \n  else if(next) \n  sel_first_r <= 1'b0; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, ThermoGauge, implements a thermal gauge with configurable bit width. It has input ports for value, enable, and enforce signals, and an output port for the gauge reading. The behavior of the gauge is based on the inputs and is influenced by the LOGWORD parameter, which determines the bit width. It uses internal registers and wires to perform calculations and manage the gauge readings. The module also instantiates two submodules based on the LOGWORD parameter to process the input value and control signals and produce the left and right gauge readings.\n\n Module header:\n\nmodule ThermoGauge(gauge,value,enable,enforce);\n [/INST]\n", "output": "parameter LOGWORD=0; \n  localparam WORD=(1<<LOGWORD); \n  localparam HWORD=(1<<(LOGWORD-1)); \n  output reg [WORD-1:0] gauge; \n  input [LOGWORD+1-1:0] value; \n  input enable; \n  input enforce; \n  reg l_enable; \n  reg l_enforce; \n  reg r_enable; \n  reg r_enforce; \n  wire [HWORD+1-1:0] l_gauge; \n  wire [HWORD+1-1:0] r_gauge; \n  generate \n  if(LOGWORD<=0) begin \n  always @(*) begin \n  gauge <= enforce; \n  end \n  end \n  else begin \n  always @(*) begin \n  l_enable <= enable && value[LOGWORD-1]; \n  r_enable <= enable; \n  l_enforce <= enforce; \n  r_enforce <= enforce || l_enable; \n  gauge[ WORD-1:HWORD] <= l_gauge; \n  gauge[HWORD-1: 0] <= r_gauge; \n  end \n ThermoGauge #(.LOGWORD(LOGWORD-1)) i_l_thermogauge (l_gauge[HWORD-1:0],value[LOGWORD-1:0],l_enable,l_enforce); \n ThermoGauge #(.LOGWORD(LOGWORD-1)) i_r_thermogauge (r_gauge[HWORD-1:0],value[LOGWORD-1:0],r_enable,r_enforce); \n  end \n  endgenerate \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module \"mc\" has an output \"out\" of 32 bits and contains logic for manipulating P2 and P3 parameters. It has an initial block that assigns values to \"out\" based on P2 and P3. Inside an always block triggered by the positive edge of the \"t.clk\" signal, it checks the value of \"reach_up_cyc\" and performs operations on \"out\" based on specific conditions. For example, when \"reach_up_cyc\" equals 4, it updates bits 15 to 12 of \"out\" based on the sum of P2 and P3 plus 1. Furthermore, when \"reach_up_cyc\" equals 5 and P3 equals 1, it modifies bits 19 to 16 of the \"mc0.out\" signal, and then displays a message.\n\n Module header:\n\nmodule mc (output reg [31:0] out);\n [/INST]\n", "output": "`INLINE_MODULE \n  parameter P2 = 0; \n  parameter P3 = 0; \n  initial begin \n  out = {24'h0,P2[3:0],P3[3:0]}; \n  end \n  wire [31:0] reach_up_cyc = t.cyc; \n  always @ (posedge t.clk) begin \n  if (reach_up_cyc==2) begin \n  if (global_cell.globali != 32'hf00d) $stop; \n  if (global_cell2.globali != 32'hf33d) $stop; \n  end \n  if (reach_up_cyc==4) begin \n  out[15:12] <= {P2[3:0]+P3[3:0]+4'd1}; \n  end \n  if (reach_up_cyc==5) begin \n  if (P3==1) begin \n  mc0.out[19:16] <= {mc0.out[19:16]+P2[3:0]+P3[3:0]+4'd2}; \n  $display(\"%m Set %x->%x %x %x %x %x\",mc0.out, {mc0.out[19:16]+P2[3:0]+P3[3:0]+4'd2}, mc0.out[19:16],P2[3:0],P3[3:0],4'd2); \n  end \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module acl_fp_sub_altpriority_encoder_bv7 implements a priority encoder. It takes an 8-bit input data and generates a 3-bit output q. The input data is split into two 4-bit groups, which are then separately processed by two altpriority encoders, altpriority_encoder15 and altpriority_encoder16. The outputs of these two encoders are combined to form the final output q using bitwise operations. If the altpriority_encoder16 produces a zero, it is used to determine the most significant bit of q, otherwise a combination of both encoders' outputs is used.\n\n Module header:\n\nmodule acl_fp_sub_altpriority_encoder_bv7 (data,q) ;\n [/INST]\n", "output": "input [7:0] data; \n  output [2:0] q; \n  wire [1:0] wire_altpriority_encoder15_q; \n  wire [1:0] wire_altpriority_encoder16_q; \n  wire wire_altpriority_encoder16_zero; \n  acl_fp_sub_altpriority_encoder_6v7 altpriority_encoder15 \n (.data(data[3:0]),.q(wire_altpriority_encoder15_q)); \n  acl_fp_sub_altpriority_encoder_6e8 altpriority_encoder16 \n (.data(data[7:4]),.q(wire_altpriority_encoder16_q),.zero(wire_altpriority_encoder16_zero)); \n  assign \n  q = {(~ wire_altpriority_encoder16_zero), (({2{wire_altpriority_encoder16_zero}} & wire_altpriority_encoder15_q) | ({2{(~ wire_altpriority_encoder16_zero)}} & wire_altpriority_encoder16_q))}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module `select5_32` takes in five 32-bit inputs and a 3-bit selection signal. It then uses the selection signal to choose one of the inputs to output as `out`. If none of the selection conditions are met, it defaults to outputting all zeros.\n\n Module header:\n\nmodule select5_32(input [31:0] in1,input [31:0] in2,input [31:0] in3,input [31:0] in4,input [31:0] in5,input [2:0] choose,output reg [31:0] out);\n [/INST]\n", "output": "always@(in1 or in2 or in3 or in4 or in5 or choose) \n case(choose) \n 3'b000:out=in1; \n 3'b001:out=in2; \n 3'b010:out=in3; \n 3'b011:out=in4; \n 3'b100:out=in5; \n default:out=32'b0; \n endcase \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a FIFO (First In First Out) buffer with a depth of 64 to 256. It stores and retrieves 64-bit data words and increases or decreases the occupancy level. The read and write availability are determined based on the occupancy level and the data storage array. The module uses clock-edge triggering to perform read and write operations. The read and write availability flags are updated based on the occupancy level. The module also includes logic to manage the storage arrays, read and write operations, and update the occupancy level based on read and write actions.\n\n Module header:\n\nmodule tmu2_fifo64to256 #(parameter depth = 2) (input sys_clk,input sys_rst,output w8avail,input we,input [63:0] wd,output ravail,input re,output [255:0] rd);\n [/INST]\n", "output": "reg [63:0] storage1[0:(1 << depth)-1]; \n reg [63:0] storage2[0:(1 << depth)-1]; \n reg [63:0] storage3[0:(1 << depth)-1]; \n reg [63:0] storage4[0:(1 << depth)-1]; \n reg [depth+2:0] level; \n reg [depth+1:0] produce; \n reg [depth-1:0] consume; \n wire wavail = ~level[depth+2]; \n assign w8avail = level < ((1 << (depth + 2)) - 8); \n assign ravail = |(level[depth+2:2]); \n wire read = re & ravail; \n wire write = we & wavail; \n always @(posedge sys_clk) begin \n  if(sys_rst) begin \n  level <= 0; \n  produce <= 0; \n  consume <= 0; \n  end else begin \n  if(read) \n  consume <= consume + 1; \n  if(write) begin \n  produce <= produce + 1; \n  case(produce[1:0]) \n  2'd0: storage1[produce[depth+1:2]] <= wd; \n  2'd1: storage2[produce[depth+1:2]] <= wd; \n  2'd2: storage3[produce[depth+1:2]] <= wd; \n  2'd3: storage4[produce[depth+1:2]] <= wd; \n  endcase \n  end \n  case({read, write}) \n  2'b10: level <= level - 4; \n  2'b01: level <= level + 1; \n  2'b11: level <= level - 3; \n  endcase \n  end \n end \n assign rd = {storage1[consume], storage2[consume], storage3[consume], storage4[consume]}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a decrypter with the functionality of decrypting an 8x8 pixel message using a DES algorithm. It interfaces with a decrypter module to perform the actual decryption. The module handles the encryption input, decryption activation, and output of the decrypted data. It also manages the read and write addresses for the pixel array and the decrypted pixel array. The module includes logic for enabling the algorithm, acknowledging the completion of decryption, and managing the ready state for writing data. Additionally, it tracks the count of the read and write operations and handles the overall process of decryption.\n\n Module header:\n\nmodule decrypter(input clk,input reset,input [7:0] encrypted_data,input decrypter_active,input [63:0] key,output reg [14:0] read_addr,output reg [7:0] decrypted_data,output reg [14:0] write_addr,output reg done);\n [/INST]\n", "output": "wire [63:0] message; \n  wire [63:0] decrypted; \n  wire algo_done; \n  reg algo_en, ack; \n decrypt_dumb uut (.message(message),.DESkey(key),.decrypted(decrypted),.done(algo_done),.clk(clk),.reset(reset),.enable(algo_en),.ack(ack)); \n  reg [7:0] pixels [7:0]; \n  reg [7:0] dec_pixels [7:0]; \n  reg ready_to_write; \n  reg [2:0] read_count; \n  reg [2:0] write_count; \n  reg [14:0] counter; \n  reg [14:0] last_write_count; \n  assign message = {pixels[7], pixels[6], pixels[5], pixels[4], pixels[3], pixels[2], pixels[1], pixels[0]}; \n  always @(posedge clk) begin \n  if (reset) begin \n  read_count <= 0; \n  write_count <= 0; \n  counter <= 0; \n  last_write_count <= 0; \n  algo_en <= 0; \n  ready_to_write <= 0; \n  end else begin \n  if (decrypter_active) begin \n  pixels[read_count] <= encrypted_data; \n  if (read_count == 3'd7) begin \n  algo_en <= 1; \n  ack <= 0; \n  end else begin \n  algo_en <= 0; \n  ack <= 0; \n  end \n  if (algo_done) begin: ALGO_DONE \n  integer i; \n  for (i = 0; i < 8; i = i + 1) begin \n  dec_pixels[i] <= decrypted[8 * i +: 8]; \n  end \n  ack <= 1; \n  ready_to_write <= 1; \n  end \n  if (ready_to_write) begin \n  write_addr <= last_write_count; \n  write_count <= write_count + 1; \n  last_write_count <= last_write_count + 1; \n  if (write_count == 3'd7) \n  ready_to_write <= 0; \n  end \n  decrypted_data <= dec_pixels[3'd7 - write_count]; \n  read_addr <= counter; \n  read_count <= read_count + 1; \n  counter <= counter + 1; \n  if (counter > (175 * 175) & done) \n  done = 1'b1; \n  else \n  done = 1'b0; \n  end \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module `bus_w` takes several inputs and uses a combinational logic to determine the value of the output `w`. The value of `w` depends on the combination of the input signals `mwc`, `mwb`, `mwa`, `bwa`, `bwb`, `ir`, `kl`, `rdt`, `ki`, `at`, and `ac`. The module has two case statements that assign the values of `w[0:7]` and `w[8:15]` based on the input combinations. If the input combination does not match any specified cases, the default action is to reset `w` to 8'b0.\n\n Module header:\n\nmodule bus_w(input mwc, mwb, mwa,input bwa, bwb,input [0:15] ir,input [0:15] kl,input [0:15] rdt,input [0:15] ki,input [0:15] at,input [0:15] ac,input [0:15] a,output [0:15] w);\n [/INST]\n", "output": "always @ (*) begin \n  case ({bwb, mwc, mwb, mwa}) \n  4'b0000 : w[0:7] = a[0:7]; \n  4'b0001 : w[0:7] = ac[0:7]; \n  4'b0010 : w[0:7] = at[0:7]; \n  4'b0011 : w[0:7] = ki[0:7]; \n  4'b0100 : w[0:7] = 8'd0; \n  4'b0101 : w[0:7] = rdt[0:7]; \n  4'b0110 : w[0:7] = kl[0:7]; \n  4'b0111 : w[0:7] = ir[0:7]; \n  default : w[0:7] = 8'd0; \n  endcase \n  case ({bwa, mwc, mwb, mwa}) \n  4'b0000 : w[8:15] = a[8:15]; \n  4'b0001 : w[8:15] = ac[8:15]; \n  4'b0010 : w[8:15] = at[8:15]; \n  4'b0011 : w[8:15] = ki[8:15]; \n  4'b0100 : w[8:15] = ac[0:7]; \n  4'b0101 : w[8:15] = rdt[8:15]; \n  4'b0110 : w[8:15] = kl[8:15]; \n  4'b0111 : w[8:15] = ir[8:15]; \n  default : w[8:15] = 8'd0; \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a 2-bit full adder, which takes three inputs (x, y, Cin) and produces two outputs (Cout, s). It calculates the sum (s) and the carry-out (Cout) of the addition using logical operations. The sum (s) is computed based on the inputs and the carry-in (Cin), while the carry-out (Cout) is based on the inputs and the carry-in (Cin). The module essentially performs the functionality of a full adder with two inputs and an additional carry input.\n\n Module header:\n\nmodule full_adder_2(x, y, Cin, Cout, s);\n [/INST]\n", "output": "input x, y, Cin; \n  output Cout, s; \n  assign Cout = (x & y) | (x & Cin) | (y & Cin); \n  assign s = (~x & ~y & Cin) | (~x & y & ~Cin) | \n  (x & y & Cin) | (x & ~y & ~Cin); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `negedgedet` detects the negative edge of the input signal `in` using the clock signal `clk`. It maintains a shift register `sr` of size 4 and an output `out` that reflects the detected negative edge. Upon every clock edge, the module shifts the values in the shift register and updates the least significant bit with the current input value. If the second and third bits of the shift register represent a falling edge (i.e., 01), the output `out` is set to 1; otherwise, it is set to 0.\n\n Module header:\n\nmodule negedgedet(input clk,input in,output out);\n [/INST]\n", "output": "reg outreg; \n  reg [3:0] sr; \n  initial sr = 4'b0000; \n  assign out = outreg; \n  always @(*) begin \n  outreg = 0; \n  if((sr[2] == 0) && (sr[3] == 1)) \n  outreg = 1; \n  end \n  always @(posedge clk) begin \n  sr[3] <= sr[2]; \n  sr[2] <= sr[1]; \n  sr[1] <= sr[0]; \n  sr[0] <= in; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a Wishbone stream reader configuration module. It has inputs for the Wishbone bus signals and outputs the corresponding acknowledgments and error signals. It also has control signals for enabling and disabling the module. The module continuously monitors and updates the start address, buffer size, burst size, and IRQ based on the Wishbone signals. Additionally, it sets the busy signal and responds to the reset signal.\n\n Module header:\n\nmodule wb_stream_reader_cfg #(parameter WB_AW = 32,parameter WB_DW = 32) (input wb_clk_i,input wb_rst_i,input [4:0] wb_adr_i,input [WB_DW-1:0] wb_dat_i,input [WB_DW/8-1:0] wb_sel_i,input wb_we_i ,input wb_cyc_i,input wb_stb_i,input [2:0] wb_cti_i,input [1:0] wb_bte_i,output [WB_DW-1:0] wb_dat_o,output reg wb_ack_o,output wb_err_o,output reg irq,input busy,output reg enable,input [WB_DW-1:0] tx_cnt,output reg [WB_AW-1:0] start_adr,output reg [WB_AW-1:0] buf_size,output reg [WB_AW-1:0] burst_size);\n [/INST]\n", "output": "reg busy_r; \n  always @(posedge wb_clk_i) \n  if (wb_rst_i) \n  busy_r <= 0; \n  else \n  busy_r <= busy; \n  assign wb_dat_o = wb_adr_i[4:2] == 0 ? {{(WB_DW-2){1'b0}}, irq, busy} : \n  wb_adr_i[4:2] == 1 ? start_adr : \n  wb_adr_i[4:2] == 2 ? buf_size : \n  wb_adr_i[4:2] == 3 ? burst_size : \n  wb_adr_i[4:2] == 4 ? tx_cnt*4 : \n  0; \n  always @(posedge wb_clk_i) begin \n  if (wb_ack_o) \n  wb_ack_o <= 0; \n  else if (wb_cyc_i & wb_stb_i & !wb_ack_o) \n  wb_ack_o <= 1; \n  enable <= 0; \n  if (wb_stb_i & wb_cyc_i & wb_we_i & wb_ack_o) begin \n  case (wb_adr_i[4:2]) \n  0 : begin \n  if (wb_dat_i[0]) enable <= 1; \n  if (wb_dat_i[1]) irq <= 0; \n  end \n  1 : start_adr <= wb_dat_i; \n  2 : buf_size <= wb_dat_i; \n  3 : burst_size <= wb_dat_i; \n  default : ; \n  endcase \n  end \n  if (!busy & busy_r) \n  irq <= 1; \n  if (wb_rst_i) begin \n  wb_ack_o <= 0; \n  enable <= 1'b0; \n  start_adr <= 0; \n  buf_size <= 0; \n  burst_size <= 0; \n  irq <= 0; \n  end \n  end \n  assign wb_err_o = 0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module detects if the input signal `a` is zero. It takes an input of width `WIDTH` and outputs a single bit `y` which is set to true when the input signal is zero, and false otherwise.\n\n Module header:\n\nmodule zerodetect #(parameter WIDTH=32) (input [WIDTH-1:0] a,output y);\n [/INST]\n", "output": "assign y= (a==0); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is designed to interface with a Nios II processor for on-chip instruction and data trace. It has inputs such as the clock signal, CPU address, read and write signals, and control signals. The module has outputs for the address and data trace information. The module implements logic to handle different types of CPU read and write operations, based on the control signals and CPU activity. It also manages the trace control signals and the state of the trace data. The logic is sensitive to the rising edge of the clock signal and the falling edge of the jrst_n signal to determine its behavior.\n\n Module header:\n\nmodule limbus_nios2_qsys_0_nios2_oci_dtrace (clk,cpu_d_address,cpu_d_read,cpu_d_readdata,cpu_d_wait,cpu_d_write,cpu_d_writedata,jrst_n,trc_ctrl,atm,dtm);\n [/INST]\n", "output": "output [ 35: 0] atm; \n  output [ 35: 0] dtm; \n  input clk; \n  input [ 28: 0] cpu_d_address; \n  input cpu_d_read; \n  input [ 31: 0] cpu_d_readdata; \n  input cpu_d_wait; \n  input cpu_d_write; \n  input [ 31: 0] cpu_d_writedata; \n  input jrst_n; \n  input [ 15: 0] trc_ctrl; \n  reg [ 35: 0] atm ; \n  wire [ 31: 0] cpu_d_address_0_padded; \n  wire [ 31: 0] cpu_d_readdata_0_padded; \n  wire [ 31: 0] cpu_d_writedata_0_padded; \n  reg [ 35: 0] dtm ; \n  wire record_load_addr; \n  wire record_load_data; \n  wire record_store_addr; \n  wire record_store_data; \n  wire [ 3: 0] td_mode_trc_ctrl; \n  assign cpu_d_writedata_0_padded = cpu_d_writedata | 32'b0; \n  assign cpu_d_readdata_0_padded = cpu_d_readdata | 32'b0; \n  assign cpu_d_address_0_padded = cpu_d_address | 32'b0; \n  limbus_nios2_qsys_0_nios2_oci_td_mode limbus_nios2_qsys_0_nios2_oci_trc_ctrl_td_mode \n (.ctrl (trc_ctrl[8 : 0]),.td_mode (td_mode_trc_ctrl)); \n  assign {record_load_addr, record_store_addr, \n  record_load_data, record_store_data} = td_mode_trc_ctrl; \n  always @(posedge clk or negedge jrst_n) \n  begin \n  if (jrst_n == 0) \n  begin \n  atm <= 0; \n  dtm <= 0; \n  end \n  else if (0) \n  begin \n  if (cpu_d_write & ~cpu_d_wait & record_store_addr) \n  atm <= {4'b0101, cpu_d_address_0_padded}; \n  else if (cpu_d_read & ~cpu_d_wait & record_load_addr) \n  atm <= {4'b0100, cpu_d_address_0_padded}; \n  else \n  atm <= {4'b0000, cpu_d_address_0_padded}; \n  if (cpu_d_write & ~cpu_d_wait & record_store_data) \n  dtm <= {4'b0111, cpu_d_writedata_0_padded}; \n  else if (cpu_d_read & ~cpu_d_wait & record_load_data) \n  dtm <= {4'b0110, cpu_d_readdata_0_padded}; \n  else \n  dtm <= {4'b0000, cpu_d_readdata_0_padded}; \n  end \n  else \n  begin \n  atm <= 0; \n  dtm <= 0; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a permutation box for the PRESENT block cipher algorithm. It takes a 64-bit input idat and produces a 64-bit output odat. The input and output bits are rearranged based on specific assignments for each bit position, effectively permuting the input bits to produce the output.\n\n Module header:\n\nmodule PRESENT_ENCRYPT_PBOX(output [63:0] odat,input [63:0] idat);\n [/INST]\n", "output": "assign odat[0 ] = idat[0 ]; \n assign odat[16] = idat[1 ]; \n assign odat[32] = idat[2 ]; \n assign odat[48] = idat[3 ]; \n assign odat[1 ] = idat[4 ]; \n assign odat[17] = idat[5 ]; \n assign odat[33] = idat[6 ]; \n assign odat[49] = idat[7 ]; \n assign odat[2 ] = idat[8 ]; \n assign odat[18] = idat[9 ]; \n assign odat[34] = idat[10]; \n assign odat[50] = idat[11]; \n assign odat[3 ] = idat[12]; \n assign odat[19] = idat[13]; \n assign odat[35] = idat[14]; \n assign odat[51] = idat[15]; \n assign odat[4 ] = idat[16]; \n assign odat[20] = idat[17]; \n assign odat[36] = idat[18]; \n assign odat[52] = idat[19]; \n assign odat[5 ] = idat[20]; \n assign odat[21] = idat[21]; \n assign odat[37] = idat[22]; \n assign odat[53] = idat[23]; \n assign odat[6 ] = idat[24]; \n assign odat[22] = idat[25]; \n assign odat[38] = idat[26]; \n assign odat[54] = idat[27]; \n assign odat[7 ] = idat[28]; \n assign odat[23] = idat[29]; \n assign odat[39] = idat[30]; \n assign odat[55] = idat[31]; \n assign odat[8 ] = idat[32]; \n assign odat[24] = idat[33]; \n assign odat[40] = idat[34]; \n assign odat[56] = idat[35]; \n assign odat[9 ] = idat[36]; \n assign odat[25] = idat[37]; \n assign odat[41] = idat[38]; \n assign odat[57] = idat[39]; \n assign odat[10] = idat[40]; \n assign odat[26] = idat[41]; \n assign odat[42] = idat[42]; \n assign odat[58] = idat[43]; \n assign odat[11] = idat[44]; \n assign odat[27] = idat[45]; \n assign odat[43] = idat[46]; \n assign odat[59] = idat[47]; \n assign odat[12] = idat[48]; \n assign odat[28] = idat[49]; \n assign odat[44] = idat[50]; \n assign odat[60] = idat[51]; \n assign odat[13] = idat[52]; \n assign odat[29] = idat[53]; \n assign odat[45] = idat[54]; \n assign odat[61] = idat[55]; \n assign odat[14] = idat[56]; \n assign odat[30] = idat[57]; \n assign odat[46] = idat[58]; \n assign odat[62] = idat[59]; \n assign odat[15] = idat[60]; \n assign odat[31] = idat[61]; \n assign odat[47] = idat[62]; \n assign odat[63] = idat[63]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an input/output buffer with differential signaling support. It has parameters for setting slew rates, drive strengths, and termination configurations. The module handles the input signals and translates them into the appropriate output signals based on the input conditions and control signals. It incorporates conditional assignments based on the input conditions and control signals to drive the output signals. The module also has a built-in case statement to handle different input combinations and produce the corresponding output value.\n\n Module header:\n\nmodule IOBUFDS_M_VPR (input I,input T,output O,input IOPAD_$inp,output IOPAD_$out,input IB,output OB);\n [/INST]\n", "output": "parameter [0:0] LVCMOS12_LVCMOS15_LVCMOS18_LVCMOS25_LVCMOS33_LVTTL_SLEW_FAST = 1'b0; \n  parameter [0:0] LVCMOS12_LVCMOS15_LVCMOS18_LVCMOS25_LVCMOS33_LVTTL_SSTL135_SSTL15_SLEW_SLOW = 1'b0; \n  parameter [0:0] LVCMOS12_LVCMOS15_LVCMOS18_SSTL135_SSTL15_STEPDOWN = 1'b0; \n  parameter [0:0] LVCMOS15_SSTL15_DRIVE_I16_I_FIXED = 1'b0; \n  parameter [0:0] LVDS_25_DRIVE_I_FIXED = 1'b0; \n  parameter [0:0] LVDS_25_OUT = 1'b0; \n  parameter [0:0] SSTL135_DRIVE_I_FIXED = 1'b0; \n  parameter [0:0] SSTL135_SSTL15_SLEW_FAST = 1'b0; \n  parameter [0:0] TMDS_33_DRIVE_I_FIXED = 1'b0; \n  parameter [0:0] TMDS_33_OUT = 1'b0; \n  parameter [0:0] LVDS_25_SSTL135_SSTL15_IN_DIFF = 1'b0; \n  parameter [0:0] TMDS_33_IN_DIFF = 1'b0; \n  parameter [0:0] IN_TERM_UNTUNED_SPLIT_40 = 1'b0; \n  parameter [0:0] IN_TERM_UNTUNED_SPLIT_50 = 1'b0; \n  parameter [0:0] IN_TERM_UNTUNED_SPLIT_60 = 1'b0; \n  parameter [0:0] PULLTYPE_PULLUP = 1'b0; \n  parameter [0:0] PULLTYPE_PULLDOWN = 1'b0; \n  parameter [0:0] PULLTYPE_NONE = 1'b0; \n  parameter [0:0] PULLTYPE_KEEPER = 1'b0; \n  parameter PULLTYPE = \"\"; \n  parameter IOSTANDARD = \"\"; \n  parameter SLEW = \"\"; \n  reg O; \n  always @(*) case ({IB, IOPAD_$inp}) \n  2'b00: O <= 1'bX; \n  2'b01: O <= 1'b1; \n  2'b10: O <= 1'b0; \n  2'b11: O <= 1'bX; \n  endcase \n  assign IOPAD_$out = (T == 1'b0) ? I : 1'bz; \n  assign OB = (T == 1'b0) ? !I : 1'bz; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a design for a RGMII interface, which is a standard for connecting Ethernet MAC (Media Access Control) to a PHY (Physical Layer) chip. The module contains logic to handle the transmission and reception of data and control signals between the MAC and PHY chips. It handles the synchronization of data and control signals between the MAC and PHY, as well as collision detection and resolution. The module also manages the clock signals for transmission and reception.\n\n Module header:\n\nmodule rgmii (input wire reset,input wire generated_clk,output wire [3:0] phy_txd_rising,output wire [3:0] phy_txd_falling,output wire phy_tx_ctl_rising,output wire phy_tx_ctl_falling,output wire phy_gtx_clk,input wire [3:0] phy_rxd_rising,input wire [3:0] phy_rxd_falling,input wire phy_rx_ctl_rising,input wire phy_rx_ctl_falling,input wire phy_rx_clk,input wire mac_tx_er,input wire [7:0] mac_txd,input wire mac_tx_en,output wire mac_tx_clk,output wire mac_col,output wire [7:0] mac_rxd,output wire mac_rx_er,output wire mac_rx_clk,output wire mac_crs,output wire mac_rx_dv);\n [/INST]\n", "output": "assign phy_txd_rising = mac_txd[3:0]; \n assign phy_txd_falling = mac_txd[7:4]; \n assign phy_tx_ctl_rising = mac_tx_en; \n assign phy_tx_ctl_falling = mac_tx_en ^ mac_tx_er; \n assign phy_gtx_clk = generated_clk; \n assign mac_col = (mac_crs & mac_tx_en) | (mac_rx_dv & mac_tx_en); \n assign mac_rxd [3:0] = phy_rxd_rising; \n assign mac_rxd [7:4] = phy_rxd_falling; \n assign mac_rx_er = phy_rx_ctl_falling ^ phy_rx_ctl_rising; \n assign mac_rx_clk = phy_rx_clk; \n assign mac_crs = mac_rx_dv | ( mac_rx_er && mac_rxd == 8'hFF ) | ( mac_rx_er && mac_rxd == 8'h0E ) | ( mac_rx_er && mac_rxd == 8'h0F ) | ( mac_rx_er && mac_rxd == 8'h1F ); \n assign mac_rx_dv = phy_rx_ctl_rising; \n assign mac_tx_clk = generated_clk; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a UART (Universal Asynchronous Receiver/Transmitter) light transmission controller. It implements a state machine with three states: IDLE, LOAD, and TRANSMITTING. The module controls the transmission and clearing of data based on the availability of data in the FIFO buffer and the completion of data transmission. It also handles the state transitions based on the input conditions and the clock signals. The module provides control signals for FIFO fullness and emptiness, FIFO read and write enable, as well as transmission and clearing signals.\n\n Module header:\n\nmodule uart_light_tx_ctrl #(parameter STATE_COUNT = 2,parameter IDLE = 2'b00,parameter LOAD = 2'b01,parameter TRANSMITTING = 2'b10)(input wire reset,input wire clk_tx,input wire word_ready,output wire fifo_tx_full,output wire fifo_tx_empty,input wire frame_done,output reg transmit,output reg clear,output reg fifo_read_enable,input wire fifo_full,input wire fifo_empty,output wire fifo_write_enable);\n [/INST]\n", "output": "reg [STATE_COUNT-1:0] state_cur, state_next; \n  assign fifo_tx_full = fifo_full; \n  assign fifo_tx_empty = fifo_empty; \n  assign fifo_write_enable = word_ready & (~fifo_full); \n  always @(*) begin \n  transmit = 1'b0; \n  clear = 1'b0; \n  fifo_read_enable = 1'b0; \n  state_next = IDLE; \n  case(state_cur) \n  IDLE: \n  if (fifo_empty == 1'b0) begin \n  state_next = LOAD; \n  end \n  LOAD: \n  begin \n  fifo_read_enable = 1'b1; \n  state_next = TRANSMITTING; \n  end \n  TRANSMITTING: \n  if(frame_done) begin \n  clear = 1'b1; \n  state_next = IDLE; \n  end \n  else begin \n  transmit = 1'b1; \n  state_next = TRANSMITTING; \n  end \n  default: state_next = IDLE; \n  endcase \n  end \n  always @(posedge clk_tx, posedge reset) begin \n  if(reset) begin \n  state_cur <= IDLE; \n  end \n  else begin \n  state_cur <= state_next; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, \"top_reloj_digital_v2,\" interfaces with various components of a digital clock system. It includes input and output ports for data communication, controls a microcontroller module, handles keyboard input/output, interfaces with a VGA controller, and manages data transfer between different components. The module also contains logic to route different signals based on the value of the \"port_id.\" It enables communication and control between the different parts of the digital clock system.\n\n Module header:\n\nmodule top_reloj_digital_v2 (input wire clk, reset,input wire ps2data,input wire ps2clk,inout [7:0] dato,output wire AD, CS, WR, RD,output wire alarma_sonora,output wire [7:0] RGB,output wire hsync, vsync);\n [/INST]\n", "output": "reg [7:0]in_port; \n wire [7:0]out_port; \n wire [7:0]port_id; \n wire write_strobe; \n wire k_write_strobe; \n wire read_strobe; \n wire interrupt; \n wire [7:0]out_seg_hora,out_min_hora,out_hora_hora; \n wire [7:0]out_dia_fecha,out_mes_fecha,out_jahr_fecha; \n wire [7:0]out_seg_timer,out_min_timer,out_hora_timer; \n wire fin_lectura_escritura; \n wire [7:0] out_dato; \n wire [7:0] ascii_code; \n assign interrupt = 1'b0; \n microcontrolador instancia_microcontrolador \n (.clk(clk),.reset(reset),.interrupt(interrupt),.in_port(in_port),.write_strobe(write_strobe),.k_write_strobe(k_write_strobe),.read_strobe(read_strobe),.interrupt_ack(),.port_id(port_id),.out_port(out_port)); \n escritor_lector_rtc_2 instancia_escritor_lector_rtc_2 \n (.clk(clk),.reset(reset),.in_dato(out_port),.port_id(port_id),.write_strobe(write_strobe),.k_write_strobe(k_write_strobe),.read_strobe(read_strobe),.reg_a_d(AD),.reg_cs(CS),.reg_rd(RD),.reg_wr(WR),.out_dato(out_dato),.flag_done(fin_lectura_escritura),.dato(dato)); \n controlador_teclado_ps2 instancia_controlador_teclado_ps2 \n (.clk(clk),.reset(reset),.ps2data(ps2data),.ps2clk(ps2clk),.port_id(port_id),.read_strobe(read_strobe),.ascii_code(ascii_code)); \n controlador_VGA instancia_controlador_VGA \n (.clock(clk),.reset(reset),.in_dato(out_port),.port_id(port_id),.write_strobe(write_strobe),.k_write_strobe(k_write_strobe),.out_seg_hora(out_seg_hora),.out_min_hora(out_min_hora),.out_hora_hora(out_hora_hora),.out_dia_fecha(out_dia_fecha),.out_mes_fecha(out_mes_fecha),.out_jahr_fecha(out_jahr_fecha),.out_seg_timer(out_seg_timer),.out_min_timer(out_min_timer),.out_hora_timer(out_hora_timer),.alarma_sonora(alarma_sonora),.hsync(hsync),.vsync(vsync),.RGB(RGB)); \n always@(posedge clk) \n begin \n  case (port_id) \n  8'h0F : in_port <= fin_lectura_escritura; \n  8'h10 : in_port <= out_dato; \n  8'h02 : in_port <= ascii_code; \n  8'h12 : in_port <= out_seg_hora; \n  8'h13 : in_port <= out_min_hora; \n  8'h14 : in_port <= out_hora_hora; \n  8'h15 : in_port <= out_dia_fecha; \n  8'h16 : in_port <= out_mes_fecha; \n  8'h17 : in_port <= out_jahr_fecha; \n  8'h18 : in_port <= out_seg_timer; \n  8'h19 : in_port <= out_min_timer; \n  8'h1A : in_port <= out_hora_timer; \n  default : in_port <= 8'bXXXXXXXX; \n  endcase \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a UART transmitter. It has a state machine that controls the transmission of data. It receives data from the input interface and outputs the serialized data on the serialOut wire. The module also has a baud rate generator for generating the required clock for serial transmission. The state machine manages the shifting of the data bits and controls the timing of the transmission. The module also handles the memory interface to read and write data.\n\n Module header:\n\nmodule uartTx (input wire clk,input wire resetn,input wire enable,input wire mem_valid,output wire mem_ready,input wire mem_instr,input wire [3:0] mem_wstrb,input wire [31:0] mem_wdata,input wire [31:0] mem_addr,output wire [31:0] mem_rdata,input wire baudClock,output wire probe,output reg serialOut);\n [/INST]\n", "output": "reg [7:0] shifter; \n  reg [7:0] buffer; \n  reg [7:0] state; \n  reg [3:0] bitCount; \n  reg bufferEmpty; \n  reg rdy; \n  wire baudRateClock; \n BaudRateGenerator baudRateGenerator(.clk(clk),.resetn(resetn),.baudClock(baudClock),.bitStart(bitStart),.probe(probe)); \n  always @ (posedge clk or negedge resetn) begin \n  if (!resetn) begin \n  state <= 0; \n  buffer <= 0; \n  bufferEmpty <= 1; \n  shifter <= 0; \n  serialOut <= 1; \n  bitCount <= 0; \n  rdy <= 0; \n  end else begin \n  if (mem_valid & enable) begin \n  if ((mem_wstrb[0] == 1) && (bufferEmpty == 1)) begin \n  buffer <= mem_wdata[7:0]; \n  bufferEmpty <= 0; \n  end \n  rdy <= 1; \n  end else begin \n  rdy <= 0; \n  end \n  if (bitStart) begin \n  case (state) \n  0 : begin \n  if (bufferEmpty == 0) begin \n  shifter <= buffer; \n  bufferEmpty <= 1; \n  bitCount <= 8; \n  serialOut <= 0; \n  state <= 1; \n  end \n  end \n  1 : begin \n  if (bitCount > 0) begin \n  serialOut <= shifter[0]; \n  bitCount <= bitCount - 4'd1; \n  shifter <= shifter >> 1; \n  end else begin \n  serialOut <= 1; \n  state <= 2; \n  end \n  end \n  2 : begin \n  serialOut <= 1; \n  state <= 0; \n  end \n  default : ; \n  endcase \n  end \n  end \n  end \n  assign mem_rdata = enable ? bufferEmpty : 1'b0; \n  assign mem_ready = enable ? rdy : 1'b0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a processor control unit that handles interrupts, CPU operations, and memory access. It has inputs for the clock, reset, interrupt signals, CPU operations, and data, and outputs for the jump enable, CPU register, and jump address. The module utilizes memory to store data and uses combinatorial and sequential logic to handle interrupts, CPU operations, and memory accesses. The jump address output is determined based on the interrupt signal and CPU operations.\n\n Module header:\n\nmodule pc0(clk,rst,interrupt_signal,cp_oper,cp_cd,return_addr,GPR,jump_en,CPR,jump_addr);\n [/INST]\n", "output": "input clk,rst; \n  input [1:0] interrupt_signal; \n  input [1:0] cp_oper; \n  input [4:0] cp_cd; \n  input [31:0] return_addr,GPR; \n  output jump_en; \n  output [31:0] CPR; \n  output [31:0] jump_addr; \n  reg [31:0] mem [31:0]; \n  wire inter; \n  assign inter=|interrupt_signal; \n  always @(negedge clk or posedge rst or posedge inter) \n  begin \n  if(rst) \n  begin \n  mem[0] <=32'b0;mem[1] <=32'b0;mem[2] <=32'b0;mem[3] <=32'b0; \n  mem[4] <=32'b0;mem[5] <=32'b0;mem[6] <=32'b0;mem[7] <=32'b0; \n  mem[8] <=32'b0;mem[9] <=32'b0;mem[10]<=32'b0;mem[11]<=32'b0; \n  mem[12]<=32'b0;mem[13]<=32'b0;mem[14]<=32'b0;mem[15]<=32'b0; \n  mem[16]<=32'b0;mem[17]<=32'b0;mem[18]<=32'b0;mem[19]<=32'b0; \n  mem[20]<=32'b0;mem[21]<=32'b0;mem[22]<=32'b0;mem[23]<=32'b0; \n  mem[24]<=32'b0;mem[25]<=32'b0;mem[26]<=32'b0;mem[27]<=32'b0; \n  mem[28]<=32'b0;mem[29]<=32'b0;mem[30]<=32'b0;mem[31]<=32'b0; \n  end \n  else if(inter) \n  begin \n  mem[13] <= {30'b0,interrupt_signal}; \n  mem[14] <= return_addr; \n  end \n  else if(cp_oper[0]) \n  mem[cp_cd]<=GPR; \n  end \n  assign CPR = mem[cp_cd]; \n  assign jump_en = inter | cp_oper[1]; \n  assign jump_addr = (inter)?mem[1]:mem[14]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, SB_GB, is a simple global buffer that forwards the input signal, USER_SIGNAL_TO_GLOBAL_BUFFER, to the output, GLOBAL_BUFFER_OUTPUT. Additionally, it contains a timing constraint block that specifies the timing relationship between the input and output signals. If the TIMING macro is defined, the timing constraint is enforced, ensuring a specific timing relationship between the input and output signals.\n\n Module header:\n\nmodule SB_GB (input USER_SIGNAL_TO_GLOBAL_BUFFER,output GLOBAL_BUFFER_OUTPUT);\n [/INST]\n", "output": "assign GLOBAL_BUFFER_OUTPUT = USER_SIGNAL_TO_GLOBAL_BUFFER; \n `ifdef TIMING \n specify \n  (USER_SIGNAL_TO_GLOBAL_BUFFER => GLOBAL_BUFFER_OUTPUT) = (0:0:0, 0:0:0); \n endspecify \n `endif \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module is a control unit for a processor. It determines stall and forwarding signals based on various inputs. It matches the input ports with specific control signals and sets corresponding flags for stall and forwarding. The forwarding signals determine which input to forward to the output based on specific conditions. It also sets stall signals for the memory, exception, execution, and instruction decode stages based on various conditions.\n\n Module header:\n\nmodule ada_hazard(input [4:0] id_gpr_port_a,input [4:0] id_gpr_port_b,input [4:0] ex_gpr_wa,input [4:0] mem_gpr_wa,input [4:0] wb_gpr_wa,input ex_gpr_we,input mem_gpr_we,input wb_gpr_we,input if_mem_request_stall,input ex_data_read,input mem_request_stall,input if_exception_stall,input id_exception_stall,input ex_exception_stall,input mem_exception_stall,input ex_exu_stall,output [1:0] forward_port_a_select,output [1:0] forward_port_b_select,output if_stall,output id_stall,output ex_stall,output mem_stall,output wb_stall);\n [/INST]\n", "output": "wire id_port_a_is_zero; \n  wire id_port_b_is_zero; \n  wire id_ex_port_a_match; \n  wire id_ex_port_b_match; \n  wire id_mem_port_a_match; \n  wire id_mem_port_b_match; \n  wire id_wb_port_a_match; \n  wire id_wb_port_b_match; \n  wire id_stall_1; \n  wire id_stall_2; \n  wire id_forward_1; \n  wire id_forward_2; \n  wire id_forward_3; \n  wire id_forward_4; \n  wire id_forward_5; \n  wire id_forward_6; \n  assign id_port_a_is_zero = (id_gpr_port_a == 5'b0); \n  assign id_port_b_is_zero = (id_gpr_port_b == 5'b0); \n  assign id_ex_port_a_match = (id_gpr_port_a == ex_gpr_wa) & (~id_port_a_is_zero) & ex_gpr_we; \n  assign id_mem_port_a_match = (id_gpr_port_a == mem_gpr_wa) & (~id_port_a_is_zero) & mem_gpr_we; \n  assign id_wb_port_a_match = (id_gpr_port_a == wb_gpr_wa) & (~id_port_a_is_zero) & wb_gpr_we; \n  assign id_ex_port_b_match = (id_gpr_port_b == ex_gpr_wa) & (~id_port_b_is_zero) & ex_gpr_we; \n  assign id_mem_port_b_match = (id_gpr_port_b == mem_gpr_wa) & (~id_port_b_is_zero) & mem_gpr_we; \n  assign id_wb_port_b_match = (id_gpr_port_b == wb_gpr_wa) & (~id_port_b_is_zero) & wb_gpr_we; \n  assign id_stall_1 = id_ex_port_a_match & ex_data_read; \n  assign id_stall_2 = id_ex_port_b_match & ex_data_read; \n  assign id_forward_1 = id_ex_port_a_match & ~ex_data_read; \n  assign id_forward_2 = id_ex_port_b_match & ~ex_data_read; \n  assign id_forward_3 = id_mem_port_a_match; \n  assign id_forward_4 = id_mem_port_b_match; \n  assign id_forward_5 = id_wb_port_a_match; \n  assign id_forward_6 = id_wb_port_b_match; \n  assign wb_stall = mem_stall; \n  assign mem_stall = mem_exception_stall | mem_request_stall; \n  assign ex_stall = ex_exception_stall | ex_exu_stall | mem_stall; \n  assign id_stall = id_exception_stall | id_stall_1 | id_stall_2 | ex_stall ; \n  assign if_stall = if_exception_stall | if_mem_request_stall | id_stall; \n  assign forward_port_a_select = (id_forward_1) ? 2'b01 : ((id_forward_3) ? 2'b10 : ((id_forward_5) ? 2'b11 : 2'b00)); \n  assign forward_port_b_select = (id_forward_2) ? 2'b01 : ((id_forward_4) ? 2'b10 : ((id_forward_6) ? 2'b11 : 2'b00)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module defines a debug register with a specified data bus width. It has inputs for the data to be written to the register, a write enable signal, clock signal, reset signal, and a default value. The module contains an always block that triggers on the positive edge of the clock signal. When the reset signal is asserted, the output data is reset to the default value. Otherwise, if the write enable signal is asserted, the output data is updated with the input data. The output is the updated data bus.\n\n Module header:\n\nmodule dbg_register(DataIn, DataOut, Write, Clk, Reset, Default);\n [/INST]\n", "output": "parameter WIDTH = 8; \n input [WIDTH-1:0] DataIn; \n input Write; \n input Clk; \n input Reset; \n input [WIDTH-1:0] Default; \n output [WIDTH-1:0] DataOut; \n reg [WIDTH-1:0] DataOut; \n always @ (posedge Clk) \n begin \n  if(Reset) \n  DataOut[WIDTH-1:0]<=#1 Default; \n  else \n  begin \n  if(Write) \n  DataOut[WIDTH-1:0]<=#1 DataIn[WIDTH-1:0]; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a memory module, specifically a 256-byte RAM. It provides read and write operations. When the write enable (WE) signal is asserted, it writes the data (WD) into the RAM at the specified address (A). On the rising edge of the clock signal, if the WE signal is de-asserted, it writes 0 into the RAM at the specified address (A). Additionally, it reads the data from the RAM at the specified address (A) and assigns it to the output (RD) if the address is non-zero, otherwise, it sets the output (RD) to 0.\n\n Module header:\n\nmodule dmem(output [31:0] RD,input [31:0] A, WD,input WE, clk);\n [/INST]\n", "output": "reg [31:0] RAM [0:255]; \n  assign RD = (A != 0) ? RAM[A[7:0]] : 0; \n  always @ (posedge clk) \n  if (WE) \n  RAM[A[7:0]] <= WD; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, \"gen_test4\", uses a generate statement to create a loop that iterates through 3 input bits. It calculates the previous value and assigns it to a temporary wire. It then checks if it is the first input and assigns the first input value, or combines the previous value and the current input. Finally, it assigns the output value based on the temporary wire.\n\n Module header:\n\nmodule gen_test4(a, b);\n [/INST]\n", "output": "input [3:0] a; \n output [3:0] b; \n genvar i; \n generate \n  for (i=0; i < 3; i=i+1) begin : foo \n  localparam PREV = i - 1; \n  wire temp; \n  if (i == 0) \n  assign temp = a[0]; \n  else \n  assign temp = foo[PREV].temp & a[i]; \n  assign b[i] = temp; \n  end \n endgenerate \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module serves as a test environment for the messbauer system. It utilizes the global clock and reset signals, and features two messbauer generators and associated diff discriminators. The module also contains a counter for the period done signal. On the positive edge of the global clock, the module checks the state of the global reset and increments the counter accordingly. When the counter reaches a specific value, it sets the internal reset signal to control the operation of the messbauer system.\n\n Module header:\n\nmodule messbauer_test_environment (input wire global_clock,input wire global_reset,output wire v1_channel,output wire v1_start,output wire [11:0] v1_velocity_reference,output wire v1_lower_threshold,output wire v1_upper_threshold,output wire v2_channel,output wire v2_start,output wire [11:0] v2_velocity_reference,output wire v2_lower_threshold,output wire v2_upper_threshold);\n [/INST]\n", "output": "reg internal_reset; \n reg [5:0] counter; \n messbauer_generator #(.CHANNEL_NUMBER(512), .CHANNEL_TYPE(1)) v1_generator(.aclk(global_clock), .areset_n(global_reset & internal_reset), .start(v1_start), .channel(v1_channel)); \n messbauer_saw_tooth_generator #(.DIRECT_SLOPE_DURATION(512)) v1_velocity_reference_generator(.clk(global_clock), .areset_n(global_reset & internal_reset), .out_value(v1_velocity_reference)); \n messbauer_diff_discriminator_signals v1_diff_discriminator(.aclk(global_clock), .areset_n(global_reset & internal_reset), .channel(v1_channel), .lower_threshold(v1_lower_threshold), .upper_threshold(v1_upper_threshold)); \n messbauer_generator #(.CHANNEL_NUMBER(512), .CHANNEL_TYPE(2)) v2_generator(.aclk(global_clock), .areset_n(global_reset & internal_reset), .start(v2_start), .channel(v2_channel)); \n messbauer_saw_tooth_generator #(.DIRECT_SLOPE_DURATION(512)) v2_velocity_reference_generator(.clk(global_clock), .areset_n(global_reset & internal_reset), .out_value(v2_velocity_reference)); \n messbauer_diff_discriminator_signals v2_diff_discriminator(.aclk(global_clock), .areset_n(global_reset & internal_reset), .channel(v2_channel), .lower_threshold(v2_lower_threshold), .upper_threshold(v2_upper_threshold)); \n always @(posedge global_clock) \n begin \n  if(~global_reset) \n  begin \n  internal_reset <= 1; \n  counter <= 0; \n  end \n  if(counter < 16) \n  counter <= counter + 1'b1; \n  if(counter >= 16 && counter < 32) \n  begin \n  counter <= counter + 1'b1; \n  internal_reset <= 0; \n  end \n  if(counter == 32) \n  internal_reset <= 1; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a wildcard Ternary Content Addressable Memory (TCAM). It compares the input `cmp_din` against the stored data `cam_data` and `cam_data_mask` using a wildcard comparison algorithm. The match address `match_addr` and `busy` signals are generated based on the comparison result. The module also includes functionality for writing data into the TCAM and clearing the TCAM entries. Additionally, it has a `cmp_req` input and a `match` output for indicating a comparison request and result.\n\n Module header:\n\nmodule wildcard_tcam #(parameter CMP_WIDTH = 32,parameter DEPTH = 32,parameter DEPTH_BITS = 5,parameter ENCODE = 0,parameter CURRENT_TABLE_ID = 0)(input clk,input reset,input [CMP_WIDTH - 1 : 0] cmp_din,output busy,output match,output reg [DEPTH_BITS - 1 : 0] match_addr,input cmp_req,input we,input [`PRIO_WIDTH -1:0] tcam_addr,output reg [CMP_WIDTH-1:0]tcam_data_out,output reg [CMP_WIDTH-33:0] tcam_data_mask_out,input [CMP_WIDTH-1:0]tcam_data_in,input [CMP_WIDTH-33:0]tcam_data_mask_in);\n [/INST]\n", "output": "wire [DEPTH - 1 : 0] match_addr_unencoded; \n  reg [DEPTH - 1 : 0] match_addr_unencoded_reg; \n  wire [CMP_WIDTH - 1 : 0] stage1[DEPTH - 1 : 0]; \n  wire [CMP_WIDTH - 1 : 0] stage2[DEPTH - 1 : 0]; \n  reg [CMP_WIDTH - 1 : 0] cam_data[DEPTH - 1 : 0]; \n  reg [CMP_WIDTH - 33 : 0] cam_data_mask[DEPTH - 1 : 0]; \n  reg [DEPTH_BITS-1:0] prio; \n  wire [DEPTH - 1 : 0] match_addr_tmp; \n  reg [7:0] reg_addr_actions_d; \n  reg [7:0] clear_count; \n  always@(*) \n  if(tcam_addr < DEPTH) \n  begin \n  tcam_data_mask_out=cam_data_mask[tcam_addr] ; \n  tcam_data_out=cam_data[tcam_addr] ; \n  end \n  else begin \n  tcam_data_mask_out=0; \n  tcam_data_out=0; \n  end \n  always@(posedge clk) \n  if(reset) \n  clear_count<=0; \n  else if(clear_count==DEPTH) \n  clear_count<=clear_count; \n  else clear_count<=clear_count+1; \n  always@(posedge clk) \n  if(clear_count<DEPTH) \n  begin \n  cam_data[clear_count][CMP_WIDTH-1]<=1; \n  cam_data[clear_count][CMP_WIDTH-2:0]<=0; \n  cam_data_mask[clear_count]<=0; \n  end \n  else if(we) \n  begin \n  cam_data_mask[tcam_addr] <= tcam_data_mask_in; \n  cam_data[tcam_addr] <= tcam_data_in; \n  end \n  reg [CMP_WIDTH - 1 : 0] cmp_din_reg; \n  always@(posedge clk) \n  if(reset) \n  cmp_din_reg<=0; \n  else if(cmp_req) \n  cmp_din_reg<=cmp_din; \n  genvar n; \n  generate \n  for(n = DEPTH-1; n >= 0; n = n - 1) begin : gen_cmp \n  assign stage1[n] = cmp_din_reg ^ ~cam_data[n]; \n  assign stage2[n] = stage1[n] | cam_data_mask[n]; \n  assign match_addr_tmp[n]=&stage2[n]; \n  end \n  endgenerate \n  integer i; \n  always @(*) \n  begin match_addr=0; \n  if(|match_addr_tmp) \n  begin \n  for (i = 0; i <= DEPTH-1; i = i+1) begin \n  if (match_addr_tmp[i]) \n  match_addr = i[DEPTH_BITS-1:0]; \n  end \n  end \n  end \n  reg cmp_req_d1; \n  reg cmp_req_d2; \n  reg cmp_req_d3; \n  always@(posedge clk) \n  if(reset) \n  begin \n  cmp_req_d1<=0; \n  cmp_req_d2<=0; \n  cmp_req_d3<=0; \n  end \n  else \n  begin \n  cmp_req_d1<=cmp_req; \n  cmp_req_d2<=cmp_req_d1; \n  cmp_req_d3<=cmp_req_d2; \n  end \n  assign busy = 0; \n  assign match = (| match_addr_tmp) && cmp_req_d3; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a counter that can count up or down based on the inputs and the clock signal. It includes a debounce logic to eliminate glitches in the input signal. The counter value and the output are updated based on the input, debounce count, and the clock signal. The module also includes logic to handle the enable signal and reset conditions.\n\n Module header:\n\nmodule Count_Up_Down (CLK_IN,reset,enb,u,count_debounce,y);\n [/INST]\n", "output": "input CLK_IN; \n  input reset; \n  input enb; \n  input u; \n  input [7:0] count_debounce; \n  output y; \n  reg u_n1; \n  reg [7:0] count; \n  reg y_reg; \n  reg u_n1_next; \n  reg [7:0] count_next; \n  reg y_reg_next; \n  reg [8:0] add_temp_1; \n  always @(posedge CLK_IN) \n  begin : libDebounce_c2_Count_Up_Down_process \n  if (reset == 1'b1) begin \n  u_n1 <= 1'b0; \n  count <= 8'd0; \n  y_reg <= 1'b0; \n  end \n  else if (enb) begin \n  u_n1 <= u_n1_next; \n  count <= count_next; \n  y_reg <= y_reg_next; \n  end \n  end \n  always @(u, u_n1, count, count_debounce, y_reg) begin \n  count_next = count; \n  y_reg_next = y_reg; \n  if (u == u_n1) begin \n  if (count >= count_debounce) begin \n  y_reg_next = u; \n  end \n  else begin \n  add_temp_1 = count + 1; \n  if (add_temp_1[8] != 1'b0) begin \n  count_next = 8'b11111111; \n  end \n  else begin \n  count_next = add_temp_1[7:0]; \n  end \n  end \n  end \n  else begin \n  count_next = 8'd0; \n  end \n  u_n1_next = u; \n  end \n  assign y = y_reg_next; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is designed to control the setting registers based on certain input signals. It contains two instances of a setting register module, each with a different base address. The module has logic to update the output registers based on the input signals and the state of the setting registers. When the reset signal or user strobe signal is asserted, the stb_int is set to 0. If the address changes, stb_int is set to 1, and if the data changes, stb_int is also set to 1. The set_stb_user output is set to 1 only when both stb_int and data_changed are 1. This module effectively manages the setting registers and their corresponding outputs based on the input signals and their changes.\n\n Module header:\n\nmodule user_settings #(parameter BASE=0) (input clk,input rst,input set_stb,input [7:0] set_addr,input [31:0] set_data,output set_stb_user,output [7:0] set_addr_user,output [31:0] set_data_user);\n [/INST]\n", "output": "wire addr_changed, data_changed; \n  reg stb_int; \n  setting_reg #(.my_addr(BASE+0),.width(8)) sr_0 \n (.clk(clk),.rst(rst),.strobe(set_stb),.addr(set_addr),.in(set_data),.out(set_addr_user),.changed(addr_changed) ); \n  setting_reg #(.my_addr(BASE+1)) sr_1 \n (.clk(clk),.rst(rst),.strobe(set_stb),.addr(set_addr),.in(set_data),.out(set_data_user),.changed(data_changed) ); \n  always @(posedge clk) \n  if (rst|set_stb_user) \n  stb_int <= 0; \n  else \n  if (addr_changed) \n  stb_int <= 1; \n  assign set_stb_user = stb_int & data_changed; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a Serial Peripheral Interface (SPI) controller. It uses a state machine to handle the data transfer between the master and slave devices. The module drives the clock (SCLK) and slave select (SS) signals and monitors the MISO and MOSI signals. The module also maintains a counter to keep track of the bit being transmitted. When triggered, the module initiates the data transmission, and upon completion, it asserts the done signal.\n\n Module header:\n\nmodule spi (input wire clk,input wire resn,input wire trig,output wire done,output reg [15:0] rdData,input wire [15:0] wrData,output reg SCLK,output reg SS,output reg MOSI,input wire MISO);\n [/INST]\n", "output": "reg [3:0] state; \n  reg [15:0] bitCount; \n  reg [15:0] clkCounter; \n  always @ (posedge clk) begin \n  clkCounter = clkCounter + 1; \n  if (clkCounter == 33) begin \n  SCLK <= !SCLK; \n  end \n  end \n  always @ (SCLK) begin \n  if (!resn) begin \n  SS <= 1; \n  MOSI <= 0; \n  state <= 0; \n  bitCount <= 0; \n  end else begin \n  case (state) \n  0: begin \n  if (trig) begin \n  if (SCLK == 0) begin \n  SS <= 0; \n  state <= 1; \n  bitCount <= 15; \n  end \n  end \n  end \n  1: begin \n  if (SCLK == 0) begin \n  MOSI <= wrData[bitCount]; \n  bitCount <= bitCount - 1; \n  if (bitCount == 0) begin \n  state <= 2; \n  end \n  end else begin \n  rdData[bitCount] <= MISO; \n  end \n  end \n  2: begin \n  if (SCLK == 1) begin \n  SS <= 1; \n  MOSI <= 0; \n  state <= 0; \n  bitCount <= 0; \n  end \n  end \n  default: ; \n  endcase \n  end \n  end \n  assign done = SS; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `Codigo1` implements a PS/2 data signal processing module. It uses a state machine to filter and process the PS/2 data and clock signals. The module maintains the state of the state machine based on the PS/2 clock signal edges and processes the PS/2 data signal accordingly. The output `ps2_data_out` is assigned the processed PS/2 data signal, and `pulso_done` indicates the completion of the data processing.\n\n Module header:\n\nmodule Codigo1(clk, ps2_data, ps2_clk, ps2_data_out, pulso_done);\n [/INST]\n", "output": "input clk; \n  input ps2_clk, ps2_data; \n  output [7:0]ps2_data_out; \n  output reg pulso_done; \n  reg [7:0] filtro_antirebote; \n  reg ps2_clk_negedge; \n  reg [2:0] estado=0; \n  reg [7:0] contador=0; \n  reg [7:0] data_p; \n  reg data_in; \n  localparam [2:0] \n  idle = 3'b000, \n  uno = 3'b001, \n  dos = 3'b010, \n  tres = 3'b011, \n  cuatro = 3'b100; \n  always @ (posedge clk) \n  begin \n  filtro_antirebote [7:0]<= {ps2_clk, filtro_antirebote[7:1]}; \n  end \n  always @ (posedge clk) \n  begin \n  if (filtro_antirebote == 8'b00001111) \n  ps2_clk_negedge <= 1'b1; \n  else \n  ps2_clk_negedge <= 1'b0; \n  end \n  always @ (posedge clk) \n  begin \n  if (ps2_clk_negedge) \n  data_in <= ps2_data; \n  else \n  data_in <= data_in; \n  end \n  always @ (posedge clk) \n  begin \n  case (estado) \n  idle: begin \n  data_p <= data_p; \n  contador <= 4'd0; \n  pulso_done <=1'b0; \n  if (ps2_clk_negedge) \n  estado<= uno; \n  else \n  estado<= uno; \n  end \n  uno: begin \n  data_p<=data_p; \n  contador <= contador; \n  pulso_done <= 1'b0; \n  if (ps2_clk_negedge) \n  begin \n  if (contador == 4'd8) \n  estado<=tres; \n  else \n  estado <= dos; \n  end \n  else \n  estado<= uno; \n  end \n  dos: begin \n  data_p [7:0] <= {data_in, data_p[7:1]}; \n  contador <= contador +1; \n  pulso_done <= 1'b0; \n  estado <= uno; \n  end \n  tres: begin \n  estado <= cuatro; \n  pulso_done <=1'b1; \n  data_p <=data_p; \n  contador <= 4'd0; \n  end \n  cuatro: begin \n  data_p <= data_p; \n  contador <= 4'd0; \n  pulso_done <= 1'b0; \n  if (ps2_clk_negedge) \n  estado <= idle; \n  end \n  endcase \n  end \n  assign ps2_data_out = data_p; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module is a 32-bit shifter that takes a 32-bit input and shifts it to the left by one bit, while also assigning the least significant bit (out[0]) to the value of input i.\n\n Module header:\n\nmodule shifter(out,in,i);\n [/INST]\n", "output": "output [31:0]out; \n input [31:0]in; \n input i; \n assign out[31]=in[30]; \n assign out[30]=in[29]; \n assign out[29]=in[28]; \n assign out[28]=in[27]; \n assign out[27]=in[26]; \n assign out[26]=in[25]; \n assign out[25]=in[24]; \n assign out[24]=in[23]; \n assign out[23]=in[22]; \n assign out[22]=in[21]; \n assign out[21]=in[20]; \n assign out[20]=in[19]; \n assign out[19]=in[18]; \n assign out[18]=in[17]; \n assign out[17]=in[16]; \n assign out[16]=in[15]; \n assign out[15]=in[14]; \n assign out[14]=in[13]; \n assign out[13]=in[12]; \n assign out[12]=in[11]; \n assign out[11]=in[10]; \n assign out[10]=in[9]; \n assign out[9]=in[8]; \n assign out[8]=in[7]; \n assign out[7]=in[6]; \n assign out[6]=in[5]; \n assign out[5]=in[4]; \n assign out[4]=in[3]; \n assign out[3]=in[2]; \n assign out[2]=in[1]; \n assign out[1]=in[0]; \n assign out[0]=i; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"rcn_ram\" implements a memory unit with read and write capabilities. It interfaces with an \"rcn_slave\" module and consists of four 16KB memory banks named byte_0, byte_1, byte_2, and byte_3. \n\nWhen a write operation is enabled (wr is high and cs is active), the module writes the incoming data (wdata) into the corresponding memory bank based on the address (addr) and the mask configuration (mask). The data is split and stored across the four memory banks based on the mask settings.\n\nDuring a read operation (cs is active), the module retrieves the data from the memory banks based on the address and combines it into a 32-bit output (rdata) which is then assigned as the module's output.\n\n Module header:\n\nmodule rcn_ram (input clk,input rst,input [68:0] rcn_in,output [68:0] rcn_out);\n [/INST]\n", "output": "parameter ADDR_BASE = 0; \n  wire cs; \n  wire wr; \n  wire [3:0] mask; \n  wire [23:0] addr; \n  wire [31:0] wdata; \n  wire [31:0] rdata; \n  rcn_slave #(.ADDR_MASK(24'hFF0000), .ADDR_BASE(ADDR_BASE)) rcn_slave \n (.rst(rst),.clk(clk),.rcn_in(rcn_in),.rcn_out(rcn_out),.cs(cs),.wr(wr),.mask(mask),.addr(addr),.wdata(wdata),.rdata(rdata)); \n  reg [7:0] byte_0[(1024 * 16)-1:0]; \n  reg [7:0] byte_1[(1024 * 16)-1:0]; \n  reg [7:0] byte_2[(1024 * 16)-1:0]; \n  reg [7:0] byte_3[(1024 * 16)-1:0]; \n  reg [31:0] data_out; \n  always @ (posedge clk) \n  if (cs && wr) \n  begin \n  if (mask[0]) \n  byte_0[addr[15:2]] <= wdata[7:0]; \n  if (mask[1]) \n  byte_1[addr[15:2]] <= wdata[15:8]; \n  if (mask[2]) \n  byte_2[addr[15:2]] <= wdata[23:16]; \n  if (mask[3]) \n  byte_3[addr[15:2]] <= wdata[31:24]; \n  end \n  always @ (posedge clk) \n  if (cs) \n  data_out <= {byte_3[addr[15:2]], byte_2[addr[15:2]], \n  byte_1[addr[15:2]], byte_0[addr[15:2]]}; \n  assign rdata = data_out; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a block memory with 256 entries, where each entry is 32 bits wide. It has two read ports and one write port. When the write signal is asserted, the module writes the write_data to the memory location specified by write_addr. The read ports access the memory locations specified by read_addr0 and read_addr1 and output the corresponding data. The read and write operations are synchronized with the positive edge of the clock signal.\n\n Module header:\n\nmodule blockmem2r1w(input wire clk,input wire [07 : 0] read_addr0,output wire [31 : 0] read_data0,input wire [07 : 0] read_addr1,output wire [31 : 0] read_data1,input wire wr,input wire [07 : 0] write_addr,input wire [31 : 0] write_data);\n [/INST]\n", "output": "reg [31 : 0] mem [0 : 255]; \n  reg [31 : 0] tmp_read_data0; \n  reg [31 : 0] tmp_read_data1; \n  assign read_data0 = tmp_read_data0; \n  assign read_data1 = tmp_read_data1; \n  always @ (posedge clk) \n  begin : reg_mem \n  if (wr) \n  mem[write_addr] <= write_data; \n  tmp_read_data0 <= mem[read_addr0]; \n  tmp_read_data1 <= mem[read_addr1]; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an altpriority encoder that takes a 4-bit input data and outputs a 2-bit value q. The module instantiates two sub-modules, altpriority_encoder21 and altpriority_encoder22, to process portions of the input data. The output q is determined by bitwise operations involving the outputs of the sub-modules. The altpriority_encoder22_zero signal is also used in the bitwise operations to compute the output q.\n\n Module header:\n\nmodule fp_sub_altpriority_encoder_6v7 (data,q) ;\n [/INST]\n", "output": "input [3:0] data; \n  output [1:0] q; \n  wire [0:0] wire_altpriority_encoder21_q; \n  wire [0:0] wire_altpriority_encoder22_q; \n  wire wire_altpriority_encoder22_zero; \n  fp_sub_altpriority_encoder_3v7 altpriority_encoder21 \n (.data(data[1:0]),.q(wire_altpriority_encoder21_q)); \n  fp_sub_altpriority_encoder_3e8 altpriority_encoder22 \n (.data(data[3:2]),.q(wire_altpriority_encoder22_q),.zero(wire_altpriority_encoder22_zero)); \n  assign \n  q = {(~ wire_altpriority_encoder22_zero), ((wire_altpriority_encoder22_zero & wire_altpriority_encoder21_q) | ((~ wire_altpriority_encoder22_zero) & wire_altpriority_encoder22_q))}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module named GP_VSS has a single output named OUT, which is set to logic 0. This means that the module continually outputs logic 0 on the OUT signal.\n\n Module header:\n\nmodule GP_VSS(output OUT);\n [/INST]\n", "output": "assign OUT = 0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"one_thousand_twenty_four_byteenable_FSM\" is a state machine that manages the transfer of data based on byte enable signals. It has inputs for clock, reset, write signal, and byte enable signal, and outputs a wait request signal and modified byte enable signals. The module tracks the progress of data transfers and advances to the next state based on various conditions such as partial or full transfers, stalls, and wait requests. It also handles lower and upper half transfers, and two-stage transfers. Additionally, it instantiates two instances of a \"five_hundred_twelve_bit_byteenable_FSM\" module to handle lower and upper half byte enable FSMs. The overall functionality of the module is to control the data transfer process based on the byte enable signals and manage the state transitions accordingly.\n\n Module header:\n\nmodule one_thousand_twenty_four_byteenable_FSM (clk,reset,write_in,byteenable_in,waitrequest_out,byteenable_out,waitrequest_in);\n [/INST]\n", "output": "input clk; \n  input reset; \n  input write_in; \n  input [127:0] byteenable_in; \n  output wire waitrequest_out; \n  output wire [127:0] byteenable_out; \n  input waitrequest_in; \n  wire partial_lower_half_transfer; \n  wire full_lower_half_transfer; \n  wire partial_upper_half_transfer; \n  wire full_upper_half_transfer; \n  wire full_word_transfer; \n  reg state_bit; \n  wire transfer_done; \n  wire advance_to_next_state; \n  wire lower_enable; \n  wire upper_enable; \n  wire lower_stall; \n  wire upper_stall; \n  wire two_stage_transfer; \n  always @ (posedge clk or posedge reset) \n  begin \n  if (reset) \n  begin \n  state_bit <= 0; \n  end \n  else \n  begin \n  if (transfer_done == 1) \n  begin \n  state_bit <= 0; \n  end \n  else if (advance_to_next_state == 1) \n  begin \n  state_bit <= 1; \n  end \n  end \n  end \n  assign partial_lower_half_transfer = (byteenable_in[63:0] != 0); \n  assign full_lower_half_transfer = (byteenable_in[63:0] == 64'hFFFFFFFFFFFFFFFF); \n  assign partial_upper_half_transfer = (byteenable_in[127:64] != 0); \n  assign full_upper_half_transfer = (byteenable_in[127:64] == 64'hFFFFFFFFFFFFFFFF); \n  assign full_word_transfer = (full_lower_half_transfer == 1) & (full_upper_half_transfer == 1); \n  assign two_stage_transfer = (full_word_transfer == 0) & (partial_lower_half_transfer == 1) & (partial_upper_half_transfer == 1); \n  assign advance_to_next_state = (two_stage_transfer == 1) & (lower_stall == 0) & (write_in == 1) & (state_bit == 0) & (waitrequest_in == 0); \n  assign transfer_done = ((full_word_transfer == 1) & (waitrequest_in == 0) & (write_in == 1)) | \n  ((two_stage_transfer == 0) & (lower_stall == 0) & (upper_stall == 0) & (write_in == 1) & (waitrequest_in == 0)) | \n  ((two_stage_transfer == 1) & (state_bit == 1) & (upper_stall == 0) & (write_in == 1) & (waitrequest_in == 0)); \n  assign lower_enable = ((write_in == 1) & (full_word_transfer == 1)) | \n  ((write_in == 1) & (two_stage_transfer == 0) & (partial_lower_half_transfer == 1)) | \n  ((write_in == 1) & (two_stage_transfer == 1) & (partial_lower_half_transfer == 1) & (state_bit == 0)); \n  assign upper_enable = ((write_in == 1) & (full_word_transfer == 1)) | \n  ((write_in == 1) & (two_stage_transfer == 0) & (partial_upper_half_transfer == 1)) | \n  ((write_in == 1) & (two_stage_transfer == 1) & (partial_upper_half_transfer == 1) & (state_bit == 1)); \n five_hundred_twelve_bit_byteenable_FSM lower_five_hundred_twelve_bit_byteenable_FSM (.clk (clk),.reset (reset),.write_in (lower_enable),.byteenable_in (byteenable_in[63:0]),.waitrequest_out (lower_stall),.byteenable_out (byteenable_out[63:0]),.waitrequest_in (waitrequest_in)); \n five_hundred_twelve_bit_byteenable_FSM upper_five_hundred_twelve_bit_byteenable_FSM (.clk (clk),.reset (reset),.write_in (upper_enable),.byteenable_in (byteenable_in[127:64]),.waitrequest_out (upper_stall),.byteenable_out (byteenable_out[127:64]),.waitrequest_in (waitrequest_in)); \n  assign waitrequest_out = (waitrequest_in == 1) | ((transfer_done == 0) & (write_in == 1)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module `mainlogic` is a complex combinational and sequential logic circuit with multiple inputs and outputs. It includes input registers, output registers, parameters, a submodule instantiation, and an always block. The module takes in various inputs such as switches, distances, speeds, and triangles. It has outputs for LEDs, voice, speed control, angle control, and an output number. The module contains logic to control the outputs based on the inputs and certain conditions, such as setting the LED, voice, speed control, and angle control based on the input conditions. It also includes a reset logic to initialize the outputs and other registers. The Verilog module is essentially a control logic unit that manipulates the outputs based on the input conditions and certain criteria.\n\n Module header:\n\nmodule mainlogic(rst_n,switch1,switch2,switch3,distance,speed,triangle,led1,led2,speed_control,voice,clk,out_num,angle_control);\n [/INST]\n", "output": "input switch1,switch2,switch3,rst_n,clk; \n input [9:0]distance,speed; \n input [15:0]triangle; \n output reg led1,led2,voice; \n output reg[15:0]speed_control,angle_control; \n parameter SPEED_LOW=0; \n parameter SPEED_NORMAL=2000; \n reg[9:0]timed; \n wire[9:0]temp_time; \n output reg[9:0]out_num; \n div_rill u1(.a(distance),.b(speed),.shang(temp_time),.yushu()); \n always @(posedge clk or negedge rst_n) \n begin \n  timed<=temp_time; \n  if(!rst_n)begin led1<=0;led2<=0;voice<=0;out_num<=0;speed_control<=SPEED_NORMAL; angle_control<=1500; timed<=10; end \n  else begin if(switch1==1'b1)begin out_num<=distance;end \n  else begin \n  if(switch2==1)begin out_num<=speed;end \n  else begin out_num<=0;end \n  end \n  if(distance<=60 && distance>=5)begin angle_control<=1000; speed_control<=SPEED_LOW; voice<=1; end \n  else begin angle_control<=1500;speed_control<=SPEED_NORMAL;end \n  if($signed(triangle)>16'sd10000)begin led2<=1;voice<=1;speed_control<=SPEED_LOW; end \n  else begin voice<=0;led2<=0; speed_control<=SPEED_NORMAL; end \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module sminvblock takes an input signal GIN and outputs its inverse signal GOUT. The output GOUT is the logical negation of the input GIN.\n\n Module header:\n\nmodule sminvblock ( GIN, GOUT );\n [/INST]\n", "output": "input GIN; \n  output GOUT; \n  assign GOUT = ~ GIN; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a deglitch shift register that takes in an input io_d and provides an output io_q. It uses a clock signal and a reset signal to synchronize the input and output. The input io_d is stored in the register T_8 and then delayed by one clock cycle using the register T_9. The synchronization signal sync is set to T_9, and the last signal is set to sync. The output io_q is the result of the logical AND operation between the sync and last signals. This module effectively filters out glitches from the input signal and provides a synchronized output.\n\n Module header:\n\nmodule sirv_DeglitchShiftRegister(input clock,input reset,input io_d,output io_q);\n [/INST]\n", "output": "reg T_8; \n  reg [31:0] GEN_0; \n  reg T_9; \n  reg [31:0] GEN_1; \n  reg sync; \n  reg [31:0] GEN_2; \n  reg last; \n  reg [31:0] GEN_3; \n  wire T_12; \n  assign io_q = T_12; \n  assign T_12 = sync & last; \n  always @(posedge clock) begin \n  T_8 <= io_d; \n  T_9 <= T_8; \n  sync <= T_9; \n  last <= sync; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a simple memory array with a read pointer and outputs the value at the memory location pointed to by the read pointer. On a positive clock edge, the read pointer is incremented by one, and the output is assigned to the memory value at the updated read pointer position. The module also includes a reset functionality that initializes the read pointer and sets initial values for the memory array.\n\n Module header:\n\nmodule wire_test_case (array_out, clock, reset);\n [/INST]\n", "output": "output [15:0] array_out; \n  input clock, reset; \n  reg [3:0] readptr; \n  reg [15:0] body [15:0]; \n  wire [15:0] array_out; \n  assign array_out = body[readptr]; \n  always @(posedge clock) begin \n  if (reset == 0) begin \n  readptr <= 16'h0000; \n  body[0] <= 16'h0001; \n  body[1] <= 16'h0002; \n  body[2] <= 16'h0003; \n  body[3] <= 16'h0005; \n  body[4] <= 16'h0008; \n  body[5] <= 16'h000D; \n  body[6] <= 16'h0015; \n  end \n  else begin \n  readptr <= readptr + 16'h0001; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a forward unit that provides control signals for data forwarding in a pipeline. It checks for conditions where data needs to be forwarded from the MEM/WB and EX/MEM pipeline stages to the input registers of the current pipeline stage. The control signals forwardA and forwardB are set based on specific conditions in the pipeline registers and are updated accordingly. The module also includes a reset functionality to initialize the control signals when a reset signal is asserted.\n\n Module header:\n\nmodule forwardUnit(input [4:0] rs,input [4:0] rt,input MEM_WB_regWrite,input [4:0] MEM_WB_rd,input EX_MEM_regWrite,input [4:0] EX_MEM_rd,output reg [1:0] forwardA,output reg [1:0] forwardB,input rst);\n [/INST]\n", "output": "always @(*) begin \n  if(rst) begin \n  forwardA = 'b00; \n  forwardB = 'b00; \n  end \n  else \n  begin \n  if(MEM_WB_regWrite & MEM_WB_rd != 0 & MEM_WB_rd == rs) forwardA = 'b01; \n  else if(EX_MEM_regWrite & EX_MEM_rd != 0 & EX_MEM_rd == rs) forwardA = 'b10; \n  else forwardA = 'b00; \n  if(MEM_WB_regWrite & MEM_WB_rd != 0 & MEM_WB_rd == rt) forwardB = 'b01; \n  else if(EX_MEM_regWrite & EX_MEM_rd != 0 & EX_MEM_rd == rt) forwardB = 'b10; \n  else forwardB = 'b00; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module represents a CPU with various input and output ports for data and control signals. It includes parameters for defining boot and interrupt vectors, register file type, and cache enabling. The module instantiates an instance of the \"altor32_lite\" module with specified parameters and connects its ports to the CPU's input and output signals. Additionally, there are some assignments for the instruction memory address, CTI, cycle, and stall signals. The module effectively serves as a top-level wrapper for the CPU functionality, handling memory and control signals.\n\n Module header:\n\nmodule cpu (input clk_i ,input rst_i ,input intr_i ,input nmi_i ,output fault_o ,output break_o ,output [31:0] imem_addr_o ,input [31:0] imem_dat_i ,output [2:0] imem_cti_o ,output imem_cyc_o ,output imem_stb_o ,input imem_stall_i,input imem_ack_i,output [31:0] dmem_addr_o ,input [31:0] dmem_dat_i ,output [31:0] dmem_dat_o ,output [2:0] dmem_cti_o ,output dmem_cyc_o ,output dmem_stb_o ,output dmem_we_o ,output [3:0] dmem_sel_o ,input dmem_stall_i,input dmem_ack_i);\n [/INST]\n", "output": "parameter BOOT_VECTOR = 32'h00000000; \n parameter ISR_VECTOR = 32'h00000000; \n parameter REGISTER_FILE_TYPE = \"SIMULATION\"; \n parameter ENABLE_ICACHE = \"DISABLED\"; \n parameter ENABLE_DCACHE = \"DISABLED\"; \n parameter SUPPORT_32REGS = \"ENABLED\"; \n altor32_lite \n #(.BOOT_VECTOR(BOOT_VECTOR),.ISR_VECTOR(ISR_VECTOR),.REGISTER_FILE_TYPE(REGISTER_FILE_TYPE)) \n u_exec \n (.clk_i(clk_i),.rst_i(rst_i),.fault_o(fault_o),.break_o(break_o),.nmi_i(nmi_i),.intr_i(intr_i),.enable_i(1'b1),.mem_addr_o(dmem_addr_o),.mem_dat_o(dmem_dat_o),.mem_dat_i(dmem_dat_i),.mem_sel_o(dmem_sel_o),.mem_cti_o(dmem_cti_o),.mem_cyc_o(dmem_cyc_o),.mem_we_o(dmem_we_o),.mem_stb_o(dmem_stb_o),.mem_stall_i(dmem_stall_i),.mem_ack_i(dmem_ack_i)); \n assign imem_addr_o = 32'b0; \n assign imem_cti_o = 3'b0; \n assign imem_cyc_o = 1'b0; \n assign imem_stb_o = 1'b0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a multiplier that takes two input numbers a and b, both of configurable widths, and produces an output c with a width equal to the sum of the widths of a and b. The module performs signed multiplication of the input numbers a and b, and assigns the result to the output c.\n\n Module header:\n\nmodule SMUL(a, b, c);\n [/INST]\n", "output": "parameter WIDTH_A = 1; \n parameter WIDTH_B = 1; \n input [WIDTH_A-1:0] a; \n input [WIDTH_B-1:0] b; \n output [WIDTH_A+WIDTH_B-2:0] c; \n  assign c = $signed(a) * $signed(b); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a conditional code section with if-else-if-else structures and ifdef definitions. It contains input declarations for signals like sysclk and bclko. It also includes always blocks for different signals such as a, b, and (a or b). The functionality is selected based on the ifdef definitions for A and B. The module further performs assignments and comparisons based on the conditions.\n\n Module header:\n\nmodule foo;\n [/INST]\n", "output": "`ifdef LABEL_A \n CHIP CPU (.clkin(clkin),`ifdef LABEL_B.bclko(bclko),`endif.cmode(cmode),); \n  input sysclk; \n  `ifdef LABEL_B \n  input bclko; \n  `endif \n  input cmode; \n `endif \n `ifdef LABEL_A \n CHIP CPU (.clkin(clkin),`ifdef LABEL_B.bclko(bclko),`endif.cmode(cmode),); \n  input sysclk; \n  `ifdef LABEL_B \n  input bclko; \n  `endif \n  input cmode; \n `endif \n  reg a,b; \n `ifdef A \n  always @(a) begin \n  b = a; \n  b = a; \n  b = a; \n  b = a; \n  b = a; \n  b = a; \n  b = a; \n  b = a; \n  b = a; \n  end \n `elsif B \n  always @(b) begin \n  a = b; \n  a = b; \n  a = b; \n  a = b; \n  a = b; \n  a = b; \n  a = b; \n  a = b; \n  a = b; \n  a = b; \n  a = b; \n  a = b; \n  end \n `else \n  always @(a or b) begin \n  a <= b; \n  b <= a; \n  end \n `endif \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements the functionality for interfacing with an LCD display. It provides inputs for addressing, initiating data transfer, reading, and writing data to the display. The module also includes outputs for enabling the LCD, selecting the row, and controlling the data lines. The behavior includes setting the row write enable, row select, and LCD enable signals based on the input address and control signals. Additionally, the module handles the bidirectional data lines and the transfer of data to and from the LCD.\n\n Module header:\n\nmodule lcd_display (address,begintransfer,read,write,writedata,LCD_E,LCD_RS,LCD_RW,LCD_data,readdata);\n [/INST]\n", "output": "output LCD_E; \n  output LCD_RS; \n  output LCD_RW; \n  inout [ 7: 0] LCD_data; \n  output [ 7: 0] readdata; \n  input [ 1: 0] address; \n  input begintransfer; \n  input read; \n  input write; \n  input [ 7: 0] writedata; \n  wire LCD_E; \n  wire LCD_RS; \n  wire LCD_RW; \n  wire [ 7: 0] LCD_data; \n  wire [ 7: 0] readdata; \n  assign LCD_RW = address[0]; \n  assign LCD_RS = address[1]; \n  assign LCD_E = read | write; \n  assign LCD_data = (address[0]) ? 8'bz : writedata; \n  assign readdata = LCD_data; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, named \"mii,\" implements the Media Independent Interface (MII) for Ethernet communication. It connects the physical layer (PHY) and the media access control (MAC) layer. It includes clock dividers for the transmit and receive clocks, as well as logic for handling data transmission and reception.\n\nThe module includes various signal assignments to connect the PHY and MAC interfaces. It also implements clock dividers for the transmit and receive clocks to ensure proper synchronization. Additionally, the module utilizes flip-flops to manage the transmission and reception of data, along with specific logic for handling resets and data indexing.\n\nOverall, the module acts as a bridge between the PHY and MAC layers, managing the flow of data and ensuring proper communication between the two layers.\n\n Module header:\n\nmodule mii (input wire reset,output wire phy_tx_er,output reg [3:0] phy_txd,output wire phy_tx_en,input wire phy_tx_clk,input wire phy_col,input wire [3:0] phy_rxd,input wire phy_rx_er,input wire phy_rx_clk,input wire phy_crs,input wire phy_rx_dv,input wire mac_tx_er,input wire [7:0] mac_txd,input wire mac_tx_en,output wire mac_tx_clk,output wire mac_col,output reg [7:0] mac_rxd,output wire mac_rx_er,output wire mac_rx_clk,output wire mac_crs,output wire mac_rx_dv);\n [/INST]\n", "output": "reg tx_index; \n reg rx_index; \n assign phy_tx_er = mac_tx_er; \n assign phy_tx_en = mac_tx_en; \n assign mac_col = phy_col; \n assign mac_rx_er = phy_rx_er; \n assign mac_crs = phy_crs; \n assign mac_rx_dv = phy_rx_dv; \n clock_divider #(.DIVIDER(2)) clk_div_tx \n (.reset(reset),.clock_in(phy_tx_clk),.clock_out(mac_tx_clk)); \n clock_divider #(.DIVIDER(2)) clk_div_rx \n (.reset(reset),.clock_in(phy_rx_clk),.clock_out(mac_rx_clk)); \n always @(posedge phy_tx_clk) \n begin \n  if (reset) \n  begin \n  tx_index <= 0; \n  end \n  else \n  begin \n  tx_index <= ~tx_index; \n  end \n end \n always @(posedge phy_tx_clk) \n begin \n  if (reset) \n  begin \n  phy_txd <= 0; \n  end \n  else \n  begin \n  phy_txd <= mac_txd[tx_index*4+:4]; \n  end \n end \n always @(posedge phy_rx_clk) \n begin \n  if (reset) \n  begin \n  rx_index <= 0; \n  end \n  else \n  begin \n  rx_index <= ~rx_index; \n  end \n end \n always @(posedge phy_rx_clk) \n begin \n  if (reset) \n  begin \n  mac_rxd <= 0; \n  end \n  else \n  begin \n  mac_rxd[rx_index*4+:4] <= phy_rxd; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module SN74LS195ARelativeTime simulates a SN74LS195A shift register IC. It contains two components, GatesChip and BehaviorChip, which implement the gate-level and behavioral functionality of the chip. The module has inputs P, PE, J, K, CP, MR, and outputs Qgates, Q3not_gate, Qbehavior, and Q3not_behavior. \n\nThe CP signal toggles every 5 time units, and the MR signal is initially set to 1. The P, PE, J, and K inputs are sequentially set to specific values at different time intervals to simulate the behavior of the shift register. The simulation ends with a $stop command.\n\nThe module initializes the input signals and continuously toggles the clock signal CP. It then sets the mode control signal MR and the data and control signals, simulating the shift register's behavior.\n\nIn summary, this Verilog module models the behavior of a SN74LS195A shift register IC using gate-level and behavioral components.\n\n Module header:\n\nmodule SN74LS195ARelativeTime;\n [/INST]\n", "output": "reg [3:0] P; \n  reg PE, J, K, CP, MR; \n  wire Q3not_gate, Q3not_behavior; \n  wire [3:0] Qbehavior, Qgates; \n  SN74LS195Agates GatesChip (Qgates, P, Q3not_gate, PE, J, K, CP, MR); \n  SN74LS195Abehavior BehaviorChip (Qbehavior, P, Q3not_behavior, PE, J, K, CP, MR); \n  initial begin P = 0; PE = 0; J = 0; K = 0; CP = 0; MR = 0; end \n  always #5 CP = ~CP; \n  initial begin \n  MR = 1; P = 4'b1010; PE=0; J = 0; K = 0; #5; \n  MR = 0; P = 4'b1010; PE=0; J = 0; K = 0; #18; \n  MR = 1; P = 4'b1010; PE=0; J = 1; K = 1; #18; \n  MR = 1; P = 4'b1010; PE=1; J = 1; K = 1; #18; \n  MR = 1; P = 4'b1010; PE=1; J = 0; K = 0; #18; \n  MR = 1; P = 4'b1010; PE=1; J = 1; K = 0; #26; \n  MR = 1; P = 4'b1010; PE=1; J = 0; K = 1; #50; \n  $stop; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module is an implementation of a CBCDes encryptor. It features register and wire declarations to handle various signals and modes, as well as an instantiation of a DES module. The module includes logic for mode switching, data input/output, key initialization, and handling of reset and clock signals. It also includes a validation and ready output logic for data transmission. The DES module is instantiated to handle the actual encryption and decryption processes.\n\n Module header:\n\nmodule cbcdes (input reset_i,input clk_i,input start_i,input mode_i,input [0:63] key_i,input [0:63] iv_i,input [0:63] data_i,input valid_i,output reg ready_o,output reg [0:63] data_o,output valid_o);\n [/INST]\n", "output": "reg mode; \n  wire des_mode; \n  reg start; \n  reg [0:63] key; \n  wire [0:63] des_key; \n  reg [0:63] iv; \n  reg [0:63] datain; \n  reg [0:63] datain_d; \n  reg [0:63] des_datain; \n  wire validin; \n  wire [0:63] des_dataout; \n  reg reset; \n  reg [0:63] dataout; \n  assign des_key = (start_i) ? key_i : key; \n  assign des_mode = (start_i) ? mode_i : mode; \n  assign validin = valid_i & ready_o; \n  always @(*) begin \n  if (~mode_i && start_i) begin \n  des_datain = iv_i ^ data_i; \n  end \n  else if (~mode && ~start_i) begin \n  des_datain = dataout ^ data_i; \n  end \n  else begin \n  des_datain = data_i; \n  end \n  end \n  always @(*) begin \n  if (mode && start) begin \n  data_o = iv ^ des_dataout; \n  end \n  else if (mode && ~start) begin \n  data_o = datain_d ^ des_dataout; \n  end \n  else begin \n  data_o = des_dataout; \n  end \n  end \n  always @(posedge clk_i, negedge reset_i) begin \n  if (~reset_i) begin \n  reset <= 0; \n  mode <= 0; \n  start <= 0; \n  key <= 0; \n  iv <= 0; \n  datain <= 0; \n  datain_d <= 0; \n  end \n  else begin \n  reset <= reset_i; \n  if (valid_i && ready_o) begin \n  start <= start_i; \n  datain <= data_i; \n  datain_d <= datain; \n  end \n  else if (valid_i && ready_o && start_i) begin \n  mode <= mode_i; \n  key <= key_i; \n  iv <= iv_i; \n  end \n  end \n  end \n  always @(posedge clk_i, negedge reset_i) begin \n  if (~reset_i) begin \n  ready_o <= 0; \n  dataout <= 0; \n  end \n  else begin \n  if (valid_i && ready_o) begin \n  ready_o <= 0; \n  end \n  else if (valid_o || (reset_i && ~reset)) begin \n  ready_o <= 1; \n  dataout <= des_dataout; \n  end \n  end \n  end \n des i_des (.reset_i(reset),.clk_i(clk_i),.mode_i(des_mode),.key_i(des_key),.data_i(des_datain),.valid_i(validin),.data_o(des_dataout),.valid_o(valid_o)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module extends the input data width from 32 bits to 64 bits. It takes a 32-bit input i_datain, and generates a 64-bit output o_dataout by sign-extending the input. The output is based on the input i_datain, and the module also manages stall and valid signals for the input and output data streams.\n\n Module header:\n\nmodule vfabric_zextend(clock, reset,i_datain, i_datain_valid, o_datain_stall,o_dataout, i_dataout_stall, o_dataout_valid);\n [/INST]\n", "output": "parameter DATAIN_WIDTH = 32; \n parameter DATAOUT_WIDTH = 64; \n  input clock, reset; \n  input [DATAIN_WIDTH-1:0] i_datain; \n  input i_datain_valid; \n  output o_datain_stall; \n  output [DATAOUT_WIDTH-1:0] o_dataout; \n  input i_dataout_stall; \n  output o_dataout_valid; \n  assign o_dataout = {{DATAOUT_WIDTH{1'b0}}, i_datain[DATAIN_WIDTH-1:0]}; \n  assign o_datain_stall = i_dataout_stall; \n  assign o_dataout_valid = i_datain_valid; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a configurable register file with a specified data width (BITSIZE) and address size (ADDSIZE). It has read and write ports along with a synchronous reset. The register file is implemented using an array of registers, where the size of the array is determined by 2 raised to the power of the address size.\n\nDuring a write operation (controlled by the wren input), the module writes the wdat input to the register specified by the rw input. During a read operation, the module retrieves data from the register specified by the ra input and assigns it to the output adat. Similarly, it retrieves data from the register specified by the rb input and assigns it to the output bdat.\n\nWhen the reset signal is asserted (negedge rst), all registers in the array are cleared to 0. If the reset signal is not asserted, the module retains the data stored in the registers or allows for new data to be written to them.\n\nThe register file also provides an additional output zeroDat which retrieves the content of the register at address 0.\n\nIn summary, this module provides a customizable register file with read and write capabilities, synchronous reset, and configurable data and address widths.\n\n Module header:\n\nmodule regfileparam_behav #(parameter BITSIZE = 16,parameter ADDSIZE = 4) (output [BITSIZE-1:0] adat,output [BITSIZE-1:0] bdat,output [BITSIZE-1:0] zeroDat,input [ADDSIZE-1:0] ra,input [ADDSIZE-1:0] rb,input [ADDSIZE-1:0] rw,input [BITSIZE-1:0] wdat,input wren,input clk, rst);\n [/INST]\n", "output": "integer i; \n  reg [BITSIZE-1:0] array_reg [2**ADDSIZE-1:0]; \n  always @(posedge clk, negedge rst) begin \n  if(~rst) begin \n  for(i = 0; i < 2**ADDSIZE; i = i + 1) begin \n  array_reg[i] <= 0; \n  end \n  end \n  else if(wren) begin \n  array_reg[rw] <= wdat; \n  end \n  end \n  assign adat = array_reg[ra]; \n  assign bdat = array_reg[rb]; \n  assign zeroDat = array_reg[0]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module has a parameter declaration, registers for CLK, A, B, and C, and an initial block to set the initial state. There is an always block for toggling the CLK signal. Another always block is used for the combinatorial process that updates the A and C signals. The module also includes a display of the time and the result of the bitwise XOR operation between A and C.\n\n Module header:\n\nmodule sensitivity_list ();\n [/INST]\n", "output": "parameter ii = 4; \n reg CLK; \n reg A; \n reg [ii-1:0] B,C; \n initial \n begin \n  #30; \n  C <= {ii{1'b0}}; \n  #60; \n  $finish(0); \n end \n always \n begin \n  CLK = 1'b0; \n  #10; \n  CLK = 1'b1; \n  #10; \n  $display ($time); \n end \n always @(A or C) begin \n  A = 1'b0; \n  $display (\"combinatorial process \", A, \" time:\",$time); \n  A = 1'b1; \n  $display (\"combinatorial process \", A, \" time:\",$time); \n  B = A+C; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a packet input control with a state machine that processes input signals to control the transmission of data from a CDP to a UM. It handles write requests, data validity, and enables the transmission when necessary. The state machine transitions through idle, transmit, and tail states based on various conditions such as transmit enable, packet input validity, and the status of the packet input control queue. It includes logic to manage the validity of the data and to update the state based on the input signals.\n\n Module header:\n\nmodule pkt_input_ctrl(clk,reset,cdp2um_tx_enable,cdp2um_data_valid,cdp2um_data,pkt_input_ctrl_wrreq,pkt_input_ctrl_data,pkt_input_ctrl_usedw,pkt_input_ctrl_valid_wrreq,pkt_input_ctrl_valid);\n [/INST]\n", "output": "input clk; \n input reset; \n input pkt_input_ctrl_wrreq; \n input [138:0] pkt_input_ctrl_data; \n output [7:0] pkt_input_ctrl_usedw; \n input pkt_input_ctrl_valid_wrreq; \n input pkt_input_ctrl_valid; \n input cdp2um_tx_enable; \n output cdp2um_data_valid; \n output [138:0] cdp2um_data; \n reg [138:0] cdp2um_data; \n reg cdp2um_data_valid; \n reg [2:0] state; \n parameter idle=3'b000, \n  transmit=3'b001, \n  tail=3'b010; \n always@(posedge clk or negedge reset) \n if(!reset) \n begin \n  cdp2um_data_valid<=1'b0; \n  state<=idle; \n end \n else \n begin \n  case(state) \n  idle: \n  begin \n  if(cdp2um_tx_enable) \n  begin \n  if((!pkt_input_ctrl_valid_empty)&&(pkt_input_ctrl_valid_q==1'b1)) \n  begin \n  pkt_input_ctrl_valid_rdreq<=1'b1; \n  pkt_input_ctrl_rdreq<=1'b1; \n  state<=transmit; \n  end \n  else \n  begin \n  state<=idle; \n  end \n  end \n  else \n  begin \n  state<=idle; \n  end \n  end \n  transmit: \n  begin \n  pkt_input_ctrl_valid_rdreq<=1'b0; \n  pkt_input_ctrl_rdreq<=1'b0; \n  if(pkt_input_ctrl_q[138:136]==3'b110) \n  begin \n  pkt_input_ctrl_rdreq<=1'b0; \n  cdp2um_data_valid<=1'b1; \n  cdp2um_data<=pkt_input_ctrl_q; \n  state<=tail; \n  end \n  else \n  begin \n  pkt_input_ctrl_rdreq<=1'b1; \n  cdp2um_data_valid<=1'b1; \n  cdp2um_data<=pkt_input_ctrl_q; \n  state<=transmit; \n  end \n  end \n  tail: \n  begin \n  pkt_input_ctrl_rdreq<=1'b0; \n  cdp2um_data_valid<=1'b0; \n  state<=idle; \n  end \n  default: \n  begin \n  cdp2um_data_valid<=1'b0; \n  state<=idle; \n  end \n  endcase \n  end \n  reg pkt_input_ctrl_rdreq; \n  wire [138:0]pkt_input_ctrl_q; \n  wire [7:0]pkt_input_ctrl_usedw; \n  reg pkt_input_ctrl_valid_rdreq; \n  wire pkt_input_ctrl_valid_q; \n  wire pkt_input_ctrl_valid_empty; \n fifo_256_139 pkt_input_ctrl_fifo(.aclr(!reset),.clock(clk),.data(pkt_input_ctrl_data),.rdreq(pkt_input_ctrl_rdreq),.wrreq(pkt_input_ctrl_wrreq),.q(pkt_input_ctrl_q),.usedw(pkt_input_ctrl_usedw)); \n fifo_64_1 pkt_input_ctrl_valid_fifo(.aclr(!reset),.clock(clk),.data(pkt_input_ctrl_valid),.rdreq(pkt_input_ctrl_valid_rdreq),.wrreq(pkt_input_ctrl_valid_wrreq),.empty(pkt_input_ctrl_valid_empty),.q(pkt_input_ctrl_valid_q)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe given Verilog module represents a Dual-Port Single-Port Memory (DSPM) with input and output ports for core and bus. The module also includes byte write signals for the core and bus.\n\n- The byte write signals for core and bus are concatenated into 8-bit values.\n- Inside a loop, the module uses 8 instances of a Block RAM (BRAM) to store and access data.\n- On a positive clock edge, if core enable is high, and the respective byte write is high, the module stores the input data at the specified core address in the BRAM.\n- The module also reads the data from the BRAM based on the core address and assigns it to the output data for the core.\n\nOverall, the module functions as a memory block with separate read and write ports, utilizing BRAMs to store and retrieve data.\n\n Module header:\n\nmodule DSpm(input clk,input [11:0] io_core_addr,input io_core_enable,output[31:0] io_core_data_out,input io_core_byte_write_3,input io_core_byte_write_2,input io_core_byte_write_1,input io_core_byte_write_0,input [31:0] io_core_data_in,input [11:0] io_bus_addr,input io_bus_enable,output[31:0] io_bus_data_out,input io_bus_byte_write_3,input io_bus_byte_write_2,input io_bus_byte_write_1,input io_bus_byte_write_0,input [31:0] io_bus_data_in);\n [/INST]\n", "output": "wire [7:0] core_byte_write; \n wire [7:0] bus_byte_write; \n assign core_byte_write = {io_core_byte_write_3, io_core_byte_write_3, io_core_byte_write_2, io_core_byte_write_2, io_core_byte_write_1, io_core_byte_write_1, io_core_byte_write_0, io_core_byte_write_0}; \n assign bus_byte_write = {io_core_byte_write_3, io_core_byte_write_3, io_core_byte_write_2, io_core_byte_write_2, io_core_byte_write_1, io_core_byte_write_1, io_core_byte_write_0, io_core_byte_write_0}; \n genvar i; \n generate \n for(i = 0; i < 8; i = i+1) \n begin: BRAMS \n reg [3:0] dspm [4095:0]; \n reg [3:0] core_data_out, bus_data_out; \n always @(posedge clk) begin \n  if(io_core_enable) begin \n  if(core_byte_write[i]) begin \n  dspm[io_core_addr] <= io_core_data_in[4*i+3:4*i]; \n  end \n  core_data_out <= dspm[io_core_addr]; \n  end \n end \n assign io_core_data_out[4*i+3:4*i] = core_data_out; \n end \n endgenerate \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a register file with 8 registers, each of 16 bits. It selects the register to write to based on the \"writenum\" input and the \"write\" signal. The data to be written is determined based on the \"vsel\" input and is stored in \"data_in\". The module also has synchronous D flip-flops to load data into each of the 8 registers based on the register select signal. The \"data_in\" is assigned based on the \"vsel\" input. If none of the cases match, \"data_in\" is set to 16 bits of 'x'.\n\n Module header:\n\nmodule write(clk, vsel, write, writenum, C, mdata, sximm8, PC, reg0, reg1, reg2, reg3, reg4, reg5, reg6, reg7);\n [/INST]\n", "output": "parameter width= 1; \n  input clk, write; \n  input [1:0] vsel; \n  input [2:0] writenum; \n  input [7:0] PC; \n  input [15:0] C, mdata, sximm8; \n  output [15:0] reg0, reg1, reg2, reg3, reg4, reg5, reg6, reg7; \n  reg [15:0] data_in; \n  reg [7:0] regSelect; \n  always @(*) begin \n  case(writenum) \n  3'b000: regSelect= write? 8'b00000001: 8'b00000000; \n  3'b001: regSelect= write? 8'b00000010: 8'b00000000; \n  3'b010: regSelect= write? 8'b00000100: 8'b00000000; \n  3'b011: regSelect= write? 8'b00001000: 8'b00000000; \n  3'b100: regSelect= write? 8'b00010000: 8'b00000000; \n  3'b101: regSelect= write? 8'b00100000: 8'b00000000; \n  3'b110: regSelect= write? 8'b01000000: 8'b00000000; \n  3'b111: regSelect= write? 8'b10000000: 8'b00000000; \n  default: regSelect= {8{1'bx}}; \n  endcase \n  end \n  DFlipFlopAllow #(.width(width)) loadreg0Data(clk, regSelect[0], data_in, reg0); \n  DFlipFlopAllow #(.width(width)) loadreg1Data(clk, regSelect[1], data_in, reg1); \n  DFlipFlopAllow #(.width(width)) loadreg2Data(clk, regSelect[2], data_in, reg2); \n  DFlipFlopAllow #(.width(width)) loadreg3Data(clk, regSelect[3], data_in, reg3); \n  DFlipFlopAllow #(.width(width)) loadreg4Data(clk, regSelect[4], data_in, reg4); \n  DFlipFlopAllow #(.width(width)) loadreg5Data(clk, regSelect[5], data_in, reg5); \n  DFlipFlopAllow #(.width(width)) loadreg6Data(clk, regSelect[6], data_in, reg6); \n  DFlipFlopAllow #(.width(width)) loadreg7Data(clk, regSelect[7], data_in, reg7); \n  always @(*) begin \n  case(vsel) \n  2'b00: data_in= mdata; \n  2'b01: data_in= sximm8; \n  2'b10: data_in= {8'b00000000, PC}; \n  2'b11: data_in= C; \n  default: data_in={16{1'bx}}; \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an arbiter for a memory system with multiple memory units. It uses priority encoding to determine which memory unit is selected for read and write operations. The module also handles data transfer between the memory units and the memory bus. The 'ms' signal indicates the selected memory unit, and various signals such as 'qs_cs', 'qs_we', 'qs_sel', 'qs_adr', 'qs_dat_w', 'qs_dat_r', 'qm_ack', and 'qm_err' control and monitor the memory bus operations.\n\n Module header:\n\nmodule qmem_arbiter #(parameter QAW = 32,parameter QDW = 32,parameter QSW = QDW/8,parameter MN = 2)(input wire clk,input wire rst,input wire [MN -1:0] qm_cs,input wire [MN -1:0] qm_we,input wire [MN*QSW-1:0] qm_sel,input wire [MN*QAW-1:0] qm_adr,input wire [MN*QDW-1:0] qm_dat_w,output wire [MN*QDW-1:0] qm_dat_r,output wire [MN -1:0] qm_ack,output wire [MN -1:0] qm_err,output wire qs_cs,output wire qs_we,output wire [QSW-1:0] qs_sel,output wire [QAW-1:0] qs_adr,output wire [QDW-1:0] qs_dat_w,input wire [QDW-1:0] qs_dat_r,input wire qs_ack,input wire qs_err,output wire [MN-1:0] ms);\n [/INST]\n", "output": "wire [3:0] ms_a; \n wire [MN-1:0] ms_tmp; \n reg [MN-1:0] ms_reg; \n genvar i; \n assign ms_tmp[0] = qm_cs[0]; \n generate for (i=1; i<MN; i=i+1) begin : loop_arbiter \n  assign ms_tmp[i] = qm_cs[i] & ~|qm_cs[i-1:0]; \n end endgenerate \n always @(posedge clk, posedge rst) begin \n  if (rst) ms_reg <= #1 0; \n  else if (qs_ack | qs_err) ms_reg <= #1 0; \n  else if (!(|ms_reg)) ms_reg <= #1 ms_tmp; \n end \n assign ms = |ms_reg ? ms_reg : ms_tmp; \n generate if (MN == 1) assign ms_a = 0; endgenerate \n generate if (MN == 2) assign ms_a = ms[1]?1:0; endgenerate \n generate if (MN == 3) assign ms_a = ms[2]?2:ms[1]?1:0; endgenerate \n generate if (MN == 4) assign ms_a = ms[3]?3:ms[2]?2:ms[1]?1:0; endgenerate \n generate if (MN == 5) assign ms_a = ms[4]?4:ms[3]?3:ms[2]?2:ms[1]?1:0; endgenerate \n generate if (MN == 6) assign ms_a = ms[5]?5:ms[4]?4:ms[3]?3:ms[2]?2:ms[1]?1:0; endgenerate \n generate if (MN == 7) assign ms_a = ms[6]?6:ms[5]?5:ms[4]?4:ms[3]?3:ms[2]?2:ms[1]?1:0; endgenerate \n generate if (MN == 8) assign ms_a = ms[7]?7:ms[6]?6:ms[5]?5:ms[4]?4:ms[3]?3:ms[2]?2:ms[1]?1:0; endgenerate \n assign qs_cs = qm_cs >> ms_a ; \n assign qs_we = qm_we >> ms_a ; \n assign qs_sel = qm_sel >> (QSW*ms_a); \n assign qs_adr = qm_adr >> (QAW*ms_a); \n assign qs_dat_w = qm_dat_w >> (QDW*ms_a); \n generate for (i=0; i<MN; i=i+1) begin : loop_bus \n  assign qm_dat_r [QDW*(i+1)-1:QDW*(i+1)-QDW] = qs_dat_r; \n end endgenerate \n assign qm_ack = ms & {MN{qs_ack}}; \n assign qm_err = ms & {MN{qs_err}}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a double altpriority encoder that takes a 16-bit input data and outputs a 4-bit encoded value. The input data is split into two 8-bit chunks, each of which is separately encoded using an altpriority encoder. The outputs of the two encoders are then combined using a logical operation to produce the final 4-bit encoded output.\n\n Module header:\n\nmodule acl_fp_sub_double_altpriority_encoder_r08 (data,q) ;\n [/INST]\n", "output": "input [15:0] data; \n  output [3:0] q; \n  wire [2:0] wire_altpriority_encoder17_q; \n  wire [2:0] wire_altpriority_encoder18_q; \n  wire wire_altpriority_encoder18_zero; \n  acl_fp_sub_double_altpriority_encoder_bv7 altpriority_encoder17 \n (.data(data[7:0]),.q(wire_altpriority_encoder17_q)); \n  acl_fp_sub_double_altpriority_encoder_be8 altpriority_encoder18 \n (.data(data[15:8]),.q(wire_altpriority_encoder18_q),.zero(wire_altpriority_encoder18_zero)); \n  assign \n  q = {(~ wire_altpriority_encoder18_zero), (({3{wire_altpriority_encoder18_zero}} & wire_altpriority_encoder17_q) | ({3{(~ wire_altpriority_encoder18_zero)}} & wire_altpriority_encoder18_q))}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes a signed 32-bit input and outputs the 14 most significant bits of the input as a signed 18-bit output. It uses the assign statement to perform this data type conversion and assign the result to the output.\n\n Module header:\n\nmodule controllerHdl_Convert_Data_Type_block (In1,Out1);\n [/INST]\n", "output": "input signed [31:0] In1; \n  output signed [17:0] Out1; \n  wire signed [17:0] Data_Type_Conversion_out1; \n  assign Data_Type_Conversion_out1 = In1[31:14]; \n  assign Out1 = Data_Type_Conversion_out1; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"comparator\" implements a comparison logic to detect errors between the reference input \"I_DAT_REF\" and the input \"I_DAT_IOB\" using shift registers. It also includes a counter to track the number of errors and a mechanism to assert the \"O_ERROR\" output when errors are detected.\n\nThe module uses shift registers to capture the input values, compares the bit values, and updates the error count based on the comparison result. Additionally, it includes a counter to hold the error signal for a specified duration.\n\nThe module's behavior is controlled by clock signals and a reset signal \"RST,\" and it employs various registers and wires to perform the comparison and error tracking.\n\n Module header:\n\nmodule comparator # (parameter ERROR_COUNT = 8,parameter ERROR_HOLD = 2500000) (input wire CLK,input wire RST,input wire I_DAT_REF,input wire I_DAT_IOB,output wire O_ERROR);\n [/INST]\n", "output": "reg [2:0] i_dat_ref_sr; \n reg [2:0] i_dat_iob_sr; \n always @(posedge CLK) \n  i_dat_ref_sr <= (i_dat_ref_sr << 1) | I_DAT_REF; \n always @(posedge CLK) \n  i_dat_iob_sr <= (i_dat_iob_sr << 1) | I_DAT_IOB; \n wire i_dat_ref = i_dat_ref_sr[2]; \n wire i_dat_iob = i_dat_iob_sr[2]; \n reg [31:0] sreg; \n reg [ 4:0] sreg_sel; \n wire sreg_dat; \n reg sreg_sh; \n always @(posedge CLK) \n  sreg <= (sreg << 1) | i_dat_ref; \n always @(posedge CLK) \n  if (RST) \n  sreg_sel <= 0; \n  else if(sreg_sh) \n  sreg_sel <= sreg_sel + 1; \n assign sreg_dat = sreg[sreg_sel]; \n wire cmp_err; \n reg [31:0] err_cnt; \n assign cmp_err = sreg_dat ^ i_dat_iob; \n always @(posedge CLK) \n  if (RST) \n  err_cnt <= 0; \n  else if(sreg_sh) \n  err_cnt <= 0; \n  else if(cmp_err) \n  err_cnt <= err_cnt + 1; \n always @(posedge CLK) \n  if (RST) \n  sreg_sh <= 0; \n  else if(~sreg_sh && (err_cnt == ERROR_COUNT)) \n  sreg_sh <= 1; \n  else \n  sreg_sh <= 0; \n reg [24:0] o_cnt; \n always @(posedge CLK) \n  if (RST) \n  o_cnt <= -1; \n  else if (cmp_err) \n  o_cnt <= ERROR_HOLD - 2; \n  else if (~o_cnt[24]) \n  o_cnt <= o_cnt - 1; \n assign O_ERROR = !o_cnt[24]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"test_for_datamem\" is used to test a data memory module. It instantiates a data memory module and provides input signals for clock, address, write data, memory write enable, and memory read enable. The clock signal is inverted for the data memory module, and its initial values are set to 0. After specific clock cycles, the memory write enable, address, write data, and memory read enable signals are changed to test the functionality of the data memory module.\n\n Module header:\n\nmodule test_for_datamem;\n [/INST]\n", "output": "reg clock_in; \n  reg [31:0] address; \n  reg [31:0] writeData; \n  reg memWrite; \n  reg memRead; \n  wire [31:0] readData; \n data_memory uut (.clock_in(clock_in),.address(address),.writeData(writeData),.memWrite(memWrite),.memRead(memRead),.readData(readData)); \n  always #100 clock_in = ~clock_in; \n  initial begin \n  clock_in = 0; \n  address = 0; \n  writeData = 0; \n  memWrite = 0; \n  memRead = 0; \n  #185; \n  memWrite = 1'b1; \n  address = 32'b00000000000000000000000000001111; \n  writeData = 32'b11111111111111110000000000000000; \n  #250; \n  memRead = 1'b1; \n  memWrite = 1'b0; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, system_auto_cc_0_rd_status_flags_as, connects inputs \\gc0.count_d1_reg[2], s_aclk, and AR to an FDPE module to generate two outputs, ram_empty_fb_i and ram_empty_i. The ram_empty_fb_i output is assigned to the out signal. The module essentially uses an FDPE module to generate the ram_empty_fb_i and ram_empty_i outputs based on the input signals.\n\n Module header:\n\nmodule system_auto_cc_0_rd_status_flags_as (out,\\gc0.count_d1_reg[2] ,s_aclk,AR);\n [/INST]\n", "output": "output out; \n  input \\gc0.count_d1_reg[2] ; \n  input s_aclk; \n  input [0:0]AR; \n  wire [0:0]AR; \n  wire \\gc0.count_d1_reg[2] ; \n  (* DONT_TOUCH *) wire ram_empty_fb_i; \n  (* DONT_TOUCH *) wire ram_empty_i; \n  wire s_aclk; \n  assign out = ram_empty_fb_i; \n  (* DONT_TOUCH *) \n  (* KEEP = \"yes\" *) \n  (* equivalent_register_removal = \"no\" *) \n FDPE #(.INIT(1'b1)) \n  ram_empty_fb_i_reg \n (.C(s_aclk),.CE(1'b1),.D(\\gc0.count_d1_reg[2] ),.PRE(AR),.Q(ram_empty_fb_i)); \n  (* DONT_TOUCH *) \n  (* KEEP = \"yes\" *) \n  (* equivalent_register_removal = \"no\" *) \n FDPE #(.INIT(1'b1)) \n  ram_empty_i_reg \n (.C(s_aclk),.CE(1'b1),.D(\\gc0.count_d1_reg[2] ),.PRE(AR),.Q(ram_empty_i)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, named shifter_32b, implements a configurable shifter that can shift a 32-bit input value by a specified number of positions. When the LENGTH parameter is greater than or equal to 4, the module instantiates an altshift_taps module to perform the shift operation. If LENGTH is less than 4, the module uses a series of taps to implement the shift. The taps are created using a for loop, where each tap stores the output of the previous tap. The last tap's output is assigned to the val_out. The shifter operates on the positive edge of the clock signal and has a synchronous behavior.\n\n Module header:\n\nmodule shifter_32b # (parameter LENGTH = 1) (input clk,input [31:0] val_in,output [31:0] val_out);\n [/INST]\n", "output": "genvar i; \n  generate \n  if (LENGTH >= 4) \n  begin \n  altshift_taps # (.number_of_taps(1), .tap_distance(LENGTH), .width(32)) shifttaps \n  (.clken(1'b1), .aclr(1'b0), .clock(clk), .shiftin(val_in), .taps(), .shiftout(val_out) ); \n  end \n  else \n  begin \n  for (i = 0; i < LENGTH; i = i + 1) begin : TAPS \n  reg [31:0] r; \n  wire [31:0] prev; \n  if (i == 0) \n  assign prev = val_in; \n  else \n  assign prev = TAPS[i-1].r; \n  always @ (posedge clk) \n  r <= prev; \n  end \n  assign val_out = TAPS[LENGTH-1].r; \n  end \n  endgenerate \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes an 8-bit input `iMop` and assigns a 9-bit output `oUopFlowIdx` based on the value of `iMop`. When `iMop` is `8'h7C`, `oUopFlowIdx` is set to 16. When `iMop` is `8'h11`, `oUopFlowIdx` is set to 69. When `iMop` is `8'h38`, `oUopFlowIdx` is set to 477. For any other value of `iMop`, `oUopFlowIdx` is set to 0.\n\n Module header:\n\nmodule dzcpu_ucode_cblut (input wire[7:0] iMop,output reg [8:0] oUopFlowIdx);\n [/INST]\n", "output": "always @ ( iMop ) \n begin \n  case ( iMop ) \n  8'h7C: oUopFlowIdx = 9'd16; \n  8'h11: oUopFlowIdx = 9'd69; \n  8'h38: oUopFlowIdx = 9'd477; \n  default: \n  oUopFlowIdx = 9'd0; \n  endcase \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"nsgpio16LE\" is designed as a register-based I/O controller. It has input and output registers for data and control signals. The \"ctrl,\" \"line,\" \"ddr,\" \"dbg,\" and \"lgpio\" registers are used for controlling input/output data and debug signals. The module decodes the address input to select the appropriate data registers for write operations and outputs the data based on the address. The \"ack_o\" output signal indicates whether a write access has been acknowledged. Additionally, the module updates the \"gpio\" signal based on the control, line, debug, attribute, ddr, and debug_1 registers. The \"igpio\" register is updated based on the control signals and data from the other registers, and the \"gpio\" output is assigned the value of \"igpio.\"\n\n Module header:\n\nmodule nsgpio16LE (input clk_i, input rst_i,input cyc_i, input stb_i, input [3:0] adr_i, input we_i, input [15:0] dat_i,output reg [15:0] dat_o, output reg ack_o,input [31:0] atr, input [31:0] debug_0, input [31:0] debug_1,inout [31:0] gpio);\n [/INST]\n", "output": "reg [31:0] ctrl, line, ddr, dbg, lgpio; \n  wire wb_acc = cyc_i & stb_i; \n  wire wb_wr = wb_acc & we_i; \n  always @(posedge clk_i or posedge rst_i) \n  if (rst_i) \n  begin \n  ctrl <= 32'h0; \n  line <= 32'h0; \n  ddr <= 32'h0; \n  dbg <= 32'h0; \n  end \n  else if (wb_wr) \n  case( adr_i[3:1] ) \n  3'b000 : \n  line[15:0] <= dat_i; \n  3'b001 : \n  line[31:16] <= dat_i; \n  3'b010 : \n  ddr[15:0] <= dat_i; \n  3'b011 : \n  ddr[31:16] <= dat_i; \n  3'b100 : \n  ctrl[15:0] <= dat_i; \n  3'b101 : \n  ctrl[31:16] <= dat_i; \n  3'b110 : \n  dbg[15:0] <= dat_i; \n  3'b111 : \n  dbg[31:16] <= dat_i; \n  endcase \n  always @(posedge clk_i) \n  case (adr_i[3:1]) \n  3'b000 : \n  dat_o <= lgpio[15:0]; \n  3'b001 : \n  dat_o <= lgpio[31:16]; \n  3'b010 : \n  dat_o <= ddr[15:0]; \n  3'b011 : \n  dat_o <= ddr[31:16]; \n  3'b100 : \n  dat_o <= ctrl[15:0]; \n  3'b101 : \n  dat_o <= ctrl[31:16]; \n  3'b110 : \n  dat_o <= dbg[15:0]; \n  3'b111 : \n  dat_o <= dbg[31:16]; \n  endcase \n  always @(posedge clk_i or posedge rst_i) \n  if (rst_i) \n  ack_o <= 1'b0; \n  else \n  ack_o <= wb_acc & !ack_o; \n  always @(posedge clk_i) \n  lgpio <= gpio; \n  integer n; \n  reg [31:0] igpio; \n  always @(ctrl or line or debug_1 or debug_0 or atr or ddr or dbg) \n  for(n=0;n<32;n=n+1) \n igpio[n] <= ddr[n] ? (dbg[n] ? (ctrl[n] ? debug_1[n] : debug_0[n]) :(ctrl[n] ? atr[n] : line[n]) ) \n  : 1'bz; \n  assign gpio = igpio; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module f3_test has two input ports, b and c, and one output port, a. It contains an always block that assigns the value of b to a when there's a change in the value of b or c, and assigns the value of c to a when there's a change in the value of b or c.\n\n Module header:\n\nmodule f3_test(a, b, c);\n [/INST]\n", "output": "input b, c; \n output reg a; \n always @(b or c) begin \n a = b; \n a = c; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a D flip-flop with asynchronous reset and enable signals. The flip-flop stores the value of input d on the rising edge of the clock signal when the enable signal is asserted, and is asynchronously cleared to 0 when the clear signal is low.\n\n Module header:\n\nmodule my_dffre_n (input d,clk,clr,en,output reg q);\n [/INST]\n", "output": "always @(posedge clk or negedge clr) \n  if (!clr) q <= 1'b0; \n  else if (en) q <= d; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a 4-bit multiplier. It calculates the product of the input A and B and outputs the result R. The module uses individual bit multiplication assignments followed by full adders to calculate the 8-bit product. It then assigns the calculated product to the output register R.\n\n Module header:\n\nmodule Multiplier(input [3:0] A,input [3:0] B,output [7:0] R);\n [/INST]\n", "output": "wire P00, P01, P02, P03, P10, P11, P12, P13, P20, P21, P22, P23, P30, P31, P32, P33; \n  assign P00 = A[0] & B[0]; \n  assign P01 = A[1] & B[0]; \n  assign P02 = A[2] & B[0]; \n  assign P03 = A[3] & B[0]; \n  assign P10 = A[0] & B[1]; \n  assign P11 = A[1] & B[1]; \n  assign P12 = A[2] & B[1]; \n  assign P13 = A[3] & B[1]; \n  assign P20 = A[0] & B[2]; \n  assign P21 = A[1] & B[2]; \n  assign P22 = A[2] & B[2]; \n  assign P23 = A[3] & B[2]; \n  assign P30 = A[0] & B[3]; \n  assign P31 = A[1] & B[3]; \n  assign P32 = A[2] & B[3]; \n  assign P33 = A[3] & B[3]; \n  wire [3:0] Part1_2; \n  wire [3:0] Part2_3; \n  wire Cout1_2, Cout2_3; \n FullAdder Part1 (.A({1'b0, P03, P02, P01}),.B({P13, P12, P11, P10}),.Operation(1'b0),.S(Part1_2),.Cout(Cout1_2)); \n FullAdder Part2 (.A({P23, P22, P21, P20}),.B({Cout1_2, Part1_2[3:1]}),.Operation(1'b0),.S(Part2_3),.Cout(Cout2_3)); \n wire [3:0] temp; \n FullAdder Part3 (.A({P33, P32, P31, P30}),.B({Cout2_3, Part2_3[3:1]}),.Operation(1'b0),.S(temp ),.Cout(R[7])); \n  assign R[6:3] = temp; \n  assign R[0] = P00; \n  assign R[1] = Part1_2[0]; \n  assign R[2] = Part2_3[0]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module represents a pixel RAM with a specified data width and address width. It contains a RAM array with a width of 2 to the power of ADDR_WIDTH and a data width of DATA_WIDTH. It has a write enable signal we_a and clock signals clk_a and clk_b. The module writes data to the RAM array when we_a is asserted on the rising edge of clk_a, and reads data from the RAM array on the rising edge of clk_b based on the address signal addr_b, storing the result in q_b.\n\n Module header:\n\nmodule pixel_ram #(parameter DATA_WIDTH=24, parameter ADDR_WIDTH=9) (input [(DATA_WIDTH-1):0] data_a,input [(ADDR_WIDTH-1):0] addr_a, addr_b,input we_a, clk_a, clk_b,output reg [(DATA_WIDTH-1):0] q_b);\n [/INST]\n", "output": "reg [DATA_WIDTH-1:0] ram[2**ADDR_WIDTH-1:0]; \n  always @ (posedge clk_a) \n  begin \n  if (we_a) \n  ram[addr_a] <= data_a; \n  end \n  always @ (posedge clk_b) \n  begin \n  q_b <= ram[addr_b]; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, named Ethernet, implements a set of logic and control signals to manage the behavior of an Ethernet interface. It includes functionality to generate specific control signals for data transmission and link status monitoring. The module involves handling various input signals and updating internal state variables based on clock edges and signal conditions. It also instantiates and uses several submodules to manage different aspects of the Ethernet functionality, including signal timing, counting, and pattern generation. Overall, this module orchestrates the behavior of an Ethernet interface through its internal control logic and external signal outputs.\n\n Module header:\n\nmodule Ethernet(txd, lcw, burst_start, link_up);\n [/INST]\n", "output": "(* LOC = \"P20\" *) \n  output link_up; \n  (* LOC = \"P19\" *) \n  (* DRIVE_STRENGTH = \"2X\" *) \n  output wire txd; \n  (* LOC = \"P18\" *) \n  output wire lcw; \n  (* LOC = \"P17\" *) \n  output burst_start; \n  wire por_done; \n  GP_POR #(.POR_TIME(500)) por (.RST_DONE(por_done)); \n  wire clk_hardip; \n  wire clk_fabric; \n GP_RCOSC #(.PWRDN_EN(0),.AUTO_PWRDN(0),.OSC_FREQ(\"2M\"),.HARDIP_DIV(1),.FABRIC_DIV(1)) rcosc (.PWRDN(1'b0),.CLKOUT_HARDIP(clk_hardip),.CLKOUT_FABRIC(clk_fabric)); \n  reg pulse_en = 0; \n GP_EDGEDET #(.DELAY_STEPS(1),.EDGE_DIRECTION(\"RISING\"),.GLITCH_FILTER(0)) delay(.IN(pulse_en),.OUT(txd)); \n  localparam PULSE_INTERVAL = 124; \n  reg[7:0] pulse_count = PULSE_INTERVAL; \n  wire pulse_start = (pulse_count == 0); \n  always @(posedge clk_hardip) begin \n  if(pulse_count == 0) \n  pulse_count <= PULSE_INTERVAL; \n  else \n  pulse_count <= pulse_count - 1'd1; \n  end \n  localparam BURST_INTERVAL = 15999; \n  reg[13:0] interval_count = BURST_INTERVAL; \n  wire burst_start_raw = (interval_count == 0); \n  always @(posedge clk_hardip) begin \n  if(interval_count == 0) \n  interval_count <= BURST_INTERVAL; \n  else \n  interval_count <= interval_count - 1'd1; \n  end \n  reg burst_start_t = 0; \n  reg burst_start = 0; \n  always @(posedge clk_fabric) begin \n  burst_start <= 0; \n  if(burst_start_raw) \n  burst_start_t <= !burst_start_t; \n  if(burst_start_t && burst_start_raw) \n  burst_start <= 1; \n  end \n  wire linkup_en; \n GP_COUNT14_ADV #(.CLKIN_DIVIDE(1),.COUNT_TO(128),.RESET_MODE(\"RISING\"),.RESET_VALUE(\"COUNT_TO\")) linkup_count (.CLK(clk_hardip),.RST(1'b0),.UP(1'b0),.KEEP(!burst_start),.OUT(linkup_en)); \n  reg pgen_reset = 1; \n  reg lcw_advance = 0; \n GP_PGEN #(.PATTERN_DATA(16'h8602),.PATTERN_LEN(5'd16)) pgen (.nRST(pgen_reset),.CLK(lcw_advance),.OUT(lcw)); \n  wire burst_done; \n GP_COUNT8_ADV #(.CLKIN_DIVIDE(1),.COUNT_TO(33),.RESET_MODE(\"RISING\"),.RESET_VALUE(\"COUNT_TO\")) burst_count (.CLK(clk_hardip),.RST(burst_start),.UP(1'b0),.KEEP(!pulse_start),.OUT(burst_done)); \n  reg next_pulse_is_lcw = 0; \n  reg burst_active = 0; \n  reg pulse_start_gated = 0; \n  reg link_up = 0; \n  always @(posedge clk_fabric) begin \n  lcw_advance <= 0; \n  pulse_en <= 0; \n  pgen_reset <= 1; \n  if(linkup_en) \n  link_up <= 1; \n  if(burst_start) begin \n  burst_active <= 1; \n  next_pulse_is_lcw <= 0; \n  lcw_advance <= 1; \n  end \n  else if(burst_done) begin \n  burst_active <= 0; \n  pgen_reset <= 0; \n  end \n  else if(link_up && pulse_start) begin \n  burst_active <= 0; \n  end \n  pulse_start_gated <= burst_active && pulse_start; \n  if(pulse_en && next_pulse_is_lcw) \n  lcw_advance <= 1; \n  if(pulse_start_gated) begin \n  if(next_pulse_is_lcw) \n  pulse_en <= lcw; \n  else \n  pulse_en <= 1'b1; \n  next_pulse_is_lcw <= ~next_pulse_is_lcw; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module takes two 32-bit inputs, dataA and dataB, and computes their sum. The result is stored in the 32-bit dataOut register, which is continuously updated when there's a change in dataA or dataB.\n\n Module header:\n\nmodule Adder(dataA, dataB, dataOut);\n [/INST]\n", "output": "input [31:0] dataA, dataB; \n output dataOut; \n reg [31:0] dataOut; \n always @ (dataA or dataB) \n begin \n  dataOut = dataA + dataB; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module Sks7 performs various bitwise operations and multiplication on the input ports a and b. It uses a few wire declarations and two instances of another module Sks4, which isn't described here. The outputs d are assigned based on the results of these operations, including bitwise XOR and multiplication, involving the intermediate wires m1, m2, m3, ahl, and bhl. The module ultimately manipulates and assigns the bits of d based on the results of the operations performed on the inputs a and b.\n\n Module header:\n\nmodule Sks7(a, b, d);\n [/INST]\n", "output": "input wire [6:0] a; \n input wire [6:0] b; \n output wire [12:0] d; \n wire [4:0] m1; \n wire [6:0] m2; \n wire [6:0] m3; \n wire [3:0] ahl; \n wire [3:0] bhl; \n Sks4 ksm1(a[3:0], b[3:0], m2); \n assign m1 = a[6:4] * b[6:4]; \n assign ahl[2:0] = a[6:4] ^ a[2:0]; \n assign ahl[3] = a[3]; \n assign bhl[2:0] = b[6:4] ^ b[2:0]; \n assign bhl[3] = b[3]; \n Sks4 ksm3(ahl, bhl, m3); \n assign d[00] = m2[00]; \n assign d[01] = m2[01]; \n assign d[02] = m2[02]; \n assign d[03] = m2[03]; \n assign d[04] = m2[04] ^ m1[00] ^ m2[00] ^ m3[00]; \n assign d[05] = m2[05] ^ m1[01] ^ m2[01] ^ m3[01]; \n assign d[06] = m2[06] ^ m1[02] ^ m2[02] ^ m3[02]; \n assign d[07] = m1[03] ^ m2[03] ^ m3[03]; \n assign d[08] = m1[04] ^ m2[04] ^ m3[04] ^ m1[00]; \n assign d[09] = m2[05] ^ m3[05] ^ m1[01]; \n assign d[10] = m2[06] ^ m3[06] ^ m1[02]; \n assign d[11] = m1[03]; \n assign d[12] = m1[04]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is designed to generate VGA signals for a display device. It uses the input clock and reset signals to drive the horizontal and vertical synchronization outputs. The color input is processed to generate the red, green, and blue signals for the VGA interface. The module includes counting registers to track the horizontal and vertical positions of the pixels. It also defines parameters for the number of pixels per line, the number of lines, and the blanking and porch periods. The module uses these parameters and the counting registers to generate the synchronization signals and calculate the pixel pointers. Finally, it uses the valid signal to determine if the current pixel is within the active display area, and uses this information to drive the VGA color signals.\n\n Module header:\n\nmodule Vga_dev(clk, reset, hsync, vsync, color, VGA_R, VGA_G, VGA_B, x_ptr, y_ptr);\n [/INST]\n", "output": "input clk; \n  input reset; \n  input [7: 0] color; \n  output vsync, hsync; \n  output [2: 0] VGA_R, VGA_G; \n  output [1: 0] VGA_B; \n  output [9: 0] x_ptr, y_ptr; \n  reg [9: 0] x_cnt, y_cnt; \n  reg [1: 0] cnt = 0; \n  wire [7: 0] color; \n  always @(posedge clk or posedge reset) begin \n  if (reset) cnt <= 0; \n  else cnt <= cnt + 1; \n  end \n  parameter \n  HPIXELS = 10'd800, \n  VLINES = 10'd521, \n  HBP = 10'd144, \n  HFP = 10'd784, \n  VBP = 10'd31, \n  VFP = 10'd511; \n  initial begin \n  x_cnt = 0; \n  y_cnt = 0; \n  end \n  always @(posedge cnt[1]) begin \n  if (x_cnt == HPIXELS - 1) \n  x_cnt <= 0; \n  else \n  x_cnt <= x_cnt + 1; \n  end \n  always @(posedge cnt[1]) begin \n  if (x_cnt == HPIXELS - 1) begin \n  if (y_cnt == VLINES - 1) \n  y_cnt <= 0; \n  else y_cnt <= y_cnt + 1; \n  end else \n  y_cnt <= y_cnt; \n  end \n  assign valid = (x_cnt > HBP) && (x_cnt < HFP) && (y_cnt > VBP) && (y_cnt < VFP); \n  assign hsync = (x_cnt >= 10'd96) ? 1'b1 : 1'b0; \n  assign vsync = (y_cnt >= 10'd2) ? 1'b1 : 1'b0; \n  assign x_ptr = x_cnt - HBP; \n  assign y_ptr = y_cnt - VBP; \n  assign VGA_R = valid ? color[7: 5] : 0; \n  assign VGA_G = valid ? color[4: 2] : 0; \n  assign VGA_B = valid ? color[1: 0] : 0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a parameterized shift register with a defined element width and depth. The input data is shifted through the register on each clock pulse, and the output is the last element of the register, effectively shifting the input through the register and providing a delayed output.\n\n Module header:\n\nmodule parameterized_shift_packed (clk, in, out);\n [/INST]\n", "output": "parameter elementWidth = 32; \n  parameter depth = 64; \n  input clk; \n  input [(elementWidth-1):0] in; \n  output [(elementWidth-1):0] out; \n  reg [(elementWidth-1):0] sr[0:(depth-1)]; \n  always@(posedge clk) begin \n  sr[1:(depth-1)] <= sr[0:(depth-2)]; \n  sr[0] <= in; \n  end \n  assign out = sr[depth-1]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a data permutation circuit with handshake signals for input and output. It includes a counter for the number of rounding iterations and uses a calculation register for rounding. The module generates acknowledgement and ready signals for data processing and implements a rounding correction when required. The design ensures proper data flow and synchronization using clock and reset signals.\n\n Module header:\n\nmodule f_permutation(clk, reset, in, in_ready, ack, out, out_ready);\n [/INST]\n", "output": "input clk, reset; \n  input [575:0] in; \n  input in_ready; \n  output ack; \n  output reg [1599:0] out; \n  output reg out_ready; \n  reg [10:0] i; \n  wire [1599:0] round_in, round_out; \n  wire [63:0] rc1, rc2; \n  wire update; \n  wire accept; \n  reg calc; \n  assign accept = in_ready & (~ calc); \n  always @ (posedge clk) \n  if (reset) i <= 0; \n  else i <= {i[9:0], accept}; \n  always @ (posedge clk) \n  if (reset) calc <= 0; \n  else calc <= (calc & (~ i[10])) | accept; \n  assign update = calc | accept; \n  assign ack = accept; \n  always @ (posedge clk) \n  if (reset) \n  out_ready <= 0; \n  else if (accept) \n  out_ready <= 0; \n  else if (i[10]) \n  out_ready <= 1; \n  assign round_in = accept ? {in ^ out[1599:1599-575], out[1599-576:0]} : out; \n  rconst2in1 \n  rconst_ ({i, accept}, rc1, rc2); \n  round2in1 \n  round_ (round_in, rc1, rc2, round_out); \n  always @ (posedge clk) \n  if (reset) \n  out <= 0; \n  else if (update) \n  out <= round_out; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module serves as a coprocessor interface and control unit. It takes in various control signals such as the clock signal, core stall signal, coprocessor control signals, data for the coprocessor, fault signals, fault status, and fault address. It also provides outputs for coprocessor read data, cache enable signal, cache flush signal, and cacheable area.\n\nThe module includes logic to handle fault status and fault address updates, as well as updating cache control based on the coprocessor operation and control register number. It also manages the coprocessor read data based on the coprocessor operation and control register number.\n\nThe module essentially acts as a bridge between the core processor and the coprocessor, handling various control and data signals to manage coprocessor operations and cache control.\n\n Module header:\n\nmodule a25_coprocessor(i_clk,i_core_stall,i_copro_crn,i_copro_operation,i_copro_write_data,i_fault,i_fault_status,i_fault_address,o_copro_read_data,o_cache_enable,o_cache_flush,o_cacheable_area);\n [/INST]\n", "output": "input i_clk; \n input i_core_stall; \n input [3:0] i_copro_crn; \n input [1:0] i_copro_operation; \n input [31:0] i_copro_write_data; \n input i_fault; \n input [7:0] i_fault_status; \n input [31:0] i_fault_address; \n output [31:0] o_copro_read_data; \n output o_cache_enable; \n output o_cache_flush; \n output [31:0] o_cacheable_area; \n reg [31:0] o_copro_read_data; \n reg [2:0] cache_control = 3'b000; \n reg [31:0] cacheable_area = 32'h0; \n reg [31:0] updateable_area = 32'h0; \n reg [31:0] disruptive_area = 32'h0; \n reg [7:0] fault_status = 8'd0; \n reg [31:0] fault_address = 32'b0; \n wire copro15_reg1_write; \n assign o_cache_enable = cache_control[0]; \n assign o_cache_flush = copro15_reg1_write; \n assign o_cacheable_area = cacheable_area; \n always @ ( posedge i_clk ) \n  if ( !i_core_stall ) \n  begin \n  if ( i_fault ) \n  begin \n  fault_status <= i_fault_status; \n  fault_address <= i_fault_address; \n  end \n  end \n always @ ( posedge i_clk ) \n  if ( !i_core_stall ) \n  begin \n  if ( i_copro_operation == 2'd2 ) \n  case ( i_copro_crn ) \n  4'd2: cache_control <= i_copro_write_data[2:0]; \n  4'd3: cacheable_area <= i_copro_write_data[31:0]; \n  4'd4: updateable_area <= i_copro_write_data[31:0]; \n  4'd5: disruptive_area <= i_copro_write_data[31:0]; \n  default: cache_control <=cache_control; \n  endcase \n  end \n assign copro15_reg1_write = !i_core_stall && i_copro_operation == 2'd2 && i_copro_crn == 4'd1; \n always @ ( posedge i_clk ) \n  if ( !i_core_stall ) \n  case ( i_copro_crn ) \n  4'd0: o_copro_read_data <= 32'h41560300; \n  4'd2: o_copro_read_data <= {29'd0, cache_control}; \n  4'd3: o_copro_read_data <= cacheable_area; \n  4'd4: o_copro_read_data <= updateable_area; \n  4'd5: o_copro_read_data <= disruptive_area; \n  4'd6: o_copro_read_data <= {24'd0, fault_status }; \n  4'd7: o_copro_read_data <= fault_address; \n  default: o_copro_read_data <= 32'd0; \n  endcase \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module performs exponential operations using three input data streams and produces an output result along with overflow and underflow flags. The module utilizes various submodules to handle addition or subtraction, overflow, and underflow conditions, as well as comparison operations. The module also applies different constraints based on the value of the EW parameter. The outputs are derived based on the input data and specific conditions, and all calculations are synchronized with the clock signal.\n\n Module header:\n\nmodule Exp_Operation_m #(parameter EW = 8) (input wire clk,input wire rst,input wire load_a_i,input wire load_b_i,input wire load_c_i,input wire [EW:0] Data_A_i,input wire [EW:0] Data_B_i,input wire Add_Subt_i,output wire [EW:0] Data_Result_o,output wire Overflow_flag_o,output wire Underflow_flag_o);\n [/INST]\n", "output": "wire [EW:0] Data_S; \n wire Overflow_A; \n wire Overflow_flag_A; \n wire underflow_exp_reg; \n wire [EW:0] U_Limit; \n add_sub_carry_out #(.W(EW+1)) exp_add_subt_m(.op_mode (Add_Subt_i),.Data_A (Data_A_i),.Data_B (Data_B_i),.Data_S ({Overflow_A,Data_S})); \n RegisterMult #(.W(EW+1)) exp_result_m(.clk (clk),.rst (rst),.load (load_c_i),.D (Data_S),.Q (Data_Result_o)); \n RegisterMult#(.W(1)) Oflow_A_m (.clk(clk),.rst(rst),.load(load_b_i),.D(Overflow_A),.Q(Overflow_flag_A)); \n assign Overflow_flag_o = Overflow_flag_A | Data_Result_o[EW]; \n Comparator_Less #(.W(EW+1)) Exp_unflow_Comparator_m (.Data_A(Data_S),.Data_B(U_Limit),.less(underflow_exp_reg)); \n RegisterMult #(.W(1)) Underflow_m (.clk(clk),.rst(rst),.load(load_a_i),.D(underflow_exp_reg),.Q(Underflow_flag_o)); \n generate \n  if (EW == 8) \n  assign U_Limit = 9'd127; \n  else \n  assign U_Limit = 12'd1023; \n endgenerate \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes a 4-bit input and performs the operation of subtracting the input from 5. The result is stored in a 5-bit wire called fiveminus. If the most significant bit of fiveminus is not set, the 4-bit output o is assigned the value of the lower 4 bits of fiveminus; otherwise, o is set to 4'b0.\n\n Module header:\n\nmodule fiveminusmax0(input [3:0] i,output [3:0] o);\n [/INST]\n", "output": "wire [4:0] fiveminus; \n assign fiveminus = 5'd5 - {1'b0,i}; \n assign o = ( !fiveminus[4]) ? fiveminus[3:0] : 4'b0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module defines a logic gate that computes the logical AND of inputs a and b and stores the result in the output o. The o output is a register, and the logic is implemented using an always block with the @* sensitivity list to continuously update the output based on changes in the input signals a and b.\n\n Module header:\n\nmodule has_ports (output reg o, input wire a, input wire b);\n [/INST]\n", "output": "always @* o <= a & b; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, named \"pulse,\" generates a pulse signal based on the input clock and reset signals. It uses the parameters \"dly\" and \"len\" to determine the duration and length of the pulse. The module utilizes two always blocks to control the pulse generation: one for the reset and count management and the other for updating the pulse signal based on the count value. The count is incremented on each clock cycle, and when it reaches the specified delay, the pulse signal is set to 1. After the total duration (delay + length), the pulse signal is set back to 0.\n\n Module header:\n\nmodule pulse #(parameter dly=3,parameter len=2) (input rstn,input clk,output reg pulse);\n [/INST]\n", "output": "localparam width = $clog2(dly+len)+1; \n  reg [width-1:0] cnt; \n  always @(posedge clk or negedge rstn) begin \n  if (~rstn) \n  cnt <= 1'b0; \n  else if (cnt != dly+len) \n  cnt <= cnt + 1'b1; \n  end \n  always @(posedge clk or negedge rstn) begin \n  if (~rstn) \n  pulse <= 1'b0; \n  else if (cnt == dly) \n  pulse <= 1'b1; \n  else if (cnt == dly+len) \n  pulse <= 1'b0; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a top-level harness for integrating and connecting various sub-modules. It instantiates several sub-modules and connects them using ready signals and process input/output ports. The module coordinates the flow of data and control signals between the instantiated sub-modules based on the ready and process signals. The sub-modules included are responsible for different functions such as overflow, underflow, cycle counting, and input/output data processing. The module also includes parameters and wires to manage the flow of data and control signals between the sub-modules.\n\n Module header:\n\nmodule harness4(input CLK, input ready_downstream, output ready, input reset, input process_input, output [64:0] process_output);\n [/INST]\n", "output": "parameter INSTANCE_NAME=\"INST\"; \n parameter OUTPUT_COUNT=0; \n parameter INPUT_COUNT=0; \n  wire fwrite_ready; \n  wire cycleCounter_ready; \n  wire underflow_ready; \n  wire overflow_ready; \n  wire HARNESS_inner_ready; \n  wire fread_ready; \n  wire inpdata_ready; \n  wire underflow_US_ready; \n  assign ready = underflow_US_ready; \n  wire [0:0] underflow_US_process_output; \n  wire [0:0] inpdata_process_output; \n  wire [64:0] fread_process_output; \n  wire [64:0] HARNESS_inner_process_output; \n  wire [64:0] overflow_process_output; \n  wire [64:0] underflow_process_output; \n  wire [64:0] cycleCounter_process_output; \n  wire [64:0] fwrite_process_output; \n  assign process_output = fwrite_process_output; \n  Underflow_A_null_null__count153600_cycles1874016_toosoon156168_UStrue #(.INSTANCE_NAME({INSTANCE_NAME,\"_underflow_US\"})) underflow_US(.CLK(CLK), .ready_downstream(inpdata_ready), .ready(underflow_US_ready), .reset(reset), .process_input(process_input), .process_output(underflow_US_process_output)); \n  MakeHandshake_index__null_null__0 #(.INSTANCE_NAME({INSTANCE_NAME,\"_inpdata\"})) inpdata(.CLK(CLK), .ready_downstream(fread_ready), .ready(inpdata_ready), .reset(reset), .process_input(underflow_US_process_output), .process_output(inpdata_process_output)); \n  MakeHandshake_freadSeq____ov7660_raw_dup #(.INSTANCE_NAME({INSTANCE_NAME,\"_fread\"})) fread(.CLK(CLK), .ready_downstream(HARNESS_inner_ready), .ready(fread_ready), .reset(reset), .process_input(inpdata_process_output), .process_output(fread_process_output)); \n  hsfn #(.INSTANCE_NAME({INSTANCE_NAME,\"_HARNESS_inner\"})) HARNESS_inner(.CLK(CLK), .ready_downstream(overflow_ready), .ready(HARNESS_inner_ready), .reset(reset), .process_input(fread_process_output), .process_output(HARNESS_inner_process_output)); \n  LiftHandshake_LiftDecimate_Overflow_307200 #(.INSTANCE_NAME({INSTANCE_NAME,\"_overflow\"})) overflow(.CLK(CLK), .ready_downstream(underflow_ready), .ready(overflow_ready), .reset(reset), .process_input(HARNESS_inner_process_output), .process_output(overflow_process_output)); \n  Underflow_Auint8_4_1__2_1__count307200_cycles468504_toosoon156168_USfalse #(.INSTANCE_NAME({INSTANCE_NAME,\"_underflow\"})) underflow(.CLK(CLK), .ready_downstream(cycleCounter_ready), .ready(underflow_ready), .reset(reset), .process_input(overflow_process_output), .process_output(underflow_process_output)); \n  CycleCounter_Auint8_4_1__2_1__count153600 #(.INSTANCE_NAME({INSTANCE_NAME,\"_cycleCounter\"})) cycleCounter(.CLK(CLK), .ready_downstream(fwrite_ready), .ready(cycleCounter_ready), .reset(reset), .process_input(underflow_process_output), .process_output(cycleCounter_process_output)); \n  MakeHandshake_fwriteSeq_campipe_ov7660_half_sim_raw #(.INSTANCE_NAME({INSTANCE_NAME,\"_fwrite\"})) fwrite(.CLK(CLK), .ready_downstream(ready_downstream), .ready(fwrite_ready), .reset(reset), .process_input(cycleCounter_process_output), .process_output(fwrite_process_output)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module generates a constant 32-bit value and assigns it to the output signal \"op\" when the clock signal \"clk,\" clock enable signal \"ce,\" and clear signal \"clr\" are provided.\n\n Module header:\n\nmodule sysgen_constant_b4741603e8 (output [(32 - 1):0] op,input clk,input ce,input clr);\n [/INST]\n", "output": "assign op = 32'b00000111111111110000000000000000; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a 26-bit counter 'r', a delay element 'l', and a pulse 'p' generation. When the reset signal is high, the counter is reset and 'l' is set to 0. On each rising clock edge, the counter increments unless it is already at the maximum value. If the input 'in' is high, the counter is set to 1 and 'l' is set to 1. If 'p' is high, the counter and 'l' are both set to 0. The output 'p' is set to 1 when the counter reaches a value of 50000000.\n\n Module header:\n\nmodule ldly1s(input clk, input reset, input in, output p, output reg l);\n [/INST]\n", "output": "reg [26-1:0] r; \n  always @(posedge clk or posedge reset) begin \n  if(reset) begin \n  r <= 0; \n  l <= 0; \n  end else begin \n  if(r) \n  r <= r + 26'b1; \n  if(in) begin \n  r <= 1; \n  l <= 1; \n  end \n  if(p) begin \n  r <= 0; \n  l <= 0; \n  end \n  end \n  end \n  assign p = r == 50000000; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a clock generator that produces a square wave clock signal based on the input clock, enable, reset, limit, and count signals. It utilizes a 32-bit counter to keep track of the count and compares it with the limit to determine the next clock edge. The output done indicates when the count exceeds the limit.\n\n Module header:\n\nmodule clk_generator(input clk,input en,input rst,input [31:0] limit,input [31:0] count,output reg clk_0,output reg done);\n [/INST]\n", "output": "reg [31:0] ndCount; \n  initial clk_0 = 1'b0; \n  initial ndCount = 32'h00000000; \n  always@(negedge clk) begin \n  if(en) begin \n  if(count > ndCount) begin \n  ndCount <= count + limit; \n  clk_0 <= ~clk_0; \n  end \n  else begin \n  ndCount <= ndCount; \n  clk_0 <= clk_0; \n  end \n  end \n  else begin \n  ndCount <= count+limit; \n  clk_0 <= 1'b0; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, named \"packet2emesh,\" takes in a 104-bit packet and extracts various fields from it. It outputs the access control, write control, data mode, control mode, destination address, data, and source address. The specific fields are extracted and assigned to the corresponding outputs based on their positions within the input packet.\n\n Module header:\n\nmodule packet2emesh(access_out, write_out, datamode_out, ctrlmode_out, dstaddr_out,data_out, srcaddr_out,packet_in);\n [/INST]\n", "output": "parameter AW=32; \n  parameter DW=32; \n  parameter PW=104; \n  output access_out; \n  output write_out; \n  output [1:0] datamode_out; \n  output [3:0] ctrlmode_out; \n  output [AW-1:0] dstaddr_out; \n  output [DW-1:0] data_out; \n  output [AW-1:0] srcaddr_out; \n  input [PW-1:0] packet_in; \n  assign access_out = packet_in[0]; \n  assign write_out = packet_in[1]; \n  assign datamode_out[1:0] = packet_in[3:2]; \n  assign ctrlmode_out[3:0] = packet_in[7:4]; \n  assign dstaddr_out[AW-1:0] = packet_in[39:8]; \n  assign data_out[AW-1:0] = packet_in[71:40]; \n  assign srcaddr_out[AW-1:0] = packet_in[103:72]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module implements a debouncer to filter out noise in a digital input signal. It uses a counter to determine if the input signal is stable over a specified number of clock cycles. The synchronizer module ensures that the input signal is sampled synchronously with the clock. The clean output signal is asserted only when the filtered input is stable and free from noise.\n\n Module header:\n\nmodule debouncer (clean_out,clk, noisy_in);\n [/INST]\n", "output": "parameter N = 20; \n  input clk; \n  input noisy_in; \n  output clean_out; \n  wire expired; \n  wire sync_in; \n  reg [N-1:0] counter; \n  wire filtering; \n synchronizer #(1) synchronizer(.out (sync_in),.in (noisy_in),.clk (clk),.reset (1'b0)); \n  always @ (posedge clk) \n  if(sync_in) \n  counter[N-1:0]={(N){1'b1}}; \n  else if(filtering) \n  counter[N-1:0]=counter[N-1:0]-1'b1; \n  assign filtering =|counter[N-1:0]; \n  assign clean_out = filtering | sync_in; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a structural design that instantiates other modules and assigns their inputs and outputs. It contains input, output, and inout ports, as well as wire connections to connect the ports of the instantiated modules. The module serves as a higher-level composition of lower-level modules and interconnects them to achieve a larger functionality.\n\n Module header:\n\nmodule inst_a_e (p_mix_sig_in_01_gi,p_mix_sig_in_03_gi,p_mix_sig_io_05_gc,p_mix_sig_io_06_gc,p_mix_sig_out_02_go,p_mix_sig_out_04_go);\n [/INST]\n", "output": "input p_mix_sig_in_01_gi; \n  input [7:0] p_mix_sig_in_03_gi; \n  inout [5:0] p_mix_sig_io_05_gc; \n  inout [6:0] p_mix_sig_io_06_gc; \n  output p_mix_sig_out_02_go; \n  output [7:0] p_mix_sig_out_04_go; \n  wire p_mix_sig_in_01_gi; \n  wire [7:0] p_mix_sig_in_03_gi; \n  wire [5:0] p_mix_sig_io_05_gc; \n  wire [6:0] p_mix_sig_io_06_gc; \n  wire p_mix_sig_out_02_go; \n  wire [7:0] p_mix_sig_out_04_go; \n  wire sig_in_01; \n  wire [7:0] sig_in_03; \n  wire [5:0] sig_io_05; \n  wire [6:0] sig_io_06; \n  wire sig_out_02; \n  wire [7:0] sig_out_04; \n  assign sig_in_01 = p_mix_sig_in_01_gi; \n  assign sig_in_03 = p_mix_sig_in_03_gi; \n  assign sig_io_05 = p_mix_sig_io_05_gc; \n  assign sig_io_06 = p_mix_sig_io_06_gc; \n  assign p_mix_sig_out_02_go = sig_out_02; \n  assign p_mix_sig_out_04_go = sig_out_04; \n inst_aa_e inst_aa(.sig_in_01_p(sig_in_01),.sig_in_03_p(sig_in_03),.sig_io_out_05_p(sig_io_05),.sig_io_out_06_p(sig_io_06),.sig_out_02_p(sig_out_02),.sig_out_04_p(sig_out_04)); \n inst_ab_e inst_ab(); \n inst_ac_e inst_ac(); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `HazardCheckUnit` checks for data hazards in a pipelined processor. It has various inputs like IDEXRt, IFIDRt, IFIDRs, IDEXRd, EXMEMRt, IDEXMemRead, IDEXRegWrite, EXMEMRead, opcode, and clk. The module sets outputs PCWrite, IFIDWrite, and ctrlSetZero based on the inputs and opcode. It updates these outputs based on the conditions related to data hazards and the opcode of the instruction. It uses an always block sensitive to the inputs and opcode to continuously monitor and update the outputs.\n\n Module header:\n\nmodule HazardCheckUnit(IDEXMemRead,IDEXRt,IFIDRs,IFIDRt,PCWrite,IFIDWrite,ctrlSetZero,IDEXRd,IDEXRegWrite,opcode,EXMEMRead,EXMEMRt,clk);\n [/INST]\n", "output": "input[4:0] IDEXRt,IFIDRt,IFIDRs,IDEXRd,EXMEMRt; \n  input IDEXMemRead,IDEXRegWrite,EXMEMRead; \n  input[5:0] opcode; \n  input clk; \n  output PCWrite,IFIDWrite,ctrlSetZero; \n  reg PCWrite,IFIDWrite,ctrlSetZero; \n  initial \n  begin \n  PCWrite<=1; \n  IFIDWrite<=1; \n  ctrlSetZero<=0; \n  end \n  always @(opcode or IDEXMemRead or IDEXRt or IFIDRs or IFIDRt or IDEXRd or IDEXRegWrite or clk) begin \n  if(opcode==6'b000100)begin \n  if(IDEXMemRead && ((IDEXRt==IFIDRs) || (IDEXRt==IFIDRt))) begin \n  PCWrite<=0; \n  IFIDWrite<=0; \n  ctrlSetZero<=1; \n  end \n  else if(IDEXRegWrite && ((IDEXRd==IFIDRs) || (IDEXRd==IFIDRt)))begin \n  PCWrite<=0; \n  IFIDWrite<=0; \n  ctrlSetZero<=1; \n  end \n  else begin \n  PCWrite<=1; \n  IFIDWrite<=1; \n  ctrlSetZero<=0; \n  end \n  if(EXMEMRead && ((EXMEMRt==IFIDRs) || (EXMEMRt==IFIDRt)))begin \n  PCWrite<=0; \n  IFIDWrite<=0; \n  ctrlSetZero<=1; \n  end \n  end \n  else begin \n  if(IDEXMemRead && ((IDEXRt==IFIDRs) || (IDEXRt==IFIDRt))) begin \n  PCWrite<=0; \n  IFIDWrite<=0; \n  ctrlSetZero<=1; \n  end \n  else begin \n  PCWrite<=1; \n  IFIDWrite<=1; \n  ctrlSetZero<=0; \n  end \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is designed to interface with a 7-segment display. The input `num` represents a 4-bit binary number, and based on its value, the module determines the appropriate pattern to display on the 7-segment display. It uses a conditional operator to check the value of `num` and assign the corresponding 7-bit pattern to the `display` output. If `num` doesn't match any of the predefined values, the display remains blank.\n\n Module header:\n\nmodule seven_seg (input [3:0] num,output [6:0] display);\n [/INST]\n", "output": "assign display = \n  num == 0 ? ~7'b0111111: \n  num == 1 ? ~7'b0000110: \n  num == 2 ? ~7'b1011011: \n  num == 3 ? ~7'b1001111: \n  num == 4 ? ~7'b1100110: \n  num == 5 ? ~7'b1101101: \n  num == 6 ? ~7'b1111101: \n  num == 7 ? ~7'b0000111: \n  num == 8 ? ~7'b1111111: \n  num == 9 ? ~7'b1100111: \n  7'bxxxxxxx; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module represents a flip-flop with clock and cs inputs, and ns as the output. The flip-flop stores the value of cs on the rising edge of the clock and holds it until the next rising edge. The temporary variable is used to hold the value of cs before assigning it to ns.\n\n Module header:\n\nmodule f10_FlipFlop(clock, cs, ns);\n [/INST]\n", "output": "input clock; \n input cs; \n output reg ns; \n reg temp; \n always @(posedge clock) \n begin \n  temp <= cs; \n  ns <= temp; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes an 8-bit input and outputs a 7-bit value to drive a 7-segment display. It uses a combinational logic to assign the 7-segment display code for each digit based on the input value. For example, if the input is 0, the output is the code for displaying 0 on a 7-segment display.\n\n Module header:\n\nmodule number_to_seg(input[7:0] d, output[6:0] seg);\n [/INST]\n", "output": "assign seg = (d == 0) ? 7'b1000000 : \n  (d == 1) ? 7'b1111001 : \n  (d == 2) ? 7'b0100100 : \n  (d == 3) ? 7'b0110000 : \n  (d == 4) ? 7'b0011001 : \n  (d == 5) ? 7'b0010010 : \n  (d == 6) ? 7'b0000010 : \n  (d == 7) ? 7'b1111000 : \n  (d == 8) ? 7'b0000000 : \n  (d == 9) ? 7'b0010000 : 7'b1000000; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module implements a 16-bit carry-lookahead adder. It consists of 16 ripple carry adder (RFA) blocks for adding each pair of bits from the input vectors a and b. The outputs of the RFAs are then fed into 4-bit carry-lookahead generator (BCLG4) blocks, which generate the carries for the addition. Finally, the module calculates the carry-out and assigns it to the most significant bit of the sum. The module utilizes hierarchical instantiation to create the adder using smaller building blocks and interconnects their outputs to achieve the final functionality of the 16-bit adder.\n\n Module header:\n\nmodule cla16(sum, a, b);\n [/INST]\n", "output": "output [16:0] sum; \n  input [15:0] a,b; \n  wire [14:0] carry; \n  wire [15:0] g, p; \n  wire [4:0] gout, pout; \n  rfa rfa0(sum[0], g[0], p[0], a[0], b[0], 1'b0); \n  rfa rfa1(sum[1], g[1], p[1], a[1], b[1], carry[0]); \n  rfa rfa2(sum[2], g[2], p[2], a[2], b[2], carry[1]); \n  rfa rfa3(sum[3], g[3], p[3], a[3], b[3], carry[2]); \n  bclg4 bclg30(carry[2:0], gout[0], pout[0], g[3:0], p[3:0], 1'b0); \n  rfa rfa4(sum[4], g[4], p[4], a[4], b[4], carry[3]); \n  rfa rfa5(sum[5], g[5], p[5], a[5], b[5], carry[4]); \n  rfa rfa6(sum[6], g[6], p[6], a[6], b[6], carry[5]); \n  rfa rfa7(sum[7], g[7], p[7], a[7], b[7], carry[6]); \n  bclg4 bclg74(carry[6:4], gout[1], pout[1], g[7:4], p[7:4], carry[3]); \n  rfa rfa8(sum[8], g[8], p[8], a[8], b[8], carry[7]); \n  rfa rfa9(sum[9], g[9], p[9], a[9], b[9], carry[8]); \n  rfa rfa10(sum[10], g[10], p[10], a[10], b[10], carry[9]); \n  rfa rfa11(sum[11], g[11], p[11], a[11], b[11], carry[10]); \n  bclg4 bclg118(carry[10:8], gout[2], pout[2], g[11:8], p[11:8], carry[7]); \n  rfa rfa12(sum[12], g[12], p[12], a[12], b[12], carry[11]); \n  rfa rfa13(sum[13], g[13], p[13], a[13], b[13], carry[12]); \n  rfa rfa14(sum[14], g[14], p[14], a[14], b[14], carry[13]); \n  rfa rfa15(sum[15], g[15], p[15], a[15], b[15], carry[14]); \n  bclg4 bclg1512(carry[14:12], gout[3], pout[3], g[15:12], p[15:12], carry[11]); \n  bclg4 bclg_150({carry[11], carry[7], carry[3]}, gout[4], pout[4], {gout[3], gout[2], gout[1], gout[0]}, {pout[3], pout[2], pout[1], pout[0]}, 1'b0); \n  assign sum[16] = gout[4]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a register module with a read/write data path. It takes in clock and reset signals, along with several control and data signals, and generates read and write responses. The module maintains a wait state machine to handle read and write operations, and also validates the output data and wait requests. It resets the input and output data, wait requests, and wait counter on a reset signal. The read and write data paths handle byte enable signals to write or invert specific bytes of the data based on the address. The output read data, read data validity, and wait request signals are assigned based on the internal logic of the module.\n\n Module header:\n\nmodule test_RegWaitRW32(input rsi_MRST_reset,input csi_MCLK_clk,input [31:0] avs_test_writedata,output [31:0] avs_test_readdata,input [5:0] avs_test_address,input [3:0] avs_test_byteenable,input avs_test_write,input avs_test_read,output avs_test_readdatavalid,output avs_test_waitrequest);\n [/INST]\n", "output": "reg [31:0] out_data = 0; \n reg [31:0] r_data = 0; \n reg r_wait = 0; \n reg [3:0] r_wait_cnt = 0; \n reg r_valid = 0; \n assign avs_test_readdata = out_data; \n assign avs_test_waitrequest = r_wait; \n assign avs_test_readdatavalid = r_valid; \n always@(posedge csi_MCLK_clk or posedge rsi_MRST_reset) \n begin \n  if(rsi_MRST_reset) begin \n  out_data <= 0; \n  r_data <= 0; \n  r_wait <= 0; \n  r_wait_cnt <= 0; \n  r_valid <= 0; \n  end \n  else begin \n  if(r_wait_cnt == 15) r_valid <= 1; else r_valid <= 0; \n  if(((r_wait_cnt > 0)&&(r_wait_cnt < 15))||(avs_test_read)||(avs_test_write)) r_wait <= 1; else r_wait <= 0; \n  if(avs_test_read) begin \n  r_wait_cnt <= r_wait_cnt + 1; \n  out_data <= r_data + avs_test_address; \n  end \n  else if(avs_test_write) begin \n  r_wait_cnt <= r_wait_cnt + 1; \n  case(avs_test_address) \n  0: begin \n  if(avs_test_byteenable[3]) r_data[31:24] <= avs_test_writedata[31:24]; \n  if(avs_test_byteenable[2]) r_data[23:16] <= avs_test_writedata[23:16]; \n  if(avs_test_byteenable[1]) r_data[15:8] <= avs_test_writedata[15:8]; \n  if(avs_test_byteenable[0]) r_data[7:0] <= avs_test_writedata[7:0]; \n  end \n  1: begin \n  if(avs_test_byteenable[3]) r_data[31:24] <= ~avs_test_writedata[31:24]; \n  if(avs_test_byteenable[2]) r_data[23:16] <= ~avs_test_writedata[23:16]; \n  if(avs_test_byteenable[1]) r_data[15:8] <= ~avs_test_writedata[15:8]; \n  if(avs_test_byteenable[0]) r_data[7:0] <= ~avs_test_writedata[7:0]; \n  end \n  default: begin \n  r_data <= 0; \n  end \n  endcase \n  end \n  else begin \n  if(r_wait_cnt > 0) r_wait_cnt <= r_wait_cnt + 1; else r_wait_cnt <= 0; \n  end \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `imu_controller` interfaces with an IMU chip and an ADC. It has inputs for chip select, address, read, SPI clock, reset, system clock, and ADC serial data, and outputs the data read from the ADC. It uses a `casex` block to select specific parts of the `adc_channels` based on the address and chip select signals, and assigns the selected data to the `readdata` output.\n\n Module header:\n\nmodule imu_controller(input chipselect,input [3:0]addr,input read,output reg [31:0] readdata,input spi_clk,input spi_reset,input sys_clk,input ADC_SDAT,output ADC_CS_N,output ADC_SADDR,output ADC_SCLK);\n [/INST]\n", "output": "wire [8*32-1:0] adc_channels; \n imu imu(.reset_n(1'b1),.spi_clk(spi_clk),.sys_clk(sys_clk),.sda(),.scl(),.adc_channels(adc_channels),.ADC_SDAT(ADC_SDAT),.ADC_CS_N(ADC_CS_N),.ADC_SADDR(ADC_SADDR),.ADC_SCLK(ADC_SCLK)); \n  always @(posedge sys_clk) \n  if (chipselect & read) \n  casex (addr) \n  4'b0000: \n  readdata <= adc_channels[1*32-1:0*32]; \n  4'b0001: \n  readdata <= adc_channels[2*32-1:1*32]; \n  4'b0010: \n  readdata <= adc_channels[3*32-1:2*32]; \n  4'b0011: \n  readdata <= adc_channels[4*32-1:3*32]; \n  4'b0100: \n  readdata <= adc_channels[5*32-1:4*32]; \n  4'b0101: \n  readdata <= adc_channels[6*32-1:5*32]; \n  4'b0110: \n  readdata <= adc_channels[7*32-1:6*32]; \n  4'b0111: \n  readdata <= adc_channels[8*32-1:7*32]; \n  default: \n  readdata <= 32'd0; \n  endcase \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a register bank with a specified number of address bits and word width. It contains an array of registers called \"banco\" and supports reading from and writing to these registers based on the input control signals. The module also includes a reset functionality to initialize all the registers to zero and a register write logic to update the specified register with the provided write data when the regWrite signal is asserted. The readData1 and readData2 outputs provide the data from the specified registers for readReg1 and readReg2, respectively. The module's behavior is synchronized to the clock signal, and the registers are initialized to zero when the reset signal is active.\n\n Module header:\n\nmodule REGBANK_banco #(parameter addr_bits=5, word_wide=32)(input clock,input regWrite,input [addr_bits-1:0] readReg1,input [addr_bits-1:0] readReg2,input [addr_bits-1:0] writeReg,input reset,input [word_wide-1:0] writeData,output [word_wide-1:0] readData1,output [word_wide-1:0] readData2);\n [/INST]\n", "output": "localparam bank_depth = 1 << addr_bits; \n  reg [word_wide-1:0] banco [bank_depth-1:0]; \n  assign readData1 = banco[readReg1]; \n  assign readData2 = banco[readReg2]; \n  always@(posedge clock,posedge reset) begin \n  if(reset)begin \n  banco[0]=0;banco[1]=0;banco[2]=0;banco[3]=0; \n  banco[4]=0;banco[5]=0;banco[6]=0;banco[7]=0; \n  banco[8]=0;banco[9]=0;banco[10]=0;banco[11]=0; \n  banco[12]=0;banco[13]=0;banco[14]=0;banco[15]=0; \n  banco[16]=0;banco[17]=0;banco[18]=0;banco[19]=0; \n  banco[20]=0;banco[21]=0;banco[22]=0;banco[23]=0; \n  banco[24]=0;banco[25]=0;banco[26]=0;banco[27]=0; \n  banco[28]=0;banco[29]=0;banco[30]=0;banco[31]=0; \n  end \n  else if (regWrite) begin \n  banco[writeReg] = writeData; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a main PLL (Phase-Locked Loop) module that generates multiple clock signals based on an input clock. It includes input and output ports for various clock signals, and internal wires for intermediate clock signals. The module instantiates buffer and PLL components to generate the required clock signals using phase-locking techniques. The output clock signals include CLKIN_IBUFG_OUT, CLK0_OUT, CLK2X_OUT, and LOCKED_OUT. The PLL module also includes internal wires for GND_BIT and CLKFB_IN, which are used in the clock generation process. The module ensures that the generated clock signals are synchronized and stable based on the input clock.\n\n Module header:\n\nmodule main_pll(CLKIN_IN,CLKIN_IBUFG_OUT,CLK0_OUT,CLK2X_OUT,LOCKED_OUT);\n [/INST]\n", "output": "input CLKIN_IN; \n  output CLKIN_IBUFG_OUT; \n  output CLK0_OUT; \n  output CLK2X_OUT; \n  output LOCKED_OUT; \n  wire CLKFB_IN; \n  wire CLKIN_IBUFG; \n  wire CLK0_BUF; \n  wire CLK2X_BUF; \n  wire GND_BIT; \n  assign GND_BIT = 0; \n  assign CLKIN_IBUFG_OUT = CLKIN_IBUFG; \n  assign CLK0_OUT = CLKFB_IN; \n IBUFG CLKIN_IBUFG_INST (.I(CLKIN_IN),.O(CLKIN_IBUFG)); \n BUFG CLK0_BUFG_INST (.I(CLK0_BUF),.O(CLKFB_IN)); \n BUFG CLK2X_BUFG_INST (.I(CLK2X_BUF),.O(CLK2X_OUT)); \n DCM_SP #( .CLK_FEEDBACK(\"1X\"), .CLKDV_DIVIDE(2.0), .CLKFX_DIVIDE(1),.CLKFX_MULTIPLY(4), .CLKIN_DIVIDE_BY_2(\"FALSE\"),.CLKIN_PERIOD(20.000), .CLKOUT_PHASE_SHIFT(\"NONE\"),.DESKEW_ADJUST(\"SYSTEM_SYNCHRONOUS\"), .DFS_FREQUENCY_MODE(\"LOW\"),.DLL_FREQUENCY_MODE(\"LOW\"), .DUTY_CYCLE_CORRECTION(\"TRUE\"),.FACTORY_JF(16'hC080), .PHASE_SHIFT(0), .STARTUP_WAIT(\"FALSE\") ) \n DCM_SP_INST (.CLKFB(CLKFB_IN),.CLKIN(CLKIN_IBUFG),.DSSEN(GND_BIT),.PSCLK(GND_BIT),.PSEN(GND_BIT),.PSINCDEC(GND_BIT),.RST(GND_BIT),.CLKDV(),.CLKFX(),.CLKFX180(),.CLK0(CLK0_BUF),.CLK2X(CLK2X_BUF),.CLK2X180(),.CLK90(),.CLK180(),.CLK270(),.LOCKED(LOCKED_OUT),.PSDONE(),.STATUS()); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module replicates the input data (data_in) across multiple output ports (data_out) based on the width and count parameters. It uses a generate block to create the required number of output elements and assigns the replicated data to these elements. The output data_out is a concatenation of the replicated input data based on the count and width parameters.\n\n Module header:\n\nmodule c_replicator (data_in, data_out);\n [/INST]\n", "output": "parameter width = 32; \n  parameter count = 2; \n  input [0:width-1] data_in; \n  output [0:count*width-1] data_out; \n  wire [0:count*width-1] data_out; \n  generate \n  genvar idx; \n  for(idx = 0; idx < width; idx = idx + 1) \n  begin:idxs \n  assign data_out[idx*count:(idx+1)*count-1] = {count{data_in[idx]}}; \n  end \n  endgenerate \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an arbiter with priority. It has inputs for clk, clk_en, reset, hold, and request, and outputs for grant and arb_wait. The module uses a grant_hold register to track the hold status for each request. It calculates request_mask and grant_mask based on the request and grant_hold, and uses these to determine the grant and arb_wait signals for each input. Additionally, it has error checking to ensure that requests are held steady.\n\n Module header:\n\nmodule e16_arbiter_priority(grant, arb_wait,clk, clk_en, reset, hold, request);\n [/INST]\n", "output": "parameter ARW=99; \n  input clk; \n  input clk_en; \n  input reset; \n  input hold; \n  input [ARW-1:0] request; \n  output [ARW-1:0] grant; \n  output [ARW-1:0] arb_wait; \n  wire [ARW-1:0] grant_mask; \n  wire [ARW-1:0] request_mask; \n  reg [ARW-1:0] grant_hold; \n  always @ (posedge clk or posedge reset) \n  if(reset) \n  grant_hold[ARW-1:0] <= {(ARW){1'b0}}; \n  else if(clk_en) \n  grant_hold[ARW-1:0] <= grant[ARW-1:0] & {(ARW){hold}}; \n  genvar i; \n  generate \n  for(i=0;i<ARW-1;i=i+1) begin : gen_block \n  assign request_mask[i]=request[i] & ~(|grant_hold[ARW-1:i+1]); \n  end \n  assign request_mask[ARW-1]=request[ARW-1]; \n  endgenerate \n  genvar j; \n  assign grant_mask[0] = 1'b0; \n  generate for (j=ARW-1; j>=1; j=j-1) begin : gen_arbiter \n  assign grant_mask[j] = |request_mask[j-1:0]; \n  end \n  endgenerate \n  assign grant[ARW-1:0] = request_mask[ARW-1:0] & ~grant_mask[ARW-1:0]; \n  assign arb_wait[ARW-1:0] = request[ARW-1:0] & ({(ARW){hold}} | ~grant[ARW-1:0]); \n  always @* \n  if((|(grant_hold[ARW-1:0] & ~request[ARW-1:0])) & ~reset & $time> 0) \n  begin \n  $display(\"ERROR>>Request not held steady in cell %m at time %0d\", $time); \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module serves as an adapter between a pipelined FIFO (ppfifo) and an AXI stream interface. It manages the data transfer between the two interfaces, keeping track of the state, sizes, and data validity. The module uses a state machine to control the flow of data and the readiness of both interfaces. It also provides debug information about the internal state and data counters.\n\n Module header:\n\nmodule adapter_ppfifo_2_axi_stream #(parameter DATA_WIDTH = 24,parameter STROBE_WIDTH = DATA_WIDTH / 8,parameter USE_KEEP = 0)(input rst,input i_ppfifo_rdy,output reg o_ppfifo_act,input [23:0] i_ppfifo_size,input [(DATA_WIDTH + 1) - 1:0] i_ppfifo_data,output o_ppfifo_stb,input i_axi_clk,output [3:0] o_axi_user,input i_axi_ready,output [DATA_WIDTH - 1:0] o_axi_data,output o_axi_last,output reg o_axi_valid,output [31:0] o_debug);\n [/INST]\n", "output": "localparam IDLE = 0; \n localparam READY = 1; \n localparam RELEASE = 2; \n reg [3:0] state; \n reg [23:0] r_count; \n assign o_axi_data = i_ppfifo_data[DATA_WIDTH - 1: 0]; \n assign o_ppfifo_stb = (i_axi_ready & o_axi_valid); \n assign o_axi_user[0] = (r_count < i_ppfifo_size) ? i_ppfifo_data[DATA_WIDTH] : 1'b0; \n assign o_axi_user[3:1] = 3'h0; \n assign o_axi_last = ((r_count + 1) >= i_ppfifo_size) & o_ppfifo_act & o_axi_valid; \n assign o_debug[3:0] = state; \n assign o_debug[4] = (r_count < i_ppfifo_size) ? i_ppfifo_data[DATA_WIDTH]: 1'b0; \n assign o_debug[5] = o_ppfifo_act; \n assign o_debug[6] = i_ppfifo_rdy; \n assign o_debug[7] = (r_count > 0); \n assign o_debug[8] = (i_ppfifo_size > 0); \n assign o_debug[9] = (r_count == i_ppfifo_size); \n assign o_debug[15:10] = 0; \n assign o_debug[23:16] = r_count[7:0]; \n assign o_debug[31:24] = 0; \n always @ (posedge i_axi_clk) begin \n  o_axi_valid <= 0; \n  if (rst) begin \n  state <= IDLE; \n  o_ppfifo_act <= 0; \n  r_count <= 0; \n  end \n  else begin \n  case (state) \n  IDLE: begin \n  o_ppfifo_act <= 0; \n  if (i_ppfifo_rdy && !o_ppfifo_act) begin \n  r_count <= 0; \n  o_ppfifo_act <= 1; \n  state <= READY; \n  end \n  end \n  READY: begin \n  if (r_count < i_ppfifo_size) begin \n  o_axi_valid <= 1; \n  if (i_axi_ready && o_axi_valid) begin \n  r_count <= r_count + 1; \n  if ((r_count + 1) >= i_ppfifo_size) begin \n  o_axi_valid <= 0; \n  end \n  end \n  end \n  else begin \n  o_ppfifo_act <= 0; \n  state <= RELEASE; \n  end \n  end \n  RELEASE: begin \n  state <= IDLE; \n  end \n  default: begin \n  end \n  endcase \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a full adder, which takes inputs A, B, and CARRY_IN, and produces outputs SUM and CARRY_OUT. The SUM is calculated using XOR and AND gates, while the CARRY_OUT is determined using OR gates based on the input signals.\n\n Module header:\n\nmodule full_adder (input A,input B,input CARRY_IN,output SUM,output CARRY_OUT);\n [/INST]\n", "output": "assign SUM = (A ^ B) ^ CARRY_IN; \n  assign CARRY_OUT = (A & ~B & CARRY_IN) | (~A & B & CARRY_IN) | (A & B); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a Finite Impulse Response (FIR) filter. The input signal x is multiplied with the coefficient signals k0, k1, k2, and k3 using floating-point multiplication units (fpu_mul). The results of the multiplications are then added together using floating-point addition units (fpu_add). The final result is stored in the output register out_reg. The filter coefficients are applied sequentially to delayed versions of the input signal x, which are stored in registers x_reg1 through x_reg18. The registers are updated on each clock cycle.\n\n Module header:\n\nmodule fir(clock,reset,x,k0,k1,k2,k3,out);\n [/INST]\n", "output": "input clock; \n input reset; \n input [`BITS-1:0] x; \n input [`BITS-1:0] k0; \n input [`BITS-1:0] k1; \n input [`BITS-1:0] k2; \n input [`BITS-1:0] k3; \n output [`BITS-1:0] out; \n wire [`BITS-1:0] x0k0; \n wire [`BITS-1:0] x1k1; \n wire [`BITS-1:0] x2k2; \n wire [`BITS-1:0] x3k3; \n wire [`BITS-1:0] add0; \n wire [`BITS-1:0] add1; \n wire [`BITS-1:0] add2; \n wire [`BITS-1:0] add3; \n reg [`BITS-1:0] x_reg1; \n reg [`BITS-1:0] x_reg2; \n reg [`BITS-1:0] x_reg3; \n reg [`BITS-1:0] x_reg4; \n reg [`BITS-1:0] x_reg5; \n reg [`BITS-1:0] x_reg6; \n reg [`BITS-1:0] x_reg7; \n reg [`BITS-1:0] x_reg8; \n reg [`BITS-1:0] x_reg9; \n reg [`BITS-1:0] x_reg10; \n reg [`BITS-1:0] x_reg11; \n reg [`BITS-1:0] x_reg12; \n reg [`BITS-1:0] x_reg13; \n reg [`BITS-1:0] x_reg14; \n reg [`BITS-1:0] x_reg15; \n reg [`BITS-1:0] x_reg16; \n reg [`BITS-1:0] x_reg17; \n reg [`BITS-1:0] x_reg18; \n wire [`BITS-1:0] out; \n wire [`BITS-1:0] out_temp; \n reg [`BITS-1:0] out_reg; \n assign out= out_reg; \n wire [7:0] x0k0_control; \n fpu_mul x0k0_mul \n (.clk(clock),.opa(k0),.opb(x),.out(x0k0),.control(x0k0_control)); \n wire [7:0] x1k1_control; \n fpu_mul x1k1_mul \n (.clk(clock),.opa(k1),.opb(x_reg6),.out(x1k1),.control(x1k1_control)); \n wire [7:0] x2k2_control; \n fpu_mul x2k2_mul \n (.clk(clock),.opa(k2),.opb(x_reg12),.out(x2k2),.control(x2k2_control)); \n wire [7:0] x3k3_control; \n fpu_mul x3k3_mul \n (.clk(clock),.opa(k3),.opb(x_reg18),.out(x3k3),.control(x3k3_control)); \n wire [7:0] add0_control; \n fpu_add add0_add \n (.clk(clock),.opa(x0k0),.opb(x1k1),.out(add0),.control(add0_control)); \n wire [7:0] add1_control; \n fpu_add add1_add \n (.clk(clock),.opa(add0),.opb(x2k2),.out(add1),.control(add1_control)); \n wire [7:0] out_temp_control; \n fpu_add out_temp_add \n (.clk(clock),.opa(add1),.opb(x3k3),.out(out_temp),.control(out_temp_control)); \n always @(posedge clock) \n begin \n  out_reg <= out_temp; \n  x_reg1 <= x; \n  x_reg2 <= x_reg1; \n  x_reg3 <= x_reg2; \n  x_reg4 <= x_reg3; \n  x_reg5 <= x_reg4; \n  x_reg6 <= x_reg5; \n  x_reg7 <= x_reg6; \n  x_reg8 <= x_reg7; \n  x_reg9 <= x_reg8; \n  x_reg10 <= x_reg9; \n  x_reg11 <= x_reg10; \n  x_reg12 <= x_reg11; \n  x_reg13 <= x_reg12; \n  x_reg14 <= x_reg13; \n  x_reg15 <= x_reg14; \n  x_reg16 <= x_reg15; \n  x_reg17 <= x_reg16; \n  x_reg18 <= x_reg17; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a D-type flip-flop with Set/Reset capability. It has an input D, clock input CLK, and a Set input SET_B. The output Q is the buffered output signal. It also includes supply voltage declarations for power management. Inside the module, it uses a D flip-flop and some logic gates to handle the set/reset functionality. The module delays input signals to synchronize them with the clock and includes a notifier register to control the flip-flop operation. It also checks for certain conditions and adjusts the output signal accordingly. Overall, it implements a D-type flip-flop with set/reset functionality and power supply considerations.\n\n Module header:\n\nmodule sky130_fd_sc_ls__dfstp (Q ,CLK ,D ,SET_B);\n [/INST]\n", "output": "output Q ; \n  input CLK ; \n  input D ; \n  input SET_B; \n  supply1 VPWR; \n  supply0 VGND; \n  supply1 VPB ; \n  supply0 VNB ; \n  wire buf_Q ; \n  wire SET ; \n  reg notifier ; \n  wire D_delayed ; \n  wire SET_B_delayed; \n  wire CLK_delayed ; \n  wire awake ; \n  wire cond0 ; \n  wire cond1 ; \n  not not0 (SET , SET_B_delayed ); \n  sky130_fd_sc_ls__udp_dff$PS_pp$PG$N dff0 (buf_Q , D_delayed, CLK_delayed, SET, notifier, VPWR, VGND); \n  assign awake = ( VPWR === 1'b1 ); \n  assign cond0 = ( SET_B_delayed === 1'b1 ); \n  assign cond1 = ( SET_B === 1'b1 ); \n  buf buf0 (Q , buf_Q ); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a simple logic gate that outputs a constant value of 1.\n\n Module header:\n\nmodule logic_1(output a);\n [/INST]\n", "output": "assign a = 1; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a D flip-flop with an asynchronous active-low reset. The D flip-flop's output Q is driven by an input D, and is reset to a low state when the RESET_B input is low. The module includes a notification register, a condition flag, and various delayed signals for synchronization. The module also contains a reset buffer, a D-latch, and a buffer instantiation for the Q output. Overall, this module represents a basic D flip-flop with an asynchronous reset functionality.\n\n Module header:\n\nmodule sky130_fd_sc_hvl__dlrtp (Q ,RESET_B,D ,GATE);\n [/INST]\n", "output": "output Q ; \n  input RESET_B; \n  input D ; \n  input GATE ; \n  supply1 VPWR; \n  supply0 VGND; \n  supply1 VPB ; \n  supply0 VNB ; \n  wire RESET ; \n  reg notifier ; \n  wire cond0 ; \n  wire D_delayed ; \n  wire GATE_delayed ; \n  wire RESET_delayed ; \n  wire RESET_B_delayed; \n  wire buf_Q ; \n  not not0 (RESET , RESET_B_delayed ); \n  sky130_fd_sc_hvl__udp_dlatch$PR_pp$PG$N dlatch0 (buf_Q , D_delayed, GATE_delayed, RESET, notifier, VPWR, VGND); \n  assign cond0 = ( RESET_B_delayed === 1'b1 ); \n  buf buf0 (Q , buf_Q ); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a one-bit adder with a carry input. It takes three inputs a, b, and ci, and produces sum and co as outputs. The outputs are assigned based on the sum and carry resulting from adding the inputs a, b, and ci.\n\n Module header:\n\nmodule add1(a, b, ci, sum, co);\n [/INST]\n", "output": "input a, b, ci; \n  output sum, co; \n  assign {co,sum} = a + b + ci; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a register file that holds 32 registers of 32-bit data each. Upon initialization, the registers are pre-loaded with incrementing values. On a positive clock edge, the module writes data to the register at the specified address when the WriteEnable signal is asserted, and the module resets to its initial state when the reset signal is asserted. On a negative clock edge, the module reads data from the specified registers and outputs the data to the corresponding output ports.\n\n Module header:\n\nmodule regFileBoard(input wire clock,input wire clock_debug,input wire reset,input wire WriteEnable,input wire [4:0] read_address_1,input wire [4:0] read_address_2,input wire [4:0] read_address_3,input wire [31:0] write_data_in,input wire [4:0] write_address,input wire [4:0] read_address_debug,output reg [31:0] data_out_1,output reg [31:0] data_out_2,output reg [31:0] data_out_3,output reg [31:0] data_out_debug);\n [/INST]\n", "output": "integer i; \n  reg [31:0] register[0:31]; \n  initial begin \n  for(i=0;i<32;i=i+1)begin \n  register[i] = i; \n  end \n  end \n  always @(posedge clock) begin \n  if(WriteEnable &&(write_address != 5'b0))begin \n  register[write_address] <= write_data_in; \n  end \n  if(reset)begin \n  for(i=0;i<32;i=i+1)begin \n  register[i] = i; \n  end \n  end \n  end \n  always @(negedge clock) begin \n  data_out_1 = register[read_address_1]; \n  data_out_2 = register[read_address_2]; \n  data_out_debug = register[read_address_debug]; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"adxl362_system_controller\" generates multiple clock signals based on the input ODR value to drive the system. It includes a system clock, a clock divider, and various frequency clocks. The module also includes a reset signal that is activated during power-on or with a soft reset input. The clock signal frequency is determined by the ODR input and is selected using a conditional assignment based on its value.\n\n Module header:\n\nmodule adxl362_system_controller (clk, clk_sys, reset, clk_odr, rst,soft_reset, odr);\n [/INST]\n", "output": "output reg clk; \n  output reg clk_sys; \n  output wire reset; \n  input wire soft_reset; \n  output wire clk_odr; \n  input wire [2:0] odr; \n  output wire rst; \n  reg [5:0] reset_count = 0; \n  reg por = 1; \n  assign rst = |reset_count; \n  always @(posedge clk_sys) \n  if (por || soft_reset) begin \n  reset_count <= 1; \n  por <= 0; \n  end else begin \n  if (rst) \n  reset_count <= reset_count + 1; \n  end \n  initial begin \n  clk <= 1'b0; \n  forever begin \n  #9803 clk <= ~clk; \n  end \n  end \n  initial begin \n  clk_sys <= 1'b0; \n  forever begin \n  #5 clk_sys <= ~clk_sys; \n  end \n  end \n  reg clk_12_5_Hz; \n  initial begin \n  clk_12_5_Hz <= 0; \n  forever begin \n  #40000000 clk_12_5_Hz <= ~clk_12_5_Hz; \n  end \n  end \n  reg clk_25_Hz; \n  initial begin \n  clk_25_Hz <= 0; \n  forever begin \n  #20000000 clk_25_Hz <= ~clk_25_Hz; \n  end \n  end \n  reg clk_50_Hz; \n  initial begin \n  clk_50_Hz <= 0; \n  forever begin \n  #10000000 clk_50_Hz <= ~clk_50_Hz; \n  end \n  end \n  reg clk_100_Hz; \n  initial begin \n  clk_100_Hz <= 0; \n  forever begin \n  #5000000 clk_100_Hz <= ~clk_100_Hz; \n  end \n  end \n  reg clk_200_Hz; \n  initial begin \n  clk_200_Hz <= 0; \n  forever begin \n  #2500000 clk_200_Hz <= ~clk_200_Hz; \n  end \n  end \n  reg clk_400_Hz; \n  initial begin \n  clk_400_Hz <= 0; \n  forever begin \n  #1250000 clk_400_Hz <= ~clk_400_Hz; \n  end \n  end \n  assign clk_odr = (odr == 3'b000) ? clk_12_5_Hz: \n  (odr == 3'b001) ? clk_25_Hz: \n  (odr == 3'b010) ? clk_50_Hz: \n  (odr == 3'b011) ? clk_100_Hz: \n  (odr == 3'b100) ? clk_200_Hz: clk_400_Hz; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a clock enable circuit that takes an input clock signal and various control signals to generate an output clock and enable signal. It uses flip-flops to synchronize and control the enable signal and output clock. The parameters allow for configuration of the clock type and enable register mode. The module ultimately produces an output clock and enable signal based on the input clock and control signals.\n\n Module header:\n\nmodule arriaiigz_clkena (inclk,ena,devpor,devclrn,enaout,outclk);\n [/INST]\n", "output": "input inclk; \n input ena; \n input devpor; \n input devclrn; \n output enaout; \n output outclk; \n parameter clock_type = \"Auto\"; \n parameter ena_register_mode = \"falling edge\"; \n parameter lpm_type = \"arriaiigz_clkena\"; \n tri1 devclrn; \n tri1 devpor; \n wire cereg1_out; \n wire cereg2_out; \n wire ena_out; \n arriaiigz_ena_reg extena_reg1(.clk(!inclk),.ena(1'b1),.d(ena),.clrn(1'b1),.prn(devpor),.q(cereg1_out)); \n arriaiigz_ena_reg extena_reg2(.clk(!inclk),.ena(1'b1),.d(cereg1_out),.clrn(1'b1),.prn(devpor),.q(cereg2_out)); \n assign ena_out = (ena_register_mode == \"falling edge\") ? cereg1_out : \n  ((ena_register_mode == \"none\") ? ena : cereg2_out); \n arriaiigz_and2 outclk_and(.IN1(inclk),.IN2(ena_out),.Y(outclk)); \n arriaiigz_and2 enaout_and(.IN1(1'b1),.IN2(ena_out),.Y(enaout)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module acts as a register that synchronously updates its outputs based on the inputs and a clock signal. It also has a reset capability to initialize the output registers. The outputs mirror the inputs when the clock signal is high, and they are reset when the reset signal is asserted.\n\n Module header:\n\nmodule EX2MEM(input clk, rst,input RegWrite_In, MemWrite_In, MemRead_In,input [31:0] PC_In, ALUOut_In, DataBusB_In,input [4:0] AddrC_In,input [1:0] MemtoReg_In,output reg RegWrite_Out, MemWrite_Out, MemRead_Out,output reg [31:0] PC_Out, ALUOut_Out, DataBusB_Out,output reg [4:0] AddrC_Out,output reg [1:0] MemtoReg_Out);\n [/INST]\n", "output": "always @(posedge clk or posedge rst) begin \n  if (rst) begin \n  RegWrite_Out <= 0; \n  MemWrite_Out <= 0; \n  MemRead_Out <= 0; \n  PC_Out <= 0; \n  ALUOut_Out <= 0; \n  AddrC_Out <= 0; \n  MemtoReg_Out <= 0; \n  DataBusB_Out <= 0; \n  end else begin \n  RegWrite_Out <= RegWrite_In; \n  MemWrite_Out <= MemWrite_In; \n  MemRead_Out <= MemRead_In; \n  PC_Out <= PC_In; \n  ALUOut_Out <= ALUOut_In; \n  AddrC_Out <= AddrC_In; \n  MemtoReg_Out <= MemtoReg_In; \n  DataBusB_Out <= DataBusB_In; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a Qsys system ID module with configurable ID_VALUE and TIMESTAMP parameters. It takes an address, clock, and reset_n as inputs and outputs the system ID data based on the address and timestamp. If the address is non-zero, it outputs the TIMESTAMP value; otherwise, it outputs the ID_VALUE.\n\n Module header:\n\nmodule altera_avalon_sysid_qsys #(parameter ID_VALUE = 1,parameter TIMESTAMP = 1)(address,clock,reset_n,readdata);\n [/INST]\n", "output": "output [ 31: 0] readdata; \n  input address; \n  input clock; \n  input reset_n; \n  wire [ 31: 0] readdata; \n  assign readdata = address ? TIMESTAMP : ID_VALUE; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a register file with two read ports and one write port. It consists of an array of 8 16-bit registers and supports writing to a specific register based on the write_adr and write_en inputs. It also has two output ports, data_out_1 and data_out_2, which output data based on the read_adr_1 and read_adr_2 inputs. The module initializes the registers to zero and updates the register file on the negative edge of the clock. It flushes the data and sets the output ports to zero on the positive edge of the clock when the flush input is asserted.\n\n Module header:\n\nmodule register_file(input clock,input flush,input [2:0] read_adr_1,input [2:0] read_adr_2,input [15:0] write_data,input [2:0] write_adr,input write_en,output reg [15:0] data_out_1,output reg [15:0] data_out_2);\n [/INST]\n", "output": "reg [15:0] file [7:0]; \n  integer i; \n  initial begin \n  for (i = 0; i < 8 ; i = i + 1) begin \n  file[i] = 16'h00; \n  end \n  data_out_1 = 0; \n  data_out_2 = 0; \n  end \n  always @(negedge clock) begin \n  if (write_en == 1) begin \n  file[write_adr] = write_data; \n  end \n  end \n  always @(posedge clock) begin \n  case (flush) \n  0: begin \n  data_out_1 = file[read_adr_1]; \n  data_out_2 = file[read_adr_2]; \n  end \n  1: begin \n  data_out_1 = 0; \n  data_out_2 = 0; \n  end \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"EdgeDelay\" implements a delay circuit that produces an output \"sigOut\" delayed by a specified number of clock cycles. The delay is triggered by the positive or negative edges of the input signal \"sigIn\". The delay is controlled by the \"waitCnt\" input. The \"sigOut\" output is set to 1 after the specified delay following the positive edge of \"sigIn\", and set to 0 after the specified delay following the negative edge of \"sigIn\". The \"diagOut\" output reflects the toggling of the \"negEdgeReg\".\n\n Module header:\n\nmodule EdgeDelay(clk, sigIn, waitCnt, sigOut, diagOut);\n [/INST]\n", "output": "parameter WAIT_CNT_SIZE=11; \n parameter INVERT_FLAG=1'b0; \n parameter MIN_WAIT=3'b10; \n input clk, sigIn; \n input [WAIT_CNT_SIZE-1:0] waitCnt; \n output sigOut; \n output diagOut; \n reg [WAIT_CNT_SIZE-1:0] posEdgeDelayTimer; \n reg [WAIT_CNT_SIZE-1:0] negEdgeDelayTimer; \n reg sigOutReg; \n reg sigLast; \n reg sigReg; \n reg resetFlag; \n initial begin \n  #0 \n  sigOutReg=1'b0; \n  posEdgeDelayTimer=1'b0; \n  negEdgeDelayTimer=1'b0; \n  sigLast=1'b0; \n end \n reg posEdgeReg, posEdgeRegLast, negEdgeReg, negEdgeRegLast; \n always @(posedge sigIn) begin \n  posEdgeReg=~posEdgeReg; \n end \n always @(negedge sigIn) begin \n  negEdgeReg=~negEdgeReg; \n end \n always @(posedge clk) begin \n  sigReg=sigIn; \n  if(posEdgeRegLast!=posEdgeReg && posEdgeDelayTimer>MIN_WAIT) begin \n  posEdgeDelayTimer=1'b0; \n  posEdgeRegLast=posEdgeReg; \n  end else if(negEdgeRegLast!=negEdgeReg && negEdgeDelayTimer>MIN_WAIT) begin \n  negEdgeDelayTimer=1'b0; \n  negEdgeRegLast=negEdgeReg; \n  resetFlag=~resetFlag; \n  end \n  if(posEdgeDelayTimer<waitCnt) begin \n  posEdgeDelayTimer=posEdgeDelayTimer+1'b1; \n  end else if(posEdgeDelayTimer==waitCnt) begin \n  posEdgeDelayTimer=posEdgeDelayTimer+1'b1; \n  sigOutReg=1'b1; \n  end \n  else \n  if(negEdgeDelayTimer<waitCnt) begin \n  negEdgeDelayTimer=negEdgeDelayTimer+1'b1; \n  end else if(negEdgeDelayTimer==waitCnt) begin \n  negEdgeDelayTimer=negEdgeDelayTimer+1'b1; \n  sigOutReg=1'b0; \n  end \n end \n assign sigOut=sigOutReg; \n assign diagOut=negEdgeReg; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a 4-to-1 multiplexer that selects one of the four input vectors a, b, c, or d based on the value of the sel input. When sel is 00, the output o is assigned the value of a; when sel is 01, o is assigned the value of b; when sel is 10, o is assigned the value of c; and when sel is 11, o is assigned the value of d.\n\n Module header:\n\nmodule mux4to1_5(input wire sel,input wire [4:0] a,input wire [4:0] b,input wire [4:0] c,input wire [4:0] d,output reg [4:0] o);\n [/INST]\n", "output": "always @(*) \n  case(sel) \n  2'b00: o<=a; \n  2'b01: o<=b; \n  2'b10: o<=c; \n  2'b11: o<=d; \n  endcase \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a simple hardware description of a digital circuit. It includes components such as a timer, program counter, address, data registers, and a clock. The module also has a reset initialization and uses a case statement for program counter updates. The behavior of the module is synchronous with the clock, and it updates the program counter and register values based on the clock signal and reset condition.\n\n Module header:\n\nmodule real_main;\n [/INST]\n", "output": "integer file_count; \n  reg [15:0] timer; \n  reg [1:0] program_counter; \n  reg [15:0] address_2; \n  reg [15:0] data_out_2; \n  reg [15:0] data_in_2; \n  reg write_enable_2; \n  reg [15:0] address_4; \n  reg [31:0] data_out_4; \n  reg [31:0] data_in_4; \n  reg write_enable_4; \n  reg [15:0] register_0; \n  reg clk; \n  reg rst; \n  initial \n  begin \n  rst <= 1'b1; \n  #50 rst <= 1'b0; \n  end \n  initial \n  begin \n  clk <= 1'b0; \n  while (1) begin \n  #5 clk <= ~clk; \n  end \n  end \n  always @(posedge clk) \n  begin \n  timer <= 16'h0000; \n  case(program_counter) \n  16'd0: \n  begin \n  program_counter <= 16'd1; \n  program_counter <= 16'd3; \n  register_0 <= 16'd1; \n  end \n  16'd1: \n  begin \n  program_counter <= 16'd3; \n  $finish; \n  program_counter <= program_counter; \n  end \n  16'd3: \n  begin \n  program_counter <= 16'd2; \n  program_counter <= register_0; \n  end \n  endcase \n  if (rst == 1'b1) begin \n  program_counter <= 0; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a settings bus cross-clock bridge with an optional flow control feature. It synchronizes data transfers between two different clock domains. It uses a 16x40 FIFO to handle the settings data and includes full and empty flags to manage the FIFO status. The module outputs the set_stb_o signal, which is determined by the empty flag and the optional flow control logic.\n\n Module header:\n\nmodule settings_bus_crossclock #(parameter FLOW_CTRL=0) (input clk_i, input rst_i, input set_stb_i, input [7:0] set_addr_i, input [31:0] set_data_i,input clk_o, input rst_o, output set_stb_o, output [7:0] set_addr_o, output [31:0] set_data_o, input blocked);\n [/INST]\n", "output": "wire full, empty; \n  fifo_xlnx_16x40_2clk settings_fifo \n (.rst(rst_i),.wr_clk(clk_i), .din({set_addr_i,set_data_i}), .wr_en(set_stb_i & ~full), .full(full),.rd_clk(clk_o), .dout({set_addr_o,set_data_o}), .rd_en(set_stb_o), .empty(empty)); \n  assign set_stb_o = ~empty & (~blocked | ~FLOW_CTRL); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module is responsible for USB clock recovery. It contains a counter, a register to store the previous input value, and logic to generate the strobe signal. The counter is incremented or decremented based on the current and previous input values, with additional logic to handle the reset condition. The strobe output is generated based on the counter value.\n\n Module header:\n\nmodule usb_clk_recovery(input rst_n,input clk,input i,output strobe);\n [/INST]\n", "output": "reg[1:0] cntr; \n reg prev_i; \n assign strobe = cntr == 1'b0; \n always @(posedge clk or negedge rst_n) begin \n  if (!rst_n) begin \n  cntr <= 1'b0; \n  prev_i <= 1'b0; \n  end else begin \n  if (i == prev_i) begin \n  cntr <= cntr - 1'b1; \n  end else begin \n  cntr <= 1'b1; \n  end \n  prev_i <= i; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a multiplier circuit that computes the product of two input vectors A and B. It uses a generate statement to create an array of partial products, adds them using a Ripple Carry Adder, and outputs the final result P. The circuit can be parameterized for different sizes of input vectors M and N. The implementation also includes conditional compilation based on different macros and indexed part select options.\n\n Module header:\n\nmodule Multiplier_flat #(parameter M = 4, parameter N = 4)(input [M-1:0] A,input [N-1:0] B,output [M+N-1:0] P );\n [/INST]\n", "output": "`ifdef macro_args \n `define calc_pp_lsb(n) (((n)-1)*((n)+2*M)/2) \n `define calc_pp_msb(n) ((n**2+(2*M+1)*n-2)/2) \n `define calc_pp_range(n) `calc_pp_lsb(n) +: (M+n) \n wire [`calc_pp_msb(N):0] PP; \n assign PP[`calc_pp_range(1)] = { 1'b0 , { A & {M{B[0]}} } }; \n assign P = PP[`calc_pp_range(N)]; \n `elsif indexed_part_select \n localparam MSB = (N**2+(2*M+1)*N-2)/2; \n wire [MSB:0] PP; \n assign PP[M:0] = { 1'b0 , { A & {M{B[0]}} } }; \n assign P = PP[MSB -: M+N]; \n `else \n localparam MSB = (N**2+(2*M+1)*N-2)/2; \n wire [MSB:0] PP; \n assign PP[M:0] = { 1'b0 , { A & {M{B[0]}} } }; \n assign P = PP[MSB : MSB+1-M-N]; \n `endif \n genvar i; \n generate \n for (i=1; i < N; i=i+1) \n begin: addPartialProduct \n  wire [M+i-1:0] gA,gB,gS; \n  wire Cout; \n  assign gA = { A & {M{B[i]}} , {i{1'b0}} }; \n  `ifdef macro_args \n  assign gB = PP[`calc_pp_range(i)]; \n  assign PP[`calc_pp_range(i+1)] = {Cout,gS}; \n  `elsif indexed_part_select \n  assign gB = PP[(i-1)*(i+2*M)/2 +: M+i]; \n  assign PP[i*((i+1)+2*M)/2 +: M+i+1] = {Cout,gS}; \n  `else \n  localparam LSB = (i-1)*(i+2*M)/2; \n  localparam MSB = (i**2+(2*M+1)*i-2)/2; \n  localparam MSB2 = ((i+1)**2+(2*M+1)*(i+1)-2)/2; \n  assign gB = PP[MSB : LSB]; \n  assign PP[ MSB2 : MSB+1] = {Cout,gS}; \n  `endif \n  RippleCarryAdder#(M+i) adder( .A(gA), .B(gB), .S(gS), .Cin (1'b0), .Cout(Cout) ); \n end \n endgenerate \n `ifdef macro_args \n `undef calc_pp_range \n `undef calc_pp_msb \n `undef calc_pp_lsb \n `endif \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a content-addressable memory (CAM) with a width of 128 bits and a word width of 9 bits. It has a configurable number of stages, bypass mode, pipeline mode, and integration with block RAM. It uses a for loop to instantiate the CAM stages and bitwise AND operation to compare and match the stored patterns with the input pattern. The module generates a match signal and the corresponding address when there is a match in the CAM.\n\n Module header:\n\nmodule bcam_trc #( parameter CAMD = 128 ,parameter CAMW = 9 ,parameter STGW = 9 ,parameter BYPS = 1 ,parameter PIPE = 0 ,parameter INOM = 1 ,parameter BRAM = \"M20K\") ( input clk ,input rst ,input wEnb ,input [`log2(CAMD)-1:0] wAddr ,input [ CAMW -1:0] wPatt ,input [ CAMW -1:0] mPatt ,output match ,output [`log2(CAMD)-1:0] mAddr );\n [/INST]\n", "output": "localparam nSTG = CAMW/STGW+((CAMW%STGW)>1) ; \n  localparam LSTGW = ((CAMW%STGW)==0) ? STGW : (((CAMW%STGW)==1) ? (STGW+1) : (CAMW%STGW)); \n  wire [CAMD-1:0] matchStg [nSTG-1:0]; \n  genvar gi; \n  generate \n  for (gi=0 ; gi<nSTG ; gi=gi+1) begin: STGgi \n bcam_trs #( .CAMD ( CAMD ),.CAMW ( gi<(nSTG-1) ? STGW : LSTGW ),.BYPS ( BYPS ),.PIPE ( PIPE ),.INOM ( INOM ),.BRAM ( BRAM )) \n bcam_trs_i ( .clk ( clk ),.rst ( rst ),.wEnb ( wEnb ),.wAddr( wAddr ),.wPatt( wPatt[gi*STGW +: (gi<(nSTG-1)?STGW:LSTGW)] ),.mPatt( mPatt[gi*STGW +: (gi<(nSTG-1)?STGW:LSTGW)] ),.match( matchStg[gi] )); \n  end \n  endgenerate \n  integer i; \n  reg [CAMD-1:0] matchOH; \n  always @(*) begin \n  matchOH = {CAMD{1'b1}}; \n  for (i=0; i<nSTG; i=i+1) \n  matchOH = matchOH & matchStg[i]; \n  end \n pe_camd pe_trc_inst (.clk( clk ),.rst( rst ),.oht( matchOH ),.bin( mAddr ),.vld( match )); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes an input clock signal, and creates an inverted clock signal as the output. The output, clkout, is assigned to be the logical negation of the input clock signal, clkin.\n\n Module header:\n\nmodule bw_clk_cclk_inv_96x (clkout,clkin );\n [/INST]\n", "output": "output clkout; \n  input clkin; \n  assign clkout = ~( clkin ); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a state machine and data generator for a stream input interface. The state machine transitions through different states based on input and output ready signals, controlling the output enable for the stream in. The data generator increments its value when the stream in mode is selected and the output is ready, and resets to 0 when the mode is not selected. The data_out_stream_in output is driven by the data_gen_stream_in value.\n\n Module header:\n\nmodule prometheus_fx3_stream_in(input rst_n,input clk_100,input stream_in_mode_selected,input i_gpif_in_ch0_rdy_d,input i_gpif_out_ch0_rdy_d,output o_gpif_we_n_stream_in_,output [31:0] data_out_stream_in);\n [/INST]\n", "output": "reg [2:0]current_stream_in_state; \n reg [2:0]next_stream_in_state; \n reg [31:0]data_gen_stream_in; \n parameter [2:0] stream_in_idle = 3'd0; \n parameter [2:0] stream_in_wait_flagb = 3'd1; \n parameter [2:0] stream_in_write = 3'd2; \n parameter [2:0] stream_in_write_wr_delay = 3'd3; \n assign o_gpif_we_n_stream_in_ = ((current_stream_in_state == stream_in_write) && (i_gpif_out_ch0_rdy_d == 1'b1)) ? 1'b0 : 1'b1; \n always @(posedge clk_100, negedge rst_n)begin \n  if(!rst_n)begin \n  current_stream_in_state <= stream_in_idle; \n  end else begin \n  current_stream_in_state <= next_stream_in_state; \n  end \n end \n always @(*)begin \n  next_stream_in_state = current_stream_in_state; \n  case(current_stream_in_state) \n  stream_in_idle:begin \n  if((stream_in_mode_selected) & (i_gpif_in_ch0_rdy_d == 1'b1))begin \n  next_stream_in_state = stream_in_wait_flagb; \n  end else begin \n  next_stream_in_state = stream_in_idle; \n  end \n  end \n  stream_in_wait_flagb :begin \n  if (i_gpif_out_ch0_rdy_d == 1'b1)begin \n  next_stream_in_state = stream_in_write; \n  end else begin \n  next_stream_in_state = stream_in_wait_flagb; \n  end \n  end \n  stream_in_write:begin \n  if(i_gpif_out_ch0_rdy_d == 1'b0)begin \n  next_stream_in_state = stream_in_write_wr_delay; \n  end else begin \n  next_stream_in_state = stream_in_write; \n  end \n  end \n  stream_in_write_wr_delay:begin \n  next_stream_in_state = stream_in_idle; \n  end \n  endcase \n end \n always @(posedge clk_100, negedge rst_n)begin \n  if(!rst_n)begin \n  data_gen_stream_in <= 32'd0; \n  end else if((o_gpif_we_n_stream_in_ == 1'b0) & (stream_in_mode_selected)) begin \n  data_gen_stream_in <= data_gen_stream_in + 1; \n  end else if (!stream_in_mode_selected) begin \n  data_gen_stream_in <= 32'd0; \n  end \n end \n assign data_out_stream_in = data_gen_stream_in; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a hardware description of a system that interfaces with UART0, memory, and task execution. It contains registers for storing data and implements logic for reading and writing to memory and UART0. The module also handles task execution based on the input thread and address, and manages the kill slot request based on various conditions. It also displays the values of io_thread_ and io_din based on certain conditions and updates the kill_slot_rq value accordingly. The module acts as an interface between the UART, memory, and task execution components of the system.\n\n Module header:\n\nmodule j4a(input wire clk,input wire resetq,output wire uart0_wr,output wire uart0_rd,output wire [7:0] uart_w,input wire uart0_valid,input wire [7:0] uart0_data);\n [/INST]\n", "output": "wire io_rd, io_wr; \n  wire [15:0] mem_addr; \n  wire mem_wr; \n  wire [15:0] dout; \n  wire [15:0] io_din; \n  wire [12:0] code_addr; \n  wire [15:0] return_top; \n  wire [1:0] io_thread; \n  wire [3:0] kill_slot_rq; \n  wire [15:0] insn; \n  assign kill_slot_rq = 4'b0; \n  reg [15:0] ram_prog[0:4095] ; \n  always @(posedge clk) begin \n  insn <= ram_prog[code_addr[11:0]]; \n  if (mem_wr) \n  ram_prog[mem_addr[12:1]] <= dout; \n  end \n j4 _j4(.clk(clk),.resetq(resetq),.io_rd(io_rd),.io_wr(io_wr),.mem_wr(mem_wr),.dout(dout),.io_din(io_din),.mem_addr(mem_addr),.code_addr(code_addr),.insn(insn),.io_slot(io_thread),.return_top(return_top),.kill_slot_rq(kill_slot_rq)); \n  reg io_wr_, io_rd_; \n  reg [15:0] dout_; \n  reg [15:0] io_addr_; \n  reg [1:0] io_thread_; \n  always @(posedge clk) begin \n  {io_rd_, io_wr_, dout_} <= {io_rd, io_wr, dout}; \n  io_thread_ <= io_thread; \n  if (io_rd | io_wr) \n  io_addr_ <= mem_addr; \n  else \n  io_addr_ <= 0; \n  end \n  wire uart0_wr = io_wr_ & io_addr_[12]; \n  wire uart0_rd = io_rd_ & io_addr_[12]; \n  assign uart_w = dout_[7:0]; \n  reg [15:0] taskexec; \n  reg [47:0] taskexecn; \n  always @* begin \n  case (io_thread_) \n  2'b00: taskexec = 16'b0; \n  2'b01: taskexec = taskexecn[15:0]; \n  2'b10: taskexec = taskexecn[31:16]; \n  2'b11: taskexec = taskexecn[47:32]; \n  endcase \n  end \n  assign io_din = \n  (io_addr_[12] ? {8'd0, uart0_data} : 16'd0) | \n  (io_addr_[13] ? {12'd0, 1'b0, 1'b0, uart0_valid, 1'b1} : 16'd0) | \n  (io_addr_[14] ? {taskexec}: 16'd0)| \n  (io_addr_[15] ? {14'd0, io_thread_}: 16'd0); \n  always@( posedge clk) begin \n  if (io_wr_ ) begin \n  if (io_addr_[8]) taskexecn[15:0] <= dout_; \n  if (io_addr_[9]) taskexecn[31:16] <= dout_; \n  if (io_addr_[10]) taskexecn[47:32] <= dout_; \n  end \n  if (io_addr_[15]==1'b1) $display(\"io_thread_ = %d, io_din = %d\", io_thread_, io_din); \n  case ({io_wr_ , io_addr_[14], io_thread_}) \n  4'b1100: kill_slot_rq <= dout_[3:0]; \n  4'b1101: kill_slot_rq <= 4'b0010; \n  4'b1111: kill_slot_rq <= 4'b1000; \n  4'b1110: kill_slot_rq <= 4'b0100; \n  default: kill_slot_rq <= 4'b0000; \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is designed to convert raw data to RGB components based on the input X and Y coordinates, data, and a data valid signal. The module uses a line buffer for data processing and calculates the red, green, and blue components based on the input coordinates and data. The module also includes logic for resetting and shifting the data, and assigns the calculated RGB values to the output ports oRed, oGreen, and oBlue.\n\n Module header:\n\nmodule RAW2RGB( oRed,oGreen,oBlue,oDVAL,iX_Cont,iY_Cont,iDATA,iDVAL,iCLK,iRST);\n [/INST]\n", "output": "input [10:0] iX_Cont; \n input [10:0] iY_Cont; \n input [11:0] iDATA; \n input iDVAL; \n input iCLK; \n input iRST; \n output [11:0] oRed; \n output [11:0] oGreen; \n output [11:0] oBlue; \n output oDVAL; \n wire [11:0] mDATA_0; \n wire [11:0] mDATA_1; \n reg [11:0] mDATAd_0; \n reg [11:0] mDATAd_1; \n reg [11:0] mCCD_R; \n reg [12:0] mCCD_G; \n reg [11:0] mCCD_B; \n reg mDVAL; \n reg [12:0] mDATA_green_0; \n reg [12:0] mDATA_green_1; \n assign oRed = mCCD_R[11:0]; \n assign oGreen = mCCD_G[12:1]; \n assign oBlue = mCCD_B[11:0]; \n assign oDVAL = mDVAL; \n Line_Buffer u0 ( .clken(iDVAL),.clock(iCLK),.shiftin(iDATA),.taps0x(mDATA_1),.taps1x(mDATA_0) ); \n always@(posedge iCLK or negedge iRST) \n begin \n  if(!iRST) \n  begin \n  mCCD_R <= 0; \n  mCCD_G <= 0; \n  mCCD_B <= 0; \n  mDATAd_0 <= 0; \n  mDATAd_1 <= 0; \n  mDVAL <= 0; \n  end \n  else \n  begin \n  mDATAd_0 <= mDATA_0; \n  mDATAd_1 <= mDATA_1; \n  mDVAL <= {iY_Cont[0]|iX_Cont[0]} ? 1'b0 : iDVAL; \n  if({iY_Cont[0],iX_Cont[0]}==2'b10) \n  begin \n  mCCD_R <= mDATA_0; \n  mCCD_G <= mDATAd_0 + mDATA_1; \n  mCCD_B <= mDATAd_1; \n  end \n  else if({iY_Cont[0],iX_Cont[0]}==2'b11) \n  begin \n  mCCD_R <= mDATAd_0; \n  mCCD_G <= mDATA_0 + mDATAd_1; \n  mCCD_B <= mDATA_1; \n  end \n  else if({iY_Cont[0],iX_Cont[0]}==2'b00) \n  begin \n  mCCD_R <= mDATA_1; \n  mCCD_G <= mDATA_0 + mDATAd_1; \n  mCCD_B <= mDATAd_0; \n  end \n  else if({iY_Cont[0],iX_Cont[0]}==2'b01) \n  begin \n  mCCD_R <= mDATAd_1; \n  mCCD_G <= mDATAd_0 + mDATA_1; \n  mCCD_B <= mDATA_0; \n  end \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, named \"logic_0\", has a single output 'a'. It assigns the value 0 to 'a' using a continuous assignment statement.\n\n Module header:\n\nmodule logic_0(output a);\n [/INST]\n", "output": "assign a = 0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an implementation of a USB transmit data module. It consists of a state machine with various states such as idle, synchronization, data, CRC calculation, and completion. The module includes logic to control the state transitions and generate the necessary control signals for the USB protocol. It also incorporates a CRC16 generator for error checking and a data register for storing the transmitted data. Additionally, it has multiplexers for selecting the appropriate data and CRC signals based on the current state. The module handles the transmission process by managing the state transitions and data flow according to the USB protocol specification.\n\n Module header:\n\nmodule usb_tx_data (input c,input [7:0] d,input dv,output [7:0] sie_d,output sie_dv);\n [/INST]\n", "output": "localparam ST_IDLE = 4'd0; \n localparam ST_SYNC = 4'd1; \n localparam ST_DATA = 4'd2; \n localparam ST_CRC_HI = 4'd3; \n localparam ST_CRC_LO = 4'd4; \n localparam ST_DONE = 4'd5; \n localparam SW=4, CW=5; \n reg [CW+SW-1:0] ctrl; \n wire [SW-1:0] state; \n wire [SW-1:0] next_state = ctrl[SW+CW-1:CW]; \n r #(SW) state_r \n (.c(c), .rst(1'b0), .en(1'b1), .d(next_state), .q(state)); \n wire [7:0] d_d1; \n d1 #(8) d_d1_r(.c(c), .d(d), .q(d_d1)); \n wire [15:0] crc; \n wire crc_dv; \n usb_crc16 usb_crc16_inst \n (.c(c), .d(d_d1), .dv(crc_dv), .rst(state == ST_IDLE), .crc(crc)); \n wire [1:0] sie_d_sel; \n wire [7:0] sie_mux_z; \n gmux #(.DWIDTH(8), .SELWIDTH(2)) sie_d_gmux \n (.d({crc, d_d1, 8'b10000000}),.sel(sie_d_sel),.z(sie_mux_z)); \n wire [7:0] sie_d_i = sie_dv_i ? sie_mux_z : 8'h0; \n always @* begin \n  case (state) \n  ST_IDLE: \n  if (dv) ctrl = { ST_SYNC , 5'b00_00_1 }; \n  else ctrl = { ST_IDLE , 5'b00_00_0 }; \n  ST_SYNC: ctrl = { ST_DATA , 5'b00_01_1 }; \n  ST_DATA: \n  if (~dv) ctrl = { ST_CRC_LO, 5'b01_01_1 }; \n  else ctrl = { ST_DATA , 5'b01_01_1 }; \n  ST_CRC_LO: ctrl = { ST_CRC_HI, 5'b00_10_1 }; \n  ST_CRC_HI: ctrl = { ST_DONE , 5'b00_11_1 }; \n  ST_DONE: ctrl = { ST_IDLE , 5'b00_11_0 }; \n  default: ctrl = { ST_IDLE , 5'b00_00_0 }; \n  endcase \n end \n wire sie_dv_i = ctrl[0]; \n assign sie_d_sel = ctrl[2:1]; \n assign crc_dv = ctrl[3]; \n d1 #(8) sie_d1_d_r (.c(c), .d(sie_d_i ), .q(sie_d )); \n d1 sie_d1_dv_r(.c(c), .d(sie_dv_i), .q(sie_dv)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `map_slice_typeuint8_2_1__xl0_xh0_yl0_yh0_W2_H1` takes an input of 32 bits and produces an output of 16 bits. It uses two instances of the `slice_typeuint8_2_1__xl0_xh0_yl0_yh0` module to split the input into two 8-bit segments and assigns the concatenated result to the output. The inner modules are configured with the given parameters and connected to the input and clock signals.\n\n Module header:\n\nmodule map_slice_typeuint8_2_1__xl0_xh0_yl0_yh0_W2_H1(input CLK, input process_CE, input [31:0] process_input, output [15:0] process_output);\n [/INST]\n", "output": "parameter INSTANCE_NAME=\"INST\"; \n  wire [7:0] inner0_0_process_output; \n  wire [7:0] inner1_0_process_output; \n  assign process_output = {inner1_0_process_output,inner0_0_process_output}; \n  slice_typeuint8_2_1__xl0_xh0_yl0_yh0 #(.INSTANCE_NAME({INSTANCE_NAME,\"_inner0_0\"})) inner0_0(.CLK(CLK), .process_CE(process_CE), .inp(({process_input[15:0]})), .process_output(inner0_0_process_output)); \n  slice_typeuint8_2_1__xl0_xh0_yl0_yh0 #(.INSTANCE_NAME({INSTANCE_NAME,\"_inner1_0\"})) inner1_0(.CLK(CLK), .process_CE(process_CE), .inp(({process_input[31:16]})), .process_output(inner1_0_process_output)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a D-latch with an enable input. When the enable input E is low (0), the D-latch transparently passes the input data D to the output register Q. When the enable input is high (1), the D-latch holds the previous value at the output.\n\n Module header:\n\nmodule \\$_DLATCH_N_ (E, D, Q);\n [/INST]\n", "output": "input E, D; \n output reg Q; \n always @* begin \n  if (E == 0) \n  Q <= D; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an Input Buffer Differential Output module with differential termination, DQS bias, and low-power attributes. It takes differential input signals I and IB and generates differential output signals O and OB. The module includes logic to handle attributes such as DIFF_TERM, DQS_BIAS, and IBUF_LOW_PWR. It also has a DQS_BIAS_BINARY signal that is set based on the input values and module attributes. The module also contains output logic for different input combinations and handles high-impedance states. Additionally, it has specific input/output relationships specified for Xilinx timing analysis.\n\n Module header:\n\nmodule IBUFDS_DIFF_OUT (O, OB, I, IB);\n [/INST]\n", "output": "parameter DIFF_TERM = \"FALSE\"; \n  parameter DQS_BIAS = \"FALSE\"; \n  parameter IBUF_LOW_PWR = \"TRUE\"; \n  parameter IOSTANDARD = \"DEFAULT\"; \n `ifdef XIL_TIMING \n  parameter LOC = \" UNPLACED\"; \n `endif \n  output O, OB; \n  input I, IB; \n  reg o_out; \n  reg DQS_BIAS_BINARY = 1'b0; \n  buf B0 (O, o_out); \n  not B1 (OB, o_out); \n  initial begin \n  case (DIFF_TERM) \n  \"TRUE\", \"FALSE\" : ; \n  default : begin \n  $display(\"Attribute Syntax Error : The attribute DIFF_TERM on IBUFDS_DIFF_OUT instance %m is set to %s. Legal values for this attribute are TRUE or FALSE.\", DIFF_TERM); \n  $finish; \n  end \n  endcase \n  case (IBUF_LOW_PWR) \n  \"FALSE\", \"TRUE\" : ; \n  default : begin \n  $display(\"Attribute Syntax Error : The attribute IBUF_LOW_PWR on IBUFDS_DIFF_OUT instance %m is set to %s. Legal values for this attribute are TRUE or FALSE.\", IBUF_LOW_PWR); \n  $finish; \n  end \n  endcase \n  case (DQS_BIAS) \n  \"TRUE\" : DQS_BIAS_BINARY <= #1 1'b1; \n  \"FALSE\" : DQS_BIAS_BINARY <= #1 1'b0; \n  default : begin \n  $display(\"Attribute Syntax Error : The attribute DQS_BIAS on IBUFDS_DIFF_OUT instance %m is set to %s. Legal values for this attribute are TRUE or FALSE.\", DQS_BIAS); \n  $finish; \n  end \n  endcase \n  end \n  always @(I or IB or DQS_BIAS_BINARY) begin \n  if (I == 1'b1 && IB == 1'b0) \n  o_out <= I; \n  else if (I == 1'b0 && IB == 1'b1) \n  o_out <= I; \n  else if ((I === 1'bz || I == 1'b0) && (IB === 1'bz || IB == 1'b1)) \n  if (DQS_BIAS_BINARY == 1'b1) \n  o_out <= 1'b0; \n  else \n  o_out <= 1'bx; \n  else if (I == 1'bx || IB == 1'bx) \n  o_out <= 1'bx; \n  end \n  `ifdef XIL_TIMING \n  specify \n  (I => O) = (0:0:0, 0:0:0); \n  (I => OB) = (0:0:0, 0:0:0); \n  (IB => O) = (0:0:0, 0:0:0); \n  (IB => OB) = (0:0:0, 0:0:0); \n  specparam PATHPULSE$ = 0; \n  endspecify \n  `endif \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a testbench for a UART (Universal Asynchronous Receiver/Transmitter) design. It declares signals for the clock, reset, baud strobe, read and write signals, as well as the data input and output registers. It also declares signals for the receive and transmit data present, half full, and full signals. The module includes logic to generate the clock signal, handle the baud strobe count, and set the initial values for the signals. Additionally, it instantiates the RxUart and TxUart modules with the specified parameters, linking the input and output ports accordingly. The testbench is designed to verify the functionality of the UART design.\n\n Module header:\n\nmodule RxUart_tb ();\n [/INST]\n", "output": "reg clk; \n reg rst; \n reg x16BaudStrobe; \n reg read; \n reg write; \n reg [7:0] dataIn; \n wire [7:0] dataOut; \n wire rxDataPresent; \n wire rxHalfFull; \n wire rxFull; \n wire serial; \n wire txDataPresent; \n wire txHalfFull; \n wire txFull; \n reg [2:0] baudStrobeCount; \n integer i; \n always #1 clk = ~clk; \n always @(posedge clk) baudStrobeCount <= baudStrobeCount + 2'd1; \n always @(posedge clk) x16BaudStrobe <= baudStrobeCount == 'd0; \n initial begin \n  clk = 1'b0; \n  rst = 1'b1; \n  x16BaudStrobe = 1'b0; \n  read = 1'b0; \n end \n RxUart #(.LOG2_DEPTH(4)) \n uut \n (.clk(clk),.rst(rst),.x16BaudStrobe(x16BaudStrobe),.read(read),.serialIn(serial),.dataOut(dataOut),.dataPresent(rxDataPresent),.halfFull(rxHalfFull),.full(rxFull)); \n TxUart #(.LOG2_DEPTH(4)) \n stimulus \n (.clk(clk),.rst(rst),.x16BaudStrobe(x16BaudStrobe),.dataIn(dataIn),.write(write),.serialOut(serial),.dataPresent(txDataPresent),.halfFull(txHalfFull),.full(txFull)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module checks for the validity of a phase shift operation on a clock signal. It takes inputs for the desired phase shift, clock period, shifted clock signal, original clock signal, reset signal, and a LOCKED signal. The module calculates the phase shift based on the desired shift and clock period, and then checks if the shifted clock signal is valid. If the desired shift is out of range, the module sets a fail signal. Additionally, it delays for 0.2 seconds and then checks if the shifted clock signal and the desired shift are valid. If not, it sets the fail signal. The fail signal is registered and output as 'fail'.\n\n Module header:\n\nmodule phase_shift_check (input [31:0] desired_shift_1000,input [31:0] clk_period_1000,input clk_shifted,input clk,input rst,input LOCKED,output reg fail);\n [/INST]\n", "output": "always @(posedge clk or posedge rst) begin \n  if (rst) begin \n  fail <= 0; \n  end else if (LOCKED) begin \n  if (desired_shift_1000 > 0) begin \n  #(((desired_shift_1000 / 1000.0) * ((clk_period_1000 / 1000.0) / 360.0)) - 0.1); \n  if (clk_shifted !== 0) begin \n  fail <= 1; \n  end \n  end else if (desired_shift_1000 < 0) begin \n  #(((clk_period_1000 / 1000.0) + ((desired_shift_1000 / 1000.0) * ((clk_period_1000 / 1000.0) / 360.0))) - 0.1); \n  if (clk_shifted !== 0) begin \n  fail <= 1; \n  end \n  end \n  #0.2; \n  if (clk_shifted !== 1 && desired_shift_1000 !== 0) begin \n  fail <= 1; \n  end \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a sequence of operations based on the input signals. It assigns the value of activate_0r to sreq_0n[0], and activateOut_0a to activate_0a. It also assigns activateOut_2r to sreq_0n[2]. Additionally, it instantiates two components, I3 and I4, passing relevant signals to them. I3 is an instance of telemr, while I4 is an instance of selem.\n\n Module header:\n\nmodule BrzSequence_3_s2_ST (activate_0r, activate_0a,activateOut_0r, activateOut_0a,activateOut_1r, activateOut_1a,activateOut_2r, activateOut_2a,initialise);\n [/INST]\n", "output": "input activate_0r; \n  output activate_0a; \n  output activateOut_0r; \n  input activateOut_0a; \n  output activateOut_1r; \n  input activateOut_1a; \n  output activateOut_2r; \n  input activateOut_2a; \n  input initialise; \n  wire [2:0] sreq_0n; \n  assign activate_0a = activateOut_2a; \n  assign activateOut_2r = sreq_0n[2]; \n  assign sreq_0n[0] = activate_0r; \n  telemr I3 (sreq_0n[1], sreq_0n[2], activateOut_1r, activateOut_1a, initialise); \n  selem I4 (sreq_0n[0], sreq_0n[1], activateOut_0r, activateOut_0a); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a D flip-flop, which is a fundamental sequential logic circuit. It has an input D, clock input Clk, and an output Q. On every positive edge of the clock, the input D is transferred to the output Q, effectively storing the value of D.\n\n Module header:\n\nmodule D_flip_flop (output Q, input D, Clk);\n [/INST]\n", "output": "reg Q; \n  initial Q = 1'b0; \n  always @ (posedge Clk) Q <= D; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes in 4 input signals and assigns them to a 4-bit output in the same order.\n\n Module header:\n\nmodule v84f0a1_v9a2a06 (input i3,input i2,input i1,input i0,output [3:0] o);\n [/INST]\n", "output": "assign o = {i3, i2, i1, i0}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module defines a dual-port RAM with configurable address and data width. The RAM depth is calculated based on the address width, and a RAM array is declared. The module supports simultaneous read and write operations on separate ports, with write operations triggered by the positive edge of clk_a. The module also initializes the RAM contents from a memory file, if specified. The RAM is updated based on the input signals, and the read data is output accordingly.\n\n Module header:\n\nmodule dp_ram #(parameter adr_width = 13,parameter dat_width = 16,parameter mem_file_name = \"none\") (input clk_a,input en_a,input en_b,input [adr_width-1:0] adr_a,input [dat_width-1:0] dat_a,input clk_b,input [adr_width-1:0] adr_b,output reg [dat_width-1:0] dat_b,output reg [dat_width-1:0] dat_a_out,input we_a);\n [/INST]\n", "output": "parameter depth = (1 << adr_width); \n  reg [dat_width-1:0] ram [0:depth-1]; \n  always @(posedge clk_b) begin \n  if (en_b) \n  dat_b <= ram[adr_b]; \n  end \n  always @(posedge clk_a) begin \n  if (en_a) begin \n  if (we_a) begin \n  ram[adr_a] <= dat_a; \n  end else dat_a_out<=ram[adr_a]; \n  end \n  end \n  initial \n  begin \n  if (mem_file_name != \"none\") begin \n  $readmemh(mem_file_name, ram); \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a D-type flip-flop with asynchronous set signal. When the set signal S is high, the output Q is set to 1. Otherwise, the output Q follows the input D. The flip-flop is clocked by the input C.\n\n Module header:\n\nmodule SB_DFFNS (output Q, input C, S, D);\n [/INST]\n", "output": "`SB_DFF_REG \n  always @(negedge C, posedge S) \n  if (S) \n  Q <= 1; \n  else \n  Q <= D; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a synchronous Gray code generator. It includes a clock domain crossing synchronization stage and functions for converting binary to Gray code and vice versa. The module takes inputs for clock, reset, count, and clock enable, and outputs the synchronized Gray code count. When the asynchronous clock enable signal is asserted, it performs Gray code conversion and synchronization. If the asynchronous clock enable is not asserted, the module directly outputs the input count.\n\n Module header:\n\nmodule sync_gray #(parameter DATA_WIDTH = 1,parameter ASYNC_CLK = 1)(input in_clk,input in_resetn,input [DATA_WIDTH-1:0] in_count,input out_resetn,input out_clk,output [DATA_WIDTH-1:0] out_count);\n [/INST]\n", "output": "generate if (ASYNC_CLK == 1) begin \n  reg [DATA_WIDTH-1:0] cdc_sync_stage0 = 'h0; \n  reg [DATA_WIDTH-1:0] cdc_sync_stage1 = 'h0; \n  reg [DATA_WIDTH-1:0] cdc_sync_stage2 = 'h0; \n  reg [DATA_WIDTH-1:0] out_count_m = 'h0; \n  function [DATA_WIDTH-1:0] g2b; \n  input [DATA_WIDTH-1:0] g; \n  reg [DATA_WIDTH-1:0] b; \n  integer i; \n  begin \n  b[DATA_WIDTH-1] = g[DATA_WIDTH-1]; \n  for (i = DATA_WIDTH - 2; i >= 0; i = i - 1) \n  b[i] = b[i + 1] ^ g[i]; \n  g2b = b; \n  end \n  endfunction \n  function [DATA_WIDTH-1:0] b2g; \n  input [DATA_WIDTH-1:0] b; \n  reg [DATA_WIDTH-1:0] g; \n  integer i; \n  begin \n  g[DATA_WIDTH-1] = b[DATA_WIDTH-1]; \n  for (i = DATA_WIDTH - 2; i >= 0; i = i -1) \n  g[i] = b[i + 1] ^ b[i]; \n  b2g = g; \n  end \n  endfunction \n  always @(posedge in_clk) begin \n  if (in_resetn == 1'b0) begin \n  cdc_sync_stage0 <= 'h00; \n  end else begin \n  cdc_sync_stage0 <= b2g(in_count); \n  end \n  end \n  always @(posedge out_clk) begin \n  if (out_resetn == 1'b0) begin \n  cdc_sync_stage1 <= 'h00; \n  cdc_sync_stage2 <= 'h00; \n  out_count_m <= 'h00; \n  end else begin \n  cdc_sync_stage1 <= cdc_sync_stage0; \n  cdc_sync_stage2 <= cdc_sync_stage1; \n  out_count_m <= g2b(cdc_sync_stage2); \n  end \n  end \n  assign out_count = out_count_m; \n end else begin \n  assign out_count = in_count; \n end endgenerate \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a palette RAM with addressable locations from 0 to 31. It has synchronous write functionality and outputs the data stored at the specified address. When writing, it checks for specific address conditions before updating the palette data.\n\n Module header:\n\nmodule PaletteRam(input clk, input ce, input [4:0] addr, input [5:0] din, output [5:0] dout, input write);\n [/INST]\n", "output": "reg [5:0] palette [0:31]; \n  initial begin \n  end \n  wire [4:0] addr2 = (addr[1:0] == 0) ? 0 : addr; \n  assign dout = palette[addr2]; \n  always @(posedge clk) if (ce && write) begin \n  if (!(addr[3:2] != 0 && addr[1:0] == 0)) \n  palette[addr2] <= din; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module WcaDducController is a control module that configures various sub-modules and generates control signals for a communication system. It includes parameter definitions for different addresses and modes. The module instantiates sub-modules like WcaWriteByteReg, WcaPhaseGen, and WcaWriteWordReg to handle configuration, phase generation, and register writing operations.\n\nThe module includes a strobe generator that is updated based on the clock signal and control inputs. It also checks for specific conditions related to reset, enable, and configuration signals, and then generates the strobe_cic and strobe_bb signals accordingly.\n\nAdditionally, the module computes the log2 of the interpolation rate and provides it as the log2_rate output.\n\nIn summary, the WcaDducController module acts as a central control unit for configuring and generating control signals for different sub-modules in a communication system.\n\n Module header:\n\nmodule WcaDducController(input clock,input reset,input enable,input wire strobe_if,output wire [7:0] cfg,output wire [12:0] rate_interp,output wire rate_interp_we,output wire [3:0] log2_rate,output wire strobe_cic,output wire strobe_bb,output wire [31:0] phase_cordic,input wire [11:0] rbusCtrl,inout wire [7:0] rbusData);\n [/INST]\n", "output": "parameter IF_FREQ_ADDR = 0; \n  parameter INTERP_RATE_ADDR = 1; \n  parameter CONFIG_ADDR = 2; \n  parameter MODE = 4'hF; \n  `define CORDIC_ENABLED 3'h1 \n  `define CIC_ENABLED 3'h2 \n  `define HBF_ENABLED 3'h4 \n  `define DYNAMIC_CONFIG 4'h8 \n  wire [2:0] dumpReg; \n  WcaWriteByteReg #(CONFIG_ADDR) wr_config \n (.reset(reset),.out( cfg),.rbusCtrl(rbusCtrl), .rbusData(rbusData) ); \n  WcaPhaseGen #(IF_FREQ_ADDR, 32) phase_generator \n (.clock(clock), .reset(reset), .aclr(cfg[1]), .enable(enable), .strobe(strobe_if),.rbusCtrl(rbusCtrl), .rbusData(rbusData),.phase(phase_cordic)); \n  WcaWriteWordReg #(INTERP_RATE_ADDR) reg_interp_rate \n (.reset(reset), .out({dumpReg,rate_interp}), .nd(rate_interp_we),.rbusCtrl(rbusCtrl), .rbusData(rbusData) ); \n  reg [11:0] strobeGenerator; \n  wire clear = strobeGenerator[11:2] == rate_interp[9:0]; \n  always @( posedge clock) \n  begin \n  if( reset | ~enable | clear | cfg[1]) \n  begin \n  strobeGenerator <= 12'h1; \n  end \n  else \n  begin \n  strobeGenerator <= strobeGenerator + 12'h1; \n  end \n  end \n  assign strobe_cic = enable & ((MODE[3] & cfg[4]) ? strobe_if : strobeGenerator == 12'h3); \n  assign strobe_bb = enable & ((MODE[3] & cfg[5]) ? strobe_cic : strobe_cic); \n  assign log2_rate = rate_interp[7] ? 4'h7 : \n  rate_interp[6] ? 4'h6 : \n  rate_interp[5] ? 4'h5 : \n  rate_interp[4] ? 4'h4 : \n  rate_interp[3] ? 4'h3 : \n  rate_interp[2] ? 4'h2 : \n  rate_interp[1] ? 4'h1 : 4'h0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module selects a vector based on the spectag input and assigns it to the output. It uses a case statement to determine which input vector to select based on the value of spectag. If none of the specified conditions match, the output is set to 0.\n\n Module header:\n\nmodule select_vector(input wire [`SPECTAG_LEN-1:0] spectag,input wire [`REG_NUM-1:0] dat0,input wire [`REG_NUM-1:0] dat1,input wire [`REG_NUM-1:0] dat2,input wire [`REG_NUM-1:0] dat3,input wire [`REG_NUM-1:0] dat4,output reg [`REG_NUM-1:0] out);\n [/INST]\n", "output": "always @ (*) begin \n  out = 0; \n  case (spectag) \n  5'b00001 : out = dat1; \n  5'b00010 : out = dat2; \n  5'b00100 : out = dat3; \n  5'b01000 : out = dat4; \n  5'b10000 : out = dat0; \n  default : out = 0; \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module is a block memory with four separate memory arrays. It has write and read ports for each array, and a multiplexer to select the data to be read based on the address. The module updates the memory contents based on the write enable signal api_we and the write data api_wr_data. The output api_rd_data is determined by the selected memory array, and the internal_rd_data is a concatenation of the data from all memory arrays at the specified internal address. The memory arrays are updated on the positive edge of the clock signal, and the read data is selected using a case statement based on the lower two bits of the address.\n\n Module header:\n\nmodule blockmem_rw32_r128(input wire clk,input wire api_we,input wire [07 : 0] api_addr,input wire [31 : 0] api_wr_data,output wire [31 : 0] api_rd_data,input wire [05 : 0] internal_addr,output wire [127 : 0] internal_rd_data);\n [/INST]\n", "output": "reg [31 : 0] mem0 [0 : 63]; \n  reg [31 : 0] mem1 [0 : 63]; \n  reg [31 : 0] mem2 [0 : 63]; \n  reg [31 : 0] mem3 [0 : 63]; \n  reg [31 : 0] muxed_api_rd_data; \n  reg [31 : 0] mem0_api_rd_data; \n  reg [31 : 0] mem1_api_rd_data; \n  reg [31 : 0] mem2_api_rd_data; \n  reg [31 : 0] mem3_api_rd_data; \n  reg [31 : 0] mem0_int_rd_data; \n  reg [31 : 0] mem1_int_rd_data; \n  reg [31 : 0] mem2_int_rd_data; \n  reg [31 : 0] mem3_int_rd_data; \n  reg mem0_we; \n  reg mem1_we; \n  reg mem2_we; \n  reg mem3_we; \n  assign api_rd_data = muxed_api_rd_data; \n  assign internal_rd_data = {mem3_int_rd_data, mem2_int_rd_data, \n  mem1_int_rd_data, mem0_int_rd_data}; \n  always @ (posedge clk) \n  begin : reg_update_mem0 \n  if (mem0_we) \n  mem0[api_addr[7 : 2]] <= api_wr_data; \n  mem0_api_rd_data <= mem0[api_addr[7 : 2]]; \n  mem0_int_rd_data <= mem0[internal_addr]; \n  end \n  always @ (posedge clk) \n  begin : reg_update_mem1 \n  if (mem1_we) \n  mem1[api_addr[7 : 2]] <= api_wr_data; \n  mem1_api_rd_data <= mem1[api_addr[7 : 2]]; \n  mem1_int_rd_data <= mem1[internal_addr]; \n  end \n  always @ (posedge clk) \n  begin : reg_update_mem2 \n  if (mem2_we) \n  mem2[api_addr[7 : 2]] <= api_wr_data; \n  mem2_api_rd_data <= mem2[api_addr[7 : 2]]; \n  mem2_int_rd_data <= mem2[internal_addr]; \n  end \n  always @ (posedge clk) \n  begin : reg_update_mem3 \n  if (mem3_we) \n  mem3[api_addr[7 : 2]] <= api_wr_data; \n  mem3_api_rd_data <= mem3[api_addr[7 : 2]]; \n  mem3_int_rd_data <= mem3[internal_addr]; \n  end \n  always @* \n  begin : api_mux \n  mem0_we = 1'b0; \n  mem1_we = 1'b0; \n  mem2_we = 1'b0; \n  mem3_we = 1'b0; \n  case (api_addr[1 : 0]) \n  0: \n  begin \n  muxed_api_rd_data = mem0_api_rd_data; \n  mem0_we = api_we; \n  end \n  1: \n  begin \n  muxed_api_rd_data = mem1_api_rd_data; \n  mem1_we = api_we; \n  end \n  2: \n  begin \n  muxed_api_rd_data = mem2_api_rd_data; \n  mem2_we = api_we; \n  end \n  3: \n  begin \n  muxed_api_rd_data = mem3_api_rd_data; \n  mem3_we = api_we; \n  end \n  default: \n  begin \n  end \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module `FpuFp64_Rcp` implements a floating-point reciprocal operation. It contains registers for exponent, fraction, and temporary results. The module initializes a lookup table for reciprocals from a file during simulation setup. \n\nIt operates on the source operand `src` to compute the reciprocal using the lookup table and shifts. It then selects the appropriate reciprocal based on the exponent and checks for its validity. Depending on the validity of the reciprocal, it calculates the destination exponent and mantissa, and stores the result in the output destination register `dst`. The module is clock-triggered and performs these operations on each rising edge of the clock signal.\n\n Module header:\n\nmodule FpuFp64_Rcp(clk,src,dst);\n [/INST]\n", "output": "input clk; \n input[63:0] src; \n output[63:0] dst; \n reg[12:0] exa; \n reg[12:0] exb; \n reg[52:0] fra; \n reg[52:0] frb; \n reg[52:0] tFr2; \n reg[52:0] tFr3; \n reg[63:0] tDst; \n assign dst = tDst; \n reg[15:0] rcpLut[255:0]; \n initial begin \n  $readmemh(\"rcplut0.txt\", rcpLut); \n end \n always @ (clk) \n begin \n  exa[12:11]=0; \n  exa[10:0]=src[62:52]; \n  fra[52]=0; \n  fra[51:0]=src[51:0]; \n  tDst = 0; \n  tFr2[52:37]=rcpLut[fra[51:44]]; \n  tFr2[36:0]=0; \n  tFr3[52:44]=0; \n  tFr3[43:0]=(fra[43:0]>>1)-(fra[43:0]>>6); \n  case(tFr2[52:49]) \n  4'h8: frb=tFr2-(tFr3<<1); \n  4'h7: frb=tFr2-(tFr3<<1); \n  4'h6: frb=tFr2-(tFr3 ); \n  4'h5: frb=tFr2-(tFr3 ); \n  4'h4: frb=tFr2-(tFr3>>1); \n  default: frb=tFr2; \n  endcase \n  if(frb[52]) \n  begin \n  exb=2046-exa; \n  tDst[63]=src[63]; \n  tDst[62:52]=exb[10:0]; \n  tDst[51:0]=frb[51:0]; \n  end \n  else \n  begin \n  exb=2045-exa; \n  tDst[63]=src[63]; \n  tDst[62:52]=exb[10:0]; \n  tDst[51:1]=frb[50:0]; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module is a 16x16 multiplier. It takes two 16-bit inputs A and B, and multiplies them to produce a 32-bit output Z. The multiplication result is assigned to the output wire Z using the assign statement.\n\n Module header:\n\nmodule mult_16x16 (input wire [15:0] A,input wire [15:0] B,output wire [31:0] Z);\n [/INST]\n", "output": "assign Z = A * B; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a register group with two outputs data_out_A and data_out_B, a write input, an address input, an output_AB input, and a data_in input. It uses a register array with 16 16-bit registers, initializes register[0] to 0, and assigns data_out_A and data_out_B from the register array based on the output_AB input. The module triggers on the positive edge of the write input and assigns the data_in to the register addressed by the non-zero address.\n\n Module header:\n\nmodule Register_Group(output [15 : 0] data_out_A,output [15 : 0] data_out_B,input write,input [3 : 0] address,input [7 : 0] output_AB,input [15 : 0] data_in);\n [/INST]\n", "output": "reg [15 : 0] register [15 : 0]; \n  initial \n  begin \n  register[0] <= 0; \n  end \n  assign data_out_A = register[output_AB[7 : 4]]; \n  assign data_out_B = register[output_AB[3 : 0]]; \n  always @(posedge write) \n  begin \n  if (address != 0) \n  begin \n  register[address] <= data_in; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a light-up control module. It takes in a clock signal, a header, and a counter, and outputs control signals for tachy_pin, brady_pin, and normal_pin. The module contains parameters for defining fast and slow beat thresholds, and correct header values. It uses registers and wires to track the previous counter value, calculate the difference between the current and previous counter values, and determine if the beat is too fast or too slow based on the thresholds. It uses these calculations to control the tachy_pin and brady_pin outputs. The module also instantiates two LED flasher modules for tachy and brady flashing, and assigns the normal_pin based on the absence of tachy and brady flashes.\n\n Module header:\n\nmodule light_up (clk,header,counter,tachy_pin,brady_pin,normal_pin);\n [/INST]\n", "output": "input clk; \n input[7:0] header; \n input[31:0] counter; \n output tachy_pin; \n output brady_pin; \n output normal_pin; \n parameter FAST_BEAT = 32'd750; \n parameter SLOW_BEAT = 32'd1800; \n parameter CORRECT_HEAD1 = 8'd4; \n parameter CORRECT_HEAD2 = 8'd6; \n reg brady_flash; \n reg tachy_flash; \n reg[31:0] counter_previous; \n wire[31:0] difference; \n wire correct_header; \n wire too_fast; \n wire too_slow; \n assign correct_header = (header == CORRECT_HEAD1 || header == CORRECT_HEAD2); \n assign difference = counter - counter_previous; \n assign too_fast = difference <= FAST_BEAT; \n assign too_slow = difference >= SLOW_BEAT; \n always @(posedge clk) begin \n  if (correct_header) begin \n  tachy_flash <= too_fast; \n  brady_flash <= too_slow; \n  counter_previous <= counter; \n  end \n end \n led_flasher tachy_flasher \n (.clk(clk),.LED_flash(tachy_flash),.LED_out(tachy_pin)); \n led_flasher brady_flasher \n (.clk(clk),.LED_flash(brady_flash),.LED_out(brady_pin)); \n assign normal_pin = !tachy_flash && !brady_flash; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a programmable interrupt controller. It takes in various input signals including clock, reset, and interrupt requests, and outputs interrupt acknowledgement, interrupt signals, and data for interrupt handling.\n\nThe module includes registers to store polarity, edge information, pending interrupts, and masks. It also utilizes a function called trigger to determine the type of interrupt (edge or level triggered) based on the input signal configurations.\n\nAdditionally, it has a register for the IRQ event and uses a priority encoder to encode live interrupts. The module also has address decoding logic to handle configuration and data transfer for edge, polarity, mask, and pending interrupt registers.\n\nThe module also handles interrupt acknowledgement and prioritizes interrupts based on their pending status and masking. It resets various registers and outputs based on the reset signal.\n\nOverall, this module acts as a configurable interrupt controller to manage and prioritize interrupt requests for a microcontroller or processor.\n\n Module header:\n\nmodule pic (input clk_i, input rst_i, input cyc_i, input stb_i,input [2:0] adr_i,input we_i,input [31:0] dat_i,output reg [31:0] dat_o,output reg ack_o,output reg int_o,input [31:0] irq);\n [/INST]\n", "output": "reg [31:0] pol, edgen, pending, mask; \n  reg [31:0] lirq, dirq; \n  always @(posedge clk_i) \n  lirq <= irq; \n  always @(posedge clk_i) \n  dirq <= lirq; \n  function trigger; \n  input edgen, pol, lirq, dirq; \n  reg edge_irq, level_irq; \n  begin \n  edge_irq = pol ? (lirq & ~dirq) : (dirq & ~lirq); \n  level_irq = pol ? lirq : ~lirq; \n  trigger = edgen ? edge_irq : level_irq; \n  end \n  endfunction \n  reg [31:0] irq_event; \n  integer n; \n  always @(posedge clk_i) \n  for(n = 0; n < 32; n = n+1) \n  irq_event[n] <= trigger(edgen[n], pol[n], lirq[n], dirq[n]); \n  wire wb_acc = cyc_i & stb_i; \n  wire wb_wr = wb_acc & we_i; \n  always @(posedge clk_i) \n  if (rst_i) \n  begin \n  pol <= 0; \n  edgen <= 0; \n  mask <= 0; \n  end \n  else if(wb_wr) \n  case (adr_i) \n  3'd0 : edgen <= dat_i; \n  3'd1 : pol <= dat_i; \n  3'd2 : mask <= dat_i; \n  3'd3 : ; \n  3'd4 : ; \n  endcase \n  always @(posedge clk_i) \n  if (rst_i) \n  pending <= 0; \n  else if ( wb_wr & (adr_i == 3'd3) ) \n  pending <= (pending & ~dat_i) | irq_event; \n  else \n  pending <= pending | irq_event; \n  wire [31:0] live_enc; \n  priority_enc priority_enc ( .in(pending & ~mask), .out(live_enc) ); \n  always @(posedge clk_i) \n  case (adr_i) \n  3'd0 : dat_o <= edgen; \n  3'd1 : dat_o <= pol; \n  3'd2 : dat_o <= mask; \n  3'd3 : dat_o <= pending; \n  3'd4 : dat_o <= live_enc; \n  endcase \n  always @(posedge clk_i) \n  ack_o <= wb_acc & !ack_o; \n  always @(posedge clk_i) \n  if(rst_i) \n  int_o <= 0; \n  else \n  int_o <= |(pending & ~mask); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a multiplier with carry save and carry propagate. It takes inputs a, b, c, d, and cin and computes the sum, carry, and cout outputs. The module uses XOR gates to compute intermediate values x, y, and z, and then uses AND and OR gates to calculate the final outputs.\n\n Module header:\n\nmodule mul_csa42 (sum, carry, cout, a, b, c, d, cin);\n [/INST]\n", "output": "output sum, carry, cout; \n input a, b, c, d, cin; \n wire x, y, z; \n assign x = a ^ b; \n assign y = c ^ d; \n assign z = x ^ y; \n assign sum = z ^ cin ; \n assign carry = (b & ~z) | (cin & z); \n assign cout = (d & ~y) | (a & y); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an 8b/10b encoder for a specific FPGA architecture. It takes in various control and data signals and encodes the data using the 8b/10b encoding scheme. The module includes parameters for setting the transmission protocol and encoding mode. It also includes control signals for managing the encoding process. The module then instantiates the 8b/10b encoder core and connects the input and output signals accordingly.\n\n Module header:\n\n module stratixgx_8b10b_encoder (clk,reset,xgmctrl,kin,xgmdatain,datain,forcedisparity,dataout,parafbkdataout);\n [/INST]\n", "output": "parameter transmit_protocol = \"none\"; \n  parameter use_8b_10b_mode = \"true\"; \n  parameter force_disparity_mode = \"false\"; \n  input clk; \n  input reset; \n  input kin; \n  input [7:0] datain; \n  input [7:0] xgmdatain; \n  input xgmctrl; \n  input forcedisparity; \n  output [9:0] dataout; \n  output [9:0] parafbkdataout; \n  wire tx_clk; \n  wire soft_reset; \n  wire INDV; \n  wire ENDEC; \n  wire GE_XAUI_SEL; \n  wire IB_FORCE_DISPARITY; \n  wire prbs_en; \n  wire tx_ctl_ts; \n  wire tx_ctl_tc; \n  wire [7:0] tx_data_ts; \n  wire [7:0] tx_data_tc; \n  wire tx_data_9_tc; \n  wire [9:0] tx_data_pg; \n  wire [9:0] TXLP10B; \n  wire [9:0] PUDR; \n  assign tx_clk = clk; \n  assign soft_reset = reset; \n  assign INDV = (transmit_protocol != \"xaui\") ? 1'b1 : 1'b0; \n  assign ENDEC = (use_8b_10b_mode == \"true\") ? 1'b1 : 1'b0; \n  assign GE_XAUI_SEL = (transmit_protocol == \"gige\") ? 1'b1 : 1'b0; \n  assign IB_FORCE_DISPARITY = (force_disparity_mode == \"true\") ? 1'b1 : 1'b0; \n  assign prbs_en = 1'b0; \n  assign tx_ctl_ts = xgmctrl; \n  assign tx_ctl_tc = kin; \n  assign tx_data_ts = xgmdatain; \n  assign tx_data_tc = datain; \n  assign tx_data_9_tc = forcedisparity; \n  assign tx_data_pg = 'b0; \n  assign dataout = PUDR; \n  assign parafbkdataout = TXLP10B; \n stratixgx_hssi_tx_enc_rtl m_enc_core (.tx_clk(tx_clk),.soft_reset(soft_reset),.INDV(INDV),.ENDEC(ENDEC),.GE_XAUI_SEL(GE_XAUI_SEL),.IB_FORCE_DISPARITY(IB_FORCE_DISPARITY),.prbs_en(prbs_en),.tx_ctl_ts(tx_ctl_ts),.tx_ctl_tc(tx_ctl_tc),.tx_data_ts(tx_data_ts),.tx_data_tc(tx_data_tc),.tx_data_9_tc(tx_data_9_tc),.tx_data_pg(tx_data_pg),.PUDR(PUDR),.TXLP10B(TXLP10B)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module implements a multi-operand accumulator that computes the accumulation of the input data over multiple clock cycles. The module includes logic to select between different operations based on the input signals, such as summing, updating and enabling the accumulators. It also incorporates a pair of single-operand accumulators to compute the left and right outputs separately based on the processed input data. The accumulator is sensitive to the rising edge of the clock and an additional clock enable signal, allowing for synchronous operation.\n\n Module header:\n\nmodule jt12_acc(input rst,input clk,input clk_en ,input signed [8:0] op_result,input [ 1:0] rl,input zero,input s1_enters,input s2_enters,input s3_enters,input s4_enters,input ch6op,input [2:0] alg,input pcm_en,input signed [8:0] pcm,output reg signed [11:0] left,output reg signed [11:0] right);\n [/INST]\n", "output": "reg sum_en; \n always @(*) begin \n  case ( alg ) \n  default: sum_en = s4_enters; \n  3'd4: sum_en = s2_enters | s4_enters; \n  3'd5,3'd6: sum_en = ~s1_enters; \n  3'd7: sum_en = 1'b1; \n  endcase \n end \n reg pcm_sum; \n always @(posedge clk) if(clk_en) \n  if( zero ) pcm_sum <= 1'b1; \n  else if( ch6op ) pcm_sum <= 1'b0; \n wire use_pcm = ch6op && pcm_en; \n wire sum_or_pcm = sum_en | use_pcm; \n wire left_en = rl[1]; \n wire right_en= rl[0]; \n wire signed [8:0] pcm_data = pcm_sum ? pcm : 9'd0; \n wire [8:0] acc_input = use_pcm ? pcm_data : op_result; \n wire signed [11:0] pre_left, pre_right; \n jt12_single_acc #(.win(9),.wout(12)) u_left(.clk ( clk ),.clk_en ( clk_en ),.op_result ( acc_input ),.sum_en ( sum_or_pcm & left_en ),.zero ( zero ),.snd ( pre_left )); \n jt12_single_acc #(.win(9),.wout(12)) u_right(.clk ( clk ),.clk_en ( clk_en ),.op_result ( acc_input ),.sum_en ( sum_or_pcm & right_en ),.zero ( zero ),.snd ( pre_right )); \n always @(posedge clk) if(clk_en) begin \n  left <= pre_left + { {2{pre_left [11]}}, pre_left [11:2] }; \n  right <= pre_right + { {2{pre_right[11]}}, pre_right[11:2] }; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a buffer with a parameterized size. It has an input 'in' and an output 'dout' of the specified size. The input is directly assigned to the output, effectively creating a buffer that holds the input value.\n\n Module header:\n\nmodule dp_buffer(dout, in);\n [/INST]\n", "output": "parameter SIZE = 1; \n output [SIZE-1:0] dout; \n input [SIZE-1:0] in; \n assign dout = in; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module implements a priority encoder using the assign statement. It takes a 16-bit input and based on the enable signal, it outputs a 4-bit binary number representing the highest-order bit that is set in the input. If enable is low, the output is 0000. If enable is high, the output corresponds to the highest-order bit set in the input, with bit 15 being the highest priority and bit 0 being the lowest priority.\n\n Module header:\n\nmodule pri_encoder_using_assign (binary_out ,encoder_in ,enable);\n [/INST]\n", "output": "output [3:0] binary_out ; \n input enable ; \n input [15:0] encoder_in ; \n wire [3:0] binary_out ; \n assign binary_out = (!enable) ? 0 : ((encoder_in == 16'bxxxx_xxxx_xxxx_xxx1) ? 0 :(encoder_in == 16'bxxxx_xxxx_xxxx_xx10) ? 1 :(encoder_in == 16'bxxxx_xxxx_xxxx_x100) ? 2 :(encoder_in == 16'bxxxx_xxxx_xxxx_1000) ? 3 :(encoder_in == 16'bxxxx_xxxx_xxx1_0000) ? 4 :(encoder_in == 16'bxxxx_xxxx_xx10_0000) ? 5 :(encoder_in == 16'bxxxx_xxxx_x100_0000) ? 6 :(encoder_in == 16'bxxxx_xxxx_1000_0000) ? 7 :(encoder_in == 16'bxxxx_xxx1_0000_0000) ? 8 :(encoder_in == 16'bxxxx_xx10_0000_0000) ? 9 :(encoder_in == 16'bxxxx_x100_0000_0000) ? 10 :(encoder_in == 16'bxxxx_1000_0000_0000) ? 11 :(encoder_in == 16'bxxx1_0000_0000_0000) ? 12 :(encoder_in == 16'bxx10_0000_0000_0000) ? 13 :(encoder_in == 16'bx100_0000_0000_0000) ? 14 : 15); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"bw_iodll\" implements an input/output delay-locked loop (IODLL) for a DDR interface. It takes several input signals including data, clock, test mode, control signals, and reset signals. The module generates outputs such as the locked status, filtered data, overflow indication, and strobe signal. The \"lpf_out\" output is determined based on the \"io_dll_bypass_l\" signal, and the module operates as a delay-locked loop to align and synchronize input and output signals.\n\n Module header:\n\nmodule bw_iodll(bypass_data,ddr_clk_in,ddr_testmode_l,delay_ctrl,io_dll_bypass_l,io_dll_reset_l,se,si,iodll_lock,lpf_out,overflow,so,strobe);\n [/INST]\n", "output": "input [4:0] bypass_data; \n  input ddr_clk_in; \n  input ddr_testmode_l; \n  input [2:0] delay_ctrl; \n  input io_dll_bypass_l; \n  input io_dll_reset_l; \n  input se; \n  input si; \n  output iodll_lock; \n  output [4:0] lpf_out; \n  output overflow; \n  output so; \n  output strobe; \n assign lpf_out = (io_dll_bypass_l == 1'b0)? bypass_data:5'b00000; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a counter with a specified address modulus and width. It increments the counter on the positive edge of the clock when the clock enable signal is high. The counter is reset to 0 on a reset signal or when the carry_tmp signal is high. The module also assigns the counter value to the output q and the carry_tmp signal to the carry output.\n\n Module header:\n\nmodule counters_mod_rtl(clk, rst, clk_ena,q,carry);\n [/INST]\n", "output": "parameter ADDR_MOD = 9; \n  parameter ADDR_WIDTH = 9; \n  input clk, clk_ena, rst; \n  output [ADDR_WIDTH-1:0] q; \n  output carry; \n  reg [ADDR_WIDTH-1:0] cnt; \n  reg carry_tmp; \n  always @ (posedge clk or posedge rst) \n  begin \n  if(rst) \n  cnt <= 0; \n  else if(clk_ena) \n  if(carry_tmp) \n  cnt <= 0; \n  else \n  cnt <= cnt + 1; \n  end \n  always @ (cnt) \n  begin \n  if(cnt == ADDR_MOD-1) \n  carry_tmp = 'b1; \n  else \n  carry_tmp = 'b0; \n  end \n  assign q = cnt; \n  assign carry = carry_tmp; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a barrel shifter, which is a digital circuit that can shift the bits of an input number by a specified amount in a single clock cycle. The module has inputs for the clock signal, the input data, the carry-in signal, the shift amount, an indication if the shift amount is zero, and a function select. It also has outputs for the shifted output data, the carry-out signal, and a stall signal.\n\nInternally, the module contains two sub-modules: a quick shifter and a full shifter. The stall signal determines which shifter to use. If the shift amount is non-zero, the full shifter is used, and if it is zero, the quick shifter is used.\n\nThe quick shifter and the full shifter perform the actual shifting operation based on the input data, shift amount, carry-in, and function select. The output of the selected shifter is then routed to the module's outputs, and the carry-out and stall signals are also determined accordingly.\n\nThe module uses a flip-flop to store the output data and carry-out from the full shifter, and a control signal to indicate whether the quick shifter can be used, based on the stall condition. This enables the module to select the appropriate shifter and produce the correct output based on the input conditions.\n\n Module header:\n\nmodule a25_barrel_shift (i_clk,i_in,i_carry_in,i_shift_amount,i_shift_imm_zero,i_function,o_out,o_carry_out,o_stall);\n [/INST]\n", "output": "input i_clk; \n input [31:0] i_in; \n input i_carry_in; \n input [7:0] i_shift_amount; \n input i_shift_imm_zero; \n input [1:0] i_function; \n output [31:0] o_out; \n output o_carry_out; \n output o_stall; \n wire [31:0] quick_out; \n wire quick_carry_out; \n wire [31:0] full_out; \n wire full_carry_out; \n reg [31:0] full_out_r = 32'd0; \n reg full_carry_out_r = 1'd0; \n reg use_quick_r = 1'd1; \n assign o_stall = (|i_shift_amount[7:2]) & use_quick_r; \n assign o_out = use_quick_r ? quick_out : full_out_r; \n assign o_carry_out = use_quick_r ? quick_carry_out : full_carry_out_r; \n always @(posedge i_clk) \n  begin \n  full_out_r <= full_out; \n  full_carry_out_r <= full_carry_out; \n  use_quick_r <= !o_stall; \n  end \n a25_shifter_full u_shifter_full (.i_in ( i_in ),.i_carry_in ( i_carry_in ),.i_shift_amount ( i_shift_amount ),.i_shift_imm_zero ( i_shift_imm_zero ),.i_function ( i_function ),.o_out ( full_out ),.o_carry_out ( full_carry_out )); \n a25_shifter_quick u_shifter_quick (.i_in ( i_in ),.i_carry_in ( i_carry_in ),.i_shift_amount ( i_shift_amount ),.i_shift_imm_zero ( i_shift_imm_zero ),.i_function ( i_function ),.o_out ( quick_out ),.o_carry_out ( quick_carry_out )); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module `next_pc` is designed to handle the generation of the next program counter based on the current instruction, program counter source, clock signal, and load dependence. It uses a 4x32 multiplexer to select the appropriate next program counter. The output `npc` is updated on the positive edge of the clock signal when the load dependence is not asserted. The module also calculates the program counter increment, branch address, and jump address based on the input instruction.\n\n Module header:\n\nmodule next_pc(inst,pc_source,clk,loaddepend,pc,npc);\n [/INST]\n", "output": "input clk ,loaddepend; \n  input[31:0] inst; \n  input [31:0] pc; \n  output[31:0] npc; \n  reg[31:0] npc; \n  input[1:0] pc_source; \n  wire[31:0] pcInc,Branch1,branchAdd,jumpAdd,next; \n  wire[15:0] address; \n  assign pcInc = pc + 4 ; \n  assign address = inst[15:0]; \n  assign branchAdd = {pcInc[31:26],inst[25:0]}; \n  assign jumpAdd = {{16{1'h0}},address[15:0]}; \n  mux4x32 slct_pc(pcInc,jumpAdd,pcInc,branchAdd,pc_source,next); \n  always @(posedge clk) \n  begin \n  if (~loaddepend) \n  npc <= next; \n  end \n endmodule"}
