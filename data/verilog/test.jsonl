{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a data decoder with inputs for clock signal, reset, code, and parameters for data width and AFI ratio. The code_R register is updated on the rising edge of the clock or falling edge of the reset signal. The pattern output is calculated based on the code and AFI ratio, where specific bits of code_R are XOR-ed and assigned to the pattern output based on the AFI_RATIO and the data width. This process is repeated for each bit of the pattern output.\n\n Module header:\n\nmodule rw_manager_data_decoder(ck,reset_n,code,pattern);\n [/INST]\n", "output": "parameter DATA_WIDTH = \"\"; \n  parameter AFI_RATIO = \"\"; \n  input ck; \n  input reset_n; \n  input [3:0] code; \n  output [2 * DATA_WIDTH * AFI_RATIO - 1 : 0] pattern; \n  reg [3:0] code_R; \n  always @(posedge ck or negedge reset_n) begin \n  if(~reset_n) begin \n  code_R <= 4'b0000; \n  end \n  else begin \n  code_R <= code; \n  end \n  end \n  genvar j; \n  generate \n  for(j = 0; j < DATA_WIDTH; j = j + 1) \n  begin : bit_pattern \n  if(j % 2 == 0) begin \n  assign pattern[j] = code_R[3]; \n  assign pattern[j + DATA_WIDTH] = code_R[2]; \n  if (AFI_RATIO == 2) begin \n  assign pattern[j + 2 * DATA_WIDTH] = code_R[3] ^ code_R[1]; \n  assign pattern[j + 3 * DATA_WIDTH] = code_R[2] ^ code_R[1]; \n  end else if (AFI_RATIO == 4) begin \n  assign pattern[j + 2 * DATA_WIDTH] = code_R[3] ^ code_R[1]; \n  assign pattern[j + 3 * DATA_WIDTH] = code_R[2] ^ code_R[1]; \n  assign pattern[j + 4 * DATA_WIDTH] = code_R[3]; \n  assign pattern[j + 5 * DATA_WIDTH] = code_R[2]; \n  assign pattern[j + 6 * DATA_WIDTH] = code_R[3] ^ code_R[1]; \n  assign pattern[j + 7 * DATA_WIDTH] = code_R[2] ^ code_R[1]; \n  end \n  end \n  else begin \n  assign pattern[j] = code_R[3] ^ code_R[0]; \n  assign pattern[j + DATA_WIDTH] = code_R[2] ^ code_R[0]; \n  if (AFI_RATIO == 2) begin \n  assign pattern[j + 2 * DATA_WIDTH] = code_R[3] ^ code_R[1] ^ code_R[0]; \n  assign pattern[j + 3 * DATA_WIDTH] = code_R[2] ^ code_R[1] ^ code_R[0]; \n  end else if (AFI_RATIO == 4) begin \n  assign pattern[j + 2 * DATA_WIDTH] = code_R[3] ^ code_R[1] ^ code_R[0]; \n  assign pattern[j + 3 * DATA_WIDTH] = code_R[2] ^ code_R[1] ^ code_R[0]; \n  assign pattern[j + 4 * DATA_WIDTH] = code_R[3] ^ code_R[0]; \n  assign pattern[j + 5 * DATA_WIDTH] = code_R[2] ^ code_R[0]; \n  assign pattern[j + 6 * DATA_WIDTH] = code_R[3] ^ code_R[1] ^ code_R[0]; \n  assign pattern[j + 7 * DATA_WIDTH] = code_R[2] ^ code_R[1] ^ code_R[0]; \n  end \n  end \n  end \n  endgenerate \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a latch with two gated inputs G1A and G1B, and a data input D. The output Q_ is a reg type. The module contains a combinatorial always block that triggers on changes in G1A, G1B, or D. When both G1A and G1B are 1, the latch updates its output Q_ to be the negation of the input D after a delay of 1 time unit.\n\n Module header:\n\nmodule UDP_LATCH2(Q_, G1A,G1B, D);\n [/INST]\n", "output": "output Q_; \n input G1A, G1B, D; \n  reg Q_; \n always @ (G1A or G1B or D) begin \n  if ((G1A==1) & (G1B==1)) Q_ <= #1 ~D; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module defines a RAM with parameters for delay, depth, and width. It has inputs for address, enable, write, and data, and an output for data. It uses registers and an array to store and retrieve data based on the input signals. The module contains logic to handle enable, write, and data signals to read from or write to the RAM array. The logic ensures that the output data is set to the appropriate values based on the input signals.\n\n Module header:\n\nmodule RAM(i_addr,i_enable_x,i_write_x,i_data,o_data);\n [/INST]\n", "output": "parameter delay = 10; \n  parameter depth = 16; \n  parameter width = 8; \n  input [depth - 1:0] i_addr; \n  input i_enable_x; \n  input i_write_x; \n  input [width - 1:0] i_data; \n  output [width - 1:0] o_data; \n  reg [width - 1:0] o_data; \n  reg [width - 1:0] r_ram[0:2**depth]; \n  reg [depth - 1:0] r_addr; \n  reg r_enable_x; \n  reg r_write_x; \n  reg [width - 1:0] r_data; \n  always r_addr = #delay i_addr; \n  always r_enable_x = #delay i_enable_x; \n  always r_write_x = #delay i_write_x; \n  always r_data = #delay i_data; \n  always @ (r_addr or r_enable_x or r_write_x or r_data) begin \n  if (r_enable_x) begin \n  o_data <= {width{1'bz}}; \n  end else if (r_write_x) begin \n  o_data <= r_ram[r_addr]; \n  end else begin \n  o_data <= {width{1'bx}}; \n  r_ram[r_addr] <= r_data; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an instantiation of a 2-port RAM with a word width of 32 bits and an address width of 8 bits. It has two clock inputs, clka and clkb, along with respective enable signals, address inputs, and data ports. The module includes a memory array, data output register, and logic to handle read and write operations based on the clock and enable signals. When the enable signal is low, the output data is updated based on the value from the memory array, and when the enable signal is high, the output data is assigned 'bx'. Write operations occur when the enable and write enable signals are low, updating the memory array with the input data.\n\n Module header:\n\nmodule rf_2p (clka ,cena_i ,addra_i ,dataa_o ,clkb ,cenb_i ,wenb_i ,addrb_i ,datab_i);\n [/INST]\n", "output": "parameter Word_Width=32; \n parameter Addr_Width=8; \n input clka; \n input cena_i; \n input [Addr_Width-1:0] addra_i; \n output [Word_Width-1:0] dataa_o; \n input clkb; \n input cenb_i; \n input wenb_i; \n input [Addr_Width-1:0] addrb_i; \n input [Word_Width-1:0] datab_i; \n reg [Word_Width-1:0] mem_array[(1<<Addr_Width)-1:0]; \n reg [Word_Width-1:0] dataa_r; \n always @(posedge clka) begin \n  if (!cena_i) \n  dataa_r <= mem_array[addra_i]; \n  else \n  dataa_r <= 'bx; \n end \n assign dataa_o = dataa_r; \n always @(posedge clkb) begin \n  if(!cenb_i && !wenb_i) \n  mem_array[addrb_i] <= datab_i; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is designed for USB access and includes logic for controlling the USB communication interface. It implements a state machine to manage the read and write operations, as well as the acknowledgment signals. The module also includes logic for setting various control signals such as drive, output enable, write enable, and MPCE (Multiprocessor Communication Engine) signals based on the current state and input conditions. The module also synchronizes inputs and outputs with the clock signal and incorporates a reset function to initialize the state machine.\n\n Module header:\n\nmodule aceusb_access(input ace_clkin,input rst,input [5:0] a,input [15:0] di,output reg [15:0] do,input read,input write,output reg ack,output [6:0] aceusb_a,inout [15:0] aceusb_d,output reg aceusb_oe_n,output reg aceusb_we_n,output reg ace_mpce_n,input ace_mpirq,output usb_cs_n,output usb_hpi_reset_n,input usb_hpi_int);\n [/INST]\n", "output": "assign usb_cs_n = 1'b1; \n assign usb_hpi_reset_n = 1'b1; \n assign aceusb_a = {a, 1'b0}; \n reg d_drive; \n assign aceusb_d = d_drive ? di : 16'hzz; \n reg d_drive_r; \n reg aceusb_oe_n_r; \n reg aceusb_we_n_r; \n reg ace_mpce_n_r; \n always @(posedge ace_clkin) begin \n  d_drive <= d_drive_r; \n  aceusb_oe_n <= aceusb_oe_n_r; \n  aceusb_we_n <= aceusb_we_n_r; \n  ace_mpce_n <= ace_mpce_n_r; \n end \n reg d_in_sample; \n always @(posedge ace_clkin) \n  if(d_in_sample) \n  do <= aceusb_d; \n reg [2:0] state; \n reg [2:0] next_state; \n localparam \n  IDLE = 3'd0, \n  READ = 3'd1, \n  READ1 = 3'd2, \n  READ2 = 3'd3, \n  WRITE = 3'd4, \n  ACK = 3'd5; \n always @(posedge ace_clkin) begin \n  if(rst) \n  state <= IDLE; \n  else \n  state <= next_state; \n end \n always @(*) begin \n  d_drive_r = 1'b0; \n  aceusb_oe_n_r = 1'b1; \n  aceusb_we_n_r = 1'b1; \n  ace_mpce_n_r = 1'b1; \n  d_in_sample = 1'b0; \n  ack = 1'b0; \n  next_state = state; \n  case(state) \n  IDLE: begin \n  if(read) begin \n  ace_mpce_n_r = 1'b0; \n  next_state = READ; \n  end \n  if(write) begin \n  ace_mpce_n_r = 1'b0; \n  next_state = WRITE; \n  end \n  end \n  READ: begin \n  ace_mpce_n_r = 1'b0; \n  next_state = READ1; \n  end \n  READ1: begin \n  ace_mpce_n_r = 1'b0; \n  aceusb_oe_n_r = 1'b0; \n  next_state = READ2; \n  end \n  READ2: begin \n  d_in_sample = 1'b1; \n  next_state = ACK; \n  end \n  WRITE: begin \n  d_drive_r = 1'b1; \n  ace_mpce_n_r = 1'b0; \n  aceusb_we_n_r = 1'b0; \n  next_state = ACK; \n  end \n  ACK: begin \n  ack = 1'b1; \n  next_state = IDLE; \n  end \n  endcase \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module serves as an I/O controller with a Wishbone interface. It includes a state machine that controls the acknowledgement signal and data output based on the input signals. The state machine transitions between an IDLE state and an ACK state, updating the acknowledgement signal and the data output accordingly. Additionally, it interfaces with an SPI module to read data and updates the data output based on the address match. The module also includes logic for resetting the internal state and signals when the reset input is asserted.\n\n Module header:\n\nmodule ioctrl_wb #(parameter BASE_ADDR = 32'h00000800) (input clk_i,input rst_i,input [31:0] dat_i,output reg [31:0] dat_o,input [31:0] adr_i,input we_i,input [3:0] sel_i,input cyc_i,input stb_i,output reg ack_o,input sdo_i,output sck_o,output cs_o);\n [/INST]\n", "output": "localparam IDLE = 0; \n localparam ACK = 1; \n wire read_flag; \n wire read = cyc_i & stb_i & !we_i; \n wire write = cyc_i & stb_i & we_i; \n reg state_r; \n wire[7:0] data_r; \n spi_read spi (.clk(clk_i),.sdo(sdo_i),.reset(rst_i),.data(data_r),.cs(cs_o),.sck(sck_o),.read_flag(read_flag)); \n always@(posedge clk_i, posedge rst_i) \n  if(rst_i) begin \n  state_r <= 0; \n  ack_o <= 1'b0; \n  dat_o <= 0; \n  end else begin \n  ack_o <= 1'b0; \n  case(state_r) \n  IDLE: \n  begin \n  if(read && read_flag) begin \n  dat_o <= (adr_i == BASE_ADDR)? data_r: 0; \n  state_r <= ACK; \n  end \n  end \n  ACK: \n  begin \n  ack_o <= 1'b1; \n  state_r <= IDLE; \n  end \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is combining signals from two separate FIFO modules to create unified outputs. It incorporates two FIFO modules, each handling 64-bit and 128-bit data, to merge the upper and lower signals for FULL, ALMOSTFULL, EMPTY, ALMOSTEMPTY, WRERR, and RDERR. It uses parameters to configure the offsets for ALMOST_EMPTY and ALMOST_FULL and includes options for selecting whether the FIRST_WORD_FALL_THROUGH is \"TRUE\". The inputs and outputs are linked through the specified module instances and resulting signals are combined using logical operations to create the final outputs.\n\n Module header:\n\nmodule fifo_512x128 #(parameter ALMOST_EMPTY_OFFSET1 = 13'h0020,parameter ALMOST_EMPTY_OFFSET2 = 13'h0006,parameter ALMOST_FULL_OFFSET1 = 13'h0020,parameter ALMOST_FULL_OFFSET2 = 13'h0006,parameter FIRST_WORD_FALL_THROUGH = \"TRUE\") (input RST,input [127:0] DI,output FULL,output ALMOSTFULL1,output ALMOSTFULL2,output WRERR,input WRCLK,input WREN,output [127:0] DO,output EMPTY,output ALMOSTEMPTY1,output ALMOSTEMPTY2,output RDERR,input RDCLK,input RDEN);\n [/INST]\n", "output": "FIFO36E1 #(.ALMOST_EMPTY_OFFSET(ALMOST_EMPTY_OFFSET1),.ALMOST_FULL_OFFSET(ALMOST_FULL_OFFSET1),.DATA_WIDTH(72),.DO_REG(1),.EN_ECC_READ(\"TRUE\"),.EN_ECC_WRITE(\"TRUE\"),.EN_SYN(\"FALSE\"),.FIFO_MODE(\"FIFO36_72\"),.FIRST_WORD_FALL_THROUGH(FIRST_WORD_FALL_THROUGH),.INIT(72'h000000000000000000),.SIM_DEVICE(\"7SERIES\"),.SRVAL(72'h000000000000000000)) \n U (.DBITERR(),.ECCPARITY(),.SBITERR(),.DO(DO[127:64]),.DOP(),.ALMOSTEMPTY(ALMOSTEMPTY1),.ALMOSTFULL(ALMOSTFULL1),.EMPTY(EMPTY_U),.FULL(FULL_U),.RDCOUNT(),.RDERR(RDERR_U),.WRCOUNT(),.WRERR(WRERR_U),.INJECTDBITERR(1'b0),.INJECTSBITERR(1'b0),.RDCLK(RDCLK),.RDEN(RDEN),.REGCE(1'b0),.RST(RST),.RSTREG(1'b0),.WRCLK(WRCLK),.WREN(WREN),.DI(DI[127:64]),.DIP(4'd0)); \n FIFO36E1 #(.ALMOST_EMPTY_OFFSET(ALMOST_EMPTY_OFFSET2),.ALMOST_FULL_OFFSET(ALMOST_FULL_OFFSET2),.DATA_WIDTH(72),.DO_REG(1),.EN_ECC_READ(\"TRUE\"),.EN_ECC_WRITE(\"TRUE\"),.EN_SYN(\"FALSE\"),.FIFO_MODE(\"FIFO36_72\"),.FIRST_WORD_FALL_THROUGH(FIRST_WORD_FALL_THROUGH),.INIT(72'h000000000000000000),.SIM_DEVICE(\"7SERIES\"),.SRVAL(72'h000000000000000000)) \n L (.DBITERR(),.ECCPARITY(),.SBITERR(),.DO(DO[63:0]),.DOP(),.ALMOSTEMPTY(ALMOSTEMPTY2),.ALMOSTFULL(ALMOSTFULL2),.EMPTY(EMPTY_L),.FULL(FULL_L),.RDCOUNT(),.RDERR(RDERR_L),.WRCOUNT(),.WRERR(WRERR_L),.INJECTDBITERR(1'b0),.INJECTSBITERR(1'b0),.RDCLK(RDCLK),.RDEN(RDEN),.REGCE(1'b0),.RST(RST),.RSTREG(1'b0),.WRCLK(WRCLK),.WREN(WREN),.DI(DI[63:0]),.DIP(4'd0)); \n  assign EMPTY = EMPTY_U || EMPTY_L; \n  assign FULL = FULL_U || FULL_L; \n  assign RDERR = RDERR_U || RDERR_L; \n  assign WRERR = WRERR_U || WRERR_L; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a clock with four outputs: hourTens, hourMu, minTens, and minMu. It includes instantiations of four-bit synchronous counters and NAND gates to control the count and generate the outputs. The module also includes logic for setting the time by toggling the setH and setM inputs. The circuit's functionality is determined by these inputs and a 10Hz clock signal.\n\n Module header:\n\nmodule clock(output [3:0] hourTens,hourMu, minTens,minMu,output sig1s,input clk10hz,input setH,input setM);\n [/INST]\n", "output": "parameter dGND = 4'b0000; \n  parameter h = 1'b1; \n  wire [3:0] qS___, qS__, qS_; \n  wire rcoS___, rcoS__, rcoS_, rcoM__, rcoM_, rcoH__, rcoH_; \n  wire qS__d1,qS__d2,qS__d3, qS_d0, qS_d1, qS_d2, qS_d3; \n  assign nand1 = !(qS_[0] & qS_[2] & rcoS__); \n  assign nand2 = !(nand1 & setM); \n  assign nand3 = !(minTens[0] & minTens[2] & rcoM__); \n  assign nand4 = !(((setM&nand3)|(!setM)) & setH); \n  assign nand5 = !(nand4 & hourMu[0] & hourMu[1] & hourTens[1]); \n  assign sig1s = qS__[0]; \n  c74160 s___(qS___, rcoS___, dGND, h, h, clk10hz,h); \n  c74160 s__(qS__, rcoS__, dGND, rcoS___, h, clk10hz,h); \n  c74160 s_(qS_, rcoS_, dGND, rcoS__, nand1, clk10hz, h); \n  c74160 m__(minMu, rcoM__, dGND, nand2, h, clk10hz, h); \n  c74160 m_(minTens, rcoM_, dGND, rcoM__, nand3, clk10hz, h); \n  c74160 h__(hourMu, rcoH__, dGND, nand4, nand5, clk10hz, h); \n  c74160 h_(hourTens, rcoH_, dGND, rcoH__, nand5, clk10hz, h); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a dual-clock FIFO with write and read interfaces. The module uses gray code for address generation and has separate logic for write and read clocks. It includes functionality for resetting, updating the full and empty flags, and managing the memory array for data storage. The module also defines a function for gray code conversion. The module has inputs for write and read reset signals, write and read clock signals, write and read enable signals, write data input, and read data output. It has outputs for read data, full flag, and empty flag. The module makes use of a memory array for data storage and includes logic for address calculation and management based on the write and read operations.\n\n Module header:\n\nmodule dual_clock_fifo #(parameter ADDR_WIDTH = 3,parameter DATA_WIDTH = 32) (input wire wr_rst_i,input wire wr_clk_i,input wire wr_en_i,input wire [DATA_WIDTH-1:0] wr_data_i,input wire rd_rst_i,input wire rd_clk_i,input wire rd_en_i,output reg [DATA_WIDTH-1:0] rd_data_o,output reg full_o,output reg empty_o);\n [/INST]\n", "output": "reg [ADDR_WIDTH-1:0] wr_addr; \n reg [ADDR_WIDTH-1:0] wr_addr_gray; \n reg [ADDR_WIDTH-1:0] wr_addr_gray_rd; \n reg [ADDR_WIDTH-1:0] wr_addr_gray_rd_r; \n reg [ADDR_WIDTH-1:0] rd_addr; \n reg [ADDR_WIDTH-1:0] rd_addr_gray; \n reg [ADDR_WIDTH-1:0] rd_addr_gray_wr; \n reg [ADDR_WIDTH-1:0] rd_addr_gray_wr_r; \n function [ADDR_WIDTH-1:0] gray_conv; \n input [ADDR_WIDTH-1:0] in; \n begin \n  gray_conv = {in[ADDR_WIDTH-1], \n  in[ADDR_WIDTH-2:0] ^ in[ADDR_WIDTH-1:1]}; \n end \n endfunction \n always @(posedge wr_clk_i) begin \n  if (wr_rst_i) begin \n  wr_addr <= 0; \n  wr_addr_gray <= 0; \n  end else if (wr_en_i) begin \n  wr_addr <= wr_addr + 1'b1; \n  wr_addr_gray <= gray_conv(wr_addr + 1'b1); \n  end \n end \n always @(posedge wr_clk_i) begin \n  rd_addr_gray_wr <= rd_addr_gray; \n  rd_addr_gray_wr_r <= rd_addr_gray_wr; \n end \n always @(posedge wr_clk_i) \n  if (wr_rst_i) \n  full_o <= 0; \n  else if (wr_en_i) \n  full_o <= gray_conv(wr_addr + 2) == rd_addr_gray_wr_r; \n  else \n  full_o <= full_o & (gray_conv(wr_addr + 1'b1) == rd_addr_gray_wr_r); \n always @(posedge rd_clk_i) begin \n  if (rd_rst_i) begin \n  rd_addr <= 0; \n  rd_addr_gray <= 0; \n  end else if (rd_en_i) begin \n  rd_addr <= rd_addr + 1'b1; \n  rd_addr_gray <= gray_conv(rd_addr + 1'b1); \n  end \n end \n always @(posedge rd_clk_i) begin \n  wr_addr_gray_rd <= wr_addr_gray; \n  wr_addr_gray_rd_r <= wr_addr_gray_rd; \n end \n always @(posedge rd_clk_i) \n  if (rd_rst_i) \n  empty_o <= 1'b1; \n  else if (rd_en_i) \n  empty_o <= gray_conv(rd_addr + 1) == wr_addr_gray_rd_r; \n  else \n  empty_o <= empty_o & (gray_conv(rd_addr) == wr_addr_gray_rd_r); \n reg [DATA_WIDTH-1:0] mem[(1<<ADDR_WIDTH)-1:0]; \n always @(posedge rd_clk_i) \n  if (rd_en_i) \n  rd_data_o <= mem[rd_addr]; \n always @(posedge wr_clk_i) \n  if (wr_en_i) \n  mem[wr_addr] <= wr_data_i; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a state machine that generates lower and upper threshold signals for a messbauer diff discriminator. It includes a counter for impulse signals, state machine transitions based on clock and reset signals, and toggling of the enable signal. The state machine transitions through various phases to control the generation of the threshold signals based on the input clock and reset signals. The module also includes logic to handle the duration of threshold phases, impulse rejection, and the count of total impulses.\n\n Module header:\n\n module messbauer_diff_discriminator_signals # (parameter GCLK_PERIOD = 20,parameter LOWER_THRESHOLD_DURATION = 3,parameter UPPER_THRESHOLD_DURATION = 1,parameter DISCRIMINATOR_IMPULSES_PAUSE = 10,parameter IMPULSES_PER_CHANNEL = 16,parameter IMPULSES_FOR_SELECTION = 4) (input wire aclk,input wire areset_n,input wire channel,output reg lower_threshold,output reg upper_threshold);\n [/INST]\n", "output": "localparam INITIAL_STATE = 0; \n  localparam LOWER_THRESHOLD_HIGH_PHASE = 1; \n  localparam UPPER_THRESHOLD_HIGH_PHASE = 2; \n  localparam UPPER_THRESHOLD_LOW_PHASE = 3; \n  localparam LOWER_THRESHOLD_LOW_PHASE = 4; \n  localparam FINAL_STATE = 5; \n  localparam PAUSE_DURATION = 4; \n  reg enable; \n  reg first_enable; \n  reg[15:0] clk_counter; \n  reg[15:0] impulse_counter; \n  reg[15:0] total_impulse_counter; \n  reg[2:0] state; \n  reg impulse_rejected; \n  reg period_done; \n  always @(posedge aclk) \n  begin \n  if(~areset_n) \n  begin \n  clk_counter <= 0; \n  impulse_counter <= 0; \n  total_impulse_counter <= 0; \n  state <= INITIAL_STATE; \n  lower_threshold <= 0; \n  upper_threshold <= 0; \n  first_enable <= 1; \n  impulse_rejected <= 1; \n  end \n  else \n  begin \n  if(first_enable || enable) \n  begin \n  clk_counter <= clk_counter + 1'b1; \n  case (state) \n  INITIAL_STATE: \n  begin \n  clk_counter <= 0; \n  state <= LOWER_THRESHOLD_HIGH_PHASE; \n  impulse_rejected <= 0; \n  period_done <= 0; \n  end \n  LOWER_THRESHOLD_HIGH_PHASE: \n  begin \n  lower_threshold <= 1; \n  if(clk_counter == 1) \n  begin \n  if(impulse_counter <= IMPULSES_FOR_SELECTION) \n  state <= LOWER_THRESHOLD_LOW_PHASE; \n  else state <= UPPER_THRESHOLD_HIGH_PHASE;; \n  end \n  end \n  UPPER_THRESHOLD_HIGH_PHASE: \n  begin \n  impulse_rejected <= 1; \n  upper_threshold <= 1; \n  if(clk_counter == UPPER_THRESHOLD_DURATION + 1) \n  state <= UPPER_THRESHOLD_LOW_PHASE; \n  end \n  UPPER_THRESHOLD_LOW_PHASE: \n  begin \n  state <= LOWER_THRESHOLD_LOW_PHASE; \n  upper_threshold <= 0; \n  end \n  LOWER_THRESHOLD_LOW_PHASE: \n  begin \n  lower_threshold <= 0; \n  if(clk_counter >= LOWER_THRESHOLD_DURATION) \n  begin \n  if(impulse_rejected == 0) \n  impulse_counter <= impulse_counter + 1'b1; \n  total_impulse_counter <= total_impulse_counter + 1'b1; \n  if(total_impulse_counter < IMPULSES_PER_CHANNEL) \n  state <= INITIAL_STATE; \n  else state <= FINAL_STATE; \n  end \n  end \n  FINAL_STATE: \n  begin \n  impulse_counter <= 0; \n  total_impulse_counter <= 0; \n  period_done <= 1; \n  first_enable <= 0; \n  end \n  default: \n  begin \n  end \n  endcase \n  end \n  else state <= INITIAL_STATE; \n  end \n  end \n  always @(posedge channel or negedge areset_n) \n  begin \n  if(~areset_n) \n  enable = 0; \n  else \n  begin \n  if(period_done) \n  enable = ~enable; \n  end \n  end \n  endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module instantiates a testbench for a Box-Muller module. It initializes inputs, reads data from files, and compares the module outputs with expected values. The clock signal is toggled at regular intervals to simulate a clock. It writes the comparison results to an output file, indicating if the outputs match the expected values for each iteration. This testbench is intended to verify the functionality of the Box-Muller module by comparing its outputs with pre-determined values.\n\n Module header:\n\nmodule boxmuller_tb();\n [/INST]\n", "output": "reg [47:0] u0_m[9999:0]; \n reg [15:0] u1_m[9999:0]; \n reg [47:0] u0; \n reg [15:0] u1; \n reg clk, reset; \n wire [15:0]x0,x1; \n reg [15:0]x0_m[9999:0]; \n reg [15:0]x1_m[9999:0]; \n parameter n=256; \n integer A,i; \n BM_dut bm_12( .clk(clk), .reset(reset),.u0(u0),.u1(u1),.x0(x0),.x1(x1)); \n initial \n begin \n clk=0; \n reset=0; \n $readmemh(\"taus_u0.txt\",u0_m); \n $readmemh(\"taus_u1.txt\", u1_m); \n $readmemb(\"x0_bm.txt\",x0_m); \n $readmemb(\"x1_bm.txt\", x1_m); \n end \n initial \n  begin \n  A=$fopen(\"BM_tb_result.txt\", \"w\"); \n  for (i=0;i<10000;i=i+1) \n  begin \n  #2 \n  u0<=u0_m[i]; \n  u1<=u1_m[i]; \n  #1 \n  if(x0==x0_m[i]&&x1==x1_m[i]) \n  begin \n  $fwrite( A, \"x0: %b and x0_m:%b; ,x1: %b and x1_m: %b are equal \\n\",x0,x0_m[i],x1,x1_m[i]); \n  end \n  else \n  begin \n  $fwrite( A, \"x0: %b and x0_m:%b; ,x1: %b and x1_m:%b are not equal \\n\",x0,x0_m[i],x1,x1_m[i]); \n  end \n  end \n  $fclose(A); \n  end \n always \n  begin \n  #5 \n  clk<=~clk; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a decoder that takes a 4-bit input value and a control signal (auxValue) to determine the segment pattern to display on a 7-segment display. When auxValue is high, it selects one set of segment patterns for the input value, and when auxValue is low, it selects a different set of segment patterns. The selected segment pattern is then stored in the output reg segments.\n\n Module header:\n\nmodule TubeROM (input wire[3:0] value,input wire auxValue,output reg[6:0] segments);\n [/INST]\n", "output": "always @ (*) begin \n  if (auxValue) begin \n  case (value) \n  4'h0: segments = 7'h00; \n  4'h1: segments = 7'h73; \n  4'h2: segments = 7'h78; \n  4'h3: segments = 7'h50; \n  4'h4: segments = 7'h1C; \n  4'h5: segments = 7'h76; \n  4'h6: segments = 7'h38; \n  default: segments = 7'b0; \n  endcase \n  end \n  else begin \n  case (value) \n  4'h0: segments = 7'h3F; \n  4'h1: segments = 7'h06; \n  4'h2: segments = 7'h5B; \n  4'h3: segments = 7'h4F; \n  4'h4: segments = 7'h66; \n  4'h5: segments = 7'h6D; \n  4'h6: segments = 7'h7D; \n  4'h7: segments = 7'h07; \n  4'h8: segments = 7'h7F; \n  4'h9: segments = 7'h6F; \n  4'hA: segments = 7'h77; \n  4'hB: segments = 7'h7C; \n  4'hC: segments = 7'h39; \n  4'hD: segments = 7'h5E; \n  4'hE: segments = 7'h79; \n  4'hF: segments = 7'h71; \n  default: segments = 7'b0; \n  endcase \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module serves as a priority multiplexer that selects between two sets of input signals based on the dprio_init_done signal. When dprio_init_done is low, it uses the init signals for address, read, byte enable, write, write data, ATPG mode, scan enable, MDIO disable, and SerDes shift load. When dprio_init_done is high, it uses the avmm signals for the same purposes. The selected signals are then assigned to the corresponding output ports.\n\n Module header:\n\nmodule dprio_mux (input [ 5:0] init_dprio_address,input init_dprio_read,input [ 1:0] init_dprio_byteen,input init_dprio_write,input [15:0] init_dprio_writedata,input init_atpgmode,input init_mdio_dis,input init_scanen,input init_ser_shift_load,input dprio_init_done,input [ 5:0] avmm_dprio_address,input avmm_dprio_read,input [ 1:0] avmm_dprio_byteen,input avmm_dprio_write,input [15:0] avmm_dprio_writedata,input avmm_atpgmode,input avmm_mdio_dis,input avmm_scanen,input avmm_ser_shift_load,output [ 5:0] dprio_address,output dprio_read,output [ 1:0] dprio_byteen,output dprio_write,output [15:0] dprio_writedata,output atpgmode,output mdio_dis,output scanen,output ser_shift_load);\n [/INST]\n", "output": "assign dprio_address = dprio_init_done ? avmm_dprio_address : init_dprio_address; \n  assign dprio_read = dprio_init_done ? avmm_dprio_read : init_dprio_read; \n  assign dprio_byteen = dprio_init_done ? avmm_dprio_byteen : init_dprio_byteen; \n  assign dprio_write = dprio_init_done ? avmm_dprio_write : init_dprio_write; \n  assign dprio_writedata = dprio_init_done ? avmm_dprio_writedata : init_dprio_writedata; \n  assign atpgmode = init_atpgmode; \n  assign scanen = init_scanen; \n  assign mdio_dis = init_mdio_dis; \n  assign ser_shift_load = init_ser_shift_load ; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an axis_bayer_extractor that performs data extraction and manipulation between two data streams. It has configurable parameters such as C_PIXEL_WIDTH, C_BYPASS, C_COL_ODD, and C_ROW_ODD. When C_BYPASS is 1, the module directly connects the input to the output; otherwise, it extracts and manipulates the data based on the input conditions.\n\nThe extraction process involves checking for specific conditions based on the input signals and then setting the output signals accordingly. This includes toggling specific bits and setting valid and last signals based on the input and output ready conditions. The module also handles the reset condition for various internal registers to ensure proper initialization.\n\nThe module uses clocked and combinational logic to handle the data extraction and manipulation, taking into account the reset conditions and input/output ready signals. It has multiple always blocks to handle the extraction and manipulation of the input data and setting the output signals accordingly.\n\nOverall, the module allows for flexible data extraction and manipulation between the input and output data streams based on configurable parameters and input conditions.\n\n Module header:\n\nmodule axis_bayer_extractor # (parameter integer C_PIXEL_WIDTH = 8,parameter integer C_BYPASS = 0,parameter integer C_COL_ODD = 0,parameter integer C_ROW_ODD = 0) (input wire clk,input wire resetn,input wire s_axis_tvalid,input wire [C_PIXEL_WIDTH-1:0] s_axis_tdata,input wire s_axis_tuser,input wire s_axis_tlast,output wire s_axis_tready,output wire m_axis_tvalid,output wire [C_PIXEL_WIDTH-1:0] m_axis_tdata,output wire m_axis_tuser,output wire m_axis_tlast,input wire m_axis_tready);\n [/INST]\n", "output": "generate \n if (C_BYPASS == 1) begin: direct_connect \n  assign m_axis_tvalid = s_axis_tvalid; \n  assign m_axis_tdata[C_PIXEL_WIDTH-1:0] = s_axis_tdata[C_PIXEL_WIDTH-1:0]; \n  assign m_axis_tuser = s_axis_tuser; \n  assign m_axis_tlast = s_axis_tlast; \n  assign s_axis_tready = m_axis_tready; \n end \n else begin: extract_quater \n  reg r_m_axis_tvalid; \n  assign m_axis_tvalid = r_m_axis_tvalid; \n  reg [C_PIXEL_WIDTH-1:0] r_m_axis_tdata; \n  assign m_axis_tdata[C_PIXEL_WIDTH-1:0] = r_m_axis_tdata; \n  reg r_m_axis_tuser; \n  assign m_axis_tuser = r_m_axis_tuser; \n  reg r_m_axis_tlast; \n  assign m_axis_tlast = r_m_axis_tlast; \n  wire snext; \n  assign snext = s_axis_tvalid && s_axis_tready; \n  wire mnext; \n  assign mnext = m_axis_tvalid && m_axis_tready; \n  reg sline_lsb; \n  reg spixel_lsb; \n  always @ (posedge clk) begin \n  if (resetn == 1'b0) \n  sline_lsb <= 0; \n  else if (snext && s_axis_tlast) \n  sline_lsb <= ~sline_lsb; \n  end \n  always @ (posedge clk) begin \n  if (resetn == 1'b0) \n  spixel_lsb <= 0; \n  else if (snext) \n  spixel_lsb <= ~spixel_lsb; \n  end \n  always @ (posedge clk) begin \n  if (resetn == 1'b0) \n  r_m_axis_tdata <= 0; \n else if (snext&& (spixel_lsb == C_COL_ODD)&& (sline_lsb == C_ROW_ODD)) \n  r_m_axis_tdata <= s_axis_tdata; \n  end \n  always @ (posedge clk) begin \n  if (resetn == 1'b0) \n  r_m_axis_tvalid <= 0; \n else if (snext&& (spixel_lsb == 1)&& (sline_lsb == C_ROW_ODD)) \n  r_m_axis_tvalid <= 1; \n  else if (m_axis_tready) \n  r_m_axis_tvalid <= 0; \n  end \n  always @ (posedge clk) begin \n  if (resetn == 1'b0) \n  r_m_axis_tlast <= 0; \n else if (snext&& (spixel_lsb == 1)&& (sline_lsb == C_ROW_ODD)) \n  r_m_axis_tlast <= s_axis_tlast; \n  end \n  always @ (posedge clk) begin \n  if (resetn == 1'b0) \n  r_m_axis_tuser <= 0; \n else if (snext&& s_axis_tuser) \n  r_m_axis_tuser <= 1; \n  else if (mnext) \n  r_m_axis_tuser <= 0; \n  end \n  assign s_axis_tready = (~m_axis_tvalid || m_axis_tready); \n end \n endgenerate \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an arbiter that controls access to multiple data sources and manages the transmission of packets. It includes input and output ports for various access controls and packet transmissions, and utilizes registers and wires to manage access and wait signals. The module also includes an arbiter and a packet-to-mesh converter to handle access requests and data transmission. It incorporates logic to handle reset signals and to update access signals based on grants and matches.\n\n Module header:\n\nmodule etx_arbiter (txwr_wait, txrd_wait, txrr_wait, etx_access, cfg_access,etx_packet,clk, nreset, txwr_access, txwr_packet, txrd_access, txrd_packet,txrr_access, txrr_packet, etx_wait, etx_cfg_wait);\n [/INST]\n", "output": "parameter AW = 32; \n  parameter PW = 2*AW+40; \n  parameter ID = 0; \n  input clk; \n  input nreset; \n  input txwr_access; \n  input [PW-1:0] txwr_packet; \n  output txwr_wait; \n  input txrd_access; \n  input [PW-1:0] txrd_packet; \n  output txrd_wait; \n  input txrr_access; \n  input [PW-1:0] txrr_packet; \n  output txrr_wait; \n  input etx_wait; \n  input etx_cfg_wait; \n  output etx_access; \n  output cfg_access; \n  output [PW-1:0] etx_packet; \n  reg etx_access; \n  reg [PW-1:0] etx_packet; \n  reg cfg_access; \n  reg [PW-1:0] cfg_packet; \n  wire [3:0] txrd_ctrlmode; \n  wire [3:0] txwr_ctrlmode; \n  wire access_in; \n  wire [PW-1:0] etx_packet_mux; \n  wire txrr_grant; \n  wire txrd_grant; \n  wire txwr_grant; \n  wire [PW-1:0] etx_mux; \n  wire [31:0] dstaddr_mux; \n oh_arbiter #(.N(3)) arbiter (.grants({txrd_grant,txwr_grant,txrr_grant}),.requests({txrd_access,txwr_access,txrr_access})); \n  oh_mux3 #(.DW(PW)) \n mux3(.out (etx_mux[PW-1:0]),.in0 (txwr_packet[PW-1:0]),.sel0 (txwr_grant),.in1 (txrd_packet[PW-1:0]),.sel1 (txrd_grant),.in2 (txrr_packet[PW-1:0]),.sel2 (txrr_grant)); \n  assign etx_all_wait = (etx_wait & ~cfg_match) | \n  (etx_cfg_wait & cfg_match); \n  assign txrr_wait = etx_all_wait; \n  assign txwr_wait = etx_all_wait | \n  txrr_access; \n  assign txrd_wait = etx_all_wait | \n  txrr_access | \n  txwr_access; \n  assign access_in = txwr_grant | \n  txrd_grant | \n  txrr_grant; \n  packet2emesh #(.AW(AW)) \n p2e (.write_in (),.datamode_in (),.ctrlmode_in (),.dstaddr_in (dstaddr_mux[31:0]),.srcaddr_in (),.data_in (),.packet_in (etx_mux[PW-1:0])); \n  assign cfg_match = (dstaddr_mux[31:20]==ID); \n  always @ (posedge clk) \n  if (!nreset) \n  etx_access <= 1'b0; \n  else if (~etx_wait) \n  etx_access <= access_in & ~cfg_match; \n  always @ (posedge clk) \n  if (!nreset) \n  cfg_access <= 1'b0; \n  else if (~etx_cfg_wait) \n  cfg_access <= (txwr_grant | txrd_grant) & cfg_match; \n  always @ (posedge clk) \n  if (access_in & ~etx_all_wait) \n  etx_packet[PW-1:0] <= etx_mux[PW-1:0]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a Register File that includes 32 32-bit registers. The module provides the functionality to read from and write to these registers. It includes logic for register reading and writing based on clock and reset signals. The ReadData1 and ReadData2 outputs provide the data from the specified registers, and the RegWrite input enables writing to the specified register. The module also implements voter registers to handle the writing process, along with voter signals for reading and writing data from and to the registers.\n\n Module header:\n\nmodule RegisterFile(input clock,input reset,input [4:0] ReadReg1, ReadReg2, WriteReg,input [31:0] WriteData,input RegWrite,output [31:0] ReadData1, ReadData2,input [991:0] registers_in,output [991:0] registers_out);\n [/INST]\n", "output": "wire [31:0] registers [1:31]; \n  reg [31:0] vote_registers [1:31]; \n  integer i; \n  always @(posedge clock) begin \n  for (i=1; i<32; i=i+1) begin \n  vote_registers[i] <= (reset) ? 0 : (RegWrite && (WriteReg==i)) ? WriteData : registers[i]; \n  end \n  end \n  genvar j; \n  generate \n  for (j=1; j<32; j=j+1) begin : Voter_Signals \n  assign registers[j] = registers_in[((32*j)-1):(32*(j-1))]; \n  assign registers_out[((32*j)-1):(32*(j-1))] = vote_registers[j]; \n  end \n  endgenerate \n  assign ReadData1 = (ReadReg1 == 0) ? 32'h00000000 : registers[ReadReg1]; \n  assign ReadData2 = (ReadReg2 == 0) ? 32'h00000000 : registers[ReadReg2]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a patch for the GE interface. It takes clock signals, enables, and various interfaces as inputs and outputs. The module includes a clock generation module for a Phase Locked Loop (PLL) and an input/output buffer for the MDIO interface. The module also has a timer for the GE enable signal and logic to select the GMII transmit clock based on the GE enable signal. The patch is designed to control the GE enable signal based on the input clock and interface signals.\n\n Module header:\n\nmodule GE_patch (SYS_CLK,GMII_TXCLK,GMII_GTXCLK,GMII_GE_IND,ENET0_GMII_TX_CLK,ENET0_MDIO_I,ENET0_MDIO_O,ENET0_MDIO_T,GMII_MDIO);\n [/INST]\n", "output": "input SYS_CLK; \n  input GMII_TXCLK; \n  output GMII_GTXCLK; \n  input GMII_GE_IND; \n  output ENET0_GMII_TX_CLK; \n  output ENET0_MDIO_I; \n  input ENET0_MDIO_O; \n  input ENET0_MDIO_T; \n  inout GMII_MDIO; \n  wire clk_125M; \n  wire pll_locked; \n  wire pll_reset; \n  reg GMII_GE_IND_reg; \n  reg[27:0] GMII_GE_TIMER; \n clk_wiz_0 pll \n (.clk_in1(SYS_CLK),.clk_out1(clk_125M)); \n IOBUF GMII_MDIO_BUF \n (.I(ENET0_MDIO_O),.IO(GMII_MDIO),.O(ENET0_MDIO_I),.T(ENET0_MDIO_T)); \n always @ (posedge clk_125M) \n begin \n  if ( GMII_GE_IND==1'b1 ) begin \n  GMII_GE_IND_reg <= 1'b1; \n  GMII_GE_TIMER <= 28'h0000000; \n  end \n  else begin \n  if ( GMII_GE_TIMER==28'hffffff ) GMII_GE_IND_reg <= 1'b0; \n  else GMII_GE_TIMER <= GMII_GE_TIMER+1'b1; \n  end \n end \n assign GMII_GTXCLK = clk_125M; \n assign ENET0_GMII_TX_CLK = (GMII_GE_IND_reg==1'b1)? clk_125M:GMII_TXCLK; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module v80ac84 is a top-level module with 2 input wires, vee8a83 and v03aaf0, and an output wire v67a3fc of width 2 bits. Inside the module, there is an instance of another module v80ac84_v9a2a06, which takes w0, w1, and w2 as inputs. The input wires vee8a83 and v03aaf0 are connected to w0 and w1, respectively. The output wire v67a3fc is connected to w2. This module essentially acts as a connector between the inputs vee8a83 and v03aaf0 and the output v67a3fc, by passing them through the internal wire w0, w1, and w2 to the instantiated module v80ac84_v9a2a06.\n\n Module header:\n\nmodule v80ac84 (input vee8a83,input v03aaf0,output [1:0] v67a3fc);\n [/INST]\n", "output": "wire w0; \n  wire w1; \n  wire [0:1] w2; \n  assign w0 = vee8a83; \n  assign w1 = v03aaf0; \n  assign v67a3fc = w2; \n v80ac84_v9a2a06 v9a2a06 (.i1(w0),.i0(w1),.o(w2)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module performs a 4-bit addition by taking two sets of 4-bit input data and producing a 4-bit result along with a carry-out bit. The addition operation is executed using concatenation and addition of the input data, with the result and carry-out being assigned to the specified output ports.\n\n Module header:\n\nmodule ADD4(DataA0, DataA1, DataA2, DataA3,DataB0, DataB1, DataB2, DataB3,Result0, Result1, Result2, Result3, Cout);\n [/INST]\n", "output": "input DataA0, DataA1, DataA2, DataA3; \n input DataB0, DataB1, DataB2, DataB3; \n output Result0, Result1, Result2, Result3, Cout; \n assign {Cout, Result3, Result2, Result1, Result0} = {DataA3, DataA2, DataA1, DataA0} + {DataB3, DataB2, DataB1, DataB0}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `alu` is an arithmetic logic unit (ALU) that performs operations on two 16-bit inputs x and y based on control signals zx, nx, zy, ny, f, and no. It includes registers for x, y, and the ALU output, as well as registers for zr (zero) and ng (negative) flags.\n\nThe module first processes the input signals based on the control signals zx, nx, zy, and ny to prepare the inputs for the ALU operation. Then, based on the control signal f, it either performs addition or bitwise AND operation on the processed inputs. Additionally, if the control signal no is asserted, the module performs bitwise inversion on the output.\n\nThe module also sets the zr flag if the output is zero and the ng flag based on the most significant bit of the output.\n\nThe final output \"out\" is the result of the ALU operation, \"zr\" indicates if the output is zero, and \"ng\" indicates if the output is negative.\n\n Module header:\n\nmodule alu (input [15:0] x,input [15:0] y,input zx, nx, zy, ny, f, no,output [15:0] out,output zr,output ng);\n [/INST]\n", "output": "reg [15:0] r_x_a; \n  reg [15:0] r_x; \n  reg [15:0] r_y_a; \n  reg [15:0] r_y; \n  reg [15:0] r_out = 16'b0; \n  reg r_zr; \n  reg r_ng; \n  always @ (*) begin \n  if (zx == 1) begin \n  r_x_a = 16'b0; \n  end else begin \n  r_x_a = x; \n  end \n  if (nx == 1) begin \n  r_x = ~r_x_a; \n  end else begin \n  r_x = r_x_a; \n  end \n  if (zy) begin \n  r_y_a = 1'b0; \n  end else begin \n  r_y_a = y; \n  end \n  if (ny == 1) begin \n  r_y = ~r_y_a; \n  end else begin \n  r_y = r_y_a; \n  end \n  if (f == 1) begin \n  r_out = r_x + r_y; \n  end else begin \n  r_out = r_x & r_y; \n  end \n  if (no == 1) begin \n  r_out = ~r_out; \n  end else begin \n  r_out = r_out; \n  end \n  if (r_out == 0) begin \n  r_zr = 1'b1; \n  end else begin \n  r_zr = 1'b0; \n  end \n  if (r_out[15] == 1) begin \n  r_ng = 1'b1; \n  end else begin \n  r_ng = 1'b0; \n  end \n  end \n  assign out = r_out; \n  assign zr = r_zr; \n  assign ng = r_ng; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module acts as a bus level shifter with LVDS (Low Voltage Differential Signaling) outputs. It takes in a data signal, output enable, and two differential input signals. The output enable controls the bus output, and the input data is shifted and inverted to generate the positive and negative LVDS outputs. The module also includes buffers and differentiators for signal processing.\n\n Module header:\n\nmodule buslvds(doutp,oe,din,p,n);\n [/INST]\n", "output": "input wire doutp; \n input wire oe; \n output wire din; \n inout wire p; \n inout wire n; \n wire oebout; \n wire oeout; \n wire [0:0] SYNTHESIZED_WIRE_0; \n wire SYNTHESIZED_WIRE_1; \n wire SYNTHESIZED_WIRE_2; \n wire SYNTHESIZED_WIRE_3; \n pdo b2v_inst(.i(doutp),.oein(oe),.o(SYNTHESIZED_WIRE_2),.obar(SYNTHESIZED_WIRE_3),.oebout(oebout),.oeout(oeout)); \n assign din = SYNTHESIZED_WIRE_0 & SYNTHESIZED_WIRE_1; \n assign SYNTHESIZED_WIRE_1 = ~oe; \n twentynm_io_obuf b2v_inst3(.i(SYNTHESIZED_WIRE_2),.oe(oeout),.o(p),.obar()); \n twentynm_io_obuf b2v_inst4(.i(SYNTHESIZED_WIRE_3),.oe(oebout),.o(n),.obar()); \n diffin b2v_inst5(.datain(p),.datain_b(n),.dataout(SYNTHESIZED_WIRE_0)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an address decoder that takes a 5-bit input address and produces a 16-bit output based on the input. The output is updated on the positive edge of the clock signal. The output value is determined by a case statement that assigns different 16-bit values based on the input address. If the input address does not match any specified cases, the output is set to 0.\n\n Module header:\n\nmodule D2_32101(addr, out, clk);\n [/INST]\n", "output": "input clk; \n  output [15:0] out; \n  reg [15:0] out, out2, out3; \n  input [4:0] addr; \n  always @(posedge clk) begin \n  out2 <= out3; \n  out <= out2; \n  case(addr) \n  0: out3 <= 16'h4000; \n  1: out3 <= 16'h3fb1; \n  2: out3 <= 16'h3ec5; \n  3: out3 <= 16'h3d3f; \n  4: out3 <= 16'h3b21; \n  5: out3 <= 16'h3871; \n  6: out3 <= 16'h3537; \n  7: out3 <= 16'h3179; \n  8: out3 <= 16'h2d41; \n  9: out3 <= 16'h289a; \n  10: out3 <= 16'h238e; \n  11: out3 <= 16'h1e2b; \n  12: out3 <= 16'h187e; \n  13: out3 <= 16'h1294; \n  14: out3 <= 16'hc7c; \n  15: out3 <= 16'h646; \n  16: out3 <= 16'h0; \n  17: out3 <= 16'hf9ba; \n  18: out3 <= 16'hf384; \n  19: out3 <= 16'hed6c; \n  20: out3 <= 16'he782; \n  21: out3 <= 16'he1d5; \n  22: out3 <= 16'hdc72; \n  23: out3 <= 16'hd766; \n  24: out3 <= 16'hd2bf; \n  25: out3 <= 16'hce87; \n  26: out3 <= 16'hcac9; \n  27: out3 <= 16'hc78f; \n  28: out3 <= 16'hc4df; \n  29: out3 <= 16'hc2c1; \n  30: out3 <= 16'hc13b; \n  31: out3 <= 16'hc04f; \n  default: out3 <= 0; \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module simulates a Direct Memory Access (DMA) controller. It initializes and toggles various control signals like reset, clock, command register write/read, and others. It also toggles the clock signal every 5 units of time. Additionally, it sets the simulation variables and ends the DMA test after a specified time, displaying a message and finishing the module.\n\n Module header:\n\nmodule probador_dma(output reg reset,output reg clk,output reg TFC,output reg cmd_reg_write,output reg cmd_reg_read,output reg Continue,output reg TRAN,output reg STOP,output reg empty,output reg full,output reg [63:0] data_address,output reg [15:0] length,output reg [5:0] descriptor_index,output reg act1,output reg act2,output reg END,output reg valid,output reg dir);\n [/INST]\n", "output": "always begin \n  #5 clk =! clk; \n end \n initial begin \n  $dumpfile(\"testDMA.vcd\"); \n  $dumpvars(0,probador_dma); \n  reset = 1; \n  clk = 0; \n  TFC = 0; \n  cmd_reg_write = 0; \n  cmd_reg_read = 0; \n  Continue = 0; \n  TRAN = 0; \n  STOP = 0; \n  empty = 1; \n  full = 0; \n  data_address = 0; \n  length = 10; \n  descriptor_index = 0; \n  act1 = 0; \n  act2 = 1; \n  END = 1; \n  valid = 1; \n  dir = 1; \n  #50 \n  reset = 0; \n  #50 \n  cmd_reg_write = 1; \n  $display(\"Fin del DMA test\"); \n  $finish(2); \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module is a synchronizer that takes in an input Q_reg_reg[3]_0 and m_aclk, and outputs D and out. It contains asynchronous registers to capture and synchronize the input data using FDCE components. The module utilizes LUT components to generate the output D based on the synchronized input Q_reg. The synchronization process is intended to ensure that the output is properly aligned with the clock signal m_aclk.\n\n Module header:\n\nmodule system_auto_cc_0_synchronizer_ff__parameterized4_25 (out,D,\\Q_reg_reg[3]_0 ,m_aclk,\\ngwrdrst.grst.g7serrst.rd_rst_reg_reg[1] );\n [/INST]\n", "output": "output [3:0]out; \n  output [0:0]D; \n  input [3:0]\\Q_reg_reg[3]_0 ; \n  input m_aclk; \n  input [0:0]\\ngwrdrst.grst.g7serrst.rd_rst_reg_reg[1] ; \n  wire [0:0]D; \n  (* async_reg = \"true\" *) (* msgon = \"true\" *) wire [3:0]Q_reg; \n  wire [3:0]\\Q_reg_reg[3]_0 ; \n  wire m_aclk; \n  wire [0:0]\\ngwrdrst.grst.g7serrst.rd_rst_reg_reg[1] ; \n  assign out[3:0] = Q_reg; \n  (* ASYNC_REG *) \n  (* KEEP = \"yes\" *) \n  (* msgon = \"true\" *) \n FDCE #(.INIT(1'b0)) \n  \\Q_reg_reg[0] \n (.C(m_aclk),.CE(1'b1),.CLR(\\ngwrdrst.grst.g7serrst.rd_rst_reg_reg[1] ),.D(\\Q_reg_reg[3]_0 [0]),.Q(Q_reg[0])); \n  (* ASYNC_REG *) \n  (* KEEP = \"yes\" *) \n  (* msgon = \"true\" *) \n FDCE #(.INIT(1'b0)) \n  \\Q_reg_reg[1] \n (.C(m_aclk),.CE(1'b1),.CLR(\\ngwrdrst.grst.g7serrst.rd_rst_reg_reg[1] ),.D(\\Q_reg_reg[3]_0 [1]),.Q(Q_reg[1])); \n  (* ASYNC_REG *) \n  (* KEEP = \"yes\" *) \n  (* msgon = \"true\" *) \n FDCE #(.INIT(1'b0)) \n  \\Q_reg_reg[2] \n (.C(m_aclk),.CE(1'b1),.CLR(\\ngwrdrst.grst.g7serrst.rd_rst_reg_reg[1] ),.D(\\Q_reg_reg[3]_0 [2]),.Q(Q_reg[2])); \n  (* ASYNC_REG *) \n  (* KEEP = \"yes\" *) \n  (* msgon = \"true\" *) \n FDCE #(.INIT(1'b0)) \n  \\Q_reg_reg[3] \n (.C(m_aclk),.CE(1'b1),.CLR(\\ngwrdrst.grst.g7serrst.rd_rst_reg_reg[1] ),.D(\\Q_reg_reg[3]_0 [3]),.Q(Q_reg[3])); \n LUT2 #(.INIT(4'h6)) \n  \\gnxpm_cdc.wr_pntr_bin[2]_i_1__0 \n (.I0(Q_reg[2]),.I1(Q_reg[3]),.O(D)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes two inputs, a and b, and performs a bitwise OR operation on them. The result is assigned to the output y after a delay of 1 time unit.\n\n Module header:\n\nmodule th12_ref (y,a,b);\n [/INST]\n", "output": "output y; \n  input a; \n  input b; \n  assign #1 y = a | b; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a D flip-flop with a reset (clr) and an enable (en) input. The output q is updated on the positive clock edge, and is reset to 0 when clr is asserted. Additionally, when en is asserted and clr is not asserted, q takes on the value of the input d.\n\n Module header:\n\nmodule my_dffre_p (input d,clk,clr,en,output reg q);\n [/INST]\n", "output": "always @(posedge clk or posedge clr) \n  if (clr) q <= 1'b0; \n  else if (en) q <= d; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a full adder circuit. It takes three inputs IN0, IN1, and CIN, and produces two outputs COUT and SUM. The SUM output is the result of a bitwise XOR operation on the inputs and the carry-in (CIN). The COUT output is the result of a carry logic expression involving the inputs and the carry-in.\n\n Module header:\n\nmodule FADDER (IN0,IN1,CIN,COUT,SUM);\n [/INST]\n", "output": "input IN0, IN1, CIN; \n  output COUT, SUM; \n  assign SUM = IN0^IN1^CIN; \n  assign COUT = ((CIN&IN0)|(CIN&IN1)|(IN0&IN1)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module MULFILTER takes in inputs BWD, FLOAT, SRC1, and SRC2, and outputs DEST1 and DEST2. It uses sign1 and sign2 wires to determine the sign of the inputs SRC1 and SRC2. The module then updates DEST1 and DEST2 based on the input conditions using a case statement. The output DEST1 is determined based on the values of FLOAT, BWD, and sign1, while DEST2 is determined based on FLOAT, BWD, and sign2. The module effectively performs conditional assignments to DEST1 and DEST2 based on the input conditions.\n\n Module header:\n\nmodule MULFILTER (BWD, FLOAT, SRC1, SRC2, DEST1, DEST2);\n [/INST]\n", "output": "input [1:0] BWD; \n  input FLOAT; \n  input [31:0] SRC1,SRC2; \n  output [31:0] DEST1,DEST2; \n  wire sign1,sign2; \n  reg [31:0] DEST1,DEST2; \n  assign sign1 = BWD[0] ? SRC1[15] : SRC1[7]; \n  always @(FLOAT or BWD or SRC1 or sign1) \n  casex ({FLOAT,BWD,sign1}) \n  4'b0_00_0 : DEST1 = {24'h000000, SRC1[7:0]}; \n  4'b0_00_1 : DEST1 = {24'hFFFFFF, SRC1[7:0]}; \n  4'b0_01_0 : DEST1 = { 16'h0000,SRC1[15:0]}; \n  4'b0_01_1 : DEST1 = { 16'hFFFF,SRC1[15:0]}; \n  4'b1_xx_x : DEST1 = { 9'h001,SRC1[22:0]}; \n  default : DEST1 = SRC1; \n  endcase \n  assign sign2 = BWD[0] ? SRC2[15] : SRC2[7]; \n  always @(FLOAT or BWD or SRC2 or sign2) \n  casex ({FLOAT,BWD,sign2}) \n  4'b0_00_0 : DEST2 = {24'h000000, SRC2[7:0]}; \n  4'b0_00_1 : DEST2 = {24'hFFFFFF, SRC2[7:0]}; \n  4'b0_01_0 : DEST2 = { 16'h0000,SRC2[15:0]}; \n  4'b0_01_1 : DEST2 = { 16'hFFFF,SRC2[15:0]}; \n  4'b1_xx_x : DEST2 = { 9'h001,SRC2[22:0]}; \n  default : DEST2 = SRC2; \n  endcase \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an up counter with a clock monitor. It consists of two clock domains, \"up_clk\" and \"d_clk\". The module monitors \"up_clk\" and generates \"up_d_count\" based on the input signals. It also monitors \"d_clk\" and controls the count and toggle logic. The module includes reset logic for both clock domains and toggles between counts based on the clock signals.\n\n Module header:\n\nmodule up_clock_mon (up_rstn,up_clk,up_d_count,d_rst,d_clk);\n [/INST]\n", "output": "input up_rstn; \n  input up_clk; \n  output [31:0] up_d_count; \n  input d_rst; \n  input d_clk; \n  reg [15:0] up_count = 'd0; \n  reg up_count_toggle = 'd0; \n  reg up_count_toggle_m1 = 'd0; \n  reg up_count_toggle_m2 = 'd0; \n  reg up_count_toggle_m3 = 'd0; \n  reg [31:0] up_d_count = 'd0; \n  reg d_count_toggle_m1 = 'd0; \n  reg d_count_toggle_m2 = 'd0; \n  reg d_count_toggle_m3 = 'd0; \n  reg d_count_toggle = 'd0; \n  reg [31:0] d_count_hold = 'd0; \n  reg [32:0] d_count = 'd0; \n  wire up_count_toggle_s; \n  wire d_count_toggle_s; \n  assign up_count_toggle_s = up_count_toggle_m3 ^ up_count_toggle_m2; \n  always @(negedge up_rstn or posedge up_clk) begin \n  if (up_rstn == 0) begin \n  up_count <= 'd0; \n  up_count_toggle <= 'd0; \n  up_count_toggle_m1 <= 'd0; \n  up_count_toggle_m2 <= 'd0; \n  up_count_toggle_m3 <= 'd0; \n  up_d_count <= 'd0; \n  end else begin \n  up_count <= up_count + 1'b1; \n  if (up_count == 16'd0) begin \n  up_count_toggle <= ~up_count_toggle; \n  end \n  up_count_toggle_m1 <= d_count_toggle; \n  up_count_toggle_m2 <= up_count_toggle_m1; \n  up_count_toggle_m3 <= up_count_toggle_m2; \n  if (up_count_toggle_s == 1'b1) begin \n  up_d_count <= d_count_hold; \n  end \n  end \n  end \n  assign d_count_toggle_s = d_count_toggle_m3 ^ d_count_toggle_m2; \n  always @(posedge d_clk) begin \n  if (d_rst == 1'b1) begin \n  d_count_toggle_m1 <= 'd0; \n  d_count_toggle_m2 <= 'd0; \n  d_count_toggle_m3 <= 'd0; \n  end else begin \n  d_count_toggle_m1 <= up_count_toggle; \n  d_count_toggle_m2 <= d_count_toggle_m1; \n  d_count_toggle_m3 <= d_count_toggle_m2; \n  end \n  end \n  always @(posedge d_clk) begin \n  if (d_count_toggle_s == 1'b1) begin \n  d_count_toggle <= ~d_count_toggle; \n  d_count_hold <= d_count[31:0]; \n  end \n  if (d_count_toggle_s == 1'b1) begin \n  d_count <= 33'd1; \n  end else if (d_count[32] == 1'b0) begin \n  d_count <= d_count + 1'b1; \n  end else begin \n  d_count <= {33{1'b1}}; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a frequency analyzer with synchronization. It uses a clock signal and control signals for starting and stopping the analyzer. It counts the clock ticks and generates start and stop signals for two separate analyzers based on the frequency of the input clock. The module includes logic for reset and enable signals to control the behavior of the analyzers. The start and stop signals for each analyzer are generated based on specific conditions related to the clock counter, signal delay, and frequency ticks.\n\n Module header:\n\nmodule frequency_analyzer_synch # (parameter integer CLOCK = 100000000,parameter integer FREQUENCY = 2000) (input wire clock,input wire reset,input wire enable,output reg start_analyzer_0,output reg stop_analyzer_0,output reg start_analyzer_1,output reg stop_analyzer_1);\n [/INST]\n", "output": "localparam integer frequency_ticks = CLOCK / FREQUENCY; \n  localparam integer signal_delay = 40; \n  integer clock_counter; \n  always @(posedge clock) \n  begin \n  if(!reset) \n  clock_counter <= 0; \n  else if(enable) \n  begin \n  clock_counter <= clock_counter + 1; \n  if(clock_counter >= frequency_ticks + frequency_ticks + signal_delay) \n  clock_counter <= 0; \n  end \n  end \n  always @(posedge clock) \n  begin \n  if(!reset) \n  begin \n  start_analyzer_0 <= 0; \n  stop_analyzer_0 <= 0; \n  start_analyzer_1 <= 0; \n  stop_analyzer_1 <= 0; \n  end \n  else if(enable) \n  begin \n  if(clock_counter < signal_delay) \n  begin \n  start_analyzer_0 <= 1; \n  stop_analyzer_0 <= 0; \n  start_analyzer_1 <= 0; \n  stop_analyzer_1 <= 0; \n  end \n  else if(clock_counter >= signal_delay && clock_counter < frequency_ticks) \n  begin \n  start_analyzer_0 <= 0; \n  stop_analyzer_0 <= 0; \n  start_analyzer_1 <= 0; \n  stop_analyzer_1 <= 0; \n  end \n  else if(clock_counter >= frequency_ticks && clock_counter < frequency_ticks + signal_delay) \n  begin \n  start_analyzer_0 <= 0; \n  stop_analyzer_0 <= 1; \n  start_analyzer_1 <= 1; \n  stop_analyzer_1 <= 0; \n  end \n  else if(clock_counter >= frequency_ticks + signal_delay && clock_counter < frequency_ticks + frequency_ticks) \n  begin \n  start_analyzer_0 <= 0; \n  stop_analyzer_0 <= 0; \n  start_analyzer_1 <= 0; \n  stop_analyzer_1 <= 0; \n  end \n  else if(clock_counter >= frequency_ticks + frequency_ticks) \n  begin \n  start_analyzer_0 <= 1; \n  stop_analyzer_0 <= 0; \n  start_analyzer_1 <= 0; \n  stop_analyzer_1 <= 1; \n  end \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a Register File (RF) with multiple functionality. It has inputs Data_in, Select, Acc_in, RF_we, Acc_we, and RF_clk, and outputs Data_out, Acc_out, FG_pair, b_out, a_out, and dat_out. The module contains registers for Data_out, Acc, B, C, D, E, F, and G, with the initial values set in the initial block.\n\nThe module updates the registers based on the Select input and RF_we, and updates the Accumulator based on Acc_we. The Data_out output is determined based on the Select input and the values of the registers. The outputs Acc_out, FG_pair, b_out, a_out, and dat_out are assigned based on the values of the corresponding registers.\n\n Module header:\n\nmodule RF(Data_in,Select,Acc_in,Data_out,Acc_out,RF_we,Acc_we,RF_clk,FG_pair,b_out,a_out,dat_out);\n [/INST]\n", "output": "input[7:0] Data_in; \n  input[2:0] Select; \n  input[7:0] Acc_in; \n  output[7:0] Data_out; \n  output[7:0] Acc_out; \n  output[15:0] FG_pair; \n  input RF_we; \n  input Acc_we; \n  input RF_clk; \n  output[7:0] b_out,a_out,dat_out; \n  reg[7:0] Data_out; \n  reg[7:0] Acc,B,C,D,E,F,G; \n  initial \n  begin \n  Acc <= 8'h49; \n  B <= 8'h06; \n  C <= 8'h06; \n  end \n  always @(posedge RF_clk) \n  begin \n  case(Select) \n  3'b000: Acc <= (RF_we ? Data_in: Acc); \n  3'b001: B <= (RF_we ? Data_in: B); \n  3'b010: C <= (RF_we ? Data_in: C); \n  3'b011: D <= (RF_we ? Data_in: D); \n  3'b100: E <= (RF_we ? Data_in: E); \n  3'b101: F <= (RF_we ? Data_in: F); \n  3'b110: G <= (RF_we ? Data_in: G); \n  endcase \n  if (Select != 3'b000) \n  Acc <= Acc_we ? Acc_in : Acc; \n  end \n  always @(Select or Acc or B or C or D or E or F or G) \n  begin \n  case (Select) \n  3'b000: Data_out <= Acc; \n  3'b001: Data_out <= B; \n  3'b010: Data_out <= C; \n  3'b011: Data_out <= D; \n  3'b100: Data_out <= E; \n  3'b101: Data_out <= F; \n  3'b110: Data_out <= G; \n  endcase \n  end \n  assign Acc_out = Acc; \n  assign FG_pair = {F,G}; \n  assign b_out = B; \n  assign a_out = Acc; \n  assign dat_out = Data_out; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module consists of an input vector vaf45b8 and an output vcbab45. It also includes internal wires w0, w1, w2, w3, w4, and w5. The output vcbab45 is assigned the value of wire w0. The vector vaf45b8 is assigned to wire w1. Additionally, there are two instantiated modules, vc4f23a and vf49321, which are connected to the internal wires. These instantiated modules use the input and output wires to perform their respective functionalities.\n\n Module header:\n\nmodule vf61fa3 (input [3:0] vaf45b8,output vcbab45);\n [/INST]\n", "output": "wire w0; \n  wire [0:3] w1; \n  wire w2; \n  wire w3; \n  wire w4; \n  wire w5; \n  assign vcbab45 = w0; \n  assign w1 = vaf45b8; \n vc4f23a v5f4674 (.v985fcb(w1),.v4f1fd3(w2),.vda577d(w3),.v3f8943(w4),.v64d863(w5)); \n vf49321 vea932e (.vcbab45(w0),.ve86251(w2),.v0e28cb(w3),.v3ca442(w4),.v8b2684(w5)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module calculates the number of wait cycles based on the input rnum. It uses a series of conditional checks on the value of n (derived from rnum) to determine the appropriate number of wait cycles. The result is stored in the output nr_wait_cycle.\n\n Module header:\n\nmodule calc_nr_wait_cycle(rnum, nr_wait_cycle);\n [/INST]\n", "output": "input [31:0] rnum; \n output reg [7:0] nr_wait_cycle; \n always @(rnum) begin :body \n  reg [7:0] n; \n  n = rnum[7:0]; \n  if (n >= 64) begin \n  nr_wait_cycle = 0; \n  end else if (n >= 32) begin \n  nr_wait_cycle = 1; \n  end else if (n >= 16) begin \n  nr_wait_cycle = 2; \n  end else if (n >= 8) begin \n  nr_wait_cycle = 3; \n  end else if (n >= 4) begin \n  nr_wait_cycle = 4; \n  end else if (n >= 2) begin \n  nr_wait_cycle = 5; \n  end else if (n >= 1) begin \n  nr_wait_cycle = 6; \n  end else begin \n  nr_wait_cycle = rnum[15:8]; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements self-healing functionality for a 4-bit deserializer. It utilizes a clock signal, error signal, and reset signals to perform self-healing. The module utilizes a register to store the self-healing signal and a separate register to output the self-healing result. The self-healing process is controlled by the clock signal and reset signals, and it involves error checking and correction.\n\n Module header:\n\nmodule selfheal_oserdese1_vlog (dq3, dq2, dq1, dq0,CLKDIV, srint, rst,SHO);\n [/INST]\n", "output": "input dq3, dq2, dq1, dq0; \n input CLKDIV, srint, rst; \n output SHO; \n reg shr; \n reg SHO; \n wire clkint; \n wire error; \n wire rst_in, rst_self_heal; \n wire [4:0] SELFHEAL; \n assign SELFHEAL = 5'b00000; \n parameter FFD = 10; \n parameter FFCD = 10; \n parameter MXD = 10; \n parameter MXR1 = 10; \n assign clkint = CLKDIV & SELFHEAL[4]; \n assign error = (((~SELFHEAL[4] ^ SELFHEAL[3]) ^ dq3) | ((~SELFHEAL[4] ^ SELFHEAL[2]) ^ dq2) | ((~SELFHEAL[4] ^ SELFHEAL[1]) ^ dq1) | ((~SELFHEAL[4] ^ SELFHEAL[0]) ^ dq0)); \n assign rst_in = (~SELFHEAL[4] | ~srint); \n assign rst_self_heal = (rst | ~shr); \n always @ (posedge clkint or posedge rst) \n begin \n  begin \n  if (rst) \n  begin \n  shr <= # FFD 1'b0; \n  end \n  else begin \n  shr <= #FFD rst_in; \n  end \n  end \n end \n always @ (posedge clkint or posedge rst_self_heal) \n begin \n  begin \n  if (rst_self_heal) \n  begin \n  SHO <= 1'b0; \n  end \n  else \n  begin \n  SHO <= # FFD error; \n  end \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a set of buffers for the signals mem_write_disable, sehold, se, and arst_l. It simply assigns each input signal to its corresponding output signal, providing isolation and buffering for each signal. The purpose of this module is to ensure that the signals are properly buffered and isolated from each other.\n\n Module header:\n\nmodule scbuf_slowsig_buf (mem_write_disable_buf,sehold_buf,se_buf,arst_l_buf,mem_write_disable,sehold,se,arst_l);\n [/INST]\n", "output": "output mem_write_disable_buf; \n output sehold_buf; \n output se_buf; \n output arst_l_buf; \n input mem_write_disable; \n input sehold; \n input se; \n input arst_l; \n assign mem_write_disable_buf = mem_write_disable; \n assign sehold_buf = sehold; \n assign se_buf = se; \n assign arst_l_buf = arst_l; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a VGA test module for displaying graphics on a VGA monitor. It takes inputs for clock, reset, switch settings, and grid cell values and outputs signals for horizontal and vertical synchronization as well as RGB color signals. \n\nThe module contains internal pixel coordinates and a control unit for managing the VGA display. It also has a graphics display unit for rendering the actual graphics. Additionally, it includes a clock generator to generate a 25 MHz clock.\n\n Module header:\n\nmodule VGA_test(input wire clk , reset,input wire [3:0] sw,input wire [1:0] casilla1, casilla2, casilla3, casilla4, casilla5, casilla6, casilla7, casilla8, casilla9,output wire hsync,vsync,output wire [2:0] rgb);\n [/INST]\n", "output": "wire[10:0] pix_x, pix_y; \n  wire video_on; \n  wire clkout; \n  wire hsync_out; \n  wire vsync_out; \n  assign hsync = ~hsync_out; \n  assign vsync = ~vsync_out; \n VGA_Controlador vsync_unit (._clk_(clkout),._reset_(reset),.hsync(hsync_out),.vsync(vsync_out),.PixelX(pix_x),.PixelY(pix_y),.video_encendido(video_on)); \n figuras_Gato graficos(.video_mostrar(video_on),.selector_entrada(sw),.c1_in(casilla1),.c2_in(casilla2),.c3_in(casilla3),.c4_in(casilla4),.c5_in(casilla5),.c6_in(casilla6),.c7_in(casilla7),.c8_in(casilla8),.c9_in(casilla9),.pixel_x(pix_x),.pixel_y(pix_y),.salida_rgb(rgb)); \n  CLK_25Mhz clock25 (.CLK_IN(clk), .CLK_OUT(clkout)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module is a read pointer that interfaces with a FIFO. It includes signals for clock, reset, read, and FIFO empty. The read pointer and FIFO read signals are computed based on the FIFO empty and read signals. The read pointer is updated on the positive clock edge and reset edge. The module contains stimulus blocks to simulate the read and reset signals, and the clock signal is generated by inverting its value in a loop. The read data, FIFO empty flag, and reset signal are set at different time points to simulate different scenarios.\n\n Module header:\n\nmodule read_pointerTBV ();\n [/INST]\n", "output": "reg clk = 0; \n reg rst_n = 0; \n reg rd = 0; \n reg fifo_empty = 0; \n wire [4:0] rptr; \n wire fifo_rd; \n wire read_pointer0_0_fifo_rd_i; \n reg [4:0] read_pointer0_0_rptr_i = 0; \n always @(rd, fifo_rd, fifo_empty, rst_n, rptr, clk) begin: READ_POINTERTBV_PRINT_DATA \n  $write(\"%h\", rd); \n  $write(\" \"); \n  $write(\"%h\", fifo_empty); \n  $write(\" \"); \n  $write(\"%h\", rptr); \n  $write(\" \"); \n  $write(\"%h\", fifo_rd); \n  $write(\" \"); \n  $write(\"%h\", clk); \n  $write(\" \"); \n  $write(\"%h\", rst_n); \n  $write(\"\\n\"); \n end \n assign read_pointer0_0_fifo_rd_i = ((!fifo_empty) && rd); \n always @(posedge clk, negedge rst_n) begin: READ_POINTERTBV_READ_POINTER0_0_POINTERUPDATE \n  if (rst_n) begin \n  read_pointer0_0_rptr_i <= 0; \n  end \n  else if (read_pointer0_0_fifo_rd_i) begin \n  read_pointer0_0_rptr_i <= (read_pointer0_0_rptr_i + 1); \n  end \n  else begin \n  read_pointer0_0_rptr_i <= read_pointer0_0_rptr_i; \n  end \n end \n assign fifo_rd = read_pointer0_0_fifo_rd_i; \n assign rptr = read_pointer0_0_rptr_i; \n initial begin: READ_POINTERTBV_CLK_SIGNAL \n  while (1'b1) begin \n  clk <= (!clk); \n  # 1; \n  end \n end \n initial begin: READ_POINTERTBV_STIMULES \n  integer i; \n  i = 0; \n  while (1'b1) begin \n  case (i) \n  'h0: begin \n  rd <= 1; \n  end \n  'ha: begin \n  rd <= 0; \n  end \n  'hc: begin \n  rd <= 1; \n  end \n  'he: begin \n  fifo_empty <= 1; \n  end \n  'h10: begin \n  rst_n <= 1; \n  end \n  'h12: begin \n  rst_n <= 0; \n  end \n  'h14: begin \n  $finish; \n  end \n  default: begin \n  end \n  endcase \n  i = i + 1; \n  @(posedge clk); \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a 17-bit MUX with two 17-bit inputs A and B and a single-bit select input S. The output MO is assigned the value of A when S is 0 and the value of B when S is 1.\n\n Module header:\n\nmodule cycloneiiils_b17mux21 (MO, A, B, S);\n [/INST]\n", "output": "input [16:0] A, B; \n  input S; \n  output [16:0] MO; \n  assign MO = (S == 1) ? B : A; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a block memory with configurable data and address width. It supports write and read operations on two different clock domains, clka and clkb. The memory is initialized based on the INC_NUM_PATTERN parameter, which determines whether the memory is populated with incrementing numbers or zeros. On a positive edge of clka, the module writes data to the memory if the write enable signal, wea, is asserted. On a positive edge of clkb, the module reads data from the memory based on the address signal, addrb, and outputs the data on doutb.\n\n Module header:\n\nmodule blk_mem #(parameter DATA_WIDTH = 8,parameter ADDRESS_WIDTH = 4,parameter INC_NUM_PATTERN = 0)(input clka,input wea,input [ADDRESS_WIDTH - 1 :0] addra,input [DATA_WIDTH - 1:0] dina,input clkb,input [ADDRESS_WIDTH - 1:0] addrb,output [DATA_WIDTH - 1:0] doutb);\n [/INST]\n", "output": "reg [DATA_WIDTH - 1:0] mem [0:2 ** ADDRESS_WIDTH]; \n reg [DATA_WIDTH - 1:0] dout; \n assign doutb = dout; \n `ifdef SIMULATION \n integer i; \n initial begin \n  i = 0; \n  for (i = 0; i < (2 ** ADDRESS_WIDTH); i = i + 1) begin \n  if (INC_NUM_PATTERN) begin \n  mem[i] <= i; \n  end \n  else begin \n  mem[i] <= 0; \n  end \n  end \n end \n `endif \n always @ (posedge clka) \n begin \n  if ( wea ) begin \n  mem[addra] <= dina; \n  end \n end \n always @ (posedge clkb) \n begin \n  dout <= mem[addrb]; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module acts as a synchronizer for an LCD display interface. It includes registers for the X and Y coordinates, data, and sync signals. The output signals are driven based on the input signals, and the module keeps track of the X and Y coordinates based on the sync and data enable signals. It also handles the reset conditions for the X, Y, data, and sync signals, ensuring proper initialization. The module essentially manages the synchronization and data flow for the LCD display.\n\n Module header:\n\nmodule lcd_sync (input rst,input [23:0] lcd_data_i,input lcd_pclk_i,input lcd_vsync_i,input lcd_hsync_i,input lcd_de_i,output lcd_clk_o,output [11:0] lcd_x_o,output [11:0] lcd_y_o,output [23:0] lcd_data_o,output lcd_data_valid_o);\n [/INST]\n", "output": "reg [11:0] lcd_x_q; \n reg [11:0] lcd_y_q; \n reg [23:0] lcd_data_q; \n reg lcd_hsync_q; \n reg lcd_vsync_q; \n reg lcd_de_q; \n assign lcd_clk_o = lcd_pclk_i; \n assign lcd_x_o = lcd_x_q; \n assign lcd_y_o = lcd_y_q; \n assign lcd_data_o = lcd_data_q; \n assign lcd_data_valid_o = lcd_de_q; \n wire lcd_hsync_end = (lcd_hsync_i == 0) && (lcd_hsync_q == 1); \n wire lcd_vsync_end = (lcd_vsync_i == 1) && (lcd_vsync_q == 0); \n always @(posedge lcd_pclk_i) begin \n  if (rst) begin \n  lcd_x_q <= 0; \n  lcd_y_q <= 0; \n  lcd_data_q <= 0; \n  lcd_hsync_q <= 0; \n  lcd_vsync_q <= 0; \n  lcd_de_q <= 0; \n  end \n  else begin \n  lcd_hsync_q <= lcd_hsync_i; \n  lcd_vsync_q <= lcd_vsync_i; \n  lcd_de_q <= lcd_de_i; \n  if (lcd_de_i) begin \n  lcd_data_q <= lcd_data_i; \n  end else begin \n  lcd_data_q <= 0; \n  end \n  if (lcd_vsync_end) begin \n  lcd_y_q <= 0; \n  end else begin \n  if (lcd_hsync_end) begin \n  lcd_y_q <= lcd_y_q + 12'h1; \n  end \n  end \n  if (lcd_hsync_end) begin \n  lcd_x_q <= 0; \n  end else begin \n  if (lcd_de_q) begin \n  lcd_x_q <= lcd_x_q + 12'h1; \n  end \n  end \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes in a 16-bit input and reinterprets it as a signed 16-bit input. The output is then forced to be the same as the input. The module is clocked and has control inputs for clearing and enabling the operation.\n\n Module header:\n\nmodule sysgen_reinterpret_af1a0b71e1 (input [(16 - 1):0] input_port,output [(16 - 1):0] output_port,input clk,input ce,input clr);\n [/INST]\n", "output": "wire signed [(16 - 1):0] input_port_1_40; \n  wire [(16 - 1):0] output_port_5_5_force; \n  assign input_port_1_40 = input_port; \n  assign output_port_5_5_force = input_port_1_40; \n  assign output_port = output_port_5_5_force; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a CRC block for a Cyclone IV E FPGA. It takes in a clock signal, shift enable signal, and data signal for loading, and outputs error and register signals. It includes parameters for oscillator divider and LPM type. The module resets the error signal and register output to 0.\n\n Module header:\n\nmodule cycloneive_crcblock (clk,shiftnld,ldsrc,crcerror,regout);\n [/INST]\n", "output": "input clk; \n input shiftnld; \n input ldsrc; \n output crcerror; \n output regout; \n assign crcerror = 1'b0; \n assign regout = 1'b0; \n parameter oscillator_divider = 1; \n parameter lpm_type = \"cycloneive_crcblock\"; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, named HADDER, implements a half adder. It takes two input bits IN0 and IN1, and produces two output bits, SUM and COUT. The SUM output is the result of bitwise XOR operation between the input bits, and the COUT output is the result of bitwise AND operation between the input bits.\n\n Module header:\n\nmodule HADDER (IN0,IN1,SUM,COUT);\n [/INST]\n", "output": "input IN0, IN1; \n  output SUM, COUT; \n  assign SUM = IN0^IN1; \n  assign COUT = IN0&IN1; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module dffrl implements a D flip-flop with reset, scan enable, and scan input. The module has input signals for data input, clock, reset, scan enable, and scan input, as well as output signals for the output q and scan output so. The module includes a register for the output q and uses conditional compilation to handle the scan enable functionality. The output so is assigned the value of q. The module operates to update the q output based on the clock and reset signals, and the scan enable and scan input signals if applicable.\n\n Module header:\n\nmodule dffrl (din, clk, rst_l, q, se, si, so);\n [/INST]\n", "output": "parameter SIZE = 1; \n input [SIZE-1:0] din ; \n input clk ; \n input rst_l ; \n output [SIZE-1:0] q ; \n input se ; \n input [SIZE-1:0] si ; \n output [SIZE-1:0] so ; \n reg [SIZE-1:0] q ; \n `ifdef NO_SCAN \n always @ (posedge clk) \n  q[SIZE-1:0] <= rst_l ? din[SIZE-1:0] : {SIZE{1'b0}}; \n `else \n always @ (posedge clk) \n  q[SIZE-1:0] <= rst_l ? ((se) ? si[SIZE-1:0] : din[SIZE-1:0] ) : {SIZE{1'b0}}; \n assign so[SIZE-1:0] = q[SIZE-1:0] ; \n `endif \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, ctu_test_stub_scan, has several inputs including global_shift_enable, ctu_tst_scan_disable, ctu_tst_short_chain, long_chain_so_0, and short_chain_so_0. It also has outputs se and so_0. The output se is assigned based on the inputs ctu_tst_scan_disable and global_shift_enable. The module also uses a wire short_chain_select, which is assigned based on the input ctu_tst_short_chain. Finally, the output so_0 is assigned based on the short_chain_select wire, choosing between short_chain_so_0 and long_chain_so_0.\n\n Module header:\n\nmodule ctu_test_stub_scan (se, so_0,global_shift_enable, ctu_tst_scan_disable,ctu_tst_short_chain, long_chain_so_0, short_chain_so_0);\n [/INST]\n", "output": "input global_shift_enable; \n  input ctu_tst_scan_disable; \n  input ctu_tst_short_chain; \n  input long_chain_so_0; \n  input short_chain_so_0; \n  output se; \n  output so_0; \n  wire short_chain_select; \n  assign se = ~ctu_tst_scan_disable & global_shift_enable; \n  assign short_chain_select = ctu_tst_short_chain; \n  assign so_0 = short_chain_select ? short_chain_so_0 : long_chain_so_0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a simple counter that increments by 1 on each rising edge of the clk input, provided the ce input is asserted. The most significant bit of the counter is assigned to the output ledalive.\n\n Module header:\n\nmodule ledctr(input clk,input ce,output ledalive);\n [/INST]\n", "output": "reg [9:0] counter = 0; \n  assign ledalive = counter[9]; \n  always @ (posedge clk) begin \n  if(ce) \n  counter <= counter + 1; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a time counter that tracks both seconds and nanoseconds. It takes inputs such as pps_in (pulse per second), clk_in (clock signal), cnt_ena_in (counter enable), and various load and clear signals, and provides outputs for the seconds and nanoseconds. The module includes logic for incrementing the nanoseconds counter, clearing the seconds counter, and loading preset values for both seconds and nanoseconds. It also accounts for the system clock frequency and logic to handle counter clearing and loading.\n\n Module header:\n\nmodule tai_counter(input [63:0] sec_data_in,input [31:0] nanosec_data_in,input pps_in,input clk_in,input cnt_ena_in,input pps_bypass_in,input clr_n_in,input load_sec_in,input load_nanosec_in,output [63:0] sec_data_out,output [31:0] nanosec_data_out);\n [/INST]\n", "output": "reg [63:0] seconds; \n reg [31:0] nanoseconds; \n reg load_sec_l, load_sec_p; \n reg load_nanosec_l, load_nanosec_p; \n wire nano_counter_carry; \n reg nano_counter_clr; \n parameter SYSCLK_FREQ = 32'd100_000_000; \n assign nano_counter_carry = (nanoseconds < SYSCLK_FREQ - 1) ? 1'b0:1'b1; \n always @ (posedge clk_in or negedge clr_n_in) \n begin \n  if (!clr_n_in) begin \n  nano_counter_clr <= 0; \n  end \n  else begin \n  nano_counter_clr <= !(nano_counter_carry); \n  end \n end \n assign sec_data_out = seconds; \n assign nanosec_data_out = nanoseconds; \n always @ (posedge clk_in or negedge clr_n_in) \n begin \n  if (!clr_n_in) begin \n  load_sec_l <= 0; \n  load_sec_p <= 0; \n  load_nanosec_l <= 0; \n  load_nanosec_p <= 0; \n  end \n  else begin \n  load_sec_l <= load_sec_p; \n  load_sec_p <= load_sec_in; \n  load_nanosec_l <= load_nanosec_p; \n  load_nanosec_p <= load_nanosec_in; \n  end \n end \n always @ (posedge clk_in or negedge nano_counter_clr) \n begin \n  if (!nano_counter_clr) begin \n  nanoseconds <= 32'b0; \n  end \n  else if (!cnt_ena_in) begin \n  nanoseconds <= nanoseconds; \n  end \n  else if ((load_nanosec_l == 0) && (load_nanosec_p == 1)) begin \n  nanoseconds <= nanosec_data_in; \n  end \n  else begin \n  nanoseconds <= nanoseconds + 1'b1; \n  end \n end \n always @ (posedge pps_in or negedge clr_n_in) \n begin \n  if (!clr_n_in) begin \n  seconds <= 0; \n  end \n  else if (!cnt_ena_in) begin \n  seconds <= seconds; \n  end \n  else if ((load_sec_l == 0) && (load_sec_p == 1)) begin \n  seconds <= sec_data_in; \n  end \n  else begin \n  seconds <= seconds + 1'b1; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes a 4-bit input din and outputs din_3_0_eq_0, din_3_2_eq_0, and lead0_4b_0. It computes the logical NOT of the bitwise OR of the 4-bit input, assigns it to din_3_0_eq_0, computes the logical NOT of the bitwise OR of bits [3:2] of the input, assigns it to din_3_2_eq_0, and computes a logic operation based on the computed values to assign the value to lead0_4b_0.\n\n Module header:\n\nmodule fpu_cnt_lead0_lvl1 (din,din_3_0_eq_0,din_3_2_eq_0,lead0_4b_0);\n [/INST]\n", "output": "input [3:0] din; \n output din_3_0_eq_0; \n output din_3_2_eq_0; \n output lead0_4b_0; \n wire din_3_0_eq_0; \n wire din_3_2_eq_0; \n wire lead0_4b_0; \n assign din_3_0_eq_0= (!(|din[3:0])); \n assign din_3_2_eq_0= (!(|din[3:2])); \n assign lead0_4b_0= ((!din_3_2_eq_0) && (!din[3])) \n  || (din_3_2_eq_0 && (!din[1])); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module instantiates a Distributed RAM component and controls its operation based on the Clock_in, Reset_in, Index_in, Dirty_in, Write_Dirty_in, Counter_in, and Init_Dirty_out signals. During the positive edge of the Clock_in signal, the module performs the reset logic if Reset_in is asserted, and otherwise, it compares the Counter_in value and updates the Init_Dirty_out signal. The Distributed RAM is written to based on the Write_Dirty_in and Dirty_in signals and read from using the Dirty_out signal.\n\n Module header:\n\nmodule Dirty_Ram(input Clock_in,input Reset_in,input [3:0] Index_in,input Dirty_in,input Write_Dirty_in,output Dirty_out,input [7:0] Counter_in,output reg Init_Dirty_out);\n [/INST]\n", "output": "Distributed_RAM #(4,1,16) DIRTY_RAM(.Clock_in (Clock_in),.Write_Enable_in ((Init_Dirty_out) ? 1'b1 : Write_Dirty_in),.Address_in ((Init_Dirty_out) ? Counter_in[3:0] : Index_in),.Data_in ((Init_Dirty_out) ? 1'b0 : Dirty_in),.Data_out (Dirty_out)); \n  always @ (posedge Clock_in) begin \n  if (Reset_in) begin \n  Init_Dirty_out = 1'b1; \n  end \n  else begin \n  if (Counter_in == 8'b00010000) begin \n  Init_Dirty_out = 1'b0; \n  end \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an accumulator memory that performs various operations based on the inputs and the internal state machine. It has a memory array, a memory index, and a state variable. The module supports operations such as write, read, fetch, and send. The state machine transitions through different states based on the input conditions and operates on the memory array and the memory index accordingly. The module also has a preview output, a full indicator, a signal output, and a state output. The state machine progresses through different states such as INI, READ, WRITE, READY, and DONE based on the input and internal conditions. The state_string represents the current state in a string format.\n\n Module header:\n\nmodule accumulator_memory (clk, reset, op, signal, read, write, load, full, index, preview, state);\n [/INST]\n", "output": "input clk, reset, load; \n input [1:0] op; \n input [31:0] write; \n output [31:0] read; \n output [31:0] preview; \n output signal, full, state; \n output [9:0] index; \n reg [31:0] M [0:1023]; \n reg [9:0] I; \n reg [4:0] state; \n reg signal; \n reg [31:0] read; \n localparam \n  NOP = 2'b00, \n  FETCH = 2'b01, \n  SEND = 2'b10; \n localparam \n  INI = 5'b00001, \n  READ = 5'b00010, \n  WRITE = 5'b00100, \n  READY = 5'b01000, \n  DONE = 5'b10000; \n assign preview = M[I]; \n assign full = ( I == 10'b1111111111 ); \n assign index = I; \n reg [5*8:1] state_string; \n always @(*) \n begin \n  case (state) \n  5'b00001: state_string = \"INI \"; \n  5'b00010: state_string = \"READ \"; \n  5'b00100: state_string = \"WRITE\"; \n  5'b01000: state_string = \"READY\"; \n  5'b10000: state_string = \"DONE \"; \n  default: state_string = \"UNKN \"; \n  endcase \n end \n always @(posedge clk, posedge reset) \n begin \n  if (reset) begin \n  state <= INI; \n  I <= 0; \n  signal <= 0; \n  end \n  else begin \n  case (state) \n  INI : \n  begin \n  if (load && write != 0) begin \n  M[I] <= write; \n  I <= I + 1; \n  end \n  if (!load && op == FETCH) begin \n  state <= READ; \n  end \n  if (!load && op == SEND) begin \n  state <= WRITE; \n  end \n  end \n  READ : \n  begin \n  if (I == 1023 && M[I] == 0) begin \n  read <= 0; \n  signal <= 1; \n  state <= READY; \n  end \n  else begin \n  if (M[I] != 0) begin \n  read <= M[I]; \n  signal <= 1; \n  M[I] <= 0; \n  if (I != 1023) \n  I <= I + 1; \n  state <= READY; \n  end \n  else begin \n  I <= I + 1; \n  end \n  end \n  end \n  WRITE : \n  begin \n  if (I == 1023 && M[I] == 0) begin \n  M[I] <= write; \n  signal <= 1; \n  I <= I - 1; \n  state <= DONE; \n  end \n  else begin \n  if (M[I] == 0) begin \n  M[I] <= write; \n  signal <= 1; \n  state <= READY; \n  end \n  else begin \n  I <= I - 1; \n  end \n  end \n  end \n  READY : \n  begin \n  signal <= 0; \n  read <= 'bx; \n  if (signal == 0 && op == FETCH) begin \n  state <= READ; \n  end \n  if (signal == 0 && op == SEND) begin \n  state <= WRITE; \n  end \n  end \n  DONE : \n  begin \n  signal <= 0; \n  read <= 'bx; \n  if (signal == 0 && op == FETCH) begin \n  read <= 0; \n  signal <= 1; \n  end \n  if (signal == 0 && op == SEND && I == 1022) begin \n  M[I] <= write; \n  signal <= 1; \n  I <= I - 1; \n  end \n  if (signal == 0 && op == SEND && I == 1021) begin \n  M[I] <= write; \n  signal <= 1; \n  I <= I - 1; \n  end \n  if (signal == 0 && op == SEND && I == 1020) begin \n  M[I] <= write; \n  signal <= 1; \n  I <= I - 1; \n  end \n  if (signal == 0 && I == 1019) begin \n  read <= (M[1023] + M[1022] + M[1021] + M[1020]); \n  end \n  end \n  endcase \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module represents a bidirectional buffer, where the input signal IB is directly routed to the output signal OB. The module includes various parameters for setting input/output standards, pull-up/pull-down configurations, and slew rates, although these specific configurations are not explicitly specified in the provided code.\n\n Module header:\n\nmodule OBUFTDS_S_VPR (input IB,output OB);\n [/INST]\n", "output": "parameter [0:0] LVCMOS12_LVCMOS15_LVCMOS18_LVCMOS25_LVCMOS33_LVTTL_SSTL135_SSTL15_SLEW_SLOW = 1'b0; \n  parameter [0:0] LVCMOS12_LVCMOS15_LVCMOS18_SSTL135_SSTL15_STEPDOWN = 1'b0; \n  parameter [0:0] LVCMOS15_SSTL15_DRIVE_I16_I_FIXED = 1'b0; \n  parameter [0:0] SSTL135_DRIVE_I_FIXED = 1'b0; \n  parameter [0:0] SSTL135_SSTL15_SLEW_FAST = 1'b0; \n  parameter [0:0] IN_TERM_UNTUNED_SPLIT_40 = 1'b0; \n  parameter [0:0] IN_TERM_UNTUNED_SPLIT_50 = 1'b0; \n  parameter [0:0] IN_TERM_UNTUNED_SPLIT_60 = 1'b0; \n  parameter [0:0] PULLTYPE_PULLUP = 1'b0; \n  parameter [0:0] PULLTYPE_PULLDOWN = 1'b0; \n  parameter [0:0] PULLTYPE_NONE = 1'b0; \n  parameter [0:0] PULLTYPE_KEEPER = 1'b0; \n  parameter PULLTYPE = \"\"; \n  parameter IOSTANDARD = \"\"; \n  parameter SLEW = \"\"; \n  assign OB = IB; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes an 8-bit input and splits it into two outputs. The first output, o1, is assigned the value of bit 7 from the input. The second output, o0, is assigned the value of bits 6 to 0 from the input.\n\n Module header:\n\nmodule v78be07_v9a2a06 (input [7:0] i,output o1,output [6:0] o0);\n [/INST]\n", "output": "assign o1 = i[7]; \n  assign o0 = i[6:0]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a frequency-sampling counter. It counts the number of clock cycles between edges of the reference clock, and categorizes the count into one of 16 bins based on predefined thresholds. The result is output as a 4-bit signal `result_o`. The module is synchronous, with the reference clock `refclk_i` and the reset signal `rst_i` controlling the state transitions. The sampled clock signal `fsclk_i` is used to detect edges for counting. When a reference clock edge is detected, the current count is latched, and the count is reset. The final result is determined based on the latched count value and predefined threshold ranges.\n\n Module header:\n\nmodule fs_counter(refclk_i, fsclk_i, rst_i, result_o);\n [/INST]\n", "output": "input refclk_i; \n  input fsclk_i; \n  input rst_i; \n  output [3:0] result_o; \n  reg [9:0] cnt; \n  reg [9:0] l_cnt; \n  reg [2:0] s_fsclk; \n  always @ (posedge rst_i or negedge refclk_i) begin \n  if(rst_i) begin \n  s_fsclk[0] <= 1'b0; \n  end \n  else begin \n  s_fsclk[2:0] <= {s_fsclk[1:0], fsclk_i}; \n  end \n  end \n  wire edgedet = (s_fsclk[1] ^ s_fsclk[2]) & ~s_fsclk[1]; \n  always @ (posedge refclk_i or posedge rst_i) begin \n  if(rst_i) begin \n  l_cnt[9:0] <= 10'b0; \n  cnt[9:0] <= 10'b0; \n  end \n  else begin \n  if(edgedet) begin \n  l_cnt[9:0] <= cnt[9:0]; \n  cnt[9:0] <= 10'b0; \n  end \n  else begin \n  cnt[9:0] <= cnt[9:0] + 1'b1; \n  end \n  end \n  end \n  assign result_o = (l_cnt[9:0] >= 10'd662) ? 4'b0000 : \n  (l_cnt[9:0] >= 10'd534 && l_cnt[9:0] < 662) ? 4'b0001 : \n  (l_cnt[9:0] >= 10'd448 && l_cnt[9:0] < 534) ? 4'b0010 : \n  (l_cnt[9:0] >= 10'd331 && l_cnt[9:0] < 448) ? 4'b0100 : \n  (l_cnt[9:0] >= 10'd267 && l_cnt[9:0] < 331) ? 4'b0101 : \n  (l_cnt[9:0] >= 10'd224 && l_cnt[9:0] < 267) ? 4'b0110 : \n  (l_cnt[9:0] >= 10'd165 && l_cnt[9:0] < 224) ? 4'b1000 : \n  (l_cnt[9:0] >= 10'd133 && l_cnt[9:0] < 165) ? 4'b1001 : \n  (l_cnt[9:0] >= 10'd112 && l_cnt[9:0] < 133) ? 4'b1010 : \n  (l_cnt[9:0] >= 10'd82 && l_cnt[9:0] < 112) ? 4'b1100 : \n  (l_cnt[9:0] >= 10'd66 && l_cnt[9:0] < 82) ? 4'b1101 : \n  (l_cnt[9:0] >= 10'd1 && l_cnt[9:0] < 66) ? 4'b1110 : \n  4'b1111; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module implements a 7-segment decoder with input number num_in and control signals. The module outputs the corresponding 7-segment display output based on the control and num_in inputs. It also includes a display_sel input to select between the BCD and hexadecimal outputs. The module contains logic to decode the BCD and hexadecimal values for the input numbers and selects the appropriate output based on the control and display_sel inputs. The outputs are assigned based on the conditions specified in the module, and the module includes intermediate wires for buffering and intermediate BCD and hexadecimal outputs.\n\n Module header:\n\nmodule seven_seg_decoder(num_in,control,seg_out,display_sel);\n [/INST]\n", "output": "input [3:0] num_in; \n  input [1:0] control; \n  output [6:0] seg_out; \n  input display_sel; \n  wire [6:0] seg_out_bcd; \n  wire [6:0] seg_out_hex; \n  wire [6:0] seg_out_buf; \n  assign seg_out = (control == 2'b11 & display_sel == 1'b0) ? 7'b0001001 : seg_out_buf; \n  assign seg_out_buf = (display_sel == 1'b1) ? seg_out_bcd : seg_out_hex; \n  assign seg_out_bcd = (num_in == 4'b0000) ? 7'b1000000 : \n  (num_in == 4'b0001) ? 7'b1111001 : \n  (num_in == 4'b0010) ? 7'b0100100 : \n  (num_in == 4'b0011) ? 7'b0110000 : \n  (num_in == 4'b0100) ? 7'b0011001 : \n  (num_in == 4'b0101) ? 7'b0010010 : \n  (num_in == 4'b0110) ? 7'b0000010 : \n  (num_in == 4'b0111) ? 7'b1111000 : \n  (num_in == 4'b1000) ? 7'b0000000 : \n  (num_in == 4'b1001) ? 7'b0010000 : \n  (num_in == 4'b1010) ? 7'b1111111 : \n  (num_in == 4'b1011) ? 7'b1000110 : \n  7'b0111111; \n  assign seg_out_hex = (num_in == 4'b0000) ? 7'b1000000 : \n  (num_in == 4'b0001) ? 7'b1111001 : \n  (num_in == 4'b0010) ? 7'b0100100 : \n  (num_in == 4'b0011) ? 7'b0110000 : \n  (num_in == 4'b0100) ? 7'b0011001 : \n  (num_in == 4'b0101) ? 7'b0010010 : \n  (num_in == 4'b0110) ? 7'b0000010 : \n  (num_in == 4'b0111) ? 7'b1111000 : \n  (num_in == 4'b1000) ? 7'b0000000 : \n  (num_in == 4'b1001) ? 7'b0010000 : \n  (num_in == 4'b1010) ? 7'b0001000 : \n  (num_in == 4'b1011) ? 7'b0000011 : \n  (num_in == 4'b1100) ? 7'b1000110 : \n  (num_in == 4'b1101) ? 7'b0100001 : \n  (num_in == 4'b1110) ? 7'b0000110 : \n  7'b0001110; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module generates a constant output value of 8'b11001000 on the 'op' output signal. The output value remains constant regardless of the input signals clk, ce, and clr.\n\n Module header:\n\nmodule sysgen_constant_07b701207a (output [(8 - 1):0] op,input clk,input ce,input clr);\n [/INST]\n", "output": "assign op = 8'b11001000; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module serves as the top-level design, with inputs including a clock signal, reset signal, 2-bit signal, and a flip signal, as well as outputs that encompass two 16-bit buses, a 22-bit bus, and several other 2 to 3-bit buses. \n\nIt also instantiates a submodule, \"SubModule1,\" and connects its input and output ports with the corresponding signals. Moreover, it assigns the output \"sig_out\" to the value of \"MyInterfaceInstance_mysig_out\" and sets the value of \"MyInterfaceInstance_setting\" to the value of the \"flip\" input signal.\n\n Module header:\n\nmodule TopModule(input logic clk,input logic rst,input logic [1:0] sig,input logic flip,output logic [15:0] passThrough,output logic [21:0] outOther,input logic interfaceInstanceAtTop_setting,output logic [2:0] interfaceInstanceAtTop_other_setting,output logic [1:0] interfaceInstanceAtTop_mysig_out,output logic [15:0] interfaceInstanceAtTop_passThrough,output logic [1:0] sig_out);\n [/INST]\n", "output": "logic MyInterfaceInstance_setting; \n  logic [3:0] MyInterfaceInstance_other_setting; \n  logic [1:0] MyInterfaceInstance_mysig_out; \n SubModule1 u_SubModule1 (.clk(clk),.rst(rst),.u_MyInterface_setting(MyInterfaceInstance_setting),.u_MyInterface_mysig_out(MyInterfaceInstance_mysig_out),.u_MyInterface_other_setting(MyInterfaceInstance_other_setting),.u_MyInterfaceFromTop_setting(interfaceInstanceAtTop_setting),.u_MyInterfaceFromTop_other_setting(interfaceInstanceAtTop_other_setting),.u_MyInterfaceFromTop_mysig_out(interfaceInstanceAtTop_mysig_out),.u_MyInterfaceFromTop_passThrough(interfaceInstanceAtTop_passThrough),.outOther(outOther),.passThrough (passThrough),.sig (sig)); \n  assign sig_out = MyInterfaceInstance_mysig_out; \n  assign MyInterfaceInstance_setting = flip; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module `RMON` is a module for monitoring network packet traffic. It has various inputs including packet type, length, and error type for both transmit (Tx) and receive (Rx) packets, as well as CPU read and control signals. The module also instantiates submodules for address generation, control logic, and dual-port RAMs for both Rx and Tx data. The submodules are responsible for handling the addressing, data storage, and control logic for the monitored network packets. The CPU read signals are used to interface the monitored packet data with an external CPU. The module primarily facilitates the monitoring and processing of network packet data for analysis and debugging.\n\n Module header:\n\nmodule RMON (Clk ,Reset ,Tx_pkt_type_rmon ,Tx_pkt_length_rmon ,Tx_apply_rmon ,Tx_pkt_err_type_rmon,Rx_pkt_type_rmon ,Rx_pkt_length_rmon ,Rx_apply_rmon ,Rx_pkt_err_type_rmon,CPU_rd_addr ,CPU_rd_apply ,CPU_rd_grant ,CPU_rd_dout);\n [/INST]\n", "output": "input Clk ; \n input Reset ; \n input [2:0] Tx_pkt_type_rmon ; \n input [15:0] Tx_pkt_length_rmon ; \n input Tx_apply_rmon ; \n input [2:0] Tx_pkt_err_type_rmon; \n input [2:0] Rx_pkt_type_rmon ; \n input [15:0] Rx_pkt_length_rmon ; \n input Rx_apply_rmon ; \n input [2:0] Rx_pkt_err_type_rmon; \n input [5:0] CPU_rd_addr ; \n input CPU_rd_apply ; \n output CPU_rd_grant ; \n output [31:0] CPU_rd_dout ; \n wire Reg_apply_0 ; \n wire [4:0] Reg_addr_0 ; \n wire [15:0] Reg_data_0 ; \n wire Reg_next_0 ; \n wire Reg_apply_1 ; \n wire [4:0] Reg_addr_1 ; \n wire [15:0] Reg_data_1 ; \n wire Reg_next_1 ; \n wire [5:0] Addra ; \n wire [31:0] Dina ; \n wire [31:0] Douta ; \n wire Wea ; \n assign RxAddrb=0; \n assign TxAddrb=0; \n RMON_addr_gen U_0_Rx_RMON_addr_gen(.Clk (Clk ),.Reset (Reset ),.Pkt_type_rmon (Rx_pkt_type_rmon ),.Pkt_length_rmon (Rx_pkt_length_rmon ),.Apply_rmon (Rx_apply_rmon ),.Pkt_err_type_rmon (Rx_pkt_err_type_rmon ),.Reg_apply (Reg_apply_0 ),.Reg_addr (Reg_addr_0 ),.Reg_data (Reg_data_0 ),.Reg_next (Reg_next_0 ),.Reg_drop_apply ( )); \n RMON_addr_gen U_0_Tx_RMON_addr_gen(.Clk (Clk ),.Reset (Reset ),.Pkt_type_rmon (Tx_pkt_type_rmon ),.Pkt_length_rmon (Tx_pkt_length_rmon ),.Apply_rmon (Tx_apply_rmon ),.Pkt_err_type_rmon (Tx_pkt_err_type_rmon ),.Reg_apply (Reg_apply_1 ),.Reg_addr (Reg_addr_1 ),.Reg_data (Reg_data_1 ),.Reg_next (Reg_next_1 ),.Reg_drop_apply ( )); \n RMON_CTRL U_RMON_CTRL(.Clk (Clk ),.Reset (Reset ),.Reg_apply_0 (Reg_apply_0 ),.Reg_addr_0 (Reg_addr_0 ),.Reg_data_0 (Reg_data_0 ),.Reg_next_0 (Reg_next_0 ),.Reg_apply_1 (Reg_apply_1 ),.Reg_addr_1 (Reg_addr_1 ),.Reg_data_1 (Reg_data_1 ),.Reg_next_1 (Reg_next_1 ),.Addra (Addra ),.Dina (Dina ),.Douta (Douta ),.Wea (Wea ),.CPU_rd_addr (CPU_rd_addr ),.CPU_rd_apply (CPU_rd_apply ),.CPU_rd_grant (CPU_rd_grant ),.CPU_rd_dout (CPU_rd_dout )); \n RMON_dpram U_Rx_RMON_dpram(.Reset (Reset ),.Clk (Clk ),.Addra (Addra ),.Dina (Dina ),.Douta ( ),.Wea (Wea ),.Addrb (Addra ),.Doutb (Douta )); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a True Random Number Generator (TRNG) that takes a clock signal, an enable signal, and outputs an 8-bit random number. The module contains registers 'a' and 'd', and wires 'c' and 'R'. On each clock edge, the module updates 'a' based on the enable signal, and assigns the value of 'a' to 'b'. It then updates 'd' based on the enable signal and the value of 'c'. The final random number output 'R' is equal to the value of 'd'. The algorithm uses bitwise XOR and concatenation operations to generate the random number.\n\n Module header:\n\nmodule trng (input clk,input en,output [7:0] R);\n [/INST]\n", "output": "wire [7:0] a, c; \n reg [7:0] b, d; \n assign a = (en) ? ({ a[6:0], a[7] } ^ a ^ { a[0], a[7:1] } ^ 8'h80) : a; \n always @(posedge clk) \n begin \n  b <= a; \n end \n assign c = (d & 8'h96) ^ { d[6:0], 1'b0 } ^ { 1'b0, d[7:1] } ^ b; \n always @(posedge clk) \n begin \n  d <= (en) ? c : d; \n end \n assign R = d; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is the top-level module for a hardware design. It generates internal clock signal, manages reset and clock enable signals, and interfaces with various input and output ports. It includes a clock divider and handles register addresses and data. The module instantiates the \"sm_top\" submodule and assigns LED output based on the clock signal. It also assigns the LED and hex segment data to the register data. The module further manages the segment enable signals and instantiates two \"sm_hex_display\" submodules for digit display.\n\n Module header:\n\nmodule de4_230 (input GCLKIN,output GCLKOUT_FPGA,input OSC_50_BANK2,input OSC_50_BANK3,input OSC_50_BANK4,input OSC_50_BANK5,input OSC_50_BANK6,input OSC_50_BANK7,input PLL_CLKIN_p,output [7:0] LED,input [3:0] BUTTON,input CPU_RESET_n,inout EXT_IO,input [7:0] SW,input [3:0] SLIDE_SW,output [6:0] SEG0_D,output SEG0_DP,output [6:0] SEG1_D,output SEG1_DP);\n [/INST]\n", "output": "wire clk; \n  wire clkIn = OSC_50_BANK2; \n  wire rst_n = CPU_RESET_n; \n  wire clkEnable = SW [7] | ~BUTTON[0]; \n  wire [ 3:0 ] clkDevide = SW [3:0]; \n  wire [ 4:0 ] regAddr = { ~BUTTON[1], SLIDE_SW }; \n  wire [ 31:0 ] regData; \n  sm_top sm_top \n (.clkIn ( clkIn ),.rst_n ( rst_n ),.clkDevide ( clkDevide ),.clkEnable ( clkEnable ),.clk ( clk ),.regAddr ( regAddr ),.regData ( regData )); \n  assign LED[0] = clk; \n  assign LED[7:1] = regData[6:0]; \n  wire [ 31:0 ] h7segment = regData; \n  assign SEG0_DP = 1'b1; \n  assign SEG1_DP = 1'b1; \n  sm_hex_display digit_1 ( h7segment [ 7: 4] , SEG1_D ); \n  sm_hex_display digit_0 ( h7segment [ 3: 0] , SEG0_D ); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a component of a system that collects data from multiple clusters. It iterates through the clusters, fetching data from each cluster when a specific condition is met. It also captures potential errors associated with the fetched data and forwards the error information to the sender module. The cluster iterator is incremented upon the receipt of a signal indicating that cluster data has been successfully fetched. The module also handles error detection and validation, and prepares the error information to be sent out to the sender module.\n\n Module header:\n\nmodule SHDCollector #(parameter DNA_DATA_WIDTH = 128, NUM_CLUSTERS = 8, NUM_PES = 8) (input clk,input rst,output reg[NUM_CLUSTERS - 1:0] cluster_rd_en,input[NUM_CLUSTERS * NUM_PES - 1:0] cluster_data,input[NUM_CLUSTERS - 1:0] cluster_valid,input sender_ready,output sender_data_valid,output[NUM_PES - 1:0] sender_data);\n [/INST]\n", "output": "wire cluster_fetched; \n  parameter CLUSTER_BITS = $clog2(NUM_CLUSTERS); \n  reg[CLUSTER_BITS - 1:0] cluster_iterator = 0; \n  wire advance_cluster_it; \n  always@(posedge clk) begin \n  if(rst) begin \n  cluster_iterator <= 0; \n  end \n  else begin \n  if(advance_cluster_it) begin \n  cluster_iterator <= cluster_iterator + 1'b1; \n  end \n  end \n  end \n  assign advance_cluster_it = cluster_fetched; \n  reg[NUM_PES - 1:0] dna_err_r; \n  reg dna_err_valid_r; \n  wire accept_cluster_data; \n  always@(posedge clk) begin \n  if(rst) begin \n  dna_err_r <= 0; \n  dna_err_valid_r <= 1'b0; \n  end \n  else begin \n  if(accept_cluster_data) begin \n  dna_err_r <= cluster_data[cluster_iterator*NUM_PES +: NUM_PES]; \n  dna_err_valid_r <= cluster_valid[cluster_iterator]; \n  end \n  end \n  end \n  always@* begin \n  cluster_rd_en = 0; \n  cluster_rd_en[cluster_iterator] = accept_cluster_data; \n  end \n  assign cluster_fetched = accept_cluster_data && cluster_valid[cluster_iterator]; \n  assign accept_cluster_data = sender_ready; \n  assign sender_data_valid = dna_err_valid_r; \n  assign sender_data = dna_err_r; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a data processing pipeline with multiple input and output signals. It calculates differential values and sets flags based on comparisons between input data. It also handles reset conditions and controls the pipeline based on the status of its input and output signals. The 'busy' output signal indicates the pipeline status, and the 'pipe_ack_o' signal is derived from internal logic and input signals.\n\n Module header:\n\nmodule tmu2_vdivops(input sys_clk,input sys_rst,output busy,input pipe_stb_i,output pipe_ack_o,input signed [17:0] ax,input signed [17:0] ay,input signed [17:0] bx,input signed [17:0] by,input signed [17:0] cx,input signed [17:0] cy,input signed [17:0] dx,input signed [17:0] dy,input signed [11:0] drx,input signed [11:0] dry,output reg pipe_stb_o,input pipe_ack_i,output reg signed [17:0] ax_f,output reg signed [17:0] ay_f,output reg signed [17:0] bx_f,output reg signed [17:0] by_f,output reg diff_cx_positive,output reg [16:0] diff_cx,output reg diff_cy_positive,output reg [16:0] diff_cy,output reg diff_dx_positive,output reg [16:0] diff_dx,output reg diff_dy_positive,output reg [16:0] diff_dy,output reg signed [11:0] drx_f,output reg signed [11:0] dry_f);\n [/INST]\n", "output": "always @(posedge sys_clk) begin \n  if(sys_rst) \n  pipe_stb_o <= 1'b0; \n  else begin \n  if(pipe_ack_i) \n  pipe_stb_o <= 1'b0; \n  if(pipe_stb_i & pipe_ack_o) begin \n  pipe_stb_o <= 1'b1; \n  if(cx > ax) begin \n  diff_cx_positive <= 1'b1; \n  diff_cx <= cx - ax; \n  end else begin \n  diff_cx_positive <= 1'b0; \n  diff_cx <= ax - cx; \n  end \n  if(cy > ay) begin \n  diff_cy_positive <= 1'b1; \n  diff_cy <= cy - ay; \n  end else begin \n  diff_cy_positive <= 1'b0; \n  diff_cy <= ay - cy; \n  end \n  if(dx > bx) begin \n  diff_dx_positive <= 1'b1; \n  diff_dx <= dx - bx; \n  end else begin \n  diff_dx_positive <= 1'b0; \n  diff_dx <= bx - dx; \n  end \n  if(dy > by) begin \n  diff_dy_positive <= 1'b1; \n  diff_dy <= dy - by; \n  end else begin \n  diff_dy_positive <= 1'b0; \n  diff_dy <= by - dy; \n  end \n  ax_f <= ax; \n  ay_f <= ay; \n  bx_f <= bx; \n  by_f <= by; \n  drx_f <= drx; \n  dry_f <= dry; \n  end \n  end \n end \n assign pipe_ack_o = ~pipe_stb_o | pipe_ack_i; \n assign busy = pipe_stb_o; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module serves as a clock counter. It increments the time in seconds, minutes, and hours based on the clock signal and resets when the load signal transitions from high to low. The output signals chour2, chour1, cminute2, cminute1, csecond2, and csecond1 represent the updated time values. The clock starts from 00:00:00 and increments the time until it reaches 23:59:59.\n\n Module header:\n\nmodule run_clock (nLoad, Clk, hour2, hour1, minute2, minute1, second2, second1,chour2, chour1, cminute2, cminute1, csecond2, csecond1);\n [/INST]\n", "output": "input Clk, nLoad; \n  input [3:0] hour2, hour1, minute2, minute1, second2, second1; \n  output reg [3:0] chour2, chour1, cminute2, cminute1, csecond2, csecond1; \n  always @ (posedge Clk, negedge nLoad) \n  begin \n  if (~nLoad) \n  begin \n  chour2 <= hour2; chour1 <= hour1; cminute2 <= minute2; cminute1 <= minute1; csecond2 <= second2; csecond1 <= second1; \n  end \n  else \n  begin \n  csecond1 <= csecond1 + 1; \n  if (csecond1 > 8) \n  begin \n  csecond2 <= csecond2 + 1; \n  csecond1 <= 0; \n  end \n  if ((csecond2 == 5)&(csecond1 == 9)) \n  begin \n  cminute1 <= cminute1 + 1; \n  csecond2 <= 0; \n  csecond1 <= 0; \n  end \n  if ((cminute2 < 5) & (cminute1 == 9) & (csecond2 == 5) & (csecond1 == 9)) \n  begin \n  cminute2 <= cminute2 + 1; \n  cminute1 <= 0; \n  end \n  if ((cminute2 == 5)&(cminute1 == 9)&(csecond2 == 5)&(csecond1 == 9)) \n  begin \n  chour1 <= chour1 + 1; \n  cminute2 <= 0; \n  cminute1 <= 0; \n  end \n  if ((chour2 < 2) & (chour1 == 9) & (cminute2 == 5) & (cminute1 == 9) & (csecond2 == 5) & (csecond1 == 9)) \n  begin \n  chour2 <= chour2 + 1; \n  chour1 <= 0; \n  end \n  if ((chour2 == 2)&(chour1 == 3)&(cminute2 == 5)&(cminute1 == 9)&(csecond2==5)&(csecond1==9)) \n  begin \n  chour2 <= 0; \n  chour1 <= 0; \n  end \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module serves as a top-level design for a digital system. It includes modules for a register file, ALU, control FSM, and main memory, each with specific inputs and outputs. The module has various internal wires to facilitate communication between these modules. It also contains logic to control write enable signals for the main memory and register file. The output register reg_out is assigned the value of reg_data_d. The entire design coordinates the operation of these individual components and their interconnections.\n\n Module header:\n\nmodule core_top(input clk, rst, run_n,input [3:0] reg_addr_d,output [15:0] reg_out);\n [/INST]\n", "output": "wire reg_we, sram_we_n, ram_wren; \n wire [2:0] alu_operator; \n wire [3:0] reg_addr_a, reg_addr_b, reg_addr_c; \n wire [15:0] ram_addr, ram_data, reg_data_a, reg_data_b, reg_data_c, reg_data_d, alu_op_a,alu_out,alu_status, ram_q,pc; \n assign reg_out = reg_data_d; \n assign ram_wren = ~sram_we_n; \n register_file register_file0(clk, rst, reg_we, reg_addr_a, reg_addr_b, reg_addr_c, reg_addr_d, reg_data_c, reg_data_a, reg_data_b, reg_data_d); \n alu16 alu16_0( clk,rst,alu_operator, alu_op_a, reg_data_b, alu_out, alu_status); \n control_fsm control_fsm0( clk, rst, run_n, ram_q, reg_data_a, reg_data_b, alu_status, alu_out,sram_we_n, reg_we, alu_operator, reg_addr_a, reg_addr_b,reg_addr_c, alu_op_a, reg_data_c, ram_addr, ram_data); \n main_memory main_memory0(ram_addr[7:0], clk, ram_data, ram_wren, ram_q); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a clock buffer with differential input and output. It includes a differential buffer with hysteresis and handles both differential and single-ended input clock types. The module utilizes specialized buffer components to handle the different input types and generate the buffered clock signal. The module then assigns the buffered clock signal to the output.\n\n Module header:\n\nmodule clk_ibuf # (parameter INPUT_CLK_TYPE = \"DIFFERENTIAL\",parameter DIFF_TERM = \"TRUE\") (input sys_clk_p,input sys_clk_n,input sys_clk_i,output mmcm_clk);\n [/INST]\n", "output": "(* KEEP = \"TRUE\" *) wire sys_clk_ibufg; \n  generate \n  if (INPUT_CLK_TYPE == \"DIFFERENTIAL\") begin: diff_input_clk \n  IBUFGDS # \n (.DIFF_TERM (DIFF_TERM),.IBUF_LOW_PWR (\"FALSE\")) \n  u_ibufg_sys_clk \n (.I (sys_clk_p),.IB (sys_clk_n),.O (sys_clk_ibufg)); \n  end else if (INPUT_CLK_TYPE == \"SINGLE_ENDED\") begin: se_input_clk \n  IBUFG # \n (.IBUF_LOW_PWR (\"FALSE\")) \n  u_ibufg_sys_clk \n (.I (sys_clk_i),.O (sys_clk_ibufg)); \n  end \n  endgenerate \n  assign mmcm_clk = sys_clk_ibufg; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `altera_onchip_flash_avmm_csr_controller` is a controller for an Altera On-Chip Flash memory. It handles operations such as sector/page erase, write protect mode, and access control.\n\nThe module has inputs for clock, reset, AVMM read, AVMM write, AVMM address, and AVMM write data, as well as an output for AVMM read data and CSR status. The `csr_control` output is a 32-bit signal that controls the flash memory operations.\n\nInternally, the module maintains registers for sector/page erase address, write protect mode, erase state, and control access. It also has logic to handle reset, update register values based on input signals, and manage the erase state based on the status and operations.\n\nThe module handles different states such as idle, busy erase, and busy write, and transitions between these states based on the input signals and status. It also performs operations such as setting the erase state to pending, busy, or idle based on the control signals.\n\nThe module effectively serves as a controller for managing operations on the Altera On-Chip Flash memory based on the input signals and status, providing the necessary control signals for the flash memory operations.\n\n Module header:\n\nmodule altera_onchip_flash_avmm_csr_controller (clock,reset_n,avmm_read,avmm_write,avmm_addr,avmm_writedata,avmm_readdata,csr_status,csr_control);\n [/INST]\n", "output": "parameter AVMM_CSR_DATA_WIDTH = 32; \n  localparam [1:0] ERASE_ST_IDLE = 0, \n  ERASE_ST_PENDING = 1, \n  ERASE_ST_BUSY = 2; \n  localparam [1:0] STATUS_IDLE = 0, \n  STATUS_BUSY_ERASE = 1, \n  STATUS_BUSY_WRITE = 2, \n  STATUS_BUSY_READ = 3; \n  input clock; \n  input reset_n; \n  input avmm_read; \n  input avmm_write; \n  input avmm_addr; \n  input [AVMM_CSR_DATA_WIDTH-1:0] avmm_writedata; \n  output [AVMM_CSR_DATA_WIDTH-1:0] avmm_readdata; \n  input [9:0] csr_status; \n  output [31:0] csr_control; \n  reg [22:0] csr_sector_page_erase_addr_reg; \n  reg [4:0] csr_wp_mode; \n  reg [1:0] csr_erase_state; \n  reg csr_control_access; \n  reg reset_n_reg1; \n  reg reset_n_reg2; \n  wire reset_n_w; \n  wire is_idle; \n  wire is_erase_busy; \n  wire valid_csr_erase_addr; \n  wire valid_csr_write; \n  wire [31:0] csr_control_signal; \n  wire [22:0] csr_erase_addr; \n  assign is_idle = (csr_status[1:0] == STATUS_IDLE); \n  assign is_erase_busy = (csr_status[1:0] == STATUS_BUSY_ERASE); \n  assign csr_erase_addr = avmm_writedata[22:0]; \n  assign valid_csr_erase_addr = (csr_erase_addr != {(23){1'b1}}); \n  assign valid_csr_write = (avmm_write & avmm_addr); \n  assign csr_control_signal = { csr_erase_state, {(2){1'b1}}, csr_wp_mode, csr_sector_page_erase_addr_reg }; \n  assign csr_control = csr_control_signal; \n  assign avmm_readdata = (csr_control_access) ? csr_control_signal : { {(22){1'b1}}, csr_status[9:0] }; \n  assign reset_n_w = reset_n_reg2; \n  initial begin \n  csr_sector_page_erase_addr_reg <= {(23){1'b1}}; \n  csr_wp_mode = {(5){1'b1}}; \n  csr_erase_state = ERASE_ST_IDLE; \n  csr_control_access = 1'b0; \n  reset_n_reg1 = 1'b0; \n  reset_n_reg2 = 1'b0; \n  end \n  always @ (negedge reset_n or posedge clock) begin \n  if (~reset_n) begin \n  {reset_n_reg2, reset_n_reg1} <= 2'b0; \n  end \n  else begin \n  {reset_n_reg2, reset_n_reg1} <= {reset_n_reg1, 1'b1}; \n  end \n  end \n  always @ (posedge clock) begin \n  if (~reset_n_w) begin \n  csr_sector_page_erase_addr_reg <= {(23){1'b1}}; \n  csr_wp_mode <= {(5){1'b1}}; \n  csr_erase_state <= ERASE_ST_IDLE; \n  csr_control_access <= 1'b0; \n  end \n  else begin \n  if (avmm_read) begin \n  csr_control_access <= avmm_addr; \n  end \n  if (valid_csr_write) begin \n  csr_wp_mode <= avmm_writedata[27:23]; \n  if (is_idle) begin \n  csr_sector_page_erase_addr_reg <= avmm_writedata[22:0]; \n  end \n  end \n  case (csr_erase_state) \n  ERASE_ST_IDLE: \n  if (is_idle && valid_csr_write && valid_csr_erase_addr) begin \n  csr_erase_state <= ERASE_ST_PENDING; \n  end \n  ERASE_ST_PENDING: \n  if (is_erase_busy) begin \n  csr_erase_state <= ERASE_ST_BUSY; \n  end \n  ERASE_ST_BUSY: \n  if (is_idle) begin \n  csr_erase_state <= ERASE_ST_IDLE; \n  end \n  default: begin \n  csr_erase_state <= ERASE_ST_IDLE; \n  end \n  endcase \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module implements a SHA-256 stream processing unit with clock, reset, mode, data input, last flag input, and valid input, as well as ready output, digest output, and digest valid output. It handles the first block flag and triggers the SHA-256 core based on the input signals. The SHA-256 core is configured based on the input signals and generates the digest output and digest valid output.\n\n Module header:\n\nmodule sha256_stream (input clk,input rst,input mode,input [511:0] s_tdata_i,input s_tlast_i,input s_tvalid_i,output s_tready_o,output [255:0] digest_o,output digest_valid_o);\n [/INST]\n", "output": "reg first_block; \n  always @(posedge clk) begin \n  if (s_tvalid_i & s_tready_o) \n  first_block <= s_tlast_i; \n  if (rst) begin \n  first_block <= 1'b1; \n  end \n  end \n  sha256_core core \n (.clk (clk),.reset_n (~rst),.init(s_tvalid_i & first_block),.next(s_tvalid_i & !first_block),.mode (mode),.block(s_tdata_i),.ready(s_tready_o),.digest (digest_o),.digest_valid (digest_valid_o)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes in a single-bit input and directly assigns it to the output register whenever the input changes. It essentially creates a passthrough module that simply copies the input to the output.\n\n Module header:\n\nmodule f5_test(input in, output reg out);\n [/INST]\n", "output": "always @(in) \n  out = in; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"pu_reset\" implements a reset signal generator using a 4-bit counter. On each rising edge of the clock signal, the counter increments unless the reset signal is asserted, in which case the counter is set to zero. The reset output is active as long as the counter value is not 15 (4'b1111 in binary).\n\n Module header:\n\nmodule pu_reset(clk, res);\n [/INST]\n", "output": "input wire clk; \n output wire res; \n reg [3:0] res_cntr; \n assign res = (res_cntr!=4'b1111); \n wire [3:0] next_res_cntr = (res) ? res_cntr : res_cntr + 1'b1; \n always @(posedge clk) res_cntr <= next_res_cntr; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a part of a larger system and implements a Handshake protocol. It uses signals like CLK, ready_downstream, reset, process_input, ready, and process_output. It instantiates the inner module WaitOnInput_ChangeRate_uint8_2_1__from4_to2_H1 and the ShiftRegister_1_CEtrue_TY1 module. The module combines the outputs of these instantiated modules to generate the final process_output signal and also checks for X values in the valid bit of the outputs. The ready signal is computed based on the inner module's ready and the ready_downstream signal.\n\n Module header:\n\nmodule LiftHandshake_WaitOnInput_ChangeRate_uint8_2_1__from4_to2_H1(input CLK, input ready_downstream, output ready, input reset, input [64:0] process_input, output [32:0] process_output);\n [/INST]\n", "output": "parameter INSTANCE_NAME=\"INST\"; \n parameter OUTPUT_COUNT=0; \n parameter INPUT_COUNT=0; \n  wire inner_WaitOnInput_ChangeRate_uint8_2_1__from4_to2_H1_ready; \n  assign ready = {(inner_WaitOnInput_ChangeRate_uint8_2_1__from4_to2_H1_ready&&ready_downstream)}; \n  wire unnamedbinop7692USEDMULTIPLEbinop;assign unnamedbinop7692USEDMULTIPLEbinop = {(reset||ready_downstream)}; \n  wire unnamedunary7693USEDMULTIPLEunary;assign unnamedunary7693USEDMULTIPLEunary = {(~reset)}; \n  wire [32:0] inner_WaitOnInput_ChangeRate_uint8_2_1__from4_to2_H1_process_output; \n  wire validBitDelay_WaitOnInput_ChangeRate_uint8_2_1__from4_to2_H1_pushPop_out; \n  wire [32:0] unnamedtuple7703USEDMULTIPLEtuple;assign unnamedtuple7703USEDMULTIPLEtuple = {{((inner_WaitOnInput_ChangeRate_uint8_2_1__from4_to2_H1_process_output[32])&&validBitDelay_WaitOnInput_ChangeRate_uint8_2_1__from4_to2_H1_pushPop_out)},(inner_WaitOnInput_ChangeRate_uint8_2_1__from4_to2_H1_process_output[31:0])}; \n  always @(posedge CLK) begin if({(~{((unnamedtuple7703USEDMULTIPLEtuple[32])===1'bx)})} == 1'b0 && (1'd1)==1'b1) begin $display(\"%s: LiftHandshake: output valid bit should not be X!\",INSTANCE_NAME); end end \n  always @(posedge CLK) begin if({(~{((process_input[64])===1'bx)})} == 1'b0 && (1'd1)==1'b1) begin $display(\"%s: LiftHandshake: input valid bit should not be X!\",INSTANCE_NAME); end end \n  assign process_output = unnamedtuple7703USEDMULTIPLEtuple; \n  WaitOnInput_ChangeRate_uint8_2_1__from4_to2_H1 #(.INSTANCE_NAME({INSTANCE_NAME,\"_inner_WaitOnInput_ChangeRate_uint8_2_1__from4_to2_H1\"})) inner_WaitOnInput_ChangeRate_uint8_2_1__from4_to2_H1(.CLK(CLK), .ready(inner_WaitOnInput_ChangeRate_uint8_2_1__from4_to2_H1_ready), .reset(reset), .CE(unnamedbinop7692USEDMULTIPLEbinop), .process_valid(unnamedunary7693USEDMULTIPLEunary), .process_input(process_input), .process_output(inner_WaitOnInput_ChangeRate_uint8_2_1__from4_to2_H1_process_output)); \n  ShiftRegister_1_CEtrue_TY1 #(.INSTANCE_NAME({INSTANCE_NAME,\"_validBitDelay_WaitOnInput_ChangeRate_uint8_2_1__from4_to2_H1\"})) validBitDelay_WaitOnInput_ChangeRate_uint8_2_1__from4_to2_H1(.CLK(CLK), .pushPop_valid(unnamedunary7693USEDMULTIPLEunary), .CE(unnamedbinop7692USEDMULTIPLEbinop), .sr_input((1'd1)), .pushPop_out(validBitDelay_WaitOnInput_ChangeRate_uint8_2_1__from4_to2_H1_pushPop_out), .reset(reset)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a CRC16 update logic. It takes in a dataIn input and updates the CRCResult based on the dataIn and control signals rstCRC, CRCEn, ready, clk, and rst. The module includes a state machine that handles the CRC update process, setting the ready output when the update is complete. The CRCResult is continuously updated based on the data input and control signals.\n\n Module header:\n\nmodule updateCRC16 (rstCRC, CRCResult, CRCEn, dataIn, ready, clk, rst);\n [/INST]\n", "output": "input rstCRC; \n input CRCEn; \n input [7:0] dataIn; \n input clk; \n input rst; \n output [15:0] CRCResult; \n output ready; \n wire rstCRC; \n wire CRCEn; \n wire [7:0] dataIn; \n wire clk; \n wire rst; \n reg [15:0] CRCResult; \n reg ready; \n reg doUpdateCRC; \n reg [7:0] data; \n reg [3:0] i; \n always @(posedge clk) \n begin \n  if (rst == 1'b1 || rstCRC == 1'b1) begin \n  doUpdateCRC <= 1'b0; \n  i <= 4'h0; \n  CRCResult <= 16'hffff; \n  ready <= 1'b1; \n  end \n  else \n  begin \n  if (doUpdateCRC == 1'b0) \n  begin \n  if (CRCEn == 1'b1) begin \n  doUpdateCRC <= 1'b1; \n  data <= dataIn; \n  ready <= 1'b0; \n  end \n  end \n  else begin \n  i <= i + 1'b1; \n  if ( (CRCResult[0] ^ data[0]) == 1'b1) begin \n  CRCResult <= {1'b0, CRCResult[15:1]} ^ 16'ha001; \n  end \n  else begin \n  CRCResult <= {1'b0, CRCResult[15:1]}; \n  end \n  data <= {1'b0, data[7:1]}; \n  if (i == 4'h7) \n  begin \n  doUpdateCRC <= 1'b0; \n  i <= 4'h0; \n  ready <= 1'b1; \n  end \n  end \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe `fscmos` module processes video signals. It determines the active video period based on the input cmos signals, and outputs vid_active_video accordingly. The vid_data output is derived from cmos_data with zero-padding if the input width is less than the output width, and by slicing if the input width is greater than or equal to the output width. Additionally, it generates vid_hblank, vid_hsync, vid_vblank, and vid_vsync signals based on the cmos inputs.\n\n Module header:\n\nmodule fscmos # (parameter integer C_IN_WIDTH = 8,parameter integer C_OUT_WIDTH = 8) (input wire cmos_pclk,input wire cmos_vsync,input wire cmos_href,input wire [C_IN_WIDTH-1:0] cmos_data,output wire vid_active_video,output wire[C_OUT_WIDTH-1:0] vid_data,output wire vid_hblank,output wire vid_hsync,output wire vid_vblank,output wire vid_vsync);\n [/INST]\n", "output": "assign vid_active_video= (cmos_href && ~cmos_vsync); \n  assign vid_hblank = ~cmos_href; \n  assign vid_hsync = vid_hblank; \n  assign vid_vsync = vid_vblank; \n  assign vid_vblank = ~cmos_vsync; \n generate \n if (C_IN_WIDTH < C_OUT_WIDTH) begin: in_lt_out \n  assign vid_data = {cmos_data, {(C_OUT_WIDTH - C_IN_WIDTH){1'b0}}}; \n end \n else begin: in_ge_out \n  assign vid_data = cmos_data[C_IN_WIDTH-1:C_IN_WIDTH-C_OUT_WIDTH]; \n end \n endgenerate \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"RetimeWrapper_58\" includes a retime shift register, which re-times the input data and then outputs the re-timed data. It has input ports for clock, reset, and a 64-bit input data \"io_in\", and an output port for the re-timed 64-bit data \"io_out\". Inside the module, it instantiates a \"RetimeShiftRegister\" module with 64-bit input, output, flow, reset, and clock wires. The module connects its input \"io_in\" to the shift register's input \"sr_in\", sets the shift register's flow to 1, connects its reset to the shift register's reset, and its clock to the shift register's clock. The shift register's output \"sr_out\" is connected to the module's output \"io_out\".\n\n Module header:\n\nmodule RetimeWrapper_58(input clock,input reset,input [63:0] io_in,output [63:0] io_out);\n [/INST]\n", "output": "wire [63:0] sr_out; \n  wire [63:0] sr_in; \n  wire sr_flow; \n  wire sr_reset; \n  wire sr_clock; \n RetimeShiftRegister #(.WIDTH(64), .STAGES(1)) sr (.out(sr_out),.in(sr_in),.flow(sr_flow),.reset(sr_reset),.clock(sr_clock)); \n  assign io_out = sr_out; \n  assign sr_in = io_in; \n  assign sr_flow = 1'h1; \n  assign sr_reset = reset; \n  assign sr_clock = clock; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a sampler that processes input data based on clock edges and control signals. It has inputs for the clock, external clock mode, write divider, configuration data, valid input, and data input. It also has outputs for the valid output, data output, and a ready signal. \n\nThe module uses registers to store the current state and control the sampling process. The sampling logic is triggered by the positive edge of the clock signal. It updates the state based on various conditions, such as the external clock mode, the write divider enable, and the counter status. The ready signal is updated based on the write divider and counter status.\n\nOverall, this module functions as a sampler with configurable sampling and control parameters to process input data and generate output based on the defined logic.\n\n Module header:\n\nmodule sampler (clock, extClock_mode,wrDivider, config_data,validIn, dataIn,validOut, dataOut, ready50);\n [/INST]\n", "output": "input clock; \n input extClock_mode; \n input wrDivider; \n input [23:0] config_data; \n input validIn; \n input [31:0] dataIn; \n output validOut; \n output [31:0] dataOut; \n output ready50; \n parameter TRUE = 1'b1; \n parameter FALSE = 1'b0; \n reg validOut, next_validOut; \n reg [31:0] dataOut, next_dataOut; \n reg ready50, next_ready50; \n reg [23:0] divider, next_divider; \n reg [23:0] counter, next_counter; \n wire counter_zero = ~|counter; \n initial \n begin \n  divider = 0; \n  counter = 0; \n  validOut = 0; \n  dataOut = 0; \n end \n always @ (posedge clock) \n begin \n  divider = next_divider; \n  counter = next_counter; \n  validOut = next_validOut; \n  dataOut = next_dataOut; \n end \n always @* \n begin \n  #1; \n  next_divider = divider; \n  next_counter = counter; \n  next_validOut = FALSE; \n  next_dataOut = dataOut; \n  if (extClock_mode) \n  begin \n  next_validOut = validIn; \n  next_dataOut = dataIn; \n  end \n  else if (validIn && counter_zero) \n  begin \n  next_validOut = TRUE; \n  next_dataOut = dataIn; \n  end \n  if (wrDivider) \n  begin \n  next_divider = config_data[23:0]; \n  next_counter = next_divider; \n  next_validOut = FALSE; \n  end \n  else if (validIn) \n  if (counter_zero) \n  next_counter = divider; \n  else next_counter = counter-1'b1; \n end \n always @(posedge clock) \n begin \n  ready50 = next_ready50; \n end \n always @* \n begin \n  #1; \n  next_ready50 = ready50; \n  if (wrDivider) \n  next_ready50 = FALSE; \n  else if (counter_zero) \n  next_ready50 = TRUE; \n  else if (counter == divider[23:1]) \n  next_ready50 = FALSE; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a synchronizer with a parameter ADDRSIZE. It has an output wq2_rptr, inputs rptr, wclk, and wrst_n. Inside, it uses two registers wq1_rptr and wq2_rptr to synchronize the rptr input to the wclk domain. The registers are updated on the positive edge of wclk or the negative edge of wrst_n. When wrst_n is low, both wq2_rptr and wq1_rptr are reset to 0, otherwise, wq2_rptr is updated with the value of wq1_rptr and rptr is concatenated.\n\n Module header:\n\nmodule sync_r2w #(parameter ADDRSIZE = 3) (output reg [ADDRSIZE:0] wq2_rptr,input [ADDRSIZE:0] rptr,input wclk, wrst_n);\n [/INST]\n", "output": "reg [ADDRSIZE:0] wq1_rptr; \n  always @(posedge wclk or negedge wrst_n) \n  if (!wrst_n) {wq2_rptr,wq1_rptr} <= 0; \n  else {wq2_rptr,wq1_rptr} <= {wq1_rptr,rptr}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes a 5-bit input \"d\" and an enable signal \"en\" and assigns the value of \"d\" to the lower 5 bits of the output \"q\" when the enable signal is asserted. The upper 27 bits of the output are always set to 0.\n\n Module header:\n\nmodule zeroer(d,en,q);\n [/INST]\n", "output": "input en; \n input [4:0] d; \n output [31:0] q; \n assign q[4:0]= (en) ? d : 0; \n assign q [31:05] = 0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a design for an XDCT (crossbar Discrete Cosine Transform) module. It consists of input and output signals, as well as several internal wires and registers to handle the data flow and control signals. The module includes instances of DCT stage 1, DCT stage 2, and a transpose memory, which are interconnected to perform the necessary computation for the XDCT operation. The module implements logic for controlling the data flow between these instances and also includes a register for storing the last input.\n\n Module header:\n\nmodule xdct ( clk,en,start,xin,last_in,pre_first_out,dv,d_out);\n [/INST]\n", "output": "input clk; \n  input en,start; \n  input [9:0] xin; \n  output last_in; \n  output pre_first_out; \n  output dv; \n  output [12:0] d_out; \n  wire clk, en,start,dv,stage1_done, tm_page,tm_we; \n  wire [9:0] xin; \n  wire [12:0] d_out; \n  wire [6:0] tm_ra; \n  wire [6:0] tm_wa; \n  wire [15:0] tm_out; \n  wire [15:0] tm_di; \n  reg last_in; \n  wire pre_first_out; \n  always @ (posedge clk) last_in <= (tm_wa[5:0]== 6'h30); \n dct_stage1 i_dct_stage1( .clk(clk),.en(en),.start(start),.xin(xin),.we(tm_we),.wr_cntr(tm_wa),.z_out(tm_di[15:0]),.page(tm_page),.done(stage1_done)); \n dct_stage2 i_dct_stage2( .clk(clk),.en(en),.start(stage1_done),.page(tm_page),.rd_cntr(tm_ra[6:0]),.tdin(tm_out[15:0]),.endv(pre_first_out),.dv(dv),.dct2_out(d_out[12:0])); \n RAMB16_S18_S18 i_transpose_mem (.DOA(),.DOPA(),.ADDRA({3'b0,tm_wa[6:0]}),.CLKA(clk),.DIA(tm_di[15:0]),.DIPA(2'b0),.ENA(1'b1),.SSRA(1'b0),.WEA(tm_we),.DOB(tm_out[15:0]),.DOPB(),.ADDRB({3'b0,tm_ra[6:0]}),.CLKB(clk),.DIB(16'b0),.DIPB(2'b0),.ENB(1'b1),.SSRB(1'b0),.WEB(1'b0)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a bias generator. It has inputs for din, mainclk, updateclk, capture, and update, and an output dout. The module contains registers for temporary output (dout_tmp), a generator (generator_reg), and an update (update_reg). On the rising edge of the main clock, the module captures and updates the registers based on the values of capture and update. On the rising edge of the update clock, it updates the update register based on the values of capture and update. Finally, it asserts the output dout based on the value of dout_tmp.\n\n Module header:\n\nmodule stratixv_bias_generator (din,mainclk,updateclk,capture,update,dout);\n [/INST]\n", "output": "input din; \n input mainclk; \n input updateclk; \n input capture; \n input update; \n output dout; \n parameter TOTAL_REG = 202; \n reg dout_tmp; \n reg generator_reg [TOTAL_REG - 1:0]; \n reg update_reg [TOTAL_REG - 1:0]; \n integer i; \n initial \n begin \n  dout_tmp <= 'b0; \n  for (i = 0; i < TOTAL_REG; i = i + 1) \n  begin \n  generator_reg [i] <= 'b0; \n  update_reg [i] <= 'b0; \n  end \n end \n always @(posedge mainclk) \n begin \n  if ((capture == 'b0) && (update == 'b1)) \n  begin \n  for (i = 0; i < TOTAL_REG; i = i + 1) \n  begin \n  generator_reg[i] <= update_reg[i]; \n  end \n  end \n end \n always @(posedge updateclk) \n begin \n  dout_tmp <= update_reg[TOTAL_REG - 1]; \n  if ((capture == 'b0) && (update == 'b0)) \n  begin \n  for (i = (TOTAL_REG - 1); i > 0; i = i - 1) \n  begin \n  update_reg[i] <= update_reg[i - 1]; \n  end \n  update_reg[0] <= din; \n  end \n  else if ((capture == 'b1) && (update == 'b0)) \n  begin \n  for (i = 0; i < TOTAL_REG; i = i + 1) \n  begin \n  update_reg[i] <= generator_reg[i]; \n  end \n  end \n end \n and (dout, dout_tmp, 1'b1); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a memory block with 32 registers, each of width B bits. The module can read from and write to these registers using the w_addr and r_addr1, r_addr2 inputs. When the wr_en signal is asserted, the module writes the data from w_data into the register specified by w_addr. The module also provides the ability to read the data from the specified registers and outputs them as r_data1, r_data2, and reg_0 to reg_31. The memory is synchronized with the clock signal and can be reset using the reset input.\n\n Module header:\n\nmodule registers_memory #(parameter B=32,W=5) (input wire clk,input wire reset,input wire wr_en,input wire [W-1:0] w_addr, r_addr1, r_addr2,input wire [B-1:0] w_data,output wire [B-1:0] r_data1, r_data2,output wire [B-1:0] reg_0,output wire [B-1:0] reg_1,output wire [B-1:0] reg_2,output wire [B-1:0] reg_3,output wire [B-1:0] reg_4,output wire [B-1:0] reg_5,output wire [B-1:0] reg_6,output wire [B-1:0] reg_7,output wire [B-1:0] reg_8,output wire [B-1:0] reg_9,output wire [B-1:0] reg_10,output wire [B-1:0] reg_11,output wire [B-1:0] reg_12,output wire [B-1:0] reg_13,output wire [B-1:0] reg_14,output wire [B-1:0] reg_15,output wire [B-1:0] reg_16,output wire [B-1:0] reg_17,output wire [B-1:0] reg_18,output wire [B-1:0] reg_19,output wire [B-1:0] reg_20,output wire [B-1:0] reg_21,output wire [B-1:0] reg_22,output wire [B-1:0] reg_23,output wire [B-1:0] reg_24,output wire [B-1:0] reg_25,output wire [B-1:0] reg_26,output wire [B-1:0] reg_27,output wire [B-1:0] reg_28,output wire [B-1:0] reg_29,output wire [B-1:0] reg_30,output wire [B-1:0] reg_31);\n [/INST]\n", "output": "reg [B-1:0] array_reg [0:31]; \n  integer i; \n  always @(negedge clk,posedge reset) \n  begin \n  if (reset) \n  begin \n  for (i=0;i<32;i=i+1) \n  begin \n  array_reg[i] <= 0; \n  end \n  end \n  else if (wr_en) \n  array_reg[w_addr] <= w_data; \n  end \n  assign r_data1 = array_reg[r_addr1]; \n  assign r_data2 = array_reg[r_addr2]; \n  assign reg_0 = array_reg[0]; \n  assign reg_1 = array_reg[1]; \n  assign reg_2 = array_reg[2]; \n  assign reg_3 = array_reg[3]; \n  assign reg_4 = array_reg[4]; \n  assign reg_5 = array_reg[5]; \n  assign reg_6 = array_reg[6]; \n  assign reg_7 = array_reg[7]; \n  assign reg_8 = array_reg[8]; \n  assign reg_9 = array_reg[9]; \n  assign reg_10 = array_reg[10]; \n  assign reg_11 = array_reg[11]; \n  assign reg_12 = array_reg[12]; \n  assign reg_13 = array_reg[13]; \n  assign reg_14 = array_reg[13]; \n  assign reg_15 = array_reg[15]; \n  assign reg_16 = array_reg[16]; \n  assign reg_17 = array_reg[17]; \n  assign reg_18 = array_reg[18]; \n  assign reg_19 = array_reg[19]; \n  assign reg_20 = array_reg[20]; \n  assign reg_21 = array_reg[21]; \n  assign reg_22 = array_reg[22]; \n  assign reg_23 = array_reg[23]; \n  assign reg_24 = array_reg[24]; \n  assign reg_25 = array_reg[25]; \n  assign reg_26 = array_reg[26]; \n  assign reg_27 = array_reg[27]; \n  assign reg_28 = array_reg[28]; \n  assign reg_29 = array_reg[29]; \n  assign reg_30 = array_reg[30]; \n  assign reg_31 = array_reg[31]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `bcd_add_digit` takes two 4-bit BCD numbers `rx_a` and `rx_b` as input, and a carry `rx_c`. It computes the sum `tx_s` of the inputs and the output carry `tx_c`. The sum is calculated by adding `rx_a`, `rx_b`, and `rx_c`, and then adjusting the result to a valid BCD number if it exceeds 9. The output `tx_s` takes the lower 4 bits of the adjusted sum, while `tx_c` indicates if the sum exceeds 9.\n\n Module header:\n\nmodule bcd_add_digit (input [3:0] rx_a,input [3:0] rx_b,input rx_c,output [3:0] tx_s,output tx_c);\n [/INST]\n", "output": "wire [4:0] s = rx_a + rx_b + rx_c; \n  wire [4:0] s_wrap = s + 5'd6; \n  assign tx_s = (s > 5'd9) ? s_wrap[3:0] : s[3:0]; \n  assign tx_c = s > 5'd9; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"sky130_fd_sc_ms__dfxbp\" implements a D flip-flop with delayed inputs. It has input signals for clock (CLK) and data (D), as well as power and ground signals (VPWR, VGND). It also has output signals Q and its complement Q_N. Inside the module, it instantiates a D flip-flop (dff0), a buffer (buf0), and a NOT gate (not0). The D flip-flop has delayed inputs (D_delayed and CLK_delayed), and it connects the buffer's output (buf_Q) to the Q output. Additionally, it assigns the VPWR signal to the awake signal, and it declares a wire for the buffer (buf_Q) and a register for the notifier.\n\n Module header:\n\nmodule sky130_fd_sc_ms__dfxbp (Q ,Q_N ,CLK ,D ,VPWR,VGND,VPB ,VNB);\n [/INST]\n", "output": "output Q ; \n  output Q_N ; \n  input CLK ; \n  input D ; \n  input VPWR; \n  input VGND; \n  input VPB ; \n  input VNB ; \n  wire buf_Q ; \n  reg notifier ; \n  wire D_delayed ; \n  wire CLK_delayed; \n  wire awake ; \n  sky130_fd_sc_ms__udp_dff$P_pp$PG$N dff0 (buf_Q , D_delayed, CLK_delayed, notifier, VPWR, VGND); \n  assign awake = ( VPWR === 1'b1 ); \n  buf buf0 (Q , buf_Q ); \n  not not0 (Q_N , buf_Q ); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module is a Xilinx DDR2 WB IF cache address register. It takes an input address and can validate or invalidate it. The module has parameters for defining the width of the address components. It stores a cached address and detects cache hits. It also provides a valid address output and resets the cached address and validity based on the clock and reset signals.\n\n Module header:\n\nmodule xilinx_ddr2_wb_if_cache_adr_reg (adr_i, validate, invalidate,cached_adr_o, cache_hit, adr_valid,clk, rst);\n [/INST]\n", "output": "parameter full_adr_width = 32; \n  parameter word_adr_width = 2; \n  parameter line_adr_width = 8; \n  parameter tag_width = full_adr_width - line_adr_width - word_adr_width; \n  input [full_adr_width-1: word_adr_width + line_adr_width] adr_i; \n  input validate; \n  input invalidate; \n  output [full_adr_width-1: word_adr_width + line_adr_width] cached_adr_o; \n  output cache_hit; \n  output reg adr_valid; \n  input clk, rst; \n  reg [tag_width-1:0] cached_adr; \n  assign cached_adr_o = cached_adr; \n  always @(posedge clk) \n  if (rst) \n  cached_adr <= 0; \n  else if (validate) \n  cached_adr <= adr_i; \n  always @(posedge clk) \n  if (rst) \n  adr_valid <= 0; \n  else if (validate) \n  adr_valid <= 1; \n  else if (invalidate) \n  adr_valid <= 0; \n  assign cache_hit = (adr_i == cached_adr); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a 5-bit convolutional arbitration with a state machine. It uses a system clock and reset signal, and takes in a 5-bit request signal and outputs a 3-bit grant signal. The state machine has 5 states, and transitions between them based on the active requests. When a request is granted, the corresponding state is output on the grant signal.\n\n Module header:\n\nmodule conbus_arb5(input sys_clk,input sys_rst,input [4:0] req,output [2:0] gnt);\n [/INST]\n", "output": "reg [2:0] state; \n reg [2:0] next_state; \n assign gnt = state; \n always @(posedge sys_clk) begin \n  if(sys_rst) \n  state <= 3'd0; \n  else \n  state <= next_state; \n end \n always @(*) begin \n  next_state = state; \n  case(state) \n  3'd0: begin \n  if(~req[0]) begin \n  if(req[1]) next_state = 3'd1; \n  else if(req[2]) next_state = 3'd2; \n  else if(req[3]) next_state = 3'd3; \n  else if(req[4]) next_state = 3'd4; \n  end \n  end \n  3'd1: begin \n  if(~req[1]) begin \n  if(req[2]) next_state = 3'd2; \n  else if(req[3]) next_state = 3'd3; \n  else if(req[4]) next_state = 3'd4; \n  else if(req[0]) next_state = 3'd0; \n  end \n  end \n  3'd2: begin \n  if(~req[2]) begin \n  if(req[3]) next_state = 3'd3; \n  else if(req[4]) next_state = 3'd4; \n  else if(req[0]) next_state = 3'd0; \n  else if(req[1]) next_state = 3'd1; \n  end \n  end \n  3'd3: begin \n  if(~req[3]) begin \n  if(req[4]) next_state = 3'd4; \n  else if(req[0]) next_state = 3'd0; \n  else if(req[1]) next_state = 3'd1; \n  else if(req[2]) next_state = 3'd2; \n  end \n  end \n  3'd4: begin \n  if(~req[4]) begin \n  if(req[0]) next_state = 3'd0; \n  else if(req[1]) next_state = 3'd1; \n  else if(req[2]) next_state = 3'd2; \n  else if(req[3]) next_state = 3'd3; \n  end \n  end \n  endcase \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"BusClient\" is a configurable bus client that communicates over a bus with a maximum number of devices, a specific width for data and device addressing, and a buffer size. It interfaces with a BusReader and a BusWriter. It has inputs for client data in, client source address, client read next, and bus voice, and outputs for client data out, client destination address, client read next, client send next, client input buffer empty, and client input buffer full. The module includes a clocked block that prints the number of words in the input and output buffers.\n\n Module header:\n\nmodule BusClient #(parameter bus_width=32,parameter bus_max_devices=16,parameter bus_buffer_size=32,parameter device_id=1) (input clk,inout [bus_width-1:0] bus_data,inout [bus_max_devices-1:0] bus_receiver,inout [bus_max_devices-1:0] bus_write_request,inout [bus_max_devices-1:0] bus_buffer_full,input [bus_max_devices-1:0] bus_voice,output [bus_width-1:0] client_data_in,output [bus_max_devices-1:0] client_source_addr,input [bus_width-1:0] client_data_out,input [bus_max_devices-1:0] client_destination_addr,input client_read_next,input client_send_next,output client_input_buffer_empty,output client_input_buffer_full,output client_output_buffer_empty,output client_output_buffer_full);\n [/INST]\n", "output": "BusReader \n #(.bus_width(bus_width),.bus_max_devices(bus_max_devices),.bus_buffer_size(bus_buffer_size),.device_id(device_id)) reader \n (clk,bus_data,bus_receiver,bus_buffer_full,bus_voice,client_data_in,client_source_addr,client_read_next,client_input_buffer_empty,client_input_buffer_full); \n  BusWriter \n #(.bus_width(bus_width),.bus_max_devices(bus_max_devices),.bus_buffer_size(bus_buffer_size),.device_id(device_id)) writer \n (clk,bus_data,bus_receiver,bus_buffer_full,bus_write_request,bus_voice,client_data_out,client_destination_addr,client_send_next,client_output_buffer_empty,client_output_buffer_full); \n  always @(negedge clk) begin \n  $display(\"BusClient %d: words in in_buffer: %d\",device_id,reader.buffer.words_inside); \n  $display(\"BusClient %d: words in out_buffer: %d\",device_id,writer.buffer.words_inside); \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"PhotonBlock1\" is a synchronous module with clock, reset, and enable inputs, as well as inputs i_x, i_y, and i_z, and outputs o_x, o_y, and o_z. It features a synchronous reset and updates the outputs o_x, o_y, and o_z based on the inputs i_x, i_y, and i_z when the enable signal is asserted and the clock signal transitions.\n\n Module header:\n\nmodule PhotonBlock1(clock,reset,enable,i_x,i_y,i_z,o_x,o_y,o_z);\n [/INST]\n", "output": "input clock; \n input reset; \n input enable; \n input [`BIT_WIDTH-1:0] i_x; \n input [`BIT_WIDTH-1:0] i_y; \n input [`BIT_WIDTH-1:0] i_z; \n output [`BIT_WIDTH-1:0] o_x; \n output [`BIT_WIDTH-1:0] o_y; \n output [`BIT_WIDTH-1:0] o_z; \n wire clock; \n wire reset; \n wire enable; \n wire [`BIT_WIDTH-1:0] i_x; \n wire [`BIT_WIDTH-1:0] i_y; \n wire [`BIT_WIDTH-1:0] i_z; \n reg [`BIT_WIDTH-1:0] o_x; \n reg [`BIT_WIDTH-1:0] o_y; \n reg [`BIT_WIDTH-1:0] o_z; \n always @ (posedge clock) \n  if(reset) begin \n  o_x <= {`BIT_WIDTH{1'b0}} ; \n  o_y <= {`BIT_WIDTH{1'b0}}; \n  o_z <= {`BIT_WIDTH{1'b0}}; \n  end else if(enable) begin \n  o_x <= i_x; \n  o_y <= i_y; \n  o_z <= i_z; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements the calculation of a CRC-16 checksum for a given input data. The module has inputs for the initial CRC value (crc_in) and the data to be checked (din), and an output for the computed CRC-16 checksum (crc_out). The module computes the checksum based on the input data and initial CRC value, and assigns the calculated values to the output vector crc_out.\n\n Module header:\n\nmodule usbf_crc16(crc_in, din, crc_out);\n [/INST]\n", "output": "input [15:0] crc_in; \n input [7:0] din; \n output [15:0] crc_out; \n assign crc_out[0] = din[7] ^ din[6] ^ din[5] ^ din[4] ^ din[3] ^ \n  din[2] ^ din[1] ^ din[0] ^ crc_in[8] ^ crc_in[9] ^ \n  crc_in[10] ^ crc_in[11] ^ crc_in[12] ^ crc_in[13] ^ \n  crc_in[14] ^ crc_in[15]; \n assign crc_out[1] = din[7] ^ din[6] ^ din[5] ^ din[4] ^ din[3] ^ din[2] ^ \n  din[1] ^ crc_in[9] ^ crc_in[10] ^ crc_in[11] ^ \n  crc_in[12] ^ crc_in[13] ^ crc_in[14] ^ crc_in[15]; \n assign crc_out[2] = din[1] ^ din[0] ^ crc_in[8] ^ crc_in[9]; \n assign crc_out[3] = din[2] ^ din[1] ^ crc_in[9] ^ crc_in[10]; \n assign crc_out[4] = din[3] ^ din[2] ^ crc_in[10] ^ crc_in[11]; \n assign crc_out[5] = din[4] ^ din[3] ^ crc_in[11] ^ crc_in[12]; \n assign crc_out[6] = din[5] ^ din[4] ^ crc_in[12] ^ crc_in[13]; \n assign crc_out[7] = din[6] ^ din[5] ^ crc_in[13] ^ crc_in[14]; \n assign crc_out[8] = din[7] ^ din[6] ^ crc_in[0] ^ crc_in[14] ^ crc_in[15]; \n assign crc_out[9] = din[7] ^ crc_in[1] ^ crc_in[15]; \n assign crc_out[10] = crc_in[2]; \n assign crc_out[11] = crc_in[3]; \n assign crc_out[12] = crc_in[4]; \n assign crc_out[13] = crc_in[5]; \n assign crc_out[14] = crc_in[6]; \n assign crc_out[15] = din[7] ^ din[6] ^ din[5] ^ din[4] ^ din[3] ^ din[2] ^ \n  din[1] ^ din[0] ^ crc_in[7] ^ crc_in[8] ^ crc_in[9] ^ \n  crc_in[10] ^ crc_in[11] ^ crc_in[12] ^ crc_in[13] ^ \n  crc_in[14] ^ crc_in[15]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"performance_counters\" is designed to track the number of DMA (Direct Memory Access) read and write operations. It uses the input signals clk, rst, wr_dma_start, wr_dma_done, rd_dma_start, rd_dma_done, read_last, and write_last to control and calculate the DMA counts. \n\nThe module utilizes rising_edge_detect instances to detect the rising edges of the DMA start and done signals. It also maintains write_active and read_active registers to track the state of the write and read operations.\n\nBased on the input signals and state of the module, it increments the dma_wr_count and dma_rd_count when the write_active and read_active signals are asserted, respectively.\n\nFurthermore, the module uses a combination of the input signals and states to determine when to reset the write and read counts.\n\nIn summary, the \"performance_counters\" module provides a mechanism to accurately count the number of DMA read and write operations based on the input signals and their respective states.\n\n Module header:\n\nmodule performance_counters(input clk,input rst,input wr_dma_start,input wr_dma_done,input rd_dma_start,input rd_dma_done,output reg [31:0] dma_wr_count,output reg [31:0] dma_rd_count,input read_last,input write_last);\n [/INST]\n", "output": "wire wr_dma_start_one; \n wire rd_dma_start_one; \n wire wr_dma_done_one; \n wire rd_dma_done_one; \n reg write_active, read_active; \n rising_edge_detect wr_dma_start_one_inst(.clk(clk),.rst(rst),.in(wr_dma_start),.one_shot_out(wr_dma_start_one)); \n rising_edge_detect rd_dma_start_one_inst(.clk(clk),.rst(rst),.in(rd_dma_start),.one_shot_out(rd_dma_start_one)); \n rising_edge_detect wr_dma_done_one_inst(.clk(clk),.rst(rst),.in(wr_dma_done),.one_shot_out(wr_dma_done_one)); \n rising_edge_detect rd_dma_done_one_inst(.clk(clk),.rst(rst),.in(rd_dma_done),.one_shot_out(rd_dma_done_one)); \n always@(posedge clk)begin \n  if(rst)begin \n  write_active <= 1'b0; \n  end else if(wr_dma_start_one | wr_dma_done_one)begin \n  case({wr_dma_start_one, wr_dma_done_one, write_last}) \n  3'b000,3'b001,3'b110,3'b111:begin \n  write_active <= write_active; \n  end \n  3'b011:begin \n  write_active <= 1'b0; \n  end \n  3'b100,3'b101,3'b010:begin \n  write_active <= 1'b1; \n  end \n  default:begin write_active <= 1'b0;end \n  endcase \n  end else begin \n  write_active <= write_active; \n  end \n end \n always@(posedge clk)begin \n  if(rst)begin \n  read_active <= 1'b0; \n  end else if(rd_dma_start_one | rd_dma_done_one)begin \n  case({rd_dma_start_one, rd_dma_done_one, read_last}) \n  3'b000,3'b001,3'b110,3'b111:begin \n  read_active <= read_active; \n  end \n  3'b011:begin \n  read_active <= 1'b0; \n  end \n  3'b100,3'b101,3'b010:begin \n  read_active <= 1'b1; \n  end \n  default:begin read_active <= 1'b0;end \n  endcase \n  end else begin \n  read_active <= read_active; \n  end \n end \n always@(posedge clk)begin \n  if(rst) \n  dma_wr_count[31:0] <= 0; \n  else if(write_active) \n  dma_wr_count <= dma_wr_count + 1; \n end \n always@(posedge clk)begin \n  if(rst) \n  dma_rd_count[31:0] <= 0; \n  else if(read_active) \n  dma_rd_count <= dma_rd_count + 1; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a full adder, which takes two input bits (wA and wB) and a carry-in bit (wCi), and produces a sum bit (wR) and a carry-out bit (wCo) as outputs based on the addition logic.\n\n Module header:\n\nmodule FULL_ADDER (input wire wA,wB,wCi,output wire wR ,output wire wCo);\n [/INST]\n", "output": "assign {wCo,wR} = wA + wB + wCi; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a divider circuit. It takes a 32-bit divident and a 32-bit divisor as input and produces a 32-bit quotient as output. The circuit uses sequential logic to calculate the quotient and remainder, considering various scenarios such as handling zero values and performing bit shifts. The module also uses loops and conditional statements to iterate through the dividend and divisor, performing division operations until the quotient is obtained.\n\n Module header:\n\nmodule divider(divident,divisor,quotient);\n [/INST]\n", "output": "input wire [31:0] divident; \n input wire [31:0] divisor; \n output reg [31:0] quotient; \n reg [47:0]tmpDivident; \n reg [23:0]tmpDivisor; \n reg [25:0]tmpQuotient; \n reg [25:0] remainder; \n reg [8:0]exponent; \n reg [8:0]tmp; \n integer i; \n always @(divident or divisor) \n  begin \n  quotient=0; \n  remainder=0; \n  tmpDivident={1,divident[22:0],24'b0}; \n  tmpDivisor={1,divisor[22:0]}; \n  exponent=divident[30:23]+128-divisor[30:23]; \n  tmpQuotient=0; \n  tmp=divident[30:23]+127; \n  if(tmp<divisor[30:23]) \n  begin \n  quotient=0; \n  end \n  else if(tmp-divisor[30:23]>254) \n  begin \n  quotient={divident[31]^divisor[31],8'b1,23'b0}; \n  end \n  else if(divident==0||divisor[30:23]-255==0) \n  begin \n  quotient=0; \n  end \n  else if(divident[30:23]==255) \n  begin \n  quotient=divident; \n  end \n  else if(divisor==0) \n  begin \n  quotient={divident[31],8'b1,23'b0}; \n  end \n  else \n  begin \n  for (i=48;i>0;i=i-1) \n  begin \n  remainder={remainder[25:0],tmpDivident[i-1]}; \n  tmpQuotient=tmpQuotient<<1; \n  if(remainder>=tmpDivisor) \n  begin \n  tmpQuotient=tmpQuotient+1; \n  remainder=remainder-tmpDivisor; \n  end \n  end \n  for(i=3;i>0;i=i-1) \n  begin \n  if(tmpQuotient[25]!=1) \n  begin \n  tmpQuotient=tmpQuotient*2; \n  exponent=exponent-1; \n  end \n  end \n  quotient={divident[31]^divisor[31],exponent[7:0],tmpQuotient[24:2]}; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module represents a 64x128 Single Port Static RAM (SRAM) with a single read and write port. The module has input ports for address (A), chip enable (CE), write enable (WEB), output enable (OEB), and chip select (CSB), as well as an input data port (I) and an output data port (O). Inside the module, there is a 128x64 array of registers representing the memory cells. The behavior of the module is driven by an always block sensitive to the positive edge of the chip enable signal. The module performs write operations when the chip select is enabled and the write enable is active, and read operations when the chip select is enabled and the output enable is active. When a write operation is performed, the input data is written into the memory cell at the specified address, and when a read operation is performed, the data from the memory cell at the specified address is output.\n\n Module header:\n\nmodule SRAM1RW64x128 (input [6:0] A,input CE,input WEB,input OEB,input CSB,input [127:0] I,output reg [127:0] O);\n [/INST]\n", "output": "reg [127:0] ram [63:0]; \n always @(posedge CE) begin \n  if (~CSB) begin \n  if (~WEB) begin \n  ram[A] <= I; \n  end \n  if (~OEB) begin \n  O <= ram[A]; \n  end \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is designed to control SRAM access based on input commands. It takes in various control signals such as read/write enable, address, data, and user-defined information. These inputs are packed into a single bus using a buffer. The module also includes clock gating logic and a 1-cycle SRAM control module to manage SRAM access. The SRAM control active signal is determined by the input command valid, buffer command valid, SRAM active, and command response valid signals.\n\n Module header:\n\nmodule sirv_sram_icb_ctrl #(parameter DW = 32,parameter MW = 4,parameter AW = 32,parameter AW_LSB = 3,parameter USR_W = 3)(output sram_ctrl_active,input tcm_cgstop,input i_icb_cmd_valid,output i_icb_cmd_ready,input i_icb_cmd_read,input [AW-1:0] i_icb_cmd_addr,input [DW-1:0] i_icb_cmd_wdata,input [MW-1:0] i_icb_cmd_wmask,input [USR_W-1:0] i_icb_cmd_usr,output i_icb_rsp_valid,input i_icb_rsp_ready,output [DW-1:0] i_icb_rsp_rdata,output [USR_W-1:0] i_icb_rsp_usr,output ram_cs,output ram_we,output [AW-AW_LSB-1:0] ram_addr,output [MW-1:0] ram_wem,output [DW-1:0] ram_din,input [DW-1:0] ram_dout,output clk_ram,input test_mode,input clk,input rst_n);\n [/INST]\n", "output": "wire byp_icb_cmd_valid; \n  wire byp_icb_cmd_ready; \n  wire byp_icb_cmd_read; \n  wire [AW-1:0] byp_icb_cmd_addr; \n  wire [DW-1:0] byp_icb_cmd_wdata; \n  wire [MW-1:0] byp_icb_cmd_wmask; \n  wire [USR_W-1:0] byp_icb_cmd_usr; \n  localparam BUF_CMD_PACK_W = (AW+DW+MW+USR_W+1); \n  wire [BUF_CMD_PACK_W-1:0] byp_icb_cmd_o_pack; \n  wire [BUF_CMD_PACK_W-1:0] byp_icb_cmd_i_pack = { \n  i_icb_cmd_read, \n  i_icb_cmd_addr, \n  i_icb_cmd_wdata, \n  i_icb_cmd_wmask, \n  i_icb_cmd_usr \n  }; \n  assign { \n  byp_icb_cmd_read, \n  byp_icb_cmd_addr, \n  byp_icb_cmd_wdata, \n  byp_icb_cmd_wmask, \n  byp_icb_cmd_usr \n  } = byp_icb_cmd_o_pack; \n sirv_gnrl_bypbuf # (.DP(1),.DW(BUF_CMD_PACK_W)) u_byp_icb_cmd_buf(.i_vld(i_icb_cmd_valid),.i_rdy(i_icb_cmd_ready),.i_dat(byp_icb_cmd_i_pack),.o_vld(byp_icb_cmd_valid),.o_rdy(byp_icb_cmd_ready),.o_dat(byp_icb_cmd_o_pack),.clk (clk ),.rst_n(rst_n)); \n  wire sram_active; \n sirv_1cyc_sram_ctrl #(.DW (DW),.AW (AW),.MW (MW),.AW_LSB (AW_LSB),.USR_W (USR_W)) u_sirv_1cyc_sram_ctrl(.sram_ctrl_active (sram_active),.tcm_cgstop (tcm_cgstop),.uop_cmd_valid (byp_icb_cmd_valid),.uop_cmd_ready (byp_icb_cmd_ready),.uop_cmd_read (byp_icb_cmd_read ),.uop_cmd_addr (byp_icb_cmd_addr ),.uop_cmd_wdata (byp_icb_cmd_wdata),.uop_cmd_wmask (byp_icb_cmd_wmask),.uop_cmd_usr (byp_icb_cmd_usr ),.uop_rsp_valid (i_icb_rsp_valid),.uop_rsp_ready (i_icb_rsp_ready),.uop_rsp_rdata (i_icb_rsp_rdata),.uop_rsp_usr (i_icb_rsp_usr ),.ram_cs (ram_cs ),.ram_we (ram_we ),.ram_addr (ram_addr),.ram_wem (ram_wem ),.ram_din (ram_din ),.ram_dout (ram_dout),.clk_ram (clk_ram ),.test_mode(test_mode ),.clk (clk ),.rst_n(rst_n)); \n  assign sram_ctrl_active = \n  i_icb_cmd_valid \n  | byp_icb_cmd_valid \n  | sram_active \n | i_icb_rsp_valid; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a configurable Look-Up Table (LUT) that takes an input A and outputs Y. The LUT has a configurable WIDTH and LUT value. If the WIDTH is less than or equal to 1, a simple LUT is used to directly assign the LUT output based on the input LUT value. For larger WIDTH values, the input is split and passed to two smaller LUTs, with the output combined to form the final output. The logic for the LUT is implemented using a case statement to determine the output Y based on the combination of input A and the outputs of the smaller LUTs. The module essentially implements a flexible configurable LUT based on the input parameters.\n\n Module header:\n\nmodule \\$lut (A, Y);\n [/INST]\n", "output": "parameter WIDTH = 0; \n parameter LUT = 0; \n input [WIDTH-1:0] A; \n output reg Y; \n wire lut0_out, lut1_out; \n generate \n  if (WIDTH <= 1) begin:simple \n  assign {lut1_out, lut0_out} = LUT; \n  end else begin:complex \n  \\$lut #( .WIDTH(WIDTH-1), .LUT(LUT ) ) lut0 ( .A(A[WIDTH-2:0]), .Y(lut0_out) ); \n  \\$lut #( .WIDTH(WIDTH-1), .LUT(LUT >> (2**(WIDTH-1))) ) lut1 ( .A(A[WIDTH-2:0]), .Y(lut1_out) ); \n  end \n  if (WIDTH > 0) begin:lutlogic \n  always @* begin \n  casez ({A[WIDTH-1], lut0_out, lut1_out}) \n  3'b?11: Y = 1'b1; \n  3'b?00: Y = 1'b0; \n  3'b0??: Y = lut0_out; \n  3'b1??: Y = lut1_out; \n  default: Y = 1'bx; \n  endcase \n  end \n  end \n endgenerate \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a chroma filter for image processing. It takes fractional coordinates, pixel data A, B, C, D, and computes a weighted sum based on the fractional x value. The sum is then adjusted and stored in pel_out based on certain conditions, and the output is determined by the fractional coordinates.\n\n Module header:\n\nmodule mc_chroma_filter_hor(frac_x,frac_y,A,B,C,D,out);\n [/INST]\n", "output": "input [2:0] frac_x,frac_y; \n input [`PIXEL_WIDTH-1:0] A; \n input [`PIXEL_WIDTH-1:0] B; \n input [`PIXEL_WIDTH-1:0] C; \n input [`PIXEL_WIDTH-1:0] D; \n output[2*`PIXEL_WIDTH-1:0] out; \n reg signed [2*`PIXEL_WIDTH-1:0] sum; \n reg [`PIXEL_WIDTH-1: 0] pel_out; \n wire signed [2*`PIXEL_WIDTH-1:0] val_out; \n always @(*) begin \n  case(frac_x) \n  'd0: sum = (B*64); \n  'd1: sum = B*58 + C*10 - ((A + D) *2); \n  'd2: sum = B*54 + C*16 - ((A*2 + D) *2); \n  'd3: sum = B*46 + C*28 - (A*6 + D*4); \n  'd4: sum = 36*(B+C) - ((A+D)*4); \n  'd5: sum = C*46 + 28*B - (D*6 + A*4); \n  'd6: sum = C*54 + B*16 - (D*4 + A*2); \n  'd7: sum = C*58 + B*10 - ((A + D) *2); \n  endcase \n end \n assign val_out = sum - 'd8192; \n always @(*) begin \n  if (((sum+'d32) >> 6) < 0) \n  pel_out = 'd0; \n  else if (((sum+'d32) >> 6) > 255)begin \n  pel_out = 'd255; \n  end \n  else begin \n  pel_out = (sum+'d32) >> 6; \n  end \n end \n assign out = (frac_x == 0 || frac_y == 0 ) ? {{`PIXEL_WIDTH{1'b0}}, pel_out} : val_out; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module is designed to handle keyboard scan codes. It synchronizes the clock and data signals from the keyboard, then uses them as inputs to three sub-modules: Muestrear, ScanCodeControl, and ModuloDato. The Muestrear module samples the keyboard input, while the ScanCodeControl module coordinates the scanning process. The ModuloDato module processes the scanned data and generates the new scan code and parity information. The outputs of the module are the new scan code and an 8-bit scan code. The entire module operates on the rising edge of the clock and includes a reset signal for initialization.\n\n Module header:\n\nmodule ScanCodeModule(Clk,Reset, ClkKB, DataKB,NewScanCode, ScanCode);\n [/INST]\n", "output": "input Clk,Reset,ClkKB, DataKB; \n  wire NewDataKB; \n  output NewScanCode; \n  output [7:0] ScanCode; \n  wire Load, New,Borrar,EndTras,ParityCoherente; \n  reg ClkKB_syn, DataKB_syn ; \n always @(negedge Clk) begin \n  ClkKB_syn <= ClkKB; \n  DataKB_syn <= DataKB; \n end \n  Muestrear Muestrear (.Clk(Clk), .Reset(Reset),.ClkKB(ClkKB_syn), .NewDataKB(NewDataKB) ); \n  ScanCodeControl Control (.Clk(Clk), .Reset(Reset),.NewDataKB(NewDataKB), .Load(Load) , .New(New), .Borrar(Borrar), .EndTras(EndTras), .ParityCoherente(ParityCoherente)); \n  ModuloDato Dato (.Clk(Clk), .Reset(Reset), .DataKB(DataKB_syn), .NewScanCode(NewScanCode), .ScanCode(ScanCode), .Load(Load), .Borrar(Borrar), .EndTras(EndTras), .ParityCoherente(ParityCoherente),.New(New)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a testbench for a signal generator design. It uses parameters to configure the number of input ports and the period of the clock signal. The module generates clock and reset signals, and drives a request signal. It also monitors the grant signal and displays simulation start and end times. The behavior is controlled by the clock and request signals, and the simulation stops when the grant signal is received.\n\n Module header:\n\nmodule tb_signal_gen;\n [/INST]\n", "output": "parameter INPUT_PORTS = 3; \n  reg clk; \n  reg rst; \n  reg req; \n  wire [INPUT_PORTS-1:0] stm_value; \n  wire gnt; \n  signal_gen \n  #(.INPUT_PORTS(INPUT_PORTS)) \n uut (.clk(clk),.rst(rst),.req(req),.stm_value(stm_value),.gnt(gnt)); \n  parameter PERIOD = 10; \n  always begin \n  clk = 1'b0; \n  #(PERIOD/2) \n  clk = 1'b1; \n  #(PERIOD/2); \n  end \n  initial begin \n  rst = 1; \n  req = 0; \n  #100; \n  rst = 0; \n  req = 0; \n  #100; \n  req = 1; \n  $display($time, \" << Starting the Simulation >>\"); \n  #100; \n  req = 0; \n  $monitor(\" %0d %b\", $time, gnt); \n  wait(gnt) \n  begin \n  $display($time, \" << Finishing the Simulation >>\"); \n  $stop; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a state machine to perform left and right shifting operations on a 128-bit input data. It divides the input into a 4x4 grid and then shifts the data within each row to the left and right. The shifted data is then output as data_out_enc and data_out_dec. The module uses generate blocks and for loops to efficiently generate the state and perform the shifting operations for each row and column of the input data.\n\n Module header:\n\nmodule shift_rows (output [127 : 0] data_out_enc,output [127 : 0] data_out_dec,input [127 : 0] data_in);\n [/INST]\n", "output": "localparam integer BUS_WIDTH = 128; \n localparam integer ST_WORD = 8; \n localparam integer ST_LINE = 4; \n localparam integer ST_COL = 4; \n wire [ST_WORD - 1 : 0] state[0 : ST_LINE - 1][0 : ST_COL - 1]; \n wire [ST_WORD - 1 : 0] state_sft_l[0 : ST_LINE - 1][0 : ST_COL - 1]; \n wire [ST_WORD - 1 : 0] state_sft_r[0 : ST_LINE - 1][0 : ST_COL - 1]; \n generate \n  genvar l,c; \n  for(l = 0; l < ST_LINE; l = l + 1) \n  begin:SMG \n  for(c = 0; c < ST_COL; c = c + 1) \n  begin:BLOCK \n  assign state[l][c] = data_in[ST_WORD*((ST_COL - c)*ST_LINE - l) - 1 : ST_WORD*((ST_COL - c)*ST_LINE - l - 1)]; \n  end \n  end \n endgenerate \n generate \n  genvar l1,c1; \n  for(l1 = 0; l1 < ST_LINE; l1 = l1 + 1) \n  begin:SRO \n  for(c1 = 0; c1 < ST_COL; c1 = c1 + 1) \n  begin:BLOCK \n  assign state_sft_l[l1][c1] = state[l1][(c1 + l1)%ST_COL]; \n  assign state_sft_r[l1][c1] = state[l1][(c1 + (ST_COL - l1))%ST_COL]; \n  end \n  end \n endgenerate \n generate \n  genvar l2,c2; \n  for(l2 = 0; l2 < ST_LINE; l2 = l2 + 1) \n  begin:SMBOT \n  for(c2 = 0; c2 < ST_COL; c2 = c2 + 1) \n  begin:BLOCK \n  assign data_out_enc[ST_WORD*((ST_COL - c2)*ST_LINE - l2) - 1 : ST_WORD*((ST_COL - c2)*ST_LINE - l2 - 1)] = state_sft_l[l2][c2]; \n  assign data_out_dec[ST_WORD*((ST_COL - c2)*ST_LINE - l2) - 1 : ST_WORD*((ST_COL - c2)*ST_LINE - l2 - 1)] = state_sft_r[l2][c2]; \n  end \n  end \n endgenerate \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a receiver lane logic for descrambling data. It takes clock and reset signals, scrambled data inputs, a bit slip control, lane polarity, and descrambler control signals as inputs. The module generates descrambled data outputs and a descrambler lock status signal. The descrambling process can be enabled or disabled. The module also handles lane polarity control and asynchronous reset. The descrambler is an instance of the `rx_descrambler` module, which uses the provided bit slip control and data inputs to produce the descrambled data outputs.\n\n Module header:\n\nmodule rx_lane_logic #(parameter DWIDTH = 512,parameter NUM_LANES = 8,parameter LANE_DWIDTH = (DWIDTH/NUM_LANES),parameter CTRL_LANE_POLARITY = 1,parameter BITSLIP_SHIFT_RIGHT= 1) (input wire clk,input wire res_n,input wire [LANE_DWIDTH-1:0] scrambled_data_in,input wire bit_slip,input wire lane_polarity,output wire [LANE_DWIDTH-1:0] descrambled_data_out,output wire descrambler_locked,input wire descrambler_disable);\n [/INST]\n", "output": "wire [LANE_DWIDTH-1:0] descrambled_data_out_tmp; \n wire [LANE_DWIDTH-1:0] data_2_descrambler; \n wire descrambler_locked_tmp; \n assign descrambler_locked = descrambler_disable ? 1'b1 : descrambler_locked_tmp; \n generate \n  if(CTRL_LANE_POLARITY==1) begin \n  reg [LANE_DWIDTH-1:0] scrambled_data_in_reg; \n  `ifdef ASYNC_RES \n  always @(posedge clk or negedge res_n) begin `else \n  always @(posedge clk) begin `endif \n  if(!res_n) begin \n  scrambled_data_in_reg <= {LANE_DWIDTH{1'b0}}; \n  end \n  else begin \n  scrambled_data_in_reg <= scrambled_data_in^{LANE_DWIDTH{lane_polarity}}; \n  end \n  end \n  assign data_2_descrambler = scrambled_data_in_reg; \n  assign descrambled_data_out = descrambler_disable ? scrambled_data_in_reg : descrambled_data_out_tmp; \n  end else begin \n  assign data_2_descrambler = scrambled_data_in; \n  assign descrambled_data_out = descrambler_disable ? scrambled_data_in : descrambled_data_out_tmp; \n  end \n endgenerate \n rx_descrambler #(.DWIDTH(LANE_DWIDTH),.BITSLIP_SHIFT_RIGHT(BITSLIP_SHIFT_RIGHT)) descrambler_I (.clk(clk),.res_n(res_n),.bit_slip(bit_slip),.locked(descrambler_locked_tmp),.data_in(data_2_descrambler),.data_out(descrambled_data_out_tmp)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `xdom_pulse_sender` is a control unit that generates and manages pulses based on input signals. It utilizes various registers and logic to handle pulse generation, feedback, and error checking.\n\nIt includes multiple always blocks that are sensitive to different clock and reset signals. The `odom_pulse_i` and `odom_clk_i` inputs are used to control the behavior of the module, with the `xdom_clk_i` signal being used for pulse output. The `grst_i` input is a global reset signal that resets various internal registers and signals.\n\nThe module manages the generation of pulses and includes mechanisms to handle error conditions. It also uses feedback mechanisms to ensure proper pulse generation and cancellation. The `busy_o` output indicates the module's operational status, while the `err_o` output signals any error conditions.\n\nOverall, the `xdom_pulse_sender` module functions as a pulse generator and manager, with mechanisms to handle error conditions and ensure proper pulse generation based on the input signals.\n\n Module header:\n\nmodule xdom_pulse_sender (input grst_i,input odom_clk_i,input odom_pulse_i,input xdom_clk_i,output xdom_pulse_o,output busy_o,output err_o);\n [/INST]\n", "output": "reg odom_pulse_delay_r; \n reg odom_pulse_keeper_r; \n reg [1:0] odom_feedback_double_flips_r ; \n reg err_r; \n reg odom_pulse_gen_r; \n wire xdom_pulse_en; \n wire odom_pulse_safe_cancel; \n reg [1:0] xdom_double_flips_r ; \n reg xdom_pulse_en_delay_r ; \n reg xdom_pulse_gen_r ; \n always @(posedge odom_clk_i or posedge grst_i) \n  if (grst_i) \n  odom_pulse_delay_r <= 1'b0; \n  else \n  odom_pulse_delay_r <= odom_pulse_i; \n always @(posedge odom_clk_i or posedge grst_i) \n  if (grst_i) \n  odom_pulse_gen_r <= 1'b0; \n  else if ((odom_pulse_i == 1'b1) && (odom_pulse_delay_r == 1'b0)) \n  odom_pulse_gen_r <= 1'b1; \n  else \n  odom_pulse_gen_r <= 1'b0; \n always @(posedge odom_clk_i or posedge grst_i) \n  if (grst_i) \n  odom_pulse_keeper_r <= 1'b0; \n  else if (odom_pulse_keeper_r == 1'b0 && (odom_pulse_gen_r == 1'b1)) \n  odom_pulse_keeper_r <= 1'b1; \n  else if (odom_pulse_keeper_r == 1'b1 && odom_pulse_safe_cancel == 1'b1) \n  odom_pulse_keeper_r <= 1'b0; \n  else \n  odom_pulse_keeper_r <= odom_pulse_keeper_r; \n assign busy_o = odom_pulse_keeper_r | odom_pulse_i | odom_pulse_safe_cancel; \n always @(posedge odom_clk_i or posedge grst_i) \n  if (grst_i) \n  err_r <= 1'b0; \n  else \n  err_r <= (odom_pulse_keeper_r == 1'b1) && (odom_pulse_i == 1'b1); \n assign err_o = err_r; \n always @(posedge xdom_clk_i or posedge grst_i) \n  if (grst_i) \n  xdom_double_flips_r <= 2'b0; \n  else \n  xdom_double_flips_r <= {odom_pulse_keeper_r, xdom_double_flips_r[1]}; \n assign xdom_pulse_en = xdom_double_flips_r[0]; \n always @(posedge odom_clk_i or posedge grst_i) \n  if (grst_i) \n  odom_feedback_double_flips_r <= 2'b0; \n  else \n  odom_feedback_double_flips_r <= {xdom_pulse_en, odom_feedback_double_flips_r[1]}; \n assign odom_pulse_safe_cancel = odom_feedback_double_flips_r[0]; \n always @(posedge xdom_clk_i or posedge grst_i) \n  if (grst_i) \n  xdom_pulse_en_delay_r <= 1'b0; \n  else \n  xdom_pulse_en_delay_r <= xdom_pulse_en; \n always @(posedge xdom_clk_i or posedge grst_i) \n  if (grst_i) \n  xdom_pulse_gen_r <= 1'b0; \n  else if (xdom_pulse_en == 1'b1 && xdom_pulse_en_delay_r == 1'b0) \n  xdom_pulse_gen_r <= 1'b1; \n  else \n  xdom_pulse_gen_r <= 1'b0; \n assign xdom_pulse_o = xdom_pulse_gen_r; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements the address mapping and selection logic for a memory system. It takes clock signal and SNES_ADDR input and generates ROM_ADDR, ROM_HIT, IS_SAVERAM, and IS_ROM outputs. The module calculates the SRAM_SNES_ADDR based on the SNES_ADDR and generates the IS_ROM and IS_SAVERAM signals based on the SNES_ROMSEL and SNES_ADDR. Finally, the module assigns ROM_ADDR and ROM_HIT based on the SRAM_SNES_ADDR and the IS_SAVERAM and IS_ROM signals.\n\n Module header:\n\nmodule address(input CLK,input [23:0] SNES_ADDR,input SNES_ROMSEL,output [23:0] ROM_ADDR,output ROM_HIT,output IS_SAVERAM,output IS_ROM,input [23:0] SAVERAM_MASK,input [23:0] ROM_MASK);\n [/INST]\n", "output": "wire [23:0] SRAM_SNES_ADDR; \n assign IS_ROM = ~SNES_ROMSEL; \n assign IS_SAVERAM = (!SNES_ADDR[22]& &SNES_ADDR[21:20]& &SNES_ADDR[14:13]& !SNES_ADDR[15]); \n assign SRAM_SNES_ADDR = (IS_SAVERAM? 24'hFF0000 + ((SNES_ADDR[14:0] - 15'h6000)& SAVERAM_MASK): (({1'b0, SNES_ADDR[22:0]} & ROM_MASK)+ 24'hC00000)); \n assign ROM_ADDR = SRAM_SNES_ADDR; \n assign ROM_HIT = IS_ROM | IS_SAVERAM; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module is a test bench for a keypad interpreter. It instantiates the KeyPadInterpreter module and provides the necessary inputs such as Clock, ResetButton, KeyRead, RowDataIn, and receives outputs such as KeyReady, DataOut, ColDataOut, and PressCount. The module sets initial values for the flag and ResetButton and checks the DataOut value to display \"CorrectKey\" or \"Wrong DataOut\" based on the comparison with 4'b0110. The module also toggles the Clock and assigns RowDataIn based on the ColDataOut pattern in the ColDataOut always block.\n\n Module header:\n\nmodule KeyPadTestBench();\n [/INST]\n", "output": "reg flag; \n reg Clock; \n reg ResetButton; \n reg KeyRead; \n reg [3:0] RowDataIn; \n wire KeyReady; \n wire [3:0] DataOut; \n wire [3:0] ColDataOut; \n wire [3:0] PressCount; \n initial begin \n  Clock = 0; \n end \n always begin \n  #1 Clock = ~Clock; \n end \n always @(ColDataOut) begin \n  if(flag==1) begin \n  case(ColDataOut) \n  4'bzzz0: RowDataIn = 4'b1111; \n  4'bzz0z: RowDataIn = 4'b1111; \n  4'bz0zz: RowDataIn = 4'b1101; \n  4'b0zzz: RowDataIn = 4'b1111; \n  endcase \n  end \n  else begin \n  case(ColDataOut) \n  4'bzzz0: RowDataIn = 4'b1111; \n  4'bzz0z: RowDataIn = 4'b1111; \n  4'bz0zz: RowDataIn = 4'b1111; \n  4'b0zzz: RowDataIn = 4'b1111; \n  endcase \n  end \n end \n initial begin \n  #0 flag = 0; \n  #0 ResetButton = 0; \n  #3 ResetButton = 1; \n  #10000000; \n  flag = 1; \n  #10000000; \n  if(DataOut == 4'b0110) \n  $display(\"CorrectKey\"); \n  else \n  $display(\"Wrong DataOut\"); \n end \n KeyPadInterpreter test(Clock,ResetButton,KeyRead,RowDataIn,KeyReady,DataOut,ColDataOut,PressCount); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a linear feedback shift register (LFSR) that generates a pseudorandom sequence. It has inputs for clock, reset, new seed, enable, seed, and long heartbeat, as well as outputs for heartbeat and LFSR data. The LFSR data is updated based on the inputs and feedback logic, and the heartbeat is toggled based on the specified conditions and a counter. The module also has a reset function that initializes the LFSR and heartbeat.\n\n Module header:\n\nmodule alorium_lfsr (input clk,input reset_n,input new_seed,input enable,input wire [7:0] seed,input long_hb,output reg heartbeat,output reg [7:0] lfsr_data);\n [/INST]\n", "output": "reg [29:0] hb_cnt; \n  wire feedback; \n assign feedback = ~(lfsr_data[7] ^ lfsr_data[5] ^lfsr_data[4] ^ lfsr_data[3]); \n  always @(posedge clk) begin \n  if (!reset_n) begin \n  heartbeat <= 0; \n  hb_cnt <= 0; \n  lfsr_data <= 8'h01; \n  end \n  else if (new_seed) begin \n  lfsr_data <= &seed ? 8'h01 : seed; \n  hb_cnt <= hb_cnt + 1; \n  end \n  else if (enable) begin \n  lfsr_data <= {lfsr_data[6:0],feedback}; \n  hb_cnt <= hb_cnt + 1; \n  end \n  if ((long_hb) && (hb_cnt > 9999999)) begin \n  hb_cnt <= 0; \n  heartbeat <= ~heartbeat; \n  end \n  else if ((!long_hb) && (hb_cnt > 9)) begin \n  hb_cnt <= 0; \n  heartbeat <= ~heartbeat; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an alternative priority encoder with two internal altpriority encoders. It takes a 4-bit input 'data' and outputs a 2-bit 'q'. The module uses altpriority_encoder17 and altpriority_encoder18 to encode the input data and combines their outputs to produce the final output 'q'.\n\n Module header:\n\nmodule acl_fp_add_sub_fast_altpriority_encoder_6v7 (data,q) ;\n [/INST]\n", "output": "input [3:0] data; \n  output [1:0] q; \n  wire [0:0] wire_altpriority_encoder17_q; \n  wire [0:0] wire_altpriority_encoder18_q; \n  wire wire_altpriority_encoder18_zero; \n  acl_fp_add_sub_fast_altpriority_encoder_3v7 altpriority_encoder17 \n (.data(data[1:0]),.q(wire_altpriority_encoder17_q)); \n  acl_fp_add_sub_fast_altpriority_encoder_3e8 altpriority_encoder18 \n (.data(data[3:2]),.q(wire_altpriority_encoder18_q),.zero(wire_altpriority_encoder18_zero)); \n  assign \n  q = {(~ wire_altpriority_encoder18_zero), ((wire_altpriority_encoder18_zero & wire_altpriority_encoder17_q) | ((~ wire_altpriority_encoder18_zero) & wire_altpriority_encoder18_q))}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `ad_serdes_clk` instantiates clock generation logic with options for configuring clock sources and modes. It incorporates a phase-locked loop (PLL) or a clock buffer (BUFR) based on the configuration parameters. The module generates clocks and also provides control and status interface for the clock management. The clock signal is generated based on the input clock signals, and phase and frequency dividers are applied as per the specified settings. The module also manages configuration and status for the clock management resources.\n\n Module header:\n\nmodule ad_serdes_clk #(parameter DEVICE_TYPE = 0,parameter DDR_OR_SDR_N = 1,parameter CLKIN_DS_OR_SE_N = 1,parameter SERDES_FACTOR = 8,parameter MMCM_OR_BUFR_N = 1,parameter MMCM_CLKIN_PERIOD = 1.667,parameter MMCM_VCO_DIV = 6,parameter MMCM_VCO_MUL = 12.000,parameter MMCM_CLK0_DIV = 2.000,parameter MMCM_CLK1_DIV = 6) (input rst,input clk_in_p,input clk_in_n,output clk,output div_clk,output out_clk,output loaden,output [ 7:0] phase,input up_clk,input up_rstn,input up_drp_sel,input up_drp_wr,input [11:0] up_drp_addr,input [31:0] up_drp_wdata,output [31:0] up_drp_rdata,output up_drp_ready,output up_drp_locked);\n [/INST]\n", "output": "localparam BUFR_DIVIDE = (DDR_OR_SDR_N == 1'b1) ? SERDES_FACTOR / 2 : SERDES_FACTOR; \n  wire clk_in_s; \n  assign loaden = 'd0; \n  assign phase = 'd0; \n  assign up_drp_rdata[31:16] = 'd0; \n  generate \n  if (CLKIN_DS_OR_SE_N == 1) begin \n IBUFGDS i_clk_in_ibuf (.I (clk_in_p),.IB (clk_in_n),.O (clk_in_s)); \n  end else begin \n IBUF IBUF_inst (.O(clk_in_s),.I(clk_in_p)); \n  end \n  endgenerate \n  generate \n  if (MMCM_OR_BUFR_N == 1) begin \n ad_mmcm_drp #(.MMCM_DEVICE_TYPE (DEVICE_TYPE),.MMCM_CLKIN_PERIOD (MMCM_CLKIN_PERIOD),.MMCM_CLKIN2_PERIOD (MMCM_CLKIN_PERIOD),.MMCM_VCO_DIV (MMCM_VCO_DIV),.MMCM_VCO_MUL (MMCM_VCO_MUL),.MMCM_CLK0_DIV (MMCM_CLK0_DIV),.MMCM_CLK0_PHASE (0.0),.MMCM_CLK1_DIV (MMCM_CLK1_DIV),.MMCM_CLK1_PHASE (0.0),.MMCM_CLK2_DIV (MMCM_CLK0_DIV),.MMCM_CLK2_PHASE (90.0)) \n i_mmcm_drp (.clk (clk_in_s),.clk2 (1'b0),.clk_sel (1'b1),.mmcm_rst (rst),.mmcm_clk_0 (clk),.mmcm_clk_1 (div_clk),.mmcm_clk_2 (out_clk),.up_clk (up_clk),.up_rstn (up_rstn),.up_drp_sel (up_drp_sel),.up_drp_wr (up_drp_wr),.up_drp_addr (up_drp_addr),.up_drp_wdata (up_drp_wdata[15:0]),.up_drp_rdata (up_drp_rdata[15:0]),.up_drp_ready (up_drp_ready),.up_drp_locked (up_drp_locked)); \n  end \n  endgenerate \n  generate \n  if (MMCM_OR_BUFR_N == 0) begin \n BUFIO i_clk_buf (.I (clk_in_s),.O (clk)); \n BUFR #(.BUFR_DIVIDE(BUFR_DIVIDE)) i_div_clk_buf (.CLR (1'b0),.CE (1'b1),.I (clk_in_s),.O (div_clk)); \n  assign out_clk = clk; \n  assign up_drp_rdata[15:0] = 'd0; \n  assign up_drp_ready = 'd0; \n  assign up_drp_locked = 'd0; \n  end \n  endgenerate \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a buffer with a one-time unit delay. It takes an input 'i' and produces an output 'z' delayed by one time unit.\n\n Module header:\n\nmodule buff (z,i);\n [/INST]\n", "output": "parameter DELAY = 1; \n  input i; \n  output z; \n  assign #DELAY z = i; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a synchronous general shift register with a specified data width and depth. It uses a generate loop to instantiate multiple instances of a D flip-flop based on the depth parameter. The first D flip-flop is connected to the input data, and subsequent D flip-flops are connected to the output of the previous stage. The final output is assigned to the last stage of the shift register. The D flip-flops are clocked by the input clock signal and are resettable by the input reset signal.\n\n Module header:\n\nmodule sirv_gnrl_sync # (parameter DP = 2,parameter DW = 32) (input [DW-1:0] din_a,output [DW-1:0] dout,input rst_n,input clk);\n [/INST]\n", "output": "wire [DW-1:0] sync_dat [DP-1:0]; \n  genvar i; \n  generate \n  for(i=0;i<DP;i=i+1) begin:sync_gen \n  if(i==0) begin:i_is_0 \n  sirv_gnrl_dffr #(DW) sync_dffr(din_a, sync_dat[0], clk, rst_n); \n  end \n  else begin:i_is_not_0 \n  sirv_gnrl_dffr #(DW) sync_dffr(sync_dat[i-1], sync_dat[i], clk, rst_n); \n  end \n  end \n  endgenerate \n  assign dout = sync_dat[DP-1]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module compares four sets of input values and selects the maximum value from each pair. The module also determines the corresponding position of the maximum value. The result of the comparison and the position are then assigned to the output signals \"state\" and \"max\" respectively.\n\n Module header:\n\nmodule max_metric_logic (a ,b ,c ,d ,sa ,sb ,sc ,sd ,state ,max);\n [/INST]\n", "output": "parameter M = 7 ; \n parameter K = 7 ; \n input [M -1:0] a ; \n input [M -1:0] b ; \n input [M -1:0] c ; \n input [M -1:0] d ; \n input [K -2:0] sa ; \n input [K -2:0] sb ; \n input [K -2:0] sc ; \n input [K -2:0] sd ; \n output [K -2:0] state ; \n output [M -1:0] max ; \n reg [K -2:0] pos0 ; \n reg [K -2:0] pos1 ; \n reg [M -1:0] max0 ; \n reg [M -1:0] max1 ; \n reg [M -1:0] tmp ; \n reg [K -2:0] state_i ; \n reg [M -1:0] max_i ; \n assign state = state_i ; \n assign max = max_i ; \n always @* \n begin \n  tmp = a-b ; \n  if(~tmp[M -1]) \n  begin \n  max0 = a ; \n  pos0 = sa ; \n  end \n  else \n  begin \n  max0 = b ; \n  pos0 = sb ; \n  end \n  tmp = c-d ; \n  if(~tmp[M-1]) \n  begin \n  max1 = c ; \n  pos1 = sc ; \n  end \n  else \n  begin \n  max1 = d ; \n  pos1 = sd ; \n  end \n  tmp = max0 - max1 ; \n  if (~tmp[M-1]) \n  begin \n  max_i = max0 ; \n  state_i = pos0 ; \n  end \n  else \n  begin \n  state_i = pos1 ; \n  max_i = max1 ; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a half adder, which takes two input bits x_in and y_in, and produces a sum output s_out and a carry output c_out. The sum output is the result of an XOR operation between the two inputs, while the carry output is the result of an AND operation between the inputs.\n\n Module header:\n\nmodule half_adder (input x_in,input y_in,output wire s_out,output wire c_out);\n [/INST]\n", "output": "assign s_out = x_in ^ y_in; \n assign c_out = x_in & y_in; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, hamming_distance, calculates the Hamming distance between two 8-bit input values, val_a and val_b, and stores the result in the 4-bit output distance. It first performs a bitwise XOR operation on val_a and val_b to obtain bit_diff. Then, on every positive clock edge, it calculates the number of differing bits in bit_diff and assigns the result to the distance output.\n\n Module header:\n\nmodule hamming_distance (input wire clock,input wire [7:0] val_a, val_b,output reg [3:0] distance);\n [/INST]\n", "output": "wire [7:0] bit_diff; \n assign bit_diff = val_a ^ val_b; \n always @(posedge clock) begin \n  distance = bit_diff[0] + bit_diff[1] + bit_diff[2] + bit_diff[3] \n  + bit_diff[4] + bit_diff[5] + bit_diff[6] + bit_diff[7]; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a system controller that interfaces with a CPU (Picoblaze) and GPIO peripherals for LEDs and switches. It implements the functionality to handle input clock signals, reset signals, and data transfer between GPIO peripherals and the CPU. The module includes a system controller instance, a Picoblaze CPU instance, and two instances of a GPIO module for LEDs and switches. The input and output ports, as well as the clock and reset signals, are appropriately connected between these modules to facilitate the data flow and control signals within the system. Additionally, the module assigns specific values to control signals and data transfer operations to ensure proper functionality of the GPIO peripherals and CPU.\n\n Module header:\n\nmodule basic (SWITCHES, LEDS,CLK_IN, RESET_IN);\n [/INST]\n", "output": "input CLK_IN; \n  input RESET_IN; \n  inout [7:0] SWITCHES; \n  inout [7:0] LEDS; \n  wire [7:0] in_port; \n  wire [7:0] LEDS; \n  wire [7:0] port_id; \n  wire [7:0] out_port; \n  wire [7:0] gpio_switches_data_out; \n  wire [7:0] gpio_leds_data_out; \n  wire CLK_OUT; \n  wire RESET_OUT; \n system_controller syscon(.CLK_OUT (CLK_OUT),.RESET_OUT (RESET_OUT),.CLK_IN (CLK_IN),.RESET_IN (RESET_IN)); \n cpu Picoblaze(.port_id (port_id[7:0]),.out_port (out_port[7:0]),.write_strobe (write_strobe),.read_strobe (read_strobe),.interrupt_ack (interrupt_ack),.clk (CLK_OUT),.in_port (in_port[7:0]),.interrupt (interrupt),.kcpsm6_sleep (kcpsm6_sleep),.cpu_reset (RESET_OUT)); \n  assign in_port = gpio_leds_data_out | gpio_switches_data_out; \n  assign interrupt = gpio_switches_interrupt; \n  assign kcpsm6_sleep = 0; \n pb_gpio gpio_leds(.data_out(gpio_leds_data_out),.interrupt(gpio_leds_interrupt),.gpio(LEDS),.clk(CLK_OUT),.reset(RESET_OUT),.port_id(port_id),.data_in(out_port),.read_strobe(read_strobe),.write_strobe(write_strobe)); \n  pb_gpio #(.GPIO_BASE_ADDRESS(8)) \n gpio_switches(.data_out(gpio_switches_data_out),.interrupt(gpio_switches_interrupt),.gpio(SWITCHES),.clk(CLK_OUT),.reset(RESET_OUT),.port_id(port_id),.data_in(out_port),.read_strobe(read_strobe),.write_strobe(write_strobe)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module is an Apb3Decoder that takes input signals related to the APB3 protocol and provides corresponding output signals. It utilizes logic to decode the input address and control signals to generate the appropriate output signals. The module also ensures that the output signals align with the APB3 protocol requirements.\n\n Module header:\n\nmodule Apb3Decoder (input [19:0] io_input_PADDR,input [0:0] io_input_PSEL,input io_input_PENABLE,output reg io_input_PREADY,input io_input_PWRITE,input [31:0] io_input_PWDATA,output [31:0] io_input_PRDATA,output reg io_input_PSLVERROR,output [19:0] io_output_PADDR,output reg [2:0] io_output_PSEL,output io_output_PENABLE,input io_output_PREADY,output io_output_PWRITE,output [31:0] io_output_PWDATA,input [31:0] io_output_PRDATA,input io_output_PSLVERROR);\n [/INST]\n", "output": "wire [19:0] _zz_1_; \n  wire [19:0] _zz_2_; \n  wire [19:0] _zz_3_; \n  assign _zz_1_ = (20'b11111111000000000000); \n  assign _zz_2_ = (20'b11111111000000000000); \n  assign _zz_3_ = (20'b11111111000000000000); \n  assign io_output_PADDR = io_input_PADDR; \n  assign io_output_PENABLE = io_input_PENABLE; \n  assign io_output_PWRITE = io_input_PWRITE; \n  assign io_output_PWDATA = io_input_PWDATA; \n  always @ (*) begin \n  io_output_PSEL[0] = (((io_input_PADDR & _zz_1_) == (20'b00000000000000000000)) && io_input_PSEL[0]); \n  io_output_PSEL[1] = (((io_input_PADDR & _zz_2_) == (20'b00010000000000000000)) && io_input_PSEL[0]); \n  io_output_PSEL[2] = (((io_input_PADDR & _zz_3_) == (20'b00100000000000000000)) && io_input_PSEL[0]); \n  end \n  always @ (*) begin \n  io_input_PREADY = io_output_PREADY; \n  io_input_PSLVERROR = io_output_PSLVERROR; \n  if((io_input_PSEL[0] && (io_output_PSEL == (3'b000))))begin \n  io_input_PREADY = 1'b1; \n  io_input_PSLVERROR = 1'b1; \n  end \n  end \n  assign io_input_PRDATA = io_output_PRDATA; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a pipeline delay with data and control signals. It consists of several registers for storing data and control flags. The module uses the input data and flags to perform calculations and updates on the data and control signals on every rising edge of the clock signal. The module also initializes and updates a series of registers in a loop to create a pipeline delay. Finally, it assigns the output signals based on the calculated values and the pipeline delay.\n\n Module header:\n\nmodule uut_8_top (output wire [31:0] res_o,output wire [31:0] exp_o,output wire [31:0] obs_o,output wire val_o,input wire [7:0] data_i,input wire sof_i,input wire eof_i,input wire pclk_i);\n [/INST]\n", "output": "localparam LO = 1'b0; \n  localparam HI = 1'b1; \n  localparam [31:0] ZEROS = {32{LO}}; \n  localparam [31:0] ONES = {32{HI}}; \n  localparam FIRST = 7; \n  localparam LAST = 9; \n  reg [7:0] data_z1; \n  reg sof_z1; \n  reg [7:0] data_z2; \n  reg sof_z2; \n  reg [7:0] data_z3; \n  reg sof_z3; \n  reg [7:0] data_z4; \n  reg sof_z4; \n  reg val_z5; \n  reg [31:0] exp_z5; \n  reg [31:0] fcs_z5; \n  reg val_z6; \n  reg [31:0] exp_z6; \n  reg [31:0] fcs_z6; \n  reg [31:0] exp[FIRST:LAST]; \n  reg [31:0] crc[FIRST:LAST]; \n  reg val[FIRST:LAST]; \n  always @ (posedge pclk_i) begin \n  data_z1[7:0] <= data_i[7:0]; \n  sof_z1 <= sof_i; \n  data_z2[7:0] <= data_z1[7:0]; \n  sof_z2 <= sof_z1; \n  data_z3[7:0] <= data_z2[7:0]; \n  sof_z3 <= sof_z2; \n  data_z4[7:0] <= data_z3[7:0]; \n  sof_z4 <= sof_z3; \n  val_z5 <= eof_i; \n  if (eof_i == HI) begin \n  exp_z5[31:0] <= {data_z3[7:0], data_z2[7:0], data_z1[7:0], data_i[7:0]}; \n  end \n  if (sof_z4 == HI) begin \n  fcs_z5[31:0] <= fcs32_8(data_z4[7:0], ONES[31:0]); \n  end else begin \n  fcs_z5[31:0] <= fcs32_8(data_z4[7:0], fcs_z5[31:0]); \n  end \n  val_z6 <= val_z5; \n  exp_z6[31:0] <= exp_z5[31:0]; \n  fcs_z6[31:0] <= fcs32_brev(fcs_z5[31:0]); \n  end \n  generate \n  genvar i; \n  for (i = FIRST ; i <= LAST ; i = i + 1) begin : ppln_delay \n  always @ (posedge pclk_i) begin \n  if (i == FIRST) begin \n  exp[i][31:0] <= exp_z6[31:0]; \n  crc[i][31:0] <= fcs_z6[31:0]; \n  val[i] <= val_z6; \n  end else begin \n  exp[i][31:0] <= exp[i - 1][31:0]; \n  crc[i][31:0] <= crc[i - 1][31:0]; \n  val[i] <= val[i - 1]; \n  end \n  end \n  end \n  endgenerate \n  always @ (*) begin \n  res_o[31:0] = fcs_z5[31:0]; \n  exp_o[31:0] = exp[LAST][31:0]; \n  obs_o[31:0] = crc[LAST][31:0]; \n  val_o = val[LAST]; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module represents a register file with the ability to read and write to specific registers. It has two read ports (A and B) and one write port. The data at the read addresses is assigned to dataA and dataB based on the state of st_A and st_B. The module supports writing to the register file based on the write enable signal and the selected write mode. Additionally, it includes an optional trace register functionality to display the contents of the registers.\n\n Module header:\n\nmodule Reg(input wire clk,input wire [`REG_ADDR_LEN - 1:0] ra,input wire [`REG_ADDR_LEN - 1:0] rb,output wire [`WIDTH - 1:0] dataA,output wire [`WIDTH - 1:0] dataB,output reg st_A,output reg st_B,input wire r_en_A,input wire r_en_B,input wire [`REG_ADDR_LEN - 1:0] rc,input wire [`WIDTH -1 :0] dataC,input wire w_en,input wire [1:0] w_mode);\n [/INST]\n", "output": "reg [`WIDTH - 1:0] RegFile [`NUM_REGS - 1:0]; \n  assign dataA = (st_A == 1)?((ra!=0)?RegFile[ra]:0):32'bz; \n  assign dataB = (st_B == 1)?((rb!=0)?RegFile[rb]:0):32'bz; \n  always @(posedge clk) begin \n  if (w_en) begin \n  if(rc != 0) begin \n  case(w_mode) \n  0: RegFile[rc] <= dataC; \n  1: RegFile[rc] <= {16'b0, dataC[15:0]}; \n  2: RegFile[rc] <= {24'b0, dataC[7:0]}; \n  endcase \n  end \n  end \n  end \n  always @(negedge clk) begin \n  st_A = 0; \n  if (r_en_A) begin \n  st_A = 1; \n  end \n  end \n  always @(negedge clk) begin \n  st_B = 0; \n  if (r_en_B) begin \n  st_B = 1; \n  end \n  end \n `ifdef TRACE_REG \n  integer i,j,k; \n  always @(posedge clk) begin \n  k=0; \n  for(i=0;i<32;i=i+4) \n  begin \n  for(j=0;j<4;j=j+1) \n  begin \n  $write(\"R[%d] = %h\\t\", k, RegFile[k]); \n  k = k + 1; \n  end \n  $write(\"\\n\"); \n  end \n  end \n `endif \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, named \"CenterMaze,\" takes in the X and Y coordinates, along with wall data, and outputs the map data. It checks the coordinates to determine if they are within specific ranges and sets the color based on the presence of a wall. If the coordinates fall within certain regions, the module assigns a color based on the wall data. If the coordinates do not match any specific regions, a default color is assigned. The output mapData is then assigned the determined color.\n\n Module header:\n\n module CenterMaze(clk_vga, CurrentX, CurrentY, mapData, wall);\n [/INST]\n", "output": "input clk_vga; \n  input [9:0]CurrentX; \n  input [8:0]CurrentY; \n  input [7:0]wall; \n  output [7:0]mapData; \n  reg [7:0]mColor; \n  always @(posedge clk_vga) begin \n if((CurrentX >= 0 && CurrentX <=63) && ((CurrentY <= 39) ||(CurrentY >= 120 && CurrentY <= 199) ||(CurrentY >= 280 && CurrentY <= 359) ||(CurrentY >= 441) ) ) \n  mColor[7:0] <= wall; \n else if( (CurrentX >= 64 && CurrentX <= 95) && ((CurrentY >= 120 && CurrentY <= 199) ||(CurrentY >= 441) ) ) \n  mColor[7:0] <= wall; \n else if( (CurrentX >= 96 && CurrentX <= 127) && ((CurrentY <= 199) ||(CurrentY >= 441) ) ) \n  mColor[7:0] <= wall; \n else if( (CurrentX >= 128 && CurrentX <= 159) && ((CurrentY >= 120 && CurrentY <= 199) ) ) \n  mColor[7:0] <= wall; \n else if( (CurrentX >= 160 && CurrentX <= 191) && ((CurrentY <= 39) ||(CurrentY >= 120) ) ) \n  mColor[7:0] <= wall; \n else if( (CurrentX >= 192 && CurrentX <= 223) && ((CurrentY <= 39) ) ) \n  mColor[7:0] <= wall; \n  else if( (CurrentX >= 224 && CurrentX <= 255) ) \n  mColor[7:0] <= wall; \n else if( (CurrentX >= 256 && CurrentX <= 287) && ((CurrentY <= 359) ) ) \n  mColor[7:0] <= wall; \n else if( (CurrentX >= 352 && CurrentX <= 383) && ((CurrentY <= 359) ) ) \n  mColor[7:0] <= wall; \n  else if( (CurrentX >= 384 && CurrentX <= 415) ) \n  mColor[7:0] <= wall; \n else if( (CurrentX >= 416 && CurrentX <= 447) && ((CurrentY <= 39) ) ) \n  mColor[7:0] <= wall; \n else if( (CurrentX >= 448 && CurrentX <= 479) && ((CurrentY <= 39) ||(CurrentY >= 120) ) ) \n  mColor[7:0] <= wall; \n else if( (CurrentX >= 480 && CurrentX <= 511) && ((CurrentY >= 120 && CurrentY <= 199) ) ) \n  mColor[7:0] <= wall; \n else if( (CurrentX >= 512 && CurrentX <= 543) && ((CurrentY <= 199) ||(CurrentY >= 441) ) ) \n  mColor[7:0] <= wall; \n else if( (CurrentX >= 544 && CurrentX <= 575) && ((CurrentY >= 120 && CurrentY <= 199) ||(CurrentY >= 441) ) ) \n  mColor[7:0] <= wall; \n else if((CurrentX >= 576 && CurrentX <= 640) && ((CurrentY <= 39) ||(CurrentY >= 120 && CurrentY <= 199) ||(CurrentY >= 280 && CurrentY <= 359) ||(CurrentY >= 441) ) ) \n  mColor[7:0] <= wall; \n  else \n  mColor[7:0] <= 8'b10110110; \n  end \n  assign mapData = mColor; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module is a decoder that takes an 8-bit opcode as input and decodes it to determine various control signals for the microprocessor. It sets the instruction length, operands for the ALU, the ALU operation, the destination for the result, and flags like carry, zero, and overflow based on the opcode. The decoder implements specific logic for certain opcodes, such as loading an immediate value into a register or performing arithmetic operations. If the opcode does not match any defined case, the decoder does not make any changes to the control signals.\n\n Module header:\n\nmodule m6502_decoder(input wire [7 : 0] opcode,output wire [2 : 0] instr_len,output wire [2 : 0] opa,output wire [2 : 0] opb,output wire [2 : 0] alu_op,output wire [2 : 0] destination,output wire update_carry,output wire update_zero,output wire update_overflow);\n [/INST]\n", "output": "localparam OP_BRK = 8'h00; \n  localparam OP_CLC = 8'h18; \n  localparam OP_SEC = 8'h38; \n  localparam OP_JMP = 8'h4c; \n  localparam OP_CLI = 8'h58; \n  localparam OP_RTS = 8'h60; \n  localparam OP_SEI = 8'h78; \n  localparam OP_TXA = 8'h8a; \n  localparam OP_LDA_IMM = 8'ha9; \n  localparam OP_TAX = 8'haa; \n  localparam OP_INY = 8'hc8; \n  localparam OP_DEX = 8'hca; \n  localparam OP_INX = 8'he8; \n  localparam OP_NOP = 8'hea; \n  localparam OP_AREG = 3'h0; \n  localparam OP_XREG = 3'h1; \n  localparam OP_YREG = 3'h2; \n  localparam OP_ONE = 3'h7; \n  localparam ALU_NONE = 3'h0; \n  localparam ALU_ADC = 3'h1; \n  localparam DEST_MEM = 3'h0; \n  localparam DEST_AREG = 3'h1; \n  localparam DEST_XREG = 3'h2; \n  localparam DEST_YREG = 3'h3; \n  reg [2 : 0] ilen; \n  reg [2 : 0] dest; \n  reg [2 : 0] alu; \n  reg [2 : 0] a; \n  reg [2 : 0] b; \n  reg carry; \n  reg zero; \n  reg overflow; \n  assign instr_len = ilen; \n  assign destination = dest; \n  assign alu_op = alu; \n  assign opa = a; \n  assign opb = b; \n  assign update_carry = carry; \n  assign update_zero = zero; \n  assign update_overflow = overflow; \n  always @* \n  begin : decoder \n  ilen = 3'h0; \n  dest = DEST_MEM; \n  alu = ALU_NONE; \n  carry = 0; \n  zero = 0; \n  overflow = 0; \n  case (opcode) \n  OP_LDA_IMM: \n  begin \n  ilen = 3'h2; \n  dest = DEST_AREG; \n  alu = ALU_NONE; \n  end \n  OP_INY: \n  begin \n  ilen = 3'h1; \n  a = OP_YREG; \n  b = OP_ONE; \n  alu = ALU_ADC; \n  dest = DEST_YREG; \n  end \n  OP_INX: \n  begin \n  ilen = 3'h1; \n  a = OP_XREG; \n  b = OP_ONE; \n  alu = ALU_ADC; \n  dest = DEST_XREG; \n  end \n  default: \n  begin \n  end \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module `BLE_v2_0_0` is a design for a Bluetooth Low Energy (BLE) module with an integrated interrupt handler, clock configuration, and RF external PA enable. The module connects the BLE core with the interrupt controller `cy_isr_v1_0` and the clock module `cy_clock_v1_0`. The output `clk` is derived from the logical OR of `Net_55` and `Net_53`, while `Net_55` is statically assigned to logic 0. The `cy_m0s8_ble_v1_0` module handles the BLE functionality and connects the interrupt signal and RF external PA enable signals. The `cy_clock_v1_0` module is responsible for configuring the LFCLK.\n\n Module header:\n\nmodule BLE_v2_0_0 (clk);\n [/INST]\n", "output": "output clk; \n  wire Net_60; \n  wire Net_53; \n  wire Net_37; \n  wire Net_63; \n  wire Net_15; \n  wire Net_14; \n  wire Net_55; \n cy_m0s8_ble_v1_0 cy_m0s8_ble (.interrupt(Net_15),.rf_ext_pa_en(Net_63)); \n  cy_isr_v1_0 \n  #(.int_type(2'b10)) \n  bless_isr \n  (.int_signal(Net_15)); \n  cy_clock_v1_0 \n #(.id(\"34930e12-af9a-4d94-86a4-9071ff746fb7/5ae6fa4d-f41a-4a35-8821-7ce70389cb0c\"),.source_clock_id(\"9A908CA6-5BB3-4db0-B098-959E5D90882B\"),.divisor(0),.period(\"0\"),.is_direct(1),.is_digital(0)) \n  LFCLK \n  (.clock_out(Net_53)); \n  assign clk = Net_55 | Net_53; \n  assign Net_55 = 1'h0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module performs an alternate priority encoding operation on the input data. It first processes the lower 4 bits of the input through an altpriority encoder, and then processes the upper 4 bits through another altpriority encoder. The result of the second encoder is also checked for a zero output. The outputs from both encoders are then combined using logical OR operations to form the final output wire q.\n\n Module header:\n\nmodule fp_add_sub_altpriority_encoder_bv7 (data,q) ;\n [/INST]\n", "output": "input [7:0] data; \n  output [2:0] q; \n  wire [1:0] wire_altpriority_encoder15_q; \n  wire [1:0] wire_altpriority_encoder16_q; \n  wire wire_altpriority_encoder16_zero; \n  fp_add_sub_altpriority_encoder_6v7 altpriority_encoder15 \n (.data(data[3:0]),.q(wire_altpriority_encoder15_q)); \n  fp_add_sub_altpriority_encoder_6e8 altpriority_encoder16 \n (.data(data[7:4]),.q(wire_altpriority_encoder16_q),.zero(wire_altpriority_encoder16_zero)); \n  assign \n  q = {(~ wire_altpriority_encoder16_zero), (({2{wire_altpriority_encoder16_zero}} & wire_altpriority_encoder15_q) | ({2{(~ wire_altpriority_encoder16_zero)}} & wire_altpriority_encoder16_q))}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a GMII to FIFO conversion. It receives GMII interface signals and outputs data to a FIFO. The received clock signal is used as the write clock for the FIFO. The module processes incoming data based on the GMII protocol and controls the write enable signal for the FIFO. The module also handles gap insertion based on the Gap parameter value. The received data is formatted and written to the output FIFO in the specified order.\n\n Module header:\n\nmodule gmii2fifo72 # (parameter Gap = 4'h2) (input sys_rst,input gmii_rx_clk,input gmii_rx_dv,input [7:0] gmii_rxd,output [71:0] din,input full,output reg wr_en,output wr_clk);\n [/INST]\n", "output": "assign wr_clk = gmii_rx_clk; \n reg [2:0] count = 3'h0; \n reg [63:0] rxd = 64'h00; \n reg [7:0] rxc = 8'h0; \n reg [3:0] gap_count = 4'h0; \n always @(posedge gmii_rx_clk) begin \n  if (sys_rst) begin \n  count <= 3'h0; \n  gap_count <= 4'h0; \n  end else begin \n  wr_en <= 1'b0; \n  if (gmii_rx_dv == 1'b1) begin \n  count <= count + 3'h1; \n  gap_count <= Gap; \n  case (count) \n  3'h0: begin \n  rxd[63: 0] <= {56'h0, gmii_rxd[7:0]}; \n  rxc[7:0] <= 8'b00000001; \n  end \n  3'h1: begin \n  rxd[15: 8] <= gmii_rxd[7:0]; \n  rxc[1] <= 1'b1; \n  end \n  3'h2: begin \n  rxd[23:16] <= gmii_rxd[7:0]; \n  rxc[2] <= 1'b1; \n  end \n  3'h3: begin \n  rxd[31:24] <= gmii_rxd[7:0]; \n  rxc[3] <= 1'b1; \n  end \n  3'h4: begin \n  rxd[39:32] <= gmii_rxd[7:0]; \n  rxc[4] <= 1'b1; \n  end \n  3'h5: begin \n  rxd[47:40] <= gmii_rxd[7:0]; \n  rxc[5] <= 1'b1; \n  end \n  3'h6: begin \n  rxd[55:48] <= gmii_rxd[7:0]; \n  rxc[6] <= 1'b1; \n  end \n  3'h7: begin \n  rxd[63:56] <= gmii_rxd[7:0]; \n  rxc[7] <= 1'b1; \n  wr_en <= 1'b1; \n  end \n  endcase \n  end else begin \n  if (count != 3'h0) begin \n  wr_en <= 1'b1; \n  count <= 3'h0; \n  end else if (gap_count != 4'h0) begin \n  rxd[63: 0] <= 64'h0; \n  rxc[7:0] <= 8'h0; \n  wr_en <= 1'b1; \n  gap_count <= gap_count - 4'h1; \n  end \n  end \n  end \n end \n assign din[71:0] = {rxc[7:0], rxd[63:0]}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a logic function that takes four inputs a, b, c, and d, performs XOR operations on pairs of inputs, and then performs a logical XOR on the results. The output z is updated based on changes to any of the input signals a, b, c, or d.\n\n Module header:\n\nmodule f1_test(a, b, c, d, z);\n [/INST]\n", "output": "input a, b, c, d; \n output z; \n reg z, temp1, temp2; \n always @(a or b or c or d) \n begin \n  temp1 = a ^ b; \n  temp2 = c ^ d; \n  z = temp1 ^ temp2; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module controltb instantiates a control module named control1, and uses a clock signal and a 32-bit register to simulate the behavior of a hardware design. It sets the value of the instruction register at different time points and finishes the simulation after a series of instructions are executed.\n\n Module header:\n\nmodule controltb;\n [/INST]\n", "output": "reg [0:31] instr; \n  reg clk; \n  wire [0:4] aluop, rrdaddra, rrdaddrb, rwraddrd; \n  wire [0:2] ppp, regop, memop; \n  wire [0:1] ww; \n  wire [0:20] maddr; \n  wire reginmuxop, aluinmuxop; \n  wire [0:15] wbyteen; \n  wire [0:31] immediate; \n control control1(instr,aluop, ppp, ww,memop, maddr, wbyteen,regop, rrdaddra, rrdaddrb, rwraddrd,reginmuxop,aluinmuxop,immediate); \n  always \n  begin \n  #5 clk=0; \n  #5 clk=1; \n  end \n  initial \n  begin \n  #5; \n  instr=32'b00010001101010100101100000000000; \n  #10; \n  instr=32'b00010001101010100101101001000000; \n  #10; \n  instr=32'b00010001101010100101110000000000; \n  #10; \n  instr=32'b00010001101010100101110001000000; \n  #10; \n  instr=32'b00010001101010100101110010000000; \n  #10; \n  instr=32'b00010001101010100101110010001001; \n  #10; \n  instr=32'b00000101101000000000000000000001; \n  #10; \n  instr=32'b00100001101010100000010010001001; \n  #10; \n  instr=32'b00010001101010100000010100001000; \n  #10; \n  instr=32'b00010001101010100101110101001010; \n  #10; \n  instr=32'b00010001101010100101110100001100; \n  #10; \n  instr=32'b00010001101010100101110101010000; \n  #10; \n  instr=32'b00010001101010100111110110010001; \n  #10; \n  instr=32'b00010001101010100101110110010110; \n  #10; \n  instr=32'b00010001101010100111110110010111; \n  #10; \n  instr=32'b00010001101010100101110110010100; \n  #10; \n  instr=32'b00010001101010100111110110010101; \n  #10; \n  instr=32'b00001001101000000000000000000001; \n  #10; \n  instr=32'b00010001101010100101111001000001; \n  #10; \n  instr=32'b00010001101010100101111101001011; \n  #10; \n  instr=32'b00000001101010100101110110001011; \n  #10; \n  $finish; \n  end \n  initial \n  begin \n  $shm_open(\"tb.shm\"); \n  $shm_probe(\"AC\"); \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a one-hot multiplexer with a parameterized select width and data width. It uses a generate block to create an array of wire inputs and a register output. Based on the select width, it uses a case statement to select the appropriate input and assign it to the output. The module supports select widths of 1, 2, 4, and 8, and handles the corresponding input combinations for each width.\n\n Module header:\n\nmodule one_hot_mux #(parameter C_DATA_WIDTH = 1,parameter C_SELECT_WIDTH = 2,parameter C_AGGREGATE_WIDTH = C_SELECT_WIDTH*C_DATA_WIDTH) (input [C_SELECT_WIDTH-1:0] ONE_HOT_SELECT,input [C_AGGREGATE_WIDTH-1:0] ONE_HOT_INPUTS,output [C_DATA_WIDTH-1:0] ONE_HOT_OUTPUT);\n [/INST]\n", "output": "genvar i; \n  wire [C_DATA_WIDTH-1:0] wOneHotInputs[(1<<C_SELECT_WIDTH):1]; \n  reg [C_DATA_WIDTH-1:0] _rOneHotOutput; \n  assign ONE_HOT_OUTPUT = _rOneHotOutput; \n  generate \n  for( i = 0 ; i < C_SELECT_WIDTH; i = i + 1 ) begin : gen_input_array \n  assign wOneHotInputs[(1<<i)] = ONE_HOT_INPUTS[C_DATA_WIDTH*i +: C_DATA_WIDTH]; \n  end \n  if(C_SELECT_WIDTH == 1) begin \n  always @(*) begin \n  _rOneHotOutput = wOneHotInputs[1]; \n  end \n  end else if(C_SELECT_WIDTH == 2) begin \n  always @(*) begin \n  case(ONE_HOT_SELECT) \n  2'b01: _rOneHotOutput = wOneHotInputs[1]; \n  2'b10: _rOneHotOutput = wOneHotInputs[2]; \n  default:_rOneHotOutput = wOneHotInputs[1]; \n  endcase \n  end \n  end else if( C_SELECT_WIDTH == 4) begin \n  always @(*) begin \n  case(ONE_HOT_SELECT) \n  4'b0001: _rOneHotOutput = wOneHotInputs[1]; \n  4'b0010: _rOneHotOutput = wOneHotInputs[2]; \n  4'b0100: _rOneHotOutput = wOneHotInputs[4]; \n  4'b1000: _rOneHotOutput = wOneHotInputs[8]; \n  default:_rOneHotOutput = wOneHotInputs[1]; \n  endcase \n  end \n  end else if( C_SELECT_WIDTH == 8) begin \n  always @(*) begin \n  case(ONE_HOT_SELECT) \n  8'b00000001: _rOneHotOutput = wOneHotInputs[1]; \n  8'b00000010: _rOneHotOutput = wOneHotInputs[2]; \n  8'b00000100: _rOneHotOutput = wOneHotInputs[4]; \n  8'b00001000: _rOneHotOutput = wOneHotInputs[8]; \n  8'b00010000: _rOneHotOutput = wOneHotInputs[16]; \n  8'b00100000: _rOneHotOutput = wOneHotInputs[32]; \n  8'b01000000: _rOneHotOutput = wOneHotInputs[64]; \n  8'b10000000: _rOneHotOutput = wOneHotInputs[128]; \n  default:_rOneHotOutput = wOneHotInputs[1]; \n  endcase \n  end \n  end \n  endgenerate \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an interface for a synchronous SRAM (Static Random-Access Memory) component. It has input ports for clock, read address, write enable, write address, and write data, as well as an output port for read data. Inside the module, it instantiates the SRAMVerilogAWS module, which interfaces with the actual SRAM hardware. It connects the input and output ports of this module to corresponding signals of the SRAMVerilogAWS module. The module also controls the flow, write enable, address enable, and clock signals for the SRAM. It essentially serves as a bridge between the external signals and the internal operation of the SRAM hardware.\n\n Module header:\n\nmodule SRAM_3(input clock,input [4:0] io_raddr,input io_wen,input [4:0] io_waddr,input [31:0] io_wdata,output [31:0] io_rdata);\n [/INST]\n", "output": "wire [31:0] SRAMVerilogAWS_rdata; \n  wire [31:0] SRAMVerilogAWS_wdata; \n  wire SRAMVerilogAWS_flow; \n  wire SRAMVerilogAWS_wen; \n  wire SRAMVerilogAWS_waddrEn; \n  wire SRAMVerilogAWS_raddrEn; \n  wire [4:0] SRAMVerilogAWS_waddr; \n  wire [4:0] SRAMVerilogAWS_raddr; \n  wire SRAMVerilogAWS_clk; \n  wire [31:0] _T_9; \n SRAMVerilogAWS #(.DWIDTH(32), .WORDS(32), .AWIDTH(5)) SRAMVerilogAWS (.rdata(SRAMVerilogAWS_rdata),.wdata(SRAMVerilogAWS_wdata),.flow(SRAMVerilogAWS_flow),.wen(SRAMVerilogAWS_wen),.waddrEn(SRAMVerilogAWS_waddrEn),.raddrEn(SRAMVerilogAWS_raddrEn),.waddr(SRAMVerilogAWS_waddr),.raddr(SRAMVerilogAWS_raddr),.clk(SRAMVerilogAWS_clk)); \n  assign io_rdata = _T_9; \n  assign SRAMVerilogAWS_wdata = io_wdata; \n  assign SRAMVerilogAWS_flow = 1'h1; \n  assign SRAMVerilogAWS_wen = io_wen; \n  assign SRAMVerilogAWS_waddrEn = 1'h1; \n  assign SRAMVerilogAWS_raddrEn = 1'h1; \n  assign SRAMVerilogAWS_waddr = io_waddr; \n  assign SRAMVerilogAWS_raddr = io_raddr; \n  assign SRAMVerilogAWS_clk = clock; \n  assign _T_9 = SRAMVerilogAWS_rdata; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements an ALU (Arithmetic Logic Unit) with two 32-bit inputs a and b, a 5-bit control input aluc, and a 32-bit output result. The ALU performs operations based on the control input aluc, including addition, subtraction, bitwise AND, bitwise OR, left shift, right shift, and conditional left shift. The result is assigned based on the selected operation.\n\n Module header:\n\nmodule alu(a,b,aluc,result);\n [/INST]\n", "output": "input wire [31:0] a,b; \n  input wire [4:0] aluc; \n  output reg [31:0] result; \n  always @* \n  begin \n  case(aluc) \n  5'd0: \n  begin \n  result=a+b; \n  end \n  5'd1: \n  begin \n  result=a-b; \n  end \n  5'd2: \n  begin \n  result=a&b; \n  end \n  5'd3: \n  begin \n  result=a|b; \n  end \n  5'd6: \n  begin \n  result=b<<a; \n  end \n  5'd10: \n  begin \n  result=b>>a; \n  end \n  5'd8: \n  begin \n  result=(b>>a)|({32{b[31]}}<<(32'd32)); \n  end \n  default: \n  begin \n  result=0; \n  end \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a 2-to-1 multiplexer with 26 outputs. It selects either D0 or D1 as the output S based on the value of the control signal ctrl. Additionally, it includes reset signals for each of the 26 output bits, setting them to 0. The module also includes an annotation for synthesis.\n\n Module header:\n\nmodule Multiplexer_AC_W26_0 ( ctrl, D0, D1, S );\n [/INST]\n", "output": "input [25:0] D0; \n  input [25:0] D1; \n  output [25:0] S; \n  input ctrl; \n  assign S[2] = ctrl; \n  assign S[25] = 1'b0; \n  assign S[24] = 1'b0; \n  assign S[23] = 1'b0; \n  assign S[22] = 1'b0; \n  assign S[21] = 1'b0; \n  assign S[20] = 1'b0; \n  assign S[19] = 1'b0; \n  assign S[18] = 1'b0; \n  assign S[17] = 1'b0; \n  assign S[16] = 1'b0; \n  assign S[15] = 1'b0; \n  assign S[14] = 1'b0; \n  assign S[13] = 1'b0; \n  assign S[12] = 1'b0; \n  assign S[11] = 1'b0; \n  assign S[10] = 1'b0; \n  assign S[9] = 1'b0; \n  assign S[8] = 1'b0; \n  assign S[7] = 1'b0; \n  assign S[6] = 1'b0; \n  assign S[5] = 1'b0; \n  assign S[4] = 1'b0; \n  assign S[3] = 1'b0; \n  assign S[1] = 1'b0; \n  assign S[0] = 1'b0; \n initial $sdf_annotate(\"FPU_Add_Subtract_Function_syn.sdf\"); \n  endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a VGA graphics controller that interfaces with a VRAM. It handles the reading and writing of data to the VRAM based on control signals and addresses. It also incorporates buffers and logic to select the appropriate VRAM output data. Additionally, it includes a VGA graphics module that generates the necessary synchronization signals and RGB outputs for the VGA display.\n\n Module header:\n\nmodule vgatopgfx(input clk,input rst,input clk25mhz,output hsync,output vsync,output [3:0] rgb,input clsrq,output reg clsack,input bufswap,input [19:0] vmem_in_addr,input [7:0] vmem_in_data,input vmem_we,input vmem_re,output [7:0] vmem_p1_out_data,output vga_scan);\n [/INST]\n", "output": "wire [19:0] vmem_out_addr; \n  wire [7:0] vmem_out_data; \n  reg clsing; \n  reg [19:0] clsaddr; \n  wire [19:0] vmem_in_addr_x; \n  wire [7:0] vmem_in_data_x; \n  wire vmem_we_x; \n  reg [19:0] vmem_in_addr_r; \n  reg [7:0] vmem_in_data_r; \n  reg vmem_we_r; \n  assign vmem_in_addr_x = clsing?clsaddr:vmem_in_addr_r; \n  assign vmem_in_data_x = clsing?0:vmem_in_data_r; \n  assign vmem_we_x = clsing|vmem_we_r; \n  wire vmem_re_x; \n  assign vmem_re_x = clsing?0:vmem_re; \n  always @(posedge clk) \n  if (!rst) begin \n  clsing <= 0; \n  clsack <= 0; \n  clsaddr <= 0; \n  vmem_in_addr_r <= 0; \n  vmem_in_data_r <= 0; \n  vmem_we_r <= 0; \n  end else begin \n  vmem_in_addr_r <= vmem_in_addr; \n  vmem_in_data_r <= vmem_in_data; \n  vmem_we_r <= vmem_we; \n  if (clsack) clsack <= 0; \n  else if (clsrq && !clsing) begin \n  clsing <= 1; \n  clsaddr <= 0; \n  clsack <= 0; \n  end else if (clsing) begin \n  clsaddr <= clsaddr + 1; \n  if (clsaddr == 153600) begin \n  clsack <= 1; \n  clsing <= 0; \n  end \n  end \n  end \n  wire buf1; \n  wire buf2; \n  assign buf1 = bufswap; \n  assign buf2 = ~bufswap; \n  wire [7:0] vmem_out_data_1; \n  wire [7:0] vmem_out_data_2; \n  assign vmem_out_data = buf1?vmem_out_data_1:vmem_out_data_2; \n  wire [7:0] vmem_p1_out_data_1; \n  wire [7:0] vmem_p1_out_data_2; \n  assign vmem_p1_out_data = buf2?vmem_p1_out_data_1:vmem_p1_out_data_2; \n vram vram1(.clk(clk),.p1_addr(vmem_in_addr_x),.p1_data(vmem_in_data_x),.p1_we(buf2?vmem_we_x:0),.p1_re(buf2?vmem_re_x:0),.p1_data_out(vmem_p1_out_data_1),.p2_addr(vmem_out_addr),.p2_data(vmem_out_data_1)); \n vram vram2(.clk(clk),.p1_addr(vmem_in_addr_x),.p1_data(vmem_in_data_x),.p1_we(buf1?vmem_we_x:0),.p1_re(buf2?vmem_re_x:0),.p1_data_out(vmem_p1_out_data_2),.p2_addr(vmem_out_addr),.p2_data(vmem_out_data_2)); \n vgagfx vga1(.clk(clk),.rst(rst),.clk25mhz(clk25mhz),.vmem_data(vmem_out_data),.vmem_addr(vmem_out_addr),.hsync(hsync),.vsync(vsync),.rgb(rgb),.scan(vga_scan)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a K-input LUT (Look-Up Table) with K inputs and 2^K entries in the LUT_MASK. The output is determined by the value stored in LUT_MASK at the index specified by the input.\n\n Module header:\n\nmodule LUT_K #(parameter K = 6,parameter LUT_MASK={2**K{1'b0}}) (input [K-1:0] in,output out);\n [/INST]\n", "output": "assign out = LUT_MASK[in]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a synchronous SRAM memory controller with read and write functionality. It includes a state machine to control the memory access operations based on the input signals. The module reads and writes data to the SRAM based on the control signals and updates the acknowledgment signal accordingly. It also handles the latency of the SRAM, ensuring proper timing for read and write operations. The module uses the clock and reset signals to synchronize its operations.\n\n Module header:\n\nmodule wb_sram16 #(parameter adr_width = 19,parameter latency = 0) (input clk,input reset,input wb_stb_i,input wb_cyc_i,input wb_tga_i,output reg wb_ack_o,input wb_we_i,input [18:0] wb_adr_i,input [1:0] wb_sel_i,input [15:0] wb_dat_i,output reg [15:0] wb_dat_o,output reg [adr_width-1:0] sram_adr,inout [15:0] sram_dat,output reg [1:0] sram_be_n,output reg sram_ce_n,output reg sram_oe_n,output reg sram_we_n);\n [/INST]\n", "output": "wire wb_rd = wb_stb_i & wb_cyc_i & ~wb_we_i & ~wb_ack_o; \n wire wb_wr = wb_stb_i & wb_cyc_i & wb_we_i & ~wb_ack_o; \n wire [adr_width-1:0] adr = wb_adr_i[adr_width-1:0]; \n reg [15:0] wdat; \n reg wdat_oe; \n assign sram_dat = wdat_oe ? wdat : 16'bz; \n reg [2:0] lcount; \n parameter s_idle = 0; \n parameter s_read = 1; \n parameter s_write = 2; \n reg [2:0] state; \n always @(posedge clk) \n begin \n  if (reset) begin \n  state <= s_idle; \n  lcount <= 0; \n  wb_ack_o <= 0; \n  end else begin \n  case (state) \n  s_idle: begin \n  wb_ack_o <= 0; \n  if (wb_rd) begin \n  sram_ce_n <= 0; \n  sram_oe_n <= 0; \n  sram_we_n <= 1; \n  sram_adr <= adr; \n  sram_be_n <= 2'b00; \n  wdat_oe <= 0; \n  lcount <= latency; \n  state <= s_read; \n  end else if (wb_wr) begin \n  sram_ce_n <= 0; \n  sram_oe_n <= 1; \n  sram_we_n <= 0; \n  sram_adr <= adr; \n  sram_be_n <= ~wb_sel_i; \n  wdat <= wb_dat_i; \n  wdat_oe <= 1; \n  lcount <= latency; \n  state <= s_write; \n  end else begin \n  sram_ce_n <= 1; \n  sram_oe_n <= 1; \n  sram_we_n <= 1; \n  wdat_oe <= 0; \n  end \n  end \n  s_read: begin \n  if (lcount != 0) begin \n  lcount <= lcount - 1; \n  end else begin \n  sram_ce_n <= 1; \n  sram_oe_n <= 1; \n  sram_we_n <= 1; \n  wb_dat_o <= sram_dat; \n  wb_ack_o <= 1; \n  state <= s_idle; \n  end \n  end \n  s_write: begin \n  if (lcount != 0) begin \n  lcount <= lcount - 1; \n  end else begin \n  sram_ce_n <= 1; \n  sram_oe_n <= 1; \n  sram_we_n <= 1; \n  wb_ack_o <= 1; \n  state <= s_idle; \n  end \n  end \n  endcase \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a data stream interface with input and output signals. It registers the stream_in_data to stream_out_data_registered on the positive edge of the clock. It also directly assigns the value of stream_in_data to stream_out_data_comb. Additionally, it sets stream_in_ready to the value of stream_out_ready. Lastly, it initializes the waveform dumping process to the file 'waveform.vcd' for simulation.\n\n Module header:\n\nmodule sample_module (input clk,output reg stream_in_ready,input stream_in_valid,input [7:0] stream_in_data,input [63:0] stream_in_data_wide,input stream_out_ready,output reg [7:0] stream_out_data_comb,output reg [7:0] stream_out_data_registered);\n [/INST]\n", "output": "always @(posedge clk) \n  stream_out_data_registered <= stream_in_data; \n always @(stream_in_data) \n  stream_out_data_comb = stream_in_data; \n always @(stream_out_ready) \n  stream_in_ready = stream_out_ready; \n initial begin \n  $dumpfile(\"waveform.vcd\"); \n  $dumpvars(0,sample_module); \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an ALU function for activation with parameterized inputs. It takes in control signals and data inputs, and produces an output based on a fixed-point multiplier and adder. The module calculates the final sum and sets the output accordingly based on the control signals and the enable signal. The output error is set to the logical OR of Error1 and Error2. The module also includes fixed-point multiplier and adder instances.\n\n Module header:\n\nmodule ALUfuncionActivacion #(parameter Width = 24, Magnitud = 4, Precision = 19, Signo = 1) (SELMUX,Enable,M,B,In,Out,Error);\n [/INST]\n", "output": "input [4:0] SELMUX; \n  input Enable; \n  input signed [Width-1:0] M,B,In; \n  output Error; \n  output reg signed [Width-1:0] Out = 0; \n  wire signed [Width-1:0] Aux,OutSum; \n  wire Error1,Error2; \n  multiplicadorPuntoFijo #(.Width(Width), .Magnitud(Magnitud), .Precision(Precision),.Signo(Signo)) \n multiplicadorPuntoFijoCopia1 (.EnableMul(Enable),.In(In),.Coeff(M),.OutMul(Aux),.Error(Error1)); \n  sumadorPuntoFijo #(.Width(Width), .Magnitud(Magnitud), .Precision(Precision),.Signo(Signo)) \n sumadorPuntoFijocopia1 (.EnableSum(Enable),.In(B),.Acumulador(Aux),.OutSum(OutSum),.Error(Error2)); \n  always@* begin \n  if(Enable) begin \n  if(SELMUX==5'd0) \n  Out <= 0; \n  else if (SELMUX==5'd31) \n  Out <= 1; \n  else \n  Out <= OutSum; \n  end else begin \n  Out <= 0; \n  end \n  end \n  assign Error = Error2 | Error1; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module checks certain conditions based on the inputs and sets different output signals accordingly. The output signals pc_stall, ifid_stall, idex_stall, and inst_stall are determined by the logical conditions involving the inputs and the write_done signal. If the write_done signal is high, then all output signals are low. Otherwise, if specific conditions involving the inputs are met, the corresponding output signal is set high; otherwise, it is set low.\n\n Module header:\n\nmodule hdUnit(d_raddr1, d_raddr2, d_addrselector, d_jr_or_exec, d_immonly, d_opcode, e_isLoad, e_wreg,pc_stall, ifid_stall, idex_stall, inst_stall,write_done);\n [/INST]\n", "output": "input [3:0] d_raddr1; \n input [3:0] d_raddr2; \n input d_addrselector; \n input d_jr_or_exec; \n input d_immonly; \n input [3:0] d_opcode; \n input e_isLoad; \n input [3:0] e_wreg; \n input write_done; \n output pc_stall; \n output ifid_stall; \n output idex_stall; \n output inst_stall; \n assign pc_stall = (write_done === 1'b1)? 1'b0 :(e_isLoad===1'b1 && d_immonly!==1'b1 && e_wreg!==4'b000 && ((d_opcode!==4'b1000 && d_addrselector===1'b1 && d_jr_or_exec!==1'b1 && (d_raddr1===e_wreg || d_raddr2===e_wreg)) ||(d_opcode!==4'b1000 && d_addrselector===1'b1 && d_jr_or_exec===1'b1 && (d_raddr2===e_wreg)) ||(d_opcode!==4'b1000 && d_addrselector!==1'b1 && (d_raddr1===e_wreg || d_raddr2===e_wreg)) ||(d_opcode===4'b1000 && d_addrselector!==1'b1 && d_raddr1===e_wreg))) ? 1'b1 : 1'b0; \n assign ifid_stall = (write_done === 1'b1)? 1'b0 :(e_isLoad===1'b1 && d_immonly!==1'b1 && e_wreg!==4'b000 && ((d_opcode!==4'b1000 && d_addrselector===1'b1 && d_jr_or_exec!==1'b1 && (d_raddr1===e_wreg || d_raddr2===e_wreg)) ||(d_opcode!==4'b1000 && d_addrselector===1'b1 && d_jr_or_exec===1'b1 && (d_raddr2===e_wreg)) ||(d_opcode!==4'b1000 && d_opcode!==4'b1000 && d_addrselector!==1'b1 && (d_raddr1===e_wreg || d_raddr2===e_wreg)) ||(d_opcode===4'b1000 && d_addrselector!==1'b1 && d_raddr1===e_wreg))) ? 1'b1 : 1'b0; \n assign idex_stall = (write_done === 1'b1)? 1'b0 :(e_isLoad===1'b1 && d_immonly!==1'b1 && e_wreg!==4'b000 && ((d_opcode!==4'b1000 && d_addrselector===1'b1 && d_jr_or_exec!==1'b1 && (d_raddr1===e_wreg || d_raddr2===e_wreg)) ||(d_opcode!==4'b1000 && d_addrselector===1'b1 && d_jr_or_exec===1'b1 && (d_raddr2===e_wreg)) ||(d_opcode!==4'b1000 && d_addrselector!==1'b1 && (d_raddr1===e_wreg || d_raddr2===e_wreg)) ||(d_opcode===4'b1000 && d_addrselector!==1'b1 && d_raddr1===e_wreg))) ? 1'b1 : 1'b0; \n assign inst_stall = (write_done === 1'b1)? 1'b0 :(e_isLoad===1'b1 && d_immonly!==1'b1 && e_wreg!==4'b000 && ((d_opcode!==4'b1000 && d_addrselector===1'b1 && d_jr_or_exec!==1'b1 && (d_raddr1===e_wreg || d_raddr2===e_wreg)) ||(d_opcode!==4'b1000 && d_addrselector===1'b1 && d_jr_or_exec===1'b1 && (d_raddr2===e_wreg)) ||(d_opcode!==4'b1000 && d_addrselector!==1'b1 && (d_raddr1===e_wreg || d_raddr2===e_wreg)) ||(d_opcode===4'b1000 && d_addrselector!==1'b1 && d_raddr1===e_wreg))) ? 1'b1 : 1'b0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes several inputs such as reset, clock, input and output enables, input and output addresses, read/write control signals, data input, and a set of switches. It provides two sets of 32-bit data outputs, one for input and one for output. The module assigns the input data to a fixed value of 32'h00000000 and concatenates the input switches with 24'h000000 to form the output data. This module effectively interfaces input and output data with external switches.\n\n Module header:\n\nmodule mod_switches(rst, clk, ie, de, iaddr, daddr, drw, din, iout, dout, switches);\n [/INST]\n", "output": "input rst; \n  input clk; \n  input ie,de; \n  input [31:0] iaddr, daddr; \n  input [1:0] drw; \n  input [31:0] din; \n  output [31:0] iout, dout; \n  input [7:0] switches; \n  wire [31:0] idata, ddata; \n  assign iout = idata; \n  assign dout = ddata; \n  assign idata = 32'h00000000; \n  assign ddata = {24'h000000,switches}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"satadd\" is a saturation adder that takes two 12-bit inputs \"a\" and \"b\", along with a 2-bit \"mode\" input, and produces a 12-bit output \"y\". It consists of a 13-bit adder and logic to handle saturation conditions.\n\nThe module includes internal wires to represent the sign bits of \"a\", \"b\", and the result \"r\", as well as a carry-out signal \"cout\" and a \"vFlag\" for overflow detection. The 13-bit sum \"r\" is computed using the add13bit module.\n\nThe saturation logic within the module ensures that the result \"y\" is saturated to the minimum or maximum value if overflow occurs. This is achieved through separate blocks for signed saturation \"sSatSum\" and unsigned saturation \"uSatSum\", each using a case statement to determine the appropriate output based on the \"vFlag\" and \"cout\" signals, and the \"mode\" selection.\n\nThe final result \"y\" is determined based on the \"mode\" input, selecting between unsigned saturation, signed saturation, or simply the 12-bit result \"r\" in different cases.\n\n Module header:\n\nmodule satadd(a,b,mode,y);\n [/INST]\n", "output": "input [11:0] a,b; \n  input [1:0] mode; \n  output [11:0] y; \n  wire aSign, bSign, rSign, cout, vFlag; \n  wire [12:0] r; \n  add13bit u1 (.a({1'b0,a}), .b({1'b0,b}), .s(r)); \n  assign vFlag = (~aSign & ~bSign & rSign | aSign & bSign & ~rSign); \n  assign cout = r[12]; \n  assign rSign = r[11]; \n  assign aSign = a[11]; \n  assign bSign = b[11]; \n  reg[11:0] sSatSum; \n  always @* begin \n  sSatSum = 'h000; \n  case(vFlag) \n  1'b0: \n  sSatSum = r[11:0]; \n  1'b1: \n  begin \n  if(aSign == 1 & bSign == 1 & rSign == 0) \n  sSatSum = 'h800; \n  else \n  sSatSum = 'h7FF; \n  end \n  endcase \n  end \n  reg[11:0] uSatSum; \n  always @* begin \n  uSatSum = 'h000; \n  case(cout) \n  1'b0: \n  uSatSum = r[11:0]; \n  1'b1: \n  uSatSum = 'hFFF; \n  endcase \n  end \n  reg[11:0] result; \n  always @* begin \n  result = 'h000; \n  case(mode) \n  2'b00: \n  result = uSatSum; \n  2'b01: \n  result = sSatSum; \n  2'b10: \n  result = r[11:0]; \n  2'b11: \n  result = r[11:0]; \n  endcase \n  end \n  assign y = result; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a ray buffer with multiple inputs and outputs for handling ray data. It includes logic for enabling various ports based on the ray write enable signal. The module also manages the active ray group, reset signal, and ray group ID based on the input signals and clock. It utilizes multiple dual-port RAM modules to store and access the original X, Y, and Z values as well as the direction X, Y, and Z values. Additionally, it uses a single-bit DRAM cell to handle the swap operation.\n\n Module header:\n\n module raybuffer (origx, origy, origz, dirx, diry, dirz, raygroupID, swap, resetout, enablenear, raydata, rayaddr, raywe, subraynum, clk);\n [/INST]\n", "output": "output[27:0] origx; \n  wire[27:0] origx; \n  output[27:0] origy; \n  wire[27:0] origy; \n  output[27:0] origz; \n  wire[27:0] origz; \n  output[15:0] dirx; \n  wire[15:0] dirx; \n  output[15:0] diry; \n  wire[15:0] diry; \n  output[15:0] dirz; \n  wire[15:0] dirz; \n  output[1:0] raygroupID; \n  reg[1:0] raygroupID; \n  output swap; \n  wire swap; \n  output resetout; \n  reg resetout; \n  output enablenear; \n  reg enablenear; \n  input[31:0] raydata; \n  input[3:0] rayaddr; \n  input[2:0] raywe; \n  input[1:0] subraynum; \n  input clk; \n  wire origxwe; \n  wire origywe; \n  wire origzwe; \n  wire dirxwe; \n  wire dirywe; \n  wire dirzwe; \n  wire swapwe; \n  wire raygroupwe; \n  wire[3:0] raddr; \n  reg[1:0] activeraygroup; \n  wire swapvect; \n  reg resetl; \n  reg[1:0] raygroupIDl; \n  reg enablenearl; \n  assign raddr = {activeraygroup, subraynum} ; \n  always @(posedge clk) \n  begin \n  resetl <= raygroupwe ; \n  resetout <= resetl ; \n  raygroupID <= raygroupIDl ; \n  enablenear <= enablenearl ; \n  if (raygroupwe == 1'b1) \n  begin \n  activeraygroup <= rayaddr[1:0] ; \n  enablenearl <= raydata[0] ; \n  raygroupIDl <= rayaddr[3:2] ; \n  end \n  end \n  assign origxwe = (raywe == 3'b001) ? 1'b1 : 1'b0 ; \n  assign origywe = (raywe == 3'b010) ? 1'b1 : 1'b0 ; \n  assign origzwe = (raywe == 3'b011) ? 1'b1 : 1'b0 ; \n  assign dirxwe = (raywe == 3'b100) ? 1'b1 : 1'b0 ; \n  assign dirywe = (raywe == 3'b100) ? 1'b1 : 1'b0 ; \n  assign dirzwe = (raywe == 3'b101) ? 1'b1 : 1'b0 ; \n  assign swapwe = (raywe == 3'b101) ? 1'b1 : 1'b0 ; \n  assign raygroupwe = (raywe == 3'b111) ? 1'b1 : 1'b0 ; \n  dpram28 origxram(origxwe, origx, raydata[27:0], clk); \n  dpram28 origyram(origywe, origy, raydata[27:0], clk); \n  dpram28 origzram(origzwe, origz, raydata[27:0], clk); \n  dpram16 dirxram(dirxwe, dirx, raydata[15:0], clk); \n  dpram16 diryram(dirywe, diry, raydata[31:16], clk); \n  dpram16 dirzram(dirzwe, dirz, raydata[15:0], clk); \n  dpram1 swapram(swapwe, swapvect, raydata[16], clk); \n  assign swap = swapvect ; \n  endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a configurable logic block with various modes of operation. It includes a lookup table (lut) initialized with a 16-bit value, and combinatorial logic based on the input signals A, B, C, D, SEL, F1, FCI, WAD0, WAD1, WAD2, WAD3, WD, WCK, WRE, and an output F. \n\nIn \"DPRAM\" mode, the module behaves as a dual-port RAM where the input data WD is written to the lut address specified by the WAD signals on the positive edge of WCK when WRE is asserted.\n\nIn \"CCU2\" mode, the module implements logic functions for the output F and FCO based on the input signals. When SEL is true, the output OFX is set to F1, otherwise, it is set to F.\n\n Module header:\n\nmodule OXIDE_COMB(input A, B, C, D,input SEL,input F1,input FCI,input WAD0, WAD1, WAD2, WAD3,input WD,input WCK, WRE,output F,output OFX);\n [/INST]\n", "output": "parameter MODE = \"LOGIC\"; \n  parameter [15:0] INIT = 16'h0000; \n  parameter INJECT = \"YES\"; \n  localparam inject_p = (INJECT == \"YES\") ? 1'b1 : 1'b0; \n  reg [15:0] lut = INIT; \n  wire [7:0] s3 = D ? INIT[15:8] : INIT[7:0]; \n  wire [3:0] s2 = C ? s3[ 7:4] : s3[3:0]; \n  wire [1:0] s1 = B ? s2[ 3:2] : s2[1:0]; \n  wire Z = A ? s1[1] : s1[0]; \n  wire [3:0] s2_3 = C ? INIT[ 7:4] : INIT[3:0]; \n  wire [1:0] s1_3 = B ? s2_3[ 3:2] : s2_3[1:0]; \n  wire Z3 = A ? s1_3[1] : s1_3[0]; \n  generate \n  if (MODE == \"DPRAM\") begin \n  always @(posedge WCK) \n  if (WRE) \n  lut[{WAD3, WAD2, WAD1, WAD0}] <= WD; \n  end \n  if (MODE == \"CCU2\") begin \n  assign F = Z ^ (FCI & ~inject_p); \n  assign FCO = Z ? FCI : (Z3 & ~inject_p); \n  end else begin \n  assign F = Z; \n  end \n  endgenerate \n  assign OFX = SEL ? F1 : F; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `seg7x16` implements a 16-bit counter `cnt` which increments on every clock cycle and a 3-bit address counter `seg7_addr` which increments on every 16th cycle of `cnt`. The input data `i_data` is stored in `i_data_store` on the assertion of the `cs` signal. Based on the `seg7_addr`, specific nibbles of `i_data_store` are assigned to `seg_data_r`. The 7-segment output `o_seg` and the selection signal `o_sel` are determined based on the values of `seg_data_r` and `seg7_addr`. When the `reset` signal is asserted, the counters and the stored data are reset to their initial values.\n\n Module header:\n\nmodule seg7x16(input clk,input reset,input cs,input [31:0] i_data,output [7:0] o_seg,output [7:0] o_sel);\n [/INST]\n", "output": "reg [14:0] cnt; \n  always @ (posedge clk, posedge reset) \n  if (reset) \n  cnt <= 0; \n  else \n  cnt <= cnt + 1'b1; \n  wire seg7_clk = cnt[14]; \n  reg [2:0] seg7_addr; \n  always @ (posedge seg7_clk, posedge reset) \n  if(reset) \n  seg7_addr <= 0; \n  else \n  seg7_addr <= seg7_addr + 1'b1; \n  reg [7:0] o_sel_r; \n  always @ (*) \n  case(seg7_addr) \n  7 : o_sel_r = 8'b01111111; \n  6 : o_sel_r = 8'b10111111; \n  5 : o_sel_r = 8'b11011111; \n  4 : o_sel_r = 8'b11101111; \n  3 : o_sel_r = 8'b11110111; \n  2 : o_sel_r = 8'b11111011; \n  1 : o_sel_r = 8'b11111101; \n  0 : o_sel_r = 8'b11111110; \n  endcase \n  reg [31:0] i_data_store; \n  always @ (posedge clk, posedge reset) \n  if(reset) \n  i_data_store <= 0; \n  else if(cs) \n  i_data_store <= i_data; \n  reg [7:0] seg_data_r; \n  always @ (*) \n  case(seg7_addr) \n  0 : seg_data_r = i_data_store[3:0]; \n  1 : seg_data_r = i_data_store[7:4]; \n  2 : seg_data_r = i_data_store[11:8]; \n  3 : seg_data_r = i_data_store[15:12]; \n  4 : seg_data_r = i_data_store[19:16]; \n  5 : seg_data_r = i_data_store[23:20]; \n  6 : seg_data_r = i_data_store[27:24]; \n  7 : seg_data_r = i_data_store[31:28]; \n  endcase \n  reg [7:0] o_seg_r; \n  always @ (posedge clk, posedge reset) \n  if(reset) \n  o_seg_r <= 8'hff; \n  else \n  case(seg_data_r) \n  4'h0 : o_seg_r <= 8'hC0; \n  4'h1 : o_seg_r <= 8'hF9; \n  4'h2 : o_seg_r <= 8'hA4; \n  4'h3 : o_seg_r <= 8'hB0; \n  4'h4 : o_seg_r <= 8'h99; \n  4'h5 : o_seg_r <= 8'h92; \n  4'h6 : o_seg_r <= 8'h82; \n  4'h7 : o_seg_r <= 8'hF8; \n  4'h8 : o_seg_r <= 8'h80; \n  4'h9 : o_seg_r <= 8'h90; \n  4'hA : o_seg_r <= 8'h88; \n  4'hB : o_seg_r <= 8'h83; \n  4'hC : o_seg_r <= 8'hC6; \n  4'hD : o_seg_r <= 8'hA1; \n  4'hE : o_seg_r <= 8'h86; \n  4'hF : o_seg_r <= 8'h8E; \n  endcase \n  assign o_sel = o_sel_r; \n  assign o_seg = o_seg_r; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module consists of two sequential always blocks that assign the input d to the output q1 on every positive edge of the clock signal, and the value of q1 to the output q2 on every positive edge of the clock signal. This creates a two-stage sequential logic circuit where q2 follows the value of q1, which in turn follows the input d.\n\n Module header:\n\nmodule abc9_test034(input clk, d, output reg q1, q2);\n [/INST]\n", "output": "always @(posedge clk) q1 <= d; \n always @(posedge clk) q2 <= q1; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module performs signed multiplication on two input signals A and B of width WIDTH. The output C is of width CWIDTH, which is twice the width of the inputs. The multiplication result is stored in the output signal C. The input Valid is used to indicate when the inputs A and B are valid. The module utilizes registers for A and B to store the input values, and the multiplication operation is performed using the A_q and B_q registers. The multiplication result is computed using C_int. The input valid_int is assigned the value of Valid. The input A_q is updated whenever the valid_int signal is asserted, and the same is true for the B_q input.\n\n Module header:\n\nmodule signed_mult (A,B,Valid,C);\n [/INST]\n", "output": "parameter WIDTH = 32; \n  parameter CWIDTH = 2 * WIDTH; \n  input [WIDTH-1:0] A, B; \n  input Valid; \n  output [CWIDTH-1:0] C; \n  reg signed [WIDTH-1:0] A_q, B_q; \n  wire signed [CWIDTH-1:0] C_int; \n  assign C_int = A_q * B_q; \n  assign valid_int = Valid; \n  assign C = C_int; \n  always @(*) if (valid_int == 1'b1) A_q <= A; \n  always @(*) if (valid_int == 1'b1) B_q <= B; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a data sampler FIFO with parameters for the input and output data widths. It uses a local parameter to calculate the FIFO reduction ratio. The module includes several registers such as trig_prev, trig_prev1, trig_prev2, trig_synced, busy, cnt, cnt1, and cnt2, which are used to manage the sampling process. The module also instantiates FIFO logic and a width reducer to handle the data flow. The main functionality involves managing the sampling process based on the TRIG signal, counting, and controlling the FIFO logic to sample and output data.\n\n Module header:\n\nmodule data_sampler_fifo #(parameter DIN_WIDTH = 512,parameter DOUT_WIDTH = 32) (input RESET,input CLK,input TRIG,input [DIN_WIDTH-1:0] DIN,input DIN_VALID,input DIN_CLK,output [DOUT_WIDTH-1:0] DOUT,output DOUT_EMPTY,input DOUT_RDEN);\n [/INST]\n", "output": "localparam FIFO_REDUCTION_RATIO = DIN_WIDTH / DOUT_WIDTH; \n  reg trig_prev, trig_prev1, trig_prev2, trig_synced, busy; \n  reg [3:0] cnt, cnt1; \n  reg [27:0] cnt2; \n  always @ (posedge CLK or posedge RESET) begin \n  if (RESET) begin \n  trig_prev <= 1; \n  trig_prev1 <= 1; \n  trig_prev2 <= 1; \n  trig_synced <= 0; \n  busy <= 0; \n  cnt <= 0; \n  cnt1 <= 0; \n  cnt2 <= 0; \n  end \n  else begin \n  cnt2 <= cnt2 + 1; \n  trig_prev <= TRIG | cnt2[27]; \n  trig_prev1 <= trig_prev; \n  trig_prev2 <= trig_prev1; \n  trig_synced <= 0; \n  if ((trig_prev2 == 0) && (trig_prev1 == 1)) begin \n  cnt1 <= 3; \n  end \n  if (cnt1 > 0) begin \n  trig_synced <= 1; \n  cnt1 <= cnt1 - 1; \n  end \n  if (!busy) begin \n  if (cnt < 15) begin \n  cnt <= cnt + 1; \n  trig_synced <= 0; \n  end \n  end \n  else begin \n  trig_synced <= 0; \n  end \n  if (trig_synced && cnt1 == 0) begin \n  busy <= 1; \n  end \n  end \n  end \n  wire [DIN_WIDTH-1:0] fifo_dout; \n  wire fifo_rden; \n  wire fifo_empty, fifo_full; \n  fifo512x fifo512x_inst \n (.rst(trig_synced | RESET),.wr_clk(DIN_CLK),.rd_clk(CLK),.din(DIN),.wr_en(DIN_VALID),.rd_en(fifo_rden),.dout(fifo_dout),.full(fifo_full),.empty(fifo_empty)); \n  fifo_rdwidth_reducer \n #(.RDWIDTH(32),.RDRATIO(FIFO_REDUCTION_RATIO),.SHIFTORDER(1)) \n  fifo_rdwidth_reducer_inst \n (.RESET(~busy | RESET),.CLK(CLK),.DIN(fifo_dout),.VALID(~fifo_empty),.RDREQ(fifo_rden),.DOUT(DOUT),.EMPTY(DOUT_EMPTY),.RD_EN(DOUT_RDEN)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a first-in-first-out (FIFO) memory with a depth of 1024 and a data bus width of 32 bits. It has separate clocks for reading and writing, as well as asynchronous clear functionality. The module provides read and write request inputs, along with read and write pointers and flags to indicate full, empty, and used conditions for both read and write operations. The module contains memory storage and handles the writing and reading of data to and from the memory based on the clock edges and request signals.\n\n Module header:\n\nmodule fifo_1c_1k ( data, wrreq, rdreq, rdclk, wrclk, aclr, q,rdfull, rdempty, rdusedw, wrfull, wrempty, wrusedw);\n [/INST]\n", "output": "parameter width = 32; \n  parameter depth = 1024; \n  input [31:0] data; \n  input wrreq; \n  input rdreq; \n  input rdclk; \n  input wrclk; \n  input aclr; \n  output [31:0] q; \n  output rdfull; \n  output rdempty; \n  output [9:0] rdusedw; \n  output wrfull; \n  output wrempty; \n  output [9:0] wrusedw; \n  reg [width-1:0] mem [0:depth-1]; \n  reg [7:0] rdptr; \n  reg [7:0] wrptr; \n `ifdef rd_req \n  reg [width-1:0] q; \n `else \n  wire [width-1:0] q; \n `endif \n  reg [9:0] rdusedw; \n  reg [9:0] wrusedw; \n  integer i; \n  always @( aclr) \n  begin \n  wrptr <= #1 0; \n  rdptr <= #1 0; \n  for(i=0;i<depth;i=i+1) \n  mem[i] <= #1 0; \n  end \n  always @(posedge wrclk) \n  if(wrreq) \n  begin \n  wrptr <= #1 wrptr+1; \n  mem[wrptr] <= #1 data; \n  end \n  always @(posedge rdclk) \n  if(rdreq) \n  begin \n  rdptr <= #1 rdptr+1; \n `ifdef rd_req \n  q <= #1 mem[rdptr]; \n `endif \n  end \n `ifdef rd_req \n `else \n  assign q = mem[rdptr]; \n `endif \n  always @(posedge wrclk) \n  wrusedw <= #1 wrptr - rdptr; \n  always @(posedge rdclk) \n  rdusedw <= #1 wrptr - rdptr; \n  assign wrempty = (wrusedw == 0); \n  assign wrfull = (wrusedw == depth-1); \n  assign rdempty = (rdusedw == 0); \n  assign rdfull = (rdusedw == depth-1); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements an energy monitoring counter with a configurable address and data width. It takes inputs from emon_vector and emon_sel to select the energy data and updates the emon_reg based on the reg_write and reg_data inputs. The emon_zero_flag output indicates zero energy detection. The module initializes the emon_reg to all 1's on reset and updates it with the new energy data or subtracts the selected energy data from it based on the control signals.\n\n Module header:\n\nmodule emon_counter (emon_reg, emon_zero_flag,clk, reset, emon_vector, emon_sel, reg_write, reg_data);\n [/INST]\n", "output": "parameter RFAW = 6; \n  parameter DW = 32; \n  input clk; \n  input reset; \n  input [15:0] emon_vector; \n  input [3:0] emon_sel; \n  input reg_write; \n  input [DW-1:0] reg_data; \n  output [DW-1:0] emon_reg; \n  output emon_zero_flag; \n  reg [DW-1:0] emon_reg; \n  reg emon_input; \n  always @(posedge clk) \n  emon_input <= emon_vector[emon_sel[3:0]]; \n  always @(posedge clk) \n  if(reset) \n  emon_reg[DW-1:0] <= {(DW){1'b1}}; \n  else if(reg_write) \n  emon_reg[DW-1:0] <= reg_data[DW-1:0]; \n  else \n  emon_reg[DW-1:0] <= emon_reg[DW-1:0] - {31'b0,emon_input}; \n  assign emon_zero_flag = ~(|emon_reg[DW-1:0]); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a clock generator that produces a 100kHz square wave output. It uses a 16-bit counter to divide the input clock frequency and toggles the output every 500 clock cycles. The output toggles between 1 and 0 every 500 cycles, effectively generating a 100kHz square wave. The module also includes a reset signal for initialization.\n\n Module header:\n\nmodule clock_100kHz(clk,rst_n,out_100kHz);\n [/INST]\n", "output": "input clk,rst_n; \n output reg out_100kHz; \n reg [15:0] counter; \n always @ (posedge clk or negedge rst_n) \n  if (!rst_n) \n  begin \n  out_100kHz <= 0; \n  counter <= 0; \n  end \n  else \n  if (counter == 16'd499) \n  begin \n  out_100kHz <= !out_100kHz; \n  counter <= 0; \n  end \n  else \n  begin \n  out_100kHz <= out_100kHz; \n  counter <= counter + 1; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a comparator that compares two input data streams and produces an output flag indicating whether the two streams are the same or different. The module has a configurable input width and operates on a clock signal and a reset signal. When the reset signal is asserted, the module initializes its internal state. When the clock signal rises, the module compares the input data streams and updates its internal state and output accordingly. If the test input is all zeros, the good output is set to indicate a match, otherwise it indicates a mismatch.\n\n Module header:\n\nmodule comparer #(parameter width=63)(input [width:0] Din,input [width:0] test,input CLK,input reset,output [width:0] Dout,output good);\n [/INST]\n", "output": "reg [width:0] Dtmp; \n reg tmpgood; \n always @(posedge CLK) \n begin \n  if (reset == 1) \n  begin \n  Dtmp <= 64'b0; \n  tmpgood <= 1; \n  end \n  else \n  begin \n  Dtmp <= Din; \n  if (test != 64'b0) \n  tmpgood <= 1; \n  else \n  tmpgood <= 0; \n  end \n end \n assign Dout = Dtmp; \n assign good = ~tmpgood; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an encoder that takes a 40-bit input and produces a 6-bit output. The output is determined based on the position of the first '1' in the input. For example, if the first '1' is at position 0, the output is 000000, if it's at position 1, the output is 000001, and so on until position 39, where the output is 100111. If there are no '1's in the input, the output is 000000.\n\n Module header:\n\nmodule encoder(in,out);\n [/INST]\n", "output": "input [39:0] in; \n output [5:0] out; \n assign out = (in[0]==1'b1)?6'd0: \n  (in[1]==1'b1)?6'd1: \n  (in[2]==1'b1)?6'd2: \n  (in[3]==1'b1)?6'd3: \n  (in[4]==1'b1)?6'd4: \n  (in[5]==1'b1)?6'd5: \n  (in[6]==1'b1)?6'd6: \n  (in[7]==1'b1)?6'd7: \n  (in[8]==1'b1)?6'd8: \n  (in[9]==1'b1)?6'd9: \n  (in[10]==1'b1)?6'd10: \n  (in[11]==1'b1)?6'd11: \n  (in[12]==1'b1)?6'd12: \n  (in[13]==1'b1)?6'd13: \n  (in[14]==1'b1)?6'd14: \n  (in[15]==1'b1)?6'd15: \n  (in[16]==1'b1)?6'd16: \n  (in[17]==1'b1)?6'd17: \n  (in[18]==1'b1)?6'd18: \n  (in[19]==1'b1)?6'd19: \n  (in[20]==1'b1)?6'd20: \n  (in[21]==1'b1)?6'd21: \n  (in[22]==1'b1)?6'd22: \n  (in[23]==1'b1)?6'd23: \n  (in[24]==1'b1)?6'd24: \n  (in[25]==1'b1)?6'd25: \n  (in[26]==1'b1)?6'd26: \n  (in[27]==1'b1)?6'd27: \n  (in[28]==1'b1)?6'd28: \n  (in[29]==1'b1)?6'd29: \n  (in[30]==1'b1)?6'd30: \n  (in[31]==1'b1)?6'd31: \n  (in[32]==1'b1)?6'd32: \n  (in[33]==1'b1)?6'd33: \n  (in[34]==1'b1)?6'd34: \n  (in[35]==1'b1)?6'd35: \n  (in[36]==1'b1)?6'd36: \n  (in[37]==1'b1)?6'd37: \n  (in[38]==1'b1)?6'd38: \n  (in[39]==1'b1)?6'd39: \n  6'b000000; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is designed to read status flags and generate an output based on the status of an external SPI flash memory. It uses an FDPE register to store the ram_empty_i0 input, and assigns the output based on the stored value. The module's functionality is dependent on the signals ext_spi_clk, AR, and ram_empty_i0.\n\n Module header:\n\nmodule system_axi_quad_spi_flash_0_rd_status_flags_as (out,ram_empty_i0,ext_spi_clk,AR);\n [/INST]\n", "output": "output out; \n  input ram_empty_i0; \n  input ext_spi_clk; \n  input [0:0]AR; \n  wire [0:0]AR; \n  wire ext_spi_clk; \n  (* DONT_TOUCH *) wire ram_empty_fb_i; \n  (* DONT_TOUCH *) wire ram_empty_i; \n  wire ram_empty_i0; \n  assign out = ram_empty_fb_i; \n  (* DONT_TOUCH *) \n  (* KEEP = \"yes\" *) \n  (* equivalent_register_removal = \"no\" *) \n FDPE #(.INIT(1'b1)) \n  ram_empty_fb_i_reg \n (.C(ext_spi_clk),.CE(1'b1),.D(ram_empty_i0),.PRE(AR),.Q(ram_empty_fb_i)); \n  (* DONT_TOUCH *) \n  (* KEEP = \"yes\" *) \n  (* equivalent_register_removal = \"no\" *) \n FDPE #(.INIT(1'b1)) \n  ram_empty_i_reg \n (.C(ext_spi_clk),.CE(1'b1),.D(ram_empty_i0),.PRE(AR),.Q(ram_empty_i)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a pipeline with registers and combinational logic. It includes an encoder, decoder, and large XOR components. The module is clocked, and it includes a reset signal for initialization. The pipeline is designed to update its internal state based on clock edges and a reset signal. It includes initial block for simulation setup, and it displays the values of certain signals at various points during the simulation. The module finishes the simulation upon completion.\n\n Module header:\n\nmodule tb_pipeline();\n [/INST]\n", "output": "wire [13:0] c; \n  wire [13:0] cx; \n  wire [3:0] q; \n  reg [3:0] b; \n  reg [3:0] r_b; \n  reg [13:0] e; \n  reg [13:0] r_e; \n  reg [13:0] r_c; \n  reg [13:0] rr_e; \n  reg [3:0] rr_b; \n  reg [13:0] r_qx; \n  reg [3:0] rb; \n  reg clk,reset; \n  reg [13:0] e2; \n encoder enc (r_b,c); \n decoder dec (r_qx,q); \n large_xor xr (r_c,rr_e,cx); \n  always begin \n  #10 clk = 0; \n  #10 clk = 1; \n  end \n  always@(posedge clk) \n  begin \n  if(reset) \n  begin \n  r_b<=0; \n  r_e<=0; \n  end \n  else \n  begin \n  r_e<=e; \n  r_b<=b; \n  end \n  end \n  always@(posedge clk) \n  begin \n  if(reset) \n  begin \n  r_c<=0; \n  rr_e<=0; \n  rr_b<=0; \n  end \n  else \n  begin \n  r_c<=c; \n  rr_e<=r_e; \n  rr_b<=r_b; \n  end \n  end \n  always@(posedge clk) \n  begin \n  if(reset) \n  begin \n  rb<=0; \n  end \n  else \n  begin \n  r_qx<=cx; \n  rb<=rr_b; \n  e2<=rr_e; \n  end \n  end \n  initial \n  begin \n  $display(\" << Starting the simulation >>\"); \n  reset=1; \n  #20; \n  reset=0; \n  b = $random; \n  e = 14'b00000000000000; \n  $display(q, \"<< Displaying q >>\"); \n  $display(rb, \"<< Displaying rb >>\"); \n  #20; \n  b = $random; \n  e = 14'b00000000000000; \n  $display(q, \"<< Displaying q >>\"); \n  $display(rb, \"<< Displaying rb >>\"); \n  #20; \n  b = $random; \n  e = 14'b00000100000000; \n  $display(q, \"<< Displaying q >>\"); \n  $display(rb, \"<< Displaying rb >>\"); \n  #20; \n  b = $random; \n  e = 14'b00000000000000; \n  $display(q, \"<< Displaying q >>\"); \n  $display(rb, \"<< Displaying rb >>\"); \n  #20; \n  b = $random; \n  e = 14'b00000000000000; \n  $display(q, \"<< Displaying q >>\"); \n  $display(rb, \"<< Displaying rb >>\"); \n  #20; \n  b = $random; \n  e = 14'b00000001000000; \n  $display(q, \"<< Displaying q >>\"); \n  $display(rb, \"<< Displaying rb >>\"); \n  #20; \n  b = $random; \n  e = 14'b00000000000000; \n  $display(q, \"<< Displaying q >>\"); \n  $display(rb, \"<< Displaying rb >>\"); \n  #20; \n  b = $random; \n  e = 14'b00000000000000; \n  $display(q, \"<< Displaying q >>\"); \n  $display(rb, \"<< Displaying rb >>\"); \n  #20; \n  b = $random; \n  e = 14'b00000100000000; \n  $display(q, \"<< Displaying q >>\"); \n  $display(rb, \"<< Displaying rb >>\"); \n  #20; \n  b = $random; \n  e = 14'b00000000000000; \n  $display(q, \"<< Displaying q >>\"); \n  $display(rb, \"<< Displaying rb >>\"); \n  #300; \n  $display(\" << Finishing the simulation >>\"); \n  $finish; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"ecc_check_pipe\" takes a clock signal, a data input \"data_i\", and a control signal \"bank_rd_m3\". It computes a 4-bit parity check \"check_group_6_0\" on specific bits of the input data. This parity result is then captured in a flip-flop \"check_group_6_0_q\" on the rising edge of the clock when \"bank_rd_m3\" is active. Finally, the output \"ecc_err_o\" is assigned the value of \"check_group_6_0_q\".\n\n Module header:\n\nmodule ecc_check_pipe (input logic clk,input logic bank_rd_m3,input logic [32:0] data_i,output logic ecc_err_o);\n [/INST]\n", "output": "logic [3:0] check_group_6_0; \n  logic check_group_6_0_q; \n  always_comb check_group_6_0 = {data_i[0], data_i[2], data_i[4], data_i[7] }; \n  always_ff @(posedge clk) if (bank_rd_m3) check_group_6_0_q <=^check_group_6_0; \n  assign ecc_err_o = check_group_6_0_q; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module detects singularity based on the inputs PTX, PTY, P1X, P1Y, P2X, and P2Y. It calculates the differences between these inputs, performs multiplications, and subtracts the results to determine the sine of the difference. The output \"sin\" is set to 1 if the difference is greater than or equal to 0, and 0 otherwise.\n\n Module header:\n\nmodule sing(input [11:0] PTX,input [11:0] PTY,input [11:0] P1X,input [11:0] P1Y,input [11:0] P2X,input [11:0] P2Y,output sin);\n [/INST]\n", "output": "wire signed [11:0] Sub1; \n  wire signed [11:0] Sub2; \n  wire signed [11:0] Sub3; \n  wire signed [11:0] Sub4; \n  wire signed [22:0] Sub5; \n  wire signed [22:0] Mult1; \n  wire signed [22:0] Mult2; \n  assign Sub1 = PTX - P2X; \n  assign Sub2 = P1Y - P2Y; \n  assign Sub3 = P1X - P2X; \n  assign Sub4 = PTY - P2Y; \n  assign Mult1 = Sub1 * Sub2; \n  assign Mult2 = Sub3 * Sub4; \n  assign Sub5 = Mult1 - Mult2; \n  assign sin = (Sub5 >= 0) ? 1 : 0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `SyncBit` synchronizes a single bit of data from one clock domain to another. It includes synchronization registers for both input and output. The input data is synchronized to the local clock domain, and then the synchronized data is further synchronized to the destination clock domain. The synchronization process is triggered by the respective clock signals, and there is a reset mechanism for initializing the synchronization registers. The synchronized output is determined based on the synchronized input data and an enable signal. Additionally, the module contains a parameter for the initial value of the synchronized bit.\n\n Module header:\n\nmodule SyncBit (sCLK,sRST_N,dCLK,sEN,sD_IN,dD_OUT);\n [/INST]\n", "output": "parameter init = 1'b0; \n  input sCLK; \n  input sRST_N; \n  input sEN; \n  input sD_IN; \n  input dCLK; \n  output dD_OUT; \n  reg sSyncReg; \n  reg dSyncReg1, dSyncReg2; \n  assign dD_OUT = dSyncReg2 ; \n  always @(posedge sCLK or negedge sRST_N) \n  begin \n  if (sRST_N ==0) \n  begin \n  sSyncReg <= `BSV_ASSIGNMENT_DELAY init ; \n  end \n  else \n  begin \n  if ( sEN ) \n  begin \n  sSyncReg <= `BSV_ASSIGNMENT_DELAY (sD_IN == 1'b1) ? 1'b1 : 1'b0 ; \n  end \n  end \n  end \n  always @(posedge dCLK or negedge sRST_N) \n  begin \n  if (sRST_N ==0) \n  begin \n  dSyncReg1 <= `BSV_ASSIGNMENT_DELAY init ; \n  dSyncReg2 <= `BSV_ASSIGNMENT_DELAY init ; \n  end \n  else \n  begin \n  dSyncReg1 <= `BSV_ASSIGNMENT_DELAY sSyncReg ; \n  dSyncReg2 <= `BSV_ASSIGNMENT_DELAY dSyncReg1 ; \n  end \n  end \n `ifdef BSV_NO_INITIAL_BLOCKS \n `else \n  initial \n  begin \n  sSyncReg = init ; \n  dSyncReg1 = init ; \n  dSyncReg2 = init ; \n  end \n `endif \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a priority encoder with two sub-encoders for an input data bus. The module has a 16-bit input data and a 4-bit output q. It uses two 3-bit sub-encoders, each for the lower and upper 8 bits of the input data. The output q is assigned based on the outputs of these sub-encoders, using logical operations to combine their outputs. The priority encoder effectively encodes the highest order set bit position from the input data into the output q.\n\n Module header:\n\nmodule sin_altpriority_encoder_r08 (data,q) ;\n [/INST]\n", "output": "input [15:0] data; \n  output [3:0] q; \n  wire [2:0] wire_altpriority_encoder5_q; \n  wire [2:0] wire_altpriority_encoder6_q; \n  wire wire_altpriority_encoder6_zero; \n  sin_altpriority_encoder_bv7 altpriority_encoder5 \n (.data(data[7:0]),.q(wire_altpriority_encoder5_q)); \n  sin_altpriority_encoder_be8 altpriority_encoder6 \n (.data(data[15:8]),.q(wire_altpriority_encoder6_q),.zero(wire_altpriority_encoder6_zero)); \n  assign \n  q = {(~ wire_altpriority_encoder6_zero), (({3{wire_altpriority_encoder6_zero}} & wire_altpriority_encoder5_q) | ({3{(~ wire_altpriority_encoder6_zero)}} & wire_altpriority_encoder6_q))}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module, `sparc_exu_div_32eql`, takes a 32-bit input and calculates the bitwise XOR of its consecutive bits, storing the result in `inxor`. It then computes the logical NOT of `notequal` and assigns the result to `equal`. The module also instantiates an ALU operation for further processing.\n\n Module header:\n\nmodule sparc_exu_div_32eql (equal,in);\n [/INST]\n", "output": "input [31:0] in; \n  output equal; \n  wire [31:0] inxor; \n  wire notequal; \n  assign inxor[0] = 1'b0; \n  assign inxor[1] = in[31] ^ in[30]; \n  assign inxor[2] = in[30] ^ in[29]; \n  assign inxor[3] = in[29] ^ in[28]; \n  assign inxor[4] = in[28] ^ in[27]; \n  assign inxor[5] = in[27] ^ in[26]; \n  assign inxor[6] = in[26] ^ in[25]; \n  assign inxor[7] = in[25] ^ in[24]; \n  assign inxor[8] = in[24] ^ in[23]; \n  assign inxor[9] = in[23] ^ in[22]; \n  assign inxor[10] = in[22] ^ in[21]; \n  assign inxor[11] = in[21] ^ in[20]; \n  assign inxor[12] = in[20] ^ in[19]; \n  assign inxor[13] = in[19] ^ in[18]; \n  assign inxor[14] = in[18] ^ in[17]; \n  assign inxor[15] = in[17] ^ in[16]; \n  assign inxor[16] = in[16] ^ in[15]; \n  assign inxor[17] = in[15] ^ in[14]; \n  assign inxor[18] = in[14] ^ in[13]; \n  assign inxor[19] = in[13] ^ in[12]; \n  assign inxor[20] = in[12] ^ in[11]; \n  assign inxor[21] = in[11] ^ in[10]; \n  assign inxor[22] = in[10] ^ in[9]; \n  assign inxor[23] = in[9] ^ in[8]; \n  assign inxor[24] = in[8] ^ in[7]; \n  assign inxor[25] = in[7] ^ in[6]; \n  assign inxor[26] = in[6] ^ in[5]; \n  assign inxor[27] = in[5] ^ in[4]; \n  assign inxor[28] = in[4] ^ in[3]; \n  assign inxor[29] = in[3] ^ in[2]; \n  assign inxor[30] = in[2] ^ in[1]; \n  assign inxor[31] = in[1] ^ in[0]; \n  assign equal = ~notequal; \n sparc_exu_aluor32 or32(.out (notequal),.in (inxor[31:0])); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a state machine timer that operates based on the ACLK and ARESETN signals. It has states such as Fetch, Decode, SMSTART, SMRESET, SMSTOP, SMLAP, SMSEND_Lo, and SMSEND_Hi, each of which transitions based on the input and state conditions. The module uses a counterR to keep track of time and sets the output mRet_tdata based on the state machine's internal variables. The state transitions are controlled by the ACLK signal and a set of conditions based on the inputs and internal state.\n\n Module header:\n\nmodule sm_timer_64 (output wire sCMD_tready ,input wire sCMD_tvalid ,input wire [31 : 0] sCMD_tdata ,input wire mRet_tready ,output wire mRet_tvalid ,output wire [31 : 0] mRet_tdata ,input wire ACLK ,input wire ARESETN);\n [/INST]\n", "output": "localparam Fetch = 8'b00000001; \n localparam Decode = 8'b00000010; \n localparam SMSTART = 8'b00000100; \n localparam SMRESET = 8'b00001000; \n localparam SMSTOP = 8'b00010000; \n localparam SMLAP = 8'b00100000; \n localparam SMSEND_Lo = 8'b01000000; \n localparam SMSEND_Hi = 8'b10000000; \n localparam OPSTART = 16'h1; \n localparam OPSTOP = 16'h2; \n localparam OPRESET = 16'h3; \n localparam OPREAD = 16'h4; \n localparam OPLAP = 16'h5; \n reg [ 7:0] state ; \n reg [31:0] instruction ; \n reg [31:0] rVal ; \n assign mRet_tdata = rVal; \n assign sCMD_tready = (state == Fetch); \n assign mRet_tvalid = (state == SMSEND_Lo || state == SMSEND_Hi); \n reg [63 : 0] counterR; \n reg rRESET; \n reg rEN; \n always @(posedge ACLK) begin \n  if (rRESET) begin \n  counterR <= 64'd0; \n  end \n  else begin \n  if (rEN) begin \n  counterR <= counterR + 1; \n  end \n  end \n end \n always @(posedge ACLK) \n begin \n  if(!ARESETN) begin \n  state <= Fetch; \n  instruction <= 32'd0; \n  rVal <= 32'd0; \n  rEN <= 1'b0; \n  rRESET<= 1'b1; \n  end \n  else begin \n  case (state) \n  Fetch: begin \n  rRESET <= 1'b0; \n  if (sCMD_tvalid == 1) begin \n  instruction <= sCMD_tdata; \n  state <= Decode; \n  end \n  else begin \n  state <= Fetch; \n  end \n  end \n  Decode: begin \n  case (instruction[31:16]) \n  OPSTART: begin \n  rEN <= 1'b1; \n  state <= Fetch; \n  end \n  OPSTOP: begin \n  rEN <= 1'b0; \n  state <= Fetch; \n  end \n  OPRESET: begin \n  rRESET <= 1'b1; \n  state <= Fetch; \n  end \n  OPREAD: begin \n  rVal <= counterR[31:0]; \n  state <= SMSEND_Lo; \n  end \n  default: begin \n  state <= Fetch; \n  end \n  endcase \n  end \n  SMSEND_Lo: begin \n  if (mRet_tready == 1) begin \n  rVal <= counterR[63:32]; \n  state <= SMSEND_Hi; \n  end \n  else begin \n  state <= SMSEND_Lo; \n  end \n  end \n  SMSEND_Hi: begin \n  if (mRet_tready == 1) begin \n  state <= Fetch; \n  end \n  else begin \n  state <= SMSEND_Hi; \n  end \n  end \n  endcase \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes in a clock signal and a 2-bit input xvecin, and outputs a 2-bit signal xvecout. The output xvecout is assigned with the first bit of xvecin and the value of the clock signal, concatenated together in that order.\n\n Module header:\n\nmodule test1 (clk,xvecin,xvecout);\n [/INST]\n", "output": "input clk; \n  input wire [1:0] xvecin; \n  output wire [1:0] xvecout; \n  assign xvecout = {xvecin[0], clk}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module implements a simple logical operation. It takes an input signal 'in' and outputs its complement 'out'. It uses the bitwise NOT operator to invert the input and assigns the result to the output.\n\n Module header:\n\nmodule exp (in, out);\n [/INST]\n", "output": "input in; \n  output out; \n  assign out = ~in; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a sine wave generator using a Direct Digital Synthesis (DDS) technique. It takes in a clock signal, frequency, amplitude, and amplitude offset as inputs, and generates a 12-bit sine wave as the output. The module uses a DDS compiler to generate the phase information and then computes the amplitude and offset for the sine wave. The amplitude is then clipped to fit within a specific range, and the output sine wave is dependent on the data validity.\n\n Module header:\n\nmodule sinemod(input clkdds,input[31:0] freq,input signed[15:0] amp,input signed[15:0] amp_off,output[11:0] sin);\n [/INST]\n", "output": "wire data_valid; \n reg phase_valid = 1; \n wire signed[16:0] data; \n wire[23:0] phase = (freq*83886)/10000; \n dds_compiler_0 sine_dds(clkdds, phase_valid, phase, data_valid, data); \n reg signed[16:0] amped = 16'b0; \n reg signed[16:0] offseted = 16'b0; \n reg signed[16:0] clipped = 16'b0; \n wire signed[16:0] amp_clipped = amp > 2048 ? 2048 : amp; \n always @(posedge clkdds) begin \n  amped <= (data * amp_clipped) / 1024; \n  offseted <= amp_off + amped; \n  clipped <= offseted < 0 ? 0 : offseted > 4095 ? 4095 : offseted; \n end \n assign sin = data_valid?clipped:0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module performs matrix multiplication operations using input signals to calculate sine and cosine values. It has input signals including the clock, reset, data vectors, and pixel values. The module computes the sine and cosine values based on the input data and then performs multiplication and addition operations to produce the final result. The output data is then adjusted based on its sign before being passed to the output.\n\n Module header:\n\nmodule matrix_prod(clk_i,reset_n_i,sclr_i,pix01_i,pix10_i,pix12_i,pix21_i,sin_i,cos_i,dv0_i,dv1_i,dv2_i,data_o);\n [/INST]\n", "output": "parameter DATA_WIDTH = 8; \n parameter COEF_WIDTH = 9; \n input clk_i; \n input reset_n_i; \n input dv0_i; \n input dv1_i; \n input dv2_i; \n input sclr_i; \n input [DATA_WIDTH-1:0] pix01_i, pix10_i, pix12_i, pix21_i; \n input [COEF_WIDTH-1:0] sin_i; \n input [COEF_WIDTH-1:0] cos_i; \n output [((COEF_WIDTH + DATA_WIDTH)+1):0] data_o; \n reg signed [DATA_WIDTH:0] tmpsin; \n reg signed [DATA_WIDTH:0] tmpcos; \n reg signed [(COEF_WIDTH + DATA_WIDTH):0] multsin; \n reg signed [(COEF_WIDTH + DATA_WIDTH):0] multcos; \n reg signed [((COEF_WIDTH + DATA_WIDTH)+1):0] finaladd; \n wire signed [COEF_WIDTH-1:0] sin_wire; \n wire signed [COEF_WIDTH-1:0] cos_wire; \n always@(posedge clk_i or negedge reset_n_i) \n  if (reset_n_i == 0) \n  tmpsin <= {(DATA_WIDTH+1){1'b0}}; \n  else if (dv0_i) \n  tmpsin <= pix21_i - pix01_i; \n  else \n  tmpsin <= tmpsin; \n always@(posedge clk_i or negedge reset_n_i) \n  if (reset_n_i == 0) \n  tmpcos <= {(DATA_WIDTH+1){1'b0}}; \n  else if (dv0_i) \n  tmpcos <= pix10_i - pix12_i; \n  else \n  tmpcos <= tmpcos; \n assign sin_wire = sin_i; \n assign cos_wire = cos_i; \n always@(posedge clk_i or negedge reset_n_i) \n  if (reset_n_i == 0) \n  begin \n  multsin <= {(COEF_WIDTH + DATA_WIDTH + 1){1'b0}}; \n  multcos <= {(COEF_WIDTH + DATA_WIDTH + 1){1'b0}}; \n  end \n  else if (dv1_i) \n  begin \n  multsin <= tmpsin * sin_wire; \n  multcos <= tmpcos * cos_wire; \n  end \n always@(posedge clk_i or negedge reset_n_i) \n  if (reset_n_i == 0) \n  begin \n  finaladd <= {((COEF_WIDTH + DATA_WIDTH)+2){1'b0}}; \n  end \n  else if (dv2_i) \n  begin \n  finaladd <= multsin + multcos; \n  end \n assign data_o = (finaladd > 0) ? finaladd : (~finaladd + 1'b1); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a single 32-bit register. The input datain is written to the register on the positive edge of the clk signal when WE is asserted. The register is reset to 0 when the clr signal is asserted. The output dataout reflects the current value stored in the register.\n\n Module header:\n\nmodule single_register(datain, dataout, clk, clr, WE);\n [/INST]\n", "output": "input [31:0] datain; \n  output [31:0] dataout; \n  input clk, clr, WE; \n  reg [31:0] register; \n always @(posedge clk or posedge clr) \n begin \n  if(clr) \n  register = 0; \n  else \n  if(WE == 1) \n  register = datain; \n end \n  assign dataout = register; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a LED driver that controls the behavior of an LED based on various input signals. It includes a counter to manage the LED behavior based on the count and data inputs. The module also has logic to handle the start, running, and resource counting states, and sets the output flags accordingly. The module uses the clock and reset signals to synchronize and control the LED behavior and manage the internal state transitions.\n\n Module header:\n\nmodule ledDriver (input clk, input reset, output reg led, input data, input lastBit, input start, output finish, output read);\n [/INST]\n", "output": "reg running = 0; \n  reg resCounting = 0; \n  reg read = 0; \n  reg[4:0] count = 0; \n  always @(posedge clk or posedge reset) begin \n  if (reset || ~running) begin \n  count<=0; \n  end else begin \n  if (count!=24) begin \n  count <= count + 1; \n  end else begin \n  count <=0; \n  end \n  end \n  end \n  reg firstbit = 0; \n  always @(posedge clk or posedge reset) begin \n  if (reset) begin \n  running <= 0; \n  firstbit <= 1; \n  read <= 0; \n  end else begin \n  if (~running & start) begin \n  running <= 1; \n  firstbit <= 1; \n  end else if (running) begin \n  firstbit<=0; \n  if (lastBit && count==24) begin \n  running <= 0; \n  resCounting <= 1; \n  read <= 0; \n  end else if (count==0 && ~firstbit) begin \n  read <= 1; \n  end else read <= 0; \n  end else if (resCounting && finish) begin \n  resCounting <= 0; \n  end \n  end \n  end \n  always @(posedge clk or posedge reset) begin \n  if (reset || ~running) begin \n  led <= 0; \n  end else begin \n  if (count==0) begin \n  led <= 1; \n  end else if ( (count==8 && ~data) || (count==16 && data)) begin \n  led<=0; \n  end \n  end \n  end \n  reg [10:0] resCounter=0; \n  always @(posedge clk or posedge reset) begin \n  if (reset || ~resCounting) begin \n  resCounter=0; \n  end else begin \n  resCounter <= resCounter+1; \n  end \n  end \n  assign finish = resCounter==11'h7FF; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a right rotation functionality. The input signal is duplicated to create a new signal that is twice the size of the original. Then, the output signal is assigned based on the rotation specified by the parameter S. The rotation is performed by taking a subset of the duplicated input signal, starting from position S modulo M and extending M bits.\n\n Module header:\n\nmodule rotate_right #(parameter M = 4,parameter S = 0) (input [M-1:0] in,output [M-1:0] out);\n [/INST]\n", "output": "wire [M*2-1:0] in2 = {in, in}; \n  assign out = in2[S%M+:M]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"tail_length\" takes a 4-bit input 'ir' and produces a 4-bit output 'len'. It checks the value of 'ir' and assigns 'len' based on specific conditions. The length value is stored in a 4-bit register. The module operates in an always block triggered by changes in the 'ir' input. If any of the defined conditions are met, the corresponding bit of 'len' is set to 1; otherwise, it is set to 0.\n\n Module header:\n\nmodule tail_length (ir, len);\n [/INST]\n", "output": "input [3:0] ir; \n output [3:0] len; \n reg [3:0] len; \n reg ir32; \n always @ (ir) \n begin \n  len = { \n  (ir == 4'b0011), \n  (ir == 4'b0010), \n  (ir == 4'b0001), \n  ((ir | 4'b0101) == 4'b1101) | ((ir | 4'b1100) == 4'b1100) \n  }; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a data storage unit with configurable parameters for data width, depth, and mode. It includes read and write pointers, status counters, full and empty flags, and read and write logic for accessing data from RAM. The module's behavior changes based on the mode input, and it supports read and write operations using different clock signals. The RAM is initialized with the specified depth, address width, and data width. The Full and Empty flags indicate the availability of space in the memory.\n\n Module header:\n\nmodule DUT #(parameter MODE=1'b1, parameter dat_width=32, parameter L=6, parameter DEPTH=64) ( input [dat_width-1:0] Datain,input Wren,input Rden,input Wrclk,input Rdclk,input Rst,output reg Full,output reg Empty,output reg [dat_width-1:0] Dataout);\n [/INST]\n", "output": "wire [dat_width-1:0] data_ram; \n  wire CLK; \n  reg [L-1:0] adr_rd_i; \n  reg [L-1:0] adr_wr_i; \n  reg [L-1:0] status_cnt; \n  assign CLK = (MODE == 1'b1 )? Rdclk : Wrclk; \n  always @ (posedge Wrclk or posedge Rst) begin : WRITE_POINTER \n  if (Rst) begin \n  adr_wr_i <= 0; \n  end \n  else if (Wrclk && Wren) begin \n  if (adr_wr_i == DEPTH ) begin \n  adr_wr_i <= adr_wr_i; \n  end \n  else begin \n  adr_wr_i <= adr_wr_i + 1; \n  end \n  end \n  if((MODE==0) && Rden) begin \n  if(adr_wr_i == 0) begin \n  adr_wr_i <= adr_wr_i; \n  end \n  else begin \n  adr_wr_i <= adr_wr_i -1; \n  end \n  end \n  end \n  always @ (posedge CLK or posedge Rst) begin : READ_POINTER \n  if (Rst) begin \n  adr_rd_i <= 0; \n  end \n  else if (Rden && (MODE == 1'b1) ) begin \n  if (adr_rd_i == DEPTH ) begin \n  adr_rd_i <= adr_rd_i; \n  end \n  else begin \n  adr_rd_i <= adr_rd_i + 1; \n  end \n  end \n  if(MODE == 1'b0) begin \n  adr_rd_i <= adr_wr_i-1; \n  end \n  end \n  always @ (posedge CLK or posedge Rst ) begin : READ_DATA \n  if (Rst ||!Rden ) begin \n  Dataout <= 0; \n  end else if (Rden) begin \n  Dataout <= data_ram; \n  end \n  end \n  always @ (posedge CLK or posedge Rst) begin : STATUS_COUNTER \n  if (Rst) begin \n  status_cnt <= 0; \n  end else if (Rden && !(Wren) && (status_cnt != 0) ) begin \n  status_cnt <= status_cnt - 1; \n  end else if (Wren && !(Rden) && (status_cnt != DEPTH)) begin \n  if (status_cnt == (DEPTH-1)) begin \n  status_cnt <=status_cnt; \n  end else begin \n  status_cnt <= status_cnt + 1; \n  end \n  end \n  end \n  always @ (posedge Wrclk or posedge Rst) begin: FULL_EMPTY \n  if (Rst) begin \n  Full <= 0 ; \n  Empty <= 1 ; \n  end else if (status_cnt == (DEPTH-1)) begin \n  Full <= 1 ; \n  Empty <= 0 ; \n  end else if (status_cnt == 0) begin \n  Full <= 0 ; \n  Empty <= 1 ; \n  end else begin \n  Full <= 0 ; \n  Empty <= 0 ; \n  end \n  end \n ram #(.mem_size(DEPTH),.adr_width(L),.dat_width(dat_width)) RAM(.dat_i(Datain),.dat_o(data_ram),.adr_wr_i(adr_wr_i),.adr_rd_i(adr_rd_i),.we_i(Wren),.rde_i(Rden),.clk(CLK)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a binary to 7-segment decoder. It takes a 14-bit input d_in, and based on the value of d_in, it updates the values of fullOutput, segA, segB, segC, segD, and d_out. The input d_in is first copied to d_inCopy, and when the copy is done, it triggers the process to update fullOutput, d_out, and the segments A, B, C, and D. The module then processes the input and sets the values of the outputs based on the input conditions. It uses case statements and conditional checks to handle the input and update the outputs accordingly. The fullOutput is continuously updated based on the input, and finally, the copyDone flag is reset.\n\n Module header:\n\nmodule bin2sevenSeg (input wire clk,input wire [13:0] d_in,output reg [15:0] fullOutput,output reg [3:0] segA,output reg [3:0] segB,output reg [3:0] segC,output reg [3:0] segD,output reg [13:0] d_out);\n [/INST]\n", "output": "reg [13:0] d_inCopy; \n reg [15:0] fullOutputCopy; \n reg copyDone; \n initial begin \n  fullOutput = 0; \n  segA = 0; \n  segB = 0; \n  segC = 0; \n  segD = 0; \n  d_inCopy = 0; \n end \n integer i; \n always @(d_in) \n  begin \n  for(i=0;i<14;i=i+1) \n  begin \n  d_inCopy[i] = d_in[i]; \n  end \n  d_out = d_inCopy; \n  copyDone = 1'b1; \n  end \n always @(posedge copyDone) \n  begin \n  for(i=0;i<14;i=i+1) \n  begin \n  case (fullOutputCopy[3:0]) \n  4'b0000: fullOutputCopy[3:0] <= 4'b0000; \n  4'b0001: fullOutputCopy[3:0] <= 4'b0001; \n  4'b0010: fullOutputCopy[3:0] <= 4'b0010; \n  4'b0011: fullOutputCopy[3:0] <= 4'b0011; \n  4'b0100: fullOutputCopy[3:0] <= 4'b0100; \n  4'b0101: fullOutputCopy[3:0] <= 4'b1000; \n  4'b0110: fullOutputCopy[3:0] <= 4'b1001; \n  4'b0111: fullOutputCopy[3:0] <= 4'b1010; \n  4'b1000: fullOutputCopy[3:0] <= 4'b1011; \n  4'b1001: fullOutputCopy[3:0] <= 4'b1100; \n  default: fullOutputCopy[3:0] <= 4'b0000; \n  endcase \n  case (fullOutputCopy[7:4]) \n  4'b0000: fullOutputCopy[7:4] <= 4'b0000; \n  4'b0001: fullOutputCopy[7:4] <= 4'b0001; \n  4'b0010: fullOutputCopy[7:4] <= 4'b0010; \n  4'b0011: fullOutputCopy[7:4] <= 4'b0011; \n  4'b0100: fullOutputCopy[7:4] <= 4'b0100; \n  4'b0101: fullOutputCopy[7:4] <= 4'b1000; \n  4'b0110: fullOutputCopy[7:4] <= 4'b1001; \n  4'b0111: fullOutputCopy[7:4] <= 4'b1010; \n  4'b1000: fullOutputCopy[7:4] <= 4'b1011; \n  4'b1001: fullOutputCopy[7:4] <= 4'b1100; \n  default: fullOutputCopy[7:4] <= 4'b0000; \n  endcase \n  if (fullOutputCopy[11:8] >= 4'd5) \n  begin \n  fullOutputCopy[11:8] = fullOutputCopy[11:8] + 2'b11; \n  end \n  else if (fullOutputCopy[13:9] >= 4'd5) \n  begin \n  fullOutputCopy[13:9] = fullOutputCopy[13:9] + 2'b11; \n  end \n  fullOutputCopy[0] = d_out[13]; \n  d_out = d_out << 1; \n  fullOutputCopy = fullOutputCopy << 1; \n  end \n  fullOutput = fullOutputCopy; \n  copyDone = 1'b0; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an LED driver with a reset logic and counter set. It takes clock and reset signals, a write enable signal, a 32-bit peripheral input, and provides LED outputs, a 2-bit counter set, and a 22-bit GPIOf0 output. It updates the LED and counter set based on the peripheral input when the write enable is asserted. The LED output is driven by a separate 8-bit register and is assigned to the led_out. The reset logic initializes the LED and counter set values.\n\n Module header:\n\nmodule led_Dev_IO(input wire clk ,input wire rst,input wire GPIOf0000000_we,input wire [31:0] Peripheral_in,output reg [1:0] counter_set,output wire [7:0] led_out,output reg [21:0] GPIOf0);\n [/INST]\n", "output": "reg [7:0]LED; \n  assign led_out = LED; \n  always @(negedge clk or posedge rst) begin \n  if (rst) begin \n  LED <= 8'hAA; \n  counter_set <= 2'b00; \n  end else begin \n  if (GPIOf0000000_we) {GPIOf0[21:0], LED, counter_set} <= Peripheral_in; \n  else begin \n  LED <= LED; \n  counter_set <= counter_set; \n  end \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module defines an output of 4 bits, where the value is assigned based on the parameter VALUE. The parameter can be specified when instantiating the module, and the assigned value will be output on k.\n\n Module header:\n\nmodule v9b9118_v465065 #(parameter VALUE = 0) (output [3:0] k);\n [/INST]\n", "output": "assign k = VALUE; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is designed to generate PWM signals for controlling the intensity of 8 LEDs. It uses an input clock and reset signal, and an output for the 8-bit PWM values to drive the LEDs. The PWM signals are generated using a for loop, with each iteration controlling the PWM signal for one LED. The module also includes SPI and AVR interfaces, which are assigned to high-impedance outputs, indicating that they are not used in this module.\n\n Module header:\n\nmodule mojo_top(input clk,input rst_n,input cclk,output[7:0]led,output spi_miso,input spi_ss,input spi_mosi,input spi_sck,output [3:0] spi_channel,input avr_tx,output avr_rx,input avr_rx_busy);\n [/INST]\n", "output": "wire rst = ~rst_n; \n assign spi_miso = 1'bz; \n assign avr_rx = 1'bz; \n assign spi_channel = 4'bzzzz; \n genvar i; \n generate \n  for (i = 0; i < 8; i=i+1) begin: pwm_gen_loop \n pwm #(.CTR_SIZE(3)) pwm (.rst(rst),.clk(clk),.compare(i),.pwm(led[i])); \n  end \n endgenerate \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module ohr_reg0 implements a register with configurable data width. When configured for ASIC, it instantiates an ASIC register with the given input and output connections. Otherwise, it declares an output register and updates it based on the input and reset signals. The output is then connected to the output register.\n\n Module header:\n\nmodule ohr_reg0 #(parameter DW = 1) ( input nreset,input clk,input [DW-1:0] in,output [DW-1:0] out);\n [/INST]\n", "output": "`ifdef CFG_ASIC \n asic_reg0 ireg [DW-1:0] (.nreset(nreset),.clk(clk),.in(in[DW-1:0]),.out(out[DW-1:0])); \n `else \n  reg [DW-1:0] out_reg; \n  always @ (negedge clk or negedge nreset) \n  if(~nreset) \n  out_reg[DW-1:0] <= 'b0; \n  else \n  out_reg[DW-1:0] <= in[DW-1:0]; \n  assign out[DW-1:0] = out_reg[DW-1:0]; \n `endif \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a sync generator for PAL and NTSC video formats. It uses the input clock and mode to generate horizontal and vertical sync signals, along with blanking signals. The module tracks the horizontal and vertical counts based on the input mode and triggers the sync signals accordingly. Additionally, it generates blanking signals based on the sync signals and mode, and produces a chip select signal.\n\n Module header:\n\nmodule sync_generator_pal_ntsc (input wire clk,input wire in_mode,output reg csync_n,output wire [8:0] hc,output wire [8:0] vc,output reg blank);\n [/INST]\n", "output": "parameter PAL = 1'b0; \n  parameter NTSC = 1'b1; \n  reg [8:0] h = 9'd0; \n  reg [8:0] v = 9'd0; \n  reg mode = PAL; \n  assign hc = h; \n  assign vc = v; \n  always @(posedge clk) begin \n  if (mode == PAL) begin \n  if (h == 9'd447) begin \n  h <= 9'd0; \n  if (v == 9'd311) begin \n  v <= 9'd0; \n  mode <= in_mode; \n  end \n  else \n  v <= v + 9'd1; \n  end \n  else \n  h <= h + 9'd1; \n  end \n  else begin \n  if (h == 9'd443) begin \n  h <= 9'd0; \n  if (v == 9'd261) begin \n  v <= 9'd0; \n  mode <= in_mode; \n  end \n  else \n  v <= v + 9'd1; \n  end \n  else \n  h <= h + 9'd1; \n  end \n  end \n  reg vblank, hblank, vsync_n, hsync_n; \n  always @* begin \n  vblank = 1'b0; \n  hblank = 1'b0; \n  vsync_n = 1'b1; \n  hsync_n = 1'b1; \n  if (mode == PAL) begin \n  if (v >= 9'd304 && v <= 9'd311) begin \n  vblank = 1'b1; \n  if (v >= 9'd304 && v <= 9'd307) begin \n  vsync_n = 1'b0; \n  end \n  end \n  if (h >= 9'd352 && h <= 9'd447) begin \n  hblank = 1'b1; \n  if (h >= 9'd376 && h <= 9'd407) begin \n  hsync_n = 1'b0; \n  end \n  end \n  end \n  else begin \n  if (v >= 9'd254 && v <= 9'd261) begin \n  vblank = 1'b1; \n  if (v >= 9'd254 && v <= 9'd257) begin \n  vsync_n = 1'b0; \n  end \n  end \n  if (h >= 9'd352 && h <= 9'd443) begin \n  hblank = 1'b1; \n  if (h >= 9'd376 && h <= 9'd407) begin \n  hsync_n = 1'b0; \n  end \n  end \n  end \n  blank = hblank | vblank; \n  csync_n = hsync_n & vsync_n; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a FAPCH (Frequency Accelerated Phase Correlator Hardware) counter. It uses registers and wires to synchronize, detect edges, and count clock cycles based on the input fclk and rdat_n. The module also generates output signals vg_rclk and vg_rawr based on the internal logic and the input signals.\n\n Module header:\n\nmodule fapch_counter (input wire fclk,input wire rdat_n,output reg vg_rclk,output reg vg_rawr);\n [/INST]\n", "output": "reg [4:0] rdat_sync; \n  reg rdat_edge1, rdat_edge2; \n  wire rdat; \n  wire rwidth_ena; \n  reg [3:0] rwidth_cnt; \n  wire rclk_strobe; \n  reg [5:0] rclk_cnt; \n  always @(posedge fclk) \n  rdat_sync[4:0] <= { rdat_sync[3:0], (~rdat_n) }; \n  always @(posedge fclk) \n  begin \n  if( rdat_sync[4:1]==4'b1111 ) \n  rdat_edge1 <= 1'b1; \n  else if( rclk_strobe ) \n  rdat_edge1 <= 1'b0; \n  rdat_edge2 <= rdat_edge1; \n  end \n  assign rdat = rdat_edge1 & (~rdat_edge2); \n  always @(posedge fclk) \n  if( rwidth_ena ) \n  begin \n  if( rdat ) \n  rwidth_cnt <= 4'd0; \n  else \n  rwidth_cnt <= rwidth_cnt + 4'd1; \n  end \n  assign rwidth_ena = rdat | (~rwidth_cnt[2]); \n  always @(posedge fclk) \n  vg_rawr <= rwidth_cnt[2]; \n  assign rclk_strobe = (rclk_cnt==6'd0); \n  always @(posedge fclk) \n  begin \n  if( rdat ) \n  rclk_cnt <= 6'd29; \n  else if( rclk_strobe ) \n  rclk_cnt <= 6'd55; \n  else \n  rclk_cnt <= rclk_cnt - 6'd1; \n  end \n  always @(posedge fclk) \n  if( rclk_strobe ) \n  vg_rclk <= ~vg_rclk; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a multiplier that multiplies input signals a and b, and stores the result in output signal p when the control signal ce is asserted on a positive clock edge. The multiplication operation takes 10ns for signal a and 12ns for signal b, and the output is a signed 22-bit signal.\n\n Module header:\n\nmodule image_filter_mul_10ns_12ns_22_2_AM2S_0(clk, ce, a, b, p);\n [/INST]\n", "output": "input clk; \n input ce; \n input [10 - 1 : 0] a; \n input [12 - 1 : 0] b; \n output[22 - 1 : 0] p; \n reg signed [22 - 1 : 0] p; \n wire [22 - 1 : 0] tmp_product; \n assign tmp_product = a * b; \n always @ (posedge clk) begin \n  if (ce) begin \n  p <= tmp_product; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a state machine that controls the generation of various control signals based on input conditions. It has a 2-bit current state and next state, and a 4-bit dardy counter output. The module uses the memory clock and reset signals to update the current state. Depending on the current state and input signals, it sets the next state and generates various control signals such as data_complete, crt_ff_write, m_t_svga_req, and m_mrd_mwr_n. The module also includes the logic to increment the dardy counter and manage the dardy counter outputs based on input conditions and state transitions.\n\n Module header:\n\n module sm_data_comp (input sync_c_crt_line_end,input cpu_arb_wr,input t_data_ready_n,input h_reset_n,input t_mem_clk,input gra_crt_svga_req,input txt_crt_svga_req,input cpu_rd_svga_req,input cpu_wr_svga_req,input text_mode,input cursor_addr_ok,input cursor_addr_ok1,input [3:0] gra_cnt_qout,output reg data_complete,output reg crt_ff_write,output m_t_svga_req,output m_mrd_mwr_n);\n [/INST]\n", "output": "reg [1:0] current_state; \n  reg [1:0] next_state; \n  reg [3:0] dardy_cnt_qout; \n  reg dardy_s1; \n  wire mux3_out; \n  wire dardy_cnt_0; \n  wire dardy_cnt_inc; \n  wire int_svga_req; \n  wire [3:0] tx_gr_muxout; \n  wire cursor_reset; \n  wire cur_addr_rst_n; \n  wire int_crt_ff_write; \n  assign int_svga_req = gra_crt_svga_req | txt_crt_svga_req; \n assign m_t_svga_req = (int_svga_req |cpu_rd_svga_req | cpu_wr_svga_req); \n  assign m_mrd_mwr_n = ~cpu_arb_wr; \n  assign mux3_out = text_mode ? 1'b0 : dardy_cnt_qout[3]; \n assign dardy_cnt_0 = ((~mux3_out) & (~dardy_cnt_qout[2]) &(~dardy_cnt_qout[1]) & (~dardy_cnt_qout[0])); \n  parameter dardy_crt_state0 = 2'b00, \n  dardy_crt_state1 = 2'b01, \n  dardy_crt_state2 = 2'b10, \n  dardy_crt_state3 = 2'b11; \n  always @ (posedge t_mem_clk or negedge h_reset_n) begin \n  if (~h_reset_n) current_state <= dardy_crt_state0; \n  else current_state <= next_state; \n  end \n  always @* begin \n  dardy_s1 = 1'b0; \n  data_complete = 1'b0; \n  crt_ff_write = 1'b0; \n  case (current_state) \n  dardy_crt_state0: begin \n  if (int_svga_req) next_state = dardy_crt_state1; \n  else next_state = dardy_crt_state0; \n  end \n  dardy_crt_state1: begin \n  dardy_s1 = 1'b1; \n  casex ({t_data_ready_n, sync_c_crt_line_end}) \n  2'b00: next_state = dardy_crt_state2; \n  2'b10: next_state = dardy_crt_state1; \n  2'bx1: next_state = dardy_crt_state3; \n  endcase \n  end \n  dardy_crt_state2: begin \n  crt_ff_write = 1'b1; \n  casex ({dardy_cnt_0, sync_c_crt_line_end}) \n  2'b00: next_state = dardy_crt_state1; \n  2'b10: next_state = dardy_crt_state3; \n  2'bx1: next_state = dardy_crt_state3; \n  endcase \n  end \n  dardy_crt_state3: begin \n  data_complete = 1'b1; \n  next_state = dardy_crt_state0; \n  end \n  endcase \n  end \n  assign dardy_cnt_inc = ~t_data_ready_n & (dardy_s1 | crt_ff_write); \n  always @ (posedge t_mem_clk or negedge h_reset_n) begin \n  if (~h_reset_n) dardy_cnt_qout <= 4'b0; \n  else if (sync_c_crt_line_end) dardy_cnt_qout <= 4'b0; \n  else if (data_complete & text_mode) dardy_cnt_qout <= 4'b0; \n  else if (dardy_cnt_inc) dardy_cnt_qout <= dardy_cnt_qout + 1; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a peripheral multiplier that interfaces with an external module to perform multiplication. It takes inputs like clock signal, reset signal, data input, chip select, address input, read and write signals. The module has a 16-bit data output and includes internal registers for storage. It has an address decoder that enables writing and reading data based on the chip select and read/write signals. It also instantiates another module called mult_32 to perform the actual multiplication operation. The results of the multiplication operation are stored in the output data register.\n\n Module header:\n\nmodule peripheral_mult(clk , rst , d_in , cs , addr , rd , wr, d_out );\n [/INST]\n", "output": "input clk; \n  input rst; \n  input [15:0]d_in; \n  input cs; \n  input [3:0]addr; \n  input rd; \n  input wr; \n  output reg [15:0]d_out; \n reg [5:0] s; \n reg [15:0] A=0; \n reg [15:0] B=0; \n reg init=0; \n wire [31:0] pp; \n wire done; \n always @(*) begin \n case (addr) \n 4'h0:begin s = (cs && wr) ? 6'b000001 : 6'b000000 ;end \n 4'h2:begin s = (cs && wr) ? 6'b000010 : 6'b000000 ;end \n 4'h4:begin s = (cs && wr) ? 6'b000100 : 6'b000000 ;end \n 4'h6:begin s = (cs && rd) ? 6'b001000 : 6'b000000 ;end \n 4'h8:begin s = (cs && rd) ? 6'b010000 : 6'b000000 ;end \n 4'hA:begin s = (cs && rd) ? 6'b100000 : 6'b000000 ;end \n default:begin s = 6'b000000 ; end \n endcase \n end \n always @(negedge clk) begin \n A = (s[0]) ? d_in : A; \n B = (s[1]) ? d_in : B; \n init = s[2] ; \n end \n always @(negedge clk) begin \n case (s[5:3]) \n 3'b001: d_out[0] = done ; \n 3'b010: d_out = pp[31:16] ; \n 3'b100: d_out = pp[15:0] ; \n default: d_out = 0 ; \n endcase \n end \n mult_32 mt_32 ( .clk(clk), .rst(rst), .A(A), .B(B), .init(init), .pp(pp), .done(done) ); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, `delay5`, implements a delay element that captures an input delay signal `d5_delay_in` and produces an output delay signal `d5_delay_out` after a clock edge. The delay is implemented using a register `d5_reg1` which is updated on each positive edge of the clock signal.\n\n Module header:\n\nmodule delay5 (clock, d5_delay_in, d5_delay_out);\n [/INST]\n", "output": "input clock; \n  input [`BITS-1:0] d5_delay_in; \n  output [`BITS-1:0] d5_delay_out; \n  reg [`BITS-1:0] d5_reg1; \n  assign d5_delay_out = d5_reg1; \n  always @(posedge clock) \n  begin \n  d5_reg1 <= d5_delay_in; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, named TestConsole, simulates a simple console interface. It has inputs for the clock, reset, and an 8-bit data input, and outputs for the 8-bit data output, a read data available signal, an acknowledge signal, a write signal, and a ready signal. \n\nThe SELREG register is incremented when the ACK signal is asserted. The output is set to 0x41 added with SELREG. RDA and RDY are always asserted. When the write signal is asserted, the module writes the input value to the console. If the acknowledge signal is asserted, the SELREG register is incremented.\n\n Module header:\n\nmodule TestConsole (input CLK,input RESET,input [7:0] IN,output [7:0] OUT,output RDA,input ACK,input WR,output RDY);\n [/INST]\n", "output": "reg [3:0] SELREG; \n  assign OUT = 8'h41 + SELREG; \n  assign RDA = 1'b1; \n  assign RDY = 1'b1; \n  always @ (posedge CLK) \n  begin \n  if(RESET) \n  SELREG <= 8'h00; \n  else \n  begin \n  if(WR) \n  $write(\"%c\", IN); \n  if(ACK) \n  SELREG <= SELREG + 1; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an instance of a register with additional control and status signals. It includes error checking for valid bit values and for multiple valid bits being active in the same cycle. The module instantiates an inner module `incif_wrapuint32_153615_inc1` which seems to be handling the inner processing of data. The inner module also checks for multiple valid bits being active and assigns the output based on arbitration. The `SETBY_OUTPUT` is assigned to the output of the inner process, and `GET_OUTPUT` is assigned to the output of the register.\n\n Module header:\n\nmodule RegBy_incif_wrapuint32_153615_inc1_CEtrue_initnil(input CLK, input set_valid, input CE, input [31:0] set_inp, input setby_valid, input setby_inp, output [31:0] SETBY_OUTPUT, output [31:0] GET_OUTPUT);\n [/INST]\n", "output": "parameter INSTANCE_NAME=\"INST\"; \n  reg [31:0] R; \n  wire [31:0] regby_inner_process_output; \n  always @(posedge CLK) begin if(set_valid===1'bx) begin $display(\"valid bit can't be x! Module '%s' instance 'R' function 'set'\", INSTANCE_NAME); end end \n  always @(posedge CLK) begin if(setby_valid===1'bx) begin $display(\"valid bit can't be x! Module '%s' instance 'R' function 'set'\", INSTANCE_NAME); end end \n  always @(posedge CLK) begin if((({4'b0,set_valid})+({4'b0,setby_valid})) > 5'd1) begin $display(\"error, function 'set' on instance 'R' in module '%s' has multiple valid bits active in same cycle!\",INSTANCE_NAME);$finish(); end end \n  wire [32:0] unnamedcallArbitrate8576USEDMULTIPLEcallArbitrate;assign unnamedcallArbitrate8576USEDMULTIPLEcallArbitrate = {(set_valid||setby_valid),((set_valid)?(set_inp):(regby_inner_process_output))}; \n  always @ (posedge CLK) begin if ((unnamedcallArbitrate8576USEDMULTIPLEcallArbitrate[32]) && CE) begin R <= (unnamedcallArbitrate8576USEDMULTIPLEcallArbitrate[31:0]); end end \n  assign SETBY_OUTPUT = regby_inner_process_output; \n  assign GET_OUTPUT = R; \n  incif_wrapuint32_153615_inc1 #(.INSTANCE_NAME({INSTANCE_NAME,\"_regby_inner\"})) regby_inner(.CLK(CLK), .CE(CE), .process_input({setby_inp,R}), .process_output(regby_inner_process_output)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module performs a DSP48 operation by multiplying two input values and then adding a third input value. The module takes three input signals in0, in1, and in2, and outputs the result in dout. The inputs in0, in1, and in2 are converted to signed or unsigned values and then used to perform the multiplication and addition operations, with the final result being assigned to the output dout.\n\n Module header:\n\nmodule hls_saturation_endEe_DSP48_0(input [20 - 1:0] in0,input [16 - 1:0] in1,input [27 - 1:0] in2,output [36 - 1:0] dout);\n [/INST]\n", "output": "wire signed [25 - 1:0] a; \n wire signed [18 - 1:0] b; \n wire signed [48 - 1:0] c; \n wire signed [43 - 1:0] m; \n wire signed [48 - 1:0] p; \n assign a = $unsigned(in0); \n assign b = $signed(in1); \n assign c = $unsigned(in2); \n assign m = a * b; \n assign p = m + c; \n assign dout = p; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a set of registers that can be read from and written to. It uses a parameter to define the width of the registers and another parameter for the data width. There is also a parameter for the number of stack registers and the starting address for the stack. It initializes the registers to 0 using an iverilog conditional statement. The rs1_data_out and rs2_data_out are assigned to the values in the registers at the specified offsets. The module also includes an always block that updates the registers on the positive edge of the clock signal. If the reset signal is high, it sets a specific register to the stack start address. If the write enable signal is high and the destination register is not 0, it updates the specified register with the input data.\n\n Module header:\n\nmodule registers(input rst,input clk,input write_enable,input [REG_WIDTH-1 : 0] rs1_offset,input [REG_WIDTH-1 : 0] rs2_offset,input [REG_WIDTH-1 : 0] rd_offset,input [WIDTH-1 : 0] rd_data_in,output [WIDTH-1 : 0] rs1_data_out,output [WIDTH-1 : 0] rs2_data_out);\n [/INST]\n", "output": "parameter REG_WIDTH = 5; \n  parameter WIDTH = 32; \n  parameter STACK_REG = 2; \n  parameter STACK_START = 1024; \n  localparam REG_COUNT = 1 << REG_WIDTH; \n  reg [WIDTH-1 : 0] regs [0 : REG_COUNT-1]; \n `ifdef IVERILOG \n  integer i; \n  initial begin \n  for (i = 0; i < REG_COUNT; i = i + 1) begin \n  regs[i] = 0; \n  end \n  end \n `endif \n  assign rs1_data_out = regs[rs1_offset]; \n  assign rs2_data_out = regs[rs2_offset]; \n  always @(posedge clk) begin \n  if (rst) begin \n  regs[2] <= STACK_START; \n  end else begin \n  if (write_enable && (rd_offset != 0)) begin \n  regs[rd_offset] <= rd_data_in; \n  end \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module instantiates a clocking wizard that generates multiple clock outputs based on the input clock signal. The clocking wizard uses a phase-locked loop (PLL) to generate multiple clock signals with specific frequencies and phases. The outputs include various clock signals as well as a signal indicating whether the PLL has locked onto the input clock signal. The module also contains several internal signals and buffers that are not directly used in the output of the module.\n\n Module header:\n\nmodule dacclk_mmcm (input CLK_IN1,output CLK_OUT1,output CLK_OUT2,output CLK_OUT3,output CLK_OUT4,output CLK_OUT5,output LOCKED);\n [/INST]\n", "output": "IBUFG clkin1_buf \n (.O (clkin1),.I (CLK_IN1)); \n  wire [15:0] do_unused; \n  wire drdy_unused; \n  wire psdone_unused; \n  wire clkfbout; \n  wire clkfboutb_unused; \n  wire clkout0b_unused; \n  wire clkout1b_unused; \n  wire clkout2b_unused; \n  wire clkout3b_unused; \n  wire clkout5_unused; \n  wire clkout6_unused; \n  wire clkfbstopped_unused; \n  wire clkinstopped_unused; \n  MMCM_ADV \n #(.BANDWIDTH (\"OPTIMIZED\"),.CLKOUT4_CASCADE (\"FALSE\"),.CLOCK_HOLD (\"FALSE\"),.COMPENSATION (\"ZHOLD\"),.STARTUP_WAIT (\"FALSE\"),.DIVCLK_DIVIDE (1),.CLKFBOUT_MULT_F (8.000),.CLKFBOUT_PHASE (0.000),.CLKFBOUT_USE_FINE_PS (\"FALSE\"),.CLKOUT0_DIVIDE_F (8.000),.CLKOUT0_PHASE (0.000),.CLKOUT0_DUTY_CYCLE (0.500),.CLKOUT0_USE_FINE_PS (\"FALSE\"),.CLKOUT1_DIVIDE (8),.CLKOUT1_PHASE (90.000),.CLKOUT1_DUTY_CYCLE (0.500),.CLKOUT1_USE_FINE_PS (\"FALSE\"),.CLKOUT2_DIVIDE (8),.CLKOUT2_PHASE (180.000),.CLKOUT2_DUTY_CYCLE (0.500),.CLKOUT2_USE_FINE_PS (\"FALSE\"),.CLKOUT3_DIVIDE (8),.CLKOUT3_PHASE (270.000),.CLKOUT3_DUTY_CYCLE (0.500),.CLKOUT3_USE_FINE_PS (\"FALSE\"),.CLKOUT4_DIVIDE (4),.CLKOUT4_PHASE (0.000),.CLKOUT4_DUTY_CYCLE (0.500),.CLKOUT4_USE_FINE_PS (\"FALSE\"),.CLKIN1_PERIOD (7.812),.REF_JITTER1 (0.010)) \n  mmcm_adv_inst \n (.CLKFBOUT (clkfbout),.CLKFBOUTB (clkfboutb_unused),.CLKOUT0 (clkout0),.CLKOUT0B (clkout0b_unused),.CLKOUT1 (clkout1),.CLKOUT1B (clkout1b_unused),.CLKOUT2 (clkout2),.CLKOUT2B (clkout2b_unused),.CLKOUT3 (clkout3),.CLKOUT3B (clkout3b_unused),.CLKOUT4 (clkout4),.CLKOUT5 (clkout5_unused),.CLKOUT6 (clkout6_unused),.CLKFBIN (clkfbout),.CLKIN1 (clkin1),.CLKIN2 (1'b0),.CLKINSEL (1'b1),.DADDR (7'h0),.DCLK (1'b0),.DEN (1'b0),.DI (16'h0),.DO (do_unused),.DRDY (drdy_unused),.DWE (1'b0),.PSCLK (1'b0),.PSEN (1'b0),.PSINCDEC (1'b0),.PSDONE (psdone_unused),.LOCKED (LOCKED),.CLKINSTOPPED (clkinstopped_unused),.CLKFBSTOPPED (clkfbstopped_unused),.PWRDWN (1'b0),.RST (1'b0)); \n  assign CLK_OUT1 = clkout0; \n  assign CLK_OUT2 = clkout1; \n  assign CLK_OUT3 = clkout2; \n  assign CLK_OUT4 = clkout3; \n  assign CLK_OUT5 = clkout4; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes an 18-bit input, Din, and outputs the 5 least significant bits, Dout, by selecting bits 7 to 3 of the input and assigning them to the output.\n\n Module header:\n\nmodule RAT_slice_12_8_0 (Din,Dout);\n [/INST]\n", "output": "input [17:0]Din; \n  output [4:0]Dout; \n  wire [17:0]Din; \n  assign Dout[4:0] = Din[7:3]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an AXI slave interface with configurable parameters. It includes a timestamp counter that increments on every clock cycle. Requests are stored in a FIFO queue, and the module controls the beat signals for data transfers. The beat_stb signal is asserted when there are pending requests and the timestamp exceeds the scheduled beat time. The beat_ack signal is an output indicating acknowledgment of data transfer. The module also handles the generation of beat_addr and beat_last signals, and updates the beat_counter and req_fifo_rd based on beat_ack and beat_last signals. The ready signal indicates the availability of the module to accept new requests. If valid and ready are both high, the module stores the request information in the FIFO queue. When reset, the module resets the timestamp and the FIFO queue pointers.\n\n Module header:\n\nmodule axi_slave #(parameter ACCEPTANCE = 3,parameter MIN_LATENCY = 16,parameter MAX_LATENCY = 32) (input clk,input reset,input valid,output ready,input [31:0] addr,input [7:0] len,input [2:0] size,input [1:0] burst,input [2:0] prot,input [3:0] cache,output beat_stb,input beat_ack,output [31:0] beat_addr,output beat_last);\n [/INST]\n", "output": "reg [31:0] timestamp = 'h00; \n always @(posedge clk) begin \n  if (reset == 1'b1) begin \n  timestamp <= 'h00; \n  end else begin \n  timestamp <= timestamp + 1'b1; \n  end \n end \n reg [32+32+8-1:0] req_fifo[0:15]; \n reg [3:0] req_fifo_rd = 'h00; \n reg [3:0] req_fifo_wr = 'h00; \n wire [3:0] req_fifo_level = req_fifo_wr - req_fifo_rd; \n assign ready = req_fifo_level < ACCEPTANCE; \n always @(posedge clk) begin \n  if (reset == 1'b1) begin \n  req_fifo_wr <= 'h00; \n  end else begin \n  if (valid == 1'b1 && ready == 1'b1) begin \n  req_fifo[req_fifo_wr][71:40] <= timestamp + {$random} % (MAX_LATENCY - MIN_LATENCY + 1) + MIN_LATENCY; \n  req_fifo[req_fifo_wr][39:0] <= {addr,len}; \n  req_fifo_wr <= req_fifo_wr + 1'b1; \n  end \n  end \n end \n reg [7:0] beat_counter = 'h00; \n assign beat_stb = req_fifo_level != 0 && timestamp > req_fifo[req_fifo_rd][71:40]; \n assign beat_last = beat_stb ? beat_counter == req_fifo[req_fifo_rd][0+:8] : 1'b0; \n assign beat_addr = req_fifo[req_fifo_rd][8+:32] + beat_counter * 4; \n always @(posedge clk) begin \n  if (reset == 1'b1) begin \n  beat_counter <= 'h00; \n  req_fifo_rd <= 'h00; \n  end else begin \n  if (beat_ack == 1'b1) begin \n  if (beat_last == 1'b1) begin \n  beat_counter <= 'h00; \n  req_fifo_rd <= req_fifo_rd + 1'b1; \n  end else begin \n  beat_counter <= beat_counter + 1'b1; \n  end \n  end \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a 1-to-4 demultiplexer. It takes a single input x and two select signals s0 and s1, and generates four outputs y0, y1, y2, and y3. The select signals determine which output will be equal to the input x, while the other outputs will be set to 0. The demultiplexer uses if-else statements to handle different combinations of the select signals and assigns the input x to the corresponding output based on the select signals.\n\n Module header:\n\nmodule DEMUX1_4_B (x,s0,s1,y0,y1,y2,y3);\n [/INST]\n", "output": "input x; \n input s0; \n input s1; \n output y0; \n reg y0; \n output y1; \n reg y1; \n output y2; \n reg y2; \n output y3; \n reg y3; \n always @(x, s1, s0) begin: DEMUX1_4_B_LOGIC \n  if (((s0 == 0) && (s1 == 0))) begin \n  y0 = x; \n  y1 = 0; \n  y2 = 0; \n  y3 = 0; \n  end \n  else if (((s0 == 1) && (s1 == 0))) begin \n  y0 = 0; \n  y1 = x; \n  y2 = 0; \n  y3 = 0; \n  end \n  else if (((s0 == 0) && (s1 == 1))) begin \n  y0 = 0; \n  y1 = 0; \n  y2 = x; \n  y3 = 0; \n  end \n  else begin \n  y0 = 0; \n  y1 = 0; \n  y2 = 0; \n  y3 = x; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module, load_data_translator, processes input data based on d_address and load_size to generate the output d_loadresult. The logic conditions in the always block determine how to extract and extend specific portions of the input data, d_readdatain, based on the values of d_address and load_size. The extended and manipulated data is then assigned to the output d_loadresult based on the specified cases and conditions.\n\n Module header:\n\nmodule load_data_translator(d_readdatain,d_address,load_size,load_sign_ext,d_loadresult);\n [/INST]\n", "output": "parameter WIDTH=32; \n input [WIDTH-1:0] d_readdatain; \n input [1:0] d_address; \n input [1:0] load_size; \n input load_sign_ext; \n output [WIDTH-1:0] d_loadresult; \n reg [WIDTH-1:0] d_loadresult; \n always @(d_readdatain or d_address or load_size or load_sign_ext) \n begin \n  case (load_size) \n  2'b11: \n  begin \n  case (d_address[1:0]) \n  0: d_loadresult[7:0]=d_readdatain[31:24]; \n  1: d_loadresult[7:0]=d_readdatain[23:16]; \n  2: d_loadresult[7:0]=d_readdatain[15:8]; \n  default: d_loadresult[7:0]=d_readdatain[7:0]; \n  endcase \n  d_loadresult[31:8]={24{load_sign_ext&d_loadresult[7]}}; \n  end \n  2'b01: \n  begin \n  case (d_address[1]) \n  0: d_loadresult[15:0]=d_readdatain[31:16]; \n  default: d_loadresult[15:0]=d_readdatain[15:0]; \n  endcase \n  d_loadresult[31:16]={16{load_sign_ext&d_loadresult[15]}}; \n  end \n  default: \n  d_loadresult=d_readdatain; \n  endcase \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is designed to reorder and manipulate input data based on the operation and addnsub inputs. The dataout output is updated based on the datain and addnsub inputs. The module uses a case statement to conditionally assign values to the dataout_tmp register based on the operation input, and then assigns the dataout output to the dataout_tmp. The operation_mode parameter determines whether the dataout_tmp is updated based on the operation input or if it's simply assigned the value of datain.\n\n Module header:\n\nmodule stratixii_reorder_output(datain,addnsub,operation,dataout);\n [/INST]\n", "output": "parameter operation_mode = \"dynamic\"; \n input [143:0] datain; \n input [3:0] operation; \n input addnsub; \n output [143:0] dataout; \n reg [143:0] dataout_tmp; \n wire [3:0] operation; \n assign dataout = dataout_tmp; \n always @ (datain or addnsub) \n  begin \n  if(operation_mode == \"dynamic\") \n  begin \n  case (operation) \n  4'b1100 : \n  dataout_tmp = {18'bX, datain[124:108],1'bX, datain[107:72],18'bX, datain[52:36], 1'bX, datain[35:0]}; \n  4'b1101 : \n  dataout_tmp = {datain[143:72], 18'bX, datain[52:36], 1'bX, datain[35:0]}; \n  4'b1110 : \n  dataout_tmp = {18'bX, datain[124:108], 1'bX, datain[107:0]}; \n  4'b0111 : \n  begin \n  dataout_tmp[17:0] = (addnsub) ? datain[17:0] : 18'bX; \n  dataout_tmp[35:18] = (addnsub) ? datain[53:36] : 18'bX; \n  dataout_tmp[53:36] = (addnsub) ? datain[35:18] : 18'bX; \n  dataout_tmp[71:54] = (addnsub) ? datain[71:54] : 18'bX; \n  dataout_tmp[143:72] = 72'bX; \n  end \n  default : \n  dataout_tmp = datain; \n  endcase \n  end \n  else \n  dataout_tmp = datain; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a Serializer/Deserializer (SerDes) implementation for a DDR (Double Data Rate) communication system. It takes in differential data signals, clock signals, and a reset signal, and outputs a serialized stream of data. The module includes a state machine to handle the deserialization process, with the ability to detect and correct bit slips in the received data. The module is designed to work with 8-bit data and includes the necessary logic for synchronization and clock domain crossing. The state machine controls the bit slip flag and ensures correct deserialization of the received data.\n\n Module header:\n\nmodule top_nto1_ddr_diff_rx (input reset,input [7:0] datain_p, datain_n,input clkin_p, clkin_n,output [63:0] dummy_out);\n [/INST]\n", "output": "parameter integer S = 8 ; \n parameter integer D = 8 ; \n parameter integer DS = (D*S)-1 ; \n wire rst ; \n wire [DS:0] rxd ; \n reg [DS:0] rxr ; \n reg state ; \n reg bslip ; \n reg [3:0] count ; \n assign rst = reset ; \n assign dummy_out = rxr ; \n serdes_1_to_n_clk_ddr_s8_diff #(.S (S),.DIFF_TERM (\"TRUE\")) \n inst_clkin (.clkin_p (clkin_p),.clkin_n (clkin_n),.rxioclkp (rxioclkp),.rxioclkn (rxioclkn),.rx_serdesstrobe (rx_serdesstrobe),.rx_bufg_x1 (rx_bufg_x1)); \n serdes_1_to_n_data_ddr_s8_diff #(.S (S),.D (D),.DIFF_TERM (\"TRUE\")) \n inst_datain (.use_phase_detector (1'b1),.datain_p (datain_p),.datain_n (datain_n),.rxioclkp (rxioclkp),.rxioclkn (rxioclkn),.rxserdesstrobe (rx_serdesstrobe),.gclk (rx_bufg_x1),.bitslip (bslip),.reset (rst),.data_out (rxd),.debug_in (2'b00),.debug ()); \n always @ (posedge rx_bufg_x1 or posedge rst) \n begin \n if (rst == 1'b1) begin \n  state <= 0 ; \n  bslip <= 1'b0 ; \n  count <= 4'b0000 ; \n end \n else begin \n  if (state == 0) begin \n  if (rxd[63:60] != 4'h3) begin \n  bslip <= 1'b1 ; \n  state <= 1 ; \n  count <= 4'b0000 ; \n  end \n  end \n  else if (state == 1) begin \n  bslip <= 1'b0 ; \n  count <= count + 4'b0001 ; \n  if (count == 4'b1111) begin \n  state <= 0; \n  end \n  end \n end \n end \n always @ (posedge rx_bufg_x1) \n begin \n  rxr <= rxd ; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module represents a data unit for performing parallel multiplication. It utilizes SN74194 shift registers, SN74157 multiplexer, SN7483 4-bit adder, and SN7483 4-bit parallel binary adder. The module takes Multiplicant, Multiplier, Shift1, Shift0, reset, and clock as inputs, and outputs the 8-bit Product. It performs multiplication by shifting the Multiplicant based on the Multiplier, adding the shifted values, and storing the result in the Product register. The CarryOut signal is used to handle the carry during addition. The module also includes logic to handle clock and reset signals.\n\n Module header:\n\nmodule DataUnit(Product, Multiplicant, Multiplier, Shift1, Shift0, reset, clock);\n [/INST]\n", "output": "input clock, reset; \n  input [3:0] Multiplicant, Multiplier; \n  input [2:0] Shift1, Shift0; \n  output [7:0] Product; \n  wire [3:0] MultiplierOut; \n  SN74194 MultiplierRegister(Multiplier,MultiplierOut,1'b0,1'b0,Shift1[2],Shift0[2],reset,clock); \n  SN74157 MultiplicantMux(Multiplicant[3],1'b0,Multiplicant[2],1'b0,Multiplicant[1],1'b0,Multiplicant[0],1'b0,1'b0,MultiplierOut[0],QA,QB,QC,QD); \n  wire [3:0] Sum; \n  reg CarryOut; \n  SN74194 UpperProductRegister(Sum,Product[7:4],1'b0,CarryOut,Shift1[1],Shift0[1],reset,clock); \n  SN74194 LowerProductRegister(4'd0,Product[3:0],1'b0,Product[4],Shift1[0],Shift0[0],reset,clock); \n  wire CO; \n  SN7483 Adder({QA,QB,QC,QD},Product[7:4],1'b0,CO,Sum); \n  always@(posedge clock or negedge reset) \n  if(reset==0) CarryOut<=0; \n  else CarryOut<=CO; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module takes in several input signals of varying bit widths and outputs segments of these input signals. Specifically, it outputs the first 11 bits of the input signal to ap_return_0, the next 3 bits to ap_return_1, and the subsequent 6 bits to ap_return_2 and ap_return_3. The module achieves this by using assign statements to directly set each output to the desired segment of the input signal.\n\n Module header:\n\nmodule sp_find_segment_stn1 (ph_seg_p_1_1_1_V_read,th_seg_p_1_1_0_V_read,th_seg_p_1_1_1_V_read,cpat_seg_p_1_1_1_V_read,ap_return_0,ap_return_1,ap_return_2,ap_return_3);\n [/INST]\n", "output": "input [11:0] ph_seg_p_1_1_1_V_read; \n input [6:0] th_seg_p_1_1_0_V_read; \n input [6:0] th_seg_p_1_1_1_V_read; \n input [3:0] cpat_seg_p_1_1_1_V_read; \n output [11:0] ap_return_0; \n output [3:0] ap_return_1; \n output [6:0] ap_return_2; \n output [6:0] ap_return_3; \n assign ap_return_0 = ph_seg_p_1_1_1_V_read; \n assign ap_return_1 = cpat_seg_p_1_1_1_V_read; \n assign ap_return_2 = th_seg_p_1_1_0_V_read; \n assign ap_return_3 = th_seg_p_1_1_1_V_read; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a 16x2 RAM with 16 addressable memory locations and 16-bit data. It has inputs for data in (DI0, DI1), write address (WAD0, WAD1, WAD2, WAD3), write enable (WRE), clock (WCK), read address (RAD0, RAD1, RAD2, RAD3), and outputs for data out (DO0, DO1).\n\nThe memory is initialized with 16-bit initial values INITVAL_0 and INITVAL_1. The module has a clock and write enable multiplexer. It writes data to memory on the positive edge of the clock when the write enable is true. It reads data from memory based on the read address and assigns it to the output.\n\n Module header:\n\nmodule TRELLIS_RAM16X2 (input DI0, DI1,input WAD0, WAD1, WAD2, WAD3,input WRE, WCK,input RAD0, RAD1, RAD2, RAD3,output DO0, DO1);\n [/INST]\n", "output": "parameter WCKMUX = \"WCK\"; \n  parameter WREMUX = \"WRE\"; \n  parameter INITVAL_0 = 16'h0000; \n  parameter INITVAL_1 = 16'h0000; \n  reg [1:0] mem[15:0]; \n  integer i; \n  initial begin \n  for (i = 0; i < 16; i = i + 1) \n  mem[i] <= {INITVAL_1[i], INITVAL_0[i]}; \n  end \n  wire muxwck = (WCKMUX == \"INV\") ? ~WCK : WCK; \n  reg muxwre; \n  always @(*) \n  case (WREMUX) \n  \"1\": muxwre = 1'b1; \n  \"0\": muxwre = 1'b0; \n  \"INV\": muxwre = ~WRE; \n  default: muxwre = WRE; \n  endcase \n  always @(posedge muxwck) \n  if (muxwre) \n  mem[{WAD3, WAD2, WAD1, WAD0}] <= {DI1, DI0}; \n  assign {DO1, DO0} = mem[{RAD3, RAD2, RAD1, RAD0}]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an I2C Master controller. It interfaces with an I2C bus to write and read data from external devices. The module includes clock and reset inputs, control signals for write and read operations, and I/O ports for the I2C bus. It also maintains internal registers for managing data transmission and reception.\n\nThe module implements clock division and timing for I2C communication, handles sending and receiving data, and tracks the status of data reception. It utilizes a finite state machine to coordinate the write and read operations.\n\nAdditionally, the module includes logic to handle acknowledgments and data transmission to and from the I2C bus. It initializes the necessary control signals and internal registers during a reset condition.\n\n Module header:\n\nmodule I2C_MASTER(clk,rst_n,sda,scl,RD_EN,WR_EN,receive_status);\n [/INST]\n", "output": "input clk; \n input rst_n; \n input RD_EN; \n input WR_EN; \n reg WR,RD; \n output scl; \n output receive_status; \n inout sda; \n reg scl_clk; \n reg receive_status; \n reg[7:0] clk_div; \n reg[7:0] send_count; \n wire[7:0] data; \n reg[7:0] data_reg; \n wire ack; \n reg[7:0] send_memory[31:0]; \n reg[7:0] receive_memory[31:0]; \n always @(posedge clk or negedge rst_n)begin \n  if(!rst_n)begin \n  scl_clk <= 1'b0; \n  clk_div <= 'h0; \n  send_memory[0] <= 8'd0; \n  send_memory[1] <= 8'd1; \n  send_memory[2] <= 8'd2; \n  send_memory[3] <= 8'd3; \n  send_memory[4] <= 8'd4; \n  send_memory[5] <= 8'd5; \n  send_memory[6] <= 8'd6; \n  send_memory[7] <= 8'd7; \n  send_memory[8] <= 8'd8; \n  send_memory[9] <= 8'd9; \n  send_memory[10] <= 8'd10; \n  send_memory[11] <= 8'd11; \n  send_memory[12] <= 8'd12; \n  send_memory[13] <= 8'd13; \n  send_memory[14] <= 8'd14; \n  send_memory[15] <= 8'd15; \n  send_memory[16] <= 8'd16; \n  send_memory[17] <= 8'd17; \n  send_memory[18] <= 8'd18; \n  send_memory[19] <= 8'd19; \n  send_memory[20] <= 8'd20; \n  send_memory[21] <= 8'd21; \n  send_memory[22] <= 8'd22; \n  send_memory[23] <= 8'd23; \n  send_memory[24] <= 8'd24; \n  send_memory[25] <= 8'd25; \n  send_memory[26] <= 8'd26; \n  send_memory[27] <= 8'd27; \n  send_memory[28] <= 8'd28; \n  send_memory[29] <= 8'd29; \n  send_memory[30] <= 8'd30; \n  send_memory[31] <= 8'd31; \n  end \n  else begin \n  if(clk_div > 'd200)begin \n  scl_clk <= ~scl_clk; \n  clk_div <= 'h0; \n  end \n  else \n  clk_div <= clk_div + 1'b1; \n  end \n end \n always @(posedge ack or negedge rst_n)begin \n  if(!rst_n)begin \n  send_count <= 'h0; \n  end \n  else begin \n  if((send_count < 10'd32) && (ack))begin \n  send_count <= send_count + 1'b1; \n  receive_memory[send_count] <= RD_EN ? data : 8'h0; \n  end \n  else begin \n  send_count <= send_count; \n  end \n  end \n end \n always @(posedge clk or negedge rst_n)begin \n  if(!rst_n) \n  receive_status <= 1'b0; \n  else \n  receive_status <=(receive_memory[31]== 31) ? 1'b1 : 1'b0; \n end \n always @(posedge clk or negedge rst_n)begin \n  if(!rst_n)begin \n  WR <= 1'b0; \n  RD <= 1'b0; \n  data_reg <= 'h0; \n  end \n  else begin \n  if(send_count == 8'd32)begin \n  WR <= 1'b0; \n  RD <= 1'b0; \n  end \n  else begin \n  if(RD_EN) \n  RD <= 1'b1; \n  else if(WR_EN)begin \n  WR <= 1'b1; \n  data_reg <= send_memory[send_count]; \n  end \n  end \n  end \n end \n assign data = WR_EN ? data_reg : 8'hz; \n I2C_wr I2C_wr_instance(.sda(sda),.scl(scl),.ack(ack),.rst_n(rst_n),.clk(scl_clk),.WR(WR),.RD(RD),.data(data)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module simply passes the inputs DOA1, DOB1, DOC1, DOD1, DOA0, DOB0, DOC0, and DOD0 directly to the outputs DOA1_OUT, DOB1_OUT, DOC1_OUT, DOD1_OUT, DOA0_OUT, DOB0_OUT, DOC0_OUT, and DOD0_OUT respectively. It doesn't perform any logic or manipulation on the input signals.\n\n Module header:\n\nmodule DRAM_8_OUTPUT_STUB(input DOA1, DOB1, DOC1, DOD1, DOA0, DOB0, DOC0, DOD0,output DOA1_OUT, DOB1_OUT, DOC1_OUT, DOD1_OUT, DOA0_OUT, DOB0_OUT, DOC0_OUT, DOD0_OUT);\n [/INST]\n", "output": "assign DOA1_OUT = DOA1; \n  assign DOB1_OUT = DOB1; \n  assign DOC1_OUT = DOC1; \n  assign DOD1_OUT = DOD1; \n  assign DOA0_OUT = DOA0; \n  assign DOB0_OUT = DOB0; \n  assign DOC0_OUT = DOC0; \n  assign DOD0_OUT = DOD0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes an 8-bit input din and produces an output dout based on the parameterized values N and M. It constructs a mask of size 2*M-1 with all bits set to 1. It then shifts the mask to the left by the N least significant bits of din, and finally shifts the result to the right by M bits to produce the output dout.\n\n Module header:\n\nmodule abc9_test023 #(parameter integer N = 2,parameter integer M = 2) (input [7:0] din,output [M-1:0] dout);\n [/INST]\n", "output": "wire [2*M-1:0] mask = {M{1'b1}}; \n  assign dout = (mask << din[N-1:0]) >> M; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, named \"R_CPU,\" implements a simplified CPU architecture. It contains multiple inputs and outputs for interfacing with other components. The module includes an Instruction Fetch and Memory unit, Register File, and Arithmetic Logic Unit (ALU).\n\nThe module uses the clock signal for synchronization and the reset signal for initialization. It extracts various fields from the instruction code, such as the operation code (OP), source and destination register addresses (rs, rt, rd), and function code. These fields are then used for control and data path operations within the CPU.\n\nThe Register File (REGS) is used for reading and writing data to specific registers. The ALU is responsible for performing arithmetic and logical operations based on the inputs from the register file and the extracted operation code (ALU_OP).\n\nThe \"always\" block handles the control logic for setting the ALU operation code and the write register based on the operation code extracted from the instruction. Additionally, the negative edge of the clock triggers the setting of the zero flag (FR_ZF) and overflow flag (FR_OF) based on the ALU's output.\n\nIn summary, the module performs instruction decoding, register file operations, ALU operations, and flag management for a simple CPU design.\n\n Module header:\n\nmodule R_CPU (input clk,input rst,output [31:0] ALU_F,output reg FR_ZF,FR_OF,output wire [4:0] rs, rt, rd,output wire [5:0] OP, func,output wire [31:0] ALU_A, ALU_B);\n [/INST]\n", "output": "wire ZF, OF; \n  wire [31:0] Inst_code; \n  reg Write_Reg; \n  reg [2:0] ALU_OP; \n IF_M theIF (.clka(clk),.rst(rst),.Inst_code(Inst_code)); \n  assign OP = Inst_code[31:26]; \n  assign rs = Inst_code[25:21]; \n  assign rt = Inst_code[20:16]; \n  assign rd = Inst_code[15:11]; \n  assign func = Inst_code[5:0]; \n register REGS (.clk(~clk),.Reset(rst),.R_Addr_A(rs),.R_Addr_B(rt),.W_Addr(rd),.W_Data(ALU_F),.Write_Reg(Write_Reg),.R_Data_A(ALU_A),.R_Data_B(ALU_B)); \n ALU theALU (.A(ALU_A),.B(ALU_B),.ZF(ZF),.OF(OF),.F(ALU_F),.ALU_OP(ALU_OP)); \n  always @(*) \n  begin \n  ALU_OP = 3'b000; \n  Write_Reg = 1'b0; \n  if(OP==6'b000000) \n  begin \n  Write_Reg = 1'b1; \n  case (func) \n  6'b100000: ALU_OP = 3'b100; \n  6'b100010: ALU_OP = 3'b101; \n  6'b100100: ALU_OP = 3'b000; \n  6'b100101: ALU_OP = 3'b001; \n  6'b100110: ALU_OP = 3'b010; \n  6'b100111: ALU_OP = 3'b011; \n  6'b101011: ALU_OP = 3'b110; \n  6'b000100: ALU_OP = 3'b111; \n  default: ALU_OP = 3'b000; \n  endcase \n  end \n  else \n  begin \n  ALU_OP = 3'b000; \n  end \n  end \n  always @(negedge clk) \n  begin \n  FR_ZF <= ZF; \n  FR_OF <= OF; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements an axis scaler for multiplying input data by a configuration value. It uses registers to hold the input data and perform the multiplication, and handles input and output valid and ready signals. The module also features a reset logic to clear the data registers. The module assigns the output ready signal and the multiplied data to the output ports.\n\n Module header:\n\nmodule axis_scaler # (parameter integer AXIS_TDATA_WIDTH = 14) (input wire aclk,input wire aresetn,input wire signed [AXIS_TDATA_WIDTH-1:0] cfg_data,input wire signed [AXIS_TDATA_WIDTH-1:0] s_axis_tdata,input wire s_axis_tvalid,output wire s_axis_tready,input wire m_axis_tready,output wire signed [AXIS_TDATA_WIDTH-1:0] m_axis_tdata,output wire m_axis_tvalid);\n [/INST]\n", "output": "reg signed [AXIS_TDATA_WIDTH-1:0] s_axis_tdata_reg,s_axis_tdata_next; \n reg [AXIS_TDATA_WIDTH*2-1:0] int_data_reg, int_data_next; \n wire multiply = s_axis_tvalid & m_axis_tready; \n always @(posedge aclk) \n  begin \n  if(~aresetn) \n  begin \n  s_axis_tdata_reg <= 0; \n  s_axis_tdata_next <= 0; \n  int_data_reg <= 0; \n  int_data_next <= 0; \n  end \n  else \n  begin \n  if(multiply) \n  begin \n  s_axis_tdata_reg <= s_axis_tdata; \n  s_axis_tdata_next <= s_axis_tdata_reg; \n  int_data_reg <= s_axis_tdata_next*cfg_data; \n  int_data_next <= int_data_reg; \n  end \n  end \n  end \n assign s_axis_tready = m_axis_tready; \n assign m_axis_tvalid = s_axis_tvalid; \n assign m_axis_tdata = int_data_next[AXIS_TDATA_WIDTH*2-3:AXIS_TDATA_WIDTH-2]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module is a state machine that controls the generation of various signals based on input events and timing. It manages a timer, enables and monitors processors, and handles the generation of the QINIT, QPULSE, QDIVIDE, QCONVEX_HULL, and QDISPLAY signals based on the input events and state transitions.\n\n Module header:\n\nmodule m_port_ultra (input clk,input reset_n,input ack,input [32767:0] convexCloud,output [4095:0] convexHull1,output [4095:0] convexHull2,output [4095:0] convexHull3,output [4095:0] convexHull4,output [4095:0] convexHull5,output [4095:0] convexHull6,output [4095:0] convexHull7,output [4095:0] convexHull8,output [8:0] convexHullSize1,output [8:0] convexHullSize2,output [8:0] convexHullSize3,output [8:0] convexHullSize4,output [8:0] convexHullSize5,output [8:0] convexHullSize6,output [8:0] convexHullSize7,output [8:0] convexHullSize8,output processorDone1,output processorDone2,output processorDone3,output processorDone4,output processorDone5,output processorDone6,output processorDone7,output processorDone8,output QINIT,output QPULSE,output QDIVIDE,output QCONVEX_HULL,output QDISPLAY);\n [/INST]\n", "output": "reg [3:0] timer; \n  reg processorEnable; \n  reg divideEnable; \n  reg divideFinished; \n m_port_ultra_processor_array processorArray (.clk (clk),.reset_n (reset_n),.processorEnable (processorEnable),.divideEnable (divideEnable),.divideFinished (divideFinished),.convexCloud (convexCloud),.convexHull1 (convexHull1),.convexHull2 (convexHull2),.convexHull3 (convexHull3),.convexHull4 (convexHull4),.convexHull5 (convexHull5),.convexHull6 (convexHull6),.convexHull7 (convexHull7),.convexHull8 (convexHull8),.convexHullSize1 (convexHullSize1),.convexHullSize2 (convexHullSize2),.convexHullSize3 (convexHullSize3),.convexHullSize4 (convexHullSize4),.convexHullSize5 (convexHullSize5),.convexHullSize6 (convexHullSize6),.convexHullSize7 (convexHullSize7),.convexHullSize8 (convexHullSize8),.processorDone1 (processorDone1),.processorDone2 (processorDone2),.processorDone3 (processorDone3),.processorDone4 (processorDone4),.processorDone5 (processorDone5),.processorDone6 (processorDone6),.processorDone7 (processorDone7),.processorDone8 (processorDone8)); \n  reg[4:0] state; \n  localparam \n  INIT = 5'b00001, \n  PULSE = 5'b00010, \n  DIVIDE = 5'b00100, \n  CONVEX_HULL = 5'b01000, \n  DISPLAY = 5'b10000; \n  assign { QDISPLAY, QCONVEX_HULL, QDIVIDE, QPULSE, QINIT } = state; \n  always @(posedge clk, negedge reset_n) begin \n  if (!reset_n) begin \n  timer <= 0; \n  processorEnable <= 0; \n  divideEnable <= 0; \n  divideFinished <= 0; \n  state <= INIT; \n  end \n  else begin \n  case (state) \n  INIT: begin \n  timer <= 0; \n  if (ack) begin \n  state <= PULSE; \n  end \n  end \n  PULSE: begin \n  timer <= timer + 1; \n  if (timer >= 9) begin \n  divideEnable <= 1'b1; \n  state <= DIVIDE; \n  end \n  end \n  DIVIDE: begin \n  processorEnable <= 1; \n  state <= CONVEX_HULL; \n  end \n  CONVEX_HULL: begin \n  if (processorDone1 && processorDone2 && processorDone3 && processorDone4 && processorDone5 && processorDone6 && processorDone7 && processorDone8) begin \n  state <= DISPLAY; \n  end \n  end \n  DISPLAY: begin \n  if (ack) begin \n  state <= INIT; \n  end \n  end \n  endcase \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a UART receiver with a configurable clock cycle count and counter width. It uses a finite state machine to receive 8-bit data when the uart_rx signal is low and sets the received flag when the data is fully received. The module tracks the number of bits left to receive and manages the receiving state based on the uart_rx signal and the configured clock cycle count.\n\n Module header:\n\nmodule uart_receiver #(parameter CLK_CYCLES=4178, CTR_WIDTH=16) (input wire clk, output reg [7:0] data, output reg received, input wire uart_rx);\n [/INST]\n", "output": "reg [CTR_WIDTH-1:0] ctr = CLK_CYCLES; \n  reg [4:0] bits_left = 0; \n  reg receiving = 0; \n  always @(posedge clk) begin \n  ctr <= ctr - 1'b1; \n  received <= 0; \n  if (ctr == 0) begin \n  ctr <= (CLK_CYCLES-1); \n  data <= {uart_rx, data[7:1]}; \n  bits_left <= bits_left - 1'b1; \n  if (receiving && (bits_left == 1)) begin \n  received <= 1; \n  end \n  if (bits_left == 0) begin \n  receiving <= 0; \n  end \n  end \n  if (uart_rx == 0 && !receiving) begin \n  ctr <= (CLK_CYCLES-1 + CLK_CYCLES / 2); \n  bits_left <= 4'd8; \n  receiving <= 1; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a simple loopback interface. It connects VJTAG and SDRAM modules, and routes signals between them. It includes inputs for VJTAG byte enable, write data, address, and control signals, as well as SDRAM read data valid, wait request, read data, and control signals. Outputs include LEDs, VJTAG read data, wait request, read data valid, SDRAM address, read, write, write data, and byte enable. \n\nThe module includes internal wires and registers to handle data transfer between VJTAG and SDRAM. The module also contains a clocked always block to handle the read/write operations based on the clock signal and reset. Additionally, the module uses assign statements to route the signals between VJTAG and SDRAM.\n\nIn summary, this Verilog module serves as a bridge between VJTAG and SDRAM, transferring data and control signals between the two modules.\n\n Module header:\n\nmodule loopback (vjtag_byteenable,vjtag_writedata,vjtag_address,sdram_readdatavalid,sdram_waitrequest,sdram_readdata,vjtag_write,vjtag_read,rst,clk,leds,vjtag_readdata,vjtag_waitrequest,vjtag_readdatavalid,sdram_address,sdram_read,sdram_write,sdram_writedata,sdram_byteenable);\n [/INST]\n", "output": "input [3:0] vjtag_byteenable; \n  input [31:0] vjtag_writedata; \n  input [31:0] vjtag_address; \n  input sdram_readdatavalid; \n  input sdram_waitrequest; \n  input [31:0] sdram_readdata; \n  input vjtag_write; \n  input vjtag_read; \n  input rst; \n  input clk; \n  output [7:0] leds; \n  output [31:0] vjtag_readdata; \n  output vjtag_waitrequest; \n  output vjtag_readdatavalid; \n  output [31:0] sdram_address; \n  output sdram_read; \n  output sdram_write; \n  output [31:0] sdram_writedata; \n  output [3:0] sdram_byteenable; \n  wire _48; \n  wire [7:0] _50 = 8'b00000000; \n  wire vdd = 1'b1; \n  wire [7:0] _51 = 8'b00000000; \n  wire _47; \n  wire [7:0] _53 = 8'b00000001; \n  wire [7:0] _54; \n  wire [7:0] _49; \n  reg [7:0] _52; \n  assign _48 = vjtag_read | vjtag_write; \n  assign _47 = ~ rst; \n  assign _54 = _52 + _53; \n  assign _49 = _54; \n  always @(posedge clk or posedge _47) begin \n  if (_47) \n  _52 <= _51; \n  else \n  if (_48) \n  _52 <= _49; \n  end \n  assign leds = _52; \n  assign vjtag_readdata = sdram_readdata; \n  assign vjtag_waitrequest = sdram_waitrequest; \n  assign vjtag_readdatavalid = sdram_readdatavalid; \n  assign sdram_address = vjtag_address; \n  assign sdram_read = vjtag_read; \n  assign sdram_write = vjtag_write; \n  assign sdram_writedata = vjtag_writedata; \n  assign sdram_byteenable = vjtag_byteenable; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an input valid synchronizer for data transfer between two clock domains. It includes logic for synchronizing input valid signals, buffering and synchronizing input and output data, and managing input and output ready signals. The module uses flip-flops and buffers to ensure proper synchronization and handshaking between the input and output signals.\n\n Module header:\n\nmodule sirv_gnrl_cdc_rx # (parameter DW = 32,parameter SYNC_DP = 2) (input i_vld_a,output i_rdy,input [DW-1:0] i_dat,output o_vld,input o_rdy,output [DW-1:0] o_dat,input clk,input rst_n);\n [/INST]\n", "output": "wire i_vld_sync; \n sirv_gnrl_sync #(.DP(SYNC_DP), .DW(1)) u_i_vld_sync (.clk (clk),.rst_n (rst_n),.din_a (i_vld_a),.dout (i_vld_sync)); \n wire i_vld_sync_r; \n sirv_gnrl_dffr #(1) i_vld_sync_dffr(i_vld_sync, i_vld_sync_r, clk, rst_n); \n wire i_vld_sync_nedge = (~i_vld_sync) & i_vld_sync_r; \n wire buf_rdy; \n wire i_rdy_r; \n wire i_rdy_set = buf_rdy & i_vld_sync & (~i_rdy_r); \n wire i_rdy_clr = i_vld_sync_nedge; \n wire i_rdy_ena = i_rdy_set | i_rdy_clr; \n wire i_rdy_nxt = i_rdy_set | (~i_rdy_clr); \n sirv_gnrl_dfflr #(1) i_rdy_dfflr(i_rdy_ena, i_rdy_nxt, i_rdy_r, clk, rst_n); \n assign i_rdy = i_rdy_r; \n wire buf_vld_r; \n wire [DW-1:0] buf_dat_r; \n wire buf_dat_ena = i_rdy_set; \n sirv_gnrl_dfflr #(DW) buf_dat_dfflr(buf_dat_ena, i_dat, buf_dat_r, clk, rst_n); \n wire buf_vld_set = buf_dat_ena; \n wire buf_vld_clr = o_vld & o_rdy; \n wire buf_vld_ena = buf_vld_set | buf_vld_clr; \n wire buf_vld_nxt = buf_vld_set | (~buf_vld_clr); \n sirv_gnrl_dfflr #(1) buf_vld_dfflr(buf_vld_ena, buf_vld_nxt, buf_vld_r, clk, rst_n); \n assign buf_rdy = (~buf_vld_r); \n assign o_vld = buf_vld_r; \n assign o_dat = buf_dat_r; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a clock generator for a DDR (Double Data Rate) interface. It takes in differential clock signals and generates multiple phased and buffered clock outputs. The clock signals are first buffered and divided by 2, and then further processed to generate the desired clock signals for the DDR interface. The generated clocks include the main differential clock output, a serialized strobe signal, and several other clock signals with specific phase relationships. The module uses specialized buffer and clock management components to ensure proper timing and signal integrity for the DDR interface.\n\n Module header:\n\nmodule clock_generator_ddr_s8_diff (clkin_p, clkin_n, ioclkap, ioclkan, serdesstrobea, ioclkbp, ioclkbn, serdesstrobeb, gclk);\n [/INST]\n", "output": "parameter integer S = 8 ; \n parameter DIFF_TERM = \"FALSE\" ; \n input clkin_p, clkin_n ; \n output ioclkap ; \n output ioclkan ; \n output serdesstrobea ; \n output ioclkbp ; \n output ioclkbn ; \n output serdesstrobeb ; \n output gclk ; \n wire clkint ; \n wire gclk_int ; \n wire freqgen_in_p ; \n wire tx_bufio2_x1 ; \n assign gclk = gclk_int ; \n IBUFGDS #(.DIFF_TERM (DIFF_TERM)) \n clk_iob_in (.I (clkin_p),.IB (clkin_n),.O (freqgen_in_p)); \n BUFIO2 #(.DIVIDE (S),.I_INVERT (\"FALSE\"),.DIVIDE_BYPASS (\"FALSE\"),.USE_DOUBLER (\"TRUE\")) \n bufio2_inst1 (.I (freqgen_in_p),.IOCLK (ioclkap),.DIVCLK (tx_bufio2_x1),.SERDESSTROBE (serdesstrobea)) ; \n BUFIO2 #(.I_INVERT (\"TRUE\"),.DIVIDE_BYPASS (\"FALSE\"),.USE_DOUBLER (\"FALSE\")) \n bufio2_inst2 (.I (freqgen_in_p),.IOCLK (ioclkan),.DIVCLK (),.SERDESSTROBE ()) ; \n BUFIO2 #(.DIVIDE (S),.I_INVERT (\"FALSE\"),.DIVIDE_BYPASS (\"FALSE\"),.USE_DOUBLER (\"TRUE\")) \n bufio2_inst3 (.I (freqgen_in_p),.IOCLK (ioclkbp),.DIVCLK (),.SERDESSTROBE (serdesstrobeb)) ; \n BUFIO2 #(.I_INVERT (\"TRUE\"),.DIVIDE_BYPASS (\"FALSE\"),.USE_DOUBLER (\"FALSE\")) \n bufio2_inst4 (.I (freqgen_in_p),.IOCLK (ioclkbn),.DIVCLK (),.SERDESSTROBE ()) ; \n BUFG bufg_tx (.I (tx_bufio2_x1), .O (gclk_int)) ; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module RCB_FRL_data_check is designed to check for errors in the input data and message signals. It has inputs CLK, RST, RDEN_DATA, RDEN_MSG, DATA, and MSG, and outputs ERR0, ERR1, ERR2, ERR3, and ERR_MSG.\n\nThe module contains registers to store temporary values of DATA and MSG. At each positive clock edge, it checks for errors in the input data and message. If the RST signal is asserted, all error counters and temporary registers are cleared.\n\nFor the data, it compares each byte of the input data with the corresponding byte from the previous cycle. If a byte is not incremented by one or is not zero (except for the first byte), it increments the corresponding error counter. \n\nFor the message, it checks if each byte is incremented by one compared to the previous byte. If not, it increments the error message counter.\n\nThe error counters ERR0, ERR1, ERR2, ERR3, and ERR_MSG keep track of the number of errors detected in the input data and message.\n\n Module header:\n\nmodule RCB_FRL_data_check(CLK,RST,RDEN_DATA,RDEN_MSG,DATA,MSG,ERR0,ERR1,ERR2,ERR3,ERR_MSG);\n [/INST]\n", "output": "input CLK,RST,RDEN_DATA,RDEN_MSG; \n input [31:0] DATA; \n input [39:0] MSG; \n output reg [3:0] ERR0,ERR1,ERR2,ERR3,ERR_MSG; \n reg [31:0] DATA_TEMP; \n reg [7:0] MSG_TEMP; \n always @ (posedge CLK) \n begin \n  if(RST) \n  begin \n  ERR0 <= 0; \n  ERR1 <= 0; \n  ERR2 <= 0; \n  ERR3 <= 0; \n  ERR_MSG <= 0; \n  DATA_TEMP <= 0; \n  MSG_TEMP <= 0; \n  end \n  else if(RDEN_DATA) \n  begin \n  DATA_TEMP <= DATA; \n  MSG_TEMP <= MSG; \n  if(DATA_TEMP[7:0] + 1 != DATA[7:0] && DATA[7:0] != 0) \n  ERR0 <= ERR0 + 1; \n  if(DATA_TEMP[15:8] + 1 != DATA[15:8] && DATA[15:8] != 0) \n  ERR1 <= ERR1 + 1; \n  if(DATA_TEMP[23:16] + 1 != DATA[23:16] && DATA[23:16] != 0) \n  ERR2 <= ERR2 + 1; \n  if(DATA_TEMP[31:24] + 1 != DATA[31:24] && DATA[31:24] != 0) \n  ERR3 <= ERR3 + 1; \n  if(MSG[39:32] + 1 != MSG[31:24] || MSG[31:24] + 1 != MSG[23:16] || MSG[23:16] + 1 != MSG[15:8] || MSG[15:8] + 1 != MSG[7:0]) \n  ERR_MSG <= ERR_MSG + 1; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `ror_struct` implements a right rotation shift operation on the input `in` with a dynamic shift amount specified by the `shift` input. The module uses a shift register to perform the rotation, and the width of the input and output is determined by the parameter `CTRL`. The output `out` is the result of the rotation operation.\n\n Module header:\n\nmodule ror_struct #(parameter CTRL=5,parameter WIDTH=2**CTRL) (input [WIDTH-1:0] in,input [ CTRL-1:0] shift,output [WIDTH:0] out);\n [/INST]\n", "output": "wire [WIDTH:0] tmp [CTRL:0]; \n  assign tmp[CTRL] = {in[31], in}; \n  assign out = tmp[0]; \n  genvar i; \n  generate \n  for (i = 0; i < CTRL; i = i + 1) begin: mux \n  assign tmp[i] = shift[i] ? {tmp[i+1][(2**i)-1], tmp[i+1][(2**i)-1:0],tmp[i+1][WIDTH-1:(2**i)]} : tmp[i+1]; \n  end \n  endgenerate \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a PS2 controller that interfaces with a PS2 device. It implements a FIFO buffer to store incoming data and a timeout mechanism to handle incoming data from the PS2 device. The module synchronizes the PS2 clock, generates a sample pulse, and tracks the count of received bits. It also handles the logic for writing data to the FIFO buffer, checking for FIFO overflow, and reading from the FIFO buffer. Additionally, it includes logic for handling the reset signal and the watchdog timer expiration. Overall, this module efficiently manages the communication with the PS2 device while ensuring data integrity and proper timing.\n\n Module header:\n\nmodule ps2(reset, clock, ps2c, ps2d, fifo_rd, fifo_data, fifo_empty,fifo_overflow, watchdog, count);\n [/INST]\n", "output": "input clock,reset,watchdog,ps2c,ps2d; \n  input fifo_rd; \n  output [7:0] fifo_data; \n  output fifo_empty; \n  output fifo_overflow; \n  output [3:0] count; \n  reg [3:0] count; \n  reg [9:0] shift; \n  reg [7:0] fifo[7:0]; \n  reg fifo_overflow; \n  reg [2:0] wptr,rptr; \n  wire [2:0] wptr_inc = wptr + 3'd1; \n  assign fifo_empty = (wptr == rptr); \n  assign fifo_data = fifo[rptr]; \n  reg [2:0] ps2c_sync; \n  always @ (posedge clock) ps2c_sync <= {ps2c_sync[1:0],ps2c}; \n  wire sample = ps2c_sync[2] & ~ps2c_sync[1]; \n  reg timeout; \n  always @(posedge clock) begin \n  if(reset) begin \n  count <= 0; \n  wptr <= 0; \n  rptr <= 0; \n  timeout <= 0; \n  fifo_overflow <= 0; \n  end else if (sample) begin \n  if(count==10) begin \n  if(shift[0]==0 && ps2d==1 && (^shift[9:1])==1) begin \n  fifo[wptr] <= shift[8:1]; \n  wptr <= wptr_inc; \n  fifo_overflow <= fifo_overflow | (wptr_inc == rptr); \n  end \n  count <= 0; \n  timeout <= 0; \n  end else begin \n  shift <= {ps2d,shift[9:1]}; \n  count <= count + 1; \n  end \n  end else if (watchdog && count!=0) begin \n  if (timeout) begin \n  count <= 0; \n  timeout <= 0; \n  end else timeout <= 1; \n  end \n  if (fifo_rd && !fifo_empty) begin \n  rptr <= rptr + 1; \n  fifo_overflow <= 0; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a BPM calculator that calculates the beats per minute (BPM) based on the input beat signal and a default BPM value. It maintains a buffer of the last 4 BPM values and updates the BPM sum based on the intervals between beats. The module has logic to handle the longest and shortest allowable intervals and updates the BPM sum and buffer accordingly. The calculated BPM value is output through the bpm_out port. The module also includes an instance of the bpm_from_interval module to calculate the BPM from the interval count.\n\n Module header:\n\nmodule bpmcalculator(input wire clk,input wire beat,input wire [7:0] default_bpm,output wire [7:0] bpm_out);\n [/INST]\n", "output": "parameter SMALLEST_ALLOWABLE_INTERVAL = 32'd23529; \n  parameter LONGEST_ALLOWABLE_INTERVAL = 32'd200000; \n  parameter STARTING_BPM = 8'd80; \n  reg [31:0] counter; \n  wire [7:0] counted_bpm; \n  reg [7:0] buffer[0:3]; \n  reg [1:0] oldest_index; \n  reg [9:0] bpm_sum; \n  reg prev_beat; \n  assign bpm_out = bpm_sum[9:2]; \n bpm_from_interval bfi (.counter(counter),.default_bpm(default_bpm),.counted_bpm(counted_bpm)); \n  initial begin \n  bpm_sum = STARTING_BPM*4; \n  buffer[0] = STARTING_BPM; \n  buffer[1] = STARTING_BPM; \n  buffer[2] = STARTING_BPM; \n  buffer[3] = STARTING_BPM; \n  counter = 0; \n  oldest_index = 0; \n  prev_beat = 0; \n  end \n  always @(posedge clk) begin \n if ((counter > LONGEST_ALLOWABLE_INTERVAL) ||(beat && ~prev_beat && (counter >= SMALLEST_ALLOWABLE_INTERVAL))) \n  begin \n  bpm_sum = bpm_sum + (counted_bpm - buffer[oldest_index]); \n  buffer[oldest_index] = counted_bpm; \n  oldest_index = (oldest_index == 3) ? 0 : oldest_index+1; \n  prev_beat = 1; \n  counter = 0; \n  end else begin \n  counter = counter + 1; \n  prev_beat = beat; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, \"tse_mac3_loopback,\" creates a simple loopback design. It generates a reference clock signal that toggles every 4 cycles and a reconfigurable clock signal that toggles every 20 cycles. The transmit signal is connected directly to the receive signal. The module has ports for the reference clock, transmit signal, and receive signal.\n\n Module header:\n\nmodule tse_mac3_loopback (ref_clk,txp,rxp);\n [/INST]\n", "output": "output ref_clk; \n  input txp; \n  output rxp; \n  reg clk_tmp; \n  initial \n  clk_tmp <= 1'b0; \n  always \n  #4 clk_tmp <= ~clk_tmp; \n  reg reconfig_clk_tmp; \n  initial \n  reconfig_clk_tmp <= 1'b0; \n  always \n  #20 reconfig_clk_tmp <= ~reconfig_clk_tmp; \n  assign ref_clk = clk_tmp; \n  assign rxp=txp; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"sysgen_constant_870c02eef2\" outputs a constant value of 8'b11001000 on the op output whenever the clk, ce, or clr input signals change.\n\n Module header:\n\nmodule sysgen_constant_870c02eef2 (output [(8 - 1):0] op,input clk,input ce,input clr);\n [/INST]\n", "output": "assign op = 8'b11001000; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a finite state machine (FSM) that controls the master's interactions with a slave based on various input signals. It includes logic for handling read and write operations, managing state transitions, and responding to wait requests from the slave. The module updates the state and control signals based on the current state and input conditions to coordinate the master's actions with the slave.\n\n Module header:\n\nmodule kernel_clock_0_master_FSM (master_clk,master_reset_n,master_waitrequest,slave_read_request_token,slave_write_request_token,master_read,master_read_done,master_write,master_write_done);\n [/INST]\n", "output": "output master_read; \n  output master_read_done; \n  output master_write; \n  output master_write_done; \n  input master_clk; \n  input master_reset_n; \n  input master_waitrequest; \n  input slave_read_request_token; \n  input slave_write_request_token; \n  reg master_read; \n  reg master_read_done; \n  reg [ 2: 0] master_state; \n  reg master_write; \n  reg master_write_done; \n  reg next_master_read; \n  reg next_master_read_done; \n  reg [ 2: 0] next_master_state; \n  reg next_master_write; \n  reg next_master_write_done; \n  always @(posedge master_clk or negedge master_reset_n) \n  begin \n  if (master_reset_n == 0) \n  master_read_done <= 0; \n  else if (1) \n  master_read_done <= next_master_read_done; \n  end \n  always @(posedge master_clk or negedge master_reset_n) \n  begin \n  if (master_reset_n == 0) \n  master_write_done <= 0; \n  else if (1) \n  master_write_done <= next_master_write_done; \n  end \n  always @(posedge master_clk or negedge master_reset_n) \n  begin \n  if (master_reset_n == 0) \n  master_read <= 0; \n  else if (1) \n  master_read <= next_master_read; \n  end \n  always @(posedge master_clk or negedge master_reset_n) \n  begin \n  if (master_reset_n == 0) \n  master_write <= 0; \n  else if (1) \n  master_write <= next_master_write; \n  end \n  always @(posedge master_clk or negedge master_reset_n) \n  begin \n  if (master_reset_n == 0) \n  master_state <= 3'b001; \n  else if (1) \n  master_state <= next_master_state; \n  end \n  always @(master_read or master_read_done or master_state or master_waitrequest or master_write or master_write_done or slave_read_request_token or slave_write_request_token) \n  begin \n  case (master_state) \n  3'b001: begin \n  if (slave_read_request_token) \n  begin \n  next_master_state = 3'b010; \n  next_master_read = 1; \n  next_master_write = 0; \n  end \n  else if (slave_write_request_token) \n  begin \n  next_master_state = 3'b100; \n  next_master_read = 0; \n  next_master_write = 1; \n  end \n  else \n  begin \n  next_master_state = master_state; \n  next_master_read = 0; \n  next_master_write = 0; \n  end \n  next_master_read_done = master_read_done; \n  next_master_write_done = master_write_done; \n  end \n  3'b010: begin \n  if (!master_waitrequest) \n  begin \n  next_master_state = 3'b001; \n  next_master_read_done = !master_read_done; \n  next_master_read = 0; \n  end \n  else \n  begin \n  next_master_state = 3'b010; \n  next_master_read_done = master_read_done; \n  next_master_read = master_read; \n  end \n  next_master_write_done = master_write_done; \n  next_master_write = 0; \n  end \n  3'b100: begin \n  if (!master_waitrequest) \n  begin \n  next_master_state = 3'b001; \n  next_master_write = 0; \n  next_master_write_done = !master_write_done; \n  end \n  else \n  begin \n  next_master_state = 3'b100; \n  next_master_write = master_write; \n  next_master_write_done = master_write_done; \n  end \n  next_master_read_done = master_read_done; \n  next_master_read = 0; \n  end \n  default: begin \n  next_master_state = 3'b001; \n  next_master_write = 0; \n  next_master_write_done = master_write_done; \n  next_master_read = 0; \n  next_master_read_done = master_read_done; \n  end \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe given Verilog module is a D flip-flop with load enable functionality. It has an input lden for load enable, input dnxt for next data, output qout for output data, input clk for clock, and input rst_n for reset.\n\nInside the module, there is a register qout_r to store the output data. It is updated based on the load enable and next data inputs when the clock signal rises. Additionally, there is a reset logic to initialize qout_r with all 1s when the reset signal is asserted.\n\nThe module also includes an instantiation of sirv_gnrl_xchecker for assertion checking. The instantiation is conditional on the absence of specific defines.\n\nIn summary, this module implements a D flip-flop with load enable functionality and includes a corresponding assertion checker instantiation.\n\n Module header:\n\nmodule sirv_gnrl_dfflrs # (parameter DW = 32) (input lden,input [DW-1:0] dnxt,output [DW-1:0] qout,input clk,input rst_n);\n [/INST]\n", "output": "reg [DW-1:0] qout_r; \n always @(posedge clk or negedge rst_n) \n begin : DFFLRS_PROC \n  if (rst_n == 1'b0) \n  qout_r <= {DW{1'b1}}; \n  else if (lden == 1'b1) \n  qout_r <= #1 dnxt; \n end \n assign qout = qout_r; \n `ifndef FPGA_SOURCE \n `ifndef DISABLE_SV_ASSERTION \n sirv_gnrl_xchecker # (.DW(1)) sirv_gnrl_xchecker(.i_dat(lden),.clk (clk)); \n `endif \n `endif \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements an ADC frontend with buffer read functionality. It uses a state machine to manage the read and write requests, as well as the buffer data retrieval. It interfaces with 8 instances of adc_deser for parallel processing and an adc_pll for clock management. The module generates the read enable and buffer read requests based on the input read_req and address signals. The state machine transitions based on the read and write requests, and the data is read from the appropriate buffer based on the address and state. The module also manages the busy signal and data read assignments.\n\n Module header:\n\nmodule adc_frontend (input wire clk,input wire reset,output wire adc_clk,input wire write_req,input wire read_req,input wire [31:0] data_write,output reg [31:0] data_read,input wire [25:0] addr,output wire busy,input wire [7:0] adc_fco,input wire [7:0] adc_dco,input wire [7:0] adc_dat_a,input wire [7:0] adc_dat_b,input wire [7:0] adc_dat_c,input wire [7:0] adc_dat_d);\n [/INST]\n", "output": "localparam IDLE = 2'd0, \n  READ_0 = 2'd1, \n  READ_1 = 2'd2; \n reg [7:0] read_enable; \n reg [7:0] buffer_rdreq; \n reg busy_int; \n reg [25:0] addr_int; \n reg [1:0] state; \n wire [7:0] deser_busy; \n wire [7:0] buffer_empty; \n wire [9:0] buffer_data_a[7:0]; \n wire [9:0] buffer_data_b[7:0]; \n wire [9:0] buffer_data_c[7:0]; \n wire [9:0] buffer_data_d[7:0]; \n assign busy = reset | busy_int | write_req | read_req; \n always @( posedge clk ) begin \n  if ( reset ) begin \n  read_enable <= 8'd0; \n  buffer_rdreq <= 8'd0; \n  data_read <= 32'd0; \n  busy_int <= 0; \n  state <= IDLE; \n  end \n  else begin \n  buffer_rdreq <= 8'd0; \n  data_read <= 32'd0; \n  case ( state ) \n  IDLE: begin \n  if ( read_req ) begin \n  busy_int <= 1; \n  state <= READ_0; \n  addr_int <= addr; \n  end \n  else if ( write_req ) begin \n  read_enable <= {8{data_write[0]}}; \n  end \n  end \n  READ_0: begin \n  if ( ~buffer_empty[addr_int[4:2]] ) begin \n  state <= READ_1; \n  buffer_rdreq[addr_int[4:2]] <= 1; \n  end \n  end \n  READ_1: begin \n  state <= IDLE; \n  busy_int <= 0; \n  case ( addr_int[1:0] ) \n  2'b00: begin \n  data_read <= {22'd1, buffer_data_a[addr_int[4:2]]}; \n  end \n  1'b01: begin \n  data_read <= {22'd1, buffer_data_b[addr_int[4:2]]}; \n  end \n  2'b10: begin \n  data_read <= {22'd1, buffer_data_c[addr_int[4:2]]}; \n  end \n  2'b11: begin \n  data_read <= {22'd1, buffer_data_d[addr_int[4:2]]}; \n  end \n  endcase \n  end \n  endcase \n  end \n end \n generate \n  genvar i; \n  for ( i=0; i<8; i=i+1 ) begin: my_loop \n adc_deser adc_deser_inst (.clk ( clk ),.reset ( reset ),.read_enable ( read_enable[i] ),.buffer_rdreq ( buffer_rdreq[i] ),.buffer_empty ( buffer_empty[i] ),.buffer_data_a ( buffer_data_a[i] ),.buffer_data_b ( buffer_data_b[i] ),.buffer_data_c ( buffer_data_c[i] ),.buffer_data_d ( buffer_data_d[i] ),.adc_fco ( adc_fco[i] ),.adc_dco ( adc_dco[i] ),.adc_dat_a ( adc_dat_a[i] ),.adc_dat_b ( adc_dat_b[i] ),.adc_dat_c ( adc_dat_c[i] ),.adc_dat_d ( adc_dat_d[i] )); \n  end \n endgenerate \n adc_pll adc_pll_inst (.areset ( 1'b0 ),.inclk0 ( clk ),.c0 ( adc_clk ),.locked ( )); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module implements a D flip-flop with synchronous reset functionality. The output Q is set to 1 when the reset signal R is low, and it follows the input D when the clock signal C transitions from high to low.\n\n Module header:\n\nmodule \\$_DFF_NN1_ (D, C, R, Q);\n [/INST]\n", "output": "input D, C, R; \n output reg Q; \n always @(negedge C or negedge R) begin \n  if (R == 0) \n  Q <= 1; \n  else \n  Q <= D; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a D-latch with an enable signal. When the enable signal EN matches the polarity defined by EN_POLARITY, the D input is assigned to the output register Q. The width of the D input and Q output is defined by the parameter WIDTH.\n\n Module header:\n\nmodule \\$dlatch (EN, D, Q);\n [/INST]\n", "output": "parameter WIDTH = 0; \n parameter EN_POLARITY = 1'b1; \n input EN; \n input [WIDTH-1:0] D; \n output reg [WIDTH-1:0] Q; \n always @* begin \n  if (EN == EN_POLARITY) \n  Q = D; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, named \"read_signal_breakout,\" breaks out various signals from the input read_command_data_in and provides them as separate outputs. It includes logic to handle different data widths and assigns values to the respective output wires based on the input signal. The module also generates certain output values based on the condition of the input data width. The final output read_command_data_out is a concatenation of the various signals with appropriate padding.\n\n Module header:\n\nmodule read_signal_breakout (read_command_data_in,read_command_data_out,read_address,read_length,read_transmit_channel,read_generate_sop,read_generate_eop,read_park,read_transfer_complete_IRQ_mask,read_burst_count,read_stride,read_sequence_number,read_transmit_error,read_early_done_enable,read_stop,read_sw_reset);\n [/INST]\n", "output": "parameter DATA_WIDTH = 256; \n  input [DATA_WIDTH-1:0] read_command_data_in; \n  output wire [255:0] read_command_data_out; \n  output wire [63:0] read_address; \n  output wire [31:0] read_length; \n  output wire [7:0] read_transmit_channel; \n  output wire read_generate_sop; \n  output wire read_generate_eop; \n  output wire read_park; \n  output wire read_transfer_complete_IRQ_mask; \n  output wire [7:0] read_burst_count; \n  output wire [15:0] read_stride; \n  output wire [15:0] read_sequence_number; \n  output wire [7:0] read_transmit_error; \n  output wire read_early_done_enable; \n  input read_stop; \n  input read_sw_reset; \n  assign read_address[31:0] = read_command_data_in[31:0]; \n  assign read_length = read_command_data_in[95:64]; \n  generate \n  if (DATA_WIDTH == 256) \n  begin \n  assign read_early_done_enable = read_command_data_in[248]; \n  assign read_transmit_error = read_command_data_in[247:240]; \n  assign read_transmit_channel = read_command_data_in[231:224]; \n  assign read_generate_sop = read_command_data_in[232]; \n  assign read_generate_eop = read_command_data_in[233]; \n  assign read_park = read_command_data_in[234]; \n  assign read_transfer_complete_IRQ_mask = read_command_data_in[238]; \n  assign read_burst_count = read_command_data_in[119:112]; \n  assign read_stride = read_command_data_in[143:128]; \n  assign read_sequence_number = read_command_data_in[111:96]; \n  assign read_address[63:32] = read_command_data_in[191:160]; \n  end \n  else \n  begin \n  assign read_early_done_enable = read_command_data_in[120]; \n  assign read_transmit_error = read_command_data_in[119:112]; \n  assign read_transmit_channel = read_command_data_in[103:96]; \n  assign read_generate_sop = read_command_data_in[104]; \n  assign read_generate_eop = read_command_data_in[105]; \n  assign read_park = read_command_data_in[106]; \n  assign read_transfer_complete_IRQ_mask = read_command_data_in[110]; \n  assign read_burst_count = 8'h00; \n  assign read_stride = 16'h0000; \n  assign read_sequence_number = 16'h0000; \n  assign read_address[63:32] = 32'h00000000; \n  end \n  endgenerate \n  assign read_command_data_out = {{115{1'b0}}, \n  read_address[63:32], \n  read_early_done_enable, \n  read_transmit_error, \n  read_stride, \n  read_burst_count, \n  read_sw_reset, \n  read_stop, \n  read_generate_eop, \n  read_generate_sop, \n  read_transmit_channel, \n  read_length, \n  read_address[31:0]}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module `tkr_chr` takes in two 8-bit input signals `inpF` and `inpT`, and has two outputs `outF` and `outT` of type `TKR_OBJ_DECL`. It also includes a string output `str` and a register `i`. The module initializes the output flip-flops `outF` and `outT` to zero. \n\nWithin the `always` block, the module waits for the input signals to be asserted, assigns the input signal to the register `i`, sets the string `str` to the input value, creates a new string object, and sets the output flip-flops `outT` and `outF` accordingly. It then waits for both input signals to be de-asserted and resets the output flip-flops to zero.\n\n Module header:\n\nmodule tkr_chr (inpF, inpT, outF, outT);\n [/INST]\n", "output": "input [7:0] inpF; \n  input [7:0] inpT; \n  output `TKR_OBJ_DECL outF; \n  output `TKR_OBJ_DECL outT; \n  reg `TKR_OBJ_DECL outF; \n  reg `TKR_OBJ_DECL outT; \n  reg `TKR_STR_DECL str; \n  reg [7:0] i; \n  reg sink; \n  initial outF = 0; \n  initial outT = 0; \n  always begin \n  wait ((&(inpT | inpF))); \n  i = inpT; \n  str = 0; \n  str[7:0] = i; \n  outT = tkr_global.new_string (str, 1); \n  outF = ~outT; \n  wait (inpT == 0 & inpF == 0); \n  outT = 0; \n  outF = 0; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a logical AND operation between the input enable signal (en) and its complement (en_), and assigns the result to the output enable signal (oe).\n\n Module header:\n\nmodule fj_xctrl(oe, en,en_);\n [/INST]\n", "output": "output oe; \n input en, en_; \n  assign oe = (en && (~en_)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a clock gating circuit, which generates an output clock signal eclk based on the input clock signal clk and the enable signal en. When CFG_ASIC is defined, it implements an ASIC ICG (Input Clock Gating) using the asic_icg module and a clock gate. Otherwise, it uses a wire en_sl to compute the logical OR between the enable signal en and the test enable signal te. It then uses an oh_lat0 module to generate a delayed version of en_sl as en_sh. Finally, it assigns eclk to the logical AND between clk and en_sh.\n\n Module header:\n\nmodule oh_clockgate (input clk,input te,input en,output eclk);\n [/INST]\n", "output": "`ifdef CFG_ASIC \n asic_icg icg (.en(en),.te(te),.clk(clk),.eclk(eclk)); \n `else \n  wire en_sh; \n  wire en_sl; \n  assign en_sl = en | te; \n oh_lat0 lat0 (.out (en_sh),.in (en_sl),.clk (clk)); \n  assign eclk = clk & en_sh; \n `endif \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module is a JTAG interface for a Cyclone II FPGA, with inputs tms, tck, tdi, ntrst, tdoutap, and tdouser, and outputs tdo, tmsutap, tckutap, tdiutap, shiftuser, clkdruser, updateuser, runidleuser, and usr1user. The initial and always blocks in the Verilog code are empty, indicating that there is no functional behavior defined within them. The module simply provides the interface connections without any specific functionality defined in the provided code.\n\n Module header:\n\nmodule cycloneii_jtag (tms, tck, tdi, ntrst, tdoutap, tdouser, tdo, tmsutap, tckutap, tdiutap, shiftuser, clkdruser, updateuser, runidleuser, usr1user);\n [/INST]\n", "output": "input tms, tck, tdi, ntrst, tdoutap, tdouser; \n  output tdo, tmsutap, tckutap, tdiutap, shiftuser, clkdruser; \n  output updateuser, runidleuser, usr1user; \n  parameter lpm_type = \"cycloneii_jtag\"; \n  initial \n  begin \n  end \n  always @(tms or tck or tdi or ntrst or tdoutap or tdouser) \n  begin \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements an asynchronous counter with configurable initial, limit, and increment values. It also features control outputs for size, result validity, result, full status, and stall status. The counter can be reset, and it has logic to handle full and stall conditions. The module operates based on clock signals and resetn (active low) signals.\n\n Module header:\n\nmodule acl_counter (enable, clock, resetn,i_init,i_limit,i_increment,i_counter_reset,o_size,o_resultvalid,o_result,o_full,o_stall);\n [/INST]\n", "output": "parameter INIT=0; \n parameter LIMIT=65536; \n input logic clock; \n input logic resetn; \n input logic enable; \n input logic [31:0] i_init; \n input logic [31:0] i_limit; \n input logic i_counter_reset; \n input logic [31:0] i_increment; \n output logic [31:0] o_size; \n output logic o_resultvalid; \n output logic [31:0] o_result; \n output logic o_full; \n output logic o_stall; \n reg [31:0] counter; \n assign o_size = counter; \n always@(posedge clock or negedge resetn) \n begin \n  if ( !resetn ) begin \n  o_resultvalid <= 1'b0; \n  counter <= 32'b0; \n  o_result <= 32'b0; \n  o_full <= 1'b0; \n  o_stall <= 1'b0; \n  end \n  else if( i_counter_reset ) begin \n  o_resultvalid <= 1'b1; \n  counter <= i_increment; \n  o_result <= i_init; \n  o_stall <= 1'b0; \n  end \n  else if( o_full ) begin \n  o_full <= 1'b0; \n  end \n  else if( ~o_stall ) begin \n  if (enable) begin \n  if( (counter != 32'b0) && (counter == i_limit) ) begin \n  o_full <= 1'b1; \n  o_stall <= 1'b1; \n  o_resultvalid <= 1'b0; \n  end \n  else begin \n  o_result <= i_init + counter; \n  o_resultvalid <= 1'b1; \n  counter <= counter + i_increment; \n  end \n  end \n  else begin \n  o_resultvalid <= 1'b0; \n  end \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes in various input signals related to video synchronization and processing, and generates address, data, and control signals for an NTSC to ZBT interface. It includes logic to track the video frame, column and row positions, and updates the video data based on the input signals. It also includes logic to generate address and data signals based on the video position and data, and control signals based on the video write enable signal and the swap signal. The module essentially handles the conversion and interfacing of video data between the NTSC and ZBT domains.\n\n Module header:\n\nmodule ntsc_to_zbt(clk, vclk, fvh, dv, din, ntsc_addr, ntsc_data, ntsc_we, sw);\n [/INST]\n", "output": "input clk; \n  input vclk; \n  input [2:0] fvh; \n  input dv; \n  input [7:0] din; \n  output [18:0] ntsc_addr; \n  output [35:0] ntsc_data; \n  output ntsc_we; \n  input sw; \n  parameter COL_START = 10'd30; \n  parameter ROW_START = 10'd30; \n  reg [9:0] col = 0; \n  reg [9:0] row = 0; \n  reg [7:0] vdata = 0; \n  reg vwe; \n  reg old_dv; \n  reg old_frame; \n  reg even_odd; \n  wire frame = fvh[2]; \n  wire frame_edge = frame & ~old_frame; \n  always @ (posedge vclk) \n  begin \n  old_dv <= dv; \n  vwe <= dv && !fvh[2] & ~old_dv; \n  old_frame <= frame; \n  even_odd = frame_edge ? ~even_odd : even_odd; \n  if (!fvh[2]) \n  begin \n  col <= fvh[0] ? COL_START : \n  (!fvh[2] && !fvh[1] && dv && (col < 1024)) ? col + 1 : col; \n  row <= fvh[1] ? ROW_START : \n  (!fvh[2] && fvh[0] && (row < 768)) ? row + 1 : row; \n  vdata <= (dv && !fvh[2]) ? din : vdata; \n  end \n  end \n  reg [9:0] x[1:0],y[1:0]; \n  reg [7:0] data[1:0]; \n  reg we[1:0]; \n  reg eo[1:0]; \n  always @(posedge clk) \n  begin \n  {x[1],x[0]} <= {x[0],col}; \n  {y[1],y[0]} <= {y[0],row}; \n  {data[1],data[0]} <= {data[0],vdata}; \n  {we[1],we[0]} <= {we[0],vwe}; \n  {eo[1],eo[0]} <= {eo[0],even_odd}; \n  end \n  reg old_we; \n  wire we_edge = we[1] & ~old_we; \n  always @(posedge clk) old_we <= we[1]; \n  reg [31:0] mydata; \n  always @(posedge clk) \n  if (we_edge) \n  mydata <= { mydata[23:0], data[1] }; \n  reg [39:0] x_delay; \n  reg [39:0] y_delay; \n  reg [3:0] we_delay; \n  reg [3:0] eo_delay; \n  always @ (posedge clk) \n  begin \n  x_delay <= {x_delay[29:0], x[1]}; \n  y_delay <= {y_delay[29:0], y[1]}; \n  we_delay <= {we_delay[2:0], we[1]}; \n  eo_delay <= {eo_delay[2:0], eo[1]}; \n  end \n  wire [8:0] y_addr = y_delay[38:30]; \n  wire [9:0] x_addr = x_delay[39:30]; \n  wire [18:0] myaddr = {1'b0, y_addr[8:0], eo_delay[3], x_addr[9:2]}; \n  wire [31:0] mydata2 = {data[1],data[1],data[1],data[1]}; \n  wire [18:0] myaddr2 = {1'b0, y_addr[8:0], eo_delay[3], x_addr[7:0]}; \n  reg [18:0] ntsc_addr; \n  reg [35:0] ntsc_data; \n  wire ntsc_we = sw ? we_edge : (we_edge & (x_delay[31:30]==2'b00)); \n  always @(posedge clk) \n  if ( ntsc_we ) \n  begin \n  ntsc_addr <= sw ? myaddr2 : myaddr; \n  ntsc_data <= sw ? {4'b0,mydata2} : {4'b0,mydata}; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module `pmsm` takes in four 4-bit inputs npm0, npm1, npm2, npm3 and has four 4-bit outputs pm0, pm1, pm2, pm3. The module has an internal state machine that normalizes the inputs and stores them in the outputs. The saturating_value is set to 15. The normalization is done based on the comparison of the inputs, and the normalized values are assigned to the outputs. The module also includes a clocked process that updates the outputs based on the normalized inputs, with reset functionality.\n\n Module header:\n\nmodule pmsm (npm0, npm1, npm2, npm3, pm0, pm1, pm2, pm3, clk, reset);\n [/INST]\n", "output": "output [3:0] pm0, pm1, pm2, pm3; \n  input clk, reset; \n  input [3:0] npm0, npm1, npm2, npm3; \n  reg [3:0] pm0, pm1, pm2, pm3; \n  reg [3:0] npm0norm, npm1norm, npm2norm, npm3norm; \n  parameter saturating_value = 4'd15; \n  always @ (npm0 or npm1 or npm2 or npm3) \n  begin \n  if ((npm0 <= npm1)&&(npm0 <= npm2)&&(npm0 <= npm3)) \n  begin \n  npm0norm <= 0; \n  npm1norm <= npm1-npm0; \n  npm2norm <= npm2-npm0; \n  npm3norm <= npm3-npm0; \n  end \n  else if ((npm1 <= npm0)&&(npm1 <= npm2)&&(npm1 <= npm3)) \n  begin \n  npm0norm <= npm0-npm1; \n  npm1norm <= 0; \n  npm2norm <= npm2-npm1; \n  npm3norm <= npm3-npm1; \n  end \n  else if ((npm2 <= npm0)&&(npm2 <= npm1)&&(npm2 <= npm3)) \n  begin \n  npm0norm <= npm0-npm2; \n  npm1norm <= npm1-npm2; \n  npm2norm <= 0; \n  npm3norm <= npm3-npm2; \n  end \n  else if ((npm3 <= npm0)&&(npm3 <= npm1)&&(npm3 <= npm2)) \n  begin \n  npm0norm <= npm0-npm3; \n  npm1norm <= npm1-npm3; \n  npm2norm <= npm2-npm3; \n  npm3norm <= 0; \n  end \n  end \n  always @ (posedge clk) \n  begin \n  if (reset) \n  begin \n  pm0 <= 4'd0; \n  pm1 <= saturating_value; \n  pm2 <= saturating_value; \n  pm3 <= saturating_value; \n  end \n  else \n  begin \n  pm0 <= npm0norm; \n  pm1 <= npm1norm; \n  pm2 <= npm2norm; \n  pm3 <= npm3norm; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module generates figures on a video display based on input coordinates and control signals. It defines the coordinates of three different boxes and sets their RGB colors. The module also determines if the input coordinates are within the boundaries of each box, and if so, selects the corresponding box's RGB value as the output color. If no boxes are selected, the output color is set to black. Additionally, it outputs a signal indicating if any of the boxes are currently being displayed on the screen.\n\n Module header:\n\nmodule generador_figuras (input wire video_on,input wire [9:0] pixel_x, pixel_y,output wire graph_on,output reg [7:0] fig_RGB);\n [/INST]\n", "output": "localparam MAX_X = 640; \n localparam MAX_Y = 480; \n localparam BOX_H_XL = 160; \n localparam BOX_H_XR = 479; \n localparam BOX_H_YT = 64; \n localparam BOX_H_YB = 255; \n localparam BOX_F_XL = 48; \n localparam BOX_F_XR = 303; \n localparam BOX_F_YT = 352; \n localparam BOX_F_YB = 447; \n localparam BOX_T_XL = 336; \n localparam BOX_T_XR = 591; \n localparam BOX_T_YT = 352; \n localparam BOX_T_YB = 447; \n wire BOX_H_on, BOX_F_on, BOX_T_on; \n wire [7:0] BOX_H_RGB, BOX_F_RGB, BOX_T_RGB; \n assign BOX_H_on = (BOX_H_XL<=pixel_x)&&(pixel_x<=BOX_H_XR) \n  &&(BOX_H_YT<=pixel_y)&&(pixel_y<=BOX_H_YB); \n assign BOX_H_RGB = 8'h1E; \n assign BOX_F_on = (BOX_F_XL<=pixel_x)&&(pixel_x<=BOX_F_XR) \n  &&(BOX_F_YT<=pixel_y)&&(pixel_y<=BOX_F_YB); \n assign BOX_F_RGB = 8'h1E; \n assign BOX_T_on = (BOX_T_XL<=pixel_x)&&(pixel_x<=BOX_T_XR) \n  &&(BOX_T_YT<=pixel_y)&&(pixel_y<=BOX_T_YB); \n assign BOX_T_RGB = 8'h1E; \n always @* \n begin \n  if(~video_on) \n  fig_RGB = 8'b0; \n  else \n  if (BOX_H_on) fig_RGB = BOX_H_RGB; \n  else if (BOX_F_on) fig_RGB = BOX_F_RGB; \n  else if (BOX_T_on) fig_RGB = BOX_T_RGB; \n  else fig_RGB = 8'b0; \n end \n assign graph_on = BOX_H_on | BOX_F_on | BOX_T_on; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module is a binary to binary-coded decimal (BCD) converter. It takes an input binary number of width IN_BITS and converts it to a BCD output of width OUT_BITS. It uses a generate block to create add3gt4_n modules for adding 3-bit binary numbers to the BCD output. The module effectively performs the conversion in stages, with each stage adding a 3-bit binary number to the BCD output. The final BCD output is assigned to the bcd_number output.\n\n Module header:\n\nmodule bin2bcd #(parameter IN_BITS = 8,parameter OUT_BITS = 10) (input wire [IN_BITS-1:0] bin_number,output wire [OUT_BITS-1:0] bcd_number);\n [/INST]\n", "output": "genvar bits_shifted; \n generate \n for (bits_shifted = 3; bits_shifted < IN_BITS; bits_shifted = bits_shifted + 1) begin : gen \n  wire [IN_BITS + bits_shifted / 3 - 1 : 0] out_wires; \n  if(bits_shifted == 3) begin \n add3gt4_n #(bits_shifted / 3) add3n({1'b0, bin_number[IN_BITS - 1 : IN_BITS - 3]},out_wires[IN_BITS : IN_BITS - 3]); \n  assign out_wires[IN_BITS - 4: 0] = bin_number[IN_BITS - 4:0]; \n  end else if(bits_shifted % 3 == 0) begin \n add3gt4_n #(bits_shifted / 3) add3n({1'b0, gen[bits_shifted - 1].out_wires[IN_BITS + (bits_shifted - 1) / 3 - 1 : IN_BITS - (bits_shifted / 3) * 3]},out_wires[IN_BITS + bits_shifted / 3 - 1 : IN_BITS - (bits_shifted / 3) * 3]); \n  assign out_wires[IN_BITS - (bits_shifted / 3) * 3 - 1: 0] = bin_number[IN_BITS - (bits_shifted / 3) * 3 - 1:0]; \n  end else begin \n add3gt4_n #(bits_shifted / 3) add3n({gen[bits_shifted - 1].out_wires[IN_BITS + bits_shifted / 3 - 1 - bits_shifted % 3 : IN_BITS - (bits_shifted / 3) * 3 - bits_shifted % 3]},out_wires[IN_BITS + bits_shifted / 3 - 1 - bits_shifted % 3 : IN_BITS - (bits_shifted / 3) * 3 - bits_shifted % 3]); \n  assign out_wires[IN_BITS + bits_shifted / 3 - 1: IN_BITS + bits_shifted / 3 - bits_shifted % 3] = gen[bits_shifted - 1].out_wires[IN_BITS + bits_shifted / 3 - 1 : IN_BITS + bits_shifted / 3 - bits_shifted % 3]; \n  assign out_wires[IN_BITS - (bits_shifted / 3) * 3 - bits_shifted % 3 - 1: 0] = bin_number[IN_BITS - (bits_shifted / 3) * 3 - bits_shifted % 3 - 1:0]; \n  end \n end \n assign bcd_number = gen[IN_BITS - 1].out_wires; \n endgenerate \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, `lo_adc`, is a control module for an analog-to-digital converter (ADC) interface. It includes power control signals, clock generation, shift register operations, and frame generation for the Serial Peripheral Interface (SPI) communication protocol. \n\nThe module handles power output enables, clock generation, and shift register operations based on the input clock signal `pck0`, ADC data `adc_d`, divisor `divisor`, and LF field `lf_field`. \n\nThe module generates the ADC clock signal, controls the shift register for the SPI data input, and generates the frame, data, and clock signals for the SPI communication based on the input signals and internal state.\n\nThe internal `to_arm_shiftreg` and `pck_divider` registers are used to control the shift register and generate clock signals, respectively, based on the input signals and the internal clock state.\n\nThe module also includes conditional logic to handle frame generation and shift register operations.\n\n Module header:\n\nmodule lo_adc(pck0,pwr_lo, pwr_hi, pwr_oe1, pwr_oe2, pwr_oe3, pwr_oe4,adc_d, adc_clk,ssp_frame, ssp_din, ssp_dout, ssp_clk,dbg, divisor,lf_field);\n [/INST]\n", "output": "input pck0; \n  output pwr_lo, pwr_hi, pwr_oe1, pwr_oe2, pwr_oe3, pwr_oe4; \n  input [7:0] adc_d; \n  output adc_clk; \n  input ssp_dout; \n  output ssp_frame, ssp_din, ssp_clk; \n  output dbg; \n  input [7:0] divisor; \n  input lf_field; \n reg [7:0] to_arm_shiftreg; \n reg [7:0] pck_divider; \n reg clk_state; \n wire tag_modulation = ssp_dout & !lf_field; \n wire reader_modulation = !ssp_dout & lf_field & clk_state; \n assign pwr_oe1 = 1'b0; \n assign pwr_hi = 1'b0; \n assign pwr_lo = reader_modulation; \n assign pwr_oe2 = 1'b0; \n assign pwr_oe3 = tag_modulation; \n assign pwr_oe4 = 1'b0; \n assign dbg = adc_clk; \n assign adc_clk = ~clk_state; \n assign ssp_din = to_arm_shiftreg[7] && !clk_state; \n assign ssp_clk = pck0; \n assign ssp_frame = (pck_divider[7:3] == 5'd1) && !clk_state; \n always @(posedge pck0) \n begin \n  if (pck_divider == divisor[7:0]) \n  begin \n  pck_divider <= 8'd0; \n  clk_state = !clk_state; \n  end \n  else \n  begin \n  pck_divider <= pck_divider + 1; \n  end \n end \n always @(posedge pck0) \n begin \n  if ((pck_divider == 8'd7) && !clk_state) \n  to_arm_shiftreg <= adc_d; \n  else begin \n  to_arm_shiftreg[7:1] <= to_arm_shiftreg[6:0]; \n  to_arm_shiftreg[0] <= 1'b0; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a signed division circuit. It takes clock and enable signals, as well as input data z and d. The module calculates the quotient q, the remainder s, and provides flags div0 and ovf. The module includes registers and wires to manage the input and output signals. The module instantiates another module, div_uu, to perform the actual division calculation. The module uses various conditions and assignments based on the input signals to perform the division and manage the output signals.\n\n Module header:\n\nmodule div_su(clk, ena, z, d, q, s, div0, ovf);\n [/INST]\n", "output": "parameter z_width = 16; \n  parameter d_width = z_width /2; \n  input clk; \n  input ena; \n  input [z_width-1:0] z; \n  input [d_width-1:0] d; \n  output [d_width :0] q; \n  output [d_width-1:0] s; \n  output div0; \n  output ovf; \n  reg [d_width :0] q; \n  reg [d_width-1:0] s; \n  reg div0; \n  reg ovf; \n  reg [z_width -1:0] iz; \n  reg [d_width -1:0] id; \n  reg [d_width +1:0] spipe; \n  wire [d_width -1:0] iq, is; \n  wire idiv0, iovf; \n  always @(posedge clk) \n  if (ena) \n  id <= #1 d; \n  always @(posedge clk) \n  if (ena) \n  if (z[z_width-1]) \n  iz <= #1 ~z +1'h1; \n  else \n  iz <= #1 z; \n  integer n; \n  always @(posedge clk) \n  if(ena) \n  begin \n  spipe[0] <= #1 z[z_width-1]; \n  for(n=1; n <= d_width+1; n=n+1) \n  spipe[n] <= #1 spipe[n-1]; \n  end \n  div_uu #(z_width, d_width) \n divider (.clk(clk),.ena(ena),.z(iz),.d(id),.q(iq),.s(is),.div0(idiv0),.ovf(iovf)); \n  always @(posedge clk) \n  if(ena) \n  if(spipe[d_width+1]) \n  begin \n  q <= #1 (~iq) + 1'h1; \n  s <= #1 (~is) + 1'h1; \n  end \n  else \n  begin \n  q <= #1 {1'b0, iq}; \n  s <= #1 {1'b0, is}; \n  end \n  always @(posedge clk) \n  if(ena) \n  begin \n  div0 <= #1 idiv0; \n  ovf <= #1 iovf; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, \"True2Comp\", converts a two's complement binary number into its one's complement representation. It takes in a binary input \"true\" and produces the one's complement representation in the \"complement\" output. The module is parameterized by the number of data channels and the width of each data channel. It uses a generate block to loop through the data channels and perform the conversion for each channel. The conversion is done by checking the most significant bit of each channel and either preserving the value as is or performing a bitwise complement operation.\n\n Module header:\n\nmodule True2Comp(true,complement);\n [/INST]\n", "output": "parameter data_channel = 1; \n  parameter data_width = 17; \n  input[data_channel * data_width - 1 : 0] true; \n  output[data_channel * data_width - 1 : 0] complement; \n  genvar i; \n  generate \n  `define h (i + 1) * data_width - 1 \n  `define l i * data_width \n  for (i = 0; i < data_channel; i = i + 1) begin \n  assign complement[`h : `l] = true[`h] == 0 ? \n  true[`h : `l] : {1'b1, ~true[`h - 1 : `l] + 1}; \n  end \n  `undef h \n  `undef l \n  endgenerate \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a floating-point adder/subtractor with an alternate priority encoder for 28-bit data input. The priority encoder 33 and priority encoder 34 are used to generate the 2-bit output q. The q output is a combination of the outputs of the priority encoders, wire_altpriority_encoder33_q, wire_altpriority_encoder33_zero, and wire_altpriority_encoder34_q based on specific conditions as indicated in the assign statement.\n\n Module header:\n\nmodule float_add_sub_altpriority_encoder_q28 (data,q) ;\n [/INST]\n", "output": "input [3:0] data; \n  output [1:0] q; \n  wire [0:0] wire_altpriority_encoder33_q; \n  wire wire_altpriority_encoder33_zero; \n  wire [0:0] wire_altpriority_encoder34_q; \n  float_add_sub_altpriority_encoder_nh8 altpriority_encoder33 \n (.data(data[1:0]),.q(wire_altpriority_encoder33_q),.zero(wire_altpriority_encoder33_zero)); \n  float_add_sub_altpriority_encoder_n28 altpriority_encoder34 \n (.data(data[3:2]),.q(wire_altpriority_encoder34_q)); \n  assign \n  q = {wire_altpriority_encoder33_zero, ((wire_altpriority_encoder33_zero & wire_altpriority_encoder34_q) | ((~ wire_altpriority_encoder33_zero) & wire_altpriority_encoder33_q))}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module `sync_data` synchronizes the input data `in_data` to the output clock domain `out_clk`. If the asynchronous clock parameter `ASYNC_CLK` is set, the module uses two flip-flops to synchronize the input and output clock domains. Otherwise, it directly assigns the input data to the output data. The synchronization is triggered by the rising edge of the input clock and output clock. The module also toggles a control signal based on the input clock and output clock, and stores the input data in a holding register to be synchronized to the output clock domain.\n\n Module header:\n\nmodule sync_data #(parameter NUM_OF_BITS = 1,parameter ASYNC_CLK = 1) (input in_clk,input [NUM_OF_BITS-1:0] in_data,input out_clk,output reg [NUM_OF_BITS-1:0] out_data);\n [/INST]\n", "output": "generate \n if (ASYNC_CLK == 1) begin \n wire out_toggle; \n wire in_toggle; \n reg out_toggle_d1 = 1'b0; \n reg in_toggle_d1 = 1'b0; \n reg [NUM_OF_BITS-1:0] cdc_hold; \n sync_bits i_sync_out (.in(in_toggle_d1),.out_clk(out_clk),.out_resetn(1'b1),.out(out_toggle)); \n sync_bits i_sync_in (.in(out_toggle_d1),.out_clk(in_clk),.out_resetn(1'b1),.out(in_toggle)); \n wire in_load = in_toggle == in_toggle_d1; \n wire out_load = out_toggle ^ out_toggle_d1; \n always @(posedge in_clk) begin \n  if (in_load == 1'b1) begin \n  cdc_hold <= in_data; \n  in_toggle_d1 <= ~in_toggle_d1; \n  end \n end \n always @(posedge out_clk) begin \n  if (out_load == 1'b1) begin \n  out_data <= cdc_hold; \n  end \n  out_toggle_d1 <= out_toggle; \n end \n end else begin \n  always @(*) begin \n  out_data <= in_data; \n  end \n end \n endgenerate \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a memory with 64K 16-bit words. It has input ports for address, write enable, clock, byte enable, and data input, as well as an output port for data output. The memory uses a 64K\u00d716 memory array and performs read and write operations based on the inputs. When a write operation is enabled, the module writes the data input to the specified memory address, considering byte enable and word alignment. During a write operation, it also displays the memory address and the value being stored. The module performs these operations on the positive edge of the clock signal.\n\n Module header:\n\nmodule memory (input wire [15:0] addr,input wire we,input wire clk,input wire bytew,input wire [15:0] d_in,output wire [15:0] d_out);\n [/INST]\n", "output": "reg [15:0] memory [64*512-1:0]; \n  wire [15:0] word = memory [addr[15:1]]; \n  assign d_out = addr[0] ? \n  (word >> 8) : \n  word; \n  always @(posedge clk) begin \n  if (we == 1) begin \n  if (bytew) begin \n  if (addr[1]) begin \n  memory [addr[15:1]] = { d_in[7:0], word[7:0] }; \n  $display (\"(%0d) store %h := %h\", $time, {addr[15:1], 1'b0}, { d_in[7:0], word[7:0] }); \n  end else begin \n  memory [addr[15:1]] = { word[15:8], d_in[7:0] }; \n  $display (\"(%0d) store %h := %h\", $time, {addr[15:1], 1'b0}, { word[15:8], d_in[7:0] }); \n  end \n  end else begin \n  memory [addr[15:1]] = d_in; \n  $display (\"(%0d) store %h := %h\", $time, {addr[15:1], 1'b0}, d_in); \n  end \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module serves as a backpressure adapter for a master 0 channel. It assigns input and output signals to enable communication between a master and a peripheral. It also includes logic to handle channel assignments and ensure proper data flow. When the input channel is greater than 0, the output valid signal is set to 0 to prevent data transmission.\n\n Module header:\n\nmodule master_0_b2p_adapter (input clk,input reset_n,output reg in_ready,input in_valid,input [ 7: 0] in_data,input [ 7: 0] in_channel,input in_startofpacket,input in_endofpacket,input out_ready,output reg out_valid,output reg [ 7: 0] out_data,output reg out_startofpacket,output reg out_endofpacket);\n [/INST]\n", "output": "reg out_channel; \n  always @* begin \n  in_ready = out_ready; \n  out_valid = in_valid; \n  out_data = in_data; \n  out_startofpacket = in_startofpacket; \n  out_endofpacket = in_endofpacket; \n  out_channel = in_channel ; \n  if (in_channel > 0) begin \n  out_valid = 0; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a clock generator that produces a clock signal zclk_out based on various input conditions. It utilizes the input clock signal fclk and control signals like rfsh_n, turbo, external_port, iorq_n, m1_n, cbeg, and pre_cend to determine the output clock signal. The clock generation involves handling of stall conditions, setting of zpos and zneg signals based on various conditions, and updating the internal state of the module. It also incorporates simulation-specific initializations when compiled for simulation.\n\n Module header:\n\nmodule zclock(input fclk,input rst_n,input zclk,input rfsh_n,output reg zclk_out,output reg zpos,output reg zneg,input wire zclk_stall,input [1:0] turbo,output reg [1:0] int_turbo,input wire external_port,input wire iorq_n,input wire m1_n,input cbeg,input pre_cend);\n [/INST]\n", "output": "reg precend_cnt; \n  wire h_precend_1; \n  wire h_precend_2; \n  reg [2:0] zcount; \n  reg old_rfsh_n; \n  wire stall; \n  reg clk14_src; \n  wire pre_zpos_35, \n  pre_zneg_35; \n  wire pre_zpos_70, \n  pre_zneg_70; \n  wire pre_zpos_140, \n  pre_zneg_140; \n `ifdef SIMULATE \n  initial \n  begin \n  precend_cnt = 1'b0; \n  int_turbo = 2'b00; \n  old_rfsh_n = 1'b1; \n  clk14_src = 1'b0; \n  zclk_out = 1'b0; \n  end \n `endif \n  always @(posedge fclk) if(zpos) \n  begin \n  old_rfsh_n <= rfsh_n; \n  if( old_rfsh_n && !rfsh_n ) \n  int_turbo <= turbo; \n  end \n  reg [3:0] io_wait_cnt; \n  reg io_wait; \n  wire io; \n  reg io_r; \n  assign io = (~iorq_n) & m1_n & external_port; \n  always @(posedge fclk) \n  if( zpos ) \n  io_r <= io; \n  always @(posedge fclk, negedge rst_n) \n  if( ~rst_n ) \n  io_wait_cnt <= 4'd0; \n  else if( io && (!io_r) && zpos && int_turbo[1] ) \n  io_wait_cnt[3] <= 1'b1; \n  else if( io_wait_cnt[3] ) \n  io_wait_cnt <= io_wait_cnt + 4'd1; \n  always @(posedge fclk) \n  case( io_wait_cnt ) \n  4'b1000: io_wait <= 1'b1; \n  4'b1001: io_wait <= 1'b1; \n  4'b1010: io_wait <= 1'b1; \n  4'b1011: io_wait <= 1'b1; \n  4'b1100: io_wait <= 1'b1; \n  4'b1101: io_wait <= 1'b0; \n  4'b1110: io_wait <= 1'b1; \n  4'b1111: io_wait <= 1'b0; \n  default: io_wait <= 1'b0; \n  endcase \n  assign stall = zclk_stall | io_wait; \n  always @(posedge fclk) \n  if( !stall ) \n  clk14_src <= ~clk14_src; \n  assign pre_zpos_140 = clk14_src ; \n  assign pre_zneg_140 = (~clk14_src); \n  always @(posedge fclk) if( pre_cend ) \n  precend_cnt <= ~precend_cnt; \n  assign h_precend_1 = precend_cnt && pre_cend; \n  assign h_precend_2 = !precend_cnt && pre_cend; \n  assign pre_zpos_35 = h_precend_2; \n  assign pre_zneg_35 = h_precend_1; \n  assign pre_zpos_70 = pre_cend; \n  assign pre_zneg_70 = cbeg; \n  assign pre_zpos = int_turbo[1] ? pre_zpos_140 : ( int_turbo[0] ? pre_zpos_70 : pre_zpos_35 ); \n  assign pre_zneg = int_turbo[1] ? pre_zneg_140 : ( int_turbo[0] ? pre_zneg_70 : pre_zneg_35 ); \n  always @(posedge fclk) \n  begin \n  zpos <= (~stall) & pre_zpos & zclk_out; \n  end \n  always @(posedge fclk) \n  begin \n  zneg <= (~stall) & pre_zneg & (~zclk_out); \n  end \n  always @(negedge fclk) \n  begin \n  if( zpos ) \n  zclk_out <= 1'b0; \n  if( zneg ) \n  zclk_out <= 1'b1; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, sirv_aon_porrst, has a single output, porrst_n. When synthesized for an FPGA, it assigns the value 1'b1 to porrst_n. When not synthesized for an FPGA, it also assigns the value 1'b1 to porrst_n.\n\n Module header:\n\nmodule sirv_aon_porrst(output porrst_n);\n [/INST]\n", "output": "`ifdef FPGA_SOURCE \n  assign porrst_n = 1'b1; \n  `else \n  assign porrst_n = 1'b1; \n  `endif \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module acts as an arbiter to select one of the input sources l_rom, u_rom, ram, eram, pio8255, io, or fdc based on their respective enable signals l_rom_e, u_rom_e, ram_e, u_ram_e, pio8255_e, io_e, and fdc_e. The selected input is then assigned to the output D. If none of the enable signals are asserted, the default value of 255 is assigned to D.\n\n Module header:\n\nmodule dat_i_arbiter(input wire clock_i,output wire [7:0] D,input [7:0] l_rom,input l_rom_e,input [7:0] u_rom,input u_rom_e,input [7:0] ram,input ram_e,input [7:0] eram,input u_ram_e,input [7:0] pio8255,input pio8255_e,input [7:0] io,input io_e,input [7:0] fdc,input fdc_e);\n [/INST]\n", "output": "assign D = (l_rom_e) ? l_rom : \n  (u_rom_e) ? u_rom : \n  (u_ram_e) ? eram : \n  (ram_e) ? ram : \n  (pio8255_e) ? pio8255 : \n  (io_e) ? io : \n  (fdc_e) ? fdc : \n  8'd255; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module simply assigns the output q to a constant value of 1.\n\n Module header:\n\nmodule vfebcfe_vb2eccd (output q);\n [/INST]\n", "output": "assign q = 1'b1; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module has a single output wire \"out\" which is continuously assigned the value 1.\n\n Module header:\n\nmodule GeneratorUnsigned1(out);\n [/INST]\n", "output": "output wire out; \n  assign out = 1; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module defines a multiplexer (mux) with parameters for width, size, and pipeline depth. It has inputs for data, select signal, clock, asynchronous clear, and clock enable. The output is the result of the mux operation. The module includes error checking for parameter values, initialization of internal registers, and logic to handle data and control signals. The module also supports pipelining with configurable depth, and the output result is determined based on the pipeline size.\n\n Module header:\n\nmodule lpm_mux (data,sel,clock,aclr,clken,result);\n [/INST]\n", "output": "parameter lpm_width = 1; \n  parameter lpm_size = 2; \n  parameter lpm_widths = 1; \n  parameter lpm_pipeline = 0; \n  parameter lpm_type = \"lpm_mux\"; \n  parameter lpm_hint = \"UNUSED\"; \n  input [(lpm_size * lpm_width)-1:0] data; \n  input [lpm_widths-1:0] sel; \n  input clock; \n  input aclr; \n  input clken; \n  output [lpm_width-1:0] result; \n  reg [lpm_width-1:0] result_pipe [lpm_pipeline+1:0]; \n  reg [lpm_width-1:0] tmp_result; \n  integer i; \n  integer pipe_ptr; \n  tri0 aclr; \n  tri0 clock; \n  tri1 clken; \n  wire i_aclr; \n  wire i_clock; \n  wire i_clken; \n  buf (i_aclr, aclr); \n  buf (i_clock, clock); \n  buf (i_clken, clken); \n  initial \n  begin \n  if (lpm_width <= 0) \n  begin \n  $display(\"Value of lpm_width parameter must be greater than 0 (ERROR)\"); \n  $display(\"Time: %0t Instance: %m\", $time); \n  $finish; \n  end \n  if (lpm_size <= 1) \n  begin \n  $display(\"Value of lpm_size parameter must be greater than 1 (ERROR)\"); \n  $display(\"Time: %0t Instance: %m\", $time); \n  $finish; \n  end \n  if (lpm_widths <= 0) \n  begin \n  $display(\"Value of lpm_widths parameter must be greater than 0 (ERROR)\"); \n  $display(\"Time: %0t Instance: %m\", $time); \n  $finish; \n  end \n  if (lpm_pipeline < 0) \n  begin \n  $display(\"Value of lpm_pipeline parameter must NOT less than 0 (ERROR)\"); \n  $display(\"Time: %0t Instance: %m\", $time); \n  $finish; \n  end \n  pipe_ptr = 0; \n  end \n  always @(data or sel) \n  begin \n  tmp_result = 0; \n  if (sel < lpm_size) \n  begin \n  for (i = 0; i < lpm_width; i = i + 1) \n  tmp_result[i] = data[(sel * lpm_width) + i]; \n  end \n  else \n  tmp_result = {lpm_width{1'bx}}; \n  end \n  always @(posedge i_clock or posedge i_aclr) \n  begin \n  if (i_aclr) \n  begin \n  for (i = 0; i <= (lpm_pipeline+1); i = i + 1) \n  result_pipe[i] <= 1'b0; \n  pipe_ptr <= 0; \n  end \n  else if (i_clken == 1'b1) \n  begin \n  result_pipe[pipe_ptr] <= tmp_result; \n  if (lpm_pipeline > 1) \n  pipe_ptr <= (pipe_ptr + 1) % lpm_pipeline; \n  end \n  end \n  assign result = (lpm_pipeline > 0) ? result_pipe[pipe_ptr] : tmp_result; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module is a full adder calculator with a parameterized width. It takes two input vectors A and B, along with a carry-in signal CIN, and computes the sum RES and carry-out signal COUT. The input vectors A and B are sign-extended to include a carry-in bit. The sum and carry-out are computed using the extended input vectors and the carry-in signal.\n\n Module header:\n\nmodule Calculator_Full_Adder #(parameter WIDTH = 4) (input [WIDTH-1:0] A,input [WIDTH-1:0] B,input CIN,output [WIDTH-1:0] RES,output COUT);\n [/INST]\n", "output": "wire signed [WIDTH:0] op_a; \n  wire signed [WIDTH:0] op_b; \n  assign op_a = { A[WIDTH-1], A }; \n  assign op_b = { B[WIDTH-1], B }; \n  assign { COUT, RES } = op_a + op_b + CIN; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes a 5-bit input and based on the value of the input and the enable signal, assigns a 32-bit output. If the enable signal is low, the output is set to zero. When the enable signal is high, the module uses a case statement to assign a specific value to the output based on the input value. Each input value has a corresponding assignment for the output.\n\n Module header:\n\nmodule f6_test (input [4:0] in, input enable, output reg [31:0] out);\n [/INST]\n", "output": "always @(in or enable) \n  if(!enable) \n  out = 32'b00000000000000000000000000000000; \n  else begin \n  case (in) \n  5'b00000 : out = 32'b00000000000000000000000000000001; \n  5'b00001 : out = 32'b00000000000000000000000000000010; \n  5'b00010 : out = 32'b00000000000000000000000000000100; \n  5'b00011 : out = 32'b00000000000000000000000000001000; \n  5'b00100 : out = 32'b00000000000000000000000000010000; \n  5'b00101 : out = 32'b00000000000000000000000000100000; \n  5'b00110 : out = 32'b00000000000000000000000001000000; \n  5'b00111 : out = 32'b00000000000000000000000010000000; \n  5'b01000 : out = 32'b00000000000000000000000100000000; \n  5'b01001 : out = 32'b00000000000000000000001000000000; \n  5'b01010 : out = 32'b00000000000000000000010000000000; \n  5'b01011 : out = 32'b00000000000000000000100000000000; \n  5'b01100 : out = 32'b00000000000000000001000000000000; \n  5'b01101 : out = 32'b00000000000000000010000000000000; \n  5'b01110 : out = 32'b00000000000000000100000000000000; \n  5'b01111 : out = 32'b00000000000000001000000000000000; \n  5'b10000 : out = 32'b00000000000000010000000000000000; \n  5'b10001 : out = 32'b00000000000000100000000000000000; \n  5'b10010 : out = 32'b00000000000001000000000000000000; \n  5'b10011 : out = 32'b00000000000010000000000000000000; \n  5'b10100 : out = 32'b00000000000100000000000000000000; \n  5'b10101 : out = 32'b00000000001000000000000000000000; \n  5'b10110 : out = 32'b00000000010000000000000000000000; \n  5'b10111 : out = 32'b00000000100000000000000000000000; \n  5'b11000 : out = 32'b00000001000000000000000000000000; \n  5'b11001 : out = 32'b00000010000000000000000000000000; \n  5'b11010 : out = 32'b00000100000000000000000000000000; \n  5'b11011 : out = 32'b00001000000000000000000000000000; \n  5'b11100 : out = 32'b00010000000000000000000000000000; \n  5'b11101 : out = 32'b00100000000000000000000000000000; \n  5'b11110 : out = 32'b01000000000000000000000000000000; \n  5'b11111 : out = 32'b10000000000000000000000000000000; \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a pipeline register that forwards input signals to output signals on the rising edge of the clock. It checks for the absence of the stallm signal and then forwards the corresponding input signals to the output signals for the next stage. The input signals include control signals for memory writes, register writes, and ALU operations. The output signals include the same control signals but for the next pipeline stage.\n\n Module header:\n\nmodule pipeem(clk,writerege,writerege2,aluoute,aluoute2,writedatae,writedatae2,memwritee,memwritee2,regwritee,regwritee2,memtorege,memtorege2,regwritem,regwritem2,memtoregm,memtoregm2,memwritem,memwritem2,writeregm,writeregm2,aluoutm,aluoutm2,writedatam,writedatam2,stallm,stallm2);\n [/INST]\n", "output": "input clk; \n  input [4:0] writerege,writerege2; \n  input [31:0] aluoute,writedatae,aluoute2,writedatae2; \n  input memwritee,memwritee2,regwritee,regwritee2,memtorege,memtorege2,stallm,stallm2; \n  output reg regwritem,memtoregm,memwritem,regwritem2,memtoregm2,memwritem2; \n  output reg [4:0] writeregm, writeregm2; \n  output reg [31:0] aluoutm,writedatam,aluoutm2,writedatam2; \n  always @ (posedge clk) begin \n  if (!stallm) begin \n  regwritem<=regwritee; \n  memtoregm<=memtorege; \n  memwritem<=memwritee; \n  aluoutm<=aluoute; \n  writedatam<=writedatae; \n  writeregm<=writerege; \n  regwritem2<=regwritee2; \n  memtoregm2<=memtorege2; \n  memwritem2<=memwritee2; \n  aluoutm2<=aluoute2; \n  writedatam2<=writedatae2; \n  writeregm2<=writerege2; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a counter that increments on each clock cycle. It has a configurable maximum value (SEG) at which it resets. The counter is enabled when the ena signal is asserted, which is based on the q, ov, and start signals. The output p reflects the value of q, and the output tic reflects the ov signal. The module also contains a heartbeat counter that increments on each clock cycle and resets at a specified maximum value.\n\n Module header:\n\nmodule v56885a_v3140f5 #(parameter SEG = 0) (input clk,input start,output p,output tic);\n [/INST]\n", "output": "localparam M = 12000000; \n  localparam N = $clog2(M); \n  wire rst_heart; \n  wire ov_heart; \n  wire ena; \n  wire tic_heart; \n  reg [N-1:0] heart=0; \n  always @(posedge clk) \n  if (rst_heart) \n  heart <= 0; \n  else \n  heart <= heart + 1; \n  assign ov_heart = (heart == M-1); \n  assign tic_heart = ov_heart; \n  assign rst_heart =~ena | ov_heart; \n  reg [7:0] counter = 0; \n  wire ov; \n  wire rst; \n  always @(posedge clk) \n  if (rst) \n  counter <= 0; \n  else \n  if (tic_heart) \n  counter <= counter + 1; \n  assign ov = (counter == SEG); \n  reg q = 0; \n  always @(posedge clk) \n  if (start) \n  q <= 1'b1; \n  else if (rst) \n  q<=1'b0; \n  assign rst = ~q | ov | start; \n  assign ena = ~rst; \n  assign p = q; \n  assign tic = ov; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is for controlling a WS2812B LED strip. It uses a counter to generate pulses for data transmission. When the module receives bitstream data, it sets the ws2812b_data signal to control the LED strip's data line. The module uses different cycle counts for short and long pulses, as well as for resetting the LED strip. The bitstream is read and shifted based on the bitnum and ws2812b_data signals, while also managing the idle state. The debug_info output provides information about the internal state of the module.\n\n Module header:\n\nmodule ws2812b_out_module (input clk,input resetn,input bitstream_available,input [23:0] bitstream,output reg bitstream_read,output reg ws2812b_data,output reg [3:0] debug_info);\n [/INST]\n", "output": "parameter CYCLES_SHORT = 3; \n  parameter CYCLES_LONG = 5; \n  parameter CYCLES_RET = 450; \n localparam CYCLES_WIDTH = $clog2(CYCLES_RET > CYCLES_LONG ? CYCLES_RET: CYCLES_LONG); \n  reg [4:0] bitnum = 0; \n  reg [CYCLES_WIDTH-1:0] counter = 0; \n  reg [23:0] bitstream_int; \n  reg [0:0] idle = 0; \n  always @(posedge clk) begin \n  if (!resetn) begin \n  counter <= 0; \n  bitstream_read <= 0; \n  bitnum <= 0; \n  end else begin \n  bitstream_read <= 0; \n  if (counter != 0) begin \n  counter <= counter - 1; \n  end else begin \n  if (!bitnum && !ws2812b_data) begin \n  if (bitstream_available) begin \n  bitstream_read <= 1; \n  bitstream_int <= bitstream; \n  ws2812b_data <= 1; \n  bitnum <= 24; \n  counter <= bitstream[23] ? CYCLES_LONG : CYCLES_SHORT; \n  idle <= 0; \n  end else begin \n  ws2812b_data <= 0; \n  counter <= CYCLES_RET; \n  idle <= 1; \n  end \n  end else if (bitnum) begin \n  if (!ws2812b_data) begin \n  ws2812b_data <= 1; \n  counter <= bitstream_int[23] ? CYCLES_LONG : CYCLES_SHORT; \n  end else begin \n  ws2812b_data <= 0; \n  counter <= (bitstream_int[23]) ? CYCLES_SHORT : CYCLES_LONG; \n  bitstream_int <= {bitstream_int[22:0], bitstream_int[23]}; \n  bitnum <= bitnum - 1; \n  end \n  end \n  end \n  end \n  end \n  assign debug_info = {ws2812b_data, bitstream_read, bitstream_available, clk}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a synchronous D flip-flop with set capability. It has a single output Q, two inputs C and S, and one data input D. When the S input is asserted, the flip-flop is set to 1. Otherwise, it stores the value of input D on the positive edge of input C.\n\nAdditionally, the module includes timing constraints for different FPGA families. These constraints define the setup time and hold time requirements for the D input with respect to the clock signal C and the set input S.\n\nThe module also includes platform-specific configurations for different FPGA families, such as ICE40_HX, ICE40_LP, and ICE40_U. These configurations define setup and hold times for the D and S inputs with respect to the clock signal C, as well as specifying the behavior of the flip-flop under certain conditions.\n\nIn summary, the module implements a configurable D flip-flop with set capability and provides timing constraints and platform-specific configurations for different FPGA families.\n\n Module header:\n\nmodule SB_DFFS (output reg Q,input C, S, D);\n [/INST]\n", "output": "`SB_DFF_INIT \n  always @(posedge C, posedge S) \n  if (S) \n  Q <= 1; \n  else \n  Q <= D; \n `ifdef ICE40_HX \n  specify \n  $setup(D, posedge C, 470 - 449); \n  $setup(negedge S, posedge C, 160); \n `ifndef YOSYS \n  (posedge S => (Q : 1'b1)) = 599; \n `else \n  if (S) (S => Q) = 599; \n `endif \n  if (!S) (posedge C => (Q : D)) = 540; \n  endspecify \n `endif \n `ifdef ICE40_LP \n  specify \n  $setup(D, posedge C, 693 - 662); \n  $setup(negedge S, posedge C, 235); \n `ifndef YOSYS \n  (posedge S => (Q : 1'b1)) = 883; \n `else \n  if (S) (S => Q) = 883; \n `endif \n  if (!S) (posedge C => (Q : D)) = 796; \n  endspecify \n `endif \n `ifdef ICE40_U \n  specify \n  $setup(D, posedge C, 0); \n  $setup(negedge S, posedge C, 424); \n `ifndef YOSYS \n  (posedge S => (Q : 1'b1)) = 1589; \n `else \n  if (S) (S => Q) = 1589; \n `endif \n  if (!S) (posedge C => (Q : D)) = 1391; \n  endspecify \n `endif \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements the control logic for a CPU. It decodes the opcode and function code inputs to generate various control signals for the CPU's components. It determines the type of instruction based on the opcode and function code inputs, and generates control signals for jump, register addresses, ALU operations, shifts, rotates, arithmetic instructions, load/store instructions, and branch instructions.\n\nThe module uses AND and OR gates to decode the opcode and function code inputs and generate the appropriate control signals. It also uses assignment statements to assign the generated control signals to the module's output ports.\n\nAdditionally, the module includes a finite state machine for ALU operations, and it generates the BJ control signal based on the result of a comparison operation.\n\n Module header:\n\nmodule cpu_ctl(op,func,equal_result,JR,J,JAL,LW,WREG,WMEM,RDorRT,SE,SA,IR,IorR,BJ,Aluc);\n [/INST]\n", "output": "input wire [5:0] op, func; \n  input wire equal_result; \n  output wire JR,J,JAL,LW,WREG,WMEM,RDorRT,SE,SA,IR,IorR,BJ; \n  output wire [4:0] Aluc; \n  wire r_type, i_jr, i_sll, i_srl, i_sra; \n  wire i_addi,i_andi,i_ori,i_xori,i_slti,i_mul,i_div,i_type,i_lw,i_sw,i_lh,i_sh,i_j,i_jal; \n  wire i_beq,i_bgez,i_bgtz,i_blez,i_bltz,i_bne; \n  and(r_type,~op[5],~op[4],~op[3],~op[2],~op[1],~op[0]); \n  and(i_jr, r_type, ~func[5], ~func[4], func[3], ~func[2], ~func[1], ~func[0]); \n  and(i_sll, r_type, ~func[5], ~func[4], ~func[3], ~func[2], ~func[1], ~func[0]); \n  and(i_srl, r_type, ~func[5], ~func[4], ~func[3], ~func[2], func[1], ~func[0]); \n  and(i_sra, r_type, ~func[5], ~func[4], ~func[3], ~func[2], func[1], func[0]); \n  or(i_type, i_addi, i_andi, i_ori, i_xori, i_slti, b_type, i_lw, i_sw ); \n  and(i_addi,~op[5],~op[4], op[3],~op[2],~op[1],~op[0]); \n  and(i_andi,~op[5],~op[4], op[3], op[2],~op[1],~op[0]); \n  and(i_ori, ~op[5],~op[4], op[3], op[2],~op[1], op[0]); \n  and(i_xori,~op[5],~op[4], op[3], op[2], op[1],~op[0]); \n  and(i_slti,~op[5],~op[4], op[3], ~op[2], op[1],~op[0]); \n  and(i_lw, op[5],~op[4],~op[3],~op[2], op[1], op[0]); \n  and(i_sw, op[5],~op[4], op[3],~op[2], op[1], op[0]); \n  or(b_type, i_beq, i_bgez, i_bgtz, i_blez, i_bltz, i_bne); \n  and(i_beq, ~op[5],~op[4],~op[3], op[2],~op[1],~op[0]); \n  and(i_bne, ~op[5],~op[4],~op[3], op[2],~op[1], op[0]); \n  and(i_j, ~op[5],~op[4],~op[3],~op[2], op[1],~op[0]); \n  and(i_jal, ~op[5],~op[4],~op[3],~op[2], op[1], op[0]); \n  assign JR = i_jr; \n  assign J = i_j; \n  assign JAL = i_jal; \n  assign LW = i_lw; \n  assign WREG = i_jal | IorR | LW ; \n  assign WMEM = i_sw; \n  assign RDorRT = r_type & ~i_jr; \n  assign SE = i_addi | i_lw |i_sw; \n  assign SA = i_sll | i_srl | i_sra; \n  assign IR =( r_type | i_type ) & ~i_jr & ~b_type & ~i_lw & ~i_sw; \n  assign IorR = i_tcype & ~b_type; \n  alt_ctl AC(.op(op),.func(func),.aluc(Aluc)); \n  assign BJ = ( i_beq & equal_result ) | ( i_bne & ~equal_result ); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module `PP_MIDDLE` implements a combinational logic function to compute the value of the output `PPBIT` based on the input signals `ONEPOS`, `ONENEG`, `TWOPOS`, `TWONEG`, `INA`, `INB`, `INC`, and `IND`. The output `PPBIT` is computed based on the logical combination of the input signals using the bitwise AND and NOT operations.\n\n Module header:\n\nmodule PP_MIDDLE ( ONEPOS, ONENEG, TWOPOS, TWONEG, INA, INB, INC, IND, PPBIT );\n [/INST]\n", "output": "input ONEPOS; \n input ONENEG; \n input TWOPOS; \n input TWONEG; \n input INA; \n input INB; \n input INC; \n input IND; \n output PPBIT; \n  assign PPBIT = ~ (( ~ (INA & TWOPOS)) & ( ~ (INB & TWONEG)) & ( ~ (INC & ONEPOS)) & ( ~ (IND & ONENEG))); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a pipeline stage with configurable parameters for input and output data width, as well as a control parameter for cut readiness. When DP is equal to 0, the output valid signal and input ready signal are directly connected, and the input data is directly forwarded to the output. When DP is greater than 0, additional logic is instantiated for managing the valid signals. The module also includes the instantiation of flip-flops for the valid signal and the data, and it provides different behavior based on the value of the CUT_READY parameter.\n\n Module header:\n\nmodule sirv_gnrl_pipe_stage # (parameter CUT_READY = 0,parameter DP = 1,parameter DW = 32) (input i_vld,output i_rdy,input [DW-1:0] i_dat,output o_vld,input o_rdy,output [DW-1:0] o_dat,input clk,input rst_n);\n [/INST]\n", "output": "genvar i; \n  generate \n  if(DP == 0) begin: dp_eq_0 \n  assign o_vld = i_vld; \n  assign i_rdy = o_rdy; \n  assign o_dat = i_dat; \n  end \n  else begin: dp_gt_0 \n  wire vld_set; \n  wire vld_clr; \n  wire vld_ena; \n  wire vld_r; \n  wire vld_nxt; \n  assign vld_set = i_vld & i_rdy; \n  assign vld_clr = o_vld & o_rdy; \n  assign vld_ena = vld_set | vld_clr; \n  assign vld_nxt = vld_set | (~vld_clr); \n  sirv_gnrl_dfflr #(1) vld_dfflr (vld_ena, vld_nxt, vld_r, clk, rst_n); \n  assign o_vld = vld_r; \n  sirv_gnrl_dffl #(DW) dat_dfflr (vld_set, i_dat, o_dat, clk); \n  if(CUT_READY == 1) begin:cut_ready \n  assign i_rdy = (~vld_r); \n  end \n  else begin:no_cut_ready \n  assign i_rdy = (~vld_r) | vld_clr; \n  end \n  end \n  endgenerate \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a BRAM (Block RAM) switch that selects between two BRAM ports based on the switch input. It uses the switch input to control which BRAM port (A or B) is connected to the BRAM port C for read and write operations. The module also includes a clock multiplexer to select the clock signal for BRAM port C based on the switch input.\n\n Module header:\n\nmodule bram_switch # (parameter integer BRAM_DATA_WIDTH = 32,parameter integer BRAM_ADDR_WIDTH = 15) (input wire switch,input wire bram_porta_clk,input wire bram_porta_rst,input wire [BRAM_ADDR_WIDTH-1:0] bram_porta_addr,input wire [BRAM_DATA_WIDTH-1:0] bram_porta_wrdata,output wire [BRAM_DATA_WIDTH-1:0] bram_porta_rddata,input wire bram_porta_we,input wire bram_portb_clk,input wire bram_portb_rst,input wire [BRAM_ADDR_WIDTH-1:0] bram_portb_addr,input wire [BRAM_DATA_WIDTH-1:0] bram_portb_wrdata,output wire [BRAM_DATA_WIDTH-1:0] bram_portb_rddata,input wire bram_portb_we,output wire bram_portc_clk,output wire bram_portc_rst,output wire [BRAM_ADDR_WIDTH-1:0] bram_portc_addr,output wire [BRAM_DATA_WIDTH-1:0] bram_portc_wrdata,input wire [BRAM_DATA_WIDTH-1:0] bram_portc_rddata,output wire bram_portc_we);\n [/INST]\n", "output": "assign bram_portc_rst = switch == 1 ? bram_porta_rst : bram_portb_rst; \n assign bram_portc_addr = switch == 1 ? bram_porta_addr : bram_portb_addr; \n assign bram_portc_wrdata = switch == 1 ? bram_porta_wrdata : bram_portb_wrdata; \n assign bram_portc_we = switch == 1 ? bram_porta_we: bram_portb_we; \n assign bram_porta_rddata = switch == 1 ? bram_portc_rddata : {(BRAM_DATA_WIDTH){1'b0}}; \n assign bram_portb_rddata = switch == 0 ? bram_portc_rddata : {(BRAM_DATA_WIDTH){1'b0}}; \n BUFGMUX #() \n BUFGMUX_inst (.O(bram_portc_clk),.I0(bram_portb_clk),.I1(bram_porta_clk),.S(switch)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, `memtest05`, implements a simple memory with 4 blocks, where each block is 8 bits wide. The module takes in a clock signal, an address, write data, write enable signals, and outputs read data. On the positive edge of the clock, it checks if any of the write enables are asserted and updates the corresponding portion of the memory. It then reads the data from the memory at the specified address and assigns it to the output register rdata.\n\n Module header:\n\nmodule memtest05(clk, addr, wdata, rdata, wen);\n [/INST]\n", "output": "input clk; \n input [1:0] addr; \n input [7:0] wdata; \n output reg [7:0] rdata; \n input [3:0] wen; \n reg [7:0] mem [0:3]; \n integer i; \n always @(posedge clk) begin \n  for (i = 0; i < 4; i = i+1) \n  if (wen[i]) mem[addr][i*2 +: 2] <= wdata[i*2 +: 2]; \n  rdata <= mem[addr]; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `ADCConnector` interfaces with an ADC device using SPI protocol. It has input and output signals for clock, reset, clock polarity, clock phase, slave select, data input and output lines, and various other control and data signals. The module includes multiple sub-modules for clock generation, SPI signal control, and data transfer management. The `SixBitCounterAsync` sub-module serves as a counter for managing the data transfer process, and there are several other sub-modules for managing the SPI signals and data transfer. The output `ready` indicates readiness for data transfer, and `loaded1` and `loaded2` indicate whether the respective data has been successfully loaded. The module uses various control signals and sub-modules to manage the SPI communication and data transfer.\n\n Module header:\n\nmodule ADCConnector (SPIClock, resetn,CPOL, CPHA, ss,SCLK, SS, MOSI1, MISO1A, MISO1B, MOSI2, MISO2A, MISO2B,DOM1, DIM1A, DIM1B, DOM2, DIM2A, DIM2B,DOL1, DOL2, ready, loaded1, loaded2);\n [/INST]\n", "output": "input SPIClock; \n  input resetn; \n  input CPOL; \n  input CPHA; \n  input ss; \n  input DOL1; \n  input DOL2; \n  output ready; \n  output loaded1; \n  output loaded2; \n  input [15:0]DOM1; \n  output [13:0]DIM1A; \n  output [13:0]DIM1B; \n  input [15:0]DOM2; \n  output [13:0]DIM2A; \n  output [13:0]DIM2B; \n  output SCLK; \n  output SS; \n  output MOSI1; \n  input MISO1A; \n  input MISO1B; \n  output MOSI2; \n  input MISO2A; \n  input MISO2B; \n  wire [5:0] master_counter_bit; \n  wire Des_en, Ser_en; \n  wire A1, B1, A2, B2, O1, O2; \n  wire [15:0] o1, o2; \n  wire RS; \n  assign SS = ss; \n  assign Ser_en = ~master_counter_bit[5] & ~master_counter_bit[4]; \n  assign Des_en = (~master_counter_bit[5] & master_counter_bit[4] & (master_counter_bit[3] | master_counter_bit[2] | master_counter_bit[1] & master_counter_bit[0]) ) | (master_counter_bit[5] & ~master_counter_bit[4] & ~master_counter_bit[3] & ~master_counter_bit[2] & ~master_counter_bit[1] & ~master_counter_bit[0]); \n  assign ready = master_counter_bit[5]; \n  assign loaded1 = (o1 == DOM1)? 1'b1: 1'b0; \n  assign loaded2 = 1'b1; \n  assign O1 = o1[15]; \n  assign O2 = o2[15]; \n SixBitCounterAsync PocketWatch(.clk(SPIClock),.resetn(resetn & ~SS),.enable(~SS & ~(master_counter_bit[5] & ~master_counter_bit[4] & ~master_counter_bit[3] & ~master_counter_bit[2] & ~master_counter_bit[1] & master_counter_bit[0]) ),.q(master_counter_bit)); \n SCLKMaker TimeLord(.Clk(SPIClock),.S(ss),.CPOL(CPOL),.SCLK(SCLK)); \n SPIRSMaker Level(.CPHA(CPHA),.CPOL(CPOL),.RS(RS)); \n ShiftRegisterWEnableSixteenAsyncMuxedInput OutBox1(.clk(~(SPIClock ^ RS)),.resetn(resetn),.enable(Ser_en),.select(DOL1),.d(DOM1),.q(o1)); \n ShiftRegisterWEnableFourteen InBox1A(.clk(~(SPIClock ^ RS)),.resetn(resetn),.enable(Des_en),.d(A1),.q(DIM1A)); \n ShiftRegisterWEnableFourteen InBox1B(.clk(~(SPIClock ^ RS)),.resetn(resetn),.enable(Des_en),.d(B1),.q(DIM1B)); \n TriStateBuffer BorderGuardOut1(.In(O1),.Select(Ser_en),.Out(MOSI1)); \n TriStateBuffer BorderGuardIn1A(.In(MISO1A),.Select(Des_en),.Out(A1)); \n TriStateBuffer BorderGuardIn1B(.In(MISO1B),.Select(Des_en),.Out(B1)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module represents a multiple-cycle CPU design. It includes instantiated sub-modules for the program counter (PC), instruction control, memory, instruction register, register shift output, memory shift output, execution number, multiplexers, MIPS registers, arithmetic logic unit (ALU), barrel shifter, and address register. The module handles various operations such as memory access, instruction decoding, register operations, arithmetic operations, and shift operations based on the input signals and control signals. Each sub-module performs specific functions, contributing to the overall functionality of the CPU.\n\n Module header:\n\nmodule Multiple_Cycles_CPU(input Clk,output [31:0] PC_in,PC_out,Mem_addr_in,Mem_data_out,IR_out,AddrReg_out,Mem_data_shift,Reg_data_shift,Shift_out,output [31:0]A_in,B_in,ALU_out,ALUShift_out,Rs_out,Rt_out,Rd_in,output [4:0] Rt_addr,Rd_addr,Rs_addr,output [2:0] condition,ALU_SrcB,output [3:0] ALU_op,Rd_write_byte_en,Mem_byte_write,output [1:0] RegDst,MemtoReg,PC_source,Shift_op,output ALU_SrcA,Ex_top,Shift_amountSrc,ALUShift_Sel,PC_write_cond,PC_write_en,IorD,IR_write_en,Addreg_write_en,output Zero,Less,Overflow,PC_write,output [3:0] state,output RegDt0);\n [/INST]\n", "output": "PC pc(PC_in,PC_out,Clk,PC_write_en); \n Instru_Control instruc_control(Less,Zero,PC_write_cond,PC_write,condition,PC_source,IR_out[25:0],PC_out[31:28],ALUShift_out,AddrReg_out,Rs_out,PC_in,PC_write_en); \n Controller controller(Clk,Overflow,IR_out,AddrReg_out[1:0],condition,ALU_SrcB,ALU_op,Rd_write_byte_en,Mem_byte_write,RegDst,MemtoReg,PC_source,Shift_op,ALU_SrcA,Ex_top,Shift_amountSrc,ALUShift_Sel,PC_write_cond,PC_write,IorD,IR_write_en,Addreg_write_en,RegDt0,state); \n assign Mem_addr_in = (IorD == 1'b1)?(AddrReg_out):(PC_out); \n Memory memory(Reg_data_shift,Mem_addr_in,Mem_byte_write, Clk,Mem_data_out); \n IRegister iregister(Mem_data_out,IR_out,Clk,IR_write_en); \n Register_ShiftOutput register_shiftOutput(Rt_out,Mem_addr_in[1:0],IR_out[31:26],Reg_data_shift); \n Memory_ShiftOutput memory_shiftOutput(Mem_data_out,Mem_addr_in[1:0],IR_out[31:26],Mem_data_shift); \n ExNumber exnumber(IR_out[15:0],Ex_top,ALU_SrcB,Rt_out,B_in); \n MUX4_1_5bit mux4_1_5bit_1(RegDst,IR_out[20:16],IR_out[15:11],5'b11111,5'b0,Rd_addr); \n assign Rt_addr = (RegDt0 == 1'b1) ? 5'b0 : IR_out[20:16]; \n assign Rs_addr = IR_out[25:21]; \n MUX4_1_32bit mux4_1_32bit_1(MemtoReg,AddrReg_out,Mem_data_shift,ALU_out,32'b0,Rd_in); \n MIPS_Register register(Rs_addr, Rt_addr, Rd_addr, Clk, Rd_write_byte_en, Rd_in, Rs_out, Rt_out); \n assign A_in = (ALU_SrcA == 1'b1)?Rs_out:PC_out; \n ALU alu(A_in,B_in,ALU_op,Zero,Less,Overflow,ALU_out); \n wire [4:0] Shift_amount; \n assign Shift_amount = (Shift_amountSrc == 1'b1) ? Rs_out[4:0] : IR_out[10:6]; \n MIPS_Shifter barrel_shifter(Rt_out,Shift_amount,Shift_op,Shift_out); \n assign ALUShift_out = (ALUShift_Sel == 1'b1)? Shift_out: ALU_out; \n AddrReg addrReg(ALUShift_out, Addreg_write_en, Clk, AddrReg_out); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a division circuit. It takes two input operands, n and d, and uses a synchronous finite state machine to perform division. The circuit also includes additional control signals for reset, isFactor, and isDone.\n\nThe division process is synchronized with a clock signal and includes a state machine to perform the division operation. The module maintains internal registers to hold the quotient, remainder, and flags indicating if the result is a factor and if the division is complete.\n\nThe circuit initially sets the remainder to -1 and the quotient to 0 and waits for the division operation to begin. The division process progresses on each clock cycle, updating the quotient, remainder, and control flags based on the current state.\n\nThe module also includes a reset mechanism to initialize the division process, as well as the necessary logic to perform the division operation on the input operands.\n\n Module header:\n\nmodule division(input [0:31] n, input [0:15] d, input clk, input reset, output reg [0:31] q, output reg isFactor, output reg isDone);\n [/INST]\n", "output": "reg [0:31] nextQ; \n  reg [0:31] remainder; \n  reg [0:31] nextRemainder; \n  reg nextIsFactor; \n  reg nextIsDone; \n  initial begin \n  nextRemainder = -1; \n  nextQ = 32'b0; \n  remainder = -1; \n  q = 32'b0; \n  nextIsFactor = 1'b0; \n  nextIsDone = 1'b0; \n  end \n  always @(posedge clk) begin \n  remainder <= nextRemainder; \n  isFactor <= nextIsFactor; \n  isDone <= nextIsDone; \n  q <= nextQ; \n  end \n  always @(*) begin \n  if (reset == 1) begin \n  nextRemainder = -1; \n  nextQ = 32'b0; \n  nextIsFactor = 1'b0; \n  nextIsDone = 1'b0; \n  end \n  else begin \n  case (remainder) \n  -1: begin \n  nextRemainder = n; \n  nextQ = 32'b0; \n  nextIsFactor = 1'b0; \n  nextIsDone = 1'b0; \n  end \n  default: begin \n  nextRemainder = remainder >= d ? remainder - d : remainder; \n  nextQ = remainder >= d ? q + 1 : q; \n  nextIsFactor = remainder == 0 ? 1 : 0; \n  nextIsDone = remainder < d ? 1 : 0; \n  end \n  endcase \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module is an altpriority encoder that takes an 8-bit input data and produces a 3-bit output q. It comprises two altpriority encoders, each handling a subset of the input data. The output of these encoders is combined using logical operations to form the final output q.\n\n Module header:\n\nmodule fp_sub_altpriority_encoder_bv7 (data,q) ;\n [/INST]\n", "output": "input [7:0] data; \n  output [2:0] q; \n  wire [1:0] wire_altpriority_encoder19_q; \n  wire [1:0] wire_altpriority_encoder20_q; \n  wire wire_altpriority_encoder20_zero; \n  fp_sub_altpriority_encoder_6v7 altpriority_encoder19 \n (.data(data[3:0]),.q(wire_altpriority_encoder19_q)); \n  fp_sub_altpriority_encoder_6e8 altpriority_encoder20 \n (.data(data[7:4]),.q(wire_altpriority_encoder20_q),.zero(wire_altpriority_encoder20_zero)); \n  assign \n  q = {(~ wire_altpriority_encoder20_zero), (({2{wire_altpriority_encoder20_zero}} & wire_altpriority_encoder19_q) | ({2{(~ wire_altpriority_encoder20_zero)}} & wire_altpriority_encoder20_q))}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a GPIO interface with a configurable number of bits. It features input and output ports for the Wishbone bus interface, as well as ports for GPIO input, output, and direction. The module processes signals on the positive edge of the wb_clk and includes logic for reset, write, acknowledgment, and error handling. The module performs address decoding to determine whether to read from or write to the GPIO output and direction registers. It also uses flip-flops to synchronize the GPIO input signals with the clock, and assigns the synchronized input to the output data when the address indicates a read operation.\n\n Module header:\n\nmodule wb_gpio #(parameter n_bits = 32) (input wb_clk,input wb_rst,input [2:2] wb_adr_i,input [n_bits-1:0] wb_dat_i,input wb_we_i,input wb_cyc_i,input wb_stb_i,input [2:0] wb_cti_i,input [1:0] wb_bte_i,output reg [n_bits-1:0] wb_dat_o,output reg wb_ack_o,output wb_err_o,output wb_rty_o,input [n_bits-1:0] gpio_i,output reg [n_bits-1:0] gpio_o,output reg [n_bits-1:0] gpio_dir_o);\n [/INST]\n", "output": "always @(posedge wb_clk) \n  if (wb_rst) \n  gpio_dir_o <= 0; \n  else if (wb_cyc_i & wb_stb_i & wb_we_i) begin \n  if (wb_adr_i[2] == 1) \n  gpio_dir_o <= wb_dat_i[n_bits-1:0]; \n  end \n  always @(posedge wb_clk) \n  if (wb_rst) \n  gpio_o <= 0; \n  else if (wb_cyc_i & wb_stb_i & wb_we_i) begin \n  if (wb_adr_i[2] == 0) \n  gpio_o <= wb_dat_i[n_bits-1:0]; \n  end \n  reg [n_bits-1:0] gpio_i_ff; \n  always @(posedge wb_clk) begin \n  gpio_i_ff <= gpio_i; \n  if (wb_adr_i[2] == 0) \n  wb_dat_o <= gpio_i_ff; \n  if (wb_adr_i[2] == 1) \n  wb_dat_o <= gpio_dir_o; \n  end \n  always @(posedge wb_clk) \n  if (wb_rst) \n  wb_ack_o <= 0; \n  else if (wb_ack_o) \n  wb_ack_o <= 0; \n  else if (wb_cyc_i & wb_stb_i & !wb_ack_o) \n  wb_ack_o <= 1; \n  assign wb_err_o = 0; \n  assign wb_rty_o = 0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, \"mouse_painter,\" takes a 5-bit input \"line_number\" and assigns an 8-bit output \"line_code\" based on a case statement. The \"line_code\" is determined by specific 8-bit parameter values based on the input \"line_number.\" If \"line_number\" matches a specified value, the corresponding parameter value is assigned to \"line_code.\" If there is no match, \"line_code\" is assigned a default value of 0.\n\n Module header:\n\nmodule mouse_painter(input [4:0] line_number,output reg [7:0] line_code);\n [/INST]\n", "output": "parameter [7:0] line00 = 8'h01; \n parameter [7:0] line01 = 8'h03; \n parameter [7:0] line02 = 8'h07; \n parameter [7:0] line03 = 8'h0F; \n parameter [7:0] line04 = 8'h1F; \n parameter [7:0] line05 = 8'h3F; \n parameter [7:0] line06 = 8'h7F; \n parameter [7:0] line07 = 8'hFF; \n parameter [7:0] line08 = 8'h07; \n parameter [7:0] line09 = 8'h03; \n parameter [7:0] line10 = 8'h01; \n always @(*) begin \n  case(line_number) \n  4'b0000 : line_code = line00; \n  4'b0001 : line_code = line01; \n  4'b0010 : line_code = line02; \n  4'b0011 : line_code = line03; \n  4'b0100 : line_code = line04; \n  4'b0101 : line_code = line05; \n  4'b0110 : line_code = line06; \n  4'b0111 : line_code = line07; \n  4'b1000 : line_code = line08; \n  4'b1001 : line_code = line09; \n  4'b1010 : line_code = line10; \n  default : line_code = 1'b0; \n  endcase \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a controller peripheral that generates different enable signals based on the input clock, reset, and clock enable signals. It includes a 2000-cycle counter and two phases, phase_0 and phase_1, which are updated based on the count of the counter and the clock enable signal. It also combines the phases and the clock enable signal to generate the enable signals enb, enb_1_1_1, enb_1_2000_0, and enb_1_2000_1, which are then output by the module.\n\n Module header:\n\nmodule controllerPeripheralHdlAdi_tc (CLK_IN,reset,clk_enable,enb,enb_1_1_1,enb_1_2000_0,enb_1_2000_1);\n [/INST]\n", "output": "input CLK_IN; \n  input reset; \n  input clk_enable; \n  output enb; \n  output enb_1_1_1; \n  output enb_1_2000_0; \n  output enb_1_2000_1; \n  reg [10:0] count2000; \n  wire phase_all; \n  reg phase_0; \n  wire phase_0_tmp; \n  reg phase_1; \n  wire phase_1_tmp; \n  always @ ( posedge CLK_IN) \n  begin: Counter2000 \n  if (reset == 1'b1) begin \n  count2000 <= 11'b00000000001; \n  end \n  else begin \n  if (clk_enable == 1'b1) begin \n  if (count2000 == 11'b11111001111) begin \n  count2000 <= 11'b00000000000; \n  end \n  else begin \n  count2000 <= count2000 + 1; \n  end \n  end \n  end \n  end \n  assign phase_all = clk_enable? 1 : 0; \n  always @ ( posedge CLK_IN) \n  begin: temp_process1 \n  if (reset == 1'b1) begin \n  phase_0 <= 1'b0; \n  end \n  else begin \n  if (clk_enable == 1'b1) begin \n  phase_0 <= phase_0_tmp; \n  end \n  end \n  end \n  assign phase_0_tmp = (count2000 == 11'b11111001111 && clk_enable == 1'b1)? 1 : 0; \n  always @ ( posedge CLK_IN) \n  begin: temp_process2 \n  if (reset == 1'b1) begin \n  phase_1 <= 1'b1; \n  end \n  else begin \n  if (clk_enable == 1'b1) begin \n  phase_1 <= phase_1_tmp; \n  end \n  end \n  end \n  assign phase_1_tmp = (count2000 == 11'b00000000000 && clk_enable == 1'b1)? 1 : 0; \n  assign enb = phase_all & clk_enable; \n  assign enb_1_1_1 = phase_all & clk_enable; \n  assign enb_1_2000_0 = phase_0 & clk_enable; \n  assign enb_1_2000_1 = phase_1 & clk_enable; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module interfaces with an SPI (Serial Peripheral Interface) module to control OLED displays. It assigns input signals to specific output wires and registers, and instantiates an SPI module with specified parameters to handle the communication with the OLED displays. The SPI module sends and receives data to and from the displays based on the specified clock signal and other control signals. The registers SS_REG and SCLK_REG are updated based on the input SS and SCLK signals, and the outputs OLED_S0, OLED_S1, OLED_S2, and OLED_S3 are updated based on the data received from the SPI module.\n\n Module header:\n\nmodule sandbox (output wire [127:0] OLED_S0,output wire [127:0] OLED_S1,output wire [127:0] OLED_S2,output wire [127:0] OLED_S3,input wire GCLK,output wire [7:0] LD,input wire [7:0] SW,output wire [7:0] JA,input wire [7:0] JB,input wire BTNC,input wire BTND,input wire BTNL,input wire BTNR,input wire BTNU);\n [/INST]\n", "output": "wire MISO; \n  wire MOSI; \n  wire SS; \n  wire SCLK; \n  reg SS_REG = 1'b0; \n  reg SCLK_REG = 1'b0; \n  assign JA[2] = SS_REG; \n  assign JA[3] = SCLK_REG; \n  always @(posedge GCLK) begin \n  SS_REG <= SS; \n  SCLK_REG <= SCLK; \n  end \n  SPI #(.m(15), .Tbit(100)) spi \n (.str0(OLED_S0),.str1(OLED_S1),.str2(OLED_S2),.str3(OLED_S3),.GCLK(GCLK),.RST(BTND),.SW(SW),.st(BTNC),.MASTER_SS(SS),.MASTER_SCLK(SCLK),.MASTER_MISO(JB[0]),.MASTER_MOSI(JA[1]),.SLAVE_SS(SS),.SLAVE_SCLK(SCLK),.SLAVE_MOSI(JB[1]),.SLAVE_MISO(JA[0])); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module emulates a keyboard device. It captures data from the keyboard in synchronization with its clock signals. The module records the keyboard data and generates a ready pulse when the correct sequence is received.\n\n Module header:\n\nmodule Keyboard_dev(clk, reset, kbd_clk, kbd_data, Keyboard_Data, ready_pulse);\n [/INST]\n", "output": "input clk; \n  input reset; \n  input kbd_clk; \n  input kbd_data; \n  output reg ready_pulse; \n  output reg [7: 0] Keyboard_Data; \n  reg [3:0] counter; \n  reg [3:0] last; \n  initial begin \n  Keyboard_Data <= 8'b0; \n  ready_pulse <= 1'b0; \n  counter <= 4'b0; \n  last <= 4'b0; \n  end \n  always @ (negedge kbd_clk) begin \n  case (counter) \n  0: begin \n  counter <= counter + 1; \n  end \n  1: begin \n  counter <= counter + 1; \n  Keyboard_Data[0] <= kbd_data; \n  end \n  2: begin \n  counter <= counter + 1; \n  Keyboard_Data[1] <= kbd_data; \n  end \n  3: begin \n  counter <= counter + 1; \n  Keyboard_Data[2] <= kbd_data; \n  end \n  4: begin \n  counter <= counter + 1; \n  Keyboard_Data[3] <= kbd_data; \n  end \n  5: begin \n  counter <= counter + 1; \n  Keyboard_Data[4] <= kbd_data; \n  end \n  6: begin \n  counter <= counter + 1; \n  Keyboard_Data[5] <= kbd_data; \n  end \n  7: begin \n  counter <= counter + 1; \n  Keyboard_Data[6] <= kbd_data; \n  end \n  8: begin \n  counter <= counter + 1; \n  Keyboard_Data[7] <= kbd_data; \n  end \n  9: begin \n  counter <= counter + 1; \n  end \n  10: begin \n  counter <= 4'b0; \n  end \n  endcase \n  end \n  always @(posedge clk) begin \n  ready_pulse <= (last != 4'd10 && counter == 4'd10); \n  last <= counter; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, named InputSync, creates a synchronous register that samples the input D_I on the rising edge of the CLK_I input and stores it in the D_O output. The register sreg is used to hold the previous value of D_I and shift it on each clock cycle to create a delay.\n\n Module header:\n\nmodule InputSync (input wire D_I,input wire CLK_I,output reg D_O);\n [/INST]\n", "output": "reg [1:0] sreg; \n  always@(posedge CLK_I) \n  begin \n  D_O <= sreg[1]; \n  sreg <= {sreg[0],D_I}; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an arithmetic logic unit (ALU) that performs operations based on the input op and enable signals. When enable is low, the output is assigned to in_b. When enable is high, the module performs different operations based on the value of op. The operations include addition, subtraction, sign extension, and logical AND between in_a and in_b. Additionally, the module assigns the complement of the output to the signal z and the 16th bit of the output to the signal n.\n\n Module header:\n\nmodule dpth_alu (input wire [15:0] in_a,input wire [15:0] in_b,output reg [15:0] out,input wire op,input wire enable,output wire z,output wire n);\n [/INST]\n", "output": "always @(*) \n  begin \n  if (enable == 1'b0) \n  out = in_b; \n  else \n  case (op) \n  2'b00: out = in_a + in_b; \n  2'b01: out = in_a - in_b; \n  2'b10: out = {in_b[15], in_b[15:1]}; \n  2'b11: out = in_a & in_b; \n  endcase \n  end \n  assign z = ~|out; \n  assign n = out[15]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a dual-port RAM with parameters for memory depth, data width, initial values, and an optional initialization file. The memory is initialized with zeroes or loaded from a file based on the parameters. The module has two write ports and two read ports, each synchronized to the positive edge of the clock signal. When a write enable signal is high, the corresponding write data is stored in the memory, and the read data is updated accordingly. If the write enable signal is low, the module reads the data from the specified address in the memory.\n\n Module header:\n\nmodule tdpram #( parameter MEMD = 2*1024,parameter DATAW = 16 ,parameter IZERO = 0 ,parameter IFILE = \"\" ) ( input clk ,input wEnbA ,input wEnbB ,input [`log2(MEMD)-1:0] addrA ,input [`log2(MEMD)-1:0] addrB ,input [DATAW -1:0] wDataA,input [DATAW -1:0] wDataB,output reg [DATAW -1:0] rDataA,output reg [DATAW -1:0] rDataB);\n [/INST]\n", "output": "integer i; \n  reg [DATAW-1:0] mem [0:MEMD-1]; \n  initial \n  if (IZERO) \n  for (i=0; i<MEMD; i=i+1) mem[i] = {DATAW{1'b0}}; \n  else \n  if (IFILE != \"\") $readmemh({IFILE,\".hex\"}, mem); \n  always @(posedge clk) begin \n  if (wEnbA) begin \n  mem[addrA] <= wDataA; \n  rDataA <= wDataA; \n  end else \n  rDataA <= mem[addrA]; \n  end \n  always @(posedge clk) begin \n  if (wEnbB) begin \n  mem[addrB] <= wDataB; \n  rDataB <= wDataB; \n  end else \n  rDataB <= mem[addrB]; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `wb_uart_wrapper` instantiates either a UART model or the `uart_top` module based on the value of the SIM parameter. If SIM is true, it instantiates a UART model with specified parameters and assigns a value to the `tx` output. If SIM is false, it instantiates the `uart_top` module with specified parameters and connects its input and output ports. In both cases, it also assigns specific values to `wb_err_o` and `wb_rty_o` outputs.\n\n Module header:\n\nmodule wb_uart_wrapper #(parameter DEBUG = 0,parameter SIM = 0) (input wb_clk_i,input wb_rst_i,input [31:0] wb_adr_i,input [7:0] wb_dat_i,input wb_we_i,input wb_cyc_i,input wb_stb_i,input [2:0] wb_cti_i,input [1:0] wb_bte_i,output [7:0] wb_dat_o,output wb_ack_o,output wb_err_o,output wb_rty_o,input rx,output tx);\n [/INST]\n", "output": "generate \n  if(SIM) begin : uart_model \n  wb_uart16550_model #(.DEBUG (DEBUG)) \n  uart \n (.wb_clk_i (wb_clk_i),.wb_rst_i (wb_rst_i),.wb_adr_i (wb_adr_i[2:0]),.wb_dat_i (wb_dat_i),.wb_we_i (wb_we_i),.wb_cyc_i (wb_cyc_i),.wb_stb_i (wb_stb_i),.wb_cti_i (wb_cti_i),.wb_bte_i (wb_bte_i),.wb_dat_o (wb_dat_o),.wb_ack_o (wb_ack_o),.wb_err_o (wb_err_o),.wb_rty_o (wb_rty_o)); \n  assign tx = 1'b0; \n  end else begin : uart16550 \n  uart_top \n #(.uart_data_width (8),.uart_addr_width (3),.debug (DEBUG)) \n  uart \n (.wb_clk_i (wb_clk_i),.wb_rst_i (wb_rst_i),.wb_adr_i (wb_adr_i[2:0]),.wb_dat_i (wb_dat_i),.wb_sel_i (4'b0),.wb_we_i (wb_we_i),.wb_cyc_i (wb_cyc_i),.wb_stb_i (wb_stb_i),.wb_dat_o (wb_dat_o),.wb_ack_o (wb_ack_o),.int_o (),.srx_pad_i (rx),.stx_pad_o (tx),.rts_pad_o (),.cts_pad_i (1'b0),.dtr_pad_o (),.dsr_pad_i (1'b0),.ri_pad_i (1'b0),.dcd_pad_i (1'b0)); \n  assign wb_err_o = 1'b0; \n  assign wb_rty_o = 1'b0; \n  end \n  endgenerate \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module represents a testbench for a memory module (dmem) with specified data and bus widths. It simulates the memory module's behavior by toggling the clock signal and manipulating the address, write enable, and write data signals to perform read and write operations on the memory. It also monitors the signals and dumps the waveform to a VCD file for further analysis.\n\n Module header:\n\nmodule dmem_tb;\n [/INST]\n", "output": "parameter DATA_WIDTH = 32; \n  parameter BUS_WIDTH = 24; \n  reg clk; \n  reg re; \n  reg we; \n  reg [DATA_WIDTH-1:0] addr; \n  reg [DATA_WIDTH-1:0] wdata; \n  wire [DATA_WIDTH-1:0] rdata; \n dmem #(.DATA_WIDTH(DATA_WIDTH),.BUS_WIDTH(BUS_WIDTH)) dmem (.clk(clk),.re(re),.we(we),.addr(addr[BUS_WIDTH+1:2]),.wdata(wdata),.rdata(rdata)); \n  always begin \n  clk <= ~clk; \n  #5; \n  end \n  initial begin \n  $dumpfile(\"vcd/dmem_tb.vcd\"); \n  $dumpvars(0, dmem_tb); \n  $display(\"clk,\\taddr,\\t\\tre,\\twe,\\twdata,\\t\\trdata\"); \n  $monitor(\"%x,\\t%x,\\t%x,\\t%x,\\t%x,\\t%x\",clk, addr, re, we, wdata, rdata); \n  clk <= 1'b0; \n  re <= 1'b0; \n  we <= 1'b0; \n  addr <= 7'd0; \n  @(posedge clk); \n  wdata <= 32'habcdfe01; \n  addr <= 7'd0; \n  re <= 1'b0; \n  we <= 1'b1; \n  @(posedge clk); \n  re <= 1'b1; \n  we <= 1'b0; \n  @(posedge clk); \n  wdata <= 32'hffffaaaa; \n  addr <= 7'd1; \n  re <= 1'b0; \n  we <= 1'b1; \n  @(posedge clk); \n  re <= 1'b1; \n  we <= 1'b0; \n  addr <= 7'd0; \n  @(posedge clk); \n  re <= 1'b1; \n  we <= 1'b0; \n  addr <= 7'd1; \n  @(posedge clk); \n  re <= 1'b1; \n  we <= 1'b1; \n  wdata <= 32'hFEFEFEFE; \n  addr <= 7'd0; \n  @(posedge clk); \n  $finish; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `ogfx_reg_fifo` is a register-based First-In-First-Out (FIFO) memory with specific input and output signals. It has a 16-bit data width and a 4-bit counter to keep track of the number of elements in the FIFO. The module includes logic for push and pop operations and handles full and empty conditions. Additionally, it features control logic to handle various events related to the FIFO, such as overflow and underflow. The module is synchronized to a clock signal and includes a power-up reset signal to ensure reliable operation.\n\n Module header:\n\nmodule ogfx_reg_fifo (fifo_cnt_o,fifo_empty_cnt_o,fifo_data_o,fifo_done_evt_o,fifo_empty_o,fifo_full_o,fifo_ovfl_evt_o,mclk,puc_rst,fifo_data_i,fifo_enable_i,fifo_pop_i,fifo_push_i);\n [/INST]\n", "output": "output [3:0] fifo_cnt_o; \n output [3:0] fifo_empty_cnt_o; \n output [15:0] fifo_data_o; \n output fifo_done_evt_o; \n output fifo_empty_o; \n output fifo_full_o; \n output fifo_ovfl_evt_o; \n input mclk; \n input puc_rst; \n input [15:0] fifo_data_i; \n input fifo_enable_i; \n input fifo_pop_i; \n input fifo_push_i; \n parameter FIFO_EMPTY = 4'h0, \n  FIFO_FULL = 4'hf; \n reg [3:0] fifo_cnt_o; \n wire [3:0] fifo_cnt_nxt; \n assign fifo_full_o = (fifo_cnt_o == FIFO_FULL); \n assign fifo_empty_o = (fifo_cnt_o == FIFO_EMPTY); \n assign fifo_empty_cnt_o = (FIFO_FULL-fifo_cnt_o); \n wire fifo_push_int = fifo_push_i & !fifo_full_o; \n wire fifo_pop_int = fifo_pop_i & !fifo_empty_o; \n assign fifo_done_evt_o = ~fifo_empty_o & (fifo_cnt_nxt == FIFO_EMPTY); \n assign fifo_ovfl_evt_o = fifo_push_i & fifo_full_o; \n assign fifo_cnt_nxt = ~fifo_enable_i ? FIFO_EMPTY : \n  (fifo_push_int & fifo_pop_int) ? fifo_cnt_o : \n  fifo_push_int ? fifo_cnt_o + 3'h1 : \n  fifo_pop_int ? fifo_cnt_o - 3'h1 : \n  fifo_cnt_o; \n always @(posedge mclk or posedge puc_rst) \n  if (puc_rst) fifo_cnt_o <= FIFO_EMPTY; \n  else fifo_cnt_o <= fifo_cnt_nxt; \n reg [3:0] wr_ptr; \n always @(posedge mclk or posedge puc_rst) \n  if (puc_rst) wr_ptr <= 4'h0; \n  else if (~fifo_enable_i) wr_ptr <= 4'h0; \n  else if (fifo_push_int) \n  begin \n  if (wr_ptr==(FIFO_FULL-1)) wr_ptr <= 4'h0; \n  else wr_ptr <= wr_ptr + 4'h1; \n  end \n reg [15:0] fifo_mem [0:15]; \n always @(posedge mclk or posedge puc_rst) \n  if (puc_rst) \n  begin \n  fifo_mem[0] <= 16'h0000; \n  fifo_mem[1] <= 16'h0000; \n  fifo_mem[2] <= 16'h0000; \n  fifo_mem[3] <= 16'h0000; \n  fifo_mem[4] <= 16'h0000; \n  fifo_mem[5] <= 16'h0000; \n  fifo_mem[6] <= 16'h0000; \n  fifo_mem[7] <= 16'h0000; \n  fifo_mem[8] <= 16'h0000; \n  fifo_mem[9] <= 16'h0000; \n  fifo_mem[10] <= 16'h0000; \n  fifo_mem[11] <= 16'h0000; \n  fifo_mem[12] <= 16'h0000; \n  fifo_mem[13] <= 16'h0000; \n  fifo_mem[14] <= 16'h0000; \n  fifo_mem[15] <= 16'h0000; \n  end \n  else if (fifo_push_int) \n  begin \n  fifo_mem[wr_ptr] <= fifo_data_i; \n  end \n reg [3:0] rd_ptr; \n always @(posedge mclk or posedge puc_rst) \n  if (puc_rst) rd_ptr <= 4'h0; \n  else if (~fifo_enable_i) rd_ptr <= 4'h0; \n  else if (fifo_pop_int) \n  begin \n  if (rd_ptr==(FIFO_FULL-1)) rd_ptr <= 4'h0; \n  else rd_ptr <= rd_ptr + 4'h1; \n  end \n assign fifo_data_o = fifo_mem[rd_ptr]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe `idxram` module is a memory module with parameters CDEP and PIPE. It has inputs clk, rst, wEnb, wAddr, vacFLoc, and newPattOccFLoc, and outputs oldIdx and newIdx. The module contains a generate loop that instantiates multiple instances of the mwm20k module. The wAddr is divided into wAddrLL, wAddrLH, and wAddrH. The module uses these addresses to access the memory and generate the output oldIdx and newIdx. In simulation, multiplexers mux_oldIdx and mux_newIdx are used to assign the outputs, while in synthesis, the outputs are assigned directly.\n\n Module header:\n\nmodule idxram #( parameter CDEP = 4 ,parameter PIPE = 1 ) ( input clk ,input rst ,input wEnb ,input [`log2(CDEP)+9:0] wAddr ,input [4 :0] vacFLoc ,input [4 :0] newPattOccFLoc ,output [4 :0] oldIdx ,output [4 :0] newIdx );\n [/INST]\n", "output": "wire [2 :0] wAddrLL = wAddr[2 :0]; \n  wire [1 :0] wAddrLH = wAddr[4 :3]; \n  wire [4 :0] wAddrL = wAddr[4 :0]; \n  wire [`log2(CDEP)+4:0] wAddrH = wAddr[`log2(CDEP)+9:5]; \n  wire [32*5-1:0] rIdx; \n  genvar gi; \n  generate \n  for (gi=0 ; gi<4 ; gi=gi+1) begin: STG \n mwm20k #( .WWID (5 ),.RWID (40 ),.WDEP (CDEP*1024/4 ),.OREG (0 ),.INIT (1 )) \n idxrami ( .clk (clk ),.rst (rst ),.wEnb ( wEnb && (gi==wAddrLH)),.wAddr ({wAddrH,wAddrLL} ),.wData (vacFLoc ),.rAddr (wAddrH ),.rData (rIdx[gi*40 +: 40] )); \n  end \n  endgenerate \n `ifdef SIM \n  assign oldIdx = rIdx[ wAddrL*5 +: 5]; \n `else \n  mux_oldIdx mux_oldIdx_inst(clk,rst,rIdx,wAddrL,oldIdx); \n `endif \n `ifdef SIM \n  assign newIdx = rIdx[newPattOccFLoc*5 +: 5]; \n `else \n  mux_newIdx mux_newIdx_inst(clk,rst,rIdx,newPattOccFLoc,newIdx); \n `endif \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"sub0\" consists of a register \"dout0\" that is updated based on the value of \"dval0\" and \"dbgsel\" inputs. If \"dbgsel\" is within the range of 34-64, \"dout0\" is assigned the value of \"dval0\"; otherwise, \"dout0\" is set to 0. The register \"dbgsel_d1r\" stores the previous value of \"dbgsel\" on every clock edge, unless the reset signal \"rstn\" is asserted, in which case it is reset to 0.\n\n Module header:\n\nmodule sub0 (dout0,rstn, clk, dval0, dbgsel);\n [/INST]\n", "output": "input rstn; \n  input clk; \n  input [7:0] dval0; \n  input [7:0] dbgsel; \n  output reg [7:0] dout0; \n  reg [7:0] dbgsel_d1r; \n  always_comb begin \n  if (((dbgsel_d1r >= 34) && (dbgsel_d1r < 65))) begin \n  dout0 = dval0; \n  end \n  else begin \n  dout0 = 0; \n  end \n  end \n  always @(posedge clk) begin \n  if ((rstn == 0)) begin \n  dbgsel_d1r <= 0; \n  end \n  else begin \n  dbgsel_d1r <= dbgsel; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a state machine that generates a pulse output based on the input signal and a clock signal. The pulse length is determined by the COUNT parameter. The state machine has an idle state and an output state. When the input signal is asserted, the state machine transitions to the output state and starts counting. Once the count reaches the specified length, the state machine transitions back to the idle state. The output signal is asserted while in the output state, generating the pulse.\n\n Module header:\n\nmodule output_pulse (clk,signal_i,signal_o);\n [/INST]\n", "output": "input clk; \n input signal_i; \n output signal_o; \n parameter COUNT = 15; \n parameter s_idle = 1'b0; \n parameter s_out = 1'b1; \n reg[15:0] cnt = 0; \n reg state = 0; \n always @(posedge clk) begin \n  case(state) \n  s_idle: \n  begin \n  state <= (signal_i) ? s_out : s_idle; \n  cnt <= 8'b0; \n  end \n  s_out: \n  begin \n  state <= (cnt >= COUNT) ? s_idle : s_out; \n  cnt <= cnt + 8'b1; \n  end \n  endcase \n end \n assign signal_o = (state == s_out); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `axi_traffic_gen_v2_0_randgen` implements a random number generator using a linear feedback shift register (LFSR). It takes a 16-bit seed as input and generates a 16-bit random number as output. The LFSR is updated on the rising edge of the clock when `generate_next` is asserted, and the LFSR is reset to the seed value when the `reset` signal is active. The LFSR is updated based on a specific XOR logic, and the resulting value is assigned to `randnum`.\n\n Module header:\n\nmodule axi_traffic_gen_v2_0_randgen(input [15:0] seed ,output [15:0] randnum ,input generate_next ,input reset ,input clk);\n [/INST]\n", "output": "reg [15:0] lfsr; \n  wire lfsr_xnor; \n always @(posedge clk) begin \n  if (reset) begin \n  lfsr <= seed; \n  end else if(generate_next) begin \n  lfsr <= {lfsr_xnor,lfsr[15:1]}; \n  end \n end \n assign randnum = lfsr; \n assign lfsr_xnor = (lfsr[12] ^ lfsr[3] ^ lfsr[1]^ lfsr[0]) ? 1'd0 : 1'd1; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a constant generator that outputs a single bit with a value of 1, which is constantly driven regardless of any input signals.\n\n Module header:\n\nmodule sysgen_constant_1e52d3a74c (output [(1 - 1):0] op,input clk,input ce,input clr);\n [/INST]\n", "output": "assign op = 1'b1; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module simulates a two-port memory with write and read functionalities. It includes parameters for the number of addresses, data bus width, and write mask. The memory array is initialized and updated based on the write clock, write enable, and write data inputs. The read operation is triggered by the read clock and read enable, with the read data being output accordingly. The memory array supports partial writes based on the write mask.\n\n Module header:\n\nmodule twoPortMemSim (writeAddress,writeClk,writeEnable,writeData,readAddress,readClk,readEnable,readData);\n [/INST]\n", "output": "parameter addresses = 32; \n  parameter width = 8; \n  parameter muxFactor = 0; \n  parameter writeMask = 1; \n  localparam addressWidth =$clog2(addresses); \n  input [addressWidth-1:0] writeAddress; \n  input writeClk; \n  input [writeMask-1:0] writeEnable; \n  input [width-1:0] writeData; \n  input [addressWidth-1:0] readAddress; \n  input readClk; \n  input readEnable; \n  output [width-1:0] readData; \n  reg [width-1:0] mem [addresses-1:0]; \n  reg [width-1:0] readData; \n  integer i; \n  initial \n  begin \n  $display(\"%m : simulation model of memory\"); \n  end \n  always @(posedge writeClk) \n  begin \n  if (writeEnable!=0) \n  begin \n  if(writeMask==1) \n  begin \n  mem[writeAddress] <= writeData; \n  end \n  else \n  begin \n  for(i=0; i<writeMask; i=i+1) \n  if(writeEnable[i]==1) \n  mem[writeAddress][i] <= writeData[i]; \n  end \n  end \n  end \n  always @(posedge writeClk) \n  begin \n  if(readEnable) \n  begin \n  readData <= mem[readAddress]; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a clocking module that generates multiple clock signals from an input clock. It uses a Digital Clock Manager (DCM) to generate different clock outputs with specific frequencies and phase shifts. The module includes input and output ports for the various clock signals and uses clocking primitives such as BUFG and IBUFG to buffer and distribute the clock signals. The DCM_SP module instance configures the parameters for clock division, multiplication, and phase shifting, allowing for precise control over the generated clock signals.\n\n Module header:\n\nmodule master_clk(CLKIN_IN,CLKDV_OUT,CLKFX_OUT,CLKIN_IBUFG_OUT,CLK0_OUT);\n [/INST]\n", "output": "input CLKIN_IN; \n  output CLKDV_OUT; \n  output CLKFX_OUT; \n  output CLKIN_IBUFG_OUT; \n  output CLK0_OUT; \n  wire CLKDV_BUF; \n  wire CLKFB_IN; \n  wire CLKFX_BUF; \n  wire CLKIN_IBUFG; \n  wire CLK0_BUF; \n  wire GND_BIT; \n  assign GND_BIT = 0; \n  assign CLKIN_IBUFG_OUT = CLKIN_IBUFG; \n  assign CLK0_OUT = CLKFB_IN; \n BUFG CLKDV_BUFG_INST (.I(CLKDV_BUF),.O(CLKDV_OUT)); \n BUFG CLKFX_BUFG_INST (.I(CLKFX_BUF),.O(CLKFX_OUT)); \n IBUFG CLKIN_IBUFG_INST (.I(CLKIN_IN),.O(CLKIN_IBUFG)); \n BUFG CLK0_BUFG_INST (.I(CLK0_BUF),.O(CLKFB_IN)); \n DCM_SP #( .CLK_FEEDBACK(\"1X\"), .CLKDV_DIVIDE(5.0), .CLKFX_DIVIDE(25),.CLKFX_MULTIPLY(7), .CLKIN_DIVIDE_BY_2(\"TRUE\"),.CLKIN_PERIOD(20.000), .CLKOUT_PHASE_SHIFT(\"NONE\"),.DESKEW_ADJUST(\"SYSTEM_SYNCHRONOUS\"), .DFS_FREQUENCY_MODE(\"LOW\"),.DLL_FREQUENCY_MODE(\"LOW\"), .DUTY_CYCLE_CORRECTION(\"TRUE\"),.FACTORY_JF(16'hC080), .PHASE_SHIFT(0), .STARTUP_WAIT(\"FALSE\") ) \n DCM_SP_INST (.CLKFB(CLKFB_IN),.CLKIN(CLKIN_IBUFG),.DSSEN(GND_BIT),.PSCLK(GND_BIT),.PSEN(GND_BIT),.PSINCDEC(GND_BIT),.RST(GND_BIT),.CLKDV(CLKDV_BUF),.CLKFX(CLKFX_BUF),.CLKFX180(),.CLK0(CLK0_BUF),.CLK2X(),.CLK2X180(),.CLK90(),.CLK180(),.CLK270(),.LOCKED(),.PSDONE(),.STATUS()); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a RAM for a text editor. It has parameters for the data width, address width, and RAM depth. The module contains a reg for storing data and includes logic for data initialization and writing to the RAM. It also assigns read data from the RAM based on the read address input. The RAM is synchronous, using a clock signal and a reset signal to control its operations.\n\n Module header:\n\nmodule text_editor_RAM(input clk,input Reset,input write,input [ADDR_WIDTH-1:0] write_address,input [DATA_WIDTH-1:0] write_data,input [ADDR_WIDTH-1:0] read_address,output [DATA_WIDTH-1:0] read_data);\n [/INST]\n", "output": "parameter DATA_WIDTH = 8; \n  parameter ADDR_WIDTH = 9; \n  parameter RAM_DEPTH = 1 << ADDR_WIDTH; \n  reg [DATA_WIDTH-1:0] data [0:RAM_DEPTH-1]; \n  always @ (posedge clk, posedge Reset) begin: RAM_logic \n  if (Reset) begin: Reset \n  integer i; \n  for (i = 0; i < RAM_DEPTH; i = i + 1) begin \n  data[i] <= 8'h29; \n  end \n  end else if (write) begin \n  data[write_address] <= write_data; \n  end \n  end \n  assign read_data = data[read_address]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module `sin_altpriority_encoder_q08` takes a 32-bit input `data` and generates a 5-bit output `q` using two sub-modules `altpriority_encoder19` and `altpriority_encoder20`. These sub-modules process the lower and upper 16 bits of the input, respectively. The outputs of these sub-modules are combined to generate the final output `q` using bitwise logic operations.\n\n Module header:\n\nmodule sin_altpriority_encoder_q08 (data,q) ;\n [/INST]\n", "output": "input [31:0] data; \n  output [4:0] q; \n  wire [3:0] wire_altpriority_encoder19_q; \n  wire [3:0] wire_altpriority_encoder20_q; \n  wire wire_altpriority_encoder20_zero; \n  sin_altpriority_encoder_r08 altpriority_encoder19 \n (.data(data[15:0]),.q(wire_altpriority_encoder19_q)); \n  sin_altpriority_encoder_rf8 altpriority_encoder20 \n (.data(data[31:16]),.q(wire_altpriority_encoder20_q),.zero(wire_altpriority_encoder20_zero)); \n  assign \n  q = {(~ wire_altpriority_encoder20_zero), (({4{wire_altpriority_encoder20_zero}} & wire_altpriority_encoder19_q) | ({4{(~ wire_altpriority_encoder20_zero)}} & wire_altpriority_encoder20_q))}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a Cipher Block Chaining Triple Data Encryption Standard (CBC-TDES) implementation. It takes multiple inputs including reset, clock, encryption mode, keys, initialization vector, data, and control signals. The module uses these inputs to perform TDES encryption and decryption operations. The module also manages internal state, such as the encryption mode, key storage, and data buffering. The TDES encryption and decryption are performed by an instantiated 'tdes' module with the encrypted/decrypted data output and control signals being managed by the main module.\n\n Module header:\n\nmodule cbctdes (input reset_i,input clk_i,input start_i,input mode_i,input [0:63] key1_i,input [0:63] key2_i,input [0:63] key3_i,input [0:63] iv_i,input [0:63] data_i,input valid_i,output reg ready_o,output reg [0:63] data_o,output valid_o);\n [/INST]\n", "output": "reg mode; \n  wire tdes_mode; \n  reg start; \n  reg [0:63] key; \n  wire [0:63] tdes_key1; \n  wire [0:63] tdes_key2; \n  wire [0:63] tdes_key3; \n  reg [0:63] key1; \n  reg [0:63] key2; \n  reg [0:63] key3; \n  reg [0:63] iv; \n  reg [0:63] datain; \n  reg [0:63] datain_d; \n  reg [0:63] tdes_datain; \n  wire validin; \n  wire [0:63] tdes_dataout; \n  reg [0:63] dataout; \n  wire tdes_ready; \n  always @(*) begin \n  if (~mode_i && start_i) begin \n  tdes_datain = iv_i ^ data_i; \n  end \n  else if (~mode && ~start_i) begin \n  tdes_datain = dataout ^ data_i; \n  end \n  else begin \n  tdes_datain = data_i; \n  end \n  end \n  always @(*) begin \n  if (mode && start) begin \n  data_o = iv ^ tdes_dataout; \n  end \n  else if (mode && ~start) begin \n  data_o = datain_d ^ tdes_dataout; \n  end \n  else begin \n  data_o = tdes_dataout; \n  end \n  end \n  assign tdes_key1 = start_i ? key1_i : key1; \n  assign tdes_key2 = start_i ? key2_i : key2; \n  assign tdes_key3 = start_i ? key3_i : key3; \n  assign validin = valid_i & ready_o; \n  always @(posedge clk_i, negedge reset_i) begin \n  if (~reset_i) begin \n  mode <= 0; \n  start <= 0; \n  key1 <= 0; \n  key2 <= 0; \n  key3 <= 0; \n  iv <= 0; \n  datain <= 0; \n  datain_d <= 0; \n  end \n  else begin \n  if (valid_i && ready_o) begin \n  start <= start_i; \n  datain <= data_i; \n  datain_d <= datain; \n  end \n  else if (valid_i && ready_o && start_i) begin \n  mode <= mode_i; \n  key1 <= key1_i; \n  key2 <= key2_i; \n  key3 <= key3_i; \n  iv <= iv_i; \n  end \n  end \n  end \n  always @(posedge clk_i, negedge reset_i) begin \n  if (~reset_i) begin \n  ready_o <= 1; \n  dataout <= 0; \n  end \n  else begin \n  if (valid_i && ready_o && tdes_ready) begin \n  ready_o <= 0; \n  end \n  else if (valid_o) begin \n  ready_o <= 1; \n  dataout <= tdes_dataout; \n  end \n  end \n  end \n tdes i_tdes (.reset_i(reset_i),.clk_i(clk_i),.mode_i(tdes_mode),.key1_i(tdes_key1),.key2_i(tdes_key2),.key3_i(tdes_key3),.data_i(tdes_datain),.valid_i(validin),.data_o(tdes_dataout),.valid_o(valid_o),.ready_o(tdes_ready)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is designed to detect edges on an input signal and generate positive, negative, and double edge signals. It utilizes a 22-bit counter to control the clock signal generation. The received input signal is processed to produce the required edge detection signals. The module employs registers to store the received interface data and uses clock and reset signals to control the edge detection and clock generation logic.\n\n Module header:\n\nmodule edge_detect(input clk_50M,input rst_n,input rx_int,output pos_rx_int,output neg_rx_int,output doub_rx_int);\n [/INST]\n", "output": "reg clk_r=1'b0; \n reg [21:0] cnt; \n always @(posedge clk_50M or negedge rst_n) \n  if(!rst_n) \n  cnt <= 22'b0; \n  else \n  if(cnt == 22'd4194303) \n  cnt <= 22'b0; \n  else \n  cnt <= cnt +1'b1; \n always @(posedge clk_50M or negedge rst_n) \n  if(!rst_n) \n  clk_r <= 1'b0; \n  else \n  if(cnt == 22'd4194300) \n  clk_r <= ~clk_r; \n  else \n  clk_r <= clk_r; \n assign clk = clk_r ; \n reg rx_int0,rx_int1,rx_int2; \n always @(posedge clk or negedge rst_n) \n  begin \n  if(!rst_n) \n  begin \n  rx_int0 <= 1'b0; \n  rx_int1 <= 1'b0; \n  rx_int2 <= 1'b0; \n  end \n  else \n  begin \n  rx_int0 <= rx_int; \n  rx_int1 <= rx_int0; \n  rx_int2 <= rx_int1; \n  end \n  end \n assign pos_rx_int = rx_int1 & ~rx_int2; \n assign neg_rx_int = ~rx_int1 & rx_int2; \n assign doub_rx_int = rx_int1 ^ rx_int2; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a position signal generator with a specified width. It uses a clock and a reset signal to update the position signal based on the speed input. The direction of the position signal is also controlled. The module incorporates pulse width modulation (PWM) signals and includes parameters for various signal widths. The position signal is incremented or decremented based on the speed and direction, with checks for upper and lower bounds.\n\n Module header:\n\nmodule SweepPosition(input wire clk200Hz,input wire rst,input wire [2:0] speed,output reg [RC_SIGNAL_WIDTH-1:0] pos);\n [/INST]\n", "output": "parameter RC_SIGNAL_WIDTH = 11; \n parameter PIN_POS_WIDTH = 10; \n parameter BCD_WIDTH = 4; \n parameter POSITION_FILE_WIDTH = 32; \n parameter POSITION_WIDTH = 11; \n parameter PWMS = 4; \n reg dir; \n always @(posedge clk200Hz or posedge rst) begin \n  if (rst) begin \n  pos = 10'd0; \n  dir = 0; \n  end \n  else if(dir == 0) begin \n  pos = pos + (speed << 1); \n  if(pos >= 2000) begin \n  dir = 1; \n  end \n  end \n  else if(dir == 1) begin \n  pos = pos - (speed << 1); \n  if (pos <= 0) begin \n  dir = 0; \n  end \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module implements a combination of registers, wires, and assignments to manipulate input signals based on clock edges and conditional events. The logic involves addition and bitwise operations to derive output signals from input signals and intermediate results. Additionally, there are assignments based on the inputs and internal signals to generate the output signals.\n\n Module header:\n\nmodule t_order_a (m_from_clk_lev1_r, n_from_clk_lev2, o_from_com_levs11,o_from_comandclk_levs12,clk, a_to_clk_levm3, b_to_clk_levm1, c_com_levs10, d_to_clk_levm2, one);\n [/INST]\n", "output": "input clk; \n  input [7:0] a_to_clk_levm3; \n  input [7:0] b_to_clk_levm1; \n  input [7:0] c_com_levs10; \n  input [7:0] d_to_clk_levm2; \n  input [7:0] one; \n  output [7:0] m_from_clk_lev1_r; \n  output [7:0] n_from_clk_lev2; \n  output [7:0] o_from_com_levs11; \n  output [7:0] o_from_comandclk_levs12; \n  reg [7:0] m_from_clk_lev1_r; \n  wire [7:0] a_to_clk_levm1; \n  wire [7:0] a_to_clk_levm2; \n  wire [7:0] c_com_levs11; \n  reg [7:0] o_from_comandclk_levs12; \n  wire [7:0] n_from_clk_lev2; \n  wire [7:0] n_from_clk_lev3; \n  assign a_to_clk_levm1 = a_to_clk_levm2 + d_to_clk_levm2; \n  assign a_to_clk_levm2 = a_to_clk_levm3 + 0; \n  always @ (posedge clk) begin \n  m_from_clk_lev1_r <= a_to_clk_levm1 + b_to_clk_levm1; \n  end \n  assign c_com_levs11 = c_com_levs10 + one; \n  always @ (c_com_levs11 or n_from_clk_lev3) o_from_comandclk_levs12 = c_com_levs11 + n_from_clk_lev3; \n  assign n_from_clk_lev2 = m_from_clk_lev1_r; \n  assign n_from_clk_lev3 = n_from_clk_lev2; \n  wire [7:0] o_from_com_levs11 = c_com_levs10 + 1; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a D flip-flop with synchronous reset. It has a parameter WIDTH for the width of the input and output signals. On the positive edge of the clock signal, the input d is loaded into the register qr. The output q is then assigned the value of qr, effectively updating q with the value of d on the next clock edge.\n\n Module header:\n\nmodule ffq (clk, d, q);\n [/INST]\n", "output": "parameter WIDTH = 32; \n  input clk; \n  input [WIDTH-1:0] d; \n  output [WIDTH-1:0] q; \n  reg [WIDTH-1:0] qr; \n  always @(posedge clk) \n  qr <= d; \n  assign q = qr; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"hardcopyiii_io_pad\" consists of input \"padin\" and output \"padout\" ports. It includes internal wires \"padin_ipd\" and \"padout_opd\" which are connected to buffers \"padin_buf\" and \"padout_buf\" respectively. The \"padin_buf\" connects the input \"padin\" to \"padin_ipd\", and the \"padout_buf\" connects \"padout\" to \"padout_opd\". The value of \"padout_opd\" is derived from \"padin_ipd\". This module essentially acts as a buffer, passing the input signal to the output.\n\n Module header:\n\nmodule hardcopyiii_io_pad (padin,padout);\n [/INST]\n", "output": "parameter lpm_type = \"hardcopyiii_io_pad\"; \n input padin; \n output padout; \n wire padin_ipd; \n wire padout_opd; \n buf padin_buf (padin_ipd,padin); \n assign padout_opd = padin_ipd; \n buf padout_buf (padout, padout_opd); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module named GP_VSS implements a simple logic gate with an output named OUT. The output is constantly driven to 0, irrespective of any input signals.\n\n Module header:\n\nmodule GP_VSS(output OUT);\n [/INST]\n", "output": "assign OUT = 0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a positive edge-triggered D flip-flop with an asynchronous preset signal. The output Q is initialized to 0 and is updated on the rising edge of the clock signal C. If the preset signal PRE is asserted, Q is set to 1. Otherwise, the module delays for FLOP_DELAY time units and then updates Q with the value of the input D.\n\n Module header:\n\nmodule beh_vlog_ff_pre_v8_2 (Q, C, D, PRE);\n [/INST]\n", "output": "parameter INIT = 0; \n localparam FLOP_DELAY = 100; \n  output Q; \n  input C, D, PRE; \n  reg Q; \n  initial Q= 1'b0; \n  always @(posedge C ) \n  if (PRE) \n  Q <= 1'b1; \n  else \n  Q <= #FLOP_DELAY D; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an arbiter that selects one of the input streams based on their validity and other conditions. It uses combinational logic to determine the output and last grant, and a clocked process to update the last grant based on the input and output signals. The module also performs various bitwise operations and concatenations to form the output signals.\n\n Module header:\n\nmodule gRRArbiter(input clk, input reset,input io_out_ready,output io_out_valid,output io_out_bits_centeroidsFinished,output io_out_bits_pointsFinished,output[15:0] io_out_bits_centeroidIndex,output[63:0] io_out_bits_point_x,output[63:0] io_out_bits_point_y,output[63:0] io_out_bits_point_z,output[4:0] io_out_tag,output io_in_0_ready,input io_in_0_valid,input io_in_0_bits_centeroidsFinished,input io_in_0_bits_pointsFinished,input [15:0] io_in_0_bits_centeroidIndex,input [63:0] io_in_0_bits_point_x,input [63:0] io_in_0_bits_point_y,input [63:0] io_in_0_bits_point_z,input [4:0] io_in_0_tag,output io_chosen);\n [/INST]\n", "output": "wire T0; \n  wire T1; \n  wire T2; \n  wire T3; \n  wire T4; \n  reg[0:0] last_grant; \n  wire T5; \n  wire T6; \n  wire T7; \n  wire[15:0] T8; \n  wire[15:0] dvec_0_centeroidIndex; \n  wire[4:0] T9; \n  wire[6:0] T10; \n  wire[6:0] tvec_0; \n  wire[6:0] T11; \n  assign io_out_valid = io_in_0_valid; \n  assign io_in_0_ready = T0; \n  assign T0 = T1 && io_out_ready; \n  assign T1 = T7 || T2; \n  assign T2 = ! T3; \n  assign T3 = io_in_0_valid && T4; \n  assign T4 = 1'h0 > last_grant; \n  assign T5 = io_out_valid && io_out_ready; \n  assign T6 = T5 ? 1'h0 : last_grant; \n  assign T7 = 1'h0 > last_grant; \n  assign io_out_bits_centeroidIndex = T8; \n  assign T8 = dvec_0_centeroidIndex & 16'hffff; \n  assign dvec_0_centeroidIndex = io_in_0_bits_centeroidIndex; \n  assign io_out_tag = T9; \n  assign T9 = T10[3'h4:1'h0]; \n  assign T10 = tvec_0 & 7'h7f; \n  assign tvec_0 = T11; \n  assign T11 = {2'h0, io_in_0_tag}; \n  always @(posedge clk) begin \n  if(reset) begin \n  last_grant <= 1'h0; \n  end else if(T5) begin \n  last_grant <= T6; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a simple 4-bit FIFO (First In, First Out) memory with clock, write enable, data input, and data output signals. When the write enable signal (wen) is high, the input data (din) is written into the FIFO, and the oldest data is shifted out. The module uses two internal registers to store the data temporarily before it is output.\n\n Module header:\n\nmodule fifo316 (clk, wen, din, dout);\n [/INST]\n", "output": "input clk; \n  input wen; \n  input[`WIDTH_4B - 1:0] din; \n  output[`WIDTH_4B - 1:0] dout; \n  reg[`WIDTH_4B - 1:0] dout; \n  reg[`WIDTH_4B-1:0]buff1; \n  reg[`WIDTH_4B-1:0]buff2; \n  always @(posedge clk) \n  begin \n  if (wen == 1'b1) \n  begin \n  buff1 <= din; \n  buff2 <= buff1; \n  dout <= buff2; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is designed for sign extension. It takes an operand, size, and signage as inputs, and produces the sign-extended result as output. The module uses a for loop to iterate over the bytes of the operand and performs sign extension for each byte. The sign extension logic ensures that the most significant bit of the operand is replicated across the additional bits added during the extension. The result is then assigned based on the size input to provide the sign-extended output.\n\n Module header:\n\nmodule Sign_Ext_Return (result,operand,size,signage);\n [/INST]\n", "output": "output reg [WORD-1:0] result; \n  input [WORD-1:0] operand; \n  input [LOGWORDBYTE-1:0] size; \n  input signage; \n  reg [WORD-1:0] extend [WORDBYTE-1:0]; \n  genvar i; \n  generate \n  for(i=0; i<WORDBYTE; i=i+1) begin \n  always @(*) begin \n  extend[i] <= { \n  {( (WORDBYTE-i-1)*BYTE ){signage && operand[(i+1)*BYTE-1]}}, \n  operand[(i+1)*BYTE-1:0] \n  }; \n  end \n  end \n  endgenerate \n  always @(*) begin \n  result <= extend[size]; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a testbench for a clocked circuit. It includes a 16-bit counter that increments on each clock cycle. When the counter reaches 100, the simulation finishes. Additionally, it includes a reset signal, memory address and data signals, memory enable and write enable signals, as well as instantiations of the CPU and ROM modules. The reset signal is set high when the count is less than 10 and low when the count is greater than or equal to 10.\n\n Module header:\n\nmodule testbench(input clk);\n [/INST]\n", "output": "parameter AWIDTH = 16; \n reg [31:0] count; \n initial \n  count = 0; \n always @(posedge clk) \n  count <= count + 1; \n always @(count) \n begin \n  if (count == 100) \n  $finish; \n end \n reg rst; \n wire [29:0] memaddr; \n wire [31:0] rmemdata; \n wire [31:0] wmemdata; \n wire mem_oe; \n wire mem_we; \n cpu cpu0(.clk(clk),.rst(rst),.mem_re(mem_oe),.mem_we(mem_we),.memaddr(memaddr),.rmemdata(rmemdata),.wmemdata(wmemdata)); \n rom rom0(.clk(clk),.re(mem_oe),.we(mem_we),.addr(memaddr),.rdata(rmemdata),.wdata(wmemdata)); \n always @(count) \n  if (count < 10) \n  rst = 1; \n  else \n  rst = 0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a dual-port RAM with one port for reading and another for writing. It has separate clock and control inputs for each port. The RAM has an address width and a data width, and includes memory array and address register. It initializes the memory with zeros and uses always blocks to handle the read and write operations based on the clock and control signals. The functions get_gpr and set_gpr are used to access and update the memory values at specific addresses.\n\n Module header:\n\nmodule or1200_dpram (clk_a, ce_a, addr_a, do_a,clk_b, ce_b, we_b, addr_b, di_b);\n [/INST]\n", "output": "parameter aw = 5; \n  parameter dw = 32; \n  input clk_a; \n  input ce_a; \n  input [aw-1:0] addr_a; \n  output [dw-1:0] do_a; \n  input clk_b; \n  input ce_b; \n  input we_b; \n  input [aw-1:0] addr_b; \n  input [dw-1:0] di_b; \n  reg [dw-1:0] mem [(1<<aw)-1:0] ; \n  reg [aw-1:0] addr_a_reg; \n  function [31:0] get_gpr; \n  input [aw-1:0] gpr_no; \n  get_gpr = mem[gpr_no]; \n  endfunction \n  function [31:0] set_gpr; \n  input [aw-1:0] gpr_no; \n  input [dw-1:0] value; \n  begin \n  mem[gpr_no] = value; \n  set_gpr = 0; \n  end \n  endfunction \n  assign do_a = mem[addr_a_reg]; \n  integer k; \n  initial begin \n  for(k = 0; k < (1 << aw); k = k + 1) begin \n  mem[k] = 0; \n  end \n  end \n  always @(posedge clk_a) \n  if (ce_a) \n  addr_a_reg <= addr_a; \n  always @(posedge clk_b) \n  if (ce_b & we_b) \n  mem[addr_b] <= di_b; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, named fifoStatus, implements a FIFO (First-In-First-Out) status controller with various status flags. It includes input and output signals such as wr, rd, fifo_we, fifo_rd, wptr, rptr, clk, and rst_n. The module continuously monitors the pointers, write and read operations, and the FIFO status to set the appropriate flags. It determines if the FIFO is full, empty, has reached a threshold, overflowed, or underflowed. The module operates synchronously with the clock and asynchronously with the reset signal. The flags fifo_full, fifo_empty, fifo_threshold, fifo_overflow, and fifo_underflow are set based on the internal logic and input signals, representing the status of the FIFO.\n\n Module header:\n\nmodule fifoStatus (wr,rd,fifo_we,fifo_rd,wptr,rptr,fifo_full,fifo_empty,fifo_threshold,fifo_overflow,fifo_underflow,clk,rst_n);\n [/INST]\n", "output": "input wr; \n input rd; \n input fifo_we; \n input fifo_rd; \n input [4:0] wptr; \n input [4:0] rptr; \n output fifo_full; \n wire fifo_full; \n output fifo_empty; \n wire fifo_empty; \n output fifo_threshold; \n wire fifo_threshold; \n output fifo_overflow; \n wire fifo_overflow; \n output fifo_underflow; \n wire fifo_underflow; \n input clk; \n input rst_n; \n reg underflow_set = 0; \n reg signed [4:0] pointer_result = 0; \n reg pointer_equal = 0; \n reg overflow_set = 0; \n reg fifo_underflow_i = 0; \n reg fifo_threshold_i = 0; \n reg fifo_overflow_i = 0; \n reg fifo_full_i = 0; \n reg fifo_empty_i = 0; \n reg fbit_comp = 0; \n always @(rd, wr, fifo_full_i, rptr, wptr, fifo_empty_i) begin: FIFOSTATUS_LOGIC1 \n  fbit_comp = (wptr[4] ^ rptr[4]); \n  if (($signed({1'b0, wptr[3-1:0]}) - rptr[3-1:0])) begin \n  pointer_equal = 0; \n  end \n  else begin \n  pointer_equal = 1; \n  end \n  pointer_result = (wptr[4-1:0] - rptr[4-1:0]); \n  overflow_set = (fifo_full_i & wr); \n  underflow_set = (fifo_empty_i & rd); \n end \n always @(fbit_comp, pointer_equal, pointer_result) begin: FIFOSTATUS_LOGIC2 \n  fifo_full_i = (fbit_comp & pointer_equal); \n  fifo_empty_i = ((!fbit_comp) & pointer_equal); \n  if ((pointer_result[4] || pointer_result[3])) begin \n  fifo_threshold_i = 1; \n  end \n  else begin \n  fifo_threshold_i = 0; \n  end \n end \n always @(posedge clk, negedge rst_n) begin: FIFOSTATUS_OVERFLOWCONTROL \n  if (rst_n) begin \n  fifo_overflow_i <= 0; \n  end \n  else if (((overflow_set == 1) && (fifo_rd == 0))) begin \n  fifo_overflow_i <= 1; \n  end \n  else if (fifo_rd) begin \n  fifo_overflow_i <= 0; \n  end \n  else begin \n  fifo_overflow_i <= fifo_overflow_i; \n  end \n end \n always @(posedge clk, negedge rst_n) begin: FIFOSTATUS_UNDERFLOWCONTROL \n  if (rst_n) begin \n  fifo_underflow_i <= 0; \n  end \n  else if (((underflow_set == 1) && (fifo_we == 0))) begin \n  fifo_underflow_i <= 1; \n  end \n  else if (fifo_we) begin \n  fifo_underflow_i <= 0; \n  end \n  else begin \n  fifo_underflow_i <= fifo_underflow_i; \n  end \n end \n assign fifo_full = fifo_full_i; \n assign fifo_empty = fifo_empty_i; \n assign fifo_threshold = fifo_threshold_i; \n assign fifo_overflow = fifo_overflow_i; \n assign fifo_underflow = fifo_underflow_i; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, named \"neo_f0\", has a variety of inputs and outputs including control signals for an embedded system. It contains logic to control slots, LEDs, and an RTC (real-time clock). The module uses registers to control the RTC and various other signals based on the input conditions. It also assigns values to the M68K_DATA based on certain conditions. The logic inside the \"always\" block handles the control and manipulation of different signals based on the nRESET and nBITWD0 inputs. The \"assign\" statements set the values of SLOTA, SLOTB, and SLOTC based on the SYSTEMB input and perform conditional assignments on nSLOT accordingly. The module effectively orchestrates the control and manipulation of various signals within an embedded system based on specific input conditions.\n\n Module header:\n\nmodule neo_f0(input nRESET,input nDIPRD0,input nDIPRD1,input nBITWD0,input [7:0] DIPSW,input [7:4] M68K_ADDR,inout [7:0] M68K_DATA,input SYSTEMB,output [5:0] nSLOT,output SLOTA, SLOTB, SLOTC,output reg [2:0] LED_LATCH,output reg [7:0] LED_DATA,input RTC_DOUT, RTC_TP,output RTC_DIN, RTC_CLK, RTC_STROBE);\n [/INST]\n", "output": "reg [2:0] REG_RTCCTRL; \n  reg [2:0] SLOTS; \n  assign RTC_DIN = REG_RTCCTRL[0]; \n  assign RTC_CLK = REG_RTCCTRL[1]; \n  assign RTC_STROBE = REG_RTCCTRL[2]; \n  assign M68K_DATA = (nDIPRD0) ? 8'bzzzzzzzz : \n  (M68K_ADDR[7]) ? 8'b11000000 : \n  DIPSW; \n  assign M68K_DATA = (nDIPRD1) ? 8'bzzzzzzzz : \n  {RTC_DOUT, RTC_TP, 1'b1, 5'b11111}; \n  always @(nRESET, nBITWD0) \n  begin \n  if (!nRESET) \n  begin \n  SLOTS <= 3'b000; \n  REG_RTCCTRL <= 3'b000; \n  end \n  else if (!nBITWD0) \n  begin \n  if (M68K_ADDR[6:4] == 3'b010) \n  $display(\"SELECT SLOT %d\", M68K_DATA[2:0]); \n  else if (M68K_ADDR[6:4] == 3'b011) \n  $display(\"SET LED LATCHES to %b\", M68K_DATA[5:3]); \n  else if (M68K_ADDR[6:4] == 3'b100) \n  $display(\"SET LED DATA to %b\", M68K_DATA[7:0]); \n  else if (M68K_ADDR[6:4] == 3'b101) \n  $display(\"SET RTCCTRL to %b\", M68K_DATA[2:0]); \n  case (M68K_ADDR[6:4]) \n  3'b010: \n  SLOTS <= M68K_DATA[2:0]; \n  3'b011: \n  LED_LATCH <= M68K_DATA[5:3]; \n  3'b100: \n  LED_DATA <= M68K_DATA[7:0]; \n  3'b101: \n  REG_RTCCTRL <= M68K_DATA[2:0]; \n  endcase \n  end \n  end \n  assign {SLOTC, SLOTB, SLOTA} = SYSTEMB ? SLOTS : 3'b000; \n  assign nSLOT = SYSTEMB ? \n  (SLOTS == 3'b000) ? 6'b111110 : \n  (SLOTS == 3'b001) ? 6'b111101 : \n  (SLOTS == 3'b010) ? 6'b111011 : \n  (SLOTS == 3'b011) ? 6'b110111 : \n  (SLOTS == 3'b100) ? 6'b101111 : \n  (SLOTS == 3'b101) ? 6'b011111 : \n  6'b111111 : \n  6'b111111 ; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a Peripheral Input/Output (PIO) interface that interfaces with a memory and contains a 64-bit transmit (TX) engine and a 64-bit receive (RX) engine. It handles data transfer and control signals between the system and the memory. The module also manages request and completion signals for data transactions. The PIO_EP_MEM_ACCESS module provides memory access for the PIO interface. The PIO_64_RX_ENGINE and PIO_64_TX_ENGINE modules handle the receive and transmit operations, respectively. The module interfaces with the system clock and reset, and has various input and output signals for data transfer and control.\n\n Module header:\n\nmodule PIO_EP #(parameter C_DATA_WIDTH = 64,parameter STRB_WIDTH = C_DATA_WIDTH / 8) (input clk,input rst_n,input s_axis_tx_tready,output [C_DATA_WIDTH-1:0] s_axis_tx_tdata,output [STRB_WIDTH-1:0] s_axis_tx_tstrb,output s_axis_tx_tlast,output s_axis_tx_tvalid,output tx_src_dsc,input [C_DATA_WIDTH-1:0] m_axis_rx_tdata,input [STRB_WIDTH-1:0] m_axis_rx_tstrb,input m_axis_rx_tlast,input m_axis_rx_tvalid,output m_axis_rx_tready,input [21:0] m_axis_rx_tuser,output req_compl_o,output compl_done_o,input [15:0] cfg_completer_id,input cfg_bus_mstr_enable);\n [/INST]\n", "output": "wire [10:0] rd_addr; \n  wire [3:0] rd_be; \n  wire [31:0] rd_data; \n  wire [10:0] wr_addr; \n  wire [7:0] wr_be; \n  wire [31:0] wr_data; \n  wire wr_en; \n  wire wr_busy; \n  wire req_compl; \n  wire req_compl_wd; \n  wire compl_done; \n  wire [2:0] req_tc; \n  wire req_td; \n  wire req_ep; \n  wire [1:0] req_attr; \n  wire [9:0] req_len; \n  wire [15:0] req_rid; \n  wire [7:0] req_tag; \n  wire [7:0] req_be; \n  wire [12:0] req_addr; \n PIO_EP_MEM_ACCESS EP_MEM (.clk(clk),.rst_n(rst_n),.rd_addr_i(rd_addr),.rd_be_i(rd_be),.rd_data_o(rd_data),.wr_addr_i(wr_addr),.wr_be_i(wr_be),.wr_data_i(wr_data),.wr_en_i(wr_en),.wr_busy_o(wr_busy)); \n PIO_64_RX_ENGINE #(.C_DATA_WIDTH( C_DATA_WIDTH ),.STRB_WIDTH( STRB_WIDTH )) EP_RX (.clk(clk),.rst_n(rst_n),.m_axis_rx_tdata( m_axis_rx_tdata ),.m_axis_rx_tstrb( m_axis_rx_tstrb ),.m_axis_rx_tlast( m_axis_rx_tlast ),.m_axis_rx_tvalid( m_axis_rx_tvalid ),.m_axis_rx_tready( m_axis_rx_tready ),.m_axis_rx_tuser ( m_axis_rx_tuser ),.req_compl_o(req_compl),.req_compl_wd_o(req_compl_wd),.compl_done_i(compl_done),.req_tc_o(req_tc),.req_td_o(req_td),.req_ep_o(req_ep),.req_attr_o(req_attr),.req_len_o(req_len),.req_rid_o(req_rid),.req_tag_o(req_tag),.req_be_o(req_be),.req_addr_o(req_addr),.wr_addr_o(wr_addr),.wr_be_o(wr_be),.wr_data_o(wr_data),.wr_en_o(wr_en),.wr_busy_i(wr_busy)); \n PIO_64_TX_ENGINE #(.C_DATA_WIDTH( C_DATA_WIDTH ),.STRB_WIDTH( STRB_WIDTH ))EP_TX(.clk(clk),.rst_n(rst_n),.s_axis_tx_tready( s_axis_tx_tready ),.s_axis_tx_tdata( s_axis_tx_tdata ),.s_axis_tx_tstrb( s_axis_tx_tstrb ),.s_axis_tx_tlast( s_axis_tx_tlast ),.s_axis_tx_tvalid( s_axis_tx_tvalid ),.tx_src_dsc( tx_src_dsc ),.req_compl_i(req_compl),.req_compl_wd_i(req_compl_wd),.compl_done_o(compl_done),.req_tc_i(req_tc),.req_td_i(req_td),.req_ep_i(req_ep),.req_attr_i(req_attr),.req_len_i(req_len),.req_rid_i(req_rid),.req_tag_i(req_tag),.req_be_i(req_be),.req_addr_i(req_addr),.rd_addr_o(rd_addr),.rd_be_o(rd_be),.rd_data_i(rd_data),.completer_id_i(cfg_completer_id),.cfg_bus_mstr_enable_i(cfg_bus_mstr_enable)); \n  assign req_compl_o = req_compl; \n  assign compl_done_o = compl_done; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes a 32-bit address input and decodes it into an 80-bit string output. It extracts the address into 8 groups of 4 bits, converts each group into a character code, and concatenates the character codes into a single string. The string is formatted as a hexadecimal value with the prefix \"0x.\"\n\n Module header:\n\nmodule addr_decoder (output [79:0] str,input [31:0] addr);\n [/INST]\n", "output": "wire [3:0] d0 = addr[3:0]; \n  wire [3:0] d1 = addr[7:4]; \n  wire [3:0] d2 = addr[11:8]; \n  wire [3:0] d3 = addr[15:12]; \n  wire [3:0] d4 = addr[19:16]; \n  wire [3:0] d5 = addr[23:20]; \n  wire [3:0] d6 = addr[27:24]; \n  wire [3:0] d7 = addr[31:28]; \n  wire [7:0] d0_s = d0 <= 9 ? \"0\" + d0 : \"A\" + d0 - 10; \n  wire [7:0] d1_s = d1 <= 9 ? \"0\" + d1 : \"A\" + d1 - 10; \n  wire [7:0] d2_s = d2 <= 9 ? \"0\" + d2 : \"A\" + d2 - 10; \n  wire [7:0] d3_s = d3 <= 9 ? \"0\" + d3 : \"A\" + d3 - 10; \n  wire [7:0] d4_s = d4 <= 9 ? \"0\" + d4 : \"A\" + d4 - 10; \n  wire [7:0] d5_s = d5 <= 9 ? \"0\" + d5 : \"A\" + d5 - 10; \n  wire [7:0] d6_s = d6 <= 9 ? \"0\" + d6 : \"A\" + d6 - 10; \n  wire [7:0] d7_s = d7 <= 9 ? \"0\" + d7 : \"A\" + d7 - 10; \n  assign str = {\"0x\", d7_s, d6_s, d5_s, d4_s, d3_s, d2_s, d1_s, d0_s}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module represents a loop of inverters to create a feedback loop. The module takes in two input signals, a and b, and connects them to an output wire. The module also instantiates three inverters, x0, y1, and y2, to create the looped feedback network. The final output b is driven by the inverted output of the first inverter in the loop. The a output is driven by the inverted output of the last inverter in the loop. This creates a feedback loop where the output of the inverters continuously feeds back into the inputs, creating a stable oscillation.\n\n Module header:\n\nmodule Loop(a, b);\n [/INST]\n", "output": "(* LOC = \"P4\" *) \n  output wire a; \n  (* LOC = \"P6\" *) \n  output wire b; \n  wire x0; \n  GP_INV inv(.IN(x0), .OUT(x0)); \n  assign a = x0; \n  wire y0, y1, y2; \n  GP_INV inv0(.IN(y0), .OUT(y1)); \n  GP_INV inv1(.IN(y1), .OUT(y2)); \n  GP_INV inv2(.IN(y2), .OUT(y0)); \n  assign b = y0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module acts as a memory interconnect that selects a specific memory based on the memory address. It includes logic to select the appropriate memory based on the address, and forwards the data, acknowledge, and interrupt signals to the selected memory. Additionally, it handles the write enable, strobe, select, cycle, address, and data signals based on the memory selection. The module effectively acts as a multiplexer for memory access, directing the signals to the appropriate memory based on the address.\n\n Module header:\n\nmodule wishbone_mem_interconnect (input clk,input rst,input i_m_we,input i_m_stb,input i_m_cyc,input [3:0] i_m_sel,input [31:0] i_m_adr,input [31:0] i_m_dat,output reg [31:0] o_m_dat,output reg o_m_ack,output reg o_m_int,output o_s0_we,output o_s0_cyc,output o_s0_stb,output [3:0] o_s0_sel,input i_s0_ack,output [31:0] o_s0_dat,input [31:0] i_s0_dat,output [31:0] o_s0_adr,input i_s0_int);\n [/INST]\n", "output": "parameter MEM_SEL_0 = 0; \n parameter MEM_OFFSET_0 = 32'h00000000; \n parameter MEM_SIZE_0 = 32'h800000; \n reg [31:0] mem_select; \n always @(rst or i_m_adr or mem_select) begin \n  if (rst) begin \n  mem_select <= 32'hFFFFFFFF; \n  end \n  else begin \n  if ((i_m_adr >= MEM_OFFSET_0) && (i_m_adr < (MEM_OFFSET_0 + MEM_SIZE_0))) begin \n  mem_select <= MEM_SEL_0; \n  end \n  else begin \n  mem_select <= 32'hFFFFFFFF; \n  end \n  end \n end \n always @ (mem_select or i_s0_dat) begin \n  case (mem_select) \n  MEM_SEL_0: begin \n  o_m_dat <= i_s0_dat; \n  end \n  default: begin \n  o_m_dat <= 32'h0000; \n  end \n  endcase \n end \n always @ (mem_select or i_s0_ack) begin \n  case (mem_select) \n  MEM_SEL_0: begin \n  o_m_ack <= i_s0_ack; \n  end \n  default: begin \n  o_m_ack <= 1'h0; \n  end \n  endcase \n end \n always @ (mem_select or i_s0_int) begin \n  case (mem_select) \n  MEM_SEL_0: begin \n  o_m_int <= i_s0_int; \n  end \n  default: begin \n  o_m_int <= 1'h0; \n  end \n  endcase \n end \n assign o_s0_we = (mem_select == MEM_SEL_0) ? i_m_we: 1'b0; \n assign o_s0_stb = (mem_select == MEM_SEL_0) ? i_m_stb: 1'b0; \n assign o_s0_sel = (mem_select == MEM_SEL_0) ? i_m_sel: 4'b0; \n assign o_s0_cyc = (mem_select == MEM_SEL_0) ? i_m_cyc: 1'b0; \n assign o_s0_adr = (mem_select == MEM_SEL_0) ? i_m_adr: 32'h0; \n assign o_s0_dat = (mem_select == MEM_SEL_0) ? i_m_dat: 32'h0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a UART transmitter that sends the message \"Hello World!\\r\\n\" character by character. It uses a clock signal and a UART ready-to-send signal as inputs and controls the UART clear-to-send and transmit data signals as outputs. The module initializes the text message and data register, and iterates through the text message to load the data register with the characters to be transmitted. It also handles the index and next character signals for sequential transmission. Finally, it instantiates a UART transmitter module and controls the UART clear-to-send signal.\n\n Module header:\n\nmodule uart_hello (input wire clk50,input wire uart_rts,input wire uart_rxd,output wire uart_cts,output wire uart_txd);\n [/INST]\n", "output": "`define LEN 14 \n  reg [8*`LEN:0] text = \"Hello World!\\r\\n\"; \n  reg [7:0] data; \n  wire rst; \n  wire nextch; \n  integer idx, i; \n  initial begin \n  idx <= 0; \n  end \n  always @ (posedge clk50) begin \n  for (i = 0; i < 8; i = i + 1) \n  data[i] = text[8*(`LEN-1-idx) + i]; \n  if (nextch) \n  idx = (idx + 1) % `LEN; \n  end \n  assign uart_cts = 0; \n reset_delay r0(.clk(clk50),.rst(rst)); \n uart_transmitter t0(.clk(clk50),.rst(rst),.data(data),.nextch(nextch),.txd(uart_txd)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a 16Kbit single-port synchronous SRAM. It has an address input, a data input, mask write enables, write enable, chip select, clock, standby, sleep, and power-off inputs. The module includes an internal memory array, and the behavior is defined to set memory content when power is off and to set the data output accordingly. The module follows timing constraints for setup and output, and the data output depends on various input conditions such as standby, chip select, and write enable.\n\n Module header:\n\nmodule SB_SPRAM256KA (input [13:0] ADDRESS,input [15:0] DATAIN,input [3:0] MASKWREN,input WREN, CHIPSELECT, CLOCK, STANDBY, SLEEP, POWEROFF,output reg [15:0] DATAOUT);\n [/INST]\n", "output": "`ifndef BLACKBOX \n `ifndef EQUIV \n  reg [15:0] mem [0:16383]; \n  wire off = SLEEP || !POWEROFF; \n  integer i; \n  always @(negedge POWEROFF) begin \n  for (i = 0; i <= 16383; i = i+1) \n  mem[i] = 16'bx; \n  end \n  always @(posedge CLOCK, posedge off) begin \n  if (off) begin \n  DATAOUT <= 0; \n  end else \n  if (STANDBY) begin \n  DATAOUT <= 16'bx; \n  end else \n  if (CHIPSELECT) begin \n  if (!WREN) begin \n  DATAOUT <= mem[ADDRESS]; \n  end else begin \n  if (MASKWREN[0]) mem[ADDRESS][ 3: 0] <= DATAIN[ 3: 0]; \n  if (MASKWREN[1]) mem[ADDRESS][ 7: 4] <= DATAIN[ 7: 4]; \n  if (MASKWREN[2]) mem[ADDRESS][11: 8] <= DATAIN[11: 8]; \n  if (MASKWREN[3]) mem[ADDRESS][15:12] <= DATAIN[15:12]; \n  DATAOUT <= 16'bx; \n  end \n  end \n  end \n `endif \n `endif \n `ifdef ICE40_U \n  specify \n  $setup(posedge ADDRESS, posedge CLOCK, 268); \n  $setup(CHIPSELECT, posedge CLOCK, 404); \n  $setup(DATAIN, posedge CLOCK, 143); \n  $setup(MASKWREN, posedge CLOCK, 143); \n  $setup(WREN, posedge CLOCK, 289); \n  (posedge CLOCK => (DATAOUT : 16'bx)) = 1821; \n  (posedge SLEEP => (DATAOUT : 16'b0)) = 1099; \n  endspecify \n `endif \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module is a dual-port RAM with a 32-bit data width and a 4-bit address width. It contains two memory ports, A and B, each with input and output clocks, control signals, data buses, address buses, and address registers. Port A and B each have an input address and data bus, and an output address and data bus. The module stores data in a memory buffer and sets the address register based on the input clock and control signals. It assigns the output address and data based on the address register and stores data in the memory based on the input address and data.\n\n Module header:\n\nmodule RAMB16_S36_S36 (CLKA,SSRA,ADDRA,DIA,DIPA,ENA,WEA,DOA,DOPA,CLKB,SSRB,ADDRB,DIB,DIPB,ENB,WEB,DOB,DOPB);\n [/INST]\n", "output": "parameter dw = 32; \n parameter dwp = 4; \n parameter aw = 9; \n input CLKA, SSRA, ENA, WEA, CLKB, SSRB, ENB, WEB; \n input [dw-1:0] DIA, DIB; \n output [dw-1:0] DOA, DOB; \n input [dwp-1:0] DIPA, DIPB; \n output [dwp-1:0] DOPA, DOPB; \n input [aw-1:0] ADDRA, ADDRB; \n reg [dw+dwp-1:0] mem [(1<<aw)-1:0]; \n reg [aw-1:0] addr_reg_a; \n reg [aw-1:0] addr_reg_b; \n assign DOA = mem[addr_reg_a][dw-1:0]; \n assign DOPA = mem[addr_reg_a][dwp+dw-1:dw]; \n assign DOB = mem[addr_reg_b][dw-1:0]; \n assign DOPB = mem[addr_reg_b][dwp+dw-1:dw]; \n always @(posedge CLKA or posedge SSRA) \n  if ( SSRA == 1'b1 ) \n  addr_reg_a <= #1 {aw{1'b0}}; \n  else if ( ENA ) \n  addr_reg_a <= #1 ADDRA; \n always @(posedge CLKB or posedge SSRB) \n  if ( SSRB == 1'b1 ) \n  addr_reg_b <= #1 {aw{1'b0}}; \n  else if ( ENB ) \n  addr_reg_b <= #1 ADDRB; \n always @(posedge CLKA) \n  if (ENA && WEA) \n  mem[ADDRA] <= #1 { DIPA , DIA }; \n always @(posedge CLKB) \n  if (ENB && WEB) \n  mem[ADDRB] <= #1 { DIPB , DIB }; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, DrawBackground, generates a background based on various input signals and outputs RGB color information. It uses the hcount and vcount inputs to determine the RGB color to be displayed. The hsync, vsync, and blnk inputs are also used to synchronize the output. The module has a reset logic for clearing registers and sets the RGB color to white if the vcount is close to the bottom of the screen and to a gradient color otherwise. This module interfaces with an instance called Clouds to further process the input signals and generate the output.\n\n Module header:\n\nmodule DrawBackground (input wire [9:0] hcount_in,input wire hsync_in,input wire [9:0] vcount_in,input wire vsync_in,input wire blnk_in,input wire [9:0] xoffset,input wire clk,input wire rst,output reg [9:0] hcount_out,output reg hsync_out,output reg [9:0] vcount_out,output reg vsync_out,output reg [23:0] rgb_out,output reg blnk_out);\n [/INST]\n", "output": "localparam BLACK = 24'h00_00_00; \n  localparam WHITE = 24'hff_ff_ff; \n  localparam OFFSET = 100; \n  localparam YRES = 480; \n  reg [7:0] r, g, b; \n  reg [23:0] rgb_cl; \n  reg [9:0] hcount_cl, vcount_cl; \n  reg hsync_cl, vsync_cl, blnk_cl; \n  wire [9:0] hcount_cl_out, vcount_cl_out; \n  wire [23:0] rgb_cl_out; \n Clouds My_Clouds(.clk(clk),.rst(rst),.xoffset(xoffset),.hcount_in(hcount_cl),.hsync_in(hsync_cl),.vcount_in(vcount_cl),.vsync_in(vsync_cl),.rgb_in(rgb_cl),.blnk_in(blnk_cl),.hcount_out(hcount_cl_out),.hsync_out(hsync_cl_out),.vcount_out(vcount_cl_out),.vsync_out(vsync_cl_out),.rgb_out(rgb_cl_out),.blnk_out(blnk_cl_out)); \n  always @(posedge clk or posedge rst) begin \n  if(rst) begin \n  hcount_cl <= #1 0; \n  hsync_cl <= #1 0; \n  vcount_cl <= #1 0; \n  vsync_cl <= #1 0; \n  rgb_cl <= #1 0; \n  blnk_cl <= #1 0; \n  hcount_out <= #1 0; \n  hsync_out <= #1 0; \n  vcount_out <= #1 0; \n  vsync_out <= #1 0; \n  rgb_out <= #1 0; \n  blnk_out <= #1 0; \n  end \n  else begin \n  hcount_cl <= #1 hcount_in; \n  hsync_cl <= #1 hsync_in; \n  vcount_cl <= #1 vcount_in; \n  vsync_cl <= #1 vsync_in; \n  rgb_cl <= #1 {r,g,b}; \n  blnk_cl <= #1 blnk_in; \n  hcount_out <= #1 hcount_cl_out; \n  hsync_out <= #1 hsync_cl_out; \n  vcount_out <= #1 vcount_cl_out; \n  vsync_out <= #1 vsync_cl_out; \n  rgb_out <= #1 rgb_cl_out; \n  blnk_out <= #1 blnk_cl_out; \n  end \n  end \n  always @* begin \n  if((YRES - vcount_in - 1) < OFFSET) {r,g,b} = WHITE; \n  else begin \n  {b} = 8'hff; \n  {r} = (vcount_in >> 1); \n  {g} = (vcount_in >> 1); \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a display controller for a 7-segment display. It takes various inputs including temperature data, x-axis, y-axis, z-axis, and display selection, and outputs control signals for driving a 7-segment display. \n\nThe module includes submodules for clock generation, anode decoding, 7-segment decoding, display refresh control, digit selection, and data control for the 7-segment display. It also contains logic to determine the display selection and anode outputs based on the inputs.\n\n Module header:\n\nmodule display_controller(clk,rst,sel,temp_data,x_axis,y_axis,z_axis,dp,an,seg,display_sel,data_out);\n [/INST]\n", "output": "input clk; \n  input rst; \n  input [1:0] sel; \n  input [7:0] temp_data; \n  input [15:0] x_axis; \n  input [15:0] y_axis; \n  input [15:0] z_axis; \n  input display_sel; \n  output dp; \n  output [3:0] an; \n  output [6:0] seg; \n  output [15:0] data_out; \n  wire [1:0] control; \n  wire dclk; \n  wire [3:0] digit; \n  wire [15:0] data; \n  wire dispSel; \n  wire [3:0] anodes; \n  wire [3:0] D1; \n  wire [3:0] D2; \n  wire [3:0] D3; \n  wire [3:0] D4; \n  reg [1:0] nSel; \n  wire [3:0] an; \n data_controller C0(.clk(clk),.dclk(dclk),.rst(rst),.display_sel(dispSel),.sel(sel),.data(data),.D1(D1),.D2(D2),.D3(D3),.D4(D4),.frmt(data_out)); \n display_clk C1(.clk(clk),.RST(rst),.dclk(dclk)); \n anode_decoder C2(.anode(anodes),.control(control)); \n seven_seg_decoder C3(.num_in(digit),.control(control),.seg_out(seg),.display_sel(dispSel)); \n two_bit_counter C4(.dclk(dclk),.rst(rst),.control(control)); \n digit_select C5(.d1(D1),.d2(D2),.d3(D3),.d4(D4),.control(control),.digit(digit)); \n decimal_select C6(.control(control),.dp(dp)); \n data_select C7(.x_axis(x_axis),.y_axis(y_axis),.z_axis(z_axis),.temp_data(temp_data),.sel(sel),.data(data)); \n  assign dispSel = (display_sel == 1'b1 || sel == 2'b11) ? 1'b1 : 1'b0; \n  assign an = (rst == 1'b1) ? 4'b1111 : anodes; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module represents a multiplier and divider circuit. It takes in a 32-bit input x, a 16-bit input y, and a 3-bit control signal f. The circuit produces a 32-bit output o, a word operation signal word_op, a carry flag out cfo, an overflow flag out ofo, an exception flag out exc, and various internal signals like as, bs, cfs, cfu, a, b, p, div0, over, ovf, mint, zi, di, q, and s.\n\nThe circuit performs sign extension, multiplication, and division based on the control signals. It also computes various flags and exception conditions based on the inputs and the computation results.\n\n Module header:\n\nmodule muldiv (input [31:0] x,input [15:0] y,output [31:0] o,input [ 2:0] f,input word_op,output cfo,output ofo,input clk,output exc);\n [/INST]\n", "output": "wire as, bs, cfs, cfu; \n  wire [16:0] a, b; \n  wire [33:0] p; \n  wire div0, over, ovf, mint; \n  wire [33:0] zi; \n  wire [16:0] di; \n  wire [17:0] q; \n  wire [17:0] s; \n mult signmul17 (.clk (clk),.a (a),.b (b),.p (p)); \n div_su #(34) dut (.clk (clk),.ena (1'b1),.z (zi),.d (di),.q (q),.s (s),.ovf (ovf),.div0 (div0)); \n  assign as = f[0] & (word_op ? x[15] : x[7]); \n  assign bs = f[0] & (word_op ? y[15] : y[7]); \n  assign a = word_op ? { as, x[15:0] } \n  : { {9{as}}, x[7:0] }; \n  assign b = word_op ? { bs, y } : { {9{bs}}, y[7:0] }; \n  assign zi = f[2] ? { 26'h0, x[7:0] } \n : (word_op ? (f[0] ? { {2{x[31]}}, x }: { 2'b0, x }): (f[0] ? { {18{x[15]}}, x[15:0] }: { 18'b0, x[15:0] })); \n  assign di = word_op ? (f[0] ? { y[15], y } : { 1'b0, y }) \n : (f[0] ? { {9{y[7]}}, y[7:0] }: { 9'h000, y[7:0] }); \n  assign o = f[2] ? { 16'h0, q[7:0], s[7:0] } \n : (f[1] ? ( word_op ? {s[15:0], q[15:0]}: {16'h0, s[7:0], q[7:0]}): p[31:0]); \n  assign ofo = f[1] ? 1'b0 : cfo; \n  assign cfo = f[1] ? 1'b0 : !(f[0] ? cfs : cfu); \n  assign cfu = word_op ? (o[31:16] == 16'h0) \n  : (o[15:8] == 8'h0); \n  assign cfs = word_op ? (o[31:16] == {16{o[15]}}) \n  : (o[15:8] == {8{o[7]}}); \n  assign over = f[2] ? 1'b0 \n : (word_op ? (f[0] ? (q[17:16]!={2{q[15]}}): (q[17:16]!=2'b0) ): (f[0] ? (q[17:8]!={10{q[7]}}): (q[17:8]!=10'h000))); \n assign mint = f[0] & (word_op ? (x==32'h80000000): (x==16'h8000)); \n  assign exc = div0 | (!f[2] & ovf) | over | mint; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes an input in the form of a floating-point number and converts it to a floating-point representation using the specified exponent and significand widths. It checks if the input exponent or significand is zero and then performs calculations to determine the normalized distance, the subnormal fraction, and the adjusted exponent. It also handles special cases for zero and non-zero exponents, and then combines the sign, exponent, and significand into the output.\n\n Module header:\n\nmodule fNToRecFN#(parameter expWidth = 3, parameter sigWidth = 3) (input [(expWidth + sigWidth - 1):0] in,output [(expWidth + sigWidth):0] out);\n [/INST]\n", "output": "localparam normDistWidth = clog2(sigWidth); \n  wire sign; \n  wire [(expWidth - 1):0] expIn; \n  wire [(sigWidth - 2):0] fractIn; \n  assign {sign, expIn, fractIn} = in; \n  wire isZeroExpIn = (expIn == 0); \n  wire isZeroFractIn = (fractIn == 0); \n  wire [(normDistWidth - 1):0] normDist; \n  countLeadingZeros#(sigWidth - 1, normDistWidth) \n  countLeadingZeros(fractIn, normDist); \n  wire [(sigWidth - 2):0] subnormFract = (fractIn<<normDist)<<1; \n  wire [expWidth:0] adjustedExp = \n  (isZeroExpIn ? normDist ^ ((1<<(expWidth + 1)) - 1) : expIn) \n  + ((1<<(expWidth - 1)) | (isZeroExpIn ? 2 : 1)); \n  wire isZero = isZeroExpIn && isZeroFractIn; \n  wire isSpecial = (adjustedExp[expWidth:(expWidth - 1)] == 'b11); \n  wire [expWidth:0] exp; \n  assign exp[expWidth:(expWidth - 2)] = \n  isSpecial ? {2'b11, !isZeroFractIn} \n  : isZero ? 3'b000 : adjustedExp[expWidth:(expWidth - 2)]; \n  assign exp[(expWidth - 3):0] = adjustedExp; \n  assign out = {sign, exp, isZeroExpIn ? subnormFract : fractIn}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a clock generator that selects and outputs different clock signals based on the configuration register and a divide value. It has two always blocks triggered by the positive edge of the input clock. The first always block updates the configuration register with the input cfg. The second always block calculates and updates the divide value based on the selected clock signal and the res input. The module then assigns the generated clock signals to the output ports clk_pll and clk_cog based on the divide value and the configuration register.\n\n Module header:\n\nmodule tim (input clk,input res,input [6:0] cfg,output clk_pll,output clk_cog);\n [/INST]\n", "output": "reg [6:0] cfgx; \n reg [12:0] divide; \n wire[4:0] clksel = {cfgx[6:5], cfgx[2:0]}; \n assign clk_pll = (clksel == 5'b11111) \n  ? clk \n  : divide[11]; \n assign clk_cog = divide[12]; \n always @ (posedge clk) \n begin \n  cfgx <= cfg; \n end \n always @ (posedge clk) \n begin \n divide <= divide +{ \n  clksel == 5'b11111 || res, \n  clksel == 5'b11110 && !res, \n  clksel == 5'b11101 && !res, \n  (clksel == 5'b11100 || clksel[2:0] == 3'b000) && !res, \n  (clksel == 5'b11011 || clksel[3:0] == 4'b1010) && !res, \n  1'b0, \n  1'b0, \n  1'b0, \n  1'b0, \n  1'b0, \n  1'b0, \n  1'b0, \n  clksel[2:0] == 3'b001 && !res \n  }; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a cache module for VGA, which interfaces with the VGA controller and a FIFO. It handles various signals for VGA timing and RGB data output. The cache module includes a state machine that controls the data transfer to the VGA and manages the VGA timing signals. It uses a counter to keep track of the VGA screen position and transitions between IDLE and FILL states based on the VGA timing signals. The RGB data output is controlled based on the state of the cache module. The module also interfaces with the FIFO to manage the data transfer between the cache and VGA.\n\n Module header:\n\nmodule vcache(rgb, hsync, vsync, wb_cyc_o, wb_adr_o, wb_stb_o, wb_we_o,wb_sel_o, wb_dat_o,wb_clk_i, wb_rst_i, vga_clk, wb_ack_i, wb_err_i, wb_rty_i,wb_dat_i);\n [/INST]\n", "output": "input wire wb_clk_i; \n  input wire wb_rst_i; \n  input wire vga_clk; \n  output [7:0] rgb; \n  output hsync; \n  output vsync; \n  input wire wb_ack_i; \n  input wire wb_err_i; \n  input wire wb_rty_i; \n  input wire [31:0] wb_dat_i; \n  output wb_cyc_o; \n  output [31:0] wb_adr_o; \n  output wb_stb_o; \n  output wb_we_o; \n  output [3:0] wb_sel_o; \n  output [31:0] wb_dat_o; \n  wire [9:0] x; \n  wire [9:0] y; \n  wire ve; \n  parameter vram_adr_base = 'hf80000; \n  wire [7:0] dout_rgb; \n  assign rgb = ve ? dout_rgb : 0; \n  assign wb_sel_o = 4'b1111; \n  assign wb_we_o = 0; \n  `define FILL 1 \n  `define IDLE 0 \n  reg state; \n  reg [16:0] counter, counter_line; \n  assign wb_adr_o = vram_adr_base + (counter_line + counter) * 4; \n  assign wb_cyc_o = (state == `IDLE)? 0 : 1; \n  assign wb_stb_o = ((state == `IDLE)? 0 : 1) & !wb_ack_i; \n  always @(posedge wb_clk_i) begin \n  if (wb_ack_i) begin \n  if (counter_line == 159) begin \n  state <= `IDLE; \n  counter_line <= 0; \n  counter <= counter + 160; \n  end \n  else begin \n  counter_line <= counter_line + 1; \n  end \n  end \n  if (y >= 0 && y < 480) begin \n  case(state) \n  `IDLE: begin \n  if (newline) state <= `FILL; \n  end \n  `FILL: begin \n  end \n  endcase \n  end \n  else begin \n  counter <= 0; \n  counter_line <= 0; \n  end \n  end \n  wire line_rst = x == 'd640; \n  wire newline, newfield; \n vcache_fifo fifo0 (.wr_clk(wb_clk_i),.rd_clk(vga_clk),.rst(x == 640 || newfield),.din(wb_dat_i),.wr_en(wb_ack_i),.rd_en(ve),.dout(dout_rgb)); \n  wire clk_p = vga_clk; \n vga vga0(.rst (~wb_rst_i),.hsync (hsync),.vsync (vsync),.x (x[9:0]),.y (y[9:0]),.ve (ve),.newline (newline),.newfield (newfield),.clk_p (clk_p)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module implements an edge-triggered dual data rate (DDR) flip-flop. It has two data inputs, din1 and din2, and a clock input. The module stores the values of din1 and din2 on the rising edge of the clock and the value of din2 on the falling edge of the clock. The output, out, alternates between the values of din1 and din2 depending on the clock signal.\n\n Module header:\n\nmodule oh_oddr #(parameter DW = 1) (input clk,input [DW-1:0] din1,input [DW-1:0] din2,output [DW-1:0] out);\n [/INST]\n", "output": "reg [DW-1:0] q1_sl; \n  reg [DW-1:0] q2_sl; \n  reg [DW-1:0] q2_sh; \n  always @ (posedge clk) \n  begin \n  q1_sl[DW-1:0] <= din1[DW-1:0]; \n  q2_sl[DW-1:0] <= din2[DW-1:0]; \n  end \n  always @ (negedge clk) \n  q2_sh[DW-1:0] <= q2_sl[DW-1:0]; \n  assign out[DW-1:0] = clk ? q1_sl[DW-1:0] : \n  q2_sh[DW-1:0]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is designed to drive a 7-segment display based on the input value and clock signal. The module uses a counter to cycle through the input value and a duty cycle parameter to control the display update rate. It converts the binary input into BCD format and assigns the BCD values to the 7-segment display, which are then used to generate the corresponding segment patterns. The module includes logic for multiplexing the segments based on the duty cycle, and it outputs the segment patterns to drive the 7-segment display.\n\n Module header:\n\nmodule sevenseg(input [15:0] value, input clk, output reg [3:0] an, output [6:0] seg);\n [/INST]\n", "output": "parameter SEVEN_SEG_DUTY_CYCLE = 0; \n  reg [15:0] counter; \n  reg [3:0] binary; \n  reg [6:0] sseg; \n  always @(posedge clk) begin \n  counter <= counter + 1; \n  if (counter[13:10] <= SEVEN_SEG_DUTY_CYCLE) begin \n  case (counter[15:14]) \n  2'b00: \n  { an[0], binary} <= {1'b0, value[15:12]}; \n  2'b01: \n  { an[1], binary} <= {1'b0, value[11:8]}; \n  2'b10: \n  { an[2], binary} <= {1'b0, value[7:4]}; \n  2'b11: \n  { an[3], binary} <= {1'b0, value[3:0]}; \n  endcase \n  end else begin \n  an <= 4'b1111; \n  end \n  end \n  always @(binary) \n  case (binary) \n  4'b0000 : \n  sseg <= 7'b1111110; \n  4'b0001 : \n  sseg <= 7'b0110000; \n  4'b0010 : \n  sseg <= 7'b1101101; \n  4'b0011 : \n  sseg <= 7'b1111001; \n  4'b0100 : \n  sseg <= 7'b0110011; \n  4'b0101 : \n  sseg <= 7'b1011011; \n  4'b0110 : \n  sseg <= 7'b1011111; \n  4'b0111 : \n  sseg <= 7'b1110000; \n  4'b1000 : \n  sseg <= 7'b1111111; \n  4'b1001 : \n  sseg <= 7'b1111011; \n  4'b1010 : \n  sseg <= 7'b1110111; \n  4'b1011 : \n  sseg <= 7'b0011111; \n  4'b1100 : \n  sseg <= 7'b1001110; \n  4'b1101 : \n  sseg <= 7'b0111101; \n  4'b1110 : \n  sseg <= 7'b1001111; \n  4'b1111 : \n  sseg <= 7'b1000111; \n  endcase \n  assign seg = sseg ^ 7'b1111111; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module is a decoder that takes an input vector \"a\" of width WIDTH and generates a code of size 2^WIDTH. The module has a clock enable input \"clken\" and uses it to update the output \"code\" and an internal register \"p\". The encoding logic is based on the input \"a\" and the clock enable signal. The code is generated by performing logical operations on \"a\" and \"p\" within nested loops and is stored in the output \"code\".\n\n Module header:\n\nmodule decoderparam # (parameter WIDTH = 4) ( output reg [2**WIDTH-1 : 0] code,input [WIDTH-1 : 0] a,input clken);\n [/INST]\n", "output": "localparam STAGE = WIDTH; \n  integer i, s, r; \n  reg [(STAGE+1)*(2**STAGE):0] p; \n  always @(a, p, clken) begin \n  p[STAGE*(2**STAGE)] <= clken; \n  for(s=STAGE; s > 0; s = s - 1) begin \n  for (r = 0; r < 2**(STAGE - s); r = r + 1) begin \n  p[(s-1)*(2**STAGE) + 2*r] <= !a[s-1] && p[s*(2**STAGE)+r]; \n  p[(s-1)*(2**STAGE) + 2*r+1] <= a[s-1] && p[s*(2**STAGE)+r]; \n  end \n  end \n  for (i=0; i < 2**STAGE; i = i + 1) begin \n  code[i] <= p[i]; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module represents a testbench for an RGB to HSV converter module. It includes signals for the clock, chip enable, RGB input, as well as H, S, V, and various synchronization signals. The testbench initializes the input signals and cycles the clock for a certain number of cycles. After that, it updates the RGB values and de-asserts the synchronization signals. This process repeats after a certain number of clock cycles. The testbench also includes an always block to control the clock and update the RGB input and synchronization signals.\n\n Module header:\n\nmodule tb_rgb2hsv;\n [/INST]\n", "output": "reg clk; \n  reg ce; \n  reg [7:0] R; \n  reg [7:0] G; \n  reg [7:0] B; \n  reg in_hsync; \n  reg in_vsync; \n  reg in_de; \n  wire [7:0] H; \n  wire [7:0] S; \n  wire [7:0] V; \n  wire out_hsync; \n  wire out_vsync; \n  wire out_de; \n rgb2hsv uut (.clk(clk),.ce(ce),.R(R),.G(G),.B(B),.in_hsync(in_hsync),.in_vsync(in_vsync),.in_de(in_de),.H(H),.S(S),.V(V),.out_hsync(out_hsync),.out_vsync(out_vsync),.out_de(out_de)); \n  initial begin \n  clk = 0; \n  ce = 1; \n  R = 8'd101; \n  G = 8'd100; \n  B = 8'd101; \n  in_hsync = 1; \n  in_vsync = 1; \n  in_de = 1; \n  #100; \n  end \n integer i = 0; \n always begin \n  #1 clk = ~clk; \n  i = i + 1; \n  if (i == 1000) begin \n  i = 0; \n  R = 8'd192; \n  G = 8'd100; \n  B = 8'd98; \n  in_hsync= 0; \n  in_vsync = 0; \n  in_de = 0; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, gt32b, initializes and assigns values to different types of variables such as real, reg, and arrays. It uses the initial block to set the time format and display messages. The always blocks are used to display the real-time values of the variables when they change. The module illustrates the use of real, reg, and array variables and their associated behaviors within a Verilog design.\n\n Module header:\n\nmodule gt32b;\n [/INST]\n", "output": "real rlval; \n  reg rval; \n  reg aval[1:0]; \n  reg [7:0] psval; \n  initial begin \n  $timeformat(-12, 0, \" ps\", 16); \n  #1; \n  $display(\"dl:gt32b- %t\", $realtime); \n  rlval <= #1 1.0; \n  rval <= #2 1'b1; \n  aval[0] <= #3 1'b0; \n  psval[1] <= #4 1'b1; \n  end \n  always @(rlval) begin \n  $display(\"rl:gt32b- %t\", $realtime); \n  end \n  always @(rval) begin \n  $display(\"rg:gt32b- %t\", $realtime); \n  end \n  always @(aval[0]) begin \n  $display(\"ar:gt32b- %t\", $realtime); \n  end \n  always @(psval) begin \n  $display(\"ps:gt32b- %t\", $realtime); \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, named \"sky130_fd_sc_hd__dlclkp,\" implements a data latch clocked by a delayed version of the input clock signal. The gate signal is delayed as well. The data latch and an AND gate are used to generate the output GCLK. There's also an awake signal dependent on the power supply VPWR.\n\n Module header:\n\nmodule sky130_fd_sc_hd__dlclkp (GCLK,GATE,CLK);\n [/INST]\n", "output": "output GCLK; \n  input GATE; \n  input CLK ; \n  supply1 VPWR; \n  supply0 VGND; \n  supply1 VPB ; \n  supply0 VNB ; \n  wire m0 ; \n  wire clkn ; \n  wire CLK_delayed ; \n  wire GATE_delayed; \n  reg notifier ; \n  wire awake ; \n  not not0 (clkn , CLK_delayed ); \n  sky130_fd_sc_hd__udp_dlatch$P_pp$PG$N dlatch0 (m0 , GATE_delayed, clkn, notifier, VPWR, VGND); \n  and and0 (GCLK , m0, CLK_delayed ); \n  assign awake = ( VPWR === 1'b1 ); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, named DelayCalculator, takes various inputs such as Clk_100MHz, rst, StartCounting, StopCounting, DelaySum, and LastSlaveIDPlus1. It has several internal registers and wires for performing calculations based on these inputs. It calculates delay related parameters such as RegLoopDelay, AveTransDelay, AveLogicDelay, and AveSlaveDelay. The module includes logic for resetting and updating these parameters based on the input signals and the 100MHz clock. It also utilizes multiplication and shifting operations to calculate the average delays and utilizes division factors to perform these calculations. Overall, the module is designed to calculate and update delay-related parameters based on the input signals and the 100MHz clock.\n\n Module header:\n\nmodule DelayCalculator(Clk_100MHz, rst, StartCounting, StopCounting, DelaySum, LastSlaveIDPlus1,RegLoopDelay, AveTransDelay, AveLogicDelay, AveSlaveDelay);\n [/INST]\n", "output": "input Clk_100MHz; \n input rst; \n input StartCounting; \n input StopCounting; \n input [15:0] DelaySum; \n input [7:0] LastSlaveIDPlus1; \n output [15:0] RegLoopDelay; \n output [7:0] AveTransDelay; \n output [7:0] AveLogicDelay; \n output [7:0] AveSlaveDelay; \n reg [31:0] Trans_mul; \n reg [31:0] Logic_mul; \n reg [15:0] LoopDelayCnt; \n reg [15:0] RegLoopDelay; \n reg [7:0] AveTransDelay; \n reg [7:0] AveLogicDelay; \n reg [7:0] AveSlaveDelay; \n reg ResetLoopDelay_100MHzSync1; \n reg ResetLoopDelay_100MHzSync2; \n reg ResetLoopDelay_100MHzSync3; \n reg StopLoopDelay_100MHzSync1; \n reg StopLoopDelay_100MHzSync2; \n reg StopLoopDelay_100MHzSync3; \n wire [16:0] mul; \n wire [8:0] shift; \n wire [16:0] mul1; \n wire [8:0] shift1; \n wire ResetLoopDelay; \n wire StopLoopDelay; \n assign ResetLoopDelay = StartCounting; \n assign StopLoopDelay = StopCounting; \n always @ (posedge Clk_100MHz or posedge rst) \n begin \n  if(rst) \n  begin \n  ResetLoopDelay_100MHzSync1 <= 1'b0; \n  ResetLoopDelay_100MHzSync2 <= 1'b0; \n  ResetLoopDelay_100MHzSync3 <= 1'b0; \n  StopLoopDelay_100MHzSync1 <= 1'b0; \n  StopLoopDelay_100MHzSync2 <= 1'b0; \n  StopLoopDelay_100MHzSync3 <= 1'b0; \n  end \n  else \n  begin \n  ResetLoopDelay_100MHzSync1 <= ResetLoopDelay; \n  ResetLoopDelay_100MHzSync2 <= ResetLoopDelay_100MHzSync1; \n  ResetLoopDelay_100MHzSync3 <= ResetLoopDelay_100MHzSync2; \n  StopLoopDelay_100MHzSync1 <= StopLoopDelay; \n  StopLoopDelay_100MHzSync2 <= StopLoopDelay_100MHzSync1; \n  StopLoopDelay_100MHzSync3 <= StopLoopDelay_100MHzSync2; \n  end \n end \n always @ (posedge Clk_100MHz or posedge rst) \n begin \n  if(rst) \n  LoopDelayCnt <= 16'd0; \n  else \n  begin \n  if((~ResetLoopDelay_100MHzSync3) & ResetLoopDelay_100MHzSync2) \n  LoopDelayCnt <= 16'd0; \n  else \n  LoopDelayCnt <= LoopDelayCnt + 16'd1; \n  end \n end \n always @ (posedge Clk_100MHz or posedge rst) \n begin \n  if(rst) \n  RegLoopDelay <= 16'd0; \n  else \n  begin \n  if((~StopLoopDelay_100MHzSync3) & (StopLoopDelay_100MHzSync2)) \n  RegLoopDelay <= LoopDelayCnt ; \n  end \n end \n always @ (*) \n begin \n  if( rst ) \n  begin \n  AveTransDelay = 8'd0; \n  AveLogicDelay = 8'd0; \n  AveSlaveDelay = 8'd0; \n  Trans_mul = 32'd0; \n  Logic_mul = 32'd0; \n  end \n  else \n  begin \n  Trans_mul = (RegLoopDelay - DelaySum) * mul1; \n  AveTransDelay = Trans_mul >> shift1; \n  Logic_mul = DelaySum * mul; \n  AveLogicDelay = Logic_mul >> shift; \n  AveSlaveDelay = AveTransDelay + AveLogicDelay; \n  end \n end \n division_factor division_factor_ins \n (.div(LastSlaveIDPlus1),.mul(mul),.shift(shift)); \n division_factor division_factor_ins1 \n (.div((LastSlaveIDPlus1 + 1'b1)),.mul(mul1),.shift(shift1)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module \"pio_latency\" implements a simple input/output port with a latency of one clock cycle. It takes an address, clock signal, input data, a reset signal, and outputs the read data. The read data is determined by a multiplexer, which selects the input data when the address is 0. The read data is stored in a register to introduce a delay of one clock cycle, and the output is updated on the rising edge of the clock signal or when the reset signal is de-asserted.\n\n Module header:\n\nmodule pio_latency (address,clk,in_port,reset_n,readdata);\n [/INST]\n", "output": "output [ 15: 0] readdata; \n  input [ 1: 0] address; \n  input clk; \n  input [ 15: 0] in_port; \n  input reset_n; \n  wire clk_en; \n  wire [ 15: 0] data_in; \n  wire [ 15: 0] read_mux_out; \n  reg [ 15: 0] readdata; \n  assign clk_en = 1; \n  assign read_mux_out = {16 {(address == 0)}} & data_in; \n  always @(posedge clk or negedge reset_n) \n  begin \n  if (reset_n == 0) \n  readdata <= 0; \n  else if (clk_en) \n  readdata <= read_mux_out; \n  end \n  assign data_in = in_port; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a traffic light controller with red, yellow, and green lights. It uses a timer that increments based on the time_signal input and is reset by the reset input. The red, yellow, and green times are predefined, and the module switches between these colors based on the timer value. The sel_color register is used to control the output signals for the red, yellow, and green lights. The timing and color transitions are defined within the always block based on the timer values.\n\n Module header:\n\nmodule tri_light_svetofor (input wire time_signal,input wire reset,output wire red,output wire yellow,output wire green);\n [/INST]\n", "output": "parameter green_time = 8'd26 * 8'd2, \n  red_time = 8'd84 * 8'd2, \n  yellow_time = 8'd3 * 8'd2, \n  blnk_time = 8'd4 * 8'd2, \n  tril_time = green_time + blnk_time + red_time + yellow_time * 8'd2; \n  reg [7:0] timer; \n  reg [2:0] sel_color; \n  assign red = sel_color[0]; \n  assign yellow = sel_color[1]; \n  assign green = sel_color[2]; \n  always @(posedge time_signal or negedge reset) \n  begin \n  if (!reset) \n  begin \n  timer <= 8'd0; \n  sel_color <= 3'b110; \n  end \n  else \n  begin \n  if (timer < tril_time) \n  timer <= timer + 8'd1; \n  else \n  timer <= 8'd0; \n  if (timer <= red_time) \n  sel_color <= 3'b110; \n  if (timer > red_time && timer <= red_time + yellow_time) \n  sel_color <= 3'b100; \n  if (timer > red_time + yellow_time && timer <= red_time + yellow_time + green_time) \n  sel_color <= 3'b011; \n  if (timer > red_time + yellow_time + green_time && timer <= red_time + yellow_time + green_time + blnk_time) \n  if (sel_color == 3'b011) \n  sel_color <= 3'b111; \n  else \n  sel_color <= 3'b011; \n  if (timer > red_time + yellow_time + green_time + blnk_time) \n  sel_color <= 3'b101; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe `foc_cmd_rx` module is a part of a digital communication system. It receives various control messages and decodes them based on the received data, valid signals, and a counter.\n\n- `submsg_rxd` is the 8-bit input for the received submessage data.\n- `submsg_rxdv` is the input for the valid signal for the received submessage data.\n- `submsg_rxlast` is the input for the last received submessage data.\n- `control_mode`, `control_id`, `target`, `damping`, and `cmd_rx` are the output signals.\n\nThe module processes the received submessage data, validates it based on the last received signal, counts the received bits, extracts specific bits for different registers, validates the received data, and then assigns the decoded information to the output signals.\n\n Module header:\n\nmodule foc_cmd_rx (input c,input [7:0] submsg_rxd,input submsg_rxdv,input submsg_rxlast,output [ 7:0] control_mode,output [31:0] control_id,output [31:0] target,output [31:0] damping,output cmd_rx);\n [/INST]\n", "output": "wire [7:0] rxd; \n d1 #(8) rxd_r(.c(c), .d(submsg_rxd), .q(rxd)); \n wire rxdv; \n d1 rxdv_r(.c(c), .d(submsg_rxdv), .q(rxdv)); \n wire rxe; \n d1 rxe_r(.c(c), .d(submsg_rxlast), .q(rxe)); \n wire [11:0] cnt; \n r #(12) cnt_r(.c(c), .rst(~rxdv), .en(1'b1), .d(cnt + 1'b1), .q(cnt)); \n wire [7:0] reg_cmd; \n r #(8) reg_cmd_r(.c(c), .rst(~rxdv), .en(cnt == 12'd0),.d(rxd), .q(reg_cmd)); \n wire [7:0] reg_subcmd; \n r #(8) reg_subcmd_r(.c(c), .rst(~rxdv), .en(cnt == 12'd1),.d(rxd), .q(reg_subcmd)); \n wire rx_valid = (reg_cmd == 8'h4) & (reg_subcmd == 8'h0) & (cnt == 11'd15); \n wire [31:0] rx_shift; \n r #(32) rx_shift_r \n (.c(c), .rst(1'b0), .en(1'b1),.d({rxd, rx_shift[31:8]}), .q(rx_shift)); \n wire [7:0] mode_i; \n r #(8) mode_i_r(.c(c), .rst(1'b0), .en(cnt == 11'd2), .d(rxd), .q(mode_i)); \n wire [31:0] tgt_0_i, tgt_1_i, control_id_i; \n r #(32) tgt_0_i_r(.c(c), .rst(1'b0), .en(cnt == 11'd07),.d(rx_shift), .q(tgt_0_i)); \n r #(32) tgt_1_i_r(.c(c), .rst(1'b0), .en(cnt == 11'd11),.d(rx_shift), .q(tgt_1_i)); \n r #(32) control_id_i_r(.c(c), .rst(1'b0), .en(cnt == 11'd15),.d(rx_shift), .q(control_id_i)); \n wire rx_valid_d1; \n d1 rx_valid_d1_r(.c(c), .d(rx_valid), .q(rx_valid_d1)); \n r #(32) target_r \n (.c(c), .rst(1'b0), .en(rx_valid_d1), .d(tgt_0_i), .q(target)); \n r #(8) mode_r \n (.c(c), .rst(1'b0), .en(rx_valid_d1), .d(mode_i), .q(control_mode)); \n r #(32) damping_r \n (.c(c), .rst(1'b0), .en(rx_valid_d1), .d(tgt_1_i), .q(damping)); \n r #(32) control_id_r \n (.c(c), .rst(1'b0), .en(rx_valid_d1), .d(control_id_i), .q(control_id)); \n assign cmd_rx = rx_valid_d1; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a 2kx8 RAM. It consists of a memory array of 2048 8-bit registers and a data output register. The output DO is assigned the value of the memory register at address AB when the CS signal is active low. The initial block initializes memory addresses 'h7FC' and 'h7FD' to 8'h00 and 8'h18, respectively. The memory access control is triggered on the positive edge of the clock signal when CS is active low. If READ is high, the output register R is loaded with the value from the memory at the address AB. Otherwise, the value at the address AB is assigned the input value DI.\n\n Module header:\n\nmodule RAM2kx8(input CLK, input[10:0] AB, input CS, input READ, output[7:0] DO, input[7:0] DI);\n [/INST]\n", "output": "reg[7:0] mem[0:2047]; \n  reg[7:0] R; \n  assign DO = CS? R: 8'bZ; \n  initial begin \n  mem['h7FC] = 8'h00; \n  mem['h7FD] = 8'h18; \n  end \n  always @(posedge CLK) if (CS) if (READ) R <= mem[AB]; else mem[AB] <= DI; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module 'right_shift_register_test' is designed to test a right shift register module. It sets up the inputs and initial values for the clock signal, enable signal, input data, and shift mode. It then instantiates the right shift register module and applies clock signals to it. The clock signal and enable signal are toggled periodically. When the clock signal is high, it waits for 5 time units, then the clock signal is set low and again waits for 5 time units. This tests the functionality of the right shift register by simulating input and clock signals.\n\n Module header:\n\nmodule right_shift_register_test;\n [/INST]\n", "output": "reg clk; \n  reg enable; \n  reg [15:0] in; \n  reg mode; \n  wire [15:0] out; \n right_shift_register uut (.clk(clk),.enable(enable),.in(in),.mode(mode),.out(out)); \n  initial begin \n  clk = 0; \n  enable = 0; \n  in = 0; \n  mode = 0; \n  enable = 0; \n  mode = 1; \n  in = 16'b1001011010010110; \n  end \n  always \n  begin \n  clk <= 1; # 5; clk <= 0; # 5; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module Apb3Router implements an Advanced Peripheral Bus (APB) router with three output ports. It uses a selIndex to select which output port to route the input signals to, based on the PSEL input. The PADDR, PENABLE, PWRITE, and PWDATA inputs are routed to the corresponding output ports, and the PRDATA, PREADY, and PSLVERROR outputs are selected based on the selIndex. The module is clocked using the io_mainClk signal and includes a system reset functionality.\n\n Module header:\n\nmodule Apb3Router (input [19:0] io_input_PADDR,input [2:0] io_input_PSEL,input io_input_PENABLE,output io_input_PREADY,input io_input_PWRITE,input [31:0] io_input_PWDATA,output [31:0] io_input_PRDATA,output io_input_PSLVERROR,output [19:0] io_outputs_0_PADDR,output [0:0] io_outputs_0_PSEL,output io_outputs_0_PENABLE,input io_outputs_0_PREADY,output io_outputs_0_PWRITE,output [31:0] io_outputs_0_PWDATA,input [31:0] io_outputs_0_PRDATA,input io_outputs_0_PSLVERROR,output [19:0] io_outputs_1_PADDR,output [0:0] io_outputs_1_PSEL,output io_outputs_1_PENABLE,input io_outputs_1_PREADY,output io_outputs_1_PWRITE,output [31:0] io_outputs_1_PWDATA,input [31:0] io_outputs_1_PRDATA,input io_outputs_1_PSLVERROR,output [19:0] io_outputs_2_PADDR,output [0:0] io_outputs_2_PSEL,output io_outputs_2_PENABLE,input io_outputs_2_PREADY,output io_outputs_2_PWRITE,output [31:0] io_outputs_2_PWDATA,input [31:0] io_outputs_2_PRDATA,input io_outputs_2_PSLVERROR,input io_mainClk,input resetCtrl_systemReset);\n [/INST]\n", "output": "reg _zz_3; \n  reg [31:0] _zz_4; \n  reg _zz_5; \n  wire _zz_1; \n  wire _zz_2; \n  reg [1:0] selIndex; \n  always @(*) begin \n  case(selIndex) \n  2'b00 : begin \n  _zz_3 = io_outputs_0_PREADY; \n  _zz_4 = io_outputs_0_PRDATA; \n  _zz_5 = io_outputs_0_PSLVERROR; \n  end \n  2'b01 : begin \n  _zz_3 = io_outputs_1_PREADY; \n  _zz_4 = io_outputs_1_PRDATA; \n  _zz_5 = io_outputs_1_PSLVERROR; \n  end \n  default : begin \n  _zz_3 = io_outputs_2_PREADY; \n  _zz_4 = io_outputs_2_PRDATA; \n  _zz_5 = io_outputs_2_PSLVERROR; \n  end \n  endcase \n  end \n  assign io_outputs_0_PADDR = io_input_PADDR; \n  assign io_outputs_0_PENABLE = io_input_PENABLE; \n  assign io_outputs_0_PSEL[0] = io_input_PSEL[0]; \n  assign io_outputs_0_PWRITE = io_input_PWRITE; \n  assign io_outputs_0_PWDATA = io_input_PWDATA; \n  assign io_outputs_1_PADDR = io_input_PADDR; \n  assign io_outputs_1_PENABLE = io_input_PENABLE; \n  assign io_outputs_1_PSEL[0] = io_input_PSEL[1]; \n  assign io_outputs_1_PWRITE = io_input_PWRITE; \n  assign io_outputs_1_PWDATA = io_input_PWDATA; \n  assign io_outputs_2_PADDR = io_input_PADDR; \n  assign io_outputs_2_PENABLE = io_input_PENABLE; \n  assign io_outputs_2_PSEL[0] = io_input_PSEL[2]; \n  assign io_outputs_2_PWRITE = io_input_PWRITE; \n  assign io_outputs_2_PWDATA = io_input_PWDATA; \n  assign _zz_1 = io_input_PSEL[1]; \n  assign _zz_2 = io_input_PSEL[2]; \n  assign io_input_PREADY = _zz_3; \n  assign io_input_PRDATA = _zz_4; \n  assign io_input_PSLVERROR = _zz_5; \n  always @ (posedge io_mainClk) begin \n  selIndex <= {_zz_2,_zz_1}; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module is a circuit that operates on a clock signal and a data input to produce a quantum output. It uses several internal registers to maintain state information. The behavior of the module is controlled by clock edges and the data input. The output q is dependent on the current state and the data input, and the state is updated based on the data input and the value of another internal register. The module also includes initialization with random values if `RANDOM_INIT` is defined.\n\n Module header:\n\nmodule pext_p2_4 ( clk, d, q );\n [/INST]\n", "output": "input clk; \n  input d; \n  output q; \n  reg q; \n  reg c_q; \n  reg [1:0] r_cnt; \n  reg [1:0] c_cnt; \n  reg [1:0] cig_zerocnt; \n `ifdef RANDOM_INIT \n  initial begin \n  $random_init(\"q\", \"r_cnt\"); \n  end \n `endif \n  always @(posedge clk) begin \n  r_cnt <= \n  (^c_cnt === 1'bx) ? $random : \n  c_cnt; \n  q <= c_q; \n  end \n  always @ (d or q or r_cnt) begin \n  cig_zerocnt = 2'b0; \n  c_cnt = d ? ~cig_zerocnt : {r_cnt - ((|r_cnt) ? 2'b1 : 2'b0)}; \n  c_q = d | (|r_cnt); \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module acts as a multiplexer to control the speed. It takes in inputs for direct control rate, direct control polarity, send packet rate, send packet polarity, and send packet selection. Based on the value of send packet selection, it outputs the full speed rate and full speed polarity by selecting either the send packet rate and polarity or the direct control rate and polarity. The module uses registers and wires to store and propagate the signals and utilizes an always block to update the outputs based on the input conditions.\n\n Module header:\n\nmodule speedCtrlMux (directCtrlRate, directCtrlPol, sendPacketRate, sendPacketPol, sendPacketSel, fullSpeedRate, fullSpeedPol);\n [/INST]\n", "output": "input directCtrlRate; \n input directCtrlPol; \n input sendPacketRate; \n input sendPacketPol; \n input sendPacketSel; \n output fullSpeedRate; \n output fullSpeedPol; \n wire directCtrlRate; \n wire directCtrlPol; \n wire sendPacketRate; \n wire sendPacketPol; \n wire sendPacketSel; \n reg fullSpeedRate; \n reg fullSpeedPol; \n always @(directCtrlRate or directCtrlPol or sendPacketRate or sendPacketPol or sendPacketSel) \n begin \n  if (sendPacketSel == 1'b1) \n  begin \n  fullSpeedRate <= sendPacketRate; \n  fullSpeedPol <= sendPacketPol; \n  end \n  else \n  begin \n  fullSpeedRate <= directCtrlRate; \n  fullSpeedPol <= directCtrlPol; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is the top-level module for the Nexys4 DDR board. It interfaces with various board components such as LEDs, RGB LEDs, segment displays, switches, and buttons. It also includes a Phase-Locked Loop (PLL) instantiation and a J1Nexys4X core instantiation. The module generates the clock signal for the PMODA and assigns values to it based on write enable. The reset signal is assigned the inversion of the nreset input. The module acts as a bridge between the external board components and the internal logic of the FPGA.\n\n Module header:\n\nmodule Board_Nexys4DDR (nreset,clk100Mhz,extInt,leds,rgbLeds,segments_a,segments_b,segments_c,segments_d,segments_e,segments_f,segments_g,dot,selector,pmodA,sSwitches,pButtons,tck,tms,tdi,tdo,rx,tx);\n [/INST]\n", "output": "input nreset; \n  input clk100Mhz; \n  input [0:0] extInt; \n  input [15:0] sSwitches; \n  input [4:0] pButtons; \n  input tck; \n  input tms; \n  input tdi; \n  input rx; \n  output [15:0] leds; \n  output [5:0] rgbLeds; \n  output tdo; \n  output tx; \n  output segments_a; \n  output segments_b; \n  output segments_c; \n  output segments_d; \n  output segments_e; \n  output segments_f; \n  output segments_g; \n  output dot; \n  output [7:0] selector; \n  inout [7:0] pmodA; \n  wire reset; \n  wire boardClk; \n  wire boardClkLocked; \n  wire [7:0] pmodA_read; \n  wire [7:0] pmodA_write; \n  wire [7:0] pmodA_writeEnable; \n PLL makeClk (.clkIn (clk100Mhz),.clkOut (boardClk),.isLocked (boardClkLocked)); \n J1Nexys4X core (.reset (reset),.boardClk (boardClk),.boardClkLocked (boardClkLocked),.extInt (extInt),.leds (leds),.rgbLeds (rgbLeds),.segments_a (segments_a),.segments_b (segments_b),.segments_c (segments_c),.segments_d (segments_d),.segments_e (segments_e),.segments_f (segments_f),.segments_g (segments_g),.dot (dot),.selector (selector),.pmodA_read (pmodA_read),.pmodA_write (pmodA_write),.pmodA_writeEnable (pmodA_writeEnable),.sSwitches (sSwitches),.pButtons (pButtons),.tck (tck),.tms (tms),.tdi (tdi),.tdo (tdo),.rx (rx),.tx (tx)); \n  assign reset = !nreset; \n  assign pmodA_read = pmodA; \n  genvar i; \n  generate \n  for (i = 0; i < 8; i = i + 1) begin \n  assign pmodA[i] = pmodA_writeEnable[i] ? pmodA_write[i] : 1'bZ; \n  end \n  endgenerate \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, named altera_up_video_alpha_blender_simple, takes in background_data and foreground_data and computes new_red, new_green, and new_blue outputs. The new_red, new_green, and new_blue outputs are determined by using the foreground_data and background_data inputs with the specified bitwise operations. The module performs alpha blending to combine the foreground and background color components to create the new color components.\n\n Module header:\n\nmodule altera_up_video_alpha_blender_simple (background_data,foreground_data,new_red,new_green,new_blue);\n [/INST]\n", "output": "input [29: 0] background_data; \n input [39: 0] foreground_data; \n output [ 9: 0] new_red; \n output [ 9: 0] new_green; \n output [ 9: 0] new_blue; \n assign new_red = \n (({10{foreground_data[39]}} & foreground_data[29:20]) |({10{~foreground_data[39]}} & background_data[29:20])); \n assign new_green = \n (({10{foreground_data[39]}} & foreground_data[19:10]) |({10{~foreground_data[39]}} & background_data[19:10])); \n assign new_blue = \n (({10{foreground_data[39]}} & foreground_data[ 9: 0]) |({10{~foreground_data[39]}} & background_data[ 9: 0])); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a clock control module. It generates control signals for reading and writing to an external device using an auxiliary clock signal. It uses various internal registers to manage the control signals and sequences for reading and writing operations. The module also includes logic for setting the address data based on the entry point and for controlling the timing of the read and write operations. The module produces the clock enable and clock select signals to control the timing of the clock signals. It also generates the start signal, counters, and commands to facilitate the communication with the external device.\n\n Module header:\n\nmodule clock_control (input reset,input aux_clk,input clk_fpga,output [1:0] clk_en,output [1:0] clk_sel,input clk_func,input clk_status,output sen,output sclk,input sdi,output sdo);\n [/INST]\n", "output": "wire read = 1'b0; \n  wire [1:0] w = 2'b00; \n  assign clk_sel = 2'b00; \n  assign clk_en = 2'b11; \n  reg [20:0] addr_data; \n  reg [5:0] entry; \n  reg start; \n  reg [7:0] counter; \n  reg [23:0] command; \n  always @* \n  case(entry) \n  6'd00 : addr_data = {13'h00,8'h10}; \n  6'd01 : addr_data = {13'h45,8'h00}; \n  6'd02 : addr_data = {13'h3D,8'h80}; \n  6'd03 : addr_data = {13'h4B,8'h80}; \n  6'd04 : addr_data = {13'h08,8'h47}; \n  6'd05 : addr_data = {13'h09,8'h70}; \n  6'd06 : addr_data = {13'h0A,8'h04}; \n  6'd07 : addr_data = {13'h0B,8'h00}; \n  6'd08 : addr_data = {13'h0C,8'h01}; \n  6'd09 : addr_data = {13'h0D,8'h00}; \n  6'd10 : addr_data = {13'h07,8'h00}; \n  6'd11 : addr_data = {13'h04,8'h00}; \n  6'd12 : addr_data = {13'h05,8'h00}; \n  6'd13 : addr_data = {13'h06,8'h05}; \n  default : addr_data = {13'h5A,8'h01}; \n  endcase \n  wire [5:0] lastentry = 6'd15; \n  wire done = (counter == 8'd49); \n  always @(posedge aux_clk) \n  if(reset) \n  begin \n  entry <= #1 6'd0; \n  start <= #1 1'b1; \n  end \n  else if(start) \n  start <= #1 1'b0; \n  else if(done && (entry<lastentry)) \n  begin \n  entry <= #1 entry + 6'd1; \n  start <= #1 1'b1; \n  end \n  always @(posedge aux_clk) \n  if(reset) \n  begin \n  counter <= #1 7'd0; \n  command <= #1 20'd0; \n  end \n  else if(start) \n  begin \n  counter <= #1 7'd1; \n  command <= #1 {read,w,addr_data}; \n  end \n  else if( |counter && ~done ) \n  begin \n  counter <= #1 counter + 7'd1; \n  if(~counter[0]) \n  command <= {command[22:0],1'b0}; \n  end \n  assign sen = (done | counter == 8'd0); \n  assign sclk = ~counter[0]; \n  assign sdo = command[23]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is designed to find the maximum absolute value from an input stream of data. It has registers for storing the maximum value, the current input data, and a counter. It also has a register for storing the validity of the input data. The module operates on a clock signal and has a reset signal. When reset is asserted, the registers are initialized. The module compares the current input data with the stored maximum value and updates the maximum if the absolute value of the input is greater. It also increments the counter when valid data is received. When the outgoing data is ready to be read, the module updates the validity flag. Additionally, it sets the tready signal to 1 and outputs the data and validity to an external module.\n\n Module header:\n\nmodule axis_maxabs_finder # (parameter integer AXIS_TDATA_WIDTH = 16,parameter integer CNTR_WIDTH = 32) (input wire aclk,input wire aresetn,input wire [CNTR_WIDTH-1:0] cfg_data,output wire s_axis_tready,input wire [AXIS_TDATA_WIDTH-1:0] s_axis_tdata,input wire s_axis_tvalid,input wire m_axis_tready,output wire [AXIS_TDATA_WIDTH-1:0] m_axis_tdata,output wire m_axis_tvalid);\n [/INST]\n", "output": "reg [AXIS_TDATA_WIDTH-1:0] int_max_reg, int_max_next; \n  reg [AXIS_TDATA_WIDTH-1:0] int_tdata_reg, int_tdata_next; \n  reg [CNTR_WIDTH-1:0] int_cntr_reg, int_cntr_next; \n  reg int_tvalid_reg, int_tvalid_next; \n  wire [AXIS_TDATA_WIDTH-1:0] int_abs_wire; \n  wire int_comp_wire; \n  always @(posedge aclk) \n  begin \n  if(~aresetn) \n  begin \n  int_max_reg <= {(AXIS_TDATA_WIDTH){1'b0}}; \n  int_tdata_reg <= {(AXIS_TDATA_WIDTH){1'b0}}; \n  int_cntr_reg <= {(CNTR_WIDTH){1'b0}}; \n  int_tvalid_reg <= 1'b0; \n  end \n  else \n  begin \n  int_max_reg <= int_max_next; \n  int_tdata_reg <= int_tdata_next; \n  int_cntr_reg <= int_cntr_next; \n  int_tvalid_reg <= int_tvalid_next; \n  end \n  end \n  assign int_comp_wire = int_cntr_reg < cfg_data; \n  assign int_abs_wire = s_axis_tdata[AXIS_TDATA_WIDTH-1] ? ~s_axis_tdata : s_axis_tdata; \n  always @* \n  begin \n  int_max_next = int_max_reg; \n  int_tdata_next = int_tdata_reg; \n  int_cntr_next = int_cntr_reg; \n  int_tvalid_next = int_tvalid_reg; \n  if(s_axis_tvalid & int_comp_wire) \n  begin \n  int_max_next = int_abs_wire > int_max_reg ? int_abs_wire : int_max_reg; \n  int_cntr_next = int_cntr_reg + 1'b1; \n  end \n  if(s_axis_tvalid & ~int_comp_wire) \n  begin \n  int_max_next = {(AXIS_TDATA_WIDTH){1'b0}}; \n  int_tdata_next = int_max_reg; \n  int_cntr_next = {(CNTR_WIDTH){1'b0}}; \n  int_tvalid_next = 1'b1; \n  end \n  if(m_axis_tready & int_tvalid_reg) \n  begin \n  int_tvalid_next = 1'b0; \n  end \n  end \n  assign s_axis_tready = 1'b1; \n  assign m_axis_tdata = int_tdata_reg; \n  assign m_axis_tvalid = int_tvalid_reg; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a 29-bit rotate-left operation by assigning the output to a concatenation of the input bits from indices 3 to 28 followed by the input bits from indices 1 to 2.\n\n Module header:\n\nmodule rol2(o, i);\n [/INST]\n", "output": "output [1:28] o; \n input [1:28] i; \n assign o={i[3:28],i[1:2]}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a FIFO (First-In-First-Out) memory with a specified data width, address width, and RAM depth. It has inputs for clock, reset, enQ (enqueue), and deQ (dequeue), as well as data_in for input data and outputs for data_out, empty, and count. The module uses pointers and a count register to keep track of the empty and full states of the FIFO. It also contains logic to handle the enqueue and dequeue operations, updating the pointers and count accordingly. Additionally, it instantiates a RAM module (RAM_SP_AR) with the specified parameters for data and address widths, and connects it to the internal logic of the FIFO module.\n\n Module header:\n\nmodule FIFO_NoFull_Count(clock, reset, enQ, deQ, data_in, data_out, empty, count);\n [/INST]\n", "output": "parameter DATA_WIDTH = 8; \n  parameter ADDR_WIDTH = 8; \n  parameter RAM_DEPTH = 1 << ADDR_WIDTH; \n  input clock; \n  input reset; \n  input enQ; \n  input deQ; \n  input [(DATA_WIDTH-1):0] data_in; \n  output [(DATA_WIDTH-1):0] data_out; \n  output empty; \n  output reg [(ADDR_WIDTH):0] count; \n  reg [(ADDR_WIDTH-1):0] enQ_ptr, deQ_ptr; \n  wire [(ADDR_WIDTH-1):0] addr = (enQ) ? enQ_ptr : deQ_ptr; \n  assign empty = (count == 0); \n  wire full = (count == (1 << ADDR_WIDTH)); \n  wire [(DATA_WIDTH-1):0] w_data_out; \n  assign data_out = (enQ & deQ) ? data_in : w_data_out; \n  wire w_enQ = enQ & ~(full | deQ); \n  wire w_deQ = deQ & ~(empty | enQ); \n  always @(posedge clock) begin \n  if (reset) begin \n  enQ_ptr <= 0; \n  deQ_ptr <= 0; \n  count <= 0; \n  end \n  else begin \n  enQ_ptr <= (w_enQ) ? enQ_ptr + 1'b1 : enQ_ptr; \n  deQ_ptr <= (w_deQ) ? deQ_ptr + 1'b1 : deQ_ptr; \n  count <= (w_enQ ~^ w_deQ) ? count : ((w_enQ) ? count + 1'b1 : count - 1'b1); \n  end \n  end \n RAM_SP_AR #(.DATA_WIDTH (DATA_WIDTH),.ADDR_WIDTH (ADDR_WIDTH)) \n ram(.clk (clock),.addr (addr),.we (w_enQ),.din (data_in),.dout (w_data_out)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes an input signal A and negates it to produce the output signal Y. It includes parameters for the signedness and widths of the input and output signals. Inside a generate block, it checks if the input signal is signed, and if so, negates the signed input signal; otherwise, it simply negates the input signal directly. The output Y is assigned the result of the negation.\n\n Module header:\n\nmodule \\$not (A, Y);\n [/INST]\n", "output": "parameter A_SIGNED = 0; \n parameter A_WIDTH = 0; \n parameter Y_WIDTH = 0; \n input [A_WIDTH-1:0] A; \n output [Y_WIDTH-1:0] Y; \n generate \n  if (A_SIGNED) begin:BLOCK1 \n  assign Y = ~$signed(A); \n  end else begin:BLOCK2 \n  assign Y = ~A; \n  end \n endgenerate \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a single-read port RAM with configurable data width, address width, and memory size. The RAM is synchronous, and data can be written to it when the write enable signal is asserted. The module also supports reading data from the RAM based on the read address input.\n\n Module header:\n\nmodule RAM_SINGLE_READ_PORT # ( parameter DATA_WIDTH= 16, parameter ADDR_WIDTH=8, parameter MEM_SIZE=8 ) (input wire Clock,input wire iWriteEnable,input wire[ADDR_WIDTH-1:0] iReadAddress,input wire[ADDR_WIDTH-1:0] iWriteAddress,input wire[DATA_WIDTH-1:0] iDataIn,output reg [DATA_WIDTH-1:0] oDataOut);\n [/INST]\n", "output": "reg [DATA_WIDTH-1:0] Ram [MEM_SIZE:0]; \n always @(posedge Clock) \n begin \n  if (iWriteEnable) \n  Ram[iWriteAddress] <= iDataIn; \n  oDataOut <= Ram[iReadAddress]; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a register with a configurable size, which takes an input and updates its output on the positive edge of the clock signal. The output is set to the value of the input.\n\n Module header:\n\nmodule bus_register #(parameter SIZE = 16) (input clk, input [SIZE-1:0] i, output reg [SIZE-1:0] o);\n [/INST]\n", "output": "always @(clk) begin \n  o <= i; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an adaptor that handles multiple fanout connections for a given data width. It takes in clock, reset, data input, and valid input signals, and outputs stall signals and data and valid signals for each fanout connection. It uses a generate block to handle the multiple fanout connections and incorporates logic to manage stall conditions and data consumption. The module ensures that data is correctly distributed to all fanout connections while accounting for stall conditions and reset behavior.\n\n Module header:\n\nmodule acl_multi_fanout_adaptor #(parameter integer DATA_WIDTH = 32,parameter integer NUM_FANOUTS = 2) (input logic clock,input logic resetn,input logic [DATA_WIDTH-1:0] data_in,input logic valid_in,output logic stall_out,output logic [DATA_WIDTH-1:0] data_out,output logic [NUM_FANOUTS-1:0] valid_out,input logic [NUM_FANOUTS-1:0] stall_in);\n [/INST]\n", "output": "genvar i; \n  logic [NUM_FANOUTS-1:0] consumed, true_stall_in; \n  assign true_stall_in = stall_in & ~consumed; \n  assign stall_out = |true_stall_in; \n  generate \n  if( DATA_WIDTH > 0 ) \n  assign data_out = data_in; \n  endgenerate \n  assign valid_out = {NUM_FANOUTS{valid_in}} & ~consumed; \n  generate \n  for( i = 0; i < NUM_FANOUTS; i = i + 1 ) \n  begin:c \n  always @( posedge clock or negedge resetn ) \n  if( !resetn ) \n  consumed[i] <= 1'b0; \n  else if( valid_in & (|true_stall_in) ) \n  begin \n  if( ~stall_in[i] ) \n  consumed[i] <= 1'b1; \n  end \n  else \n  consumed[i] <= 1'b0; \n  end \n  endgenerate \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a FIFO (First-In-First-Out) memory buffer for a Digital-to-Analog Converter (DAC) interface. It receives inputs from a Direct Memory Access (DMA) controller and outputs to the DAC. The module has registers and logic to handle the DMA data, addresses, and transfer requests, as well as the DAC clock and data. It utilizes synchronous logic for address and data processing, and interfaces with an external memory module for the DMA and DAC data operations. Overall, it serves as an intermediary data buffer between the DMA controller and the DAC.\n\n Module header:\n\nmodule util_dacfifo (dma_clk,dma_rst,dma_valid,dma_data,dma_ready,dma_xfer_req,dma_xfer_last,dac_clk,dac_valid,dac_data);\n [/INST]\n", "output": "parameter ADDR_WIDTH = 6; \n  parameter DATA_WIDTH = 128; \n  input dma_clk; \n  input dma_rst; \n  input dma_valid; \n  input [(DATA_WIDTH-1):0] dma_data; \n  output dma_ready; \n  input dma_xfer_req; \n  input dma_xfer_last; \n  input dac_clk; \n  input dac_valid; \n  output [(DATA_WIDTH-1):0] dac_data; \n  reg [(ADDR_WIDTH-1):0] dma_waddr = 'b0; \n  reg [(ADDR_WIDTH-1):0] dma_lastaddr = 'b0; \n  reg [(ADDR_WIDTH-1):0] dma_lastaddr_d = 'b0; \n  reg [(ADDR_WIDTH-1):0] dma_lastaddr_2d = 'b0; \n  reg dma_xfer_req_ff = 1'b0; \n  reg dma_ready = 1'b0; \n  reg [(ADDR_WIDTH-1):0] dac_raddr = 'b0; \n  reg [(DATA_WIDTH-1):0] dac_data = 'b0; \n  wire dma_wren; \n  wire [(DATA_WIDTH-1):0] dac_data_s; \n  always @(posedge dma_clk) begin \n  if(dma_rst == 1'b1) begin \n  dma_ready <= 1'b0; \n  dma_xfer_req_ff <= 1'b0; \n  end else begin \n  dma_ready <= 1'b1; \n  dma_xfer_req_ff <= dma_xfer_req; \n  end \n  end \n  always @(posedge dma_clk) begin \n  if(dma_rst == 1'b1) begin \n  dma_waddr <= 'b0; \n  dma_lastaddr <= 'b0; \n  end else begin \n  if (dma_valid && dma_xfer_req) begin \n  dma_waddr <= dma_waddr + 1; \n  end \n  if (dma_xfer_last) begin \n  dma_lastaddr <= dma_waddr; \n  dma_waddr <= 'b0; \n  end \n  end \n  end \n  assign dma_wren = dma_valid & dma_xfer_req; \n  always @(posedge dac_clk) begin \n  dma_lastaddr_d <= dma_lastaddr; \n  dma_lastaddr_2d <= dma_lastaddr_d; \n  end \n  always @(posedge dac_clk) begin \n  if(dac_valid == 1'b1) begin \n  if (dma_lastaddr_2d == 'h0) begin \n  dac_raddr <= dac_raddr + 1; \n  end else begin \n  dac_raddr <= (dac_raddr < dma_lastaddr_2d) ? (dac_raddr + 1) : 'b0; \n  end \n  end \n  dac_data <= dac_data_s; \n  end \n ad_mem #(.ADDR_WIDTH (ADDR_WIDTH),.DATA_WIDTH (DATA_WIDTH)) \n i_mem_fifo (.clka (dma_clk),.wea (dma_wren),.addra (dma_waddr),.dina (dma_data),.clkb (dac_clk),.addrb (dac_raddr),.doutb (dac_data_s)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module defines a constant signal generator, which outputs a 32-bit signal. The signal is always set to a specific constant value of all zeros. The module takes inputs for clock, clock enable, and clear, but these inputs do not affect the constant output.\n\n Module header:\n\nmodule sysgen_constant_a73b1fb775 (output [(32 - 1):0] op,input clk,input ce,input clr);\n [/INST]\n", "output": "assign op = 32'b00000000000000000000000000000000; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes three input signals A, B, and Cin, and generates two output signals Q and Cout. The output Q is computed as the XOR of A, B, and Cin. The output Cout is computed as the result of the logical OR operation on A and B, A and Cin, and B and Cin.\n\n Module header:\n\nmodule add1(input A, input B, input Cin, output Q, output Cout);\n [/INST]\n", "output": "assign Q = A ^ B ^ Cin; \n  assign Cout = A&B | A&Cin | B&Cin; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a UART (Universal Asynchronous Receiver/Transmitter) core with input and output signals for communication. The module includes logic for transmitting and receiving data, as well as handling control signals such as ready, valid, and flow control (RTS and CTS). It also interfaces with the LED display to show the transmitted data. The UART core is clocked and reset using the provided clk and rst signals. The module continuously processes incoming data, manages transmission, and sets the appropriate control signals based on the incoming and outgoing data.\n\n Module header:\n\nmodule fpga_core (input wire clk,input wire rst,input wire btnu,input wire btnl,input wire btnd,input wire btnr,input wire btnc,input wire [7:0] sw,output wire [7:0] led,input wire uart_rxd,output wire uart_txd,output wire uart_rts,input wire uart_cts);\n [/INST]\n", "output": "reg [7:0] uart_tx_axis_tdata; \n reg uart_tx_axis_tvalid; \n wire uart_tx_axis_tready; \n wire [7:0] uart_rx_axis_tdata; \n wire uart_rx_axis_tvalid; \n reg uart_rx_axis_tready; \n assign uart_rts = 1'b1; \n uart \n uart_inst (.clk(clk),.rst(rst),.s_axis_tdata(uart_tx_axis_tdata),.s_axis_tvalid(uart_tx_axis_tvalid),.s_axis_tready(uart_tx_axis_tready),.m_axis_tdata(uart_rx_axis_tdata),.m_axis_tvalid(uart_rx_axis_tvalid),.m_axis_tready(uart_rx_axis_tready),.rxd(uart_rxd),.txd(uart_txd),.tx_busy(),.rx_busy(),.rx_overrun_error(),.rx_frame_error(),.prescale(125000000/(9600*8))); \n assign led = uart_tx_axis_tdata; \n always @(posedge clk or posedge rst) begin \n  if (rst) begin \n  uart_tx_axis_tdata <= 0; \n  uart_tx_axis_tvalid <= 0; \n  uart_rx_axis_tready <= 0; \n  end else begin \n  if (uart_tx_axis_tvalid) begin \n  uart_rx_axis_tready <= 0; \n  if (uart_tx_axis_tready) begin \n  uart_tx_axis_tvalid <= 0; \n  end \n  end else begin \n  uart_rx_axis_tready <= 1; \n  if (uart_rx_axis_tvalid) begin \n  uart_rx_axis_tready <= ~uart_rx_axis_tready; \n  uart_tx_axis_tdata <= uart_rx_axis_tdata; \n  uart_tx_axis_tvalid <= 1; \n  end \n  end \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a register file with a parameterized size of 16 bits. It has an input x, a clock input clk, a load input ld, and an output register r. When the load input is asserted, the value of x is loaded into the register. Otherwise, the register retains its current value. The module operates on the positive edge of the clock signal.\n\n Module header:\n\nmodule regfile1 (clk,x,ld,r,r);\n [/INST]\n", "output": "parameter n = 16; \n input clk; \n input [n - 1: 0] x; \n input ld; \n output reg [n-1:0] r; \n always @(posedge clk) begin \n  if (ld) begin \n  r <= x; \n  end else begin \n  r <= r; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module acl_fp_custom_clz takes a 27-bit mantissa as input and outputs a 5-bit result and an all_zero flag. The result is calculated based on the pattern of 1s and 0s in the mantissa, with each bit of the result encoding a specific pattern in the mantissa. The all_zero flag indicates whether all bits in the mantissa are clear.\n\n Module header:\n\nmodule acl_fp_custom_clz(mantissa, result, all_zero);\n [/INST]\n", "output": "input [26:0] mantissa; \n  output [4:0] result; \n  output all_zero; \n  wire top_16 = ~|mantissa[26:11]; \n  wire top_8 = ~|mantissa[26:19]; \n  wire top_4 = ~|mantissa[26:23]; \n  wire top_2 = ~|mantissa[26:25]; \n  wire bottom_8 = ~(|mantissa[10:3]); \n  wire bottom_4 = ~(|mantissa[10:7]); \n  wire bottom_2 = ~(|mantissa[10:9]); \n  wire all_clear = ~|mantissa; \n  assign result[4] = top_16; \n  assign result[3] = top_16 & bottom_8 | ~top_16 & top_8; \n  assign result[2] = (top_16 & ~bottom_8 & bottom_4) | (~top_16 & top_8 & ~|mantissa[18:15]) | \n  (~top_16 & ~top_8 & top_4); \n  assign result[1] = (top_16 & bottom_8 & ~|mantissa[2:1]) | (top_16 & ~bottom_8 & bottom_4 & ~|mantissa[6:5]) | \n  (top_16 & ~bottom_8 & ~bottom_4 & bottom_2) | \n  (~top_16 & top_8 & ~|mantissa[18:17] & |mantissa[16:15]) | \n  (~top_16 & top_8 & ~|mantissa[18:13]) | \n  (~top_16 & ~top_8 & top_4 & ~|mantissa[22:21]) | \n  (~top_16 & ~top_8 & ~top_4 & top_2); \n  assign result[0] = (all_clear) | \n  (~|mantissa[26:2] & mantissa[1]) | \n  (~|mantissa[26:4] & mantissa[3]) | \n  (~|mantissa[26:6] & mantissa[5]) | \n  (~|mantissa[26:8] & mantissa[7]) | \n  (~|mantissa[26:10] & mantissa[9]) | \n  (~|mantissa[26:12] & mantissa[11]) | \n  (~|mantissa[26:14] & mantissa[13]) | \n  (~|mantissa[26:16] & mantissa[15]) | \n  (~|mantissa[26:18] & mantissa[17]) | \n  (~|mantissa[26:20] & mantissa[19]) | \n  (~|mantissa[26:22] & mantissa[21]) | \n  (~|mantissa[26:24] & mantissa[23]) | \n  (~mantissa[26] & mantissa[25]); \n  assign all_zero = all_clear; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `ddr3_s4_uniphy_example_if0_p0_qsys_sequencer_cpu_inst_nios2_oci_dtrace` is a sequencer for a DDR3 memory interface. It takes in clock signals, memory access signals, address and data signals, as well as control signals. The module pads the input signals to 32 bits and generates trace control signals based on the input control signals. The `atm` and `dtm` outputs are updated based on the input signals and the control signals. The module also has a reset condition that sets `atm` and `dtm` to 0 when the reset signal `jrst_n` is asserted.\n\nThe functionality includes generating memory access sequences for read and write operations based on the input signals and the trace control signals. It also handles the padding of input signals and the reset of the output signals.\n\n Module header:\n\nmodule ddr3_s4_uniphy_example_if0_p0_qsys_sequencer_cpu_inst_nios2_oci_dtrace (clk,cpu_d_address,cpu_d_read,cpu_d_readdata,cpu_d_wait,cpu_d_write,cpu_d_writedata,jrst_n,trc_ctrl,atm,dtm);\n [/INST]\n", "output": "output [ 35: 0] atm; \n  output [ 35: 0] dtm; \n  input clk; \n  input [ 18: 0] cpu_d_address; \n  input cpu_d_read; \n  input [ 31: 0] cpu_d_readdata; \n  input cpu_d_wait; \n  input cpu_d_write; \n  input [ 31: 0] cpu_d_writedata; \n  input jrst_n; \n  input [ 15: 0] trc_ctrl; \n  reg [ 35: 0] atm ; \n  wire [ 31: 0] cpu_d_address_0_padded; \n  wire [ 31: 0] cpu_d_readdata_0_padded; \n  wire [ 31: 0] cpu_d_writedata_0_padded; \n  reg [ 35: 0] dtm ; \n  wire record_load_addr; \n  wire record_load_data; \n  wire record_store_addr; \n  wire record_store_data; \n  wire [ 3: 0] td_mode_trc_ctrl; \n  assign cpu_d_writedata_0_padded = cpu_d_writedata | 32'b0; \n  assign cpu_d_readdata_0_padded = cpu_d_readdata | 32'b0; \n  assign cpu_d_address_0_padded = cpu_d_address | 32'b0; \n  ddr3_s4_uniphy_example_if0_p0_qsys_sequencer_cpu_inst_nios2_oci_td_mode ddr3_s4_uniphy_example_if0_p0_qsys_sequencer_cpu_inst_nios2_oci_trc_ctrl_td_mode \n (.ctrl (trc_ctrl[8 : 0]),.td_mode (td_mode_trc_ctrl)); \n  assign {record_load_addr, record_store_addr, \n  record_load_data, record_store_data} = td_mode_trc_ctrl; \n  always @(posedge clk or negedge jrst_n) \n  begin \n  if (jrst_n == 0) \n  begin \n  atm <= 0; \n  dtm <= 0; \n  end \n  else if (0) \n  begin \n  if (cpu_d_write & ~cpu_d_wait & record_store_addr) \n  atm <= {4'b0101, cpu_d_address_0_padded}; \n  else if (cpu_d_read & ~cpu_d_wait & record_load_addr) \n  atm <= {4'b0100, cpu_d_address_0_padded}; \n  else \n  atm <= {4'b0000, cpu_d_address_0_padded}; \n  if (cpu_d_write & ~cpu_d_wait & record_store_data) \n  dtm <= {4'b0111, cpu_d_writedata_0_padded}; \n  else if (cpu_d_read & ~cpu_d_wait & record_load_data) \n  dtm <= {4'b0110, cpu_d_readdata_0_padded}; \n  else \n  dtm <= {4'b0000, cpu_d_readdata_0_padded}; \n  end \n  else \n  begin \n  atm <= 0; \n  dtm <= 0; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a RAM with dual-port read and single-port write capability. It has address and data inputs for writing, and separate address inputs for the two read ports. The write enable signal controls the writing process, and the data outputs are updated based on the read addresses. The module also includes an initialization block for the internal data storage and uses a clocked process to handle the read and write operations. Additionally, it includes conditional compilation directives for simulation and FPGA implementation. In the simulation mode, the module uses internal registers for data storage and manipulation, while in the FPGA mode, it interfaces with an actual RAM block.\n\n Module header:\n\nmodule RAMDP(clock,reset,we,addr0,addr1,data_i,data_o0,data_o1);\n [/INST]\n", "output": "parameter AddrSize = 8; \n  parameter DataSize = 8; \n  input wire clock; \n  input wire reset; \n  input wire we; \n  input wire [AddrSize-1:0] addr0; \n  input wire [AddrSize-1:0] addr1; \n  input wire [DataSize-1:0] data_i; \n `ifdef SIM \n  output reg [DataSize-1:0] data_o0; \n  output reg [DataSize-1:0] data_o1; \n  reg [DataSize-1:0] s_Data[2**AddrSize-1:0]; \n  reg [AddrSize:0] k; \n  initial begin \n  for (k = 0; k < 2**AddrSize; k = k + 1) begin \n  s_Data[k] = 0; \n  end \n  end \n  always @ (posedge clock) begin \n  if (reset) begin \n  data_o0 <= 0; \n  data_o1 <= 0; \n  end \n  else begin \n  if (we) begin \n  s_Data[addr0] <= data_i; \n  end \n  data_o0 <= s_Data[addr0]; \n  data_o1 <= s_Data[addr1]; \n  end \n  end \n `endif \n `ifdef FPGA \n  output wire [DataSize-1:0] data_o0; \n  output wire [DataSize-1:0] data_o1; \n  RAMB16_S1_S1 \n ramse (.CLKA(clock),.CLKB(clock),.SSRA(reset),.SSRB(reset),.ENA(~reset),.WEA(we),.ADDRA(addr0),.DIA(data_i),.DOA(data_o0),.ENB(~reset),.WEB(0),.ADDRB(addr1),.DIB(1'b0),.DOB(data_o1)); \n `endif \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements an AXI interface for a dual-channel digital-to-analog converter (DAC). It takes in clock signals and DAC data inputs, and outputs a combined 128-bit data signal and a DAC clock signal. The module uses the input clock signal for the DAC clock and assigns the DAC clock to the input clock signal.\n\nThe module registers the combined data signal and updates it based on the DAC data inputs and the input clock signal. When the DAC reset signal is asserted, the module resets the combined data signal. Otherwise, it rearranges the DAC data inputs into the combined data signal according to specific bit positions.\n\n Module header:\n\nmodule axi_ad9152_if (tx_clk,tx_data,dac_clk,dac_rst,dac_data_0_0,dac_data_0_1,dac_data_0_2,dac_data_0_3,dac_data_1_0,dac_data_1_1,dac_data_1_2,dac_data_1_3);\n [/INST]\n", "output": "input tx_clk; \n  output [127:0] tx_data; \n  output dac_clk; \n  input dac_rst; \n  input [15:0] dac_data_0_0; \n  input [15:0] dac_data_0_1; \n  input [15:0] dac_data_0_2; \n  input [15:0] dac_data_0_3; \n  input [15:0] dac_data_1_0; \n  input [15:0] dac_data_1_1; \n  input [15:0] dac_data_1_2; \n  input [15:0] dac_data_1_3; \n  reg [127:0] tx_data = 'd0; \n  assign dac_clk = tx_clk; \n  always @(posedge dac_clk) begin \n  if (dac_rst == 1'b1) begin \n  tx_data <= 128'd0; \n  end else begin \n  tx_data[127:120] <= dac_data_1_3[ 7: 0]; \n  tx_data[119:112] <= dac_data_1_2[ 7: 0]; \n  tx_data[111:104] <= dac_data_1_1[ 7: 0]; \n  tx_data[103: 96] <= dac_data_1_0[ 7: 0]; \n  tx_data[ 95: 88] <= dac_data_1_3[15: 8]; \n  tx_data[ 87: 80] <= dac_data_1_2[15: 8]; \n  tx_data[ 79: 72] <= dac_data_1_1[15: 8]; \n  tx_data[ 71: 64] <= dac_data_1_0[15: 8]; \n  tx_data[ 63: 56] <= dac_data_0_3[ 7: 0]; \n  tx_data[ 55: 48] <= dac_data_0_2[ 7: 0]; \n  tx_data[ 47: 40] <= dac_data_0_1[ 7: 0]; \n  tx_data[ 39: 32] <= dac_data_0_0[ 7: 0]; \n  tx_data[ 31: 24] <= dac_data_0_3[15: 8]; \n  tx_data[ 23: 16] <= dac_data_0_2[15: 8]; \n  tx_data[ 15: 8] <= dac_data_0_1[15: 8]; \n  tx_data[ 7: 0] <= dac_data_0_0[15: 8]; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a top-level module that interfaces with a computer module and a hex_to_7seg module. It takes an input clock and a reset signal, and provides outputs to control LEDs and segment displays. The module uses the display_out signal from the computer module to drive the hex_to_7seg modules for upper and lower digits. The hlt signal from the computer module is used to control o_LED_1. o_LED_2, o_LED_3, and o_LED_4 are controlled directly with logic 0, logic 1, and logic 0, respectively.\n\n Module header:\n\nmodule grom_top (input i_Clk,input i_Switch_1,output o_LED_1,output o_LED_2,output o_LED_3,output o_LED_4,output o_Segment1_A,output o_Segment1_B,output o_Segment1_C,output o_Segment1_D,output o_Segment1_E,output o_Segment1_F,output o_Segment1_G,output o_Segment2_A,output o_Segment2_B,output o_Segment2_C,output o_Segment2_D,output o_Segment2_E,output o_Segment2_F,output o_Segment2_G);\n [/INST]\n", "output": "wire [7:0] display_out; \n  wire hlt; \n  grom_computer computer(.clk(i_Clk),.reset(i_Switch_1),.hlt(hlt),.display_out(display_out)); \n  hex_to_7seg upper_digit \n (.i_Clk(i_Clk),.i_Value(display_out[7:4]),.o_Segment_A(o_Segment1_A),.o_Segment_B(o_Segment1_B),.o_Segment_C(o_Segment1_C),.o_Segment_D(o_Segment1_D),.o_Segment_E(o_Segment1_E),.o_Segment_F(o_Segment1_F),.o_Segment_G(o_Segment1_G)); \n  hex_to_7seg lower_digit \n (.i_Clk(i_Clk),.i_Value(display_out[3:0]),.o_Segment_A(o_Segment2_A),.o_Segment_B(o_Segment2_B),.o_Segment_C(o_Segment2_C),.o_Segment_D(o_Segment2_D),.o_Segment_E(o_Segment2_E),.o_Segment_F(o_Segment2_F),.o_Segment_G(o_Segment2_G)); \n  assign o_LED_1 = hlt; \n  assign o_LED_2 = 1'b0; \n  assign o_LED_3 = 1'b1; \n  assign o_LED_4 = 1'b0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module is a testbench for a period check module. It uses a clock signal, reset signal, power down signal, and period length input to test the stability of the period. The module monitors the period_stable signal and increments pass_count or fail_count based on the results of various checks. It simulates different scenarios such as resetting the period, changing the period length, and checking for stable and unstable periods. At the end, it calculates the percentage of passed test cases and finishes the simulation. The module ensures that the period check module functions correctly under different conditions.\n\n Module header:\n\nmodule period_check_tb ();\n [/INST]\n", "output": "reg RST; \n  reg PWRDWN; \n  reg clk; \n  reg [31:0] period_length; \n  wire period_stable; \n  integer pass_count; \n  integer fail_count; \n  localparam total = 6; \n period_check dut(.RST(RST),.PWRDWN(PWRDWN),.clk(clk),.period_length(period_length),.period_stable(period_stable)); \n  initial begin \n  $dumpfile(\"period_check_tb.vcd\"); \n  $dumpvars(0, period_check_tb); \n  RST = 0; \n  PWRDWN = 0; \n  clk = 0; \n  period_length = 20; \n  pass_count = 0; \n  fail_count = 0; \n  #10; \n  RST = 1; \n  #10; \n  if (period_stable === 1'b0) begin \n  $display(\"PASSED: RST\"); \n  pass_count = pass_count + 1; \n  end else begin \n  $display(\"FAILED: RST\"); \n  fail_count = fail_count + 1; \n  end \n  RST = 0; \n  #(period_length * 2) \n  if (period_stable === 1'b1) begin \n  $display(\"PASSED: period stable\"); \n  pass_count = pass_count + 1; \n  end else begin \n  $display(\"FAILED: period stable\"); \n  fail_count = fail_count + 1; \n  end \n  period_length = 10; \n  #((period_length / 2.0) + 1); \n  if (period_stable === 1'b0) begin \n  $display(\"PASSED: period unstable\"); \n  pass_count = pass_count + 1; \n  end else begin \n  $display(\"FAILED: period unstable\"); \n  fail_count = fail_count + 1; \n  end \n  #(period_length - 1); \n  if (period_stable === 1'b0) begin \n  $display(\"PASSED: period still unstable\"); \n  pass_count = pass_count + 1; \n  end else begin \n  $display(\"FAILED: period still unstable\"); \n  fail_count = fail_count + 1; \n  end \n  #1; \n  if (period_stable === 1'b1) begin \n  $display(\"PASSED: period stable again\"); \n  pass_count = pass_count + 1; \n  end else begin \n  $display(\"FAILED: period stable again\"); \n  fail_count = fail_count + 1; \n  end \n  PWRDWN = 1; \n  #10; \n  if (period_stable === 1'bx) begin \n  $display(\"PASSED: PWRDWN\"); \n  pass_count = pass_count + 1; \n  end else begin \n  $display(\"FAILED: PWRDWN\"); \n  fail_count = fail_count + 1; \n  end \n  if ((pass_count + fail_count) == total) begin \n  $display(\"PASSED: number of test cases\"); \n  pass_count = pass_count + 1; \n  end else begin \n  $display(\"FAILED: number of test cases\"); \n  fail_count = fail_count + 1; \n  end \n  $display(\"%0d/%0d PASSED\", pass_count, (total + 1)); \n  $finish; \n  end \n  always #(period_length / 2.0) clk <= ~clk; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"DebugAndPathTest\" is a test module for a digital system that involves clock signals, global reset signals, UART communication pins, ALU zero and overflow signals, UART count, UART baud rate generation, and UART data transmission. The module instantiates submodules like Datapath1, UART_baud_rate_generator, and UART_tx to test the functionality of these components. It initializes the signals, generates clock signals, and sets/reset data transmission, and waits for specified intervals to test the behavior of the system.\n\n Module header:\n\nmodule DebugAndPathTest;\n [/INST]\n", "output": "reg clock; \n  reg resetGral; \n  wire uartRxPin; \n  wire uartTxPin; \n  wire ALUzero; \n  wire ALUOverflow; \n  localparam uart_COUNT = 651; \n  reg txStart=1; \n  reg[7:0] dataPC; \n Datapath1 uut (.clock(clock),.resetGral(resetGral),.uartRxPin(uartRxPin),.uartTxPin(uartTxPin),.ALUzero(ALUzero),.ALUOverflow(ALUOverflow)); \n UART_baud_rate_generator #(.COUNT(uart_COUNT*16)) tx_baud_rate(.clock(clock),.baud_rate(baud_rate_tx)); \n UART_tx transmisorPC(.clock(clock),.reset(resetGral),.s_tick(baud_rate_tx),.tx_start(txStart),.data_in(dataPC),.tx(uartRxPin),.tx_done(txDone)); \n  initial begin \n  clock = 0; \n  resetGral = 1; \n  txStart=1; \n  #100; \n  resetGral=0; \n  #100; \n  dataPC=115; \n  #10; \n  txStart=0; \n  #5; \n  txStart=1; \n  #500000; \n  dataPC=110; \n  #10; \n  txStart=0; \n  #5; \n  txStart=1; \n  end \n  always begin \n  clock=~clock; \n  #1; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module is for a UART, a universal asynchronous receiver-transmitter. It takes in clock and reset signals, and handles serial input and output. It also has inputs for transmit data, transmit control, and baud rate parameters. The module contains submodules for baud rate generation, UART receiving, and UART transmission. The baud rate generator generates a clock signal for the UART components based on the baud frequency and limit. The UART receiver processes the serial input and outputs received data, while the UART transmitter takes in data to be transmitted and handles the serial output.\n\n Module header:\n\nmodule uart_top (clock, reset,ser_in, ser_out,rx_data, new_rx_data,tx_data, new_tx_data, tx_busy,baud_freq, baud_limit,baud_clk);\n [/INST]\n", "output": "input clock; \n input reset; \n input ser_in; \n output ser_out; \n input [7:0] tx_data; \n input new_tx_data; \n output tx_busy; \n output [7:0] rx_data; \n output new_rx_data; \n input [11:0] baud_freq; \n input [15:0] baud_limit; \n output baud_clk; \n wire ce_16; \n assign baud_clk = ce_16; \n baud_gen baud_gen_1 \n (.clock(clock), .reset(reset),.ce_16(ce_16), .baud_freq(baud_freq), .baud_limit(baud_limit)); \n uart_rx uart_rx_1 \n (.clock(clock), .reset(reset),.ce_16(ce_16), .ser_in(ser_in),.rx_data(rx_data), .new_rx_data(new_rx_data)); \n uart_tx uart_tx_1 \n (.clock(clock), .reset(reset),.ce_16(ce_16), .tx_data(tx_data), .new_tx_data(new_tx_data),.ser_out(ser_out), .tx_busy(tx_busy)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an up/down counter with a 2-digit output. It counts up or down based on the input signals enUP and enDOWN, and the count value is displayed on the data_HH output. The counter uses a 5-bit register to store the current count and updates the count based on the input signals and the current count value. The outputs digit1 and digit0 represent the individual digits of the count, and the data_HH output combines these digits for display.\n\n Module header:\n\nmodule contador_AD_HH_2dig (input wire clk,input wire reset,input wire [3:0]en_count,input wire enUP,input wire enDOWN,output wire [7:0] data_HH);\n [/INST]\n", "output": "localparam N = 5; \n reg [N-1:0] q_act, q_next; \n wire [N-1:0] count_data; \n reg [3:0] digit1, digit0; \n always@(posedge clk, posedge reset) \n begin \n  if(reset) \n  begin \n  q_act <= 5'b0; \n  end \n  else \n  begin \n  q_act <= q_next; \n  end \n end \n always@* \n begin \n  if (en_count == 3) \n  begin \n  if (enUP) \n  begin \n  if (q_act >= 5'd23) q_next = 5'd0; \n  else q_next = q_act + 5'd1; \n  end \n  else if (enDOWN) \n  begin \n  if (q_act == 5'd0) q_next = 5'd23; \n  else q_next = q_act - 5'd1; \n  end \n  else q_next = q_act; \n  end \n  else q_next = q_act; \n end \n assign count_data = q_act; \n always@* \n begin \n  case(count_data) \n  5'd0: begin digit1 = 4'b0000; digit0 = 4'b0000; end \n  5'd1: begin digit1 = 4'b0000; digit0 = 4'b0001; end \n  5'd2: begin digit1 = 4'b0000; digit0 = 4'b0010; end \n  5'd3: begin digit1 = 4'b0000; digit0 = 4'b0011; end \n  5'd4: begin digit1 = 4'b0000; digit0 = 4'b0100; end \n  5'd5: begin digit1 = 4'b0000; digit0 = 4'b0101; end \n  5'd6: begin digit1 = 4'b0000; digit0 = 4'b0110; end \n  5'd7: begin digit1 = 4'b0000; digit0 = 4'b0111; end \n  5'd8: begin digit1 = 4'b0000; digit0 = 4'b1000; end \n  5'd9: begin digit1 = 4'b0000; digit0 = 4'b1001; end \n  5'd10: begin digit1 = 4'b0001; digit0 = 4'b0000; end \n  5'd11: begin digit1 = 4'b0001; digit0 = 4'b0001; end \n  5'd12: begin digit1 = 4'b0001; digit0 = 4'b0010; end \n  5'd13: begin digit1 = 4'b0001; digit0 = 4'b0011; end \n  5'd14: begin digit1 = 4'b0001; digit0 = 4'b0100; end \n  5'd15: begin digit1 = 4'b0001; digit0 = 4'b0101; end \n  5'd16: begin digit1 = 4'b0001; digit0 = 4'b0110; end \n  5'd17: begin digit1 = 4'b0001; digit0 = 4'b0111; end \n  5'd18: begin digit1 = 4'b0001; digit0 = 4'b1000; end \n  5'd19: begin digit1 = 4'b0001; digit0 = 4'b1001; end \n  5'd20: begin digit1 = 4'b0010; digit0 = 4'b0000; end \n  5'd21: begin digit1 = 4'b0010; digit0 = 4'b0001; end \n  5'd22: begin digit1 = 4'b0010; digit0 = 4'b0010; end \n  5'd23: begin digit1 = 4'b0010; digit0 = 4'b0011; end \n  default: begin digit1 = 0; digit0 = 0; end \n  endcase \n end \n assign data_HH = {digit1,digit0}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a logical operation using the input signals A, B, and PHI to generate the outputs POUT and GOUT. The POUT output is the negation of the logical OR operation of A and B, while the GOUT output is the negation of the logical AND operation of A and B.\n\n Module header:\n\nmodule BLOCK0 ( A, B, PHI, POUT, GOUT );\n [/INST]\n", "output": "input A; \n input B; \n input PHI; \n output POUT; \n output GOUT; \n  assign POUT = ~ (A | B); \n  assign GOUT = ~ (A & B); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a fixed configuration memory module with a specified LUT_SIZE and NUM_STAGES. It has an input address_in and clock, and an output q. The module contains a RAM initialized from an external file, and on every clock edge, it reads the memory at the given address_in and assigns the value to the output q.\n\n Module header:\n\nmodule fixed_config (address_in,clock,q);\n [/INST]\n", "output": "parameter LUT_SIZE = 6; \n  parameter NUM_STAGES = 78; \n  input [31:0] address_in; \n  input clock; \n  output [31:0] q; \n  reg [31:0] ram[0:(2**LUT_SIZE)*NUM_STAGES]; \n  reg [31:0] q; \n  initial \n  begin \n  $readmemh(\"output.hex.mif\",ram); \n  end \n  always@(posedge clock) \n  begin \n  q = ram[address_in]; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a constant generator that outputs a single-bit value of 0. The output op is driven by this constant value and is not dependent on the inputs clk, ce, or clr.\n\n Module header:\n\nmodule sysgen_constant_0ba576828b (output [(1 - 1):0] op,input clk,input ce,input clr);\n [/INST]\n", "output": "assign op = 1'b0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a Seven Segment LED decoder. It takes a 4-bit input i_data and decodes it into the corresponding 7-segment LED outputs o_a through o_g based on the input. The module includes a decoder function that uses a case statement to map each input to the appropriate 7-segment LED output. The output of the decoder function is then assigned to the wire w_out, and each bit of w_out is assigned to the respective segment output.\n\n Module header:\n\nmodule SevenSegmentLED(i_data,o_a,o_b,o_c,o_d,o_e,o_f,o_g);\n [/INST]\n", "output": "input [3:0] i_data; \n  output o_a; \n  output o_b; \n  output o_c; \n  output o_d; \n  output o_e; \n  output o_f; \n  output o_g; \n  wire [6:0] w_out; \n  function [6:0] Decode; \n  input [3:0] data; \n  begin \n  case (i_data) \n  4'h0: Decode = 7'b0000001; \n  4'h1: Decode = 7'b1001111; \n  4'h2: Decode = 7'b0010010; \n  4'h3: Decode = 7'b0000110; \n  4'h4: Decode = 7'b1001100; \n  4'h5: Decode = 7'b0100100; \n  4'h6: Decode = 7'b0100000; \n  4'h7: Decode = 7'b0001111; \n  4'h8: Decode = 7'b0000000; \n  4'h9: Decode = 7'b0000100; \n  4'ha: Decode = 7'b0001000; \n  4'hb: Decode = 7'b1100000; \n  4'hc: Decode = 7'b0110001; \n  4'hd: Decode = 7'b1000010; \n  4'he: Decode = 7'b0110000; \n  4'hf: Decode = 7'b0111000; \n  endcase \n  end \n  endfunction \n  assign w_out = Decode(i_data); \n  assign o_a = w_out[6]; \n  assign o_b = w_out[5]; \n  assign o_c = w_out[4]; \n  assign o_d = w_out[3]; \n  assign o_e = w_out[2]; \n  assign o_f = w_out[1]; \n  assign o_g = w_out[0]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a 4-bit binary counter with enable and load control. It utilizes a negative edge-triggered flip-flop for the clear and load inputs, and a positive edge-triggered flip-flop for the clock input. The counter can increment or decrement based on the M input. The counter output Q and the complemented Qcc_n are updated accordingly based on the inputs and clock signal.\n\n Module header:\n\nmodule _4bit_binary_counter(input CP,input M,input [3:0] D,input LD_n,input CLR_n,output reg [3:0] Q,output reg Qcc_n);\n [/INST]\n", "output": "always @(negedge CLR_n or negedge LD_n or posedge CP) begin \n  if (Qcc_n == 0) begin \n  Qcc_n = 1; \n  end \n  if (!CLR_n) begin \n  {Qcc_n, Q} <= 5'b10000; \n  end \n  else if (!LD_n) begin \n  {Qcc_n, Q} <= {1'b1, D}; \n  end \n  else if(CP) begin \n  if (M) begin \n  {Qcc_n, Q} <= {Qcc_n,Q} + 1; \n  end \n  else begin \n  {Qcc_n, Q} <= {Qcc_n,Q} - 1; \n  end \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an address decoder. It takes an input address and decodes it to generate bank addresses, a select signal, and an odd signal. The module uses clocked registers to delay the input signals and then uses a case statement to determine the bank addresses based on the input address. The module also outputs the select and odd signals based on the delayed input signals.\n\n Module header:\n\nmodule addrdecode(clk,addr_in,bank0_addr,bank1_addr,bank2_addr,bank3_addr,sel,odd);\n [/INST]\n", "output": "input clk; \n input [12:0]addr_in; \n output [9:0]bank0_addr; \n output [9:0]bank1_addr; \n output [9:0]bank2_addr; \n output [9:0]bank3_addr; \n output [1:0]sel; \n output odd; \n reg [9:0] bank0_addr; \n reg [9:0] bank1_addr; \n reg [9:0] bank2_addr; \n reg [9:0] bank3_addr; \n reg [1:0] sel_dlya; \n reg [1:0] sel_dlyb; \n reg [1:0] sel; \n reg odd_dlya; \n reg odd_dlyb; \n reg odd; \n wire [9:0] addr = addr_in[12:3]; \n wire [9:0] addr_pone = addr_in[12:3] + 1; \n always@(posedge clk) begin \n  odd_dlya <= addr_in[0]; \n  sel_dlya <= addr_in[2:1]; \n  end \n always@(posedge clk) begin \n  odd_dlyb <= odd_dlya; \n  sel_dlyb <= sel_dlya; \n  end \n always@(posedge clk) begin \n  odd <= odd_dlyb; \n  sel <= sel_dlyb; \n  end \n always@(posedge clk) begin \n  case(addr_in[2:1]) \n  2'b00: begin \n  bank0_addr <= addr; \n  bank1_addr <= addr; \n  bank2_addr <= addr; \n  bank3_addr <= addr; \n  end \n  2'b01: begin \n  bank0_addr <= addr_pone; \n  bank1_addr <= addr; \n  bank2_addr <= addr; \n  bank3_addr <= addr; \n  end \n  2'b10: begin \n  bank0_addr <= addr_pone; \n  bank1_addr <= addr_pone; \n  bank2_addr <= addr; \n  bank3_addr <= addr; \n  end \n  2'b11: begin \n  bank0_addr <= addr_pone; \n  bank1_addr <= addr_pone; \n  bank2_addr <= addr_pone; \n  bank3_addr <= addr; \n  end \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a down counter that decrements from 17 to 0 and then reloads. It has a clock signal, a reset signal, and a trigger signal. The counter value is printed, and the module toggles the clock signal to simulate the system. The counter logic decrements the counter and triggers a reload when it reaches 0. The simulation finishes after a certain number of cycles, and the reset signal is applied at a specific time.\n\n Module header:\n\nmodule Down_CounterTBV ();\n [/INST]\n", "output": "reg clk = 0; \n reg rst = 0; \n reg Trig = 0; \n wire [4:0] count; \n reg [4:0] Down_Counter0_0_count_i = 17; \n always @(rst, clk, Trig, count) begin: DOWN_COUNTERTBV_PRINT_DATA \n  $write(\"%h\", clk); \n  $write(\" \"); \n  $write(\"%h\", rst); \n  $write(\" \"); \n  $write(\"%h\", Trig); \n  $write(\" \"); \n  $write(\"%h\", count); \n  $write(\"\\n\"); \n end \n always @(posedge clk, negedge rst) begin: DOWN_COUNTERTBV_DOWN_COUNTER0_0_LOGIC \n  if (rst) begin \n  Down_Counter0_0_count_i <= 17; \n  Trig <= 0; \n  end \n  else if ((Down_Counter0_0_count_i == 0)) begin \n  Trig <= 1; \n  Down_Counter0_0_count_i <= 17; \n  end \n  else begin \n  Down_Counter0_0_count_i <= (Down_Counter0_0_count_i - 1); \n  end \n end \n assign count = Down_Counter0_0_count_i; \n initial begin: DOWN_COUNTERTBV_CLK_SIGNAL \n  while (1'b1) begin \n  clk <= (!clk); \n  # 1; \n  end \n end \n initial begin: DOWN_COUNTERTBV_STIMULES \n  integer i; \n  i = 0; \n  while (1'b1) begin \n  case (i) \n  'h19: begin \n  rst <= 1; \n  end \n  (-'h1): begin \n  rst <= 0; \n  end \n  default: begin \n  end \n  endcase \n  if ((i == 42)) begin \n  $finish; \n  end \n  i = i + 1; \n  @(posedge clk); \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a D Flip-Flop with asynchronous reset, preset, and load control. It has a temporary register q_tmp to hold the input value. The flip-flop is synchronized to the positive edge of the clock signal and can be asynchronously reset, preset, or loaded. The q output is driven by the value in the q_tmp register. The debug_net is an 8-bit register used for debugging purposes. The reset signal is determined by the prn, sclr, clrn, and ena inputs.\n\n Module header:\n\nmodule dffeas (output q,input d, clk, clrn, prn, ena,input asdata, aload, sclr, sload);\n [/INST]\n", "output": "parameter power_up=\"dontcare\"; \n  parameter is_wysiwyg=\"false\"; \n  reg q_tmp; \n  wire reset; \n  reg [7:0] debug_net; \n  assign reset = (prn && sclr && ~clrn && ena); \n  assign q = q_tmp & 1'b1; \n  always @(posedge clk, posedge aload) begin \n  if(reset) q_tmp <= 0; \n  else q_tmp <= d; \n  end \n  assign q = q_tmp; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module, spiral_4, processes an input data and produces four different output data. It consists of multiple stages of operations using arithmetic and shifting operations. The input data, i_data, is manipulated through various shift and add operations to produce the outputs o_data_18, o_data_50, o_data_75, and o_data_89. The module utilizes wire declarations and assignments to perform the required operations. The outputs are generated from the intermediate results obtained after each stage of processing.\n\n Module header:\n\nmodule spiral_4(i_data,o_data_18,o_data_50,o_data_75,o_data_89);\n [/INST]\n", "output": "input signed [18:0] i_data; \n output signed [18+7:0] o_data_18; \n output signed [18+7:0] o_data_50; \n output signed [18+7:0] o_data_75; \n output signed [18+7:0] o_data_89; \n wire signed [25:0] \n  w1, \n  w8, \n  w9, \n  w16, \n  w25, \n  w4, \n  w5, \n  w80, \n  w75, \n  w89, \n  w18, \n  w50; \n assign w1 = i_data; \n assign w8 = w1 << 3; \n assign w9 = w1 + w8; \n assign w16 = w1 << 4; \n assign w25 = w9 + w16; \n assign w4 = w1 << 2; \n assign w5 = w1 + w4; \n assign w80 = w5 << 4; \n assign w75 = w80 - w5; \n assign w89 = w9 + w80; \n assign w18 = w9 << 1; \n assign w50 = w25 << 1; \n assign o_data_18=w18; \n assign o_data_50=w50; \n assign o_data_75=w75; \n assign o_data_89=w89; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module acts as a multiplexer, passing through the input valid signal and 16 sets of 32-bit data signals. It copies the input valid signal to the output valid signal and each set of 32-bit data from the input to the corresponding output.\n\n Module header:\n\nmodule MuxN_4(input io_ins_0_valid,input [31:0] io_ins_0_bits_wdata_0,input [31:0] io_ins_0_bits_wdata_1,input [31:0] io_ins_0_bits_wdata_2,input [31:0] io_ins_0_bits_wdata_3,input [31:0] io_ins_0_bits_wdata_4,input [31:0] io_ins_0_bits_wdata_5,input [31:0] io_ins_0_bits_wdata_6,input [31:0] io_ins_0_bits_wdata_7,input [31:0] io_ins_0_bits_wdata_8,input [31:0] io_ins_0_bits_wdata_9,input [31:0] io_ins_0_bits_wdata_10,input [31:0] io_ins_0_bits_wdata_11,input [31:0] io_ins_0_bits_wdata_12,input [31:0] io_ins_0_bits_wdata_13,input [31:0] io_ins_0_bits_wdata_14,input [31:0] io_ins_0_bits_wdata_15,input io_ins_0_bits_wlast,output io_out_valid,output [31:0] io_out_bits_wdata_0,output [31:0] io_out_bits_wdata_1,output [31:0] io_out_bits_wdata_2,output [31:0] io_out_bits_wdata_3,output [31:0] io_out_bits_wdata_4,output [31:0] io_out_bits_wdata_5,output [31:0] io_out_bits_wdata_6,output [31:0] io_out_bits_wdata_7,output [31:0] io_out_bits_wdata_8,output [31:0] io_out_bits_wdata_9,output [31:0] io_out_bits_wdata_10,output [31:0] io_out_bits_wdata_11,output [31:0] io_out_bits_wdata_12,output [31:0] io_out_bits_wdata_13,output [31:0] io_out_bits_wdata_14,output [31:0] io_out_bits_wdata_15,output io_out_bits_wlast);\n [/INST]\n", "output": "assign io_out_valid = io_ins_0_valid; \n  assign io_out_bits_wdata_0 = io_ins_0_bits_wdata_0; \n  assign io_out_bits_wdata_1 = io_ins_0_bits_wdata_1; \n  assign io_out_bits_wdata_2 = io_ins_0_bits_wdata_2; \n  assign io_out_bits_wdata_3 = io_ins_0_bits_wdata_3; \n  assign io_out_bits_wdata_4 = io_ins_0_bits_wdata_4; \n  assign io_out_bits_wdata_5 = io_ins_0_bits_wdata_5; \n  assign io_out_bits_wdata_6 = io_ins_0_bits_wdata_6; \n  assign io_out_bits_wdata_7 = io_ins_0_bits_wdata_7; \n  assign io_out_bits_wdata_8 = io_ins_0_bits_wdata_8; \n  assign io_out_bits_wdata_9 = io_ins_0_bits_wdata_9; \n  assign io_out_bits_wdata_10 = io_ins_0_bits_wdata_10; \n  assign io_out_bits_wdata_11 = io_ins_0_bits_wdata_11; \n  assign io_out_bits_wdata_12 = io_ins_0_bits_wdata_12; \n  assign io_out_bits_wdata_13 = io_ins_0_bits_wdata_13; \n  assign io_out_bits_wdata_14 = io_ins_0_bits_wdata_14; \n  assign io_out_bits_wdata_15 = io_ins_0_bits_wdata_15; \n  assign io_out_bits_wlast = io_ins_0_bits_wlast; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a paddlescan functionality. It takes input signals ptop, pbot, x, and y, and outputs a scan signal. The module also has internal registers scanX and scanY. On each positive edge of the clock signal, the module checks conditions based on the input signals and updates the scanX and scanY registers accordingly. The scan signal is assigned the result of the logical AND operation between scanX not equal to 0 and scanY.\n\n Module header:\n\nmodule paddlescan(clk, ptop, pbot, x, y, scan);\n [/INST]\n", "output": "parameter H = 0; \n  parameter X = 0; \n  input clk; \n  input [9:0] ptop; \n  input [9:0] pbot; \n  input [9:0] x; \n  input [9:0] y; \n  output scan; \n  reg [4:0] scanX; \n  reg scanY; \n  always @(posedge clk) begin \n  if (x == X) \n  scanX = 16; \n  if (scanX > 0) \n  scanX = scanX - 1'b1; \n  end \n  always @(posedge clk) begin \n  if (y == ptop) \n  scanY = 1; \n  if (y >= pbot) \n  scanY = 0; \n  end \n  assign scan = scanX != 0 && scanY; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an operator that performs various arithmetic and control operations based on input signals. It contains registers for phase, accumulator, and add operations, along with a synthesis control register and a write request flag. The module is clocked and can be reset. It takes in synthesis control and data, and outputs a write request and data. The logic inside the module updates the phase and accumulator based on the control signals and input data, and generates a write request when necessary. The module also instantiates a sine function to generate a sine output based on the phase.\n\n Module header:\n\nmodule operator(clk,reset_n,synth_ctrl,synth_data,data_out,wreq);\n [/INST]\n", "output": "input wire clk, reset_n; \n  input wire [7:0] synth_data, synth_ctrl; \n  output wire wreq; \n  output wire [15:0] data_out; \n  wire [15:0] sine_out; \n  wire [20:0] phase; \n  reg [20:0] phase_1; \n  reg [31:0] accum_1; \n  reg [23:0] add_1; \n  reg [7:0] p_synth_ctrl; \n  reg wreq_r, wr_now; \n  initial add_1 <= 19224; \n  assign data_out = accum_1[15:0]; \n  assign phase = phase_1; \n  assign wreq = wreq_r; \n  always @(posedge clk, negedge reset_n) \n  begin \n  if(!reset_n) \n  begin \n  phase_1 <= 0; \n  accum_1 <= 0; \n  add_1 <= 0; \n  wreq_r <= 0; \n  wr_now <= 0; \n  end \n  else \n  begin \n  p_synth_ctrl <= synth_ctrl; \n  case(synth_ctrl) \n  8'b00000001 : phase_1 <= add_1; \n  8'b10000001 : wreq_r <= 1; \n  8'b01000001 : begin \n  add_1[7:0] <= synth_data; \n  wr_now <= 1; \n  end \n  8'b00010001 : add_1[15:8] <= synth_data; \n  8'b01010001 : begin \n  add_1[23:16] <= synth_data; \n  wr_now <= 0; \n  end \n  8'b00100000 : begin \n  phase_1 <= 0; \n  accum_1 <= 0; \n  add_1 <= 0; \n  wreq_r <= 0; \n  wr_now <= 0; \n  end \n  default : phase_1 <= phase_1; \n  endcase \n  case(p_synth_ctrl) \n  8'b00000001 : accum_1 <= sine_out; \n  8'b10000001 : wreq_r <= 0; \n  endcase \n  end \n  end \n sine sine(.phase(phase),.sine_out(sine_out)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module simply assigns the value 0 to the output q.\n\n Module header:\n\nmodule vd30ca9_vb2eccd (output q);\n [/INST]\n", "output": "assign q = 1'b0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module, named REG_LIST, takes an 8-bit data input DIN, a 3-bit position input IPOS, and an initialization signal INIT. It produces a 3-bit output position OPOS and a VALID signal. The module uses a filter register to manipulate the input data based on the position input. Depending on the value of IPOS, the filter register is updated accordingly. The module then processes the filtered data and produces the output OPOS and VALID signals based on specific conditions.\n\n Module header:\n\nmodule REG_LIST ( DIN, IPOS, INIT, OPOS, VALID);\n [/INST]\n", "output": "input [7:0] DIN; \n  input [2:0] IPOS; \n  input INIT; \n  output [2:0] OPOS; \n  output VALID; \n  reg [7:1] filter; \n  wire [7:0] mdat_0; \n  wire [3:0] mdat_1; \n  wire [1:0] mdat_2; \n  always @(IPOS or DIN) \n  case (IPOS) \n  3'd0 : filter = DIN[7:1]; \n  3'd1 : filter = {DIN[7:2],1'b0}; \n  3'd2 : filter = {DIN[7:3],2'b0}; \n  3'd3 : filter = {DIN[7:4],3'b0}; \n  3'd4 : filter = {DIN[7:5],4'b0}; \n  3'd5 : filter = {DIN[7:6],5'b0}; \n  3'd6 : filter = {DIN[7] ,6'b0}; \n  3'd7 : filter = 7'b0; \n  endcase \n  assign mdat_0 = INIT ? DIN : {filter,1'b0}; \n  assign OPOS[2] = (mdat_0[3:0] == 4'h0); \n  assign mdat_1 = OPOS[2] ? mdat_0[7:4] : mdat_0[3:0]; \n  assign OPOS[1] = (mdat_1[1:0] == 2'b00); \n  assign mdat_2 = OPOS[1] ? mdat_1[3:2] : mdat_1[1:0]; \n  assign OPOS[0] = ~mdat_2[0]; \n  assign VALID = (mdat_2 != 2'b00); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements an input module for text display. It accesses a font ROM and generates a 3-bit output representing the displayed text. The module calculates the tile boundaries based on input pixel coordinates and uses this information to determine the text to display. It assigns appropriate character, row, and bit addresses to extract the font bits for the displayed text from the font ROM. The displayed pixel value is set to 3'b111 if the font bit is high, otherwise, it is set to 3'b000.\n\n Module header:\n\nmodule demo2_text (input wire clk,input wire [10:0] PIXEL_H, PIXEL_V,output reg [2:0] PIXEL);\n [/INST]\n", "output": "wire [10:0] rom_addr; \n  reg [6:0] char_addr; \n  reg [3:0] row_addr; \n  reg [2:0] bit_addr; \n  wire [7:0] font_word; \n  wire font_bit; \n  wire text_on; \n  font_rom font_unit \n  (.clk(clk), .addr(rom_addr), .data(font_word)); \n  reg [10:0] tile_v_start = 8'd10; \n  reg [10:0] tile_h_start = 8'd200; \n  wire [10:0] tile_v_end; \n  wire [10:0] tile_h_end; \n  assign tile_v_end = tile_v_start + (8'd15 << 2); \n  assign tile_h_end = tile_h_start + (8'd7 << 2); \n  assign text_on = (PIXEL_H >= tile_h_start && PIXEL_H <= tile_h_end && PIXEL_V >= tile_v_start && PIXEL_V <= tile_v_end); \n  always @* begin \n  PIXEL = 3'b000; \n  if (text_on) begin \n  char_addr = 7'h30; \n  row_addr = (PIXEL_V - tile_v_start) >> 2; \n  bit_addr = (PIXEL_H - tile_h_start) >> 2; \n  if (font_bit) \n  PIXEL = 3'b111; \n  end else begin \n  char_addr = 0; \n  row_addr = 0; \n  bit_addr = 0; \n  end \n  end \n  assign rom_addr = {char_addr, row_addr}; \n  assign font_bit = font_word[~bit_addr]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module named `oh_add` implements an arithmetic unit that computes the sum of two input vectors `a` and `b`. It also outputs a carry `cout`, a zero flag `zero`, a negation flag `neg`, and an overflow flag `overflow`. The module supports both addition and subtraction based on the `opt_sub` input. The result is stored in the `sum` output vector. The input `cin` is used for the carry-in during addition. The behavior of the module is determined by the width parameter `DW` and follows the standard arithmetic rules for addition and subtraction.\n\n Module header:\n\nmodule oh_add #(parameter DW = 1) (input [DW-1:0] a,input [DW-1:0] b,input opt_sub,input cin,output [DW-1:0] sum,output cout,output zero,output neg,output overflow);\n [/INST]\n", "output": "wire [DW-1:0] b_sub; \n  assign b_sub[DW-1:0] = {(DW){opt_sub}} ^ b[DW-1:0]; \n  assign {cout,sum[DW-1:0]} = a[DW-1:0] + \n  b_sub[DW-1:0] + \n  opt_sub + \n  cin; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a calculator that takes two 6-bit inputs and an operation selector, and produces the result along with an error signal. It uses various sub-modules for addition, subtraction, multiplication, division, power, factorial, exponential, sine, cosine, and tangent operations, each of which has its own overflow indication. A multiplexer selects the output based on the operation selected, and the error signal is determined based on the overflow of the selected operation.\n\n Module header:\n\nmodule calculator (data_in1, data_in2, operator, data_out, error);\n [/INST]\n", "output": "input[5:0] data_in1; \n  input[5:0] data_in2; \n  input[3:0] operator; \n  output[5:0] data_out; \n  output error; \n  wire[5:0] sum; \n  wire[5:0] diff; \n  wire[5:0] prod; \n  wire[5:0] quotient; \n  wire[5:0] remainder; \n  wire[5:0] power; \n  wire[5:0] log; \n  wire[5:0] factorial; \n  wire[5:0] exp; \n  wire[5:0] sin; \n  wire[5:0] cos; \n  wire[5:0] tan; \n  wire[12:0] overflow; \n  sixbitadd add1 (data_in1, data_in2, sum, overflow[0]); \n  sixbitsub sub1 (data_in1, data_in2, diff, overflow[1]); \n  sixbitmul mul1 (data_in1, data_in2, prod, overflow[2]); \n  sixbitdiv div1 (data_in1, data_in2, quotient, remainder, overflow[3]); \n  sixbitpow pow1 (data_in1, data_in2, power, overflow[5]); \n  sixbitfactorial fact1 (data_in1, factorial, overflow[7]); \n  sixbitexp exp1 (data_in1, exp, overflow[8]); \n  sixbitsin sin1 (data_in1, sin, overflow[9]); \n  sixbitcos cos1 (data_in1, cos, overflow[10]); \n  sixbittan tan1 (data_in1, tan, overflow[11]); \n  assign overflow[4] = overflow[3]; \n  multiplexer mux1 (sum, diff, prod, quotient, remainder, power, log, factorial, exp, sin, cos, tan, 0, 0, 0, 0, operator, data_out); \n  assign error = overflow[operator]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements an altpriority encoder that takes a 4-bit input data and produces a 2-bit output q. The module instantiates two submodules, altpriority_encoder33 and altpriority_encoder34, which handle the encoding of the lower and upper 2 bits of the input data, respectively. The output q is generated by combining the output signals of these submodules.\n\n Module header:\n\nmodule acl_fp_sub_altpriority_encoder_q28 (data,q) ;\n [/INST]\n", "output": "input [3:0] data; \n  output [1:0] q; \n  wire [0:0] wire_altpriority_encoder33_q; \n  wire wire_altpriority_encoder33_zero; \n  wire [0:0] wire_altpriority_encoder34_q; \n  acl_fp_sub_altpriority_encoder_nh8 altpriority_encoder33 \n (.data(data[1:0]),.q(wire_altpriority_encoder33_q),.zero(wire_altpriority_encoder33_zero)); \n  acl_fp_sub_altpriority_encoder_n28 altpriority_encoder34 \n (.data(data[3:2]),.q(wire_altpriority_encoder34_q)); \n  assign \n  q = {wire_altpriority_encoder33_zero, ((wire_altpriority_encoder33_zero & wire_altpriority_encoder34_q) | ((~ wire_altpriority_encoder33_zero) & wire_altpriority_encoder33_q))}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an FPGA memory module that facilitates reading from and writing to memory. It includes various signals such as clock, reset, write enable, read enable, memory address, memory write data, memory tag request, memory input data, memory write enable, memory acknowledge, memory done, memory read data, memory tag response, memory acknowledge, memory operation, memory data output, and memory address output.\n\nThe module contains state registers and logic to manage the memory operations. It transitions through different states such as idle, write acknowledge wait, write ready wait, write long shot timeout, read acknowledge wait, read ready wait, and read long shot timeout. These states are controlled based on the signals received and the completion of memory operations.\n\nOverall, this module provides the necessary functionality to interface with FPGA memory, ensuring proper synchronization and data management.\n\n Module header:\n\nmodule fpga_memory (mem_wr_en, mem_rd_en,mem_addr, mem_wr_data, mem_tag_req,mb_data_in, mb_data_we, mb_ack, mb_done,clk, rst,mem_tag_resp, mem_rd_data, mem_ack,mb_op, mb_data_out, mb_addr);\n [/INST]\n", "output": "input clk; \n input rst; \n input mem_wr_en; \n input mem_rd_en; \n input [31:0] mem_addr; \n input [31:0] mem_wr_data; \n input [6:0] mem_tag_req; \n input [31:0] mb_data_in; \n input mb_data_we; \n input mb_ack; \n input mb_done; \n output [31:0] mem_rd_data; \n output [6:0] mem_tag_resp; \n output mem_ack; \n output [3:0] mb_op; \n output [31:0] mb_data_out; \n output [31:0] mb_addr; \n reg [31:0] mem_addr_reg; \n reg [31:0] mb_data_out_reg; \n reg[6:0] mem_tag_req_reg; \n reg[3:0] mem_state; \n reg[3:0] mem_state_next; \n reg [31:0] mb_data_in_reg; \n reg mem_ack_reg; \n reg mb_ack_reg; \n reg mb_done_reg; \n `define MEM_IDLE 4'b0000 \n `define MEM_WR_ACK_WAIT 4'b0001 \n `define MEM_WR_RDY_WAIT 4'b0010 \n `define MEM_WR_LSU_TO 4'b0011 \n `define MEM_RD_ACK_WAIT 4'b0100 \n `define MEM_RD_RDY_WAIT 4'b0101 \n `define MEM_RD_LSU_TO 4'b0110 \n assign mem_tag_resp = mem_tag_req_reg; \n assign mem_rd_data = mb_data_in_reg; \n assign mem_ack = mem_ack_reg; \n assign mb_data_out = mb_data_out_reg; \n assign mb_addr = mem_addr_reg; \n assign mb_op = mem_state; \n always@(posedge clk) begin \n  if(rst) begin \n  mem_state <= `MEM_IDLE; \n  mb_data_out_reg <= 32'd0; \n  mem_addr_reg <= 32'd0; \n  mem_tag_req_reg <= 7'd0; \n  mb_data_in_reg <= 32'd0; \n  mb_ack_reg <= 1'b0; \n  mb_done_reg <= 1'b0; \n  end \n  else begin \n  mb_ack_reg <= mb_ack; \n  mb_done_reg <= mb_done; \n  mem_state <= mem_state_next; \n  mb_data_out_reg <= mb_data_out_reg; \n  if(mem_wr_en) begin \n  mb_data_out_reg <= mem_wr_data; \n  end \n  mem_addr_reg <= mem_addr_reg; \n  mem_tag_req_reg <= mem_tag_req_reg; \n  if(mem_wr_en | mem_rd_en) begin \n  mem_addr_reg <= mem_addr; \n  mem_tag_req_reg <= mem_tag_req; \n  end \n  mb_data_in_reg <= mb_data_in_reg; \n  if(mb_data_we) begin \n  mb_data_in_reg <= mb_data_in; \n  end \n  end \n end \n always@(*) begin \n  mem_state_next <= mem_state; \n  mem_ack_reg <= 1'b0; \n  case(mem_state) \n  `MEM_IDLE: begin \n  if(mem_wr_en) begin \n  mem_state_next <= `MEM_WR_ACK_WAIT; \n  end \n  else if(mem_rd_en) begin \n  mem_state_next <= `MEM_RD_ACK_WAIT; \n  end \n  end \n  `MEM_WR_ACK_WAIT: begin \n  if(~mb_ack_reg & mb_ack) begin \n  mem_state_next <= `MEM_WR_RDY_WAIT; \n  end \n  end \n  `MEM_WR_RDY_WAIT: begin \n  if(~mb_done_reg & mb_done) begin \n  mem_state_next <= `MEM_WR_LSU_TO; \n  end \n  end \n  `MEM_WR_LSU_TO: begin \n  mem_ack_reg <= 1'b1; \n  mem_state_next <= `MEM_IDLE; \n  end \n  `MEM_RD_ACK_WAIT: begin \n  if(~mb_ack_reg & mb_ack) begin \n  mem_state_next <= `MEM_RD_RDY_WAIT; \n  end \n  end \n  `MEM_RD_RDY_WAIT: begin \n  if(~mb_done_reg & mb_done) begin \n  mem_state_next <= `MEM_RD_LSU_TO; \n  end \n  end \n  `MEM_RD_LSU_TO: begin \n  mem_ack_reg <= 1'b1; \n  mem_state_next <= `MEM_IDLE; \n  end \n  default: mem_state_next <= mem_state; \n  endcase \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module checks the value of the addr_b input on each rising clock edge. If the addr_b input is equal to 65536, it outputs the 8 least significant bits of the data_b_in input to the console for debugging purposes.\n\n Module header:\n\nmodule debugprinter (input clk,input [31:0] addr_b,input [31:0] data_b_in,input [31:0] data_b_we);\n [/INST]\n", "output": "always @(posedge clk) \n  begin \n  if (addr_b == 65536) \n  $write(\"%c\", data_b_in[7:0]); \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module serves as a clock divider, producing an output clock signal at a frequency of half the input clock frequency. It uses a 26-bit counter to count the number of input clock cycles and toggles the output clock signal when the counter reaches a specific value. Additionally, it includes logic to reset the counter and output clock signal in response to a reset signal.\n\n Module header:\n\nmodule clock_divider(input clk, input rst, output reg clk_out);\n [/INST]\n", "output": "reg [25:0] counter; \n  initial \n  begin \n  counter <= 26'd0; \n  clk_out <= 1'b1; \n  end \n  always @(posedge clk or posedge rst) \n  begin \n  if(rst) \n  begin \n  counter <= 26'd0; \n  clk_out <= ~clk_out; \n  end \n  else \n  if(counter == 26'd25000000) \n  begin \n  counter <= 26'd0; \n  clk_out <= ~clk_out; \n  end \n  else \n  begin \n  counter <= counter+1; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module is a 2-to-1 multiplexer that selects between two input buses based on the sel input. The output bus out carries the selected input, in1 if sel is high, and in0 if sel is low.\n\n Module header:\n\nmodule mux2 #(parameter WIDTH=32) (input sel,input [WIDTH-1:0] in0, in1,output [WIDTH-1:0] out);\n [/INST]\n", "output": "assign out = sel ? in1 : in0 ; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes a 24-bit input and splits it into three 8-bit outputs, o2, o1, and o0, where o2 contains the most significant 8 bits, o1 contains the middle 8 bits, and o0 contains the least significant 8 bits.\n\n Module header:\n\nmodule v6fef69_v9a2a06 (input [23:0] i,output [7:0] o2,output [7:0] o1,output [7:0] o0);\n [/INST]\n", "output": "assign o2 = i[23:16]; \n  assign o1 = i[15:8]; \n  assign o0 = i[7:0]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a stopwatch. It includes various components such as a 1 kHz clock signal, debounce circuits for the start/stop and split buttons, a state machine for time display, a time counter module, a latch for the 7-segment display, and a display port for the 7-segment display. The module manages the display of time based on the input signals and the clock, and provides the output signals for the 7-segment display.\n\n Module header:\n\nmodule stopwatch(input clock_origin,input start_stop,input spilt,output [7:0] display_dig_sel,output [7:0] seg7cod_out);\n [/INST]\n", "output": "wire clk_1khz; \n  wire clk_100hz; \n  wire start_stop_aftdb; \n  wire spilt_aftdb; \n  wire clr; \n  wire Time_ce; \n  wire enable_lc; \n  wire [3:0] lc_in7; \n  wire [3:0] lc_in6; \n  wire [3:0] lc_in5; \n  wire [3:0] lc_in4; \n  wire [3:0] lc_in3; \n  wire [3:0] lc_in2; \n  wire [3:0] lc_in1; \n  wire [3:0] lc_in0; \n  wire [3:0] lc_out7; \n  wire [3:0] lc_out6; \n  wire [3:0] lc_out5; \n  wire [3:0] lc_out4; \n  wire [3:0] lc_out3; \n  wire [3:0] lc_out2; \n  wire [3:0] lc_out1; \n  wire [3:0] lc_out0; \n  assign lc_in5 = 4'hf; \n  assign lc_in2 = 4'hf; \n clock_get_all clk_md( .clk_origin(clock_origin),.clkcnt_reset(1),.out_clk_1khz(clk_1khz),.out_clk_100hz(clk_100hz)); \n debounce start_stop_db(.sig_in(start_stop),.clk_1khz(clk_1khz),.sig_out_n(start_stop_aftdb)); \n debounce spilt_db(.sig_in(spilt),.clk_1khz(clk_1khz),.sig_out_n(spilt_aftdb)); \n statmath statmachine_md(.statmach_clock(clk_1khz),.start_stop(start_stop_aftdb),.spilt(spilt_aftdb),.clr(clr),.Time_ce(Time_ce),.enable_lc(enable_lc)); \n time_cnt timer_md(.ce(Time_ce),.clk_100hz(clk_100hz),.clr(clr),.lit_lsb(lc_in0),.lit_msb(lc_in1),.sec_lsb(lc_in3),.sec_msb(lc_in4),.min_lsb(lc_in6),.min_msb(lc_in7)); \n latch_8path_4b latch_md(.lc_in7(lc_in7),.lc_in6(lc_in6),.lc_in5(lc_in5),.lc_in4(lc_in4),.lc_in3(lc_in3),.lc_in2(lc_in2),.lc_in1(lc_in1),.lc_in0(lc_in0),.enable_lc(enable_lc),.lc_out7(lc_out7),.lc_out6(lc_out6),.lc_out5(lc_out5),.lc_out4(lc_out4),.lc_out3(lc_out3),.lc_out2(lc_out2),.lc_out1(lc_out1),.lc_out0(lc_out0)); \n display_connet_port display_md (.scancnt_reset(0),.clk_scan(clk_1khz),.in_bcd_7(lc_out7),.in_bcd_6(lc_out6),.in_bcd_5(lc_out5),.in_bcd_4(lc_out4),.in_bcd_3(lc_out3),.in_bcd_2(lc_out2),.in_bcd_1(lc_out1),.in_bcd_0(lc_out0),.display_dig_sel(display_dig_sel),.seg7cod_out(seg7cod_out)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a symmetric memory core with two independent read and write ports. It includes two RAM blocks, one for each port, and supports simultaneous read and write operations. The module initializes the memory with default values or reads data from a file, and includes logic to write to and read from the RAM based on clock signals and enable and write enable signals for each port.\n\n Module header:\n\nmodule symmetric_mem_core #(parameter RAM_WIDTH = 32,parameter RAM_ADDR_BITS = 12)(input wire clockA,input wire clockB,input wire write_enableA,input wire write_enableB,input wire [RAM_ADDR_BITS-1:0] addressA,input wire [RAM_ADDR_BITS-1:0] addressB,input wire [RAM_WIDTH-1:0] input_dataA,input wire [RAM_WIDTH-1:0] input_dataB,output reg [RAM_WIDTH-1:0] output_dataA,output reg [RAM_WIDTH-1:0] output_dataB);\n [/INST]\n", "output": "`define SIM \n  (* RAM_STYLE=\"BLOCK\" *) \n  reg [RAM_WIDTH-1:0] sym_ram [(2**RAM_ADDR_BITS)-1:0]; \n  wire enableA; \n  wire enableB; \n  integer begin_address = 0; \n  integer end_address = 2**RAM_ADDR_BITS-1; \n  assign enableA = 1'b1; \n  assign enableB = 1'b1; \n  `ifdef SIM \n  integer i; \n  initial begin \n  for(i=0;i<2**RAM_ADDR_BITS;i=i+1) \n  sym_ram[i] = 'd0; \n  end \n  `else \n  initial \n  $readmemh(\"data_file_name\", sym_ram, begin_address, end_address); \n  `endif \n  always @(posedge clockA) \n  if (enableA) begin \n  if (write_enableA) \n  sym_ram[addressA] <= input_dataA; \n  output_dataA <= sym_ram[addressA]; \n  end \n  always @(posedge clockB) \n  if (enableB) begin \n  if (write_enableB) \n  sym_ram[addressB] <= input_dataB; \n  output_dataB <= sym_ram[addressB]; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a communication interface with multiple inputs and outputs for transmitting and receiving data. It includes components for transmitter and receiver bits, EEPROM configurations, clock and data signals, and buffer status. The module interfaces with other components to handle data transmission and reception, as well as control signals for various operations. The design follows a hierarchical structure, with sub-modules for specific tasks such as receiving data (rxq) and transmitting data (txq). The module also includes parameters for baud rate and shift register width to customize the behavior of the communication interface.\n\n Module header:\n\nmodule sia(input clk_i,input reset_i,input [3:1] adr_i,input we_i,input cyc_i,input stb_i,input [1:0] sel_i,input [SRW:0] dat_i,output [SRW:0] dat_o,output ack_o,output stall_o,output irq_o,input rxd_i,input rxc_i,output txd_o,output txc_o,output rx_not_empty_o,output tx_not_full_o);\n [/INST]\n", "output": "parameter BAUD_RATE_WIDTH = 20; \n  parameter SHIFT_REG_WIDTH = 16; \n  parameter BRW = BAUD_RATE_WIDTH - 1; \n  parameter SRW = SHIFT_REG_WIDTH - 1; \n  wire [4:0] wb_tr_bits; \n  wire wb_r_eedc, wb_r_eedd, wb_r_rxcpol; \n  wire [2:0] wb_t_txcmod; \n  wire [BRW:0] wb_tr_bitrat; \n  wire txclb, txdlb; \n  wire wb_r_pop, wb_r_oe; \n  wire [SRW:0] r_wb_dat; \n  wire r_wb_full, r_wb_not_empty; \n  wire wb_t_we; \n  wire [SRW:0] wb_t_dat; \n  wire t_wb_not_full, t_wb_empty, t_wb_idle; \n  assign rx_not_empty_o = r_wb_not_empty; \n  assign tx_not_full_o = t_wb_not_full; \n  wire rxd = txdlb ? txd_o : rxd_i; \n  wire rxc = txclb ? txc_o : rxc_i; \n  wire txd, txc; \n  assign txd_o = txdlb ? 1'b0 : txd; \n  assign txc_o = txclb ? wb_t_txcmod[0] : txc; \n sia_wb wb (.clk_i(clk_i),.reset_i(reset_i),.adr_i(adr_i),.we_i(we_i),.cyc_i(cyc_i),.stb_i(stb_i),.sel_i(sel_i),.dat_i(dat_i),.dat_o(dat_o),.ack_o(ack_o),.stall_o(stall_o),.irq_o(irq_o),.bits_o(wb_tr_bits),.eedc_o(wb_r_eedc),.eedd_o(wb_r_eedd),.txcmod_o(wb_t_txcmod),.rxcpol_o(wb_r_rxcpol),.intena_o(),.bitrat_o(wb_tr_bitrat),.txdlb_o(txdlb),.txclb_o(txclb),.rxq_pop_o(wb_r_pop),.rxq_oe_o(wb_r_oe),.rxq_dat_i(r_wb_dat),.rxq_full_i(r_wb_full),.rxq_not_empty_i(r_wb_not_empty),.txq_we_o(wb_t_we),.txq_dat_o(wb_t_dat),.txq_not_full_i(t_wb_not_full),.txq_empty_i(t_wb_empty),.txq_idle_i(t_wb_idle)); \n sia_rxq #(.BAUD_RATE_WIDTH(BAUD_RATE_WIDTH),.SHIFT_REG_WIDTH(SHIFT_REG_WIDTH)) rxq (.clk_i(clk_i),.reset_i(reset_i),.bits_i(wb_tr_bits),.baud_i(wb_tr_bitrat),.eedd_i(wb_r_eedd),.eedc_i(wb_r_eedc),.rxcpol_i(wb_r_rxcpol),.rxd_i(rxd),.rxc_i(rxc),.rxq_pop_i(wb_r_pop),.rxq_oe_i(wb_r_oe),.rxq_dat_o(r_wb_dat),.rxq_full_o(r_wb_full),.rxq_not_empty_o(r_wb_not_empty)); \n sia_txq #(.BAUD_RATE_WIDTH(BAUD_RATE_WIDTH),.SHIFT_REG_WIDTH(SHIFT_REG_WIDTH)) txq (.clk_i(clk_i),.reset_i(reset_i),.dat_i(wb_t_dat),.we_i(wb_t_we),.bits_i(wb_tr_bits),.baud_i(wb_tr_bitrat),.txcmod_i(wb_t_txcmod),.txd_o(txd),.txc_o(txc),.not_full_o(t_wb_not_full),.empty_o(t_wb_empty),.idle_o(t_wb_idle)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a PWM (Pulse Width Modulation) controller for a speaker. It uses a counter to control the frequency of the PWM signal based on the slow_rate input. The speaker_out output is set to high when the counter reaches the specified slow_rate and is toggled to low, producing the desired PWM waveform. The slow_rate_old is used to track changes in the slow_rate input.\n\n Module header:\n\nmodule pwm_controller( clk, slow_rate, speaker_out );\n [/INST]\n", "output": "input clk; \n  input [12:0] slow_rate; \n  output speaker_out; \n  reg [12:0] counter; \n  reg speaker; \n  reg [12:0] slow_rate_old; \n  initial begin \n  counter = 0; \n  slow_rate_old = 0; \n  speaker = 1'b0; \n  end \n  always @(posedge clk) begin \n  if(slow_rate_old != slow_rate) begin \n  counter <= 0; \n  speaker <= 1'b0; \n  slow_rate_old <= slow_rate; \n  end \n  if(counter == slow_rate && slow_rate != 0) begin \n  speaker <= ~speaker; \n  counter <= 0; \n  end else if (slow_rate != 0) begin \n  counter <= counter + 1; \n  end else begin \n  counter <= 0; \n  end \n  end \n  assign speaker_out = speaker; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a configurable parallel counter. It has inputs for reset, clock, enable, jump, and out_enable. The bus_in input allows the counter to jump to a new address. The module has an output bus_out that reflects the current count based on the out_enable signal. The counter width is specified by the ADDRESS_WIDTH parameter. The counter is incremented when the enable signal is asserted and updated to a new address when the jump signal is asserted. The counter is reset to 0 when the rst signal is asserted.\n\n Module header:\n\nmodule pcounter(input rst,input clk,input enable,input jump,input out_enable,input [ADDRESS_WIDTH-1 : 0] bus_in,output [ADDRESS_WIDTH-1 : 0] bus_out);\n [/INST]\n", "output": "parameter ADDRESS_WIDTH = 4; \n  reg [ADDRESS_WIDTH-1 : 0] counter; \n  assign bus_out = (out_enable) ? counter : 0; \n  always @(posedge clk) begin \n  if (rst) begin \n  counter <= 0; \n  end else begin \n  if (enable) begin \n  counter <= counter + 1; \n  end else if (jump) begin \n  counter <= bus_in; \n  end \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module is a fixed-point multiplier that takes two P-bit inputs a and b, and produces a P-bit output p. The input addresses are assigned to 22-bit and 7-bit wires am, bm, ae, and be. The module includes 22-bit and 7-bit registers pm and pe, a 23-bit register xm, and a 47-bit register pmTemp. The pmTemp and peTemp values are calculated based on the inputs a and b. The output p is assigned based on the values of pe, pm, and the inputs a and b.\n\n Module header:\n\nmodule FP_Mul #(parameter P=32, biasSP=8'd127)(input wire clk,input wire [P-1:0] a,input wire [P-1:0] b,output wire [P-1:0] p);\n [/INST]\n", "output": "wire [22:0] am, bm; \n  wire [7:0] ae,be; \n  assign am = a[22:0]; \n  assign bm = b[22:0]; \n  assign ae = a[30:23]; \n  assign be = b[30:23]; \n  reg [22:0] pm; \n  reg [7:0] pe; \n  reg [47:0] pmTemp; \n  reg [7:0] peTemp; \n  reg [23:0] xm; \n  always@* \n  begin \n  pmTemp = {1'b1,am}*{1'b1,bm}; \n  peTemp = (ae+be)-biasSP; \n  xm = pmTemp[47] ? pmTemp[46:24] : pmTemp[45:23]; \n  pe = pmTemp[47] ? peTemp+1 : peTemp; \n  pm = xm[22:0]; \n  pe = xm[23] ? pe+1 : pe; \n  end \n  assign p = {(a[31]^b[31]),{pe,pm}}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a 64-input priority encoder. It uses eight instances of a sub-module \"priority_encoder8\" to encode eight sets of eight inputs each. The output of each sub-module is stored in detectL and preoutL arrays. The module then uses another instance of the \"priority_encoder8\" sub-module to encode the detectL array and preoutM. Finally, the module assigns the output \"out\" based on whether \"detect\" is true, in which case it concatenates preoutM and the value of preoutL indexed by preoutM, otherwise it assigns 6'b0 to the output.\n\n Module header:\n\nmodule priority_encoder64 (input [ 63 : 0 ] in,output detect,output [ 5 : 0 ] out);\n [/INST]\n", "output": "wire [7:0] detectL; \n  wire [2:0] preoutL [7:0]; \n  wire [2:0] preoutM; \n  priority_encoder8 e30( in[ 7:0 ], detectL[0], preoutL[0] ); \n  priority_encoder8 e31( in[ 15:8 ], detectL[1], preoutL[1] ); \n  priority_encoder8 e32( in[ 23:16 ], detectL[2], preoutL[2] ); \n  priority_encoder8 e33( in[ 31:24 ], detectL[3], preoutL[3] ); \n  priority_encoder8 e34( in[ 39:32 ], detectL[4], preoutL[4] ); \n  priority_encoder8 e35( in[ 47:40 ], detectL[5], preoutL[5] ); \n  priority_encoder8 e36( in[ 55:48 ], detectL[6], preoutL[6] ); \n  priority_encoder8 e37( in[ 63:56 ], detectL[7], preoutL[7] ); \n  priority_encoder8 e20(detectL, detect, preoutM); \n  assign out = detect ? { preoutM, preoutL[preoutM] } : 6'b0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module implements a stream writer FIFO with configurable data and address widths. It contains a counter for the number of elements in the FIFO and handles data streaming between source and destination interfaces. The module interfaces with a FIFO and manages the read and write operations, and the stream FIFO interface for data transfer. It includes logic for incrementing and decrementing the counter based on the stream validity and readiness signals. The module also includes logic for resetting the counter when the reset signal is active.\n\n Module header:\n\nmodule wb_stream_writer_fifo #(parameter DW = 0,parameter AW = 0) (input clk,input rst,output reg [AW:0] cnt,input [DW-1:0] stream_s_data_i,input stream_s_valid_i,output stream_s_ready_o,output [DW-1:0] stream_m_data_o,output stream_m_valid_o,input stream_m_ready_i);\n [/INST]\n", "output": "wire fifo_rd_en; \n  wire [DW-1:0] fifo_dout; \n  wire fifo_empty; \n  wire full; \n  reg inc_cnt; \n  reg dec_cnt; \n  assign stream_s_ready_o = !full; \n  fifo \n #(.DEPTH_WIDTH (AW),.DATA_WIDTH (DW)) \n  fifo0 \n (.clk (clk),.rst (rst),.rd_en_i (fifo_rd_en),.rd_data_o (fifo_dout),.empty_o (fifo_empty),.wr_en_i (stream_s_valid_i & ~full),.wr_data_i (stream_s_data_i),.full_o (full)); \n  stream_fifo_if \n  #(.DW (DW)) \n  stream_if \n (.clk (clk),.rst (rst),.fifo_data_i (fifo_dout),.fifo_rd_en_o (fifo_rd_en),.fifo_empty_i (fifo_empty),.stream_m_data_o (stream_m_data_o),.stream_m_valid_o (stream_m_valid_o),.stream_m_ready_i (stream_m_ready_i)); \n  always @(posedge clk) begin \n  inc_cnt = stream_s_valid_i & stream_s_ready_o; \n  dec_cnt = stream_m_valid_o & stream_m_ready_i; \n  if(inc_cnt & !dec_cnt) \n  cnt <= cnt + 1; \n  else if(dec_cnt & !inc_cnt) \n  cnt <= cnt - 1; \n  if (rst) \n  cnt <= 0; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module `tkr_const` has two output signals, `outF` and `outT`, each of width 32 bits. The module takes an input signal `go`. It contains a feedback loop where the output signals are initialized to zero and then set to a specified value when the `go` signal becomes active. Once set, the feedback signal is then inverted to provide the value for `outF`. When the `go` signal becomes inactive, the process waits until the `go` signal becomes active again.\n\n Module header:\n\nmodule tkr_const (go, outF, outT);\n [/INST]\n", "output": "parameter [31:0] width = 1; \n  parameter [width-1:0] value = 0; \n  input go; \n  output [width-1:0] outF; \n  output [width-1:0] outT; \n  reg [width-1:0] outF; \n  reg [width-1:0] outT; \n  always begin \n  outF = 0; outT = 0; \n  wait (go); \n  outT = value; outF = ~outT; \n  wait (!go); \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a delay element with a synchronous write and read interface. It consists of several registers to store input and output data, as well as control signals for write and read operations. The module uses the input clock signal to synchronize the read and write operations. Additionally, it includes a reset signal to initialize the registers to default values. The write enable signal and write data are used to update the internal registers, and the read enable signal provides access to the stored data. The module also includes logic to select the appropriate data to be read based on the write argument and control signals. The readiness signals for write and read operations are always asserted. Overall, this module acts as a delay line with the ability to store and retrieve data based on control signals.\n\n Module header:\n\nmodule mkDelay(CLK,RST_N,write_arg,EN_write,RDY_write,EN_read,read,RDY_read);\n [/INST]\n", "output": "input CLK; \n  input RST_N; \n  input [31 : 0] write_arg; \n  input EN_write; \n  output RDY_write; \n  input EN_read; \n  output [31 : 0] read; \n  output RDY_read; \n  reg [31 : 0] read; \n  wire RDY_read, RDY_write; \n  reg [3 : 0] rag; \n  wire [3 : 0] rag$D_IN; \n  wire rag$EN; \n  reg [31 : 0] regs; \n  wire [31 : 0] regs$D_IN; \n  wire regs$EN; \n  reg [31 : 0] regs_1; \n  wire [31 : 0] regs_1$D_IN; \n  wire regs_1$EN; \n  reg [31 : 0] regs_2; \n  wire [31 : 0] regs_2$D_IN; \n  wire regs_2$EN; \n  reg [31 : 0] regs_3; \n  wire [31 : 0] regs_3$D_IN; \n  wire regs_3$EN; \n  reg [3 : 0] wag; \n  wire [3 : 0] wag$D_IN; \n  wire wag$EN; \n  assign RDY_write = 1'd1 ; \n  always@(rag or regs_3 or regs or regs_1 or regs_2) \n  begin \n  case (rag) \n  4'd0: read = regs; \n  4'd1: read = regs_1; \n  4'd2: read = regs_2; \n  default: read = regs_3; \n  endcase \n  end \n  assign RDY_read = 1'd1 ; \n  assign rag$D_IN = rag + 4'd1 ; \n  assign rag$EN = EN_read ; \n  assign regs$D_IN = write_arg ; \n  assign regs$EN = EN_write && wag == 4'd0 ; \n  assign regs_1$D_IN = write_arg ; \n  assign regs_1$EN = EN_write && wag == 4'd1 ; \n  assign regs_2$D_IN = write_arg ; \n  assign regs_2$EN = EN_write && wag == 4'd2 ; \n  assign regs_3$D_IN = write_arg ; \n  assign regs_3$EN = EN_write && wag == 4'd3 ; \n  assign wag$D_IN = wag ; \n  assign wag$EN = EN_write ; \n  always@(posedge CLK) \n  begin \n  if (!RST_N) \n  begin \n  rag <= `BSV_ASSIGNMENT_DELAY 4'd0; \n  wag <= `BSV_ASSIGNMENT_DELAY 4'd0; \n  end \n  else \n  begin \n  if (rag$EN) rag <= `BSV_ASSIGNMENT_DELAY rag$D_IN; \n  if (wag$EN) wag <= `BSV_ASSIGNMENT_DELAY wag$D_IN; \n  end \n  if (regs$EN) regs <= `BSV_ASSIGNMENT_DELAY regs$D_IN; \n  if (regs_1$EN) regs_1 <= `BSV_ASSIGNMENT_DELAY regs_1$D_IN; \n  if (regs_2$EN) regs_2 <= `BSV_ASSIGNMENT_DELAY regs_2$D_IN; \n  if (regs_3$EN) regs_3 <= `BSV_ASSIGNMENT_DELAY regs_3$D_IN; \n  end \n  `ifdef BSV_NO_INITIAL_BLOCKS \n  `else \n  initial \n  begin \n  rag = 4'hA; \n  regs = 32'hAAAAAAAA; \n  regs_1 = 32'hAAAAAAAA; \n  regs_2 = 32'hAAAAAAAA; \n  regs_3 = 32'hAAAAAAAA; \n  wag = 4'hA; \n  end \n  `endif \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a memory controller that interfaces with an instruction and data memory. It has inputs for clock signal, memory requests, write enable signals, memory addresses, data, and bandwidth select signals. It also has outputs for write data, cycle signals, strobe signals, write and read addresses, write enable signal, burst write signal, data output, and readiness signals.\n\nThe module registers memory requests for data and instructions based on clock edges. It then assigns readiness outputs based on the acknowledgment signals and the registered requests. The module also connects the input and output signals to the appropriate memory control signals for instruction and data memory.\n\n Module header:\n\nmodule mem_ctrl (clk_i,IF_addr_i,IF_req_i,ID_inst_o,MEM_req_i,MEM_we_i,MEM_addr_i,MEM_data_i,MEM_bwsel_i,WB_data_o,dmem_cyc_o,dmem_stb_o,dmem_waddr_o,dmem_raddr_o,dmem_we_o,dmem_bwsel_o,dmem_ack_i,dmem_data_i,dmem_data_o,imem_cyc_o, imem_stb_o, imem_addr_o, imem_ack_i, imem_inst_i,dmem_rdy_o,imem_rdy_o);\n [/INST]\n", "output": "input clk_i; \n  input IF_req_i; \n  input [31:0] IF_addr_i; \n  output [31:0] ID_inst_o; \n  output imem_cyc_o; \n  output imem_stb_o; \n  output [31:0] imem_addr_o; \n  input imem_ack_i; \n  input [31:0] imem_inst_i; \n  input MEM_req_i; \n  input MEM_we_i; \n  input [31:0] MEM_addr_i; \n  input [31:0] MEM_data_i; \n  input [3:0] MEM_bwsel_i; \n  output [31:0] WB_data_o; \n  output dmem_cyc_o; \n  output dmem_stb_o; \n  output [31:0] dmem_waddr_o; \n  output [31:0] dmem_raddr_o; \n  output dmem_we_o; \n  output [3:0] dmem_bwsel_o; \n  input dmem_ack_i; \n  input [31:0] dmem_data_i; \n  output [31:0] dmem_data_o; \n  output dmem_rdy_o; \n  output imem_rdy_o; \n  assign imem_cyc_o = IF_req_i; \n  assign imem_stb_o = IF_req_i; \n  assign imem_addr_o = IF_addr_i; \n  assign ID_inst_o = imem_inst_i; \n  assign dmem_we_o = MEM_we_i; \n  assign dmem_cyc_o = MEM_req_i; \n  assign dmem_stb_o = MEM_req_i; \n  assign dmem_waddr_o = {MEM_addr_i[31:2],2'b00}; \n  assign dmem_raddr_o = {MEM_addr_i[31:2],2'b00}; \n  assign dmem_data_o = MEM_data_i; \n  assign dmem_bwsel_o = MEM_bwsel_i; \n  assign WB_data_o = dmem_data_i; \n  reg dmem_req_reged; \n  reg imem_req_reged; \n  always @(posedge clk_i) \n  begin \n  dmem_req_reged <= dmem_cyc_o & dmem_stb_o; \n  imem_req_reged <= IF_req_i; \n  end \n  assign dmem_rdy_o = dmem_ack_i | ~dmem_req_reged; \n  assign imem_rdy_o = imem_ack_i | ~imem_req_reged; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a tri-state buffer with input data, enable signals, and a tri-state output. It uses behavioral modeling to assign the output based on the enable signals and input data. The lpm_width parameter must be greater than 0, and an error message is displayed if it's not. The output result is determined based on the input data, tristate data, and enable signals. The tri-state buffer functionality is implemented through the use of conditional assignments and always blocks triggered by the input signals. The tristate output tridata is assigned based on the enable signal and input data.\n\n Module header:\n\nmodule lpm_bustri (tridata,data,enabletr,enabledt,result);\n [/INST]\n", "output": "parameter lpm_width = 1; \n  parameter lpm_type = \"lpm_bustri\"; \n  parameter lpm_hint = \"UNUSED\"; \n  input [lpm_width-1:0] data; \n  input enabletr; \n  input enabledt; \n  output [lpm_width-1:0] result; \n  inout [lpm_width-1:0] tridata; \n  reg [lpm_width-1:0] result; \n  tri1 enabletr; \n  tri1 enabledt; \n  wire i_enabledt; \n  wire i_enabletr; \n  buf (i_enabledt, enabledt); \n  buf (i_enabletr, enabletr); \n  initial \n  begin \n  if (lpm_width <= 0) \n  begin \n  $display(\"Value of lpm_width parameter must be greater than 0(ERROR)\"); \n  $display(\"Time: %0t Instance: %m\", $time); \n  $finish; \n  end \n  end \n  always @(data or tridata or i_enabletr or i_enabledt) \n  begin \n  if ((i_enabledt == 1'b0) && (i_enabletr == 1'b1)) \n  begin \n  result = tridata; \n  end \n  else if ((i_enabledt == 1'b1) && (i_enabletr == 1'b1)) \n  begin \n  result = data; \n  end \n  else \n  begin \n  result = {lpm_width{1'bz}}; \n  end \n  end \n  assign tridata = (i_enabledt == 1) ? data : {lpm_width{1'bz}}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"Adder\" takes three 4-bit inputs din_a, din_b, and din_c, and produces a 4-bit output dout. The module adds din_a and din_b, and assigns the result to dout.\n\n Module header:\n\nmodule Adder(din_a, din_b, din_c, dout);\n [/INST]\n", "output": "(* LOC = \"P20 P2 P7 P14\" *) \n  input wire[3:0] din_a; \n  (* LOC = \"P3 P19 P6 P15\" *) \n  input wire[3:0] din_b; \n  (* LOC = \"P13 P8 P10 P16\" *) \n  input wire[3:0] din_c; \n  (* LOC = \"P9 P4 P5 P12\" *) \n  output wire[3:0] dout; \n  assign dout = din_a + din_b; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is designed for reset synchronization. It uses two flip-flops to synchronize an input reset signal to the clock domain. The module updates the flip-flops on the positive edge of the clock signal or when the input reset signal goes low. When the input reset signal is low, both flip-flops are set to 0. When the input reset signal is high, the first flip-flop is set to 1, and the second flip-flop takes the value of the first flip-flop. The output reset signal is assigned to the value of the first flip-flop, providing a synchronized reset signal for the system.\n\n Module header:\n\nmodule zl_reset_sync (input clk,input in_rst_n,output out_rst_n);\n [/INST]\n", "output": "reg [1:0] ff; \n always @(posedge clk or negedge in_rst_n) begin \n  if(!in_rst_n) begin \n  ff[1] <= 1'b0; \n  ff[0] <= 1'b0; \n  end \n  else begin \n  ff[1] <= 1'b1; \n  ff[0] <= ff[1]; \n  end \n end \n assign out_rst_n = ff[0]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a demultiplexer for handling tri-state signals based on the selected GPIO. It assigns the appropriate tri-state signals for input and output based on the selected GPIO, allowing for proper handling of the tri-state signals for different GPIO selections. The module uses case statements to select and assign the appropriate tri-state signals for the input and output based on the selected GPIO.\n\n Module header:\n\nmodule arduino_switch_analog_bit(input [1:0] gpio_sel,input tri_i_out,output reg tri_o_out,output reg tri_t_out,output tri_i_in,input tri_o_in,input tri_t_in,output sda_i_in,input sda_o_in,input sda_t_in,output scl_i_in,input scl_o_in,input scl_t_in);\n [/INST]\n", "output": "reg [2:0] tri_i_out_demux; \n  assign {scl_i_in,sda_i_in, tri_i_in} = tri_i_out_demux; \n  always @(gpio_sel, tri_o_in, scl_o_in, sda_o_in) \n  case (gpio_sel) \n  2'h0: tri_o_out = tri_o_in; \n  2'h1: tri_o_out = tri_o_in; \n  2'h2: tri_o_out = sda_o_in; \n  2'h3: tri_o_out = scl_o_in; \n  endcase \n  always @(gpio_sel, tri_i_out) \n  begin \n  tri_i_out_demux = {3{1'b0}}; \n  case (gpio_sel) \n  2'h0: tri_i_out_demux[0] = tri_i_out; \n  2'h1: tri_i_out_demux[0] = tri_i_out; \n  2'h2: tri_i_out_demux[1] = tri_i_out; \n  2'h3: tri_i_out_demux[2] = tri_i_out; \n  endcase \n  end \n  always @(gpio_sel, tri_t_in, scl_t_in, sda_t_in) \n  case (gpio_sel) \n  2'h0: tri_t_out = tri_t_in; \n  2'h1: tri_t_out = tri_t_in; \n  2'h2: tri_t_out = sda_t_in; \n  2'h3: tri_t_out = scl_t_in; \n  endcase \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes in input data to be loaded, along with address, size, and sign extension information. Based on these inputs, it selects the appropriate portion of the input data to load into the output register. The selection is based on the address and size inputs, and sign extension is applied accordingly. The loaded result is stored in the output register.\n\n Module header:\n\nmodule load_data_translator(d_readdatain,d_address,load_size,load_sign_ext,d_loadresult);\n [/INST]\n", "output": "input [`WIDTH-1:0] d_readdatain; \n input [1:0] d_address; \n input [1:0] load_size; \n input load_sign_ext; \n output [`WIDTH-1:0] d_loadresult; \n wire d_adr_one; \n assign d_adr_one = d_address [1]; \n reg [`WIDTH-1:0] d_loadresult; \n reg sign; \n always @(d_readdatain or d_address or load_size or load_sign_ext) \n begin \n  case (load_size) \n  2'b11: \n  begin \n  case (d_address) \n  2'b00: \n  begin \n  d_loadresult[7:0]=d_readdatain[31:24]; \n  sign = d_readdatain[31]; \n  end \n  2'b01: \n  begin \n  d_loadresult[7:0]=d_readdatain[23:16]; \n  sign = d_readdatain[23]; \n  end \n  2'b10: \n  begin \n  d_loadresult[7:0]=d_readdatain[15:8]; \n  sign = d_readdatain[15]; \n  end \n  default: \n  begin \n  d_loadresult[7:0]=d_readdatain[7:0]; \n  sign = d_readdatain[7]; \n  end \n  endcase \n  d_loadresult[31]= load_sign_ext&sign; \n  d_loadresult[30]= load_sign_ext&sign; \n  d_loadresult[29]= load_sign_ext&sign; \n  d_loadresult[28]= load_sign_ext&sign; \n  d_loadresult[27]= load_sign_ext&sign; \n  d_loadresult[26]= load_sign_ext&sign; \n  d_loadresult[25]= load_sign_ext&sign; \n  d_loadresult[24]= load_sign_ext&sign; \n  d_loadresult[23]= load_sign_ext&sign; \n  d_loadresult[22]= load_sign_ext&sign; \n  d_loadresult[21]= load_sign_ext&sign; \n  d_loadresult[20]= load_sign_ext&sign; \n  d_loadresult[19]= load_sign_ext&sign; \n  d_loadresult[18]= load_sign_ext&sign; \n  d_loadresult[17]= load_sign_ext&sign; \n  d_loadresult[16]= load_sign_ext&sign; \n  d_loadresult[15]= load_sign_ext&sign; \n  d_loadresult[14]= load_sign_ext&sign; \n  d_loadresult[13]= load_sign_ext&sign; \n  d_loadresult[12]= load_sign_ext&sign; \n  d_loadresult[11]= load_sign_ext&sign; \n  d_loadresult[10]= load_sign_ext&sign; \n  d_loadresult[9]= load_sign_ext&sign; \n  d_loadresult[8]= load_sign_ext&sign; \n  end \n  2'b01: \n  begin \n  case (d_adr_one) \n  1'b0: \n  begin \n  d_loadresult[15:0]=d_readdatain[31:16]; \n  sign = d_readdatain[31]; \n  end \n  default: \n  begin \n  d_loadresult[15:0]=d_readdatain[15:0]; \n  sign = d_readdatain[15]; \n  end \n  endcase \n  d_loadresult[31]= load_sign_ext&sign; \n  d_loadresult[30]= load_sign_ext&sign; \n  d_loadresult[29]= load_sign_ext&sign; \n  d_loadresult[28]= load_sign_ext&sign; \n  d_loadresult[27]= load_sign_ext&sign; \n  d_loadresult[26]= load_sign_ext&sign; \n  d_loadresult[25]= load_sign_ext&sign; \n  d_loadresult[24]= load_sign_ext&sign; \n  d_loadresult[23]= load_sign_ext&sign; \n  d_loadresult[22]= load_sign_ext&sign; \n  d_loadresult[21]= load_sign_ext&sign; \n  d_loadresult[20]= load_sign_ext&sign; \n  d_loadresult[19]= load_sign_ext&sign; \n  d_loadresult[18]= load_sign_ext&sign; \n  d_loadresult[17]= load_sign_ext&sign; \n  d_loadresult[16]= load_sign_ext&sign; \n  end \n  default: \n  begin \n  sign = d_readdatain[31]; \n  d_loadresult[31:0]=d_readdatain[31:0]; \n end \n  endcase \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a multiplier that takes two 32-bit operands, opA and opB, and performs multiplication based on the op signal. It uses the lpm_mult_component module to perform the actual multiplication and provides the 64-bit result through the hi and lo outputs. The module also handles signedness by using the is_signed wire. The module operates on a clock signal and includes a reset signal for initialization.\n\n Module header:\n\nmodule mul (clk, resetn,opA, opB,op,hi, lo);\n [/INST]\n", "output": "parameter WIDTH=32; \n input clk; \n input resetn; \n input [WIDTH-1:0] opA; \n input [WIDTH-1:0] opB; \n input op; \n output [WIDTH-1:0] hi; \n output [WIDTH-1:0] lo; \n wire is_signed; \n assign is_signed=op; \n wire dum,dum2; \n lpm_mult lpm_mult_component (.sclr (~resetn),.ce (1'b1),.clk (clk),.a ({is_signed&opA[WIDTH-1],opA}),.b ({is_signed&opB[WIDTH-1],opB}),.p ({dum2,dum,hi,lo})); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `subleq` is a sequential circuit that implements the Subleq instruction. It has a 3-bit counter `counter` that increments with the clock signal. The module also has a 32-bit register `IP` that is updated based on the counter value and a conditional statement. \n\nAdditionally, the module contains registers `A`, `B`, and `J` as 32-bit vectors, which are updated based on the counter value and the output `q`. The module also instantiates a memory module `mem0` with specific inputs and a subtraction operation to generate the `sub` result.\n\nThe output signals `ocounter`, `oIP`, `oA`, `oB`, `oJ`, `oq`, `osub`, and `oleq` are assigned to the respective internal signals of the module for observation.\n\n Module header:\n\nmodule subleq(input iClock,input iReset,output [2:0] ocounter,output [31:0] oIP,output [31:0] oA,output [31:0] oB,output [31:0] oJ,output [31:0] oq,output [31:0] osub,output oleq);\n [/INST]\n", "output": "assign ocounter = counter; \n assign oIP = IP; \n assign oA = A; \n assign oB = B; \n assign oJ = J; \n assign oq = q; \n assign osub = sub; \n assign oleq = leq; \n reg [2:0] counter; \n initial begin \n  counter <= 3'd0; \n end \n always @(posedge iClock) begin \n  counter <= (iReset || counter == 3'd5) ? 3'd0 : counter + 3'd1; \n end \n reg [31:0] IP; \n initial begin \n  IP <= 32'd0; \n end \n always @(posedge iClock) begin \n  if (iReset) begin \n  IP <= 32'd0; \n  end else if (counter <= 3'd2) begin \n  IP <= IP + 32'd1; \n  end else if (counter == 3'd5) begin \n  IP <= leq ? J : IP; \n  end \n end \n wire [31:0] address; \n wire [31:0] q; \n always @(counter, IP, A, B) begin \n  if (counter <= 3'd2) begin \n  address <= IP; \n  end else if (counter == 3'd3) begin \n  address <= A; \n  end else begin \n  address <= B; \n  end \n end \n mem mem0(.address(address[12:0]),.clock(iClock),.data(sub),.wren(counter == 3'd5),.q(q)); \n reg [31:0] A, B, J; \n always @(posedge iClock) begin \n  if (counter == 3'd1 || counter == 3'd4) begin \n  A <= q; \n  end \n  if (counter == 3'd2) begin \n  B <= q; \n  end \n  if (counter == 3'd3) begin \n  J <= q; \n  end \n end \n wire [31:0] sub; \n assign sub = q - A; \n wire leq; \n assign leq = sub[31] || sub == 32'b0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module instantiates a sub-module `v78e0a3_v9a2a06` and connects its inputs and outputs to the specified wires. The module takes four 8-bit inputs and assigns them to four 7-bit wires. Then, it connects these wires to the corresponding inputs of the sub-module. The 32-bit output of the sub-module is assigned to the `v7d0a31` output of the module.\n\n Module header:\n\nmodule v78e0a3 (input [7:0] v12d067,input [7:0] v6127ee,input [7:0] vea9d11,input [7:0] v29bdec,output [31:0] v7d0a31);\n [/INST]\n", "output": "wire [0:31] w0; \n  wire [0:7] w1; \n  wire [0:7] w2; \n  wire [0:7] w3; \n  wire [0:7] w4; \n  assign v7d0a31 = w0; \n  assign w1 = v29bdec; \n  assign w2 = vea9d11; \n  assign w3 = v6127ee; \n  assign w4 = v12d067; \n v78e0a3_v9a2a06 v9a2a06 (.o(w0),.i0(w1),.i1(w2),.i2(w3),.i3(w4)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module vcdce79 takes an input vee8a83 and a 4-bit input v167ed7 and assigns it to the output v6a2e9e and a 5-bit wire w0, respectively. It also assigns vee8a83 to a single wire w1, and v167ed7 to a 4-bit wire w2. Additionally, it instantiates a submodule vcdce79_v9a2a06 with outputs w0 and inputs w1, w2.\n\n Module header:\n\nmodule vcdce79 (input vee8a83,input [3:0] v167ed7,output [4:0] v6a2e9e);\n [/INST]\n", "output": "wire [0:4] w0; \n  wire w1; \n  wire [0:3] w2; \n  assign v6a2e9e = w0; \n  assign w1 = vee8a83; \n  assign w2 = v167ed7; \n vcdce79_v9a2a06 v9a2a06 (.o(w0),.i1(w1),.i0(w2)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a program counter with a configurable size. It has an input for the program counter value, a clock input, a read-write signal, and a 2-bit increment input. The module uses a case statement to update the program counter value based on the increment signal. When the increment signal is '00' and the read-write signal is high, the program counter is updated to the input value. For other increment values, the program counter is incremented by 2, 4, or 6.\n\n Module header:\n\nmodule program_counter #(parameter SIZE = 16) (input clk, input [SIZE-1:0] i, output reg [SIZE-1:0] o, input rw, input [1:0] inc);\n [/INST]\n", "output": "initial o <= 0; \n  always @(clk) begin \n  case (inc) \n  2'b00 : begin \n  if (rw) \n  o <= i; \n  end \n  2'b01 : o <= o + 2; \n  2'b10 : o <= o + 4; \n  2'b11 : o <= o + 6; \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a rising edge detector for the input signal in_x0 using the ce_1 and clk_1 control signals. It uses an inverter and a 4-bit delay to generate the edge signal edge_x0. The delay and inverter operations are synchronized with the control signals ce_1 and clk_1. When a rising edge is detected on the input signal in_x0, the output edge_x0 is asserted.\n\n Module header:\n\nmodule risingedge_module_530dab4a3f (ce_1,clk_1,edge_x0,in_x0);\n [/INST]\n", "output": "input [0:0] ce_1; \n  input [0:0] clk_1; \n  input [0:0] in_x0; \n  output [0:0] edge_x0; \n  wire [0:0] ce_1_sg_x9; \n  wire [0:0] clk_1_sg_x9; \n  wire [0:0] delay4_q_net; \n  wire [0:0] inverter_op_net; \n  wire [0:0] logical_y_net_x5; \n  wire [0:0] reset_net_x1; \n  assign ce_1_sg_x9 = ce_1; \n  assign clk_1_sg_x9 = clk_1; \n  assign edge_x0 = logical_y_net_x5; \n  assign reset_net_x1 = in_x0; \n xldelay #(.latency(1),.reg_retiming(0),.width(1)) \n delay4 (.ce(ce_1_sg_x9),.clk(clk_1_sg_x9),.d(inverter_op_net),.en(1'b1),.q(delay4_q_net)); \n inverter_33a63b558a inverter (.ce(ce_1_sg_x9),.clk(clk_1_sg_x9),.clr(1'b0),.ip(reset_net_x1),.op(inverter_op_net)); \n logical_28d385d867 logical (.ce(1'b0),.clk(1'b0),.clr(1'b0),.d0(reset_net_x1),.d1(delay4_q_net),.y(logical_y_net_x5)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a multiplexer that selects between two 5-bit inputs (rtIn and rdIn) based on the imSwitch input and performs sign extension on the selected input. The selected input is then extended to a 32-bit output using a sign extension module called outExtend.\n\n Module header:\n\nmodule mux(rtIn, rdIn, imSwitch, out);\n [/INST]\n", "output": "input [4:0] rtIn; \n  input [4:0] rdIn; \n  input imSwitch; \n  output [31:0] out; \n  wire [4:0] whichIn; \n  assign whichIn = imSwitch? rtIn : rdIn; \n  signExtend outExtend(.in(whichIn),.out(out)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a display controller for drawing Mario's score on a screen. It uses the input signals for horizontal and vertical count, HSYNC and VSYNC, RGB color, and blanking. The module calculates the Mario character's position based on predefined parameters and updates the display accordingly. It also checks for character pixels to determine the color of the character and sets the RGB value for the corresponding pixels. The module contains multiple clocked and combinational logic blocks to handle display update, pixel drawing, and character position calculations.\n\n Module header:\n\nmodule DrawMarioScore(input wire clk,input wire rst,input wire [9:0] hcount_in,input wire hsync_in,input wire [9:0] vcount_in,input wire vsync_in,input wire [23:0] rgb_in,input wire blnk_in,input wire [7:0] char_pixels,output reg [9:0] hcount_out,output reg hsync_out,output reg [9:0] vcount_out,output reg vsync_out,output reg [23:0] rgb_out,output reg blnk_out,output reg [7:0] char_xy,output reg [3:0] char_line);\n [/INST]\n", "output": "reg [23:0] rgb_nxt; \n  localparam XPOS = 40; \n  localparam YPOS = 50; \n  localparam WIDTH = 552; \n  localparam HEIGHT = 16; \n  always @(posedge clk or posedge rst) begin \n  if(rst) begin \n  hcount_out <= #1 0; \n  vcount_out <= #1 0; \n  hsync_out <= #1 0; \n  vsync_out <= #1 0; \n  rgb_out <= #1 0; \n  blnk_out <= #1 0; \n  end \n  else begin \n  hcount_out <= #1 hcount_in; \n  vcount_out <= #1 vcount_in; \n  hsync_out <= #1 hsync_in; \n  vsync_out <= #1 vsync_in; \n  rgb_out <= #1 rgb_nxt; \n  blnk_out <= #1 blnk_in; \n  end \n  end \n  always @* begin \n  if ((hcount_in >= XPOS) && (hcount_in < XPOS + WIDTH) && (vcount_in >= YPOS) && (vcount_in < YPOS + HEIGHT) && (char_pixels[(XPOS - hcount_in)])) \n  begin \n  if(char_xy == 8'h20) \n  rgb_nxt = 24'hff_ff_00; \n  else \n  rgb_nxt = 24'hff_ff_ff; \n  end \n  else begin \n  rgb_nxt = rgb_in; \n  end \n  end \n  always @* begin \n  char_xy = (hcount_in - XPOS - 1)>>3; \n  end \n  always @* begin \n  char_line = vcount_in - YPOS; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, ResetToBool, takes an input RST and produces an output VAL. It assigns the value of VAL to 1 if RST is 0, and 0 otherwise.\n\n Module header:\n\nmodule ResetToBool( RST, VAL);\n [/INST]\n", "output": "input RST; \n  output VAL; \n  assign VAL = (RST == 1'b0); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a parameterized FIFO (First-In-First-Out) memory with a push and pop interface. It utilizes a RAM structure with a specified width and depth. The module has read and write pointers, as well as a count to manage the number of valid entries in the FIFO. On the positive edge of the clock or a positive reset, the module initializes the count, read, and write pointers. The push and pop handlers manage data writing and reading from the RAM and update the read and write pointers accordingly. The accept output indicates whether new data can be pushed into the FIFO, and the valid output indicates whether there is data available for popping. The data output provides the value of the data that is popped from the FIFO.\n\n Module header:\n\nmodule tcm_mem_pmem_fifo2 #(parameter WIDTH = 8,parameter DEPTH = 4,parameter ADDR_W = 2) (input clk_i,input rst_i,input [WIDTH-1:0] data_in_i,input push_i,input pop_i,output [WIDTH-1:0] data_out_o,output accept_o,output valid_o);\n [/INST]\n", "output": "localparam COUNT_W = ADDR_W + 1; \n reg [WIDTH-1:0] ram [DEPTH-1:0]; \n reg [ADDR_W-1:0] rd_ptr; \n reg [ADDR_W-1:0] wr_ptr; \n reg [COUNT_W-1:0] count; \n always @ (posedge clk_i or posedge rst_i) \n if (rst_i) \n begin \n  count <= {(COUNT_W) {1'b0}}; \n  rd_ptr <= {(ADDR_W) {1'b0}}; \n  wr_ptr <= {(ADDR_W) {1'b0}}; \n end \n else \n begin \n  if (push_i & accept_o) \n  begin \n  ram[wr_ptr] <= data_in_i; \n  wr_ptr <= wr_ptr + 1; \n  end \n  if (pop_i & valid_o) \n  rd_ptr <= rd_ptr + 1; \n  if ((push_i & accept_o) & ~(pop_i & valid_o)) \n  count <= count + 1; \n  else if (~(push_i & accept_o) & (pop_i & valid_o)) \n  count <= count - 1; \n end \n assign accept_o = (count != DEPTH); \n assign valid_o = (count != 0); \n assign data_out_o = ram[rd_ptr]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements an alternative priority encoder for processing 4-bit data. The input data is fed into two instances of the altpriority encoder, which generate encoded outputs. These outputs are then used to perform a logical operation to produce the final output q, which is a 2-bit encoded representation of the input data.\n\n Module header:\n\nmodule acl_fp_sub_double_altpriority_encoder_q28 (data,q) ;\n [/INST]\n", "output": "input [3:0] data; \n  output [1:0] q; \n  wire [0:0] wire_altpriority_encoder41_q; \n  wire wire_altpriority_encoder41_zero; \n  wire [0:0] wire_altpriority_encoder42_q; \n  acl_fp_sub_double_altpriority_encoder_nh8 altpriority_encoder41 \n (.data(data[1:0]),.q(wire_altpriority_encoder41_q),.zero(wire_altpriority_encoder41_zero)); \n  acl_fp_sub_double_altpriority_encoder_n28 altpriority_encoder42 \n (.data(data[3:2]),.q(wire_altpriority_encoder42_q)); \n  assign \n  q = {wire_altpriority_encoder41_zero, ((wire_altpriority_encoder41_zero & wire_altpriority_encoder42_q) | ((~ wire_altpriority_encoder41_zero) & wire_altpriority_encoder41_q))}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a wrapper for an IDELAYE2 and an IDDR_2CLK instantiation based on the parameters defined. If USE_PHY_IDDR is enabled, it instantiates an IDELAYE2 and an IDDR_2CLK. If USE_IDELAY is also enabled, it uses a fixed IDELAY; otherwise, it assigns the input D to the wire d. The parameters INIT_Q1 and INIT_Q2 set the initial values for the Q1 and Q2 outputs, and DDR_CLK_EDGE determines the DDR clock edge. The SRTYPE parameter configures the type of synchronous reset used in the IDDR_2CLK module. The input and output ports are connected accordingly based on the internal logic.\n\n Module header:\n\nmodule iddr_wrapper (input wire C,input wire CB,input wire CE,input wire S,input wire R,input wire D,output wire Q1,output wire Q2);\n [/INST]\n", "output": "parameter USE_PHY_IDDR = 0; \n  parameter USE_IDELAY = 0; \n  parameter DDR_CLK_EDGE = \"OPPOSITE_EDGE\"; \n  parameter INIT_Q1 = 0; \n  parameter INIT_Q2 = 0; \n  parameter SRTYPE = \"ASYNC\"; \n  generate if (USE_PHY_IDDR) begin \n  wire d; \n  if (USE_IDELAY) begin \n IDELAYE2 # (.IDELAY_TYPE (\"FIXED\"),.DELAY_SRC (\"IDATAIN\"),.IDELAY_VALUE (16)) an_idelay (.IDATAIN (D),.DATAOUT (d)); \n  end else begin \n  assign d = D; \n  end \n IDDR_2CLK # (.SRTYPE (SRTYPE),.INIT_Q1 (INIT_Q1),.INIT_Q2 (INIT_Q2),.DDR_CLK_EDGE (DDR_CLK_EDGE)) the_iddr (.C (C),.CB (CB),.CE (CE),.S (S),.R (R),.D (d),.Q1 (Q1),.Q2 (Q2)); \n  end endgenerate \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an arbiter that coordinates read requests from three different modules. It outputs the master busy signal to indicate if any module is requesting a read. The module also outputs the read request signal, address, and selection signals for the read request, as well as the read data acknowledgement signal. It takes in data and acknowledgement signals from each module and processes the read requests from these modules. The read requests are prioritized, and the address and selection signals for the read request are determined based on the highest priority requesting module.\n\n Module header:\n\nmodule gfx_wbm_read_arbiter (master_busy_o,read_request_o,addr_o,sel_o,dat_i,ack_i,m0_read_request_i,m0_addr_i,m0_sel_i,m0_dat_o,m0_ack_o,m1_read_request_i,m1_addr_i,m1_sel_i,m1_dat_o,m1_ack_o,m2_read_request_i,m2_addr_i,m2_sel_i,m2_dat_o,m2_ack_o);\n [/INST]\n", "output": "output master_busy_o; \n output read_request_o; \n output [31:2] addr_o; \n output [3:0] sel_o; \n input [31:0] dat_i; \n input ack_i; \n input m0_read_request_i; \n input [31:2] m0_addr_i; \n input [3:0] m0_sel_i; \n output [31:0] m0_dat_o; \n output m0_ack_o; \n input m1_read_request_i; \n input [31:2] m1_addr_i; \n input [3:0] m1_sel_i; \n output [31:0] m1_dat_o; \n output m1_ack_o; \n input m2_read_request_i; \n input [31:2] m2_addr_i; \n input [3:0] m2_sel_i; \n output [31:0] m2_dat_o; \n output m2_ack_o; \n wire rreq_w; \n wire [31:2] addr_w; \n wire [3:0] sel_w; \n wire [31:0] dat_w; \n wire ack_w; \n wire [2:0] master_sel; \n assign master_busy_o = m0_read_request_i | m1_read_request_i | m2_read_request_i; \n assign master_sel[0] = m0_read_request_i & !m1_read_request_i & !m2_read_request_i; \n assign master_sel[1] = m1_read_request_i & !m2_read_request_i; \n assign master_sel[2] = m2_read_request_i; \n assign m0_dat_o = dat_i; \n assign m0_ack_o = ack_i & master_sel[0]; \n assign m1_dat_o = dat_i; \n assign m1_ack_o = ack_i & master_sel[1]; \n assign m2_dat_o = dat_i; \n assign m2_ack_o = ack_i & master_sel[2]; \n assign read_request_o = master_sel[2] | \n  master_sel[1] | \n  master_sel[0]; \n assign addr_o = master_sel[2] ? m2_addr_i : \n  master_sel[1] ? m1_addr_i : \n  m0_addr_i; \n assign sel_o = master_sel[2] ? m2_sel_i : \n  master_sel[1] ? m1_sel_i : \n  m0_sel_i; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module declares and assigns several wires and registers, including a register for the RAM full flag. It uses DONT_TOUCH, KEEP, and equivalent_register_removal parameters to specify the behavior of the RAM full flag register. The output wire out is assigned the value of the RAM full flag register. The module also utilizes an FDRE register for the RAM full flag.\n\n Module header:\n\nmodule decalper_eb_ot_sdeen_pot_pi_dehcac_xnilix_wr_status_flags_as (out,\\gic0.gc0.count_d1_reg[5] ,s_dclk_o);\n [/INST]\n", "output": "output out; \n  input \\gic0.gc0.count_d1_reg[5] ; \n  input s_dclk_o; \n  wire \\gic0.gc0.count_d1_reg[5] ; \n  (* DONT_TOUCH *) wire ram_full_fb_i; \n  (* DONT_TOUCH *) wire ram_full_i; \n  wire s_dclk_o; \n  assign out = ram_full_fb_i; \n  (* DONT_TOUCH *) \n  (* KEEP = \"yes\" *) \n  (* equivalent_register_removal = \"no\" *) \n FDRE #(.INIT(1'b0)) \n  ram_full_fb_i_reg \n (.C(s_dclk_o),.CE(1'b1),.D(\\gic0.gc0.count_d1_reg[5] ),.Q(ram_full_fb_i),.R(1'b0)); \n  (* DONT_TOUCH *) \n  (* KEEP = \"yes\" *) \n  (* equivalent_register_removal = \"no\" *) \n FDRE #(.INIT(1'b0)) \n  ram_full_i_reg \n (.C(s_dclk_o),.CE(1'b1),.D(\\gic0.gc0.count_d1_reg[5] ),.Q(ram_full_i),.R(1'b0)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module SRLC16E implements a 16-bit shift register with enable functionality. It has input ports A0, A1, A2, A3, CLK, CE, and D, and output ports Q15 and Q. The module has a 16-bit memory register 'mem' and delay signals 'dly_CE', 'dly_D', and 'dly_addr'. It also has a 4-bit address 'addr' and a delay address signal 'dly_addr'. \n\nThe module uses a positive edge-triggered always block on the CLK signal to write data to the memory register when the delayed CE signal is asserted. Additionally, it has a read address register 'rdaddr' and a read data register 'Q' to read data from the memory based on the delayed address 'dly_addr'. The output Q15 is assigned the value of the 15th bit of the memory register.\n\n Module header:\n\nmodule SRLC16E (A0,A1,A2,A3,CLK,CE,D,Q15,Q);\n [/INST]\n", "output": "input A0,A1,A2,A3,CLK,CE,D; \n output Q15,Q; \n reg [15:0] mem; \n wire #1 dly_CE = CE; \n wire #1 dly_D = D; \n wire [3:0] addr = {A3,A2,A1,A0}; \n wire [3:0] #1 dly_addr = addr; \n assign Q15 = mem[15]; \n always @(posedge CLK) \n begin \n  if (dly_CE) mem = {mem,dly_D}; \n end \n reg [3:0] rdaddr; \n reg Q; \n always @* \n begin \n  rdaddr = dly_addr; \n  #1; \n  Q = mem[rdaddr]; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a DDR3 SDRAM controller instance that processes input clock and data signals for rank 0 and rank 1, and outputs the processed data signals for each rank. It utilizes registers to store and process the input data on the positive and negative edges of the clock signal, and then assigns the processed outputs based on the clock signal.\n\n Module header:\n\nmodule ddr3_s4_uniphy_example_sim_ddr3_s4_uniphy_example_sim_e0_if0_p0_hr_to_fr(clk,d_h0,d_h1,d_l0,d_l1,q0,q1);\n [/INST]\n", "output": "input clk; \n input d_h0; \n input d_h1; \n input d_l0; \n input d_l1; \n output q0; \n output q1; \n reg q_h0; \n reg q_h1; \n reg q_l0; \n reg q_l1; \n reg q_l0_neg; \n reg q_l1_neg; \n  always @(posedge clk) \n  begin \n  q_h0 <= d_h0; \n  q_l0 <= d_l0; \n  q_h1 <= d_h1; \n  q_l1 <= d_l1; \n  end \n  always @(negedge clk) \n  begin \n  q_l0_neg <= q_l0; \n  q_l1_neg <= q_l1; \n  end \n  assign q0 = clk ? q_l0_neg : q_h0; \n  assign q1 = clk ? q_l1_neg : q_h1; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a VGA timing controller for a display with a resolution of 640x480. It generates the horizontal and vertical synchronization signals based on the input clock signal. The module includes parameters for defining the display resolution and porch/sync pulse timings. It uses registers to keep track of the current horizontal and vertical counts, and calculates the visible horizontal and vertical sync pulse widths. The module also includes logic to update the horizontal and vertical counts based on the input clock signal. The horizontal and vertical synchronization signals are generated based on the comparison of the counts with the sync pulse timings.\n\n Module header:\n\nmodule driver_vga_640x480(clk_vga, hs, vs,hc_visible,vc_visible);\n [/INST]\n", "output": "input clk_vga; \n  output hs, vs; \n  output [9:0]hc_visible; \n  output [9:0]vc_visible; \n  parameter hpixels = 10'd1360; \n  parameter vlines = 10'd805; \n  parameter hfp = 10'd64; \n  parameter hsc = 10'd104; \n  parameter hbp = 10'd168; \n  parameter vfp = 10'd3; \n  parameter vsc = 10'd4; \n  parameter vbp = 10'd30; \n  reg [9:0] hc, hc_next, vc, vc_next; \n  assign hc_visible = ((hc < (hpixels - hfp)) && (hc > (hsc + hbp)))?(hc -(hsc + hbp)):10'd0; \n  assign vc_visible = ((vc < (vlines - vfp)) && (vc > (vsc + vbp)))?(vc - (vsc + vbp)):10'd0; \n  always@(*) \n  if(hc == hpixels) \n  hc_next = 10'd0; \n  else \n  hc_next = hc + 10'd1; \n  always@(*) \n  if(hc == 10'd0) \n  if(vc == vlines) \n  vc_next = 10'd0; \n  else \n  vc_next = vc + 10'd1; \n  else \n  vc_next = vc; \n  always@(posedge clk_vga) \n  {hc, vc} <= {hc_next, vc_next}; \n  assign hs = (hc < hsc) ? 1'b0 : 1'b1; \n  assign vs = (vc < vsc) ? 1'b0 : 1'b1; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a shifter circuit with a 128-bit shifter register and a 7-bit write pointer. It selects the shifter based on the address and sel_akiko inputs. On the positive clock edge, it updates the shifter based on the input data and increments the write pointer. When the read signal and select are enabled, it loads the shifter with zero and resets the write pointer. The module then assigns the output data based on the shifter contents and the read signal, and the select signal.\n\n Module header:\n\nmodule akiko (input clk,input reset,input [23:1] address_in,input [15:0] data_in,output [15:0] data_out,input rd,input sel_akiko);\n [/INST]\n", "output": "reg [127:0] shifter; \n reg [6:0] wrpointer; \n wire sel; \n assign sel = sel_akiko && address_in[7:1]==8'b0011_100; \n always @(posedge clk) \n  if (reset) \n  wrpointer <= 0; \n  else if (!rd && sel) \n  begin \n  case(wrpointer) \n  0 : shifter[127:112] <= data_in[15:0]; \n  1 : shifter[111:96] <= data_in[15:0]; \n  2 : shifter[95:80] <= data_in[15:0]; \n  3 : shifter[79:64] <= data_in[15:0]; \n  4 : shifter[63:48] <= data_in[15:0]; \n  5 : shifter[47:32] <= data_in[15:0]; \n  6 : shifter[31:16] <= data_in[15:0]; \n  7 : shifter[15:0] <= data_in[15:0]; \n  endcase \n  wrpointer <= wrpointer + 1; \n  end \n  else if (rd && sel) \n  begin \n  shifter[127:0] <= {shifter[126:0],1'b0}; \n  wrpointer <= 0; \n  end \n  assign data_out[15:0] = sel_akiko && rd ? {shifter[127],shifter[119],shifter[111],shifter[103],shifter[95],shifter[87], \n  shifter[79],shifter[71],shifter[63],shifter[55],shifter[47],shifter[39],shifter[31], \n  shifter[23],shifter[15],shifter[7]} : 16'b0 ; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module simply connects the input signals DOA, DOB, DOC, and DOD to the output signals DOA_OUT, DOB_OUT, DOC_OUT, and DOD_OUT, respectively. It acts as a pass-through for these signals.\n\n Module header:\n\nmodule DRAM_4_OUTPUT_STUB(input DOA, DOB, DOC, DOD,output DOA_OUT, DOB_OUT, DOC_OUT, DOD_OUT);\n [/INST]\n", "output": "assign DOA_OUT = DOA; \n  assign DOB_OUT = DOB; \n  assign DOC_OUT = DOC; \n  assign DOD_OUT = DOD; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"control_mult\" is a finite state machine that performs various control functions based on input signals. It uses a clock signal and a reset signal along with various control signals to determine the state and output signals.\n\nThe module has 5 states: START, CHECK, SHIFT, ADD, and END. It transitions between these states based on input conditions and the current state.\n\nThe \"done\", \"sh\", \"reset\", and \"add\" output signals are set based on the current state and are used to control various operations in the system.\n\nThe module utilizes an 8-bit count register to keep track of the number of iterations within the state machine.\n\nThe module's functionality is primarily driven by the state transitions and the associated control signal outputs that are determined by the current state.\n\n Module header:\n\nmodule control_mult( clk , rst , lsb_B , init , z , done , sh , reset , add );\n [/INST]\n", "output": "input clk; \n  input rst; \n  input lsb_B; \n  input init; \n  input z; \n  output reg done; \n  output reg sh; \n  output reg reset; \n  output reg add; \n  parameter START = 3'b000; \n  parameter CHECK = 3'b001; \n  parameter SHIFT = 3'b010; \n  parameter ADD = 3'b011; \n  parameter END = 3'b100; \n  reg [2:0] state; \n  initial begin \n  done = 0; \n  sh = 0; \n  reset = 0; \n  add = 0; \n  state = 0; \n  end \n reg [3:0] count; \n always @(posedge clk) begin \n  if (rst) begin \n  state = START; \n  end else begin \n  case(state) \n  START:begin \n  count=0; \n  if(init) \n  state = CHECK; \n  else \n  state = START; \n  end \n  CHECK: \n  if(lsb_B) \n  state = SHIFT; \n  else \n  state = ADD; \n  SHIFT: state = ADD; \n  ADD: \n  if(z) \n  state = END; \n  else \n  state = CHECK; \n  END:begin \n  count = count + 1; \n  state = (count>9) ? START : END ; \n  end \n  default: state = START; \n  endcase \n  end \n  end \n always @(state) begin \n  case(state) \n  START:begin \n  done = 0; \n  sh = 0; \n  reset = 1; \n  add = 0; \n  end \n  CHECK:begin \n  done = 0; \n  sh = 0; \n  reset = 0; \n  add = 0; \n  end \n  SHIFT:begin \n  done = 0; \n  sh = 0; \n  reset = 0; \n  add = 1; \n  end \n  ADD:begin \n  done = 0; \n  sh = 1; \n  reset = 0; \n  add = 0; \n  end \n  END:begin \n  done = 1; \n  sh = 0; \n  reset = 0; \n  add = 0; \n  end \n  default:begin \n  done = 0; \n  sh = 0; \n  reset = 0; \n  add = 0; \n  end \n  endcase \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"TestCnt\" contains inputs for a clock signal, reset signal, select signal, shift signal, and test data input. It also has an output for the test data output. The module initializes a register 'from' to 0 and uses a clock signal for the HostIODut module. \n\nThe HostIODut module is instantiated with specific parameters and the 'from' register is connected to it as an input. The HostIODut module generates a clock signal 'clkDut' as an output.\n\nThe \"TestCnt\" module includes an always block that triggers on the positive edge of 'clkDut'. Within this block, the value of 'from' is incremented by 1.\n\nIn summary, the module \"TestCnt\" serves as a test counter that increments the value of 'from' on each positive edge of the 'clkDut' signal.\n\n Module header:\n\nmodule TestCnt (drck1_i, reset_i, sel1_i, shift_i, tdi_i, tdo1_o);\n [/INST]\n", "output": "input drck1_i; \n  input reset_i; \n  input sel1_i; \n  input shift_i; \n  input tdi_i; \n  output tdo1_o; \n  reg [4:0] from = 0; \n  (* BUFFER_TYPE=\"BUFG\" *) \n  wire clkDut; \n  HostIODut #(.ID(1), .FROM_DUT_LENGTH(5), .TO_DUT_LENGTH(4)) hostiodut \n (.fromDut_i(from),.clkDut_o(clkDut),.drck1_i(drck1_i), .reset_i(reset_i), .sel1_i(sel1_i), .shift_i(shift_i), .tdi_i(tdi_i), .tdo1_o(tdo1_o)); \n  always @(posedge clkDut) \n  from <= from + 1; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a data generator for a pipelined FIFO (First-In-First-Out) design. It generates write control signals based on the input signals and manages the writing of data into the FIFO. It keeps track of the write enable, write ready, write data size, and increments the write counter to control the data writing process. The output ports o_wr_act, o_wr_stb, and o_wr_data are controlled based on the input signals and the write counter. The module ensures that the data writing process is synchronized with the clock and resets the control signals when a reset is detected.\n\n Module header:\n\nmodule ppfifo_data_generator (input clk,input rst,input i_enable,input [1:0] i_wr_rdy,output reg [1:0] o_wr_act,input [23:0] i_wr_size,output reg o_wr_stb,output reg [31:0] o_wr_data);\n [/INST]\n", "output": "reg [23:0] r_count; \n always @ (posedge clk) begin \n  if (rst) begin \n  o_wr_act <= 0; \n  o_wr_stb <= 0; \n  o_wr_data <= 0; \n  r_count <= 0; \n  end \n  else begin \n  o_wr_stb <= 0; \n  if (i_enable) begin \n  if ((i_wr_rdy > 0) && (o_wr_act == 0))begin \n  r_count <= 0; \n  if (i_wr_rdy[0]) begin \n  o_wr_act[0] <= 1; \n  end \n  else begin \n  o_wr_act[1] <= 1; \n  end \n  end \n  else if (o_wr_act > 0) begin \n  if (r_count < i_wr_size) begin \n  r_count <= r_count + 1; \n  o_wr_stb <= 1; \n  o_wr_data <= r_count; \n  end \n  else begin \n  o_wr_act <= 0; \n  end \n  end \n  end \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe `dmac_dest_axi_stream` module implements an AXI stream interface with data movement and response generation. It handles data transfers between the input and output interfaces, generating response signals, and managing readiness for data movement. The module instantiates `dmac_data_mover` to handle the data movement and `dmac_response_generator` to generate responses. It also assigns values to various signals like `fifo_ready`, `data_enabled`, `data_id`, and `_fifo_ready` to control the data movement and response generation. Finally, it assigns the `fifo_ready` signal based on the value of `_fifo_ready` and the `enabled` signal.\n\n Module header:\n\nmodule dmac_dest_axi_stream (input s_axis_aclk,input s_axis_aresetn,input enable,output enabled,input sync_id,output sync_id_ret,input [C_ID_WIDTH-1:0] request_id,output [C_ID_WIDTH-1:0] response_id,output [C_ID_WIDTH-1:0] data_id,input data_eot,input response_eot,input m_axis_ready,output m_axis_valid,output [C_S_AXIS_DATA_WIDTH-1:0] m_axis_data,output fifo_ready,input fifo_valid,input [C_S_AXIS_DATA_WIDTH-1:0] fifo_data,input req_valid,output req_ready,input [3:0] req_last_burst_length,output response_valid,input response_ready,output response_resp_eot,output [1:0] response_resp);\n [/INST]\n", "output": "parameter C_ID_WIDTH = 3; \n parameter C_S_AXIS_DATA_WIDTH = 64; \n parameter C_LENGTH_WIDTH = 24; \n assign sync_id_ret = sync_id; \n wire data_enabled; \n wire [C_ID_WIDTH-1:0] data_id; \n wire _fifo_ready; \n dmac_data_mover # (.C_ID_WIDTH(C_ID_WIDTH),.C_DATA_WIDTH(C_S_AXIS_DATA_WIDTH),.C_DISABLE_WAIT_FOR_ID(0)) i_data_mover (.clk(s_axis_aclk),.resetn(s_axis_aresetn),.enable(enable),.enabled(data_enabled),.sync_id(sync_id),.request_id(request_id),.response_id(data_id),.eot(data_eot),.req_valid(req_valid),.req_ready(req_ready),.req_last_burst_length(req_last_burst_length),.m_axi_ready(m_axis_ready),.m_axi_valid(m_axis_valid),.m_axi_data(m_axis_data),.s_axi_ready(_fifo_ready),.s_axi_valid(fifo_valid),.s_axi_data(fifo_data)); \n dmac_response_generator # (.C_ID_WIDTH(C_ID_WIDTH)) i_response_generator (.clk(s_axis_aclk),.resetn(s_axis_aresetn),.enable(data_enabled),.enabled(enabled),.sync_id(sync_id),.request_id(data_id),.response_id(response_id),.eot(response_eot),.resp_valid(response_valid),.resp_ready(response_ready),.resp_eot(response_resp_eot),.resp_resp(response_resp)); \n assign fifo_ready = _fifo_ready | ~enabled; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a D flip-flop with asynchronous reset functionality. It takes inputs D (data), CLK (clock) and outputs Q (output) and QN (complement of output). The output Q is connected to Qtemp and QN is the complement of Qtemp. The module instantiates an FD (flip-flop with asynchronous reset) component called XIL_FD, which is a primitive flip-flop component. When the CLK signal rises, the D input is sampled and stored in Qtemp, and its complement is stored in QN.\n\n Module header:\n\nmodule DFFX1 (D,CLK,Q,QN);\n [/INST]\n", "output": "output Q,QN; \n input D,CLK; \n wire Qtemp; \n  assign QN = ~Qtemp; \n  assign Q = Qtemp; \n  FD XIL_FD (.D(D),.C(CLK),.Q(Qtemp)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module GP_VDD has a single output OUT, which is constantly assigned the value 1.\n\n Module header:\n\nmodule GP_VDD(output OUT);\n [/INST]\n", "output": "assign OUT = 1; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe `cordic` module implements the Coordinate Rotation Digital Computer (CORDIC) algorithm. It takes inputs `x_i`, `y_i`, and `theta_i` and produces outputs `x_o`, `y_o`, and `theta_o`. It uses a `rotator` module to perform rotations and utilizes tangent angle values for CORDIC stored in `tanangle_values_0` to `tanangle_values_15`.\n\nThe module has an `iteration` counter and uses this to select the appropriate tangent angle value for each iteration through a case statement. The `rotator` module is instantiated and driven by the `clk`, `rst`, `init`, `iteration`, `tanangle_of_iteration`, `x`, `y`, and `z` signals.\n\nDuring the rotation, the values of `x`, `y`, and `theta` are updated based on the CORDIC algorithm, and the `x_o`, `y_o`, and `theta_o` outputs are updated accordingly.\n\nThe module also handles the initialization condition, where it selects inputs or outputs based on the `init` signal and resets the `iteration` counter.\n\n Module header:\n\nmodule cordic ( clk,rst,init,x_i,y_i,theta_i,x_o,y_o,theta_o);\n [/INST]\n", "output": "input clk; \n input rst; \n input init; \n input [16:0] x_i; \n input [16:0] y_i; \n input [16:0] theta_i; \n output [16:0] x_o; \n output [16:0] y_o; \n output [16:0] theta_o; \n wire [16:0] tanangle_values_0; \n wire [16:0] tanangle_values_1; \n wire [16:0] tanangle_values_2; \n wire [16:0] tanangle_values_3; \n wire [16:0] tanangle_values_4; \n wire [16:0] tanangle_values_5; \n wire [16:0] tanangle_values_6; \n wire [16:0] tanangle_values_7; \n wire [16:0] tanangle_values_8; \n wire [16:0] tanangle_values_9; \n wire [16:0] tanangle_values_10; \n wire [16:0] tanangle_values_11; \n wire [16:0] tanangle_values_12; \n wire [16:0] tanangle_values_13; \n wire [16:0] tanangle_values_14; \n wire [16:0] tanangle_values_15; \n reg [16:0] tanangle_of_iteration; \n assign tanangle_values_0 = 17'd25735 ; \n assign tanangle_values_1 = 17'd15192; \n assign tanangle_values_2 = 17'd8027; \n assign tanangle_values_3 = 17'd4075; \n assign tanangle_values_4 = 17'd2045; \n assign tanangle_values_5 = 17'd1024; \n assign tanangle_values_6 = 17'd512; \n assign tanangle_values_7 = 17'd256; \n assign tanangle_values_8 = 17'd128; \n assign tanangle_values_9 = 17'd64; \n assign tanangle_values_10 = 17'd32; \n assign tanangle_values_11 = 17'd16; \n assign tanangle_values_12 = 17'd8; \n assign tanangle_values_13 = 17'd4; \n assign tanangle_values_14 = 17'd2; \n assign tanangle_values_15 = 17'd1; \n  reg [4:0] iteration; \n  always @ (iteration or tanangle_values_0 or tanangle_values_1 or tanangle_values_2 or tanangle_values_3 or tanangle_values_4 or tanangle_values_5 or tanangle_values_6 or tanangle_values_7 or tanangle_values_8 or tanangle_values_9 or tanangle_values_10 or tanangle_values_11 or tanangle_values_12 or tanangle_values_13 or tanangle_values_14 or tanangle_values_15) begin \n  case (iteration) \n  'd0:tanangle_of_iteration = tanangle_values_0; \n  'd1:tanangle_of_iteration = tanangle_values_1; \n  'd2:tanangle_of_iteration = tanangle_values_2; \n  'd3:tanangle_of_iteration = tanangle_values_3; \n  'd4:tanangle_of_iteration = tanangle_values_4; \n  'd5:tanangle_of_iteration = tanangle_values_5; \n  'd6:tanangle_of_iteration = tanangle_values_6; \n  'd7:tanangle_of_iteration = tanangle_values_7; \n  'd8:tanangle_of_iteration = tanangle_values_8; \n  'd9:tanangle_of_iteration = tanangle_values_9; \n  'd10:tanangle_of_iteration = tanangle_values_10; \n  'd11:tanangle_of_iteration = tanangle_values_11; \n  'd12:tanangle_of_iteration = tanangle_values_12; \n  'd13:tanangle_of_iteration = tanangle_values_13; \n  'd14:tanangle_of_iteration = tanangle_values_14; \n  default:tanangle_of_iteration = tanangle_values_15; \n  endcase \n  end \n  wire [16:0] x,y,z; \n  assign x = init ? x_i : x_o; \n  assign y = init ? y_i : y_o; \n  assign z = init ? theta_i : theta_o; \n  always @ (posedge clk or posedge init) \n  if (init) iteration <= 0; \n  else iteration <= iteration + 1; \n  rotator U (clk,rst,init,iteration,tanangle_of_iteration,x,y,z,x_o,y_o,theta_o); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `wasca_altpll_1_stdsync_sv6` synchronizes the input signals `din` and `reset_n` with the clock signal `clk`. It uses a D flip-flop `dffpipe3` to synchronize the input data signal. The synchronized output is provided through the `dout` port. When the reset signal `reset_n` is asserted, the module initializes the flip-flop.\n\n Module header:\n\nmodule wasca_altpll_1_stdsync_sv6 (clk,din,dout,reset_n) ;\n [/INST]\n", "output": "input clk; \n  input din; \n  output dout; \n  input reset_n; \n  wire [0:0] wire_dffpipe3_q; \n  wasca_altpll_1_dffpipe_l2c dffpipe3 \n (.clock(clk),.clrn(reset_n),.d(din),.q(wire_dffpipe3_q)); \n  assign \n  dout = wire_dffpipe3_q; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module instantiates an IODELAYCTRL module, controlling the input and output delays for a specific I/O delay group. It uses clock and reset signals to ensure proper timing and synchronization, and incorporates a reset synchronizer to handle reset signal transitions. The module also exposes an output signal, iodelay_ctrl_rdy, to indicate when the IODELAYCTRL module is ready.\n\n Module header:\n\nmodule iodelay_ctrl # (parameter TCQ = 100,parameter IODELAY_GRP = \"IODELAY_MIG\",parameter RST_ACT_LOW = 0) (input clk_ref,input sys_rst,output iodelay_ctrl_rdy);\n [/INST]\n", "output": "localparam RST_SYNC_NUM = 31; \n  wire clk_ref_bufg; \n  wire clk_ref_ibufg; \n  wire rst_ref; \n  reg [RST_SYNC_NUM-1:0] rst_ref_sync_r ; \n  wire rst_tmp_idelay; \n  wire sys_rst_act_hi; \n  assign sys_rst_act_hi = RST_ACT_LOW ? ~sys_rst: sys_rst; \n  assign clk_ref_bufg = clk_ref; \n  assign rst_tmp_idelay = sys_rst_act_hi; \n  always @(posedge clk_ref_bufg or posedge rst_tmp_idelay) \n  if (rst_tmp_idelay) rst_ref_sync_r <= #TCQ {RST_SYNC_NUM{1'b1}}; \n  else rst_ref_sync_r <= #TCQ rst_ref_sync_r << 1; \n  assign rst_ref = rst_ref_sync_r[RST_SYNC_NUM-1]; \n  (* IODELAY_GROUP = IODELAY_GRP *) IDELAYCTRL u_idelayctrl \n (.RDY (iodelay_ctrl_rdy),.REFCLK (clk_ref_bufg),.RST (rst_ref)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module `SyncReset0` simply connects the input `IN_RST_N` to the output `OUT_RST_N`. When the input is low, the output will also be low, and when the input is high, the output will also be high.\n\n Module header:\n\nmodule SyncReset0 (IN_RST_N,OUT_RST_N);\n [/INST]\n", "output": "input IN_RST_N ; \n  output OUT_RST_N ; \n  assign OUT_RST_N = IN_RST_N ; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module defines a SPI interface with parameters for address width, packet width, and number of SPI registers. It includes inputs for reset, clock, hardware enable, and various signals for communication. The module instantiates a SPI master and a SPI slave, each with their respective configurations and connections to the interface signals. It also includes a multiplexer to select between the outputs of the master and slave. The output signals are derived from the outputs of the master and slave components, and there is logic to combine the wait signals from the master and slave. The module integrates both master and slave SPI functionalities to provide a single SPI interface with multiplexed outputs.\n\n Module header:\n\nmodule spi #( parameter AW = 32,parameter PW = 104,parameter UREGS = 13) (input nreset,input clk,input hw_en,output spi_irq,input access_in,input [PW-1:0] packet_in,input wait_in,output access_out,output [PW-1:0] packet_out,output wait_out,output m_sclk,output m_mosi,output m_ss,input m_miso,input s_sclk,input s_mosi,input s_ss,output s_miso);\n [/INST]\n", "output": "wire m_access_out; \n  wire [PW-1:0] m_packet_out; \n  wire m_wait_out; \n  wire s_access_out; \n  wire [PW-1:0] s_packet_out; \n  wire [511:0] s_spi_regs; \n  wire s_wait_out; \n spi_master #(.AW(AW),.PW(PW)) spi_master (.sclk (m_sclk),.mosi (m_mosi),.ss (m_ss),.wait_out (m_wait_out),.access_out (m_access_out),.packet_out (m_packet_out[PW-1:0]),.clk (clk),.nreset (nreset),.hw_en (hw_en),.miso (m_miso),.access_in (access_in),.packet_in (packet_in[PW-1:0]),.wait_in (wait_in)); \n spi_slave #(.AW(AW),.PW(PW),.UREGS(UREGS)) spi_slave (.spi_regs (s_spi_regs[511:0]),.spi_irq (spi_irq),.miso (s_miso),.access_out (s_access_out),.packet_out (s_packet_out[PW-1:0]),.wait_out (s_wait_out),.clk (clk),.nreset (nreset),.hw_en (hw_en),.sclk (s_sclk),.mosi (s_mosi),.ss (s_ss),.wait_in (wait_in),.access_in (access_in),.packet_in (packet_in[PW-1:0])); \n  assign wait_out = s_wait_out | m_wait_out; \n emesh_mux #(.N(2),.AW(AW),.PW(PW)) \n emesh_mux (.wait_out (),.access_out (access_out),.packet_out (packet_out[PW-1:0]),.access_in ({s_access_out,m_access_out}),.packet_in ({s_packet_out[PW-1:0],m_packet_out[PW-1:0]}),.wait_in (wait_in)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module represents a GPIO interface with LED register functionality. The module takes in clock, reset, bus request, write enable, address, byte enable, write data, and GPIO input, and outputs bus acknowledge, response, read data, and GPIO output. \n\nThe LED register is a 4-bit register. The GPIO output is assigned based on the values of the LED register.\n\nThe module uses three always blocks triggered by the clock signal. The first always block handles the bus response and sets it based on the bus request and write enable, with consideration of the reset signal.\n\nThe second always block handles the read data response based on the address and distinguishes between accessing the LED register and the GPIO input.\n\nThe third always block initializes the LED register on reset and writes to the LED register based on bus request, write enable, and address.\n\nThe module also assigns the bus acknowledge signal to the bus request.\n\n Module header:\n\nmodule gpio (input [0:0] clk_i, input [0:0] rst_i, input [0:0] bus_req, input [0:0] bus_we, input [31:0] bus_addr, input [3:0] bus_be, input [31:0] bus_wdata, output [0:0] bus_ack, output reg [0:0] bus_resp, output reg [31:0] bus_rdata, input [15:0] gpio_bi, output [15:0] gpio_bo);\n [/INST]\n", "output": "reg [3:0] led_register [3:0]; \n assign gpio_bo = {led_register[3], led_register[2], led_register[1], led_register[0]}; \n always @(posedge clk_i) \n  begin \n  if (rst_i) bus_resp <= 1'b0; \n  else bus_resp <= bus_req & !bus_we; \n  end \n always @(posedge clk_i) \n  begin \n  if (rst_i) bus_rdata <= 32'h0; \n  else \n  begin \n  if (bus_addr[7:0] < 8'h10) bus_rdata <= led_register[bus_addr[3:2]]; \n  else bus_rdata <= gpio_bi; \n  end \n  end \n always @(posedge clk_i) \n  begin \n  if (rst_i) begin led_register[0] <= 8'h0; led_register[1] <= 8'h0; led_register[2] <= 8'h0; led_register[3] <= 8'h0; end \n  if (bus_req && bus_we && (bus_addr[7:0] < 8'h10)) led_register[bus_addr[3:2]] <= bus_wdata; \n  end \n assign bus_ack = bus_req; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a combinational logic circuit with multiple input and output wires. It connects these wires using various logic gates to perform specific operations. The module also instantiates other modules like vd12401, vba518e, and v873425 to further process the signals. The primary inputs are v27dec4, v82de4f, and v0ef266, and the outputs are v4642b6 and v8e8a67. The internal signals w0 to w11 are used to facilitate the connections between the gates and submodules. Ultimately, the module produces the outputs v4642b6 and v8e8a67 based on the input signals.\n\n Module header:\n\nmodule vad119b (input v27dec4,input v82de4f,input v0ef266,output v4642b6,output v8e8a67);\n [/INST]\n", "output": "wire w0; \n  wire w1; \n  wire w2; \n  wire w3; \n  wire w4; \n  wire w5; \n  wire w6; \n  wire w7; \n  wire w8; \n  wire w9; \n  wire w10; \n  wire w11; \n  assign v8e8a67 = w1; \n  assign v4642b6 = w5; \n  assign w6 = v27dec4; \n  assign w7 = v27dec4; \n  assign w8 = v82de4f; \n  assign w9 = v82de4f; \n  assign w10 = v0ef266; \n  assign w11 = v0ef266; \n  assign w2 = w0; \n  assign w7 = w6; \n  assign w9 = w8; \n  assign w11 = w10; \n vd12401 v2e3d9f (.vcbab45(w0),.v0e28cb(w7),.v3ca442(w9)); \n vd12401 vb50462 (.v0e28cb(w0),.vcbab45(w1),.v3ca442(w11)); \n vba518e v4882f4 (.v3ca442(w2),.vcbab45(w3),.v0e28cb(w10)); \n vba518e v8fcf41 (.vcbab45(w4),.v0e28cb(w6),.v3ca442(w8)); \n v873425 vc5b8b9 (.v3ca442(w3),.v0e28cb(w4),.vcbab45(w5)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a short FIFO (First-In-First-Out) queue with configurable width. It contains a register for data input and output, along with control signals for read, write, clear, full, empty, space, and occupied. It uses SRL16E instances to implement the FIFO functionality, with logic for handling the read, write, clear, and reset operations. The space and occupied signals track the number of available spaces in the FIFO and the number of occupied spaces, respectively. The module also manages the full and empty flags based on the read and write operations.\n\n Module header:\n\nmodule shortfifo #(parameter WIDTH=32) (input clk, input rst,input [WIDTH-1:0] datain,output [WIDTH-1:0] dataout,input read,input write,input clear,output reg full,output reg empty,output reg [4:0] space,output reg [4:0] occupied);\n [/INST]\n", "output": "reg [3:0] a; \n  genvar i; \n  generate \n  for (i=0;i<WIDTH;i=i+1) \n  begin : gen_srl16 \n  SRL16E \n srl16e(.Q(dataout[i]),.A0(a[0]),.A1(a[1]),.A2(a[2]),.A3(a[3]),.CE(write),.CLK(clk),.D(datain[i])); \n  end \n  endgenerate \n  always @(posedge clk) \n  if(rst) \n  begin \n  a <= 0; \n  empty <= 1; \n  full <= 0; \n  end \n  else if(clear) \n  begin \n  a <= 0; \n  empty <= 1; \n  full<= 0; \n  end \n  else if(read & ~write) \n  begin \n  full <= 0; \n  if(a==0) \n  empty <= 1; \n  else \n  a <= a - 1; \n  end \n  else if(write & ~read) \n  begin \n  empty <= 0; \n  if(~empty) \n  a <= a + 1; \n  if(a == 14) \n  full <= 1; \n  end \n  always @(posedge clk) \n  if(rst) \n  space <= 16; \n  else if(clear) \n  space <= 16; \n  else if(read & ~write) \n  space <= space + 1; \n  else if(write & ~read) \n  space <= space - 1; \n  always @(posedge clk) \n  if(rst) \n  occupied <= 0; \n  else if(clear) \n  occupied <= 0; \n  else if(read & ~write) \n  occupied <= occupied - 1; \n  else if(write & ~read) \n  occupied <= occupied + 1; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module is a ring buffer with configurable parameters. It has an input data_i, a write enable we_i, a pop signal pop_i, and an offset offset_i. The module also has an output data_o. The ring buffer has a memory array mem, a write iterator witer, and a read iterator riter. On each clock cycle, if the reset signal rst is active, the write iterator witer is reset to 0. If the write enable we_i is active, the data_i is written to the memory at index witer, and then witer is incremented by 1.\n\nSimilarly, on each clock cycle, if the reset signal rst is active, the read iterator riter is set to the starting value RITER_START. Otherwise, if the pop signal pop_i is active, riter is incremented by 1, and the data_ff is updated with the data from the memory at the read address raddr. Finally, the output data_o is assigned the value of data_ff.\n\n Module header:\n\nmodule ringbuf #(parameter LEN = 16,parameter LEN_LOG2 = 4,parameter RITER_START = LEN/2)(input wire clk,input wire rst,input wire [23:0] data_i,input wire we_i,input wire pop_i,input wire [(LEN_LOG2-1):0] offset_i,output wire [23:0] data_o);\n [/INST]\n", "output": "reg [23:0] mem [(LEN-1):0]; \n reg [(LEN_LOG2-1):0] witer; \n always @(posedge clk) begin \n  if(rst) begin \n  witer <= 0; \n  end else begin \n  if(we_i) begin \n  `ifdef DEBUG \n  $display(\"ringbuf: write addr: %d/%d data: %h\", witer, LEN, data_i); \n  `endif \n  mem[witer] <= data_i; \n  witer <= witer + 1; \n  end \n  end \n end \n reg [(LEN_LOG2-1):0] riter; \n wire [(LEN_LOG2-1):0] raddr = riter - offset_i; \n reg [23:0] data_ff; \n assign data_o = data_ff; \n always @(posedge clk) begin \n  if(rst) \n  riter <= RITER_START; \n  else begin \n  if(pop_i) \n  riter <= riter + 1; \n  data_ff <= mem[raddr]; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a frequency divider that takes an input clock signal and produces an output clock signal at half the frequency. It uses a counter to toggle the output clock signal after a certain number of cycles of the input clock signal. When the counter reaches zero, the output clock signal is inverted, and the counter is reloaded with the maximum count value. Otherwise, the counter is decremented.\n\n Module header:\n\nmodule frequency_divider(clock_out,clock_in);\n [/INST]\n", "output": "input clock_in; \n  output reg clock_out; \n  reg [24:0] counter; \n  initial \n  begin \n  counter = 0; \n  clock_out = 0; \n  end \n  always @(posedge clock_in) \n  begin \n  if(counter == 0) \n  begin \n  counter <= 24999999; \n  clock_out <= ~clock_out; \n  end \n  else \n  counter <= counter - 1; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module converts the output of two altpriority encoders into a 3-bit output. The input data is split and fed into the two encoders. The outputs from the encoders are then combined using logical operations to produce the final 3-bit output q.\n\n Module header:\n\nmodule fp_convert_altpriority_encoder_bv7 (data,q) ;\n [/INST]\n", "output": "input [7:0] data; \n  output [2:0] q; \n  wire [1:0] wire_altpriority_encoder19_q; \n  wire [1:0] wire_altpriority_encoder20_q; \n  wire wire_altpriority_encoder20_zero; \n  fp_convert_altpriority_encoder_6v7 altpriority_encoder19 \n (.data(data[3:0]),.q(wire_altpriority_encoder19_q)); \n  fp_convert_altpriority_encoder_6e8 altpriority_encoder20 \n (.data(data[7:4]),.q(wire_altpriority_encoder20_q),.zero(wire_altpriority_encoder20_zero)); \n  assign \n  q = {(~ wire_altpriority_encoder20_zero), (({2{wire_altpriority_encoder20_zero}} & wire_altpriority_encoder19_q) | ({2{(~ wire_altpriority_encoder20_zero)}} & wire_altpriority_encoder20_q))}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module instantiates a set of inputs and outputs for an FPGA design. It includes a clock signal and reset block. The module also defines parameters for the audio and HDMI I2C addresses. The clock signal is used to control the behavior of the module, with a reset condition to handle initialization. The module as a whole encompasses the functionality for handling HDMI I2C communication, button inputs, UART communication, and LED outputs.\n\n Module header:\n\nmodule fltfpga(input wire clk,input wire reset_n,output wire hdmi_i2c_clk,input wire hdmi_i2c_data_in,output wire hdmi_i2c_data_out,input wire hdmi_tx_int,output wire [23 : 0] hdmi_tdx,output wire hdmi_tx_clk,output wire hdmi_tx_data_en,output wire hdmi_tx_vsync,output wire hdmi_tx_hsync,output wire hdmi_tx_de,input wire scl_in,output wire scl_out,input wire sda_in,output wire sda_out,output wire [7 : 0] led,input wire button0,input wire button1,input wire uart_rxd,output wire uart_txd);\n [/INST]\n", "output": "parameter AUDIO_I2C_ADDR = 8'h42; \n  parameter HDMI_I2C_ADDR = 8'h43; \n  always @ (posedge clk) \n  begin \n  if (!reset_n) \n  begin \n  end \n  else \n  begin \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe provided Verilog module is an RCN bridge that facilitates communication between two separate RCN entities. It includes parameters for ID mask, ID base, address mask, and address base. The module has input and output registers for both the main and sub-RCN. The module evaluates request, response, ID match, and address match signals for both main and sub-RCN. It ensures that there is no crosstalk between the main and sub-RCN through various signal evaluations. The module also contains clock and reset logic for initializing the input and output registers based on the signals and ensuring proper communication between the main and sub-RCN.\n\n Module header:\n\nmodule rcn_bridge (input rst,input clk,input [68:0] main_rcn_in,output [68:0] main_rcn_out,input [68:0] sub_rcn_in,output [68:0] sub_rcn_out);\n [/INST]\n", "output": "parameter ID_MASK = 0; \n  parameter ID_BASE = 1; \n  parameter ADDR_MASK = 0; \n  parameter ADDR_BASE = 1; \n  reg [68:0] main_rin; \n  reg [68:0] main_rout; \n  reg [68:0] sub_rin; \n  reg [68:0] sub_rout; \n  assign main_rcn_out = main_rout; \n  assign sub_rcn_out = sub_rout; \n  wire [5:0] my_id_mask = ID_MASK; \n  wire [5:0] my_id_base = ID_BASE; \n  wire [23:0] my_addr_mask = ADDR_MASK; \n  wire [23:0] my_addr_base = ADDR_BASE; \n  wire main_req = main_rin[68] && main_rin[67]; \n  wire main_rsp = main_rin[68] && !main_rin[67]; \n  wire main_id_match = ((main_rin[65:60] & my_id_mask) == my_id_base); \n  wire main_addr_match = ((main_rin[55:34] & my_addr_mask[23:2]) == my_addr_base[23:2]); \n  wire sub_req = sub_rin[68] && sub_rin[67]; \n  wire sub_rsp = sub_rin[68] && !sub_rin[67]; \n  wire sub_id_match = ((sub_rin[65:60] & my_id_mask) == my_id_base); \n  wire sub_addr_match = ((sub_rin[55:34] & my_addr_mask[23:2]) == my_addr_base[23:2]); \n  wire main_2_main = (main_req && !main_addr_match) || (main_rsp && !main_id_match); \n  wire sub_2_sub = (sub_req && sub_addr_match) || (sub_rsp && sub_id_match); \n  wire no_cross = main_2_main || sub_2_sub; \n  wire main_2_sub = (main_req && main_addr_match) || (main_rsp && main_id_match); \n  wire sub_2_main = (sub_req && !sub_addr_match) || (sub_rsp && !sub_id_match); \n  always @ (posedge clk or posedge rst) \n  if (rst) \n  begin \n  main_rin <= 69'd0; \n  main_rout <= 69'd0; \n  sub_rin <= 69'd0; \n  sub_rout <= 69'd0; \n  end \n  else \n  begin \n  main_rin <= main_rcn_in; \n  main_rout <= (sub_2_main && !no_cross) ? sub_rin : \n  (main_2_sub && !no_cross) ? 69'd0 : main_rin; \n  sub_rin <= sub_rcn_in; \n  sub_rout <= (main_2_sub && !no_cross) ? main_rin : \n  (sub_2_main && !no_cross) ? 69'd0 : sub_rin; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `cf_fir_24_16_16_13` implements a finite impulse response (FIR) filter with specific input and output configurations. It has 21 input signals and 10 output signals, with additional internal signals and registers for processing. The module contains various assignments, such as bit concatenations and additions, and uses a sub-module `cf_fir_24_16_16_14` for further processing. The output signals are derived from the internal computations and the output of the sub-module. The module operates on the rising edge of the `clock_c` input and uses conditional statements to control the flow of data based on the values of `i1` and `i2`. The module efficiently processes the input signals to produce the desired output.\n\n Module header:\n\nmodule cf_fir_24_16_16_13 (clock_c, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, o1, o2, o3, o4, o5, o6, o7, o8, o9, o10);\n [/INST]\n", "output": "input clock_c; \n input i1; \n input i2; \n input [31:0] i3; \n input [31:0] i4; \n input [31:0] i5; \n input [31:0] i6; \n input [31:0] i7; \n input [31:0] i8; \n input [31:0] i9; \n input [31:0] i10; \n input [31:0] i11; \n input [31:0] i12; \n input [31:0] i13; \n input [31:0] i14; \n input [31:0] i15; \n input [31:0] i16; \n input [31:0] i17; \n input [31:0] i18; \n input [31:0] i19; \n input [31:0] i20; \n input [31:0] i21; \n output [32:0] o1; \n output [32:0] o2; \n output [32:0] o3; \n output [32:0] o4; \n output [32:0] o5; \n output [32:0] o6; \n output [32:0] o7; \n output [32:0] o8; \n output [32:0] o9; \n output [32:0] o10; \n wire n1; \n wire [32:0] n2; \n wire n3; \n wire [32:0] n4; \n wire [32:0] n5; \n reg [32:0] n6; \n wire n7; \n wire [32:0] n8; \n wire n9; \n wire [32:0] n10; \n wire [32:0] n11; \n reg [32:0] n12; \n wire [32:0] s13_1; \n wire [32:0] s13_2; \n wire [32:0] s13_3; \n wire [32:0] s13_4; \n wire [32:0] s13_5; \n wire [32:0] s13_6; \n wire [32:0] s13_7; \n wire [32:0] s13_8; \n assign n1 = i3[31]; \n assign n2 = {n1, i3}; \n assign n3 = i4[31]; \n assign n4 = {n3, i4}; \n assign n5 = n2 + n4; \n always @ (posedge clock_c) \n begin \n  if (i2 == 1'b1) \n  n6 <= 33'b000000000000000000000000000000000; \n  else if (i1 == 1'b1) \n  n6 <= n5; \n  if (i2 == 1'b1) \n  n12 <= 33'b000000000000000000000000000000000; \n  else if (i1 == 1'b1) \n  n12 <= n11; \n end \n assign n7 = i5[31]; \n assign n8 = {n7, i5}; \n assign n9 = i6[31]; \n assign n10 = {n9, i6}; \n assign n11 = n8 + n10; \n cf_fir_24_16_16_14 s13 (clock_c, i1, i2, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, s13_1, s13_2, s13_3, s13_4, s13_5, s13_6, s13_7, s13_8); \n assign o10 = s13_8; \n assign o9 = s13_7; \n assign o8 = s13_6; \n assign o7 = s13_5; \n assign o6 = s13_4; \n assign o5 = s13_3; \n assign o4 = s13_2; \n assign o3 = s13_1; \n assign o2 = n12; \n assign o1 = n6; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a slot-based FIFO memory with 32 slots. It takes in a mixed input and stores it in the slot determined by the cnt and stg inputs. The cnt value is adjusted by stg and wrapped around modulo 32. When the cen input is high, the mixed input is assigned to the corresponding slot based on the adjusted cnt value. The module uses a case statement to assign the mixed input to the appropriate slot based on the adjusted cnt value.\n\n Module header:\n\nmodule sep32 #(parameter width=10, parameter stg=5'd0) (input clk,input cen,input [width-1:0] mixed,input [4:0] cnt,output reg [width-1:0] slot_00,output reg [width-1:0] slot_01,output reg [width-1:0] slot_02,output reg [width-1:0] slot_03,output reg [width-1:0] slot_04,output reg [width-1:0] slot_05,output reg [width-1:0] slot_06,output reg [width-1:0] slot_07,output reg [width-1:0] slot_10,output reg [width-1:0] slot_11,output reg [width-1:0] slot_12,output reg [width-1:0] slot_13,output reg [width-1:0] slot_14,output reg [width-1:0] slot_15,output reg [width-1:0] slot_16,output reg [width-1:0] slot_17,output reg [width-1:0] slot_20,output reg [width-1:0] slot_21,output reg [width-1:0] slot_22,output reg [width-1:0] slot_23,output reg [width-1:0] slot_24,output reg [width-1:0] slot_25,output reg [width-1:0] slot_26,output reg [width-1:0] slot_27,output reg [width-1:0] slot_30,output reg [width-1:0] slot_31,output reg [width-1:0] slot_32,output reg [width-1:0] slot_33,output reg [width-1:0] slot_34,output reg [width-1:0] slot_35,output reg [width-1:0] slot_36,output reg [width-1:0] slot_37);\n [/INST]\n", "output": "reg [4:0] cntadj; \n reg [width-1:0] slots[0:31] ; \n localparam pos0 = 33-stg; \n always @(*) \n  cntadj = (cnt+pos0)%32; \n always @(posedge clk) if(cen) begin \n  slots[cntadj] <= mixed; \n  case( cntadj ) \n  5'o00: slot_00 <= mixed; \n  5'o01: slot_01 <= mixed; \n  5'o02: slot_02 <= mixed; \n  5'o03: slot_03 <= mixed; \n  5'o04: slot_04 <= mixed; \n  5'o05: slot_05 <= mixed; \n  5'o06: slot_06 <= mixed; \n  5'o07: slot_07 <= mixed; \n  5'o10: slot_10 <= mixed; \n  5'o11: slot_11 <= mixed; \n  5'o12: slot_12 <= mixed; \n  5'o13: slot_13 <= mixed; \n  5'o14: slot_14 <= mixed; \n  5'o15: slot_15 <= mixed; \n  5'o16: slot_16 <= mixed; \n  5'o17: slot_17 <= mixed; \n  5'o20: slot_20 <= mixed; \n  5'o21: slot_21 <= mixed; \n  5'o22: slot_22 <= mixed; \n  5'o23: slot_23 <= mixed; \n  5'o24: slot_24 <= mixed; \n  5'o25: slot_25 <= mixed; \n  5'o26: slot_26 <= mixed; \n  5'o27: slot_27 <= mixed; \n  5'o30: slot_30 <= mixed; \n  5'o31: slot_31 <= mixed; \n  5'o32: slot_32 <= mixed; \n  5'o33: slot_33 <= mixed; \n  5'o34: slot_34 <= mixed; \n  5'o35: slot_35 <= mixed; \n  5'o36: slot_36 <= mixed; \n  5'o37: slot_37 <= mixed; \n  endcase \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a 4-input 3-bit priority encoder. The inputs i0, i1, i2, and i3 correspond to the data inputs, while s0 and s1 are the select inputs. Based on the select inputs, the module selects the highest priority input that is asserted and assigns it to the output out.\n\n Module header:\n\nmodule f5_test(out, i0, i1, i2, i3, s1, s0);\n [/INST]\n", "output": "output out; \n input i0, i1, i2, i3; \n input s1, s0; \n assign out = (~s1 & s0 & i0) | \n  (~s1 & s0 & i1) | \n  (s1 & ~s0 & i2) | \n  (s1 & s0 & i3); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module interfaces with a system, taking multiple input signals and generating several output signals. It also includes a system module instantiation. It uses assign statements to connect internal signals and outputs, and the always block updates the misoreg based on the spioe signal and also uses some combinational logic for output signals. The module serves as an interface between the input and output signals and the system it interacts with.\n\n Module header:\n\nmodule root(input clk,input sclk,input ssn,input mosi,input tstn,input wdogdisn,input currentlimit0,input currentlimit1,input currentlimit2,input [1:0] tach0,input [1:0] tach1,input [1:0] tach2,output miso,output motorena,output ledaliven,output redled0,output redled1,output redled2,output redled3,output [1:0] pwm0,output [3:0] pwm40,output [1:0] pwm1,output [3:0] pwm41,output [1:0] pwm2,output [3:0] pwm42);\n [/INST]\n", "output": "wire misoi; \n  wire ledalive; \n  wire spioe; \n  wire ss; \n  wire tst; \n  wire wdogdis; \n  reg misoreg; \n  reg redledreg1 = 0; \n  reg redledreg2 = 0; \n  reg redledreg3 = 0; \n system sys0(.clk(clk),.sclk(sclk),.ss(ss),.mosi(mosi),.spioe(spioe),.tst(tst),.wdogdis(wdogdis),.currentlimit0(currentlimit0),.currentlimit1(currentlimit1),.currentlimit2(currentlimit2),.tach0(tach0),.tach1(tach1),.tach2(tach2),.miso(misoi),.motorena(motorena),.ledalive(ledalive),.pwm0(pwm0),.pwm40(pwm40),.pwm1(pwm1),.pwm41(pwm41),.pwm2(pwm2),.pwm42(pwm42)); \n  assign miso = misoreg; \n  assign tst = ~tstn; \n  assign ss = ~ssn; \n  assign wdogdis = ~wdogdisn; \n  assign ledaliven = ~ledalive; \n  assign redled0 = motorena; \n  assign redled1 = redledreg1; \n  assign redled2 = redledreg2; \n  assign redled3 = redledreg3; \n  always @(*) begin \n  if(spioe) \n  misoreg <= misoi; \n  else \n  misoreg <= 1'bz; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a reset controller with multiple reset signals including global reset, MPFE reset, and control reset. It synchronizes the CPU and PCIe reset signals, and includes a timer for generating the global reset signal. The module also initializes MPFE and control registers based on specific conditions, such as PLL lock, calibration success, PCIe readiness, and initialization completion.\n\n Module header:\n\nmodule mpfe_rst ( input bus_clk, input pll_locked, input cal_success, input init_done, input pcie_perstn, input cpu_resetn, input pcie_ready, output global_reset_n, output mpfe_reset_n, output ctrl_reset_n);\n [/INST]\n", "output": "`ifdef MODEL_TECH \n  localparam STOP_COUNT = 26'h000000f; \n `else \n  localparam STOP_COUNT = 26'h3ffffff; \n `endif \n  reg mpfe_reg[1:0]; \n  assign mpfe_reset_n = mpfe_reg[1]; \n  reg ctrl_reg[1:0]; \n  assign ctrl_reset_n = ctrl_reg[1]; \n  reg [25:0] reset_timer; \n  reg pcie_perstn_sync[1:0]; \n  reg cpu_resetn_sync[1:0]; \n  wire timer_resetn = cpu_resetn_sync[1] & pcie_perstn_sync[1]; \n  always @(posedge bus_clk or negedge cpu_resetn) begin \n  if (~cpu_resetn) begin \n  cpu_resetn_sync[0] <= 0; \n  cpu_resetn_sync[1] <= 0; \n  end else begin \n  cpu_resetn_sync[0] <= 1; \n  cpu_resetn_sync[1] <= cpu_resetn_sync[0]; \n  end \n  end \n  always @(posedge bus_clk or negedge pcie_perstn) begin \n  if (~pcie_perstn) begin \n  pcie_perstn_sync[0] <= 0; \n  pcie_perstn_sync[1] <= 0; \n  end else begin \n  pcie_perstn_sync[0] <= 1; \n  pcie_perstn_sync[1] <= pcie_perstn_sync[0]; \n  end \n  end \n  always @(posedge bus_clk or negedge timer_resetn) begin \n  if (~timer_resetn) begin \n  reset_timer <= 0; \n  end else if (reset_timer == STOP_COUNT) begin \n  reset_timer <= STOP_COUNT; \n  end else begin \n  reset_timer <= reset_timer + 1'b1; \n  end \n  end \n  assign global_reset_n = reset_timer == STOP_COUNT; \n  wire mpfe_arstn = global_reset_n & pll_locked & cal_success & pcie_ready; \n  always @(posedge bus_clk or negedge mpfe_arstn) begin \n  if (~mpfe_arstn) begin \n  mpfe_reg[0] <= 0; \n  mpfe_reg[1] <= 0; \n  end else begin \n  mpfe_reg[0] <= 1; \n  mpfe_reg[1] <= mpfe_reg[0]; \n  end \n  end \n  wire ctrl_arstn = global_reset_n & pll_locked & cal_success & pcie_ready & init_done; \n  always @(posedge bus_clk or negedge ctrl_arstn) begin \n  if (~ctrl_arstn) begin \n  ctrl_reg[0] <= 0; \n  ctrl_reg[1] <= 0; \n  end else begin \n  ctrl_reg[0] <= 1; \n  ctrl_reg[1] <= ctrl_reg[0]; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a simple blinker circuit. It uses a 25-bit counter to control the blinking frequency. The direction of the counter is determined by the 'dir' signal. When the counter reaches the maximum value, it changes direction. The 'rst' input resets the counter and direction. The 'blink' output is set based on the most significant bit of the counter.\n\n Module header:\n\nmodule blinker(input clk,input rst,output blink);\n [/INST]\n", "output": "reg [24:0] counter_q, counter_d; \n reg dir; \n assign blink = counter_d[24]; \n always@(counter_q) begin \n  if (dir) begin \n  counter_d = counter_q - 1'b1; \n  end else begin \n  counter_d = counter_q + 1'b1; \n  end \n end \n always@(posedge clk) begin \n  if (rst) begin \n  counter_q <= 25'b0; \n  dir <= 1'b0; \n  end else begin \n  counter_q <= counter_d; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module facilitates data transfer between different components based on the value of ao486_rst. It selects the appropriate address, read, write, and data signals based on the value of ao486_rst. It also updates the validity and wait request signals accordingly. The module ensures proper communication between the components and manages the data flow based on the reset condition.\n\n Module header:\n\nmodule to_driver_sd_avs(input wire clk_sys,input wire rst,input wire ao486_rst,input wire [31:0] hdd_avalon_master_address,input wire hdd_avalon_master_read,output wire [31:0] hdd_avalon_master_readdata,input wire hdd_avalon_master_write,input wire [31:0] hdd_avalon_master_writedata,output wire hdd_avalon_master_waitrequest,output reg hdd_avalon_master_readdatavalid,input wire [31:0] bios_loader_address,input wire bios_loader_read,output wire [31:0] bios_loader_readdata,input wire bios_loader_write,input wire [31:0] bios_loader_writedata,output wire bios_loader_waitrequest,input wire [3:0] bios_loader_byteenable,output wire [1:0] driver_sd_avs_address,output wire driver_sd_avs_read,input wire [31:0] driver_sd_avs_readdata,output wire driver_sd_avs_write,output wire [31:0] driver_sd_avs_writedata);\n [/INST]\n", "output": "assign driver_sd_avs_address = (~ao486_rst) ? hdd_avalon_master_address[3:2] : bios_loader_address[3:2]; \n  assign driver_sd_avs_read = (~ao486_rst) ? hdd_avalon_master_read : bios_loader_read && bios_loader_address[31:4] == 28'h0; \n  assign driver_sd_avs_write = (~ao486_rst) ? hdd_avalon_master_write : bios_loader_write && bios_loader_address[31:4] == 28'h0; \n  assign driver_sd_avs_writedata = (~ao486_rst) ? hdd_avalon_master_writedata : bios_loader_writedata; \n  assign hdd_avalon_master_readdata = (~ao486_rst) ? driver_sd_avs_readdata : 0; \n  assign hdd_avalon_master_waitrequest = 0; \n  always @(posedge clk_sys) hdd_avalon_master_readdatavalid <= (~ao486_rst) ? driver_sd_avs_read : 0; \n  assign bios_loader_readdata = (~ao486_rst) ? 0 : driver_sd_avs_readdata; \n  assign bios_loader_waitrequest = 0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `f12_test` simply assigns the output `out` to the input `in`. This means that whatever value is applied to the input will be directly propagated to the output.\n\n Module header:\n\nmodule f12_test(input in, output out);\n [/INST]\n", "output": "assign out = in; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module named v97d607 defines inputs v6dda25 and ve556f1, and outputs v9e1c43 and ve37344. It also declares wires w0, w1, w2, w3, w4, and w5. The module then assigns values to these wires and makes calls to other Verilog modules v5495b5 and v9c4559. The functionality of the other modules and the purpose of the connections made are not provided in the code snippet.\n\n Module header:\n\nmodule v97d607 (input v6dda25,input ve556f1,output [23:0] v9e1c43,output ve37344);\n [/INST]\n", "output": "wire w0; \n  wire [0:23] w1; \n  wire [0:23] w2; \n  wire w3; \n  wire [0:23] w4; \n  wire w5; \n  assign w0 = ve556f1; \n  assign w3 = v6dda25; \n  assign v9e1c43 = w4; \n  assign ve37344 = w5; \n  assign w4 = w1; \n v5495b5 v5e4c9c (.v782748(w0),.vb02eea(w1),.v15c6e6(w2),.v6dda25(w3)); \n v9c4559 v62e821 (.v005b83(w1),.v53d485(w2),.v4642b6(w5)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a synchronous reset for data_in. When the reset signal (reset_n) is low, data_in is set to 0. Otherwise, the input data (data_in) is stored in a register (data_in_d1) on the rising edge of the clock signal. The stored data is then output on the next rising clock edge, which ensures that the output (data_out) is synchronized with the clock.\n\n Module header:\n\nmodule nios_system_reset_clk_0_domain_synch_module (clk,data_in,reset_n,data_out);\n [/INST]\n", "output": "output data_out; \n  input clk; \n  input data_in; \n  input reset_n; \n  reg data_in_d1 ; \n  reg data_out ; \n  always @(posedge clk or negedge reset_n) \n  begin \n  if (reset_n == 0) \n  data_in_d1 <= 0; \n  else \n  data_in_d1 <= data_in; \n  end \n  always @(posedge clk or negedge reset_n) \n  begin \n  if (reset_n == 0) \n  data_out <= 0; \n  else \n  data_out <= data_in_d1; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a delay function that waits for a specified duration before asserting the DELAY_FIN output. It uses clock and reset inputs to manage an internal state machine and a clock counter to track the elapsed time. The module transitions through the states: Idle, Hold, and Done based on the delay enable signal and the specified delay time. Once the delay is completed and the delay enable signal is still high, the DELAY_FIN output is asserted.\n\n Module header:\n\nmodule Delay(CLK,RST,DELAY_MS,DELAY_EN,DELAY_FIN);\n [/INST]\n", "output": "input CLK; \n  input RST; \n  input [11:0] DELAY_MS; \n  input DELAY_EN; \n  output DELAY_FIN; \n  wire DELAY_FIN; \n  reg [31:0] current_state = \"Idle\"; \n  reg [16:0] clk_counter = 17'b00000000000000000; \n  reg [11:0] ms_counter = 12'h000; \n  assign DELAY_FIN = (current_state == \"Done\" && DELAY_EN == 1'b1) ? 1'b1 : 1'b0; \n  always @(posedge CLK) begin \n  if(RST == 1'b1) begin \n  current_state <= \"Idle\"; \n  end \n  else begin \n  case(current_state) \n  \"Idle\" : begin \n  if(DELAY_EN == 1'b1) begin \n  current_state <= \"Hold\"; \n  end \n  end \n  \"Hold\" : begin \n  if(ms_counter == DELAY_MS) begin \n  current_state <= \"Done\"; \n  end \n  end \n  \"Done\" : begin \n  if(DELAY_EN == 1'b0) begin \n  current_state <= \"Idle\"; \n  end \n  end \n  default : current_state <= \"Idle\"; \n  endcase \n  end \n  end \n  always @(posedge CLK) begin \n  if(current_state == \"Hold\") begin \n  if(clk_counter == 17'b11000011010100000) begin \n  clk_counter <= 17'b00000000000000000; \n  ms_counter <= ms_counter + 1'b1; \n  end \n  else begin \n  clk_counter <= clk_counter + 1'b1; \n  end \n  end \n  else begin \n  clk_counter <= 17'b00000000000000000; \n  ms_counter <= 12'h000; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an AXI DMA Controller that resizes the source data to the memory data width. If the source and memory data widths are the same, it directly connects the source data to the memory, and if they are different, it performs resizing by replicating or skipping source data based on the width ratio. The module generates the appropriate memory data valid signal and resizes the source data accordingly, ensuring the memory receives valid and correctly formatted data.\n\n Module header:\n\nmodule axi_dmac_resize_src #(parameter DATA_WIDTH_SRC = 64,parameter DATA_WIDTH_MEM = 64) (input clk,input reset,input src_data_valid,input [DATA_WIDTH_SRC-1:0] src_data,input src_data_last,output mem_data_valid,output [DATA_WIDTH_MEM-1:0] mem_data,output mem_data_last);\n [/INST]\n", "output": "generate if (DATA_WIDTH_SRC == DATA_WIDTH_MEM) begin \n  assign mem_data_valid = src_data_valid; \n  assign mem_data = src_data; \n  assign mem_data_last = src_data_last; \n end else begin \n  localparam RATIO = DATA_WIDTH_MEM / DATA_WIDTH_SRC; \n  reg [RATIO-1:0] mask = 'h1; \n  reg valid = 1'b0; \n  reg last = 1'b0; \n  reg [DATA_WIDTH_MEM-1:0] data = 'h0; \n  always @(posedge clk) begin \n  if (reset == 1'b1) begin \n  valid <= 1'b0; \n  mask <= 'h1; \n  end else if (src_data_valid == 1'b1) begin \n  valid <= mask[RATIO-1] || src_data_last; \n  if (src_data_last) begin \n  mask <= 'h1; \n  end else begin \n  mask <= {mask[RATIO-2:0],mask[RATIO-1]}; \n  end \n  end else begin \n  valid <= 1'b0; \n  end \n  end \n  integer i; \n  always @(posedge clk) begin \n  for (i = 0; i < RATIO; i = i+1) begin \n  if (mask[i] == 1'b1) begin \n  data[i*DATA_WIDTH_SRC+:DATA_WIDTH_SRC] <= src_data; \n  end \n  end \n  last <= src_data_last; \n  end \n  assign mem_data_valid = valid; \n  assign mem_data = data; \n  assign mem_data_last = last; \n end endgenerate \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a RAM with 1024 words of 16 bits each. It has separate write and read clocks, write enable, data input, write address, read enable, read address, and data output. The RAM is initialized with predefined values. On the positive edge of the write clock, if the write enable is asserted, the module writes the input data to the RAM at the specified address. On the positive edge of the read clock, if the read enable is asserted, the module fetches data from the RAM at the specified address and stores it in the output register.\n\n Module header:\n\nmodule ram0(input wrclk,input [15:0] di,input wren,input [9:0] wraddr,input rdclk,input rden,input [9:0] rdaddr,output reg [15:0] do);\n [/INST]\n", "output": "(* ram_style = \"block\" *) reg [15:0] ram[0:1023]; \n  initial begin \n  ram[0] = 16'b00000000_00000001; \n  ram[1] = 16'b10101010_10101010; \n  ram[2] = 16'b01010101_01010101; \n  ram[3] = 16'b11111111_11111111; \n  ram[4] = 16'b11110000_11110000; \n  ram[5] = 16'b00001111_00001111; \n  ram[6] = 16'b11001100_11001100; \n  ram[7] = 16'b00110011_00110011; \n  ram[8] = 16'b00000000_00000010; \n  ram[9] = 16'b00000000_00000100; \n  end \n  always @ (posedge wrclk) begin \n  if(wren == 1) begin \n  ram[wraddr] <= di; \n  end \n  end \n  always @ (posedge rdclk) begin \n  if(rden == 1) begin \n  do <= ram[rdaddr]; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a base register with 65,536 entries, each of which is 16 bits wide. On a positive clock edge, if the reset input is asserted, all entries in the base register are set to 0. If the write input is asserted, the module writes the data from the writeData input to the address specified in the address input. The data output corresponds to the value stored at the specified address in the base register.\n\n Module header:\n\nmodule BaseRegister(input clock, write, reset,input [15:0] address,input [15:0] writeData,output [15:0] data);\n [/INST]\n", "output": "reg [15:0] base [0:65535]; \n  integer i; \n  initial begin \n  for (i = 0; i < 65536; i = i + 1) \n  base[i] = 16'b0; \n  end \n  always @ (posedge clock) begin \n  if (reset) \n  for (i = 0; i < 65536; i = i + 1) \n  base[i] = 16'b0; \n  else if (write) \n  base[address] = writeData; \n  end \n  assign data = base[address]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module FFType_546 is an instantiation of a module called RetimeWrapper_580. It takes input signals (clock, reset, io_in, io_enable) and provides an output signal (io_out). The input signals are processed and assigned to intermediate and reset signals, and then assigned to the inputs of the RetimeWrapper module. The output of the RetimeWrapper module is then assigned to the io_out signal. The purpose of this module is to interface with the RetimeWrapper module by processing and forwarding the input signals to it, and then forwarding its output to the io_out signal.\n\n Module header:\n\nmodule FFType_546(input clock,input reset,input [39:0] io_in,output [39:0] io_out,input io_enable);\n [/INST]\n", "output": "wire [39:0] d; \n  wire RetimeWrapper_clock; \n  wire RetimeWrapper_reset; \n  wire [39:0] RetimeWrapper_io_in; \n  wire [39:0] RetimeWrapper_io_out; \n  wire [39:0] _T_10; \n  wire [39:0] _GEN_0; \n  wire [39:0] _GEN_1; \n RetimeWrapper_580 RetimeWrapper (.clock(RetimeWrapper_clock),.reset(RetimeWrapper_reset),.io_in(RetimeWrapper_io_in),.io_out(RetimeWrapper_io_out)); \n  assign _GEN_0 = reset ? 40'h0 : _T_10; \n  assign _GEN_1 = io_enable ? io_in : _GEN_0; \n  assign io_out = _T_10; \n  assign d = _GEN_1; \n  assign RetimeWrapper_io_in = d; \n  assign RetimeWrapper_clock = clock; \n  assign RetimeWrapper_reset = reset; \n  assign _T_10 = RetimeWrapper_io_out; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a sprite address generator for a graphics processing unit. It generates the VRAM address and load signals based on various input conditions such as the sprite cycle, enabled flag, object size, object pattern, and temporary data. The module also includes logic for flipping the X and Y coordinates, loading pixel data, and manipulating the VRAM address based on the sprite attributes. The module has sequential logic to handle the loading of data into temporary registers based on the clock signal and the CE (chip enable) signal. Overall, it facilitates the organization and manipulation of data for rendering sprites in a graphics system.\n\n Module header:\n\nmodule SpriteAddressGen(input clk, input ce,input enabled,input obj_size,input obj_patt,input [2:0] cycle,input [7:0] temp,output [12:0] vram_addr,input [7:0] vram_data,output [3:0] load,output [26:0] load_in);\n [/INST]\n", "output": "reg [7:0] temp_tile; \n  reg [3:0] temp_y; \n  reg flip_x, flip_y; \n  wire load_y = (cycle == 0); \n  wire load_tile = (cycle == 1); \n  wire load_attr = (cycle == 2) && enabled; \n  wire load_x = (cycle == 3) && enabled; \n  wire load_pix1 = (cycle == 5) && enabled; \n  wire load_pix2 = (cycle == 7) && enabled; \n  reg dummy_sprite; \n  wire [7:0] vram_f = dummy_sprite ? 0 : \n  !flip_x ? {vram_data[0], vram_data[1], vram_data[2], vram_data[3], vram_data[4], vram_data[5], vram_data[6], vram_data[7]} : \n  vram_data; \n  wire [3:0] y_f = temp_y ^ {flip_y, flip_y, flip_y, flip_y}; \n  assign load = {load_pix1, load_pix2, load_x, load_attr}; \n  assign load_in = {vram_f, vram_f, temp, temp[1:0], temp[5]}; \n  assign vram_addr = {obj_size ? temp_tile[0] : obj_patt, \n  temp_tile[7:1], obj_size ? y_f[3] : temp_tile[0], cycle[1], y_f[2:0] }; \n  always @(posedge clk) if (ce) begin \n  if (load_y) temp_y <= temp[3:0]; \n  if (load_tile) temp_tile <= temp; \n  if (load_attr) {flip_y, flip_x, dummy_sprite} <= {temp[7:6], temp[4]}; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module generates pulse width modulation (PWM) signals based on the input clock and reset signals. It uses a state machine to track the pulse width periods for the high and low states of the PWM signal. The module calculates the pulse width period and updates the pulse width low and pulse width high accordingly. It utilizes counters to keep track of clock cycles and transitions between the low and high states of the PWM signal. The module also handles the transition between different states to control the PWM signal.\n\n Module header:\n\nmodule pulseLength (input wire clk,input wire reset,output reg [30:0] pw_low,output reg [30:0] pw_high,output reg [31:0] pwm_per,input wire pwm);\n [/INST]\n", "output": "reg [1:0] ps, ns; \n  parameter \n  init = 2'b00, \n  first = 2'b01, \n  low = 2'b10, \n  high = 2'b11; \n  reg pwm_prev; \n  reg [30:0] count_clk0, count_clk1; \n  initial begin \n  ps = init; \n  pwm_prev = 1'b1; \n  count_clk0 = 31'b0; \n  count_clk1 = 31'b0; \n  pw_high = 31'b0; \n  pw_low = 31'b0; \n  pwm_per = 32'b0; \n  end \n  always @ (*) begin \n  case (ps) \n  init: if (pwm_prev ^ pwm) ns = first; \n  else ns = init; \n  first: if (~pwm_prev & pwm) ns = high; \n  else if (pwm_prev & ~pwm) ns = low; \n  else ns = first; \n  low: if (pwm) ns = high; \n  else ns = low; \n  high: if (~pwm) ns = low; \n  else ns = high; \n  endcase \n  pwm_per = pw_low + pw_high; \n  end \n  always @ (posedge clk) begin \n  if (reset) begin \n  count_clk0 <= 31'b0; \n  count_clk1 <= 31'b0; \n  pw_high <= 31'bX; \n  pw_low <= 31'bX; \n  pwm_per <= 32'bX; \n  end else begin \n  case (ps) \n  first: begin \n  if (~pwm) count_clk0 <= count_clk0 + 1'b1; \n  else count_clk1 <= count_clk1 + 1'b1; \n  end \n  low: begin \n  if (count_clk1) begin \n  pw_high <= count_clk1; \n  count_clk1 <= 31'b0; \n  end \n  count_clk0 <= count_clk0 + 1'b1; \n  end \n  high: begin \n  if (count_clk0) begin \n  pw_low <= count_clk0; \n  count_clk0 <= 31'b0; \n  end \n  count_clk1 <= count_clk1 + 1'b1; \n  end \n  default: begin \n  pw_low <= 31'bX; \n  pw_high <= 31'bX; \n  count_clk0 <= 31'b0; \n  count_clk1 <= 31'b0; \n  end \n  endcase \n  end \n  pwm_prev <= pwm; \n  end \n  always @ (posedge clk) begin \n  if (reset) ps <= init; \n  else ps <= ns; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module compares the bits of two 8-bit input vectors 'a' and 'b'. It uses a for loop to iterate through each bit position and performs a bitwise XOR operation between the corresponding bits of 'a' and 'b'. The result of this XOR operation is then inverted and stored in the 'match' output vector, effectively indicating which bits in 'a' and 'b' are matching.\n\n Module header:\n\nmodule match_bits_v(input [7:0] a,b, output reg [7:0] match);\n [/INST]\n", "output": "integer i; \n  wire ab_xor; \n  always @(a or b) begin \n  for (i=7; i>=0; i=i-1) begin \n  match[i] = ~(a[i]^b[i]); \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an arbiter matching queue with configurable parameters. It contains write and read request interfaces, as well as full and empty flags for the queue. The module uses counters to keep track of the queue state and valid flags for each entry in the queue. It has logic to handle write and read requests, and it resets the counters and queue valid flags on reset. The module outputs flags indicating if the queue is full or empty, the validity of the read data, and the type of data being read.\n\n Module header:\n\nmodule mist1032sa_arbiter_matching_queue #(parameter D = 8,parameter DN = 3,parameter FN = 1)(input wire iCLOCK,input wire inRESET,input wire iFLASH,input wire iWR_REQ,input wire [FN-1:0] iWR_FLAG,output wire oWR_FULL,input wire iRD_REQ,output wire oRD_VALID,output wire [FN-1:0] oRD_FLAG,output wire oRD_EMPTY);\n [/INST]\n", "output": "wire full_flag; \n  wire empty_flag; \n  wire [DN:0] count; \n  reg [DN:0] wr_counter; \n  reg [DN:0] rd_counter; \n  reg queue_valid[0:D-1]; \n  reg [FN-1:0] queue_type[0:D-1]; \n  integer i; \n  assign full_flag = count[DN]; \n  assign empty_flag = (wr_counter == rd_counter)? 1'b1 : 1'b0; \n  assign count = wr_counter - rd_counter; \n  always@(posedge iCLOCK or negedge inRESET)begin \n  if(!inRESET)begin \n  wr_counter <= {DN+1{1'b0}}; \n  rd_counter <= {DN+1{1'b0}}; \n  for(i = 0; i < D; i = i + 1)begin \n  queue_valid[i] <= 1'b0; \n  end \n  end \n  else begin \n  if(iFLASH)begin \n  for(i = 0; i < D; i = i + 1)begin \n  queue_valid[i] <= 1'b0; \n  end \n  end \n  if(!full_flag && iWR_REQ)begin \n  wr_counter <= wr_counter + {{DN{1'b0}}, 1'b1}; \n  queue_valid[wr_counter[DN-1:0]] <= 1'b1; \n  queue_type[wr_counter[DN-1:0]] <= iWR_FLAG; \n  end \n  if(!empty_flag && iRD_REQ)begin \n  rd_counter <= rd_counter + {{DN{1'b0}}, 1'b1}; \n  queue_valid[rd_counter[DN-1:0]] <= 1'b0; \n  end \n  end \n  end \n  assign oWR_FULL = full_flag; \n  assign oRD_VALID = queue_valid[rd_counter[DN-1:0]] && !iFLASH; \n  assign oRD_FLAG = queue_type[rd_counter[DN-1:0]]; \n  assign oRD_EMPTY = empty_flag; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module eth_crc_40 calculates a 40-bit cyclic redundancy check (CRC) on the input data_in using the crc_iteration function. The output crc_next represents the updated CRC state after the computation.\n\n Module header:\n\nmodule eth_crc_40 (input wire [39:0] data_in,input wire [31:0] crc_state,output wire [31:0] crc_next);\n [/INST]\n", "output": "assign crc_next = crc_iteration( 40, crc_state, { 88'h0, data_in} ); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements an infinite Finite State Machine (FSM) with four states: IDLE, BBUSY, BWAIT, and BFREE. It includes inputs for dly, done, req, clk, and rst_n, as well as an output reg gnt. The module has state and next state registers, and uses a clock edge trigger to update the state based on the next state. The state transition logic is defined using a case statement, where the next state and gnt signals are assigned based on the current state and input conditions. The FSM transitions between states based on the input signals req, dly, and done, and generates the grant signal gnt accordingly.\n\n Module header:\n\nmodule in_fsm (output reg gnt,input dly, done, req, clk, rst_n);\n [/INST]\n", "output": "parameter [1:0] IDLE = 2'b00, \n  BBUSY = 2'b01, \n  BWAIT = 2'b10, \n  BFREE = 2'b11; \n reg [1:0] state; \n reg [1:0] next; \n always @(posedge clk) begin \n  state <= next; \n end \n always @(state or dly or done or req) begin \n  next = 2'bx; \n  gnt = 1'b0; \n  case (state) \n  IDLE: \n  if (req) \n  next = BBUSY; \n  else \n  next = IDLE; \n  BBUSY: begin \n  gnt = 1'b1; \n  if (!done) \n  next = BBUSY; \n  else begin \n  if ( dly ) \n  next = BWAIT; \n  else \n  next = BFREE; \n  end \n  end \n  BWAIT: begin \n  gnt = 1'b1; \n  if (!dly) \n  next = BFREE; \n  else begin \n  next = BWAIT; \n  end \n  end \n  BFREE: \n  if ( req ) \n  next = BBUSY; \n  else \n  next = IDLE; \n  endcase \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nApologies, I can only explain the high-level functionality of the provided Verilog modules.\n\n Module header:\n\nmodule JohnsonCounter_Tester (output reg clk, rst_n,input [3:0] out);\n [/INST]\n", "output": "parameter stimDelay = 20; \n  always #(stimDelay/2) clk = ~clk; \n  initial \n  begin \n  $display(\"\\t\\t clk rst_n \\t out \\t Time \"); \n  $monitor(\"\\t %b \", out, $time); \n  clk = 'b0; \n  end \n  always @(posedge clk) \n  begin \n  rst_n = 'b0; \n  #stimDelay rst_n = 'b1; \n  #(32*stimDelay) rst_n = 'b0; \n  #stimDelay clk = 'b1; \n  #(32*stimDelay) clk = 'b0; \n  #stimDelay clk = 'b1; \n  #(2*stimDelay); \n  $stop; \n  $finish; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module has 5 input signals and 10 output signals. The output signals are assigned based on the input signals using bitwise negation. The output signals are named according to specific patterns based on the input signal names.\n\n Module header:\n\nmodule pcx_buf_pdl_even(arbpc0_pcxdp_grant_pa, arbpc0_pcxdp_q0_hold_pa_l,arbpc0_pcxdp_qsel0_pa, arbpc0_pcxdp_qsel1_pa_l,arbpc0_pcxdp_shift_px, arbpc2_pcxdp_grant_pa,arbpc2_pcxdp_q0_hold_pa_l, arbpc2_pcxdp_qsel0_pa,arbpc2_pcxdp_qsel1_pa_l, arbpc2_pcxdp_shift_px,arbpc0_pcxdp_grant_bufp1_pa_l, arbpc0_pcxdp_q0_hold_bufp1_pa,arbpc0_pcxdp_qsel0_bufp1_pa_l, arbpc0_pcxdp_qsel1_bufp1_pa,arbpc0_pcxdp_shift_bufp1_px_l, arbpc2_pcxdp_grant_bufp1_pa_l,arbpc2_pcxdp_q0_hold_bufp1_pa, arbpc2_pcxdp_qsel0_bufp1_pa_l,arbpc2_pcxdp_qsel1_bufp1_pa, arbpc2_pcxdp_shift_bufp1_px_l);\n [/INST]\n", "output": "output arbpc0_pcxdp_grant_pa ; \n  output arbpc0_pcxdp_q0_hold_pa_l ; \n  output arbpc0_pcxdp_qsel0_pa ; \n  output arbpc0_pcxdp_qsel1_pa_l ; \n  output arbpc0_pcxdp_shift_px ; \n  output arbpc2_pcxdp_grant_pa ; \n  output arbpc2_pcxdp_q0_hold_pa_l ; \n  output arbpc2_pcxdp_qsel0_pa ; \n  output arbpc2_pcxdp_qsel1_pa_l ; \n  output arbpc2_pcxdp_shift_px ; \n  input arbpc0_pcxdp_grant_bufp1_pa_l; \n  input arbpc0_pcxdp_q0_hold_bufp1_pa; \n  input arbpc0_pcxdp_qsel0_bufp1_pa_l; \n  input arbpc0_pcxdp_qsel1_bufp1_pa; \n  input arbpc0_pcxdp_shift_bufp1_px_l; \n  input arbpc2_pcxdp_grant_bufp1_pa_l; \n  input arbpc2_pcxdp_q0_hold_bufp1_pa; \n  input arbpc2_pcxdp_qsel0_bufp1_pa_l; \n  input arbpc2_pcxdp_qsel1_bufp1_pa; \n  input arbpc2_pcxdp_shift_bufp1_px_l; \n  assign arbpc0_pcxdp_grant_pa = ~arbpc0_pcxdp_grant_bufp1_pa_l; \n  assign arbpc0_pcxdp_q0_hold_pa_l = ~arbpc0_pcxdp_q0_hold_bufp1_pa; \n  assign arbpc0_pcxdp_qsel0_pa = ~arbpc0_pcxdp_qsel0_bufp1_pa_l; \n  assign arbpc0_pcxdp_qsel1_pa_l = ~arbpc0_pcxdp_qsel1_bufp1_pa; \n  assign arbpc0_pcxdp_shift_px = ~arbpc0_pcxdp_shift_bufp1_px_l; \n  assign arbpc2_pcxdp_grant_pa = ~arbpc2_pcxdp_grant_bufp1_pa_l; \n  assign arbpc2_pcxdp_q0_hold_pa_l = ~arbpc2_pcxdp_q0_hold_bufp1_pa; \n  assign arbpc2_pcxdp_qsel0_pa = ~arbpc2_pcxdp_qsel0_bufp1_pa_l; \n  assign arbpc2_pcxdp_qsel1_pa_l = ~arbpc2_pcxdp_qsel1_bufp1_pa; \n  assign arbpc2_pcxdp_shift_px = ~arbpc2_pcxdp_shift_bufp1_px_l; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a parameterized data memory with a depth specified by the \"depth\" parameter. It has two sets of 8-bit RAM (RAM 0 and RAM 1). It takes input addresses, write enables, and data, and provides output data based on the input addresses. The module has synchronous behavior driven by the sys_clk. It updates the address registers, writes data to RAM1 and RAM0 based on the write enables, and provides data output and output 2 based on the input addresses. The output do2 concatenates the data outputs from RAM1 and RAM0, and the module overall acts as a synchronous dual-port memory with separate read and write ports.\n\n Module header:\n\nmodule fmlbrg_datamem #(parameter depth = 8) (input sys_clk,input [depth-1:0] a,input [1:0] we,input [15:0] di,output [15:0] dout,input [depth-1:0] a2,output [15:0] do2);\n [/INST]\n", "output": "reg [7:0] ram0[0:(1 << depth)-1]; \n reg [7:0] ram1[0:(1 << depth)-1]; \n wire [7:0] ram0di; \n wire [7:0] ram1di; \n wire [7:0] ram0do; \n wire [7:0] ram1do; \n wire [7:0] ram0do2; \n wire [7:0] ram1do2; \n reg [depth-1:0] a_r; \n reg [depth-1:0] a2_r; \n always @(posedge sys_clk) begin \n  a_r <= a; \n  a2_r <= a2; \n end \n always @(posedge sys_clk) begin \n  if(we[1]) \n  ram1[a] <= ram1di; \n end \n assign ram1do = ram1[a_r]; \n assign ram1do2 = ram1[a2_r]; \n always @(posedge sys_clk) begin \n  if(we[0]) \n  ram0[a] <= ram0di; \n end \n assign ram0do = ram0[a_r]; \n assign ram0do2 = ram0[a2_r]; \n assign ram0di = di[7:0]; \n assign ram1di = di[15:8]; \n assign dout = {ram1do, ram0do}; \n assign do2 = {ram1do2, ram0do2}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, simple_test_3a, takes a wide input bus and a 4-bit selector as input and selects a specific 8-bit chunk from the input bus based on the selector value. The selected 8-bit value is then assigned to the output selected_out.\n\n Module header:\n\nmodule simple_test_3a (input logic [8*16-1:0] wide_input_bus,input logic [3:0] selector,output logic [7:0] selected_out);\n [/INST]\n", "output": "always_comb \n  selected_out = {wide_input_bus[selector*8+7], \n  wide_input_bus[selector*8+6], \n  wide_input_bus[selector*8+5], \n  wide_input_bus[selector*8+4], \n  wide_input_bus[selector*8+3], \n  wide_input_bus[selector*8+2], \n  wide_input_bus[selector*8+1], \n  wide_input_bus[selector*8]}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module simulates a radio receiver system. It comprises submodules for synchronization, hysteresis, edge detection, and radio reception state machine. The input CLK_1M provides the clock signal, RESET for reset, and RADIO_IN for radio input. The module generates DATA_OUT as a 32-bit output, with the most significant bit inverted and the next 19 bits set to 0, followed by a 12-bit pulse_width.\n\n Module header:\n\nmodule radio_rx( input CLK_1M,input RESET,input RADIO_IN,output [31:0] DATA_OUT );\n [/INST]\n", "output": "wire sync_out, clean_out, edge_p, edge_n, online; \n wire [11:0] pulse_width; \n sync smodule(CLK_1M, RADIO_IN, sync_out); \n hystheresis hmodule(CLK_1M, RESET, sync_out, clean_out); \n edetect emodule(CLK_1M, clean_out, edge_p, edge_n); \n radio_rx_sm rmodule(CLK_1M, RESET, edge_p, edge_n, online, pulse_width); \n assign DATA_OUT = {~online, 19'd0, pulse_width}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a finite state machine with input signals giro, entrada, saida, metais, and clock, and output signals ledVerde, ledVermelho, and display. The module contains five states A, B, C, D, and E, and transitions between these states are determined based on the combinations of input signals. Each state initializes temporary registers for the LEDs and the display and transitions to the next state based on the input conditions. The output signals ledVerde, ledVermelho, and display are assigned the values of the temporary registers. If none of the conditions are met, the state machine defaults to state A.\n\n Module header:\n\nmodule inicial ( giro, entrada, saida, metais, ledVerde, ledVermelho, display, clock );\n [/INST]\n", "output": "input giro, entrada, saida, metais, clock; \n  output [1:0] ledVerde, ledVermelho; \n  output [6:0] display; \n  reg [2:0] estado; \n  reg [3:0] tmp; \n  reg [1:0] tmpLedVerde, tmpLedVermelho; \n  reg [6:0] tmpDisplay; \n  parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100; \n  initial estado = A; \n  always @( posedge clock ) begin \n  tmp = { giro, entrada, saida, metais }; \n  case( estado ) \n  A: begin \n  tmpLedVerde = 2'b00; \n  tmpLedVermelho = 2'b00; \n  tmpDisplay = 7'b1111001; \n  if( tmp == 4'b1100 ) \n  estado = B; \n  if( tmp == 4'b1101 | tmp == 4'b1111 ) \n  estado = C; \n  if( tmp == 4'b1110 ) \n  estado = D; \n  if( tmp == 4'b1010 ) \n  estado = E; \n  end \n  B: begin \n  tmpLedVerde = 2'b01; \n  tmpLedVermelho = 2'b00; \n  tmpDisplay = 7'b0100100; \n  if( tmp == 4'b0000 | tmp == 4'b1000 ) \n  estado = A; \n  if( tmp == 4'b1101 ) \n  estado = C; \n  if( tmp == 4'b1110 | tmp == 4'b1111 ) \n  estado = D; \n  if( tmp == 4'b1010 | tmp == 4'b1011 ) \n  estado = E; \n  end \n  C: begin \n  tmpLedVerde = 2'b00; \n  tmpLedVermelho = 2'b01; \n  tmpDisplay = 7'b0110000; \n  if( tmp == 4'b0100 | tmp == 4'b1100 ) \n  estado = B; \n  if( tmp == 4'b0000 | tmp == 4'b1000 ) \n  estado = A; \n  if( tmp == 4'b0110 | tmp == 4'b1110 ) \n  estado = D; \n  if( tmp == 4'b1010 ) \n  estado = E; \n  end \n  D: begin \n  tmpLedVerde = 2'b10; \n  tmpLedVermelho = 2'b10; \n  tmpDisplay = 7'b0011001; \n  if( tmp == 4'b0111 | tmp == 4'b1111 ) \n  estado = C; \n  if( tmp == 4'b1100 ) \n  estado = B; \n  if( tmp == 4'b1010 ) \n  estado = E; \n  if( tmp == 4'b0000 | tmp == 4'b1000 ) \n  estado = A; \n  end \n  E: begin \n  tmpLedVerde = 2'b00; \n  tmpLedVermelho = 2'b00; \n  tmpDisplay = 7'b0010010; \n  if( tmp == 4'b0000 | tmp == 4'b1000 ) \n  estado = A; \n  if( tmp == 4'b0110 | tmp == 4'b1110 ) \n  estado = D; \n  if( tmp == 4'b1100 ) \n  estado = B; \n  if( tmp == 4'b1101 ) \n  estado = C; \n  end \n  default: estado = A; \n  endcase \n  end \n  assign ledVerde = tmpLedVerde; \n  assign ledVermelho = tmpLedVermelho; \n  assign display = tmpDisplay; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a simple asynchronous FIFO (First-In-First-Out) memory. It has input ports for clock, control enable (ce), negative reset (nrst), reset, write data (wdata), write (wr), read (rd), and output ports for read data (rdata), empty, half_full, and full. The module contains a memory array to store the data, a counter to keep track of the number of elements in the FIFO, and separate write and read addresses. The module includes logic to handle read and write operations based on the control signals and clock, as well as managing the read and write addresses. The empty, half_full, and full flags are set based on the count of elements in the FIFO.\n\n Module header:\n\nmodule fifo_async_rd (clk ,ce ,nrst ,reset ,wdata ,wr ,rd ,rdata ,empty ,half_full ,full);\n [/INST]\n", "output": "parameter WIDTH = 8 ; \n parameter DEPTH = 8 ; \n parameter ADDR_BITS = 3 ; \n input clk ; \n input ce ; \n input nrst ; \n input reset ; \n input [WIDTH-1:0] wdata ; \n input wr ; \n input rd ; \n output [WIDTH-1:0] rdata ; \n output empty ; \n output half_full ; \n output full ; \n reg [WIDTH-1:0] mem [DEPTH-1:0] ; \n reg [ADDR_BITS:0] cnt ; \n reg [ADDR_BITS-1:0] waddr ; \n reg [ADDR_BITS-1:0] raddr ; \n assign empty = cnt == 0 ; \n assign full = cnt == DEPTH ; \n assign half_full = cnt >= DEPTH/2 ; \n always @ (posedge clk or negedge nrst) \n  if(~nrst) \n  cnt <= 0 ; \n  else if(ce) \n  begin \n  if (reset) \n  cnt <= 0 ; \n  else if (wr & ~rd) \n  cnt <= cnt +1 ; \n  else if (rd & ~wr) \n  cnt <= cnt -1 ; \n  end \n always @ (posedge clk or negedge nrst) \n  if(~nrst) \n  waddr <= 0 ; \n  else if(ce) \n  begin \n  if (reset) \n  waddr <= 0 ; \n  else if (wr) \n  waddr <= waddr == DEPTH -1 ? 0 : waddr +1 ; \n  end \n always @ (posedge clk or negedge nrst) \n  if(~nrst) \n  raddr <= 0 ; \n  else if(ce) \n  begin \n  if (reset) \n  raddr <= 0 ; \n  else if (rd) \n  raddr <= raddr == DEPTH -1 ? 0 : raddr +1 ; \n  end \n always @ (posedge clk) \n  if(ce) \n  begin \n  if (wr) \n  mem [waddr] <= wdata ; \n  end \n assign rdata = mem [raddr] ; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module implements an 8-bit ALU (Arithmetic Logic Unit) with two 8-bit inputs A_in and B_in, a carry-in C_in, a 3-bit opcode Opcode_in, an 8-bit result output Result_out, and a carry-out C_out. The ALU performs addition, subtraction, bitwise AND, bitwise OR, and modulus operations based on the opcode input. The result is stored in reg_result, and the carry-out is stored in reg_cout. The ALU operates based on the opcode provided and updates the result and carry-out accordingly.\n\n Module header:\n\nmodule alu8b (input wire [7:0] A_in,input wire [7:0] B_in,input wire C_in,input wire [2:0] Opcode_in,output wire [7:0] Result_out,output wire C_out);\n [/INST]\n", "output": "reg [7:0] reg_result; \n  reg reg_cout; \n  wire [7:0] temp_sum; \n  wire temp_cout; \n  assign Result_out = reg_result; \n  assign C_out = reg_cout; \n  assign {temp_cout, temp_sum} = A_in + B_in + C_in; \n  always @ ( * ) begin \n  reg_cout = 1'b0; \n  case (Opcode_in) \n  3'b000: \n  begin \n  reg_cout = temp_cout; \n  reg_result = temp_sum; \n  end \n  3'b001: \n  reg_result = A_in - B_in; \n  3'b010: \n  reg_result = A_in & B_in; \n  3'b011: \n  reg_result = A_in | B_in; \n  3'b100: \n  reg_result = A_in % B_in; \n  default: \n  reg_result = 8'b0; \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module performs signed 32-bit multiplication. It handles negation of input operands, multiplies the absolute values, and then adjusts the sign of the result based on the signs of the input operands. The input a is 32 bits, b is 32 bits, and the output c is 64 bits. The module utilizes temporary variables for computation and updates the output c when there is a change in the c_tmp variable.\n\n Module header:\n\nmodule mult_signed_32(a, b, c);\n [/INST]\n", "output": "input [31:0]a; \n  input [31:0]b; \n  output [63:0]c; \n  reg [63:0]c; \n  reg is_neg_a; \n  reg is_neg_b; \n  reg [31:0]a_tmp; \n  reg [31:0]b_tmp; \n  reg [63:0]c_tmp; \n always@(a or b or is_neg_a or is_neg_b or a_tmp or b_tmp or c) \n begin \n  if(a[31] == 1) begin \n  a_tmp = -a; \n  is_neg_a = 1; \n  end else \n  begin \n  a_tmp = a; \n  is_neg_a = 0; \n  end \n  if(b[31] == 1) begin \n  b_tmp = -b; \n  is_neg_b = 1; \n  end else \n  begin \n  b_tmp = b; \n  is_neg_b = 0; \n  end \n  if( is_neg_a != is_neg_b) begin \n  c_tmp = -(a_tmp * b_tmp); \n  end else \n  begin \n  c_tmp = (a_tmp * b_tmp); \n  end \n end \n always@(c_tmp) \n begin \n  c = c_tmp; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a RAM (Random Access Memory) with parameters for address width (AW) and data width (DW). It contains an array of RAM cells, and it can either write data to a specific RAM cell or read data from it. The module also has an initial block for loading ROM data into the RAM cells. The data output is assigned the value of the RAM cell at the input address when the chip select (cs) and read/write (rw) conditions are met, and the data input is assigned to the RAM cell at the address when the read/write condition is not met. This RAM module can be instantiated with specific address and data widths and can be initialized with ROM data from a file if the ROMFILE parameter is provided.\n\n Module header:\n\nmodule genram #(parameter AW = 9,parameter DW = 12) (input clk,input cs,input wire [AW-1: 0] addr,input wire rw,input wire [DW-1: 0] data_in,output reg [DW-1: 0] data_out);\n [/INST]\n", "output": "parameter ROMFILE = \"\"; \n localparam NPOS = 2 ** AW; \n  reg [DW-1: 0] ram [0: NPOS-1]; \n  always @(posedge clk) begin \n  if (cs & rw == 1) \n  data_out <= ram[addr]; \n  end \n  always @(posedge clk) begin \n  if (cs & rw == 0) \n  ram[addr] <= data_in; \n  end \n initial begin \n  if (ROMFILE) $readmemh(ROMFILE, ram); \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module represents a pipeline stage for an instruction fetch unit in a processor. It takes in various inputs such as the clock signal, reset signal, instruction address, and control signals. The module outputs the updated instruction and control information for the next stage in the pipeline. It includes logic to handle reset and flush conditions, updating the output values accordingly. The module functions as an interface between the instruction fetch and the instruction decode stages in the processor pipeline.\n\n Module header:\n\nmodule core_if_id(clk,rst,if_id_we,if_flush,pc_plus_4,inst_word,pc,pred_target,delayed_PHT,delayed_BHR,btb_type,btb_v,pc_plus_4_out,inst_word_out,pc_out,pred_target_out,delayed_PHT_out,delayed_BHR_out,btb_type_out,btb_v_out);\n [/INST]\n", "output": "input clk; \n input rst; \n input [31:0] pc_plus_4; \n input [31:0] inst_word; \n input [31:0] pc; \n input [31:0] pred_target; \n input [1:0] delayed_PHT; \n input [2:0] delayed_BHR; \n input [1:0] btb_type; \n input btb_v; \n input if_id_we; \n input if_flush; \n output [31:0] pc_plus_4_out; \n output [31:0] inst_word_out; \n output [31:0] pc_out; \n output [31:0] pred_target_out; \n output [1:0] delayed_PHT_out; \n output [2:0] delayed_BHR_out; \n output [1:0] btb_type_out; \n output btb_v_out; \n reg [31:0] inst_word_out; \n reg [31:0] pc_plus_4_out; \n reg [31:0] pc_out; \n reg [31:0] pred_target_out; \n reg [1:0] delayed_PHT_out; \n reg [2:0] delayed_BHR_out; \n reg [1:0] btb_type_out; \n reg btb_v_out; \n always@(posedge clk) \n begin \n  if(rst||if_flush) \n  begin \n  pc_plus_4_out<=32'h0000; \n  inst_word_out<=32'h0000; \n  pc_out<=32'h0000; \n  pred_target_out<=32'h0000; \n  delayed_PHT_out<=2'b00; \n  delayed_BHR_out<=3'b000; \n  btb_type_out<=2'b00; \n  btb_v_out<=1'b0; \n  end \n  else if(if_id_we) \n  begin \n  pc_plus_4_out<=pc_plus_4; \n  inst_word_out<=inst_word; \n  pc_out<=pc; \n  pred_target_out<=pred_target; \n  delayed_PHT_out<=delayed_PHT; \n  delayed_BHR_out<=delayed_BHR; \n  btb_type_out<=btb_type; \n  btb_v_out<=btb_v; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module represents a microcontroller with various input and output signals. It includes a CPU block, an APU block, a JP block, and a sprdma block. The CPU block interfaces with the input signals and generates output signals based on control logic. The APU block handles audio output, the JP block interfaces with a peripheral, and the sprdma block manages data transfers. The module also has control logic to manage the data flow between the blocks, and outputs the appropriate signals based on the active state of the sprdma block.\n\n Module header:\n\nmodule rp2a03 (input wire clk_in,input wire rst_in,input wire rdy_in,input wire [ 7:0] d_in,input wire nnmi_in,input wire nres_in,output wire [ 7:0] d_out,output wire [15:0] a_out,output wire r_nw_out,output wire brk_out,input wire jp_data1_in,input wire jp_data2_in,output wire jp_clk,output wire jp_latch,input wire [ 3:0] mute_in,output wire audio_out,output wire [ 5:0] dac_audio_out,input wire [ 3:0] dbgreg_sel_in,input wire [ 7:0] dbgreg_d_in,input wire dbgreg_wr_in,output wire [ 7:0] dbgreg_d_out);\n [/INST]\n", "output": "wire cpu_ready; \n wire [ 7:0] cpu_din; \n wire cpu_nirq; \n wire [ 7:0] cpu_dout; \n wire [15:0] cpu_a; \n wire cpu_r_nw; \n cpu cpu_blk(.clk_in(clk_in),.rst_in(rst_in),.ready_in(cpu_ready),.dbgreg_sel_in(dbgreg_sel_in),.dbgreg_in(dbgreg_d_in),.dbgreg_wr_in(dbgreg_wr_in),.d_in(cpu_din),.nnmi_in(nnmi_in),.nres_in(nres_in),.nirq_in(cpu_nirq),.d_out(cpu_dout),.a_out(cpu_a),.r_nw_out(cpu_r_nw),.brk_out(brk_out),.dbgreg_out(dbgreg_d_out)); \n wire [7:0] audio_dout; \n apu apu_blk(.clk_in(clk_in),.rst_in(rst_in),.mute_in(mute_in),.a_in(cpu_a),.d_in(cpu_dout),.r_nw_in(cpu_r_nw),.audio_out(audio_out),.dac_audio_out(dac_audio_out),.d_out(audio_dout)); \n wire [7:0] jp_dout; \n jp jp_blk(.clk(clk_in),.rst(rst_in),.wr(~cpu_r_nw),.addr(cpu_a),.din(cpu_dout[0]),.jp_data1(jp_data1_in),.jp_data2(jp_data2_in),.jp_clk(jp_clk),.jp_latch(jp_latch),.dout(jp_dout)); \n wire sprdma_active; \n wire [15:0] sprdma_a; \n wire [ 7:0] sprdma_dout; \n wire sprdma_r_nw; \n sprdma sprdma_blk(.clk_in(clk_in),.rst_in(rst_in),.cpumc_a_in(cpu_a),.cpumc_din_in(cpu_dout),.cpumc_dout_in(cpu_din),.cpu_r_nw_in(cpu_r_nw),.active_out(sprdma_active),.cpumc_a_out(sprdma_a),.cpumc_d_out(sprdma_dout),.cpumc_r_nw_out(sprdma_r_nw)); \n assign cpu_ready = rdy_in & !sprdma_active; \n assign cpu_din = d_in | jp_dout | audio_dout; \n assign cpu_nirq = 1'b1; \n assign d_out = (sprdma_active) ? sprdma_dout : cpu_dout; \n assign a_out = (sprdma_active) ? sprdma_a : cpu_a; \n assign r_nw_out = (sprdma_active) ? sprdma_r_nw : cpu_r_nw; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a 4-digit counter with increment and reset functionalities. It maintains the current score and the high score, updating them based on the input signals 'plus' for increment and 'clr' for reset. The score and high score are divided into 4-digit outputs. The module uses flip-flops to store and update the scores, and it performs arithmetic operations to extract the individual digits of the scores for display.\n\n Module header:\n\nmodule Counter(input wire clk, clr,input wire plus,output wire [3:0] score0, score1, score2, score3, high_score0, high_score1, high_score2, high_score3);\n [/INST]\n", "output": "reg [9:0] score, high_score; \n  reg [1:0] filter_plus, filter_rst; \n  initial \n  begin \n  score <= 10'b0; \n  high_score <= 10'b0; \n  filter_plus <= 2'b0; \n  filter_rst <= 2'b0; \n  end \n  always @ (posedge clk) \n  begin \n  filter_plus <= {filter_plus[0], plus}; \n  filter_rst <= {filter_rst[0], clr}; \n  if (filter_rst == 2'b01) \n  begin \n  score <= 10'b0; \n  end \n  else \n  begin \n  if (filter_plus == 2'b01) \n  score <= score + 10; \n  if (high_score < score) \n  high_score <= score; \n  end \n  end \n  assign score0 = score % 10; \n  assign score1 = (score / 10) % 10; \n  assign score2 = (score / 100) % 10; \n  assign score3 = score / 1000; \n  assign high_score0 = high_score % 10; \n  assign high_score1 = (high_score / 10) % 10; \n  assign high_score2 = (high_score / 100) % 10; \n  assign high_score3 = high_score / 1000; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a 2-to-1 multiplexer with 32-bit inputs and outputs. It selects either input A or input B based on the state of the enable signal. If the enable signal is asserted, the output O is set to input B; otherwise, it is set to input A.\n\n Module header:\n\nmodule mux_2_to_1_32(input [31:0] A,B,input enable,output reg[31:0] O);\n [/INST]\n", "output": "always @* begin \n  if (enable) O <= B; \n  else O <= A; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module acts as a combinational block that takes an 8-bit input A and a 6-bit mode, and generates an 8-bit output Y based on the selected mode. The mode determines whether Y is the result of division, modulo, or multiplication by specific values or by 0. If the mode does not match any of the specified cases, the output Y is the product of the input A and 16.\n\n Module header:\n\nmodule constmuldivmod(input [7:0] A, input [5:0] mode, output reg [7:0] Y);\n [/INST]\n", "output": "always @* begin \n  case (mode) \n  0: Y = A / 8'd0; \n  1: Y = A % 8'd0; \n  2: Y = A * 8'd0; \n  3: Y = A / 8'd1; \n  4: Y = A % 8'd1; \n  5: Y = A * 8'd1; \n  6: Y = A / 8'd2; \n  7: Y = A % 8'd2; \n  8: Y = A * 8'd2; \n  9: Y = A / 8'd4; \n  10: Y = A % 8'd4; \n  11: Y = A * 8'd4; \n  12: Y = A / 8'd8; \n  13: Y = A % 8'd8; \n  14: Y = A * 8'd8; \n  15: Y = $signed(A) / $signed(8'd0); \n  16: Y = $signed(A) % $signed(8'd0); \n  17: Y = $signed(A) * $signed(8'd0); \n  18: Y = $signed(A) / $signed(8'd1); \n  19: Y = $signed(A) % $signed(8'd1); \n  20: Y = $signed(A) * $signed(8'd1); \n  21: Y = $signed(A) / $signed(8'd2); \n  22: Y = $signed(A) % $signed(8'd2); \n  23: Y = $signed(A) * $signed(8'd2); \n  24: Y = $signed(A) / $signed(8'd4); \n  25: Y = $signed(A) % $signed(8'd4); \n  26: Y = $signed(A) * $signed(8'd4); \n  27: Y = $signed(A) / $signed(8'd8); \n  28: Y = $signed(A) % $signed(8'd8); \n  29: Y = $signed(A) * $signed(8'd8); \n  30: Y = $signed(A) / $signed(-8'd0); \n  31: Y = $signed(A) % $signed(-8'd0); \n  32: Y = $signed(A) * $signed(-8'd0); \n  33: Y = $signed(A) / $signed(-8'd1); \n  34: Y = $signed(A) % $signed(-8'd1); \n  35: Y = $signed(A) * $signed(-8'd1); \n  36: Y = $signed(A) / $signed(-8'd2); \n  37: Y = $signed(A) % $signed(-8'd2); \n  38: Y = $signed(A) * $signed(-8'd2); \n  39: Y = $signed(A) / $signed(-8'd4); \n  40: Y = $signed(A) % $signed(-8'd4); \n  41: Y = $signed(A) * $signed(-8'd4); \n  42: Y = $signed(A) / $signed(-8'd8); \n  43: Y = $signed(A) % $signed(-8'd8); \n  44: Y = $signed(A) * $signed(-8'd8); \n  default: Y = 8'd16 * A; \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements the logic for a mapper used in memory management for a NES emulator. It sets the PRG and CHR banks based on specific conditions, performs various checks and assignments, and calculates the PRG and CHR addresses for memory access. The module also handles flag checks and determines whether certain memory regions are accessible.\n\n Module header:\n\nmodule Mapper34(input clk, input ce, input reset,input [31:0] flags,input [15:0] prg_ain, output [21:0] prg_aout,input prg_read, prg_write,input [7:0] prg_din,output prg_allow,input [13:0] chr_ain, output [21:0] chr_aout,output chr_allow,output vram_a10,output vram_ce);\n [/INST]\n", "output": "reg [1:0] prg_bank; \n  reg [3:0] chr_bank_0, chr_bank_1; \n  wire NINA = (flags[13:11] != 0); \n  always @(posedge clk) if (reset) begin \n  prg_bank <= 0; \n  chr_bank_0 <= 0; \n  chr_bank_1 <= 1; \n  end else if (ce && prg_write) begin \n  if (!NINA) begin \n  if (prg_ain[15]) \n  prg_bank <= prg_din[1:0]; \n  end else begin \n  if (prg_ain == 16'h7ffd) \n  prg_bank <= prg_din[1:0]; \n  else if (prg_ain == 16'h7ffe) \n  chr_bank_0 <= prg_din[3:0]; \n  else if (prg_ain == 16'h7fff) \n  chr_bank_1 <= prg_din[3:0]; \n  end \n  end \n  wire [21:0] prg_aout_tmp = {5'b00_000, prg_bank, prg_ain[14:0]}; \n  assign chr_allow = flags[15]; \n  assign chr_aout = {6'b10_0000, chr_ain[12] == 0 ? chr_bank_0 : chr_bank_1, chr_ain[11:0]}; \n  assign vram_ce = chr_ain[13]; \n  assign vram_a10 = flags[14] ? chr_ain[10] : chr_ain[11]; \n  wire prg_is_ram = (prg_ain >= 'h6000 && prg_ain < 'h8000) && NINA; \n  assign prg_allow = prg_ain[15] && !prg_write || \n  prg_is_ram; \n  wire [21:0] prg_ram = {9'b11_1100_000, prg_ain[12:0]}; \n  assign prg_aout = prg_is_ram ? prg_ram : prg_aout_tmp; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a parallel CRC (Cyclic Redundancy Check) generator for the CCITT polynomial. The module takes a clock input, a reset signal, an enable signal, an initialization signal, an 8-bit data input, and generates a 16-bit CRC output. It uses a 16-bit register, \"crc_reg,\" to store the CRC value.\n\nThe module updates the CRC register on the rising edge of the clock based on the input signals. If the reset signal is active, the CRC register is initialized to 0xFFFF. When enabled, the module updates the CRC value according to the CCITT polynomial using XOR operations with specific bits of the data input and the current CRC register value.\n\nThe next_crc wire holds the updated CRC value, which is then assigned to the output crc_out. This module essentially performs parallel CRC generation on 8-bit input data to produce a 16-bit CRC output.\n\n Module header:\n\nmodule parallel_crc_ccitt (clk ,reset ,enable ,init ,data_in ,crc_out);\n [/INST]\n", "output": "input clk ; \n input reset ; \n input enable ; \n input init ; \n input [7:0] data_in ; \n output [15:0] crc_out; \n reg [15:0] crc_reg; \n wire [15:0] next_crc; \n assign crc_out = crc_reg; \n always @ (posedge clk) \n if (reset) begin \n  crc_reg <= 16'hFFFF; \n end else if (enable) begin \n  if (init) begin \n  crc_reg <= 16'hFFFF; \n  end else begin \n  crc_reg <= next_crc; \n  end \n end \n assign next_crc[0] = data_in[7] ^ data_in[0] ^ crc_reg[4] ^ crc_reg[11]; \n assign next_crc[1] = data_in[1] ^ crc_reg[5]; \n assign next_crc[2] = data_in[2] ^ crc_reg[6]; \n assign next_crc[3] = data_in[3] ^ crc_reg[7]; \n assign next_crc[4] = data_in[4] ^ crc_reg[8]; \n assign next_crc[5] = data_in[7] ^ data_in[5] ^ data_in[0] ^ crc_reg[4] ^ crc_reg[9] ^ crc_reg[11]; \n assign next_crc[6] = data_in[6] ^ data_in[1] ^ crc_reg[5] ^ crc_reg[10]; \n assign next_crc[7] = data_in[7] ^ data_in[2] ^ crc_reg[6] ^ crc_reg[11]; \n assign next_crc[8] = data_in[3] ^ crc_reg[0] ^ crc_reg[7]; \n assign next_crc[9] = data_in[4] ^ crc_reg[1] ^ crc_reg[8]; \n assign next_crc[10] = data_in[5] ^ crc_reg[2] ^ crc_reg[9]; \n assign next_crc[11] = data_in[6] ^ crc_reg[3] ^ crc_reg[10]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a 128-bit Linear Feedback Shift Register (LFSR) with four 32-bit LFSR stages. It uses the clock signal and a reset input to generate pseudo-random sequences. The module also outputs the shift register values and an RS232 transmit data signal. The LFSR stages are reset on initialization and shifted right by 1 on each clock cycle. The module also checks for specific patterns in the LFSR stages and provides a sample signal. Finally, it creates a LogicProbe instance to monitor the internal signals.\n\n Module header:\n\nmodule lfsr128(clk, reset_in_n, s, rs232_txd);\n [/INST]\n", "output": "input clk; \n  input reset_in_n; \n  output [3:0] s; \n  output rs232_txd; \n  wire reset; \n  reg [3:0] reset_counter; \n  reg [31:0] lfsr0; \n  reg [31:0] lfsr1; \n  reg [31:0] lfsr2; \n  reg [31:0] lfsr3; \n  wire trigger; \n  wire sample; \n  wire [127:0] log_data; \n  assign reset = (reset_counter == 4'hF) ? 0 : 1; \n  always @(posedge clk) begin \n  if (reset_in_n == 0) begin \n  reset_counter <= 4'h0; \n  end else begin \n  if (reset_counter != 4'hF) begin \n  reset_counter <= reset_counter + 1; \n  end \n  end \n  end \n  always @(posedge clk) begin \n  if (reset == 1) begin \n  lfsr0 <= 32'hC70337DB; \n  lfsr1 <= 32'h7F4D514F; \n  lfsr2 <= 32'h75377599; \n  lfsr3 <= 32'h7D5937A3; \n  end else begin \n  if (lfsr0[0] == 0) begin \n  lfsr0 <= lfsr0 >> 1; \n  end else begin \n  lfsr0 <= (lfsr0 >> 1) ^ 32'hD0000001; \n  end \n  if (lfsr1[0] == 0) begin \n  lfsr1 <= lfsr1 >> 1; \n  end else begin \n  lfsr1 <= (lfsr1 >> 1) ^ 32'hD0000001; \n  end \n  if (lfsr2[0] == 0) begin \n  lfsr2 <= lfsr2 >> 1; \n  end else begin \n  lfsr2 <= (lfsr2 >> 1) ^ 32'hD0000001; \n  end \n  if (lfsr3[0] == 0) begin \n  lfsr3 <= lfsr3 >> 1; \n  end else begin \n  lfsr3 <= (lfsr3 >> 1) ^ 32'hD0000001; \n  end \n  end \n  end \n  assign s[3] = lfsr0[27]; \n  assign s[2] = lfsr1[13]; \n  assign s[1] = lfsr2[23]; \n  assign s[0] = lfsr3[11]; \n  assign trigger = (lfsr0 == 32'h7119C0CD) ? 1 : 0; \n  assign sample = 1; \n  assign log_data = { lfsr0, lfsr1, lfsr2, lfsr3 }; \n  LogicProbe lp(clk, reset, trigger, sample, log_data, rs232_txd); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module is a decoder that corrects errors in the received data using error detection and correction (EDAC) techniques. It includes logic to handle single and double bit errors, as well as no error scenarios. The decoder sets error flags and flips bits in the data if errors are detected. The corrected data and error signals are output to the user. The module also includes a reset process and a syndrome generation loop based on the input data.\n\n Module header:\n\nmodule Decoder#(parameter DATA_BITS = 8, PARITY_BITS = 4)(DataParity_in_12p, DataParity_valid_12p,reset_b,clk,Data_out_14p, EDACerr1_14p,EDACerr2_14p);\n [/INST]\n", "output": "localparam k = DATA_BITS; \n  localparam r = PARITY_BITS; \n  input wire clk, reset_b, DataParity_valid_12p; \n  input wire [k+r:1] DataParity_in_12p; \n  output reg EDACerr1_14p; \n  output reg EDACerr2_14p; \n  output reg [k:1] Data_out_14p; \n  reg [r-1:1] syndrome; \n  reg [k+r:1] data_in,temp_data; \n  reg [k:1] data_out; \n  reg dataparity_valid_int; \n  reg err1, err2; \n  always@(posedge clk or negedge reset_b) begin \n  if(~reset_b) begin \n  data_in <= 'd0; \n  dataparity_valid_int <= 'd0; \n  err1 <= 'd0; err2 <= 'd0; \n  Data_out_14p <= 'd0; \n  EDACerr1_14p <= 1'b0; \n  EDACerr2_14p <= 1'b0; \n  end \n  else if(DataParity_valid_12p) begin \n  data_in <= DataParity_in_12p; \n  dataparity_valid_int <= DataParity_valid_12p; \n  if(dataparity_valid_int) begin \n  Data_out_14p <= data_out; \n  EDACerr1_14p <= err1; \n  EDACerr2_14p <= err2; \n  end \n  end \n  end \n  integer i,j,a,l; \n  integer cnt; \n  reg P; \n  always @(data_in) begin \n  if(reset_b) begin \n  P = ^(data_in); \n  temp_data = data_in; \n  for(i=1;i<r;i=i+1) begin \n  cnt = 1; \n  a = cnt[i-1] & data_in[1]; \n  for(cnt=2;cnt<(k+r);cnt=cnt+1) begin \n  a = a ^ (data_in[cnt] & cnt[i-1]); \n  end \n  syndrome[i] = a; \n  end \n  if(|(syndrome) && P) begin \n  $display(\"Inside decoder: One bit error was present at %0d bit, and is corrected\",syndrome); \n  temp_data[syndrome] = ~temp_data[syndrome]; \n  err1 = 1'b1; err2 = 1'b0; \n  end \n  else if(|(syndrome) && ~P) begin \n  $display(\"Inside decoder: Double bit error was present\"); \n  err2 = 1'b1; err1 = 1'b0; \n  end \n  else if (~(|syndrome) && ~P)begin \n  $display(\"Inside decoder: No error was found in the data received\"); \n  err1 = 1'b0; err2 = 1'b0; \n  end \n  j = 1; l = 1; \n  while ( (l<k+r) || (j<=k)) begin \n  if ( l == ((~l+1)&l)) begin \n  l = l+1; \n  end \n  else begin \n  data_out[j] = temp_data[l]; \n  j = j+1; l = l+1; \n  end \n  end \n  if(|(err1)) \n  $display(\"Inside decoder: Data after correction: %h\",data_out); \n  else \n  $display(\"Decoder output: Data: %h\",data_out); \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a microcontroller design with various components. It includes a program counter, memory program counter, data memory, data registers, ALU, multiplexers, and registers for control signals. The module also incorporates memory blocks for data and addresses, as well as a register file for data storage. Additionally, it features an ALU for arithmetic and logical operations, and multiplexers for selecting input signals. The module's functionality includes the execution of arithmetic and logical operations, fetching data from memory, and controlling the program flow based on various control signals.\n\n Module header:\n\nmodule microc(input wire clk, reset, s_inc, s_inm, we3, s_es, s_rel, swe, s_ret, input wire [2:0] op, input wire [7:0] data_in,output wire z, output wire [5:0] opcode, output wire [7:0] data_mem, data_reg, output wire [1:0] id_in, id_out);\n [/INST]\n", "output": "wire [9:0] mux1_pc; \n  wire [9:0] pc_memprog; \n  wire [9:0] sum_mux1; \n  wire [15:0] memprog; \n  wire [7:0] rd1,rd2,wd3; \n  wire [7:0] alu_mux2; \n  wire zero; \n  wire [7:0] mux2_out; \n  wire [9:0] mux4_sum, sub_mux5, mux5_pc, mux_subreg; \n  wire [3:0] num; \n  wire [15:0] num_vga; \n  assign opcode = memprog[5:0]; \n  assign data_mem = memprog[11:4]; \n  assign data_reg = rd1; \n  assign id_out = memprog[15:14]; \n  assign id_in = memprog[5:4]; \n  mux1 #(10) mux1_(memprog[15:6], sum_mux1, s_inc, mux1_pc); \n  registro #(10) PC_(clk, reset, mux5_pc, pc_memprog); \n  sum sumador_(mux4_sum, pc_memprog, sum_mux1); \n  memprog memoria_(clk, pc_memprog, memprog); \n  regfile banco_(clk, we3, memprog[7:4], memprog[11:8], memprog[15:12], wd3, rd1, rd2); \n  alu alu_(rd1, rd2, op, alu_mux2, zero); \n  mux2 #(8) mux2_(alu_mux2, memprog[11:4], s_inm, mux2_out); \n  registro #(1) ffzero(clk, reset, zero, z); \n  mux2 #(8) mux3_(mux2_out,data_in,s_es,wd3); \n  mux1 #(10) mux4_(1, memprog[15:6], s_rel, mux4_sum); \n  retorno_reg #(10) sub_reg(swe, reset, mux_subreg, sub_mux5); \n  mux1 #(10) mux5_(mux1_pc, sub_mux5, s_ret, mux5_pc); \n  sum sumador2(1, pc_memprog, mux_subreg); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe `debugprinter` module captures the positive edge of the clock signal. Within this block, it checks if the `addr_b` input is equal to 65536. If this condition is met, it outputs the least significant 8 bits of the `data_b_in` input.\n\n Module header:\n\nmodule debugprinter (input clk,input [31:0] addr_b,input [31:0] data_b_in,input [31:0] data_b_we);\n [/INST]\n", "output": "always @(posedge clk) \n  begin \n  if (addr_b == 65536) \n  $write(\"%c\", data_b_in[7:0]); \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module contains two always blocks. The first block triggers on the positive edge of the clk signal and assigns the value of d to the least significant bit of the q output. The second block triggers on the negative edge of the clk signal and assigns the previous value of q[0] to the most significant bit of the q output.\n\n Module header:\n\nmodule abc9_test035(input clk, d, output reg [1:0] q);\n [/INST]\n", "output": "always @(posedge clk) q[0] <= d; \n always @(negedge clk) q[1] <= q[0]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an implementation of a 16-bit shift register with FIFO (first in, first out) functionality. It has an 8-bit data width and supports operations like shifting data in and out, and checking for full and empty conditions. The module also includes coverage and assertion clauses for full and almost full conditions, as well as an assertion for empty and almost empty conditions. The module works synchronously with the clock signal and includes a reset signal to initialize internal states.\n\n Module header:\n\nmodule openhmc_srl_fifo_16 #(`ifdef CAG_ASSERTIONSparameter DISABLE_EMPTY_ASSERT = 0,parameter DISABLE_FULL_ASSERT = 0,`endifparameter DWIDTH = 8) (input wire clk,input wire res_n,input wire [DWIDTH-1:0] d_in,input wire shift_in,input wire shift_out,output wire [DWIDTH-1:0]d_out,output reg full,output reg empty,output reg almost_full,output reg almost_empty);\n [/INST]\n", "output": "reg [3:0] count; \n  wire shift_out_notempty; \n  wire shift_in_notfull; \n  genvar i; \n  assign shift_out_notempty = (shift_out && !empty); \n  assign shift_in_notfull = (shift_in && !full); \n  generate \n  for (i=0; i < DWIDTH; i=i+1) \n  begin: generate_SRL16 \n SRL16E #(.INIT(16'h0000)) SRL16_I (.Q(d_out[i]),.A0(count[0]),.A1(count[1]),.A2(count[2]),.A3(count[3]),.CLK(clk),.D(d_in[i]),.CE(shift_in_notfull)); \n  end \n  endgenerate \n  `ifdef ASYNC_RES \n  always @(posedge clk or negedge res_n) `else \n  always @(posedge clk) `endif \n  begin \n  if (!res_n) \n  begin \n  count <= 4'b0; \n  full <= 1'b0; \n  almost_full <= 1'b0; \n  empty <= 1'b1; \n  almost_empty <= 1'b1; \n  end \n  else \n  begin \n  case ({shift_in_notfull, shift_out_notempty}) \n  2'b00: ; \n  2'b01: \n  begin \n  if (|count) \n  count <= count - 1'b1; \n  empty <= !(|count); \n  almost_empty <= (count <= 1); \n  full <= 1'b0; \n  almost_full <= (count > (4'd15 - 1)); \n  end \n  2'b10: \n  begin \n  if (!empty) \n  count <= count + 1'b1; \n  empty <= 1'b0; \n  almost_empty <= empty; \n  full <= (count > 4'd13); \n  almost_full <= (count > (4'd13 - 1)); \n  end \n  2'b11: ; \n  endcase \n  end \n  end \n `ifdef CAG_COVERAGE \n  full_cov: cover property (@(posedge clk) disable iff(!res_n) (full == 1'b1)); \n  almost_full_cov: cover property (@(posedge clk) disable iff(!res_n) (almost_full == 1'b1)); \n  empty_cov: cover property (@(posedge clk) disable iff(!res_n) (empty == 1'b1)); \n  almost_empty_cov: cover property (@(posedge clk) disable iff(!res_n) (almost_empty == 1'b1)); \n `endif \n `ifdef CAG_ASSERTIONS \n  final \n  begin \n  if (DISABLE_FULL_ASSERT == 0) \n  begin \n  full_set_assert: assert (!full); \n  almost_full_set_assert: assert (!almost_full); \n  end \n  if (DISABLE_EMPTY_ASSERT == 0) \n  begin \n  almost_empty_not_set_assert: assert (almost_empty); \n  empty_not_set_assert: assert (empty); \n  end \n  end \n `endif \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a simple dual-port RAM with 9-bit address width, 8-bit data width, and 512 memory locations. It has two sets of inputs and outputs for reading and writing data. The module has logic to write and read data from the RAM based on clock enables and write enables. The RAM is implemented as a block RAM, and the module has separate always blocks for each port to handle the read and write operations.\n\n Module header:\n\nmodule doImgProc_lineBuff_val_0_ram (addr0, ce0, d0, we0, q0, addr1, ce1, q1, clk);\n [/INST]\n", "output": "parameter DWIDTH = 8; \n parameter AWIDTH = 9; \n parameter MEM_SIZE = 512; \n input[AWIDTH-1:0] addr0; \n input ce0; \n input[DWIDTH-1:0] d0; \n input we0; \n output reg[DWIDTH-1:0] q0; \n input[AWIDTH-1:0] addr1; \n input ce1; \n output reg[DWIDTH-1:0] q1; \n input clk; \n (* ram_style = \"block\" *)reg [DWIDTH-1:0] ram[MEM_SIZE-1:0]; \n always @(posedge clk) \n begin \n  if (ce0) \n  begin \n  if (we0) \n  begin \n  ram[addr0] <= d0; \n  q0 <= d0; \n  end \n  else \n  q0 <= ram[addr0]; \n  end \n end \n always @(posedge clk) \n begin \n  if (ce1) \n  begin \n  q1 <= ram[addr1]; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a memory controller with a synchronous write interface. It has a 3-bit address input and 16-bit data input and output. It contains five 16-bit output registers a11, a12, b10, b11, and b12 which are selected based on the address input. It also has a write enable input, a clock input, and a reset input. When a write is enabled and the strobe input is active, the corresponding data input is written to the selected register. On reset, the output registers are initialized to specific values. The output data is selected based on the address input.\n\n Module header:\n\nmodule coefio (clk_i,rst_i,we_i,stb_i,ack_o,dat_i,dat_o,adr_i,a11,a12,b10,b11,b12);\n [/INST]\n", "output": "input clk_i; \n input rst_i; \n input we_i; \n input stb_i; \n output ack_o; \n input [15:0] dat_i; \n output [15:0] dat_o; \n input [2:0] adr_i; \n output [15:0] a11; \n output [15:0] a12; \n output [15:0] b10; \n output [15:0] b11; \n output [15:0] b12; \n reg [15:0] a11; \n reg [15:0] a12; \n reg [15:0] b10; \n reg [15:0] b11; \n reg [15:0] b12; \n wire ack_o; \n wire sel_a11; \n wire sel_a12; \n wire sel_b10; \n wire sel_b11; \n wire sel_b12; \n assign sel_a11 = (adr_i == 3'b000); \n assign sel_a12 = (adr_i == 3'b001); \n assign sel_b10 = (adr_i == 3'b010); \n assign sel_b11 = (adr_i == 3'b011); \n assign sel_b12 = (adr_i == 3'b100); \n assign ack_o = stb_i; \n always @(posedge clk_i or posedge rst_i) \n if ( rst_i ) \n  begin \n  a11 <= 15'b11111111; \n  a12 <= 15'b11111; \n  b10 <= 15'b1111111; \n  b11 <= 15'b11; \n  b12 <= 15'b11111111; \n  end \n else \n  begin \n  a11 <= (stb_i & we_i & sel_a11) ? (dat_i) : (a11); \n  a12 <= (stb_i & we_i & sel_a12) ? (dat_i) : (a12); \n  b10 <= (stb_i & we_i & sel_b10) ? (dat_i) : (b10); \n  b11 <= (stb_i & we_i & sel_b11) ? (dat_i) : (b11); \n  b12 <= (stb_i & we_i & sel_b12) ? (dat_i) : (b12); \n  end \n assign dat_o = sel_a11 ? (a11) : \n ((sel_a12) ? (a12) :((sel_b10) ? (b10) :((sel_b11) ? (b11) :((sel_b12) ? (b12) :(16'h0000))))); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `mbus_addr_rf` consists of a dynamic address register with an input `ADDR_IN` and an output `ADDR_OUT`. It includes logic to update the address based on the `ADDR_WR_EN` and `ADDR_CLRn` signals. During the reset condition, the output address is initialized to all ones and the valid signal is set to 0. When not in reset, the output address is updated with the input address and the valid signal is asserted. Additionally, there are conditional compilation blocks for power gating.\n\n Module header:\n\nmodule mbus_addr_rf(input RESETn,`ifdef POWER_GATINGinput RELEASE_ISO_FROM_SLEEP_CTRL,`endifoutput reg [`DYNA_WIDTH-1:0] ADDR_OUT,input [`DYNA_WIDTH-1:0] ADDR_IN,output reg ADDR_VALID,input ADDR_WR_EN,input ADDR_CLRn);\n [/INST]\n", "output": "wire RESETn_local = (RESETn & ADDR_CLRn); \n `ifdef POWER_GATING \n wire ADDR_UPDATE = (ADDR_WR_EN & (~RELEASE_ISO_FROM_SLEEP_CTRL)); \n `else \n wire ADDR_UPDATE = ADDR_WR_EN; \n `endif \n always @ (posedge ADDR_UPDATE or negedge RESETn_local) \n begin \n  if (~RESETn_local) \n  begin \n  ADDR_OUT <= {`DYNA_WIDTH{1'b1}}; \n  ADDR_VALID <= 0; \n  end \n  else \n  begin \n  ADDR_OUT <= ADDR_IN; \n  ADDR_VALID <= 1; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module is a shift register with the ability to load data, shift the data, and output the shifted bit. It operates on a clock signal and a start signal to initialize the shift register. The module also takes in a load signal to load new data, a shift signal to perform a shift operation, and an input data D to load into the shift register. The output Q provides the current state of the shift register, and shift_out provides the output of the rightmost bit of the shift register.\n\n Module header:\n\nmodule shift_out_register #(parameter WIDTH = 3) (input [WIDTH:0] start,input clk,input load,input shift,input [(WIDTH-1):0] D,input shift_in,output [(WIDTH-1):0] Q,output shift_out);\n [/INST]\n", "output": "reg [(WIDTH-1):0] shift_reg; \n  always @(posedge start[0] or posedge clk) begin \n  if (start[0]) begin \n  shift_reg <= start[WIDTH:1]; \n  end \n  else begin \n  if (load) begin \n  shift_reg <= D; \n  end \n  else if (shift) begin \n  if (WIDTH == 1) begin \n  shift_reg <= shift_in; \n  end \n  else begin \n  shift_reg <= {shift_in, shift_reg[(WIDTH-1):1]}; \n  end \n  end \n  end \n  end \n  assign shift_out = shift_reg[0]; \n  assign Q = shift_reg; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a register that processes various inputs and sets the outputs accordingly. When the reset signal is active, it sets the outputs to zero. Otherwise, when the enable signal is active, it sets the outputs to the corresponding input values. The module also has a clock input for synchronous operation. The module consists of several registers and multiplexers for handling data and control signals.\n\n Module header:\n\nmodule mem_wb_reg #(parameter DATA_WIDTH = 32,parameter INSTRUCTION_WIDTH = 32,parameter REG_ADDR_WIDTH = 5) (input clk,input rst_n,input en,input write_back_mux_sel_in,input [DATA_WIDTH-1:0] alu_data_in,input [DATA_WIDTH-1:0] hi_data_in,input [REG_ADDR_WIDTH-1:0] reg_a_wr_addr_in,input [REG_ADDR_WIDTH-1:0] reg_b_wr_addr_in,input reg_a_wr_en_in,input reg_b_wr_en_in,input [INSTRUCTION_WIDTH-1:0] instruction_in,output reg write_back_mux_sel_out,output reg [DATA_WIDTH-1:0] alu_data_out,output reg [DATA_WIDTH-1:0] hi_data_out,output reg [REG_ADDR_WIDTH-1:0] reg_a_wr_addr_out,output reg [REG_ADDR_WIDTH-1:0] reg_b_wr_addr_out,output reg reg_a_wr_en_out,output reg reg_b_wr_en_out,output reg [INSTRUCTION_WIDTH-1:0] instruction_out);\n [/INST]\n", "output": "always@(posedge clk or negedge rst_n) begin \n  if(~rst_n) begin \n  write_back_mux_sel_out <= 0; \n  alu_data_out <= 0; \n  hi_data_out <= 0; \n  reg_a_wr_addr_out <= 0; \n  reg_b_wr_addr_out <= 0; \n  reg_a_wr_en_out <= 0; \n  reg_b_wr_en_out <= 0; \n  instruction_out <= 0; \n  end \n  else if(en) begin \n  write_back_mux_sel_out <= write_back_mux_sel_in; \n  alu_data_out <= alu_data_in; \n  hi_data_out <= hi_data_in; \n  reg_a_wr_addr_out <= reg_a_wr_addr_in; \n  reg_b_wr_addr_out <= reg_b_wr_addr_in; \n  reg_a_wr_en_out <= reg_a_wr_en_in; \n  reg_b_wr_en_out <= reg_b_wr_en_in; \n  instruction_out <= instruction_in; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes two 16-bit input values, adds them together using a series of 4-bit additions, and then concatenates the results to form a 17-bit output. Each 4-bit addition is represented using separate wires, and the final output is obtained by concatenating these intermediate results in a specific order.\n\n Module header:\n\nmodule ACA_I_N16_Q4(input [15:0] in1,input [15:0] in2,output [16:0] res);\n [/INST]\n", "output": "wire [4:0] temp1,temp2,temp3,temp4,temp5,temp6,temp7,temp8,temp9,temp10,temp11,temp12,temp13; \n assign temp1[4:0] = in1[3:0] + in2[3:0]; \n assign temp2[4:0] = in1[4:1] + in2[4:1]; \n assign temp3[4:0] = in1[5:2] + in2[5:2]; \n assign temp4[4:0] = in1[6:3] + in2[6:3]; \n assign temp5[4:0] = in1[7:4] + in2[7:4]; \n assign temp6[4:0] = in1[8:5] + in2[8:5]; \n assign temp7[4:0] = in1[9:6] + in2[9:6]; \n assign temp8[4:0] = in1[10:7] + in2[10:7]; \n assign temp9[4:0] = in1[11:8] + in2[11:8]; \n assign temp10[4:0] = in1[12:9] + in2[12:9]; \n assign temp11[4:0] = in1[13:10] + in2[13:10]; \n assign temp12[4:0] = in1[14:11] + in2[14:11]; \n assign temp13[4:0] = in1[15:12] + in2[15:12]; \n assign res[16:0] = {temp13[4:3],temp12[3],temp11[3],temp10[3],temp9[3],temp8[3],temp7[3],temp6[3],temp5[3],temp4[3],temp3[3],temp2[3],temp1[3:0]}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a stack-based machine with an ALU. The module has inputs for the clock, reset, g_input, and e_input, and an output register o. It also includes internal registers for the ALU and a stack. The module includes logic to perform operations such as addition, subtraction, multiplication, negation, bitwise AND, OR, and XOR on the values in the stack. It also has logic to push values onto the stack and handle stack operations based on the push, op1, and op2 signals. The module also initializes the stack to zero on reset.\n\n Module header:\n\nmodule stackMachine #(parameter N=8,parameter S=8) (clk,rst,g_input,e_input,o);\n [/INST]\n", "output": "input clk; \n  input rst; \n  input signed [N-1:0] g_input; \n  input [2:0] e_input; \n  output reg signed [N-1:0] o; \n  reg signed [N-1:0] alu; \n  reg signed [N-1:0] stack[S-1:0]; \n  reg push; \n  reg op1; \n  reg op2; \n  integer j; \n  always@(*) \n  begin \n  push <= 0; \n  op1 <= 0; \n  op2 <= 0; \n  alu <= stack[0]; \n  case(e_input) \n  3'd0: \n  begin \n  alu <= stack[0]; \n  end \n  3'd1: \n  begin \n  alu <= stack[0] + stack[1]; \n  op2 <= 1'b1; \n  end \n  3'd2: \n  begin \n  alu <= stack[0] - stack[1]; \n  op2 <= 1'b1; \n  end \n  3'd3: \n  begin \n  alu <= stack[0] * stack[1]; \n  op2 <= 1'b1; \n  end \n  3'd4: \n  begin \n  push <= 1; \n  end \n  3'd5: \n  begin \n  alu <= -1 * stack[0]; \n  op1 <= 1'b1; \n  end \n  3'd6: \n  begin \n  alu <= stack[0] & stack[1]; \n  op2 <= 1'b1; \n  end \n  3'd7: \n  begin \n  alu <= stack[0] | stack[1]; \n  op2 <= 1'b1; \n  end \n  3'd8: \n  begin \n  alu <= stack[0] ^ stack[1]; \n  op2 <= 1'b1; \n  end \n  endcase \n  end \n  always @(*) \n  begin \n  if(push) \n  begin \n  o <= g_input; \n  end \n  else \n  begin \n  o <= alu; \n  end \n  end \n  always@(posedge clk or posedge rst) \n  begin \n  if(rst) \n  begin \n  for(j=0;j<S;j=j+1) \n  begin \n  stack[j] <= 0; \n  end \n  end \n  else \n  begin \n  if(push) \n  begin \n  stack[0] <= g_input; \n  for(j=1;j<S;j=j+1) \n  begin \n  stack[j] <= stack[j-1]; \n  end \n  end \n  else if(op1) \n  begin \n  stack[0] <= alu; \n  end \n  else if(op2) \n  begin \n  stack[0] <= alu; \n  for(j=1;j<S-1;j=j+1) \n  begin \n  stack[j] <= stack[j+1]; \n  end \n  end \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a peripheral UART interface with control signals for data transfer. It includes a state machine to handle the control signals and output logic. The state machine sets the value of the state signal 's' based on the address, chip select, and write enable signals. Then, on the negative edge of the clock signal, the module processes the state signal to store the input data based on the state value. Additionally, it utilizes two instances of a 'direction' module to handle the input data based on the state value and generate the output signals adelante and atras.\n\n Module header:\n\nmodule peripheral_uart (input clk,input rst,input [15:0] d_in,input cs,input [3:0] addr,input rd,input wr,output reg [15:0] d_out,output [1:0] adelante ,output [1:0] atras);\n [/INST]\n", "output": "reg [1:0] s; \n  reg [1:0] reversa; \n  always @(*) begin \n  case(addr) \n  4'h0: s = (cs && wr) ? 2'b01 : 2'b00 ; \n  4'h2: s = (cs && wr) ? 2'b10 : 2'b00 ; \n  default: s = 2'b00 ; \n  endcase \n  end \n  always @(negedge clk) begin \n  case (s) \n  2'b01: reversa[0] = d_in[0] ; \n  2'b10: reversa[1] = d_in[0] ; \n  default: begin \n  reversa[0] = 0 ; \n  reversa[1] = 0 ; \n  end \n  endcase \n  end \n  direccion direccion1 ( .reversa(reversa[0]) , .adelante(adelante[0]) , .atras(atras[0]) ) ; \n  direccion direccion2 ( .reversa(reversa[1]) , .adelante(adelante[1]) , .atras(atras[1]) ) ; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module implements a state machine for finding the best iso. The state machine has several states, including reset, idle, and various start states. It uses the clock input for synchronization and controls the process using the start_process signal. The module interfaces with a find_iso module and a codes RAM module. The state transitions and operations within each state are defined based on the conditions and inputs, with the find_iso module being enabled at a specific state and the completion signal being monitored to advance the state machine. Overall, the module orchestrates the process of finding the best iso based on specific conditions and inputs.\n\n Module header:\n\nmodule find_best_iso (input wire clock,input wire [7:0] min_hd,input wire [7:0] min_iso,input wire start_process,output reg complete);\n [/INST]\n", "output": "parameter n = 5; \n parameter MAX_N = 8; \n parameter MAX_CAND = 2**MAX_N; \n reg [5:0] state; \n parameter [5:0] ST_RST = 6'h00, \n  ST_IDLE = 6'h01; \n reg [7:0] count, icand; \n reg [7:0] a_len, min_b_len; \n reg start_process_1, start_process_2; \n wire wren_codes; \n wire [7:0] read_codes; \n wire [10:0] addr_codes; \n wire [7:0] data_codes; \n icblbc_ram codes (.address ( addr_codes ),.clock ( clock ),.data ( data_codes ),.wren ( wren_codes ),.q ( read_codes )); \n reg fi_en; \n find_iso fi (.clock ( clock ),.start ( fi_en ),.complete ( fi_done )); \n always @(posedge clock) begin \n  {start_process_2, start_process_1} <= {start_process_1, start_process}; \n  case(state) \n  ST_RST: begin \n  state <= ST_IDLE; \n  end \n  ST_IDLE: begin \n  if( start_process_2 ) begin \n  state <= 3; \n  a_len <= 1<<(n-1); \n  min_b_len <= 2; \n  end \n  end \n  3: begin \n  state <= 4; \n  end \n  4: begin \n  state <= 5; \n  end \n  5: begin \n  state <= 10; \n  end \n  10: begin \n  fi_en <= 1; \n  state <= 11; \n  end \n  11: begin \n  if( fi_done ) begin \n  state <= 12; \n  end \n  end \n  12: begin \n  state <= 13; \n  end \n  20: begin \n  state <= ST_IDLE; \n  end \n  endcase \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is designed for load hazard detection and handling in a CPU control unit. It evaluates conditions to detect if a load hazard is present, and based on the conditions, it controls the instruction read enable, stall, and flush signals. The module also includes logic for selecting a new program counter (PC). If a load hazard is detected, it disables instruction reading, sets a stall, and performs flushing in certain pipeline stages. Otherwise, it enables instruction reading and clears the stall and flush signals.\n\n Module header:\n\nmodule control #(parameter REG_ADDR_WIDTH = 5) (input id_ex_mem_data_rd_en,input [REG_ADDR_WIDTH-1:0] id_ex_reg_wr_addr,input if_id_rd_reg_a_en,input if_id_rd_reg_b_en,input [REG_ADDR_WIDTH-1:0] if_id_rd_reg_a_addr,input [REG_ADDR_WIDTH-1:0] if_id_rd_reg_b_addr,input select_new_pc,output reg inst_rd_en,output reg stall,output reg general_flush,output reg decode_flush);\n [/INST]\n", "output": "wire load_hazard; \n assign load_hazard = id_ex_mem_data_rd_en & \n (((id_ex_reg_wr_addr==if_id_rd_reg_a_addr)&if_id_rd_reg_a_en)|((id_ex_reg_wr_addr==if_id_rd_reg_b_addr)&if_id_rd_reg_b_en)); \n always@(*)begin \n  if(select_new_pc)begin \n  inst_rd_en = 1; \n  stall = 0; \n  general_flush = 1; \n  decode_flush = 1; \n  end \n  else if(load_hazard)begin \n  inst_rd_en = 0; \n  stall = 1; \n  general_flush = 0; \n  decode_flush = 1; \n  end \n  else begin \n  inst_rd_en = 1; \n  stall = 0; \n  general_flush = 0; \n  decode_flush = 0; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a first-in-first-out (FIFO) buffer with a depth of 4. It has input and output ports for data and control signals. The module tracks the head and tail pointers, as well as the count of elements in the FIFO. It has logic for pushing and popping elements, and it also manages the full and empty flags. The module uses a reg array to implement the FIFO memory. The input data is written to the FIFO on a push operation, and the output data is read from the FIFO on a pop operation.\n\n Module header:\n\nmodule rcn_fifo (input rst,input clk,input [68:0] rcn_in,input push,output full,output [68:0] rcn_out,input pop,output empty);\n [/INST]\n", "output": "parameter DEPTH = 4; \n  reg [4:0] head; \n  reg [4:0] tail; \n  reg [5:0] cnt; \n  wire fifo_full = (cnt == DEPTH); \n  wire fifo_empty = (cnt == 0); \n  always @ (posedge clk or posedge rst) \n  if (rst) \n  begin \n  head <= 5'd0; \n  tail <= 5'd0; \n  cnt <= 6'd0; \n  end \n  else \n  begin \n  if (push) \n  head <= (head == (DEPTH - 1)) ? 5'd0 : head + 5'd1; \n  if (pop) \n  tail <= (tail == (DEPTH - 1)) ? 5'd0 : tail + 5'd1; \n  case ({push, pop}) \n  2'b10: cnt <= cnt + 6'd1; \n  2'b01: cnt <= cnt - 6'd1; \n  default: ; \n  endcase \n  end \n  reg [67:0] fifo[(DEPTH - 1):0]; \n  always @ (posedge clk) \n  if (push) \n  fifo[head] <= rcn_in[67:0]; \n  assign full = fifo_full; \n  assign empty = fifo_empty; \n  assign rcn_out = {!fifo_empty, fifo[tail]}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"RSTGEN\" generates a synchronous reset signal \"RST_X_O\" based on the input clock \"CLK\" and asynchronous reset input \"RST_X_I\". The module uses an 8-bit counter \"cnt\" to generate the reset signal. When \"RST_X_I\" is not asserted, the counter is reset to 0. Otherwise, if \"RST_X_O\" is not active, the counter increments by 1 on every clock cycle. The reset output \"RST_X_O\" is assigned the value of the most significant bit of the counter.\n\n Module header:\n\nmodule RSTGEN(CLK, RST_X_I, RST_X_O);\n [/INST]\n", "output": "input CLK, RST_X_I; \n  output RST_X_O; \n  reg [7:0] cnt; \n  assign RST_X_O = cnt[7]; \n  always @(posedge CLK or negedge RST_X_I) begin \n  if (!RST_X_I) cnt <= 0; \n  else if (~RST_X_O) cnt <= (cnt + 1'b1); \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a D flip-flop with asynchronous reset. It has inputs D (data), CLK (clock), and RSTB (asynchronous active low reset), and outputs Q (output) and QN (complementary output). The module uses a built-in flip-flop component called FDC to implement the functionality. When RSTB is asserted low, the flip-flop is asynchronously cleared, and the Q output is driven to 0. When the clock signal transitions, the D input is sampled and stored in Q, while QN represents the logical complement of Q.\n\n Module header:\n\nmodule DFFARX1 (D,CLK,RSTB,Q,QN);\n [/INST]\n", "output": "input D; \n  input CLK; \n  input RSTB; \n  output Q; \n  output QN; \n  wire Qtemp; \n  assign QN = ~Qtemp; \n  assign Q = Qtemp; \n  FDC XIL_FDC (.D(D),.C(CLK),.CLR(~(RSTB)),.Q(Qtemp)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"fifo4\" implements a 4-entry first-in-first-out (FIFO) buffer. The module has clock and reset inputs, a clear input, data input and output, write and read enable signals, and full/empty indication outputs. It uses a memory array to store the data, and maintains write and read pointers to manage the data flow. The module tracks whether the FIFO is full or empty and includes logic to reset, clear, and update the pointers and control flags based on the input signals and clock.\n\n Module header:\n\nmodule fifo4(clk, rst, clr, din, we, dout, re, full, empty);\n [/INST]\n", "output": "parameter dw = 8; \n input clk, rst; \n input clr; \n input [dw:1] din; \n input we; \n output [dw:1] dout; \n input re; \n output full, empty; \n reg [dw:1] mem[0:3]; \n reg [1:0] wp; \n reg [1:0] rp; \n wire [1:0] wp_p1; \n wire [1:0] rp_p1; \n wire full, empty; \n reg gb; \n always @(posedge clk or negedge rst) \n  if(!rst) wp <= #1 2'h0; \n  else \n  if(clr) wp <= #1 2'h0; \n  else \n  if(we) wp <= #1 wp_p1; \n assign wp_p1 = wp + 2'h1; \n always @(posedge clk or negedge rst) \n  if(!rst) rp <= #1 2'h0; \n  else \n  if(clr) rp <= #1 2'h0; \n  else \n  if(re) rp <= #1 rp_p1; \n assign rp_p1 = rp + 2'h1; \n assign dout = mem[ rp ]; \n always @(posedge clk) \n  if(we) mem[ wp ] <= #1 din; \n assign empty = (wp == rp) & !gb; \n assign full = (wp == rp) & gb; \n always @(posedge clk) \n  if(!rst) gb <= #1 1'b0; \n  else \n  if(clr) gb <= #1 1'b0; \n  else \n  if((wp_p1 == rp) & we) gb <= #1 1'b1; \n  else \n  if(re) gb <= #1 1'b0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module instantiates a test circuit with an inverter gate. It also declares registers c and d, where register c is initialized. The value of d is assigned the bitwise AND operation of register c.\n\n Module header:\n\nmodule abc9_test019(input a, output b);\n [/INST]\n", "output": "assign b = ~a; \n (* keep *) reg [1:0] c; \n reg d; \n always @* d <= &c; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"clockgen\" is a clock generation module that uses a counter to generate synchronous and phase-aligned clock signals. It features the ability to divide the clock frequency, shift the phase of the clock, and stretch the pulse width of the clock. The module includes two instances of a clock domain crossing module (\"adcgen\" and \"clkgen\") that handle clock synchronization. The module utilizes a counter to generate different clock signals based on the values of \"clkdiv\" and \"shift\", and has provisions for handling reset conditions. The module also includes logic for handling synchronization and phase alignment of the generated clock signals.\n\n Module header:\n\nmodule clockgen (input clk,input reset,input [5:0]clkdiv,input shift,input stretch,output reg sync,output reg phase,output reg adcclk,output reg adcsync);\n [/INST]\n", "output": "reg [5:0]counter; \n  always @(posedge clk or posedge reset) \n  begin \n  if (reset) counter <= 6'd0; \n  else if (!shift) counter <= counter + 6'd1; \n  end \n  reg adcfsel; \n  always @(*) \n  begin \n  case (clkdiv[5:3]) \n  0: adcfsel <= counter[0]; \n  1: adcfsel <= counter[1]; \n  2: adcfsel <= counter[2]; \n  3: adcfsel <= counter[3]; \n  4: adcfsel <= counter[4]; \n  default: adcfsel = counter[5]; \n  endcase \n  end \n  wire adcgen_sync; \n  wire adcgen_phase; \n  clocksm adcgen \n (.clk(clk),.reset(reset),.syncin(adcfsel),.veto(1'b0),.sync(adcgen_sync),.phase(adcgen_phase)); \n  always @(posedge clk or posedge reset) \n  begin \n  if (reset) \n  begin \n  adcsync <= 0; \n  adcclk <= 0; \n  end \n  else \n  begin \n  adcsync <= adcgen_sync; \n  adcclk <= adcgen_phase; \n  end \n  end \n  reg fsel; \n  always @(*) \n  begin \n  case (clkdiv[2:0]) \n  0: fsel <= counter[0]; \n  1: fsel <= counter[1]; \n  2: fsel <= counter[2]; \n  3: fsel <= counter[3]; \n  4: fsel <= counter[4]; \n  default: fsel = counter[5]; \n  endcase \n  end \n  wire clkgen_sync; \n  wire clkgen_phase; \n  clocksm clkgen \n (.clk(clk),.reset(reset),.syncin(fsel),.veto(stretch),.sync(clkgen_sync),.phase(clkgen_phase)); \n  always @(posedge clk or posedge reset) \n  begin \n  if (reset) \n  begin \n  sync <= 0; \n  phase <= 0; \n  end \n  else \n  begin \n  sync <= clkgen_sync; \n  phase <= clkgen_phase; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module `rxr8` takes in inputs `x`, `ci`, `y`, and `e`, and produces outputs `w` and `co`. It uses a case statement based on the value of `y` to determine the output assignment. If `y` does not match any specified value, the default assignment is `{co,w} <= {ci,x}`. Otherwise, based on the value of `y`, the output `{co,w}` is assigned different values calculated based on the inputs `x`, `ci`, and `e`.\n\n Module header:\n\nmodule rxr8 (input [7:0] x,input ci,input [3:0] y,input e,output reg [7:0] w,output reg co);\n [/INST]\n", "output": "always @(x or ci or y or e) \n  case (y) \n  default: {co,w} <= {ci,x}; \n  5'd01: {co,w} <= e ? {x[0], ci, x[7:1]} : {ci, x[0], x[7:1]}; \n  5'd02: {co,w} <= e ? {x[1:0], ci, x[7:2]} : {ci, x[1:0], x[7:2]}; \n  5'd03: {co,w} <= e ? {x[2:0], ci, x[7:3]} : {ci, x[2:0], x[7:3]}; \n  5'd04: {co,w} <= e ? {x[3:0], ci, x[7:4]} : {ci, x[3:0], x[7:4]}; \n  5'd05: {co,w} <= e ? {x[4:0], ci, x[7:5]} : {ci, x[4:0], x[7:5]}; \n  5'd06: {co,w} <= e ? {x[5:0], ci, x[7:6]} : {ci, x[5:0], x[7:6]}; \n  5'd07: {co,w} <= e ? {x[6:0], ci, x[7]} : {ci, x[6:0], x[7]}; \n  5'd08: {co,w} <= {x,ci}; \n  endcase \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a clocked delay module with a configurable delay and data width. It uses a generate loop to create a chain of D Flip-Flops for the delay and assigns the input and output signals accordingly. The module effectively delays the input data by the specified number of clock cycles and outputs the delayed data.\n\n Module header:\n\nmodule CC_Delay(clk, reset, d, q);\n [/INST]\n", "output": "parameter WIDTH=1; \n  parameter DELAY=1; \n  input clk; \n  input reset; \n  input [WIDTH-1:0] d; \n  output [WIDTH-1:0] q; \n  wire [(WIDTH*DELAY)-1:0] reg_inputs; \n  wire [(WIDTH*DELAY)-1:0] reg_outputs; \n  genvar i; \n  generate \n  for (i = 0; i < DELAY; i = i + 1) \n  begin: DFF_CHAIN \n CC_DFlipFlop #(WIDTH) chain_reg(.clk(clk),.en(1'b1),.reset(reset),.d(reg_inputs[(i+1)*WIDTH-1:i*WIDTH]),.q(reg_outputs[(i+1)*WIDTH-1:i*WIDTH])); \n  if (i < DELAY - 1) begin \n  assign reg_inputs[(i+2)*WIDTH-1:(i+1)*WIDTH] = \n  reg_outputs[(i+1)*WIDTH-1:i*WIDTH]; \n  end \n  end \n  endgenerate \n  assign q = reg_outputs[(DELAY*WIDTH)-1:(DELAY-1)*WIDTH]; \n  assign reg_inputs[WIDTH-1:0] = d; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"bclg4\" represents a 4-bit carry lookahead generator. It takes 4 input signals \"g\" and 4 input signals \"p\", along with a single input signal \"cin\". The module produces 3 output signals \"cout\", \"gout\", and \"pout\". The \"cout\" output is a 3-bit signal, while \"gout\" and \"pout\" are single-bit signals.\n\nThe module contains several internal wires and logical gates, including AND and OR gates, to compute the \"cout\", \"gout\", and \"pout\" outputs based on the input signals \"g\", \"p\", and \"cin\". The \"gout\" output is computed as the logical OR of certain combinations of the input \"g\" and internal wires. The \"pout\" output is the logical AND of all input \"p\" signals.\n\n Module header:\n\nmodule bclg4 (cout, gout, pout, g, p, cin);\n [/INST]\n", "output": "output [2:0] cout; \n  output gout; \n  output pout; \n  input [3:0] g; \n  input [3:0] p; \n  input cin; \n  wire a1_out, a2_out, a3_out, a4_out, a5_out, a6_out; \n  wire a7_out, a8_out, a9_out; \n  and a1(a1_out, p[0], cin); \n  or o1(cout[0], g[0], a1_out); \n  and a2(a2_out, p[1], g[0]); \n  assign a3_out = p[1] & p[0] & cin; \n  assign cout[1] = g[1] | a2_out | a2_out; \n  and a4(a4_out, p[2], g[1]); \n  assign a5_out = p[2] & p[1] & g[0]; \n  assign a6_out = p[2]& p[1]& p[0]& cin; \n  assign cout[2] = g[2] | a4_out | a5_out | a6_out; \n  and a7(a7_out, p[3], g[2]); \n  assign a8_out = p[3] & p[2] & g[1]; \n  assign a9_out = p[3] & p[2] & p[1] & g[0]; \n  assign gout= g[3]| a7_out| a8_out| a9_out; \n  assign pout= p[0]& p[1]& p[2]& p[3]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, `val2seg`, takes a 4-bit input value and maps it to a 7-bit output representing a segment display encoding. It uses a case statement to assign the segment output based on the input value. Each input value corresponds to a specific segment encoding, and if the input value does not match any of the specified cases, a default \"off\" encoding is assigned to the segment output.\n\n Module header:\n\nmodule val2seg (input wire [3:0] value,output reg [6:0] seg);\n [/INST]\n", "output": "localparam CHAR_N = 7'b1111111; \n  localparam CHAR_0 = 7'b1000000; \n  localparam CHAR_1 = 7'b1111001; \n  localparam CHAR_2 = 7'b0100100; \n  localparam CHAR_3 = 7'b0110000; \n  localparam CHAR_4 = 7'b0011001; \n  localparam CHAR_5 = 7'b0010010; \n  localparam CHAR_6 = 7'b0000010; \n  localparam CHAR_7 = 7'b1111000; \n  localparam CHAR_8 = 7'b0000000; \n  localparam CHAR_9 = 7'b0010000; \n  localparam CHAR_A = 7'b0001000; \n  localparam CHAR_B = 7'b0000011; \n  localparam CHAR_C = 7'b1000110; \n  localparam CHAR_D = 7'b0100001; \n  localparam CHAR_E = 7'b0000110; \n  localparam CHAR_F = 7'b0001110; \n  always @(*) begin \n  case (value) \n  4'h0: seg <= CHAR_0; \n  4'h1: seg <= CHAR_1; \n  4'h2: seg <= CHAR_2; \n  4'h3: seg <= CHAR_3; \n  4'h4: seg <= CHAR_4; \n  4'h5: seg <= CHAR_5; \n  4'h6: seg <= CHAR_6; \n  4'h7: seg <= CHAR_7; \n  4'h8: seg <= CHAR_8; \n  4'h9: seg <= CHAR_9; \n  4'hA: seg <= CHAR_A; \n  4'hB: seg <= CHAR_B; \n  4'hC: seg <= CHAR_C; \n  4'hD: seg <= CHAR_D; \n  4'hE: seg <= CHAR_E; \n  4'hF: seg <= CHAR_F; \n  default: seg <= CHAR_N; \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module simply takes a 10-bit input buffer and assigns it to a 10-bit output lights, effectively creating an input buffer and output lights.\n\n Module header:\n\nmodule ledr(input [9:0] buffer,output [9:0] lights);\n [/INST]\n", "output": "assign lights = buffer; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module implements a 2-to-4 demultiplexer with an input 'in' and selection inputs 's1' and 's0'. The demultiplexer has four outputs 'out0', 'out1', 'out2', and 'out3'. It uses an encoding register to determine the state based on the input encoding. There are two separate always blocks, each with a case statement to assign the state based on different encodings. The state values are assigned according to the specified conditions and default assignments. The state value is then used to select the output based on the input and the selection inputs.\n\n Module header:\n\nmodule f2_demultiplexer1_to_4 (out0, out1, out2, out3, in, s1, s0);\n [/INST]\n", "output": "output out0, out1, out2, out3; \n reg out0, out1, out2, out3; \n input in; \n input s1, s0; \n reg [3:0] encoding; \n reg [1:0] state; \n  always @(encoding) begin \n  case (encoding) \n  4'bxx11: state = 1; \n  4'bx0xx: state = 3; \n  4'b11xx: state = 4; \n  4'bx1xx: state = 2; \n  4'bxx1x: state = 1; \n  4'bxxx1: state = 0; \n  default: state = 0; \n  endcase \n  end \n  always @(encoding) begin \n  case (encoding) \n  4'b0000: state = 1; \n  default: state = 0; \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an AC97 transceiver, interfacing between two clock domains and handling data transfers in both directions. It synchronizes the incoming AC97 data and sync signals to the system clock domain, and vice versa. It utilizes FIFOs for both the up and down directions to manage data flow and ensure synchronization between the clock domains. The module also handles reset signals to properly initialize the transceiver. The module ultimately provides control signals for data transfer in the up and down directions.\n\n Module header:\n\nmodule ac97_transceiver(input sys_clk,input sys_rst,input ac97_clk,input ac97_rst_n,input ac97_sin,output reg ac97_sout,output reg ac97_sync,output up_stb,input up_ack,output up_sync,output up_data,output down_ready,input down_stb,input down_sync,input down_data);\n [/INST]\n", "output": "reg ac97_sin_r; \n always @(negedge ac97_clk) ac97_sin_r <= ac97_sin; \n reg ac97_syncfb_r; \n always @(negedge ac97_clk) ac97_syncfb_r <= ac97_sync; \n wire up_empty; \n ac97_asfifo #(.DATA_WIDTH(2),.ADDRESS_WIDTH(6)) up_fifo (.Data_out({up_sync, up_data}),.Empty_out(up_empty),.ReadEn_in(up_ack),.RClk(sys_clk),.Data_in({ac97_syncfb_r, ac97_sin_r}),.Full_out(),.WriteEn_in(1'b1),.WClk(~ac97_clk),.Clear_in(sys_rst)); \n assign up_stb = ~up_empty; \n wire ac97_sync_r; \n always @(negedge ac97_rst_n, posedge ac97_clk) begin \n  if(~ac97_rst_n) \n  ac97_sync <= 1'b0; \n  else \n  ac97_sync <= ac97_sync_r; \n end \n wire ac97_sout_r; \n always @(negedge ac97_rst_n, posedge ac97_clk) begin \n  if(~ac97_rst_n) \n  ac97_sout <= 1'b0; \n  else \n  ac97_sout <= ac97_sout_r; \n end \n wire down_full; \n ac97_asfifo #(.DATA_WIDTH(2),.ADDRESS_WIDTH(6)) down_fifo (.Data_out({ac97_sync_r, ac97_sout_r}),.Empty_out(),.ReadEn_in(1'b1),.RClk(ac97_clk),.Data_in({down_sync, down_data}),.Full_out(down_full),.WriteEn_in(down_stb),.WClk(sys_clk),.Clear_in(sys_rst)); \n assign down_ready = ~down_full; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a flip-flop with asynchronous reset and enable signals. When the clear (Clr) signal is asserted, the output Q is set to 0. When the enable (En) signal is asserted and there is a rising edge on the clock (Clk), the output Q toggles its value. When neither the clear nor enable signal are asserted, the output Q remains unchanged.\n\n Module header:\n\nmodule t_flipflop (En, Clk, Clr, Q);\n [/INST]\n", "output": "input En, Clk, Clr; \n  output reg Q; \n  always @ (posedge Clk) \n  if (~Clr) begin \n  Q <= 1'b0; \n  end else if (En) begin \n  Q <= !Q; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a D flip-flop with asynchronous reset functionality. When the asynchronous reset signals arst1 and arst2 are active, and arst3 is inactive, the output q is set to 0. When arst1 is inactive and arst2 is active, the output q is set to 0. When arst3 is inactive, the output q is set to 0. Otherwise, the output q is set to the input d.\n\n Module header:\n\nmodule dffa4(clk, arst1, arst2, arst3, d, q);\n [/INST]\n", "output": "input clk, arst1, arst2, arst3, d; \n output reg q; \n always @(posedge clk, posedge arst1, posedge arst2, negedge arst3) begin \n  if (arst1) \n  q <= 0; \n  else if (arst2) \n  q <= 0; \n  else if (!arst3) \n  q <= 0; \n  else \n  q <= d; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module has an input wire \"clk\" and a parameter \"number\" set to 999. It contains an always block sensitive to the positive edge of the clock. Inside the block, it uses the $display system function to print the value of \"number\" whenever there is a positive clock edge.\n\n Module header:\n\nmodule target(input wire clk);\n [/INST]\n", "output": "parameter number = 999; \n  always @(posedge clk) \n  $display(\"%m: number=%0d\", number); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a clock counter that increments a count value on each rising edge of the input clock signal. When the count reaches a specific value, the output clock signal is toggled and the count is reset. Additionally, the module includes a reset signal that sets the count and output clock signal to a specific state.\n\n Module header:\n\nmodule clock_counter(input clk_i,input reset_n,output reg clk_o);\n [/INST]\n", "output": "reg [20:0] count; \n  always @ (posedge clk_i, negedge reset_n) \n  begin \n  count <= count + 1; \n  if(!reset_n) \n  begin \n  clk_o <= 0; \n  count <= 0; \n  end \n  else \n  if(count >= 519999) \n  begin \n  clk_o <= ~clk_o; \n  count <= 0; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a fake delay by directly assigning the input d to the output q, effectively passing the input data to the output on the next clock edge. The module has a WIDTH parameter to specify the data width, and it operates on a positive clock edge.\n\n Module header:\n\nmodule fakedelay(d,clk,q);\n [/INST]\n", "output": "parameter WIDTH=32; \n input [WIDTH-1:0] d; \n input clk; \n output [WIDTH-1:0] q; \n assign q=d; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"reg_file\" is a register file that allows for read and write operations on four 9-bit signed registers. It has inputs for reset, clock, write enable, read addresses, write address, and write data, and outputs for the data at the two read addresses. During a positive clock edge or reset, the module resets the registers to zero if the reset signal is high. If the write enable signal is high, it writes the write data to the specified register address. The data at the specified read addresses is then output.\n\n Module header:\n\nmodule reg_file(rst, clk, wr_en, rd0_addr, rd1_addr, wr_addr, wr_data,rd0_data, rd1_data);\n [/INST]\n", "output": "input rst, clk, wr_en; \n  input [1:0] rd0_addr, rd1_addr, wr_addr; \n  input signed [8:0] wr_data; \n  output signed [8:0] rd0_data, rd1_data; \n  integer i; \n  reg signed [8:0] registers [3:0]; \n  assign rd0_data = registers[rd0_addr]; \n  assign rd1_data = registers[rd1_addr]; \n  always@(posedge clk, posedge rst) begin \n  if(rst) for(i = 0; i < 4; i=i+1) registers[i] = 0; \n  else if(wr_en) registers[wr_addr] = wr_data; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a custom Lookup Table (LUT) implementation that can be customized for different platforms. It takes inputs a, d, dpra, clk, we, qdpo_clk, and qdpo_rst, and generates outputs dpo and qdpo based on the platform it's designed for. The module includes conditional statements for different platforms (Xilinx, Altera) and also includes a verification module. The output qdpo is assigned based on the condition of lut_registered_output, and dpo is assigned based on the condition of lut_output. This module provides flexibility in implementing LUT functionality tailored to specific platform requirements.\n\n Module header:\n\nmodule elut_custom #(parameter used = 0,parameter LUT_MASK={2**K{1'b0}}) (a,d,dpra,clk,we,dpo,qdpo_clk,qdpo_rst,qdpo);\n [/INST]\n", "output": "input [5 : 0] a; \n input [0 : 0] d; \n input [5 : 0] dpra; \n input clk; \n input we; \n input qdpo_clk; \n input qdpo_rst; \n output dpo; \n output qdpo; \n wire lut_output; \n wire lut_registered_output; \n `ifdef ZUMA_VERIFICATION \n  generate \n  if( used == 0) \n  else \n LUT_K #(.K(ZUMA_LUT_SIZE),.LUT_MASK(LUT_MASK)) verification_lut (.in(dpra),.out(lut_output)); \n DFF #(.INITIAL_VALUE(1'b0)) verification_latch (.D(lut_output),.Q(lut_registered_output),.clock(qdpo_clk)); \n  endgenerate \n `elsif PLATFORM_XILINX \n elut_xilinx LUT (.a(a),.d(d),.dpra(dpra),.clk(clk),.we(we),.qdpo_clk(qdpo_clk),.qdpo_rst(qdpo_rst),.dpo(lut_output),.qdpo(lut_registered_output)); \n `elsif PLATFORM_ALTERA \n SDPR LUT(.clock(clk),.data(d),.rdaddress(dpra),.wraddress(a),.wren(we),.q(lut_output)); \n `endif \n `ifdef XILINX_ISIM \n assign dpo = (lut_output === 1'bx) ? 0 : lut_output ; \n assign qdpo = (lut_registered_output === 1'bx) ? 0 : lut_registered_output ; \n `else \n assign dpo = lut_output; \n assign qdpo = lut_registered_output; \n `endif \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a simple memory-mapped system with an address input, clock input, reset signal, and readdata output. The readdata output is assigned a value of 1411627075 when the address input is high, and 0 otherwise.\n\n Module header:\n\nmodule usb_system_sysid_qsys_0 (address,clock,reset_n,readdata);\n [/INST]\n", "output": "output [ 31: 0] readdata; \n  input address; \n  input clock; \n  input reset_n; \n  wire [ 31: 0] readdata; \n  assign readdata = address ? 1411627075 : 0; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a quantum module that operates on data and control signals. It contains a register dataA, and calculates the hrdata based on the haddr input and the data stored in dataA or rodataA. The module also handles the write operation, updates the dataA when haddr is valid, and updates the ctr and write based on the control signals. Overall, it performs read and write operations on the specified data based on the control signals and address input.\n\n Module header:\n\nmodule quantum(input clk,input rst,input hwrite,input [31:0] hwdata,input [31:0] haddr,input hsel,output reg[31:0] hrdata,output[127:0] data,input [127:0] ro_data);\n [/INST]\n", "output": "reg[15:0] dataA[7:0]; \n assign data = {dataA[7], dataA[6], dataA[5], dataA[4], \n  dataA[3], dataA[2], dataA[1], dataA[0]}; \n wire[15:0] rodataA[7:0]; \n assign {rodataA[7], rodataA[6], rodataA[5], rodataA[4], \n  rodataA[3], rodataA[2], rodataA[1], rodataA[0]} = { \n  ro_data[127:112], ro_data[111:96], \n  ro_data[95 :80], ro_data[79:64], \n  ro_data[63 :48], ro_data[47:32], \n  ro_data[31 :16], ro_data[15:0] \n }; \n reg ctr; \n reg write; \n wire[2:0] raddr = haddr[4:2]; \n always @(*) begin \n  if (haddr[15:0] >= 'h20 && haddr[15:0] < 'h40) begin \n  hrdata = rodataA[raddr]; \n  end else if (haddr[15:0] < 'h20) begin \n  hrdata = dataA[raddr]; \n  end else begin \n  hrdata = 0; \n  end \n end \n always @(posedge clk) begin \n  if (rst) begin \n  ctr <= 0; \n  write <= 0; \n  end else if (ctr) begin \n  ctr <= 0; \n  if (write && haddr[15:0] < 'h20) \n  dataA[raddr] <= hwdata; \n  end else begin \n  ctr <= hsel; \n  write <= hwrite; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module receives HDMI input and processes the video data to identify the centroid coordinates of a specific color in the image. It uses a centroid module to calculate the centroid coordinates and then updates the pixel values for the cross product of red, green, and blue based on the calculated centroid. Finally, it outputs the processed HDMI signal with the updated pixel data and sync signals.\n\n Module header:\n\nmodule tb_centro();\n [/INST]\n", "output": "wire rx_pclk; \n wire rx_de; \n wire rx_hsync; \n wire rx_vsync; \n wire [7:0] rx_red; \n wire [7:0] rx_green; \n wire [7:0] rx_blue; \n wire tx_de; \n wire tx_hsync; \n wire tx_vsync; \n wire [7:0] tx_red; \n wire [7:0] tx_green; \n wire [7:0] tx_blue; \n hdmi_in file_input (.hdmi_clk(rx_pclk),.hdmi_de(rx_de),.hdmi_hs(rx_hsync),.hdmi_vs(rx_vsync),.hdmi_r(rx_red),.hdmi_g(rx_green),.hdmi_b(rx_blue)); \n reg [7:0] cross_r; \n reg [7:0] cross_g; \n reg [7:0] cross_b; \n wire [9:0] centr_x; \n wire [9:0] centr_y; \n wire [9:0] curr_h; \n wire [9:0] curr_w; \n centroid # \n (.IMG_W(64),.IMG_H(64)) \n centro \n (.clk(rx_pclk),.ce(1'b1),.rst(1'b0),.de(rx_de),.hsync(rx_hsync),.vsync(rx_vsync),.mask((rx_red == 8'hFF) ? 1'b1 : 1'b0),.x(centr_x),.y(centr_y),.c_h(curr_h),.c_w(curr_w)); \n always @(posedge rx_pclk) begin \n  cross_r = ((curr_h[9:0] == centr_y || curr_w == centr_x) ? 8'hFF : rx_red); \n  cross_g = ((curr_h[9:0] == centr_y || curr_w == centr_x) ? 8'h00 : rx_red); \n  cross_b = ((curr_h[9:0] == centr_y || curr_w == centr_x) ? 8'h00 : rx_red); \n end \n  assign tx_de = rx_de; \n  assign tx_hsync = rx_hsync; \n  assign tx_vsync = rx_vsync; \n  assign tx_red = cross_r; \n  assign tx_green = cross_g; \n  assign tx_blue = cross_b; \n hdmi_out file_output (.hdmi_clk(rx_pclk),.hdmi_vs(tx_vsync),.hdmi_de(tx_de),.hdmi_data({8'b0,tx_red,tx_green,tx_blue})); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a 32-word RAM with 16-bit words. It has input ports for clock, write enable, write address, write data, and two read addresses. The output is the sum of the contents read from the two specified addresses. The RAM is implemented as an array of 32 16-bit registers. The module writes to the RAM when the write enable is asserted, and calculates the sum of the contents at the two read addresses on the rising edge of the clock. The sum calculation involves adding the contents of the specified addresses and processing the result.\n\n Module header:\n\nmodule ram32_2sum (input clock, input write,input [4:0] wr_addr, input [15:0] wr_data,input [4:0] rd_addr1, input [4:0] rd_addr2,output reg [15:0] sum);\n [/INST]\n", "output": "reg [15:0] ram_array [0:31]; \n  wire [16:0] sum_int; \n  always @(posedge clock) \n  if(write) \n  ram_array[wr_addr] <= #1 wr_data; \n  assign sum_int = ram_array[rd_addr1] + ram_array[rd_addr2]; \n  always @(posedge clock) \n  sum <= #1 sum_int[16:1] + (sum_int[16]&sum_int[0]); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module `main_test` instantiates another module `uut` with input signals `clk`, `Data1`, `Data2`, `Data3`, `Data4`, and `IM_Data_out`. It sets the initial values for the inputs and assigns a clock signal. The clock signal toggles every 5 time units. Upon toggling, the input data signals `Data1`, `Data2`, `Data3`, and `Data4` are successively updated with predefined values after certain time delays. The `IM_Data_out` is the output of the module `uut` and is not directly controlled within the `main_test` module.\n\n Module header:\n\nmodule main_test;\n [/INST]\n", "output": "reg clk; \n  wire [7:0] IM_Data_out; \n  reg [7:0] Data1, Data2, Data3, Data4; \n main uut (.clk(clk),.Data1(Data1),.Data2(Data2),.Data3(Data3),.Data4(Data4),.IM_Data_out(IM_Data_out)); \n  initial begin \n  clk = 0; \n  #100 \n  Data1 = 8'b10000000; \n  Data2 = 8'b00001000; \n  Data3 = 8'b00100000; \n  Data4 = 8'b00000010; \n  #100 \n  Data1 = 8'b11000000; \n  Data2 = 8'b00001100; \n  Data3 = 8'b00110000; \n  Data4 = 8'b00000011; \n  #100 \n  Data1 = 8'b01101010; \n  Data2 = 8'b01110010; \n  Data3 = 8'b01101011; \n  Data4 = 8'b10101010; \n  end \n  always begin \n  #5 clk=~clk; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a parameterized mux_shuffle that takes in a UxV input and outputs a VxU result, where U and V are parameters. It uses nested generate loops to iterate through U and V, and assigns the input elements to the output in a shuffled order. Each input element is assigned to an output element based on the index calculations v*U+u and u*V+v. The module effectively shuffles the input elements to produce the output.\n\n Module header:\n\nmodule mux_shuffle #(parameter U = 2,parameter V = 2) (input [U*V-1:0] in,output [V*U-1:0] out);\n [/INST]\n", "output": "genvar u, v; \n  generate \n  for (u = 0; u < U; u = u + 1) begin : _U \n  for (v = 0; v < V; v = v + 1) begin : _V \n  assign out[v*U+u] = in[u*V+v]; \n  end \n  end \n  endgenerate \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module performs complex number multiplication using a butterfly structure. It takes real and imaginary parts of two complex numbers as inputs and produces the real and imaginary parts of the resulting complex number as outputs. The module contains six registers for storing the real and imaginary parts of the second complex number and uses floating point units (FPUs) to perform the multiplication and addition operations. The module also includes control signals for managing the FPU operations and employs sequential logic to update the registers on the rising edge of the clock signal.\n\n Module header:\n\nmodule bfly(clock,reset,re_w,re_x,re_y,im_w,im_x,im_y,re_z,im_z);\n [/INST]\n", "output": "input clock; \n input reset; \n input [`BITS-1:0] re_w; \n input [`BITS-1:0] re_x; \n input [`BITS-1:0] re_y; \n input [`BITS-1:0] im_w; \n input [`BITS-1:0] im_x; \n input [`BITS-1:0] im_y; \n output [`BITS-1:0] re_z; \n output [`BITS-1:0] im_z; \n wire [`BITS-1:0] x1; \n wire [`BITS-1:0] x2; \n wire [`BITS-1:0] x3; \n wire [`BITS-1:0] x4; \n wire [`BITS-1:0] sub5; \n wire [`BITS-1:0] add6; \n wire [`BITS-1:0] re_z; \n wire [`BITS-1:0] im_z; \n reg [`BITS-1:0] re_y_reg1; \n reg [`BITS-1:0] re_y_reg2; \n reg [`BITS-1:0] re_y_reg3; \n reg [`BITS-1:0] re_y_reg4; \n reg [`BITS-1:0] re_y_reg5; \n reg [`BITS-1:0] re_y_reg6; \n reg [`BITS-1:0] im_y_reg1; \n reg [`BITS-1:0] im_y_reg2; \n reg [`BITS-1:0] im_y_reg3; \n reg [`BITS-1:0] im_y_reg4; \n reg [`BITS-1:0] im_y_reg5; \n reg [`BITS-1:0] im_y_reg6; \n wire [7:0] x1_control; \n fpu_mul x1_mul \n (.clk(clock),.opa(re_x),.opb(re_w),.out(x1),.control(x1_control)); \n wire [7:0] x2_control; \n fpu_mul x2_mul \n (.clk(clock),.opa(im_x),.opb(im_w),.out(x2),.control(x2_control)); \n wire [7:0] x3_control; \n fpu_mul x3_mul \n (.clk(clock),.opa(re_x),.opb(im_w),.out(x3),.control(x3_control)); \n wire [7:0] x4_control; \n fpu_mul x4_mul \n (.clk(clock),.opa(im_x),.opb(re_w),.out(x4),.control(x4_control)); \n wire [7:0] sub5_control; \n fpu_add sub5_add \n (.clk(clock),.opa(x1),.opb(x2),.out(sub5),.control(sub5_control)); \n wire [7:0] add6_control; \n fpu_add add6_add \n (.clk(clock),.opa(x3),.opb(x4),.out(add6),.control(add6_control)); \n wire [7:0] re_z_control; \n fpu_add re_z_add \n (.clk(clock),.opa(sub5),.opb(re_y_reg6),.out(re_z),.control(re_z_control)); \n wire [7:0] im_z_control; \n fpu_add im_z_add \n (.clk(clock),.opa(add6),.opb(im_y_reg6),.out(im_z),.control(im_z_control)); \n always @(posedge clock) \n begin \n  re_y_reg1 <= re_y; \n  re_y_reg2 <= re_y_reg1; \n  re_y_reg3 <= re_y_reg2; \n  re_y_reg4 <= re_y_reg3; \n  re_y_reg5 <= re_y_reg4; \n  re_y_reg6 <= re_y_reg5; \n  im_y_reg1 <= im_y; \n  im_y_reg2 <= im_y_reg1; \n  im_y_reg3 <= im_y_reg2; \n  im_y_reg4 <= im_y_reg3; \n  im_y_reg5 <= im_y_reg4; \n  im_y_reg6 <= im_y_reg5; \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module instantiates two inner modules, `inner0_0` and `inner1_0`, and concatenates their process outputs to form the `process_output`. Each inner module receives a portion of the `process_input` and processes it based on the provided clock and process enable signals. The INSTANCE_NAME parameter is used to generate unique instance names for each inner module. The process outputs of the inner modules are then concatenated to form the final process output of the module.\n\n Module header:\n\nmodule map_ccm_W2_H1(input CLK, input process_CE, input [47:0] process_input, output [47:0] process_output);\n [/INST]\n", "output": "parameter INSTANCE_NAME=\"INST\"; \n  wire [23:0] inner0_0_process_output; \n  wire [23:0] inner1_0_process_output; \n  assign process_output = {inner1_0_process_output,inner0_0_process_output}; \n  ccm #(.INSTANCE_NAME({INSTANCE_NAME,\"_inner0_0\"})) inner0_0(.CLK(CLK), .process_CE(process_CE), .ccminp(({process_input[23:0]})), .process_output(inner0_0_process_output)); \n  ccm #(.INSTANCE_NAME({INSTANCE_NAME,\"_inner1_0\"})) inner1_0(.CLK(CLK), .process_CE(process_CE), .ccminp(({process_input[47:24]})), .process_output(inner1_0_process_output)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements an 8K RAM with separate high and low ports. It instantiates two RAM4K modules for the high and low portions. The module includes logic to select the high or low data output based on the high bit of the address signal. It also sets the write enable signals for the high and low portions based on the high bit of the address signal. Additionally, it sets the read enable signals high for both high and low portions.\n\n Module header:\n\nmodule ram8k_high(input clk,input [11:0] addr,input [15:0] data_in,output [15:0] data_out,input we,input re);\n [/INST]\n", "output": "wire [15:0] data_out_low; \n  wire [15:0] data_out_high; \n  wire we_low; \n  wire re_low; \n  wire we_high; \n  wire re_high; \n ram4k_high_low r1(.clk(clk),.addr(addr[10:0]),.data_in(data_in),.data_out(data_out_low),.we(we_low),.re(re_low)); \n ram4k_high_high r2(.clk(clk),.addr(addr[10:0]),.data_in(data_in),.data_out(data_out_high),.we(we_high),.re(re_high)); \n  reg on_high; \n  always @(posedge clk) on_high <= addr[11]; \n  assign data_out = on_high?data_out_high:data_out_low; \n  assign we_high = addr[11]&we; \n  assign we_low = (~addr[11])&we; \n  assign re_low = 1; \n  assign re_high = 1; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module selects a single bit from a 4-bit input vector using the sel_a and sel_b inputs. It iterates through each combination of sel_a and sel_b and then through each bit of the data_in vector to select the desired bit based on the inputs. The selected bit is then ORed to produce the final output.\n\n Module header:\n\nmodule unary_select_pair (sel_a, sel_b, data_in, selected_bit);\n [/INST]\n", "output": "parameter input_port = 0; \n  parameter WA = 4; \n  parameter WB = 4; \n  input [WA-1:0] sel_a; \n  input [WB-1:0] sel_b; \n  input [WA*WB-1:0] data_in; \n  output selected_bit; \n  genvar i,j; \n  wire [WA*WB-1:0] selected; \n  generate \n  for (i=0; i<WA; i=i+1) begin:ol \n  for (j=0; j<WB; j=j+1) begin:il \n  assign selected[i*WB+j] = (LAG_route_valid_turn(input_port, i)) ? \n  data_in[i*WB+j] & sel_a[i] & sel_b[j] : 1'b0; \n  end \n  end \n  endgenerate \n  assign selected_bit=|selected; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module is a synchronous circuit that processes input signals to generate ready and output signals. The module contains a message buffer and a position counter. When the send signal is active, the module sets the position counter and message buffer, and then decrements the position counter and outputs the corresponding message buffer value until the counter reaches 0. Afterward, it sets the ready and output signals back to their default values and inverts the message buffer if the position counter is not greater than 0.\n\n Module header:\n\nmodule rcswitch_send(input clk,input rst,input send,input [39:0] addr,input [39:0] chan,input [15:0] stat,output ready,output out);\n [/INST]\n", "output": "reg r_out; \n  reg r_ready; \n  reg [7:0] pos; \n  reg [127:0] msg; \n  initial begin \n  r_ready <= 1; \n  r_out <= 0; \n  pos <= 0; \n  msg <= 0; \n  end \n  always @(posedge clk or posedge rst) begin \n  if(rst) begin \n  r_ready <= 1; \n  r_out <= 0; \n  pos <= 0; \n  end \n  else begin \n  if(send && pos == 0) begin \n  pos <= 128; \n  r_ready <= 0; \n  msg[127:0] <= {addr[39:0], chan[39:0], stat[15:0], 32'b10000000_00000000_00000000_00000000}; \n  end \n  else if(pos > 0) begin \n  pos <= pos - 1; \n  r_out <= msg >> pos; \n  if(pos == 0) begin \n  r_ready <= 1; \n  r_out <= 0; \n  pos <= 0; \n  end \n  else begin \n  r_ready <= 0; \n  end \n  end \n  else begin \n  msg <= ~msg; \n  end \n  end \n  end \n  assign ready = r_ready; \n  assign out = r_out; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"fifo_mux_sim\" models a simulated system with various control and data signals. It uses a FIFO multiplexer to manage data flow. The module has signals for reset, clock, enable, data buses, FIFO control, and read/write signals. The simulation initializes these signals, toggles the clock, and displays the signal values at different time instances. It also simulates keyboard input, FIFO operations, and terminal output by manipulating the control signals and data inputs. The module uses a FIFO multiplexer to select data based on certain control conditions, and it finishes the simulation after all the operations are performed.\n\n Module header:\n\nmodule fifo_mux_sim;\n [/INST]\n", "output": "reg reset; \n  reg clear; \n  reg clk; \n  reg pia_e; \n  wire pia_ca1, pia_cb1; \n  reg pia_ca2, pia_cb2; \n  wire [6:0] pia_pa; \n  reg [6:0] pia_pb; \n  wire pia_da; \n  reg fifo_rxf, fifo_txe; \n  wire fifo_rd, fifo_wr; \n  wire [7:0] fifo_data; \n  reg [7:0] fifo_data_in; \n fifo_mux U(.reset(reset),.clear(clear),.clk(clk),.pia_e(pia_e),.pia_ca1(pia_ca1),.pia_cb1(pia_cb1),.pia_ca2(pia_ca2),.pia_cb2(pia_cb2),.pia_pa(pia_pa),.pia_pb(pia_pb),.pia_da(pia_da),.fifo_rxf(fifo_rxf),.fifo_txe(fifo_txe),.fifo_rd(fifo_rd),.fifo_wr(fifo_wr),.fifo_data(fifo_data)); \n  always #41.5 clk <= ~clk; \n initial $monitor($time, \" reset=%b pia_e=%b pia_ca1=%b pia_cb1=%b pia_ca2=%b pia_cb2=%b pia_pa=%x pia_pb=%x pia_da=%b fifo_rd=%b fifo_wr=%b fifo_rxf=%b fifo_txe=%b fifo_data=%x\",reset, pia_e, pia_ca1, pia_cb1, pia_ca2, pia_cb2, pia_pa, pia_pb, pia_da, fifo_rd, fifo_wr, fifo_rxf, fifo_txe, fifo_data); \n  initial begin \n  reset <= 0; \n  clear <= 0; \n  clk <= 0; \n  pia_e <= 0; \n  $display(\"\\nReset:\"); \n  #500 reset <= 1; \n  $display(\"\\nKeyboard input:\"); \n  #500 pia_e <= 0; \n  pia_ca2 <= 0; \n  pia_cb2 <= 0; \n  fifo_rxf <= 0; \n  fifo_txe <= 1; \n  pia_pb <= 0; \n  fifo_data_in <= 8'ha; \n  #500 pia_e <= 1; \n  pia_ca2 <= 1; \n  #500 pia_e <= 0; \n  pia_ca2 <= 0; \n  fifo_rxf <= 1; \n  $display(\"\\nTerminal output:\"); \n  #500 pia_e <= 0; \n  pia_ca2 <= 0; \n  pia_cb2 <= 0; \n  fifo_rxf <= 1; \n  fifo_txe <= 0; \n  pia_pb <= 7'hb; \n  fifo_data_in <= 0; \n  #500 pia_e <= 1; \n  pia_cb2 <= 1; \n  #500 pia_e <= 0; \n  pia_cb2 <= 0; \n  fifo_txe <= 1; \n  $finish; \n  end \n  assign fifo_data = (pia_e && pia_ca2) ? fifo_data_in : 8'bz; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a RAM interface with pipelined write operations. It includes pipelines for address, data, and write signals to synchronize and control the write operation. The module handles enabling, writing, and data transfer between different pipeline stages. It also includes functionality for gray code address conversion. The RAM control signals such as RAM_CE1n, RAM_WEn, RAM_LDn, and RAM_OEn are managed based on the enable and write signals. The data_out signal is pipelined through three stages before being assigned to the RAM_D_po output. The data_in_valid and data_in signals are controlled based on the enable_pipe3 and write_pipe3 signals. The module includes reset logic to initialize the pipelines and control signals.\n\n Module header:\n\nmodule nobl_if #(parameter WIDTH=18,DEPTH=19) (input clk,input rst,input [WIDTH-1:0] RAM_D_pi,output [WIDTH-1:0] RAM_D_po,output reg RAM_D_poe,output [DEPTH-1:0] RAM_A,output reg RAM_WEn,output RAM_CENn,output RAM_LDn,output RAM_OEn,output reg RAM_CE1n,input [DEPTH-1:0] address,input [WIDTH-1:0] data_out,output reg [WIDTH-1:0] data_in,output reg data_in_valid,input write,input enable);\n [/INST]\n", "output": "reg enable_pipe1; \n  reg [DEPTH-1:0] address_pipe1; \n  reg write_pipe1; \n  reg [WIDTH-1:0] data_out_pipe1; \n  reg enable_pipe2; \n  reg write_pipe2; \n  reg [WIDTH-1:0] data_out_pipe2; \n  reg enable_pipe3; \n  reg write_pipe3; \n  reg [WIDTH-1:0] data_out_pipe3; \n  assign RAM_LDn = 0; \n  assign RAM_OEn = 0; \n  wire [DEPTH-1:0] address_gray; \n  bin2gray #(.WIDTH(DEPTH)) bin2gray (.bin(address),.gray(address_gray)); \n  always @(posedge clk) \n  if (rst) \n  begin \n  enable_pipe1 <= 0; \n  address_pipe1 <= 0; \n  write_pipe1 <= 0; \n  data_out_pipe1 <= 0; \n  RAM_WEn <= 1; \n  RAM_CE1n <= 1; \n  end \n  else \n  begin \n  enable_pipe1 <= enable; \n  RAM_CE1n <= ~enable; \n  RAM_WEn <= ~write; \n  if (enable) \n  begin \n  address_pipe1 <= address_gray; \n  write_pipe1 <= write; \n  if (write) \n  data_out_pipe1 <= data_out; \n  end \n  end \n  assign RAM_A = address_pipe1; \n  assign RAM_CENn = 1'b0; \n  always @(posedge clk) \n  if (rst) \n  begin \n  enable_pipe2 <= 0; \n  data_out_pipe2 <= 0; \n  write_pipe2 <= 0; \n  end \n  else \n  begin \n  data_out_pipe2 <= data_out_pipe1; \n  write_pipe2 <= write_pipe1; \n  enable_pipe2 <= enable_pipe1; \n  end \n  always @(posedge clk) \n  if (rst) \n  begin \n  enable_pipe3 <= 0; \n  data_out_pipe3 <= 0; \n  write_pipe3 <= 0; \n  RAM_D_poe <= 0; \n  end \n  else \n  begin \n  data_out_pipe3 <= data_out_pipe2; \n  write_pipe3 <= write_pipe2; \n  enable_pipe3 <= enable_pipe2; \n  RAM_D_poe <= ~(write_pipe2 & enable_pipe2); \n  end \n  assign RAM_D_po = data_out_pipe3; \n  always @(posedge clk) \n  if (rst) \n  begin \n  data_in_valid <= 0; \n  data_in <= 0; \n  end \n  else \n  begin \n  data_in <= RAM_D_pi; \n  if (enable_pipe3 & ~write_pipe3) \n  begin \n  data_in_valid <= 1'b1; \n  end \n  else \n  data_in_valid <= 1'b0; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a state machine that controls an ultrasonic sensor. It uses the input clock and enable signals to transition between states S0, S1, and S2, and outputs a start signal and a 16-bit value based on the state. The module also manages the clock signals and reset signals for the ultrasonic sensor and the clock counter. The state machine transitions are based on the negedge of the clock when enabled, and the outputs are updated at the posedge of the clock. The clock counter and ultrasonic modulo counter are instantiated within the module to provide the necessary functionality.\n\n Module header:\n\nmodule ultrasonic_control (input clk ,input enable ,input signal ,output reg start ,output [15:0] value);\n [/INST]\n", "output": "reg [2:0] state ; \n  reg enableClk ; \n  reg rst_clk_n ; \n  reg rst_ult_n ; \n  wire [31:0] clkNumber ; \n  wire done ; \n  localparam S0 = 3'b000 ; \n  localparam S1 = 3'b001 ; \n  localparam S2 = 3'b010 ; \n  localparam S3 = 3'b011 ; \n  always @ ( negedge clk ) \n  if ( enable ) \n  case ( state ) \n  S0: \n  state <= S1 ; \n  S1: \n  if ( 1_200 == clkNumber ) \n  state <= S2 ; \n  else \n  state <= S1 ; \n  S2: \n  if ( 25_000_000 == clkNumber ) \n  state <= S0 ; \n  else \n  state <= S2 ; \n  default: \n  state <= S0 ; \n  endcase \n  else \n  state <= S0 ; \n  always @ ( posedge clk) \n  case ( state ) \n  S0: begin \n  start <= 0 ; \n  rst_clk_n <= 0 ; \n  rst_ult_n <= 0 ; \n  enableClk <= 0 ; \n  end S1: begin \n  start <= 1 ; \n  rst_clk_n <= 1 ; \n  rst_ult_n <= 1 ; \n  enableClk <= 1 ; \n  end S2: begin \n  start <= 0 ; \n  rst_clk_n <= 1 ; \n  rst_ult_n <= 1 ; \n  enableClk <= 1 ; \n  end default: begin \n  start <= 0 ; \n  rst_clk_n <= 0 ; \n  rst_ult_n <= 0 ; \n  enableClk <= 0 ; \n  end \n  endcase \n clk_counter medidorDeTiempo (.clk (clk) ,.enable (enableClk) ,.rst_n (rst_clk_n) ,.clkNumber(clkNumber)) ; \n ultrasonic modulo (.clk (clk) ,.signal (signal) ,.rst_n (rst_ult_n) ,.value (value) ,.done (done)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a 20kHz, 1MSa/s IIR filter. It takes in a clock signal and an 8-bit input adc_d, and outputs a ready signal rdy and an 8-bit output out. The module maintains an internal count and updates it on each clock edge. It also maintains the previous and current input samples (x0 and x1) and the previous and current output samples (y0 and y1). On each clock edge, it updates the filter state based on the input adc_d and previous state values, applying a series of shift and add operations to calculate the new output sample. The module also outputs the 8 most significant bits of the current output sample.\n\n Module header:\n\nmodule lp20khz_1MSa_iir_filter(input clk, input [7:0] adc_d, output rdy, output [7:0] out);\n [/INST]\n", "output": "reg [23:0] cnt = 1; \n  assign rdy = cnt[0]; \n  always @(posedge clk) \n  cnt <= {cnt[22:0], cnt[23]}; \n  reg [7:0] x0 = 0; \n  reg [7:0] x1 = 0; \n  reg [16:0] y0 = 0; \n  reg [16:0] y1 = 0; \n  always @(posedge clk) \n  begin \n  if (rdy) \n  begin \n  x0 <= x1; \n  x1 <= adc_d; \n  y0 <= y1; \n  y1 <= \n  x0 + {x1, 1'b0} + adc_d + 436 \n  - ((y0 >> 7) + (y0 >> 6) + (y0 >> 4) + (y0 >> 2) + (y0 >> 1)) \n  + ((y1 >> 8) + (y1 >> 7) + (y1 >> 4) + (y1 >> 2) + (y1 >> 1) + y1); \n  end \n  end \n  assign out = y1[16:9]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module is a VGA color generator that sets the color output based on the horizontal sync signal and the selected mode. It uses a sync generator to generate the sync signals. When the blanking signal is high, the color is set to black. Otherwise, it checks the horizontal sync signal to determine which color to output based on specific ranges for each color. The colors are then assigned to the red, green, and blue color components.\n\n Module header:\n\nmodule dummy_ula(input wire clk,input wire mode,output reg [2:0] r,output reg [2:0] g,output reg [2:0] b,output wire csync);\n [/INST]\n", "output": "reg [2:0] ri = 3'b000; \n  reg [2:0] gi = 3'b000; \n  reg [2:0] bi = 3'b000; \n  wire [8:0] hc; \n  wire [8:0] vc; \n  wire blank; \n sync_generator_pal_ntsc sincronismos (.clk(clk),.in_mode(mode),.csync_n(csync),.hc(hc),.vc(vc),.blank(blank)); \n  parameter BLACK = 9'b000000000, \n  BLUE = 9'b000000111, \n  RED = 9'b000111000, \n  MAGENTA = 9'b000111111, \n  GREEN = 9'b111000000, \n  CYAN = 9'b111000111, \n  YELLOW = 9'b111111000, \n  WHITE = 9'b111111111; \n  always @* begin \n  if (blank == 1'b1) begin \n  {g,r,b} = BLACK; \n  end \n  else begin \n  {g,r,b} = BLACK; \n  if (hc >= (44*0) && hc <= (44*1-1)) begin \n  {g,r,b} = WHITE; \n  end \n  if (hc >= (44*1) && hc <= (44*2-1)) begin \n  {g,r,b} = YELLOW; \n  end \n  if (hc >= (44*2) && hc <= (44*3-1)) begin \n  {g,r,b} = CYAN; \n  end \n  if (hc >= (44*3) && hc <= (44*4-1)) begin \n  {g,r,b} = GREEN; \n  end \n  if (hc >= (44*4) && hc <= (44*5-1)) begin \n  {g,r,b} = MAGENTA; \n  end \n  if (hc >= (44*5) && hc <= (44*6-1)) begin \n  {g,r,b} = RED; \n  end \n  if (hc >= (44*6) && hc <= (44*7-1)) begin \n  {g,r,b} = BLUE; \n  end \n  if (hc >= (44*7) && hc <= (44*8-1)) begin \n  {g,r,b} = BLACK; \n  end \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a VGA display controller. It generates synchronization signals for horizontal and vertical timing, as well as the color signals for the red, green, and blue components of the display. The horizontal and vertical counters are updated based on the pixel clock and reset signals. The module uses specific parameters for the VGA timings and assigns the synchronization and color signals based on the count values.\n\n Module header:\n\nmodule vga_display (input wire clk_pix,input wire rst_n,output wire vga_hs,output wire vga_vs,output wire vga_r,output wire vga_g,output wire vga_b);\n [/INST]\n", "output": "parameter VGA_MAX_H = 800; \n parameter VGA_MAX_V = 525; \n parameter VGA_WIDTH = 640; \n parameter VGA_HEIGHT = 480; \n parameter VGA_SYNH_START = 656; \n parameter VGA_SYNV_START = 490; \n parameter VGA_SYNH_END = 752; \n parameter VGA_SYNV_END = 492; \n reg [9:0] cnt_hs; \n reg [9:0] cnt_vs; \n always @(posedge clk_pix) begin \n  if (~rst_n) \n  cnt_hs <= 0; \n  else if (cnt_hs < VGA_MAX_H) \n  cnt_hs <= cnt_hs + 1'd1; \n  else \n  cnt_hs <= 0; \n end \n always @(posedge clk_pix) begin \n  if (~rst_n) \n  cnt_vs <= 0; \n  else begin \n  if (cnt_hs == 0) begin \n  if (cnt_vs < VGA_MAX_V) \n  cnt_vs <= cnt_vs + 1'd1; \n  else \n  cnt_vs <= 0; \n  end \n  end \n end \n assign vga_hs = ~((cnt_hs >= VGA_SYNH_START) && (cnt_hs < VGA_SYNH_END)); \n assign vga_vs = ~((cnt_vs >= VGA_SYNV_START) && (cnt_vs < VGA_SYNV_END)); \n assign vga_r = cnt_hs[6]; \n assign vga_g =~cnt_hs[6]; \n assign vga_b = cnt_hs[5]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes a 32-bit input and splits it into two separate outputs. The upper 17 bits are assigned to o1, and the lower 15 bits are assigned to o0.\n\n Module header:\n\nmodule va7b832_v9a2a06 (input [31:0] i,output [16:0] o1,output [14:0] o0);\n [/INST]\n", "output": "assign o1 = i[31:15]; \n  assign o0 = i[14:0]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a computational unit with various inputs and outputs. The module calculates effective addresses, compares data, and generates flags based on the input signals. It includes a multiplexer to select the appropriate output based on the function select. The module also handles word operations and generates output flags. The input signals include x, y, off, seg, iflags, func, and word_op, and the module produces the output out and oflags. It includes internal wires and assigns the functionality of each component using assign statements.\n\n Module header:\n\nmodule othop (x, y, seg, off, iflags, func, word_op, out, oflags);\n [/INST]\n", "output": "input [15:0] x, y, off, seg, iflags; \n  input [2:0] func; \n  input word_op; \n  output [19:0] out; \n  output [8:0] oflags; \n  wire [15:0] deff, deff2, outf, clcm, setf, intf, strf; \n  wire [19:0] dcmp, dcmp2; \n  wire dfi; \n mux8_16 m0(func, dcmp[15:0], dcmp2[15:0], deff, outf, clcm, setf,intf, strf, out[15:0]); \n  assign out[19:16] = func ? dcmp2[19:16] : dcmp[19:16]; \n  assign dcmp = (seg << 4) + deff; \n  assign dcmp2 = (seg << 4) + deff2; \n  assign deff = x + y + off; \n  assign deff2 = x + y + off + 16'd2; \n  assign outf = y; \n assign clcm = y[2] ? (y[1] ? {iflags[15:1], 1'b0}: {iflags[15:11], 1'b0, iflags[9:0]}) \n : (y[1] ? {iflags[15:10], 1'b0, iflags[8:0]}: {iflags[15:1], ~iflags[0]}); \n assign setf = y[2] ? (y[1] ? {iflags[15:1], 1'b1}: {iflags[15:11], 1'b1, iflags[9:0]}) \n : (y[1] ? {iflags[15:10], 1'b1, iflags[8:0]}: iflags); \n  assign intf = {iflags[15:10], 2'b0, iflags[7:0]}; \n  assign dfi = iflags[10]; \n  assign strf = dfi ? (x - y) : (x + y); \n  assign oflags = word_op ? { out[11:6], out[4], out[2], out[0] } \n  : { iflags[11:8], out[7:6], out[4], out[2], out[0] }; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a Data SRAM controller with configurable parameters for cache set and line bits. It utilizes four instances of SRAM1RW64x128 to interface with the SRAM memory. The module takes clock and write enable inputs, as well as address and data inputs. It concatenates the address bits and routes the data input to the respective memory interfaces. The module then concatenates the output data from the memory instances to form the final data output. The control signals for the memory instances, such as chip select and write enable, are derived from the input signals and internal logic.\n\n Module header:\n\nmodule DataSRAMs #(parameter CACHE_SET_BITS = 2,parameter CACHE_LINE_BITS = 512)(input clk,input we,input [CACHE_SET_BITS-1:0] addr,input [CACHE_LINE_BITS-1:0] data_in,output [CACHE_LINE_BITS-1:0] data_out);\n [/INST]\n", "output": "wire oeb = 1'b0; \n  wire csb = 1'b0; \n  wire [6:0] sram_addr_concat = {{7-CACHE_SET_BITS{1'b0}}, addr}; \n  wire [5:0] sram_addr = sram_addr_concat[5:0]; \n  wire [127:0] din0 = data_in[127:0]; \n  wire [127:0] din1 = data_in[255:128]; \n  wire [127:0] din2 = data_in[383:256]; \n  wire [127:0] din3 = data_in[511:384]; \n  wire [127:0] dout0, dout1, dout2, dout3; \n  assign data_out = {dout3, dout2, dout1, dout0}; \n  SRAM1RW64x128 dn0(.A(sram_addr),.CE(clk),.WEB(~we),.OEB(oeb),.CSB(csb),.I(din0),.O(dout0)); \n  SRAM1RW64x128 dn1(.A(sram_addr),.CE(clk),.WEB(~we),.OEB(oeb),.CSB(csb),.I(din1),.O(dout1)); \n  SRAM1RW64x128 dn2(.A(sram_addr),.CE(clk),.WEB(~we),.OEB(oeb),.CSB(csb),.I(din2),.O(dout2)); \n  SRAM1RW64x128 dn3(.A(sram_addr),.CE(clk),.WEB(~we),.OEB(oeb),.CSB(csb),.I(din3),.O(dout3)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"pg\" implements a state machine with two states based on the input \"in\". The state is updated on the rising edge of the clock or on a reset. The module has an output \"p\" that depends on the values of the state variables.\n\n Module header:\n\nmodule pg(input clk,input reset,input in,output p);\n [/INST]\n", "output": "reg [1:0] x; \n  always @(posedge clk or posedge reset) \n  if(reset) \n  x <= 0; \n  else \n  x <= { x[0], in }; \n  assign p = x[0] & !x[1]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes a 2-bit input and assigns the output based on the input value. If the input is 00, 01, 10, or 11, the output is set to the input value.\n\n Module header:\n\nmodule Test (out,in);\n [/INST]\n", "output": "input [1:0] in; \n  output reg [1:0] out; \n  always @* begin \n  case (in[1:0]) \n  2'd0, 2'd1, 2'd2, 2'd3: begin \n  out = in; \n  end \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a 3-stage FIFO (First In First Out) memory. It has inputs for datain, writeen, shiften, globalreset, and clk, as well as an output dataout. The module uses three registers data0, data1, and data2 to store the incoming data. The pos register keeps track of the current position in the FIFO. The datain is written into the FIFO when writeen and shiften are both asserted, and the data is shifted through the stages based on the shiften signal. The globalreset signal resets the FIFO to its initial state. The dataout output always provides the data stored in data0.\n\n Module header:\n\nmodule fifo3 (datain, writeen, dataout, shiften, globalreset, clk);\n [/INST]\n", "output": "input[18 - 1:0] datain; \n  input writeen; \n  output[18 - 1:0] dataout; \n  wire[18 - 1:0] dataout; \n  input shiften; \n  input globalreset; \n  input clk; \n  reg[18 - 1:0] data0; \n  reg[18 - 1:0] data1; \n  reg[18 - 1:0] data2; \n  reg[1:0] pos; \n  assign dataout = data0 ; \n  always @(posedge clk or posedge globalreset) \n  begin \n  if (globalreset == 1'b1) \n  begin \n  pos <= 2'b00 ; \n  data0 <= 0 ; \n  data1 <= 0 ; \n  data2 <= 0 ; \n  end \n  else \n  begin \n  if (writeen == 1'b1 & shiften == 1'b1) \n  begin \n  case (pos) \n  2'b00 : \n  begin \n  data0 <= 0 ; \n  data1 <= 0 ; \n  data2 <= 0 ; \n  end \n  2'b01 : \n  begin \n  data0 <= datain ; \n  data1 <= 0 ; \n  data2 <= 0 ; \n  end \n  2'b10 : \n  begin \n  data0 <= data1 ; \n  data1 <= datain ; \n  data2 <= 0 ; \n  end \n  2'b11 : \n  begin \n  data0 <= data1 ; \n  data1 <= data2 ; \n  data2 <= datain ; \n  end \n  endcase \n  end \n  else if (shiften == 1'b1) \n  begin \n  data0 <= data1 ; \n  data1 <= data2 ; \n  pos <= pos - 1 ; \n  end \n  else if (writeen == 1'b1) \n  begin \n  case (pos) \n  2'b00 : \n  begin \n  data0 <= datain ; \n  end \n  2'b01 : \n  begin \n  data1 <= datain ; \n  end \n  2'b10 : \n  begin \n  data2 <= datain ; \n  end \n  endcase \n  pos <= pos + 1 ; \n  end \n  end \n  end \n  endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module defines a single-output wire for a register, with 8 bits assigned to reg_0x0B. The module initializes the register with a value of 0x00.\n\n Module header:\n\nmodule r_PD_INTERFACE_REV_HIGH(output wire [7:0] reg_0x0B);\n [/INST]\n", "output": "assign reg_0x0B=8'h00; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module consists of an output register and an input register. The output register out_0r is connected to the input register inp_0r. The input register inp_0a is connected to the output register out_0a. Additionally, the output register out_0d is assigned the value of the 17th bit from the input register inp_0d.\n\n Module header:\n\nmodule BrzSlice_1_18_16 (out_0r, out_0a, out_0d,inp_0r, inp_0a, inp_0d);\n [/INST]\n", "output": "input out_0r; \n  output out_0a; \n  output out_0d; \n  output inp_0r; \n  input inp_0a; \n  input [17:0] inp_0d; \n  assign inp_0r = out_0r; \n  assign out_0a = inp_0a; \n  assign out_0d = inp_0d[16]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module simply assigns the input IN to the output OUT. This effectively creates a buffer that just copies the input to the output.\n\n Module header:\n\nmodule GP_IBUF(input IN, output OUT);\n [/INST]\n", "output": "assign OUT = IN; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an altpriority encoder that takes a 4-bit input data and produces a 2-bit output q. It uses two instances of the fpoint_qsys_addsub_single_altpriority_encoder module internally to encode subsets of the input data. The output q is determined using logical operations based on the outputs of the internal encoders.\n\n Module header:\n\nmodule fpoint_qsys_addsub_single_altpriority_encoder_9la (data,q) ;\n [/INST]\n", "output": "input [3:0] data; \n  output [1:0] q; \n  wire [0:0] wire_altpriority_encoder33_q; \n  wire wire_altpriority_encoder33_zero; \n  wire [0:0] wire_altpriority_encoder34_q; \n  fpoint_qsys_addsub_single_altpriority_encoder_64b altpriority_encoder33 \n (.data(data[1:0]),.q(wire_altpriority_encoder33_q),.zero(wire_altpriority_encoder33_zero)); \n  fpoint_qsys_addsub_single_altpriority_encoder_6la altpriority_encoder34 \n (.data(data[3:2]),.q(wire_altpriority_encoder34_q)); \n  assign \n  q = {wire_altpriority_encoder33_zero, ((wire_altpriority_encoder33_zero & wire_altpriority_encoder34_q) | ((~ wire_altpriority_encoder33_zero) & wire_altpriority_encoder33_q))}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a 4-to-1 multiplexer. It has four 32-bit input signals A, B, C, and D, and a 2-bit control signal 'enable'. Depending on the value of the 'enable' signal, the output 'O' will be selected from one of the input signals. When enable is 00, the output is A. When enable is 01, the output is B. When enable is 10, the output is C. When enable is 11, the output is D.\n\n Module header:\n\nmodule mux_4_to_1_32(input [31:0] A,B,C,D,input [1:0] enable,output reg[31:0] O);\n [/INST]\n", "output": "always @* begin \n  case (enable) \n  2'b00 : begin \n  O <= A; \n  end \n  2'b01 : begin \n  O <= B; \n  end \n  2'b10 : begin \n  O <= C; \n  end \n  2'b11 : begin \n  O <= D; \n  end \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an interconnect with signals for enabling and clocking a RAM module, and for controlling the RX FIFO write. It includes output and input signals for the RAM module, an input signal for the interconnect, and an input clock signal. The module uses various wires and assigns for connecting signals and assigns initial values for certain registers. The module also includes flip-flops and other declarations for maintaining specific logic behavior.\n\n Module header:\n\nmodule DemoInterconnect_jtag_axi_0_0_wr_status_flags_as_5 (\\DEVICE_7SERIES.NO_BMM_INFO.SDP.WIDE_PRIM18.ram ,ENA_I,\\gic0.gc0.count_d1_reg[5] ,aclk,rx_fifo_wr_en,ENB_dly_D_0);\n [/INST]\n", "output": "output \\DEVICE_7SERIES.NO_BMM_INFO.SDP.WIDE_PRIM18.ram ; \n  output ENA_I; \n  input \\gic0.gc0.count_d1_reg[5] ; \n  input aclk; \n  input rx_fifo_wr_en; \n  input ENB_dly_D_0; \n  wire ENA_I; \n  wire ENB_dly_D_0; \n  wire aclk; \n  wire \\gic0.gc0.count_d1_reg[5] ; \n  (* DONT_TOUCH *) wire ram_full_fb_i; \n  (* DONT_TOUCH *) wire ram_full_i; \n  wire rx_fifo_wr_en; \n  assign \\DEVICE_7SERIES.NO_BMM_INFO.SDP.WIDE_PRIM18.ram = ram_full_fb_i; \n LUT3 #(.INIT(8'hF4)) \n  \\DEVICE_7SERIES.NO_BMM_INFO.SDP.WIDE_PRIM18.ram_i_2 \n (.I0(ram_full_fb_i),.I1(rx_fifo_wr_en),.I2(ENB_dly_D_0),.O(ENA_I)); \n  (* DONT_TOUCH *) \n  (* KEEP = \"yes\" *) \n  (* equivalent_register_removal = \"no\" *) \n FDRE #(.INIT(1'b0)) \n  ram_full_fb_i_reg \n (.C(aclk),.CE(1'b1),.D(\\gic0.gc0.count_d1_reg[5] ),.Q(ram_full_fb_i),.R(1'b0)); \n  (* DONT_TOUCH *) \n  (* KEEP = \"yes\" *) \n  (* equivalent_register_removal = \"no\" *) \n FDRE #(.INIT(1'b0)) \n  ram_full_i_reg \n (.C(aclk),.CE(1'b1),.D(\\gic0.gc0.count_d1_reg[5] ),.Q(ram_full_i),.R(1'b0)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a 4-bit synchronous up-counter. It increments the 2-bit output q on every positive edge of the clock signal. When the reset signal r is asserted, the output q is set to 0. The carry-out signal cout indicates overflow when the counter reaches its maximum value and wraps back to 0.\n\n Module header:\n\nmodule counter_mod4(c, r, q, cout);\n [/INST]\n", "output": "input c, r; \n  output reg[1:0] q; \n  output reg cout; \n  always @(posedge c) \n  if (r) \n  {cout, q} <= 0; \n  else \n  {cout, q} <= q + 1'b1; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a 64-bit buffer for input signals. It takes a 64-bit input signal and replicates it to the output signal. The input is directly assigned to the output, effectively buffering the input.\n\n Module header:\n\nmodule fpu_bufrpt_grp64 (in,out);\n [/INST]\n", "output": "input [63:0] in; \n  output [63:0] out; \n  assign out[63:0] = in[63:0]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a decoder that takes a 9-bit input and decodes it into a 3-bit output based on certain conditions. The module contains a 6-bit signal s that is calculated based on different combinations of the input bits. Then, the input is decoded based on the value of s, and the decoded output is stored in the 3-bit register d. The decoder's functionality is based on the input conditions and the corresponding assignments to the output bits.\n\n Module header:\n\nmodule decoder (cx,d);\n [/INST]\n", "output": "output [2:0] d; \n  input [8:0] cx; \n  reg [2:0] d; \n  reg [5:0] s; \n  reg [8:0] cx1; \n  parameter s0 = 6'b011001; \n  parameter s1 = 6'b010010; \n  parameter s2 = 6'b101010; \n  parameter s3 = 6'b100000; \n  parameter s4 = 6'b010000; \n  parameter s5 = 6'b001000; \n  parameter s6 = 6'b000100; \n  parameter s7 = 6'b000010; \n  parameter s8 = 6'b000001; \n  always @(cx) \n  begin \n  cx1[0] = cx[0]; \n  cx1[1] = cx[1]; \n  cx1[2] = cx[2]; \n  cx1[3] = cx[3]; \n  cx1[4] = cx[4]; \n  cx1[5] = cx[5]; \n  cx1[6] = cx[6]; \n  cx1[7] = cx[7]; \n  cx1[8] = cx[8]; \n  s[0]= cx[2]+ cx[3]; \n  s[1]= cx[0]+ cx[1]+ cx[4]; \n  s[2]= cx[0]+ cx[2]+ cx[5]; \n  s[3]= cx[6]; \n  s[4]= cx[1]+ cx[2]+ cx[7]; \n  s[5]= cx[0]+ cx[8]; \n  case(s) \n  s0: \n  begin \n  if(cx[0]==1'b0) \n  begin \n  cx1[0]=1'b1; \n  end \n  else \n  begin \n  cx1[0]=1'b0; \n  end \n  end \n  s1: \n  begin \n  if(cx[1]==1'b0) \n  begin \n  cx1[1]=1'b1; \n  end \n  else \n  begin \n  cx1[1]=1'b0; \n  end \n  end \n  s2: \n  begin \n  if(cx[2]==1'b0) \n  begin \n  cx1[2]=1'b1; \n  end \n  else \n  begin \n  cx1[2]=1'b0; \n  end \n  end \n  s3: \n  begin \n  if(cx[3]==1'b0) \n  begin \n  cx1[3]=1'b1; \n  end \n  else \n  begin \n  cx1[3]=1'b0; \n  end \n  end \n  s4: \n  begin \n  if(cx[4]==1'b0) \n  begin \n  cx1[4]=1'b1; \n  end \n  else \n  begin \n  cx1[4]=1'b0; \n  end \n  end \n  s5: \n  begin \n  if(cx[5]==1'b0) \n  begin \n  cx1[5]=1'b1; \n  end \n  else \n  begin \n  cx1[5]=1'b0; \n  end \n  end \n  s6: \n  begin \n  if(cx[6]==1'b0) \n  begin \n  cx1[6]=1'b1; \n  end \n  else \n  begin \n  cx1[6]=1'b0; \n  end \n  end \n  s7: \n  begin \n  if(cx[7]==1'b0) \n  begin \n  cx1[7]=1'b1; \n  end \n  else \n  begin \n  cx1[7]=1'b0; \n  end \n  end \n  s8: \n  begin \n  if(cx[8]==1'b0) \n  begin \n  cx1[8]=1'b1; \n  end \n  else \n  begin \n  cx1[8]=1'b0; \n  end \n  end \n  default: \n  begin \n  cx1[0]=cx[0]; \n  cx1[1]=cx[1]; \n  cx1[2]=cx[2]; \n  cx1[3]=cx[3]; \n  cx1[4]=cx[4]; \n  cx1[5]=cx[5]; \n  cx1[6]=cx[6]; \n  cx1[7]=cx[7]; \n  cx1[8]=cx[8]; \n  end \n  endcase \n  d[0] = cx1[0]; \n  d[1] = cx1[1]; \n  d[2] = cx1[2]; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, altor32_dfu, implements forwarding logic for a pipeline processor. It uses the inputs ra_i, rb_i, ra_regval_i, rb_regval_i, rd_ex_i, rd_wb_i, load_pending_i, rd_load_i, mult_ex_i, result_ex_i, and result_wb_i to determine the values of result_ra_o, result_rb_o, resolved_o, and stall_o.\n\nThe module checks if the values for ra_i and rb_i are valid and if there are pending loads. It also determines if the values need to be forwarded from previous pipeline stages based on the values of rd_ex_i, rd_wb_i, result_ex_i, and result_wb_i. The resolved_o signal is set when forwarding occurs, and the stall_o signal is set when there are pending loads or when mult_ex_i is true.\n\nThe module also includes debug messages to display the values being forwarded for ra and rb, providing insight into the data forwarding process.\n\n Module header:\n\nmodule altor32_dfu (input [4:0] ra_i ,input [4:0] rb_i ,input [31:0] ra_regval_i ,input [31:0] rb_regval_i ,input [4:0] rd_ex_i,input [4:0] rd_wb_i,input load_pending_i ,input [4:0] rd_load_i ,input mult_ex_i ,input [31:0] result_ex_i ,input [31:0] result_wb_i ,output reg [31:0] result_ra_o ,output reg [31:0] result_rb_o ,output reg resolved_o ,output reg stall_o);\n [/INST]\n", "output": "always @ * \n begin \n  result_ra_o = ra_regval_i; \n  result_rb_o = rb_regval_i; \n  stall_o = 1'b0; \n  resolved_o = 1'b0; \n  if (ra_i != 5'b00000) \n  begin \n  if (ra_i == rd_load_i & load_pending_i) \n  begin \n  stall_o = 1'b1; \n `ifdef CONF_CORE_DEBUG \n  $display(\" rA[%d] not ready as load still pending\", ra_i); \n `endif \n  end \n  else if (ra_i == rd_ex_i) \n  begin \n  if (mult_ex_i) \n  stall_o = 1'b1; \n  else \n  begin \n  result_ra_o = result_ex_i; \n  resolved_o = 1'b1; \n `ifdef CONF_CORE_DEBUG \n  $display(\" rA[%d] forwarded 0x%08x (PC-4)\", ra_i, result_ra_o); \n `endif \n  end \n  end \n  else if (ra_i == rd_wb_i) \n  begin \n  result_ra_o = result_wb_i; \n  resolved_o = 1'b1; \n `ifdef CONF_CORE_DEBUG \n  $display(\" rA[%d] forwarded 0x%08x (PC-8)\", ra_i, result_ra_o); \n `endif \n  end \n  end \n  if (rb_i != 5'b00000) \n  begin \n  if (rb_i == rd_load_i & load_pending_i) \n  begin \n  stall_o = 1'b1; \n `ifdef CONF_CORE_DEBUG \n  $display(\" rB[%d] not ready as load still pending\", rb_i); \n `endif \n  end \n  else if (rb_i == rd_ex_i) \n  begin \n  if (mult_ex_i) \n  stall_o = 1'b1; \n  else \n  begin \n  result_rb_o = result_ex_i; \n  resolved_o = 1'b1; \n `ifdef CONF_CORE_DEBUG \n  $display(\" rB[%d] forwarded 0x%08x (PC-4)\", rb_i, result_rb_o); \n `endif \n  end \n  end \n  else if (rb_i == rd_wb_i) \n  begin \n  result_rb_o = result_wb_i; \n  resolved_o = 1'b1; \n `ifdef CONF_CORE_DEBUG \n  $display(\" rB[%d] forwarded 0x%08x (PC-8)\", rb_i, result_rb_o); \n `endif \n  end \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module FF_6 instantiates a 2-bit flip-flop. It uses the clock and reset inputs to control the state of the flip-flop and the input and output data. The output data is derived from the flip-flop state or a reset value. The module also includes randomization features and uses the clock signal for state updates.\n\n Module header:\n\nmodule FF_6(input clock,input reset,input [1:0] io_input_0_data,input io_input_0_reset,output [1:0] io_output_data);\n [/INST]\n", "output": "reg [1:0] ff; \n  reg [31:0] _RAND_0; \n  wire [1:0] _T_8; \n  wire [1:0] _T_9; \n  assign _T_8 = io_input_0_reset ? 2'h1 : io_input_0_data; \n  assign _T_9 = io_input_0_reset ? 2'h1 : ff; \n  assign io_output_data = _T_9; \n `ifdef RANDOMIZE \n  integer initvar; \n  initial begin \n  `ifndef verilator \n  #0.002 begin end \n  `endif \n  `ifdef RANDOMIZE_REG_INIT \n  _RAND_0 = {1{$random}}; \n  ff = _RAND_0[1:0]; \n  `endif \n  end \n `endif \n  always @(posedge clock) begin \n  if (reset) begin \n  ff <= 2'h1; \n  end else begin \n  if (io_input_0_reset) begin \n  ff <= 2'h1; \n  end else begin \n  ff <= io_input_0_data; \n  end \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module acts as an AXI register slice with configurable parameters for data width and register behavior. It handles the forwarding and registering of data and valid signals between the input and output AXI interfaces. The module includes logic for both forward and backward registered data paths, and it uses the input clock and reset signals to control the data flow. The module also generates the necessary logic based on the FORWARD_REGISTERED and BACKWARD_REGISTERED parameters to enable or disable data registration for the forward and backward paths. Additionally, the module assigns the appropriate values to the output signals based on the input and generated control signals.\n\n Module header:\n\nmodule axi_register_slice #(parameter DATA_WIDTH = 32,parameter FORWARD_REGISTERED = 0,parameter BACKWARD_REGISTERED = 0)(input clk,input resetn,input s_axi_valid,output s_axi_ready,input [DATA_WIDTH-1:0] s_axi_data,output m_axi_valid,input m_axi_ready,output [DATA_WIDTH-1:0] m_axi_data);\n [/INST]\n", "output": "wire [DATA_WIDTH-1:0] bwd_data_s; \n wire bwd_valid_s; \n wire bwd_ready_s; \n wire [DATA_WIDTH-1:0] fwd_data_s; \n wire fwd_valid_s; \n wire fwd_ready_s; \n generate if (FORWARD_REGISTERED == 1) begin \n reg fwd_valid = 1'b0; \n reg [DATA_WIDTH-1:0] fwd_data = 'h00; \n assign fwd_ready_s = ~fwd_valid | m_axi_ready; \n assign fwd_valid_s = fwd_valid; \n assign fwd_data_s = fwd_data; \n always @(posedge clk) begin \n  if (~fwd_valid | m_axi_ready) \n  fwd_data <= bwd_data_s; \n end \n always @(posedge clk) begin \n  if (resetn == 1'b0) begin \n  fwd_valid <= 1'b0; \n  end else begin \n  if (bwd_valid_s) \n  fwd_valid <= 1'b1; \n  else if (m_axi_ready) \n  fwd_valid <= 1'b0; \n  end \n end \n end else begin \n assign fwd_data_s = bwd_data_s; \n assign fwd_valid_s = bwd_valid_s; \n assign fwd_ready_s = m_axi_ready; \n end \n endgenerate \n generate if (BACKWARD_REGISTERED == 1) begin \n reg bwd_ready = 1'b1; \n reg [DATA_WIDTH-1:0] bwd_data = 'h00; \n assign bwd_valid_s = ~bwd_ready | s_axi_valid; \n assign bwd_data_s = bwd_ready ? s_axi_data : bwd_data; \n assign bwd_ready_s = bwd_ready; \n always @(posedge clk) begin \n  if (bwd_ready) \n  bwd_data <= s_axi_data; \n end \n always @(posedge clk) begin \n  if (resetn == 1'b0) begin \n  bwd_ready <= 1'b1; \n  end else begin \n  if (fwd_ready_s) \n  bwd_ready <= 1'b1; \n  else if (s_axi_valid) \n  bwd_ready <= 1'b0; \n  end \n end \n end else begin \n assign bwd_valid_s = s_axi_valid; \n assign bwd_data_s = s_axi_data; \n assign bwd_ready_s = fwd_ready_s; \n end endgenerate \n assign m_axi_data = fwd_data_s; \n assign m_axi_valid = fwd_valid_s; \n assign s_axi_ready = bwd_ready_s; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, named 'modulario_en_in', has an 8-bit input 'z' and a 1-bit input 'vz'. It also has an 8-bit output 'd' and a 1-bit output 'vd'. The outputs 'd' and 'vd' are directly connected to the inputs 'z' and 'vz' respectively. The width of the input and output is parameterized with a default value of 8.\n\n Module header:\n\nmodule modulario_en_in (vd, d, vz, z);\n [/INST]\n", "output": "parameter integer rscid = 1; \n  parameter integer width = 8; \n  output vd; \n  output [width-1:0] d; \n  input vz; \n  input [width-1:0] z; \n  wire [width-1:0] d; \n  wire vd; \n  assign d = z; \n  assign vd = vz; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, named \"rrab\", implements a round-robin arbiter. It has inputs for requests and clock, as well as an active-low reset signal. The module selects one of the request lines and outputs it as the grant. The grant logic is based on the round-robin priority, where each request has a predetermined priority. When a request is granted, the module updates the last winner and the winner, and it can handle the reset condition.\n\n Module header:\n\nmodule rrab (output reg [1:0] grant,input [1:0] request,input clk,input reset_n);\n [/INST]\n", "output": "parameter S0 = 2'b00; \n  parameter S1 = 2'b01; \n  parameter S2 = 2'b10; \n  parameter S3 = 2'b11; \n  reg [1:0] grant_i; \n  reg last_winner, winner; \n  always @(posedge clk or negedge reset_n) begin \n  if (!reset_n) begin \n  last_winner <= 1'b0; \n  grant <= S0; \n  end else begin \n  last_winner <= winner; \n  grant <= grant_i; \n  end \n  end \n  always @(*) begin \n  case(request) \n  S0: begin \n  grant_i = S0; \n  end \n  S1: begin \n  grant_i = S1; \n  end \n  S2: begin \n  grant_i = S2; \n  end \n  S3: begin \n  if (last_winner == 1'b0) begin \n  grant_i = S2; \n  end else begin \n  grant_i = S1; \n  end \n  end \n  endcase \n  end \n  always @(*) begin \n  if (grant_i == S0) begin \n  winner = last_winner; \n  end else begin \n  winner = grant_i[1]; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is an adapter that interfaces between two FIFO modules. It performs data transfer between the read and write interfaces of the input and output FIFOs based on the ready and size signals. The adapter handles read and write activation, strobe signals, and count tracking to ensure data transfer between the FIFOs. It also manages the reset conditions to initialize the adapter and the FIFOs.\n\n Module header:\n\nmodule adapter_ppfifo_2_ppfifo#(parameter DATA_WIDTH = 32)(input clk,input rst,input i_read_ready,output reg o_read_activate,input [23:0] i_read_size,input [DATA_WIDTH - 1:0] i_read_data,output reg o_read_stb,input [1:0] i_write_ready,output reg [1:0] o_write_activate,input [23:0] i_write_size,output reg o_write_stb,output [DATA_WIDTH - 1:0] o_write_data);\n [/INST]\n", "output": "reg [23:0] read_count; \n reg [23:0] write_count; \n assign o_write_data = i_read_data; \n always @ (posedge clk) begin \n  o_read_stb <= 0; \n  o_write_stb <= 0; \n  if (rst) begin \n  o_write_activate <= 0; \n  o_read_activate <= 0; \n  write_count <= 0; \n  read_count <= 0; \n  end \n  else begin \n  if (i_read_ready && !o_read_activate) begin \n  read_count <= 0; \n  o_read_activate <= 1; \n  end \n  if ((i_write_ready > 0) && (o_write_activate == 0)) begin \n  write_count <= 0; \n  if (i_write_ready[0]) begin \n  o_write_activate[0] <= 1; \n  end \n  else begin \n  o_write_activate[1] <= 1; \n  end \n  end \n  if (o_read_activate && (o_write_activate > 0)) begin \n  if ((write_count < i_write_size) && (read_count < i_read_size))begin \n  o_write_stb <= 1; \n  o_read_stb <= 1; \n  write_count <= write_count + 1; \n  read_count <= read_count + 1; \n  end \n  else begin \n  if (write_count >= i_write_size) begin \n  o_write_activate <= 0; \n  end \n  if (read_count >= i_read_size) begin \n  o_read_activate <= 0; \n  o_write_activate <= 0; \n  end \n  end \n  end \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a synchronous design that processes clock signals and control signals for a Hi-Read TX system. It monitors the incoming clock signals and data, and generates power control signals, clock signals, and debug signals based on the input conditions. The module also performs operations like shallow modulation detection and byte/frame generation based on the input signals and clock edges. Overall, it handles the timing and control aspects of the Hi-Read TX system.\n\n Module header:\n\nmodule hi_read_tx(pck0, ck_1356meg, ck_1356megb,pwr_lo, pwr_hi, pwr_oe1, pwr_oe2, pwr_oe3, pwr_oe4,adc_d, adc_clk,ssp_frame, ssp_din, ssp_dout, ssp_clk,cross_hi, cross_lo,dbg,shallow_modulation);\n [/INST]\n", "output": "input pck0, ck_1356meg, ck_1356megb; \n  output pwr_lo, pwr_hi, pwr_oe1, pwr_oe2, pwr_oe3, pwr_oe4; \n  input [7:0] adc_d; \n  output adc_clk; \n  input ssp_dout; \n  output ssp_frame, ssp_din, ssp_clk; \n  input cross_hi, cross_lo; \n  output dbg; \n  input shallow_modulation; \n assign pwr_lo = 1'b0; \n assign pwr_oe2 = 1'b0; \n reg pwr_hi; \n reg pwr_oe1; \n reg pwr_oe3; \n reg pwr_oe4; \n always @(ck_1356megb or ssp_dout or shallow_modulation) \n begin \n  if(shallow_modulation) \n  begin \n  pwr_hi <= ck_1356megb; \n  pwr_oe1 <= 1'b0; \n  pwr_oe3 <= 1'b0; \n  pwr_oe4 <= ~ssp_dout; \n  end \n  else \n  begin \n  pwr_hi <= ck_1356megb & ssp_dout; \n  pwr_oe1 <= 1'b0; \n  pwr_oe3 <= 1'b0; \n  pwr_oe4 <= 1'b0; \n  end \n end \n reg [6:0] hi_div_by_128; \n always @(posedge ck_1356meg) \n  hi_div_by_128 <= hi_div_by_128 + 1; \n assign ssp_clk = hi_div_by_128[6]; \n reg [2:0] hi_byte_div; \n always @(negedge ssp_clk) \n  hi_byte_div <= hi_byte_div + 1; \n assign ssp_frame = (hi_byte_div == 3'b000); \n assign ssp_din = 1'b0; \n assign dbg = ssp_frame; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module takes in a clock signal, process clock enable, and a 24-bit input, and outputs a 32-bit signal. The output is formed by concatenating four 8-bit segments of the input in reverse order.\n\n Module header:\n\nmodule addChan(input CLK, input process_CE, input [23:0] inp, output [31:0] process_output);\n [/INST]\n", "output": "parameter INSTANCE_NAME=\"INST\"; \n  assign process_output = {(8'd0),({inp[23:16]}),({inp[15:8]}),({inp[7:0]})}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module represents an ARINC429 transmitter and receiver system. The transmitter portion is responsible for generating TXD0 and TXD1 outputs based on the inputs nvel, adr, dat, GCLK, and st. The receiver portion consists of two AR_RXD modules, which take inputs from RXD0 and RXD1 and manage the storage and writing of received data. The module also contains logic to select the appropriate data and control signals from the receiver modules based on the rec_disp input, and drives the respective signals sr_dat, sr_adr, and ce_wr.\n\n Module header:\n\nmodule ARINC429(input wire [1 : 0] nvel,input wire [7 : 0] adr,input wire [22 : 0] dat,input wire GCLK,output wire TXD0,output wire TXD1,input wire RXD0,input wire RXD1,input wire st,output reg [7:0] sr_adr,output reg [22:0] sr_dat,output reg ce_wr,input wire rec_disp,input wire reset);\n [/INST]\n", "output": "AR_TXD TX \n (.clk(GCLK),.Nvel(nvel),.ADR(adr),.DAT(dat),.st(st),.TXD0(TXD0),.TXD1(TXD1),.reset(reset)); \n  wire [7:0] sr_adr_1; \n  wire [22:0] sr_dat_1; \n  wire ce_wr_1; \n  AR_RXD RX \n (.clk(GCLK),.in0(RXD0),.in1(RXD1),.sr_dat(sr_dat_1),.sr_adr(sr_adr_1),.ce_wr(ce_wr_1)); \n  wire [7:0] sr_adr_2; \n  wire [22:0] sr_dat_2; \n  wire ce_wr_2; \n  AR_RXD_2 RX_2 \n (.clk(GCLK),.in0(RXD0),.in1(RXD1),.sr_dat(sr_dat_2),.sr_adr(sr_adr_2),.ce_wr(ce_wr_2)); \n  always @(posedge GCLK) \n  begin \n  sr_dat <= rec_disp ? sr_dat_1 : sr_dat_2; \n  sr_adr <= rec_disp ? sr_adr_1 : sr_adr_2; \n  ce_wr <= rec_disp ? ce_wr_1 : ce_wr_2; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a fixed division by 2 circuit. The ceout output is the logical AND of the input cein and the complement of q. The q signal is toggled on each rising edge of the clock when the cein input is asserted.\n\n Module header:\n\nmodule fixeddivby2(input clk,input cein,output ceout);\n [/INST]\n", "output": "reg q; \n  initial q = 0; \n  assign ceout = cein & q; \n  always @(posedge clk) begin \n  if(cein) \n  q = ~q; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a FIFO (First-In-First-Out) memory buffer with a configurable width and depth. It has input and output ports for data, control signals for read and write operations, and status indicators for full and empty conditions. The module uses separate pointers to track the read and write positions in the FIFO, and it includes logic to handle asynchronous reset, flush, and guard conditions to ensure proper FIFO operation. The FIFO is updated on the positive edge of the clock signal, and the data is read from the FIFO based on the read pointer. The module also detects full and empty conditions based on the status of the write and read pointers and the guard signal.\n\n Module header:\n\nmodule adxl362_fifo (data_read, full, empty,data_write, clk, rst, flush, read, write);\n [/INST]\n", "output": "parameter WIDTH = 16; \n  parameter DEPTH = 512; \n  parameter INDEX_WIDTH = $clog2(DEPTH); \n  output wire [WIDTH-1:0] data_read; \n  output wire full; \n  output wire empty; \n  input wire [WIDTH-1:0] data_write; \n  input wire clk; \n  input wire rst; \n  input wire flush; \n  input wire read; \n  input wire write; \n  reg [WIDTH-1:0] fifo [0:DEPTH-1]; \n  reg [INDEX_WIDTH-1:0] read_ptr; \n  wire [INDEX_WIDTH-1:0] read_ptr1; \n  reg [INDEX_WIDTH-1:0] write_ptr; \n  wire [INDEX_WIDTH-1:0] write_ptr1; \n  reg guard; \n  always @(posedge clk) \n  if (rst) begin \n  write_ptr <= 0; \n  end else if (flush) begin \n  write_ptr <= 0; \n  end else if (write) begin \n  write_ptr <= write_ptr1; \n  end \n  assign write_ptr1 = write_ptr + 1; \n  always @(posedge write) \n  if (write) begin \n  fifo[write_ptr] <= data_write; \n  end \n  always @(posedge clk) \n  if (rst) begin \n  read_ptr <= 0; \n  end else if (flush) begin \n  read_ptr <= 0; \n  end else if (read) begin \n  read_ptr <= read_ptr1; \n  end \n  assign read_ptr1 = read_ptr + 1; \n  assign data_read = fifo[read_ptr]; \n  always @(posedge clk) \n  if (rst) begin \n  guard <= 0; \n  end else if (flush) begin \n  guard <= 0; \n  end else if ((write_ptr1 == read_ptr) && write) begin \n  guard <= 1; \n  end else if (read) begin \n  guard <= 0; \n  end \n  assign empty = (write_ptr == read_ptr) & !guard; \n  assign full = (write_ptr == read_ptr) & guard; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a simple buffer, where the input signal is directly connected to the output signal. It effectively passes the input signal through to the output without any modification.\n\n Module header:\n\nmodule GP_IBUF(input IN, output OUT);\n [/INST]\n", "output": "assign OUT = IN; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a testbench for a radar top module. It initializes input signals and simulates the radar operation. It emulates the clock signal and the reset signal, loads an input vector from a file, and processes the data. It uses the clock and serial clock signals to control the data flow, and outputs the processed data to a file. The module also displays progress messages during the simulation.\n\n Module header:\n\nmodule tb_radar_top();\n [/INST]\n", "output": "reg [11:0] adc_in; \n  reg [15:0] counter; \n  reg clk, reset_n; \n  reg [11:0] input_vector [0:16383]; \n  wire fft_next_out, next_data, data, serial_clk; \n  wire [11:0] mag_out1, mag_out2; \n  integer file, j, m; \n  initial clk = 0; \n  always #25 clk = ~clk; \n Radar_top radar_inst(.clk(clk), .reset_n(reset_n),.mag_out1(mag_out1), .mag_out2(mag_out2),.fft_next_out(fft_next_out),.adc_in(adc_in),.next_data(next_data), .data(data), .clk_div_16(serial_clk)); \n  initial counter = 0; \n  always @(posedge serial_clk) begin \n  counter <= counter+1; \n  if(counter % 1000 == 0) \n  $display(\"Counter = %d.\", counter/2); \n  end \n  initial begin \n  adc_in <= 0; \n  reset_n <= 1; \n  @(posedge clk); \n  $readmemb(\"FFT_Input_54k_96k.txt\", input_vector); \n  for (j=0; j < 16384; j = j+1) begin \n  adc_in <= input_vector[j]; \n  @(posedge clk); \n  @(posedge clk); \n  end \n  $display(\"Done input vector, counter = %d\", counter); \n  end \n  initial begin \n  @(posedge serial_clk); \n  @(posedge serial_clk); \n  @(posedge serial_clk); \n  @(posedge next_data); \n  @(posedge serial_clk); \n  @(posedge serial_clk); \n  @(posedge serial_clk); #100; \n  $display(\"--- begin output ---\"); \n  file = $fopen(\"Serial_output_final.txt\") ; \n  for(m = 0; m < 2048 * 12; m = m + 1) begin \n  if(m % 12 == 0) begin \n  $fwrite(file, \"\\n\"); \n  end \n  $fwrite(file, \"%b\", data); \n  @(posedge serial_clk); \n  @(posedge serial_clk);#100; \n  end \n  $fdisplay(file, \"%b\", data); \n  $fclose(file); \n  $display(\"--- done output ---\"); \n  $finish; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a clock signal generator, which uses a phase-locked loop to generate a stable clock signal from an input clock. It includes logic for handling the reset signal and the clock output. The clock signal generator module is instantiated within this module and configured with specific settings such as frequency and phase. The module contains various internal signals and buffers for managing the clock signal generation process.\n\n Module header:\n\nmodule clk_gen_clk_wiz (input clk_in1,output clk_out1,input reset);\n [/INST]\n", "output": "IBUF clkin1_ibufg \n (.O (clk_in1_clk_gen),.I (clk_in1)); \n  wire [15:0] do_unused; \n  wire drdy_unused; \n  wire psdone_unused; \n  wire locked_int; \n  wire clkfbout_clk_gen; \n  wire clkfbout_buf_clk_gen; \n  wire clkfboutb_unused; \n  wire clkout0b_unused; \n  wire clkout1_unused; \n  wire clkout1b_unused; \n  wire clkout2_unused; \n  wire clkout2b_unused; \n  wire clkout3_unused; \n  wire clkout3b_unused; \n  wire clkout4_unused; \n  wire clkout5_unused; \n  wire clkout6_unused; \n  wire clkfbstopped_unused; \n  wire clkinstopped_unused; \n  wire reset_high; \n  MMCME2_ADV \n #(.BANDWIDTH (\"OPTIMIZED\"),.CLKOUT4_CASCADE (\"FALSE\"),.COMPENSATION (\"ZHOLD\"),.STARTUP_WAIT (\"FALSE\"),.DIVCLK_DIVIDE (1),.CLKFBOUT_MULT_F (4.000),.CLKFBOUT_PHASE (0.000),.CLKFBOUT_USE_FINE_PS (\"FALSE\"),.CLKOUT0_DIVIDE_F (20.000),.CLKOUT0_PHASE (0.000),.CLKOUT0_DUTY_CYCLE (0.500),.CLKOUT0_USE_FINE_PS (\"FALSE\"),.CLKIN1_PERIOD (4.0)) \n  mmcm_adv_inst \n (.CLKFBOUT (clkfbout_clk_gen),.CLKFBOUTB (clkfboutb_unused),.CLKOUT0 (clk_out1_clk_gen),.CLKOUT0B (clkout0b_unused),.CLKOUT1 (clkout1_unused),.CLKOUT1B (clkout1b_unused),.CLKOUT2 (clkout2_unused),.CLKOUT2B (clkout2b_unused),.CLKOUT3 (clkout3_unused),.CLKOUT3B (clkout3b_unused),.CLKOUT4 (clkout4_unused),.CLKOUT5 (clkout5_unused),.CLKOUT6 (clkout6_unused),.CLKFBIN (clkfbout_buf_clk_gen),.CLKIN1 (clk_in1_clk_gen),.CLKIN2 (1'b0),.CLKINSEL (1'b1),.DADDR (7'h0),.DCLK (1'b0),.DEN (1'b0),.DI (16'h0),.DO (do_unused),.DRDY (drdy_unused),.DWE (1'b0),.PSCLK (1'b0),.PSEN (1'b0),.PSINCDEC (1'b0),.PSDONE (psdone_unused),.LOCKED (locked_int),.CLKINSTOPPED (clkinstopped_unused),.CLKFBSTOPPED (clkfbstopped_unused),.PWRDWN (1'b0),.RST (reset_high)); \n  assign reset_high = reset; \n  BUFG clkf_buf \n (.O (clkfbout_buf_clk_gen),.I (clkfbout_clk_gen)); \n  BUFG clkout1_buf \n (.O (clk_out1),.I (clk_out1_clk_gen)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, PosEdgeDelay, is designed to detect a positive edge on the input signal, sigIn, and delay the positive edge by a specified wait count before toggling the output signal, sigOut. The module uses a clock signal, clk, and a sharedBit as input, and the waitCnt parameter specifies the delay count. Inside the module, it uses registers to track the positive edge detection and to delay the output signal. It also includes initial and always blocks to handle the logic for edge detection and signal delay. The output signal, sigOut, is assigned based on the value of the internal signal sigOutReg.\n\n Module header:\n\nmodule PosEdgeDelay(clk, sigIn, waitCnt, sharedBit, sigOut);\n [/INST]\n", "output": "parameter WAIT_CNT_SIZE=11; \n input clk, sigIn; \n input [WAIT_CNT_SIZE-1:0] waitCnt; \n input sharedBit; \n output sigOut; \n reg sigInPosEdge, sigInPosEdgeLast; \n reg [WAIT_CNT_SIZE-1:0] posEdgeDelayTimer; \n reg sigOutReg; \n initial begin \n  #0 \n  sigOutReg=1'b0; \n  posEdgeDelayTimer=1'b0; \n  sigInPosEdge=1'b0; \n  sigInPosEdgeLast=1'b0; \n end \n always @(posedge sigIn) begin \n  sigInPosEdge=~sigInPosEdge; \n end \n always @(posedge clk) begin \n  if(sigInPosEdgeLast != sigInPosEdge) begin \n  posEdgeDelayTimer=1'b0; \n  sigInPosEdgeLast = sigInPosEdge; \n  end \n  if(posEdgeDelayTimer<waitCnt) begin \n  posEdgeDelayTimer=posEdgeDelayTimer+1'b1; \n  end else if(posEdgeDelayTimer==waitCnt) begin \n  posEdgeDelayTimer=posEdgeDelayTimer+1'b1; \n  sigOutReg=~sharedBit; \n  $display(\"time=%d,waitCnt=%d, sigOutReg=%b\",$time,waitCnt, sigOutReg); \n  end \n end \n assign sigOut=sigOutReg; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a 4-to-1 multiplexer, which selects one of four input data signals based on the 2-bit selection input Sel, and outputs the selected data. The module implements the multiplexer logic using conditional assignments based on the selection inputs.\n\n Module header:\n\nmodule Mux4_1(input [31:0] Data0,Data1,Data2,Data3,input [1:0] Sel,output [31:0]Data);\n [/INST]\n", "output": "assign Data = (Sel[1] == 1'b0)?((Sel[0] == 1'b0)?(Data0):(Data1)):((Sel[0] == 1'b0)?(Data2):(Data3)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module `etx_remap` is designed to handle remapping of addresses for EMESH packet transmission. It has input signals for clock, reset, EMESH access, packet data, and various control signals for remapping. The module also has output signals for EMESH access grant and remapped packet data. \n\nThe module contains internal logic for address remapping based on the input signals and then transmits the EMESH packet data and access grants based on the remapping and other control signals. The module utilizes synchronous logic to handle the transmission of the EMESH packet data and access grants based on the write enable signals and wait conditions.\n\nOverall, the module provides functionality to remap addresses and control EMESH packet transmission based on the input signals and control parameters, allowing for flexible handling of EMESH communication.\n\n Module header:\n\nmodule etx_remap (emesh_access_out, emesh_packet_out,clk, reset, emesh_access_in, emesh_packet_in, remap_en,remap_bypass, etx_rd_wait, etx_wr_wait);\n [/INST]\n", "output": "parameter AW = 32; \n  parameter DW = 32; \n  parameter PW = 104; \n  parameter ID = 12'h808; \n  input clk; \n  input reset; \n  input emesh_access_in; \n  input [PW-1:0] emesh_packet_in; \n  input remap_en; \n  input remap_bypass; \n  output emesh_access_out; \n  output [PW-1:0] emesh_packet_out; \n  input etx_rd_wait; \n  input etx_wr_wait; \n  wire [31:0] addr_in; \n  wire [31:0] addr_remap; \n  wire [31:0] addr_out; \n  wire write_in; \n  reg emesh_access_out; \n  reg [PW-1:0] emesh_packet_out; \n  assign addr_in[31:0] = emesh_packet_in[39:8]; \n  assign write_in = emesh_packet_in[1]; \n  assign addr_remap[31:0] = {addr_in[29:18], \n  addr_in[17:16], \n  {(2){(|addr_in[17:16])}}, \n  addr_in[15:0] \n  }; \n  assign addr_out[31:0] = (remap_en & ~remap_bypass) ? addr_remap[31:0] : \n  addr_in[31:0]; \n  always @ (posedge clk) \n  if((write_in & ~etx_wr_wait) | (~write_in & ~etx_rd_wait)) \n  begin \n  emesh_access_out <= emesh_access_in; \n  emesh_packet_out[PW-1:0] <= {emesh_packet_in[PW-1:40], \n  addr_out[31:0], \n  emesh_packet_in[7:0] \n  }; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a clock gate with an enable signal. It gates the clock input, CLK, using the EN signal to produce the output ENCLK. It uses a latch to store the enable signal and an AND gate to control the clock signal, ensuring that the clock is only enabled when the EN signal is asserted.\n\n Module header:\n\nmodule SNPS_CLOCK_GATE_HIGH_ff32_en_IR ( CLK, EN, ENCLK );\n [/INST]\n", "output": "input CLK, EN; \n  output ENCLK; \n  wire net3579, net3581, net3582, net3585; \n  assign net3579 = CLK; \n  assign ENCLK = net3581; \n  assign net3582 = EN; \n  DLL_X1 latch ( .D(net3582), .GN(net3579), .Q(net3585) ); \n  AND2_X1 main_gate ( .A1(net3585), .A2(net3579), .ZN(net3581) ); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module simply assigns a constant value of 1 to the output q.\n\n Module header:\n\nmodule vfebcfe_vb2eccd (output q);\n [/INST]\n", "output": "assign q = 1'b1; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a descrambler that takes in a data input and synchronizes information and outputs the descrambled data. The descrambling process is triggered by a clock signal and controlled by an enable signal. The descrambler uses a polynomial to perform the descrambling process by XORing the input data with the polynomial value. The module includes logic for reset, clock signal handling, and enable logic. It updates the descrambler value and the unscrambled data based on the input and control signals. The descrambler also handles default values and reset logic for the descrambler and unscrambled data.\n\n Module header:\n\nmodule descrambler # (parameter RX_DATA_WIDTH = 64) (data_in,data_out,enable,sync_info,clk,rst);\n [/INST]\n", "output": "input [0:(RX_DATA_WIDTH+1)] data_in; \n  input enable; \n  output [(RX_DATA_WIDTH-1):0] data_out; \n  output [1:0] sync_info; \n  input clk; \n  input rst; \n  reg [57:0] descrambler; \n  integer i; \n  reg [((RX_DATA_WIDTH*2)-7):0] poly; \n  reg [0:(RX_DATA_WIDTH-1)] tempData; \n  reg [(RX_DATA_WIDTH-1):0] unscrambled_data_i; \n  reg xorBit; \n  wire [0:63] data_scram; \n  assign data_scram = data_in[2:65]; \n  assign sync_info = data_in[0:1]; \n  always @(descrambler,data_scram) \n  begin \n  poly = descrambler; \n  for (i=0;i<=(RX_DATA_WIDTH-1);i=i+1) \n  begin \n  xorBit = data_scram[i] ^ poly[38] ^ poly[57]; \n  poly = {poly[((RX_DATA_WIDTH*2)-8):0],data_scram[i]}; \n  tempData[i] = xorBit; \n  end \n  end \n  always @(posedge clk) \n  begin \n  if (rst) begin \n  unscrambled_data_i <= 'h0; \n  descrambler <= 122'hFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF; \n  end \n  else if (enable) begin \n  unscrambled_data_i <= tempData; \n  descrambler <= poly; \n  end \n  end \n  assign data_out = unscrambled_data_i; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis module instantiates a 6-stage shift register and connects its inputs and outputs to the io_in and io_out ports. The shift register is clocked and reset by the clock and reset signals, with the input data flowing through the shift register when sr_flow is asserted.\n\n Module header:\n\nmodule RetimeWrapper_31(input clock,input reset,input [31:0] io_in,output [31:0] io_out);\n [/INST]\n", "output": "wire [31:0] sr_out; \n  wire [31:0] sr_in; \n  wire sr_flow; \n  wire sr_reset; \n  wire sr_clock; \n RetimeShiftRegister #(.WIDTH(32), .STAGES(6)) sr (.out(sr_out),.in(sr_in),.flow(sr_flow),.reset(sr_reset),.clock(sr_clock)); \n  assign io_out = sr_out; \n  assign sr_in = io_in; \n  assign sr_flow = 1'h1; \n  assign sr_reset = reset; \n  assign sr_clock = clock; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements error status handling for a memory controller. It detects data errors and sets the error flag accordingly. The error status register is updated based on various input signals, and the error flag is set when a data error is detected. The error flag is then output as the 'error' signal. The module also includes a manual clear error input to reset the error status. The error_status register is updated with relevant information when a data error is detected.\n\n Module header:\n\nmodule mig_7series_v2_3_tg_status #(parameter TCQ = 100,parameter DWIDTH = 32) (input clk_i ,input rst_i ,input manual_clear_error,input data_error_i ,input [DWIDTH-1:0] cmp_data_i,input [DWIDTH-1:0] rd_data_i ,input [31:0] cmp_addr_i ,input [5:0] cmp_bl_i ,input mcb_cmd_full_i ,input mcb_wr_full_i,input mcb_rd_empty_i,output reg [64 + (2*DWIDTH - 1):0] error_status,output error);\n [/INST]\n", "output": "reg data_error_r; \n reg error_set; \n assign error = error_set; \n always @ (posedge clk_i) \n  data_error_r <= #TCQ data_error_i; \n always @ (posedge clk_i) \n begin \n if (rst_i || manual_clear_error) begin \n  error_status <= #TCQ 'b0; \n  error_set <= #TCQ 1'b0; \n end \n else begin \n  if (data_error_i && ~data_error_r && ~error_set ) begin \n  error_status[31:0] <= #TCQ cmp_addr_i; \n  error_status[37:32] <= #TCQ cmp_bl_i; \n  error_status[40] <= #TCQ mcb_cmd_full_i; \n  error_status[41] <= #TCQ mcb_wr_full_i; \n  error_status[42] <= #TCQ mcb_rd_empty_i; \n  error_set <= #TCQ 1'b1; \n  error_status[64 + (DWIDTH - 1) :64] <= #TCQ cmp_data_i; \n  error_status[64 + (2*DWIDTH - 1):64 + DWIDTH] <= #TCQ rd_data_i; \n  end \n  error_status[39:38] <= #TCQ 'b0; \n  error_status[63:43] <= #TCQ 'b0; \n end end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module serves as an interface between an AVR microcontroller and an external circuit. It defines an output active called \"conn\" and utilizes a parameter \"name\" to specify the pin name. The module includes an always block that triggers on the positive edge of the core.clk signal, reading the value from the AVR microcontroller using the $avr_get_pin function, and then setting the pin value to the result of the function v2a(conn) using the $avr_set_pin function. Additionally, the module includes functions a2v and v2a to convert between different pin value representations, and an assign statement to drive the 'out' wire based on the value obtained from a2v(val).\n\n Module header:\n\nmodule avr_pin(conn);\n [/INST]\n", "output": "parameter name=\"UNSPECIFIED\"; \n  inout conn; \n  wire out; \n  integer val; \n  wire output_active; \n  assign output_active = (val<=2); \n  assign conn = output_active ? out : 1'bz; \n  function a2v; \n  input apin; \n  if (apin==0) \n  a2v=0; \n  else if (apin==1) \n  a2v=1; \n  else if (apin==2) \n  a2v=1'bx; \n  else if (apin==3) \n  a2v=1; \n  else if (apin==4) \n  a2v=1'bz; \n  else if (apin==5) \n  a2v=0; \n  else if (apin==6) \n  a2v=1'bx; \n  else if (apin==7) \n  a2v=1'bx; \n  endfunction \n  function v2a; \n  input vpin; \n  if (vpin==1'bz) \n  v2a=4; \n  else if (vpin==1'bx) \n  v2a=2; \n  else if (vpin==1) \n  v2a=1; \n  else if (vpin==0) \n  v2a=0; \n  endfunction \n  assign out=a2v(val); \n  always @(posedge core.clk) begin \n  val<=$avr_get_pin(core.handle, name); \n  $avr_set_pin(core.handle, name, v2a(conn)); \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a delay circuit that waits for 35 microseconds before setting the output signal p. It uses a register r to count the number of clock cycles, and when it reaches 1750, the output signal p is set. The register r is reset when the reset signal is asserted, and it increments by 1 on each clock cycle unless the input signal in is high, in which case it resets to 1.\n\n Module header:\n\nmodule dly35us(input clk, input reset, input in, output p);\n [/INST]\n", "output": "reg [11-1:0] r; \n  always @(posedge clk or posedge reset) begin \n  if(reset) \n  r <= 0; \n  else begin \n  if(r) \n  r <= r + 11'b1; \n  if(in) \n  r <= 1; \n  end \n  end \n  assign p = r == 1750; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThe Verilog module \"address\" is used for address assignment and decoding in a system. It takes in a clock signal, 24-bit input SNES_ADDR, and various control signals, and provides different output addresses for different memory and peripheral devices. The module internally calculates various enable signals for different memory and peripheral devices based on the input address and control signals. It uses registers to store the enable signals and updates them on each clock cycle.\n\nThe module assigns different addresses for RAM0, RAM1, peripheral access (PA), and block RAM (BRAM) based on the input SNES_ADDR. It also generates enable signals for different memory banks, interrupts (IRQ), and linear addressing.\n\nThe input SNES_ADDR is decoded to generate RAM0, RAM1, PA, and BRAM addresses, and the corresponding enable signals are generated based on the input address and control signals.\n\nThe module uses sequential logic to update the enable signals on each clock cycle and then assigns these updated signals to the corresponding outputs.\n\n Module header:\n\nmodule address(input CLK,input [23:0] SNES_ADDR,output [23:0] ram0_addr,output [18:0] ram1_addr,output [7:0] PA_addr,output [12:0] bram_addr,input [7:0] ram0_bank,input ram0_linear,output ram0_enable,output ram1_enable,output PA_enable,output bram_enable,output irq_enable,output bank_enable,output linear_enable);\n [/INST]\n", "output": "wire [23:0] SRAM_SNES_ADDR; \n assign ram0bank0_enable = (SNES_ADDR[23:15] == 9'h001) | (SNES_ADDR[23:16] == 8'hC0); \n assign ram0bankx_enable = (SNES_ADDR[23:16] == 8'hC8); \n assign ram0linear_enable = ram0_linear & (SNES_ADDR[22] | SNES_ADDR[15]); \n assign ram0_enable = ram0linear_enable | ram0bank0_enable | ram0bankx_enable; \n assign ram1_enable = ~ram0_enable & (SNES_ADDR[23:20] == 4'hD); \n assign PA_enable = ~ram0_enable & (SNES_ADDR[23:20] == 4'hE); \n assign bram_enable = ~ram0_enable & (SNES_ADDR[23:20] == 4'hF); \n wire bank_enable_ = (SNES_ADDR == 24'h0055AA); \n wire irq_enable_ = (SNES_ADDR == 24'h002222); \n wire linear_enable_ = (SNES_ADDR == 24'h003333); \n reg [2:0] bank_enable_r; \n reg [2:0] irq_enable_r; \n reg [2:0] linear_enable_r; \n always @(posedge CLK) begin \n  bank_enable_r <= {bank_enable_r[1:0], bank_enable_}; \n  irq_enable_r <= {irq_enable_r[1:0], irq_enable_}; \n  linear_enable_r <= {linear_enable_r[1:0], linear_enable_}; \n end \n assign bank_enable = bank_enable_r[2]; \n assign irq_enable = irq_enable_r[2]; \n assign linear_enable = linear_enable_r[2]; \n assign ram0_addr = ram0_linear ? SNES_ADDR \n  : {2'b00,SNES_ADDR[21:0]}; \n assign ram1_addr = SNES_ADDR[18:0]; \n assign PA_addr = SNES_ADDR[7:0]; \n assign bram_addr = SNES_ADDR[12:0]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a mapper that maps different address signals based on various conditions. It has inputs such as clock signal, chip enable, reset, flags, and address signals. The outputs are the mapped address signals and control signals for a memory or other devices. The module contains sequential and combinational logic to control the mapping based on the conditions of the input signals. It utilizes flip-flops to store the state information and uses conditional assignments to calculate the mapped address and control signals.\n\n Module header:\n\nmodule Mapper234(input clk, input ce, input reset,input [31:0] flags,input [15:0] prg_ain, output [21:0] prg_aout,input prg_read, prg_write,input [7:0] prg_din,output prg_allow,input [13:0] chr_ain, output [21:0] chr_aout,output chr_allow,output vram_a10,output vram_ce);\n [/INST]\n", "output": "reg [2:0] block, inner_chr; \n  reg mode, mirroring, inner_prg; \n  always @(posedge clk) if (reset) begin \n  block <= 0; \n  {mode, mirroring} <= 0; \n  inner_chr <= 0; \n  inner_prg <= 0; \n  end else if (ce) begin \n  if (prg_read && prg_ain[15:7] == 9'b1111_1111_1) begin \n  if (prg_ain[6:0] < 7'h20 && (block == 0)) begin \n  {mirroring, mode} <= prg_din[7:6]; \n  block <= prg_din[3:1]; \n  {inner_chr[2], inner_prg} <= {prg_din[0], prg_din[0]}; \n  end \n  if (prg_ain[6:0] >= 7'h68 && prg_ain[6:0] < 7'h78) begin \n  {inner_chr[2], inner_prg} <= mode ? {prg_din[6], prg_din[0]} : {inner_chr[2], inner_prg}; \n  inner_chr[1:0] <= prg_din[5:4]; \n  end \n  end \n  end \n  assign vram_a10 = mirroring ? chr_ain[11] : chr_ain[10]; \n  assign prg_aout = {3'b00_0, block, inner_prg, prg_ain[14:0]}; \n  assign chr_aout = {3'b10_0, block, inner_chr, chr_ain[12:0]}; \n  assign prg_allow = prg_ain[15] && !prg_write; \n  assign chr_allow = flags[15]; \n  assign vram_ce = chr_ain[13]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a memory bus interface with read and write functionality. It includes control logic to manage read and write requests, waiting for acknowledgement, and handling data transfers between the memory bus and the module. The module also features address decoding and signal generation for various control and data paths. The inputs and outputs are used to control the behavior of the memory bus interface, such as clock, reset, address, write and read signals, and data to be written or read.\n\n Module header:\n\nmodule membusif(input wire clk,input wire reset,input wire [1:0] s_address,input wire s_write,input wire s_read,input wire [31:0] s_writedata,output reg [31:0] s_readdata,output wire s_waitrequest,output reg m_rq_cyc,output reg m_rd_rq,output reg m_wr_rq,output wire [21:35] m_ma,output wire [18:21] m_sel,output reg m_fmc_select,output wire [0:35] m_mb_write,output wire m_wr_rs,input wire [0:35] m_mb_read,input wire m_addr_ack,input wire m_rd_rs);\n [/INST]\n", "output": "reg [0:17] addr; \n  reg [0:35] word; \n  assign m_ma = addr[3:17]; \n  assign m_sel = addr[0:3]; \n  wire write_edge, read_edge; \n  edgedet e0(clk, reset, s_write, write_edge); \n  edgedet e1(clk, reset, s_read, read_edge); \n  reg waiting; \n  wire req = (write_edge|read_edge) & s_address == 2'h2; \n  assign s_waitrequest = req | waiting | (|waitcyc); \n  wire mb_write_pulse; \n  wire wr_rs = m_addr_ack & m_wr_rq; \n  bd mc_bd0(clk, ~reset, wr_rs, m_wr_rs); \n  bd2 mb_bd1(clk, ~reset, wr_rs, mb_write_pulse); \n  assign m_mb_write = mb_write_pulse ? word : 0; \n  reg [7:0] waitcyc; \n  always @(posedge clk or negedge reset) begin \n  if(~reset) begin \n  m_rq_cyc <= 0; \n  m_rd_rq <= 0; \n  m_wr_rq <= 0; \n  waiting <= 0; \n  addr <= 0; \n  m_fmc_select <= 0; \n  word <= 0; \n  waitcyc <= 0; \n  end else begin \n  if(write_edge) begin \n  case(s_address) \n  2'h0: begin \n  addr <= s_writedata[17:0]; \n  m_fmc_select <= s_writedata[18]; \n  end \n  2'h1: word[18:35] <= s_writedata[17:0]; \n  2'h2: word[0:17] <= s_writedata[17:0]; \n  endcase \n  end \n  if(req) begin \n  waiting <= 1; \n  m_rq_cyc <= 1; \n  if(s_write) \n  m_wr_rq <= 1; \n  else if(s_read) begin \n  m_rd_rq <= 1; \n  word <= 0; \n  end \n  end \n  if(waitcyc) begin \n  if(waitcyc == 'o14) \n  waitcyc <= 0; \n  else \n  waitcyc <= waitcyc + 1; \n  end \n  if(waiting & m_rd_rq) \n  word <= m_mb_read; \n  if(m_addr_ack) begin \n  m_rq_cyc <= 0; \n  waitcyc <= 1; \n  end \n  if(m_rd_rs) begin \n  m_rd_rq <= 0; \n  waiting <= 0; \n  end \n  if(m_wr_rs) begin \n  m_wr_rq <= 0; \n  waiting <= 0; \n  end \n  end \n  end \n  always @(*) begin \n  case(s_address) \n  2'h1: s_readdata <= { 14'b0, word[18:35] }; \n  2'h2: s_readdata <= { 14'b0, word[0:17] }; \n  default: s_readdata <= 32'b0; \n  endcase \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a SHA-256 round function using DSP48E1 blocks. It takes a 512-bit input rx_data and computes s0 and s1 values based on specific bit indices. It then performs a 16-bit addition and compression using compressor4_2 and dsp48e1_adder blocks. The module also contains registers to store intermediate values and assigns the output tx_data based on the computed data. The computations are triggered on the positive edge of the clock signal.\n\n Module header:\n\nmodule sha256_dsp48e1_wround (input clk,input [511:0] rx_data,output [511:0] tx_data);\n [/INST]\n", "output": "reg [479:0] data0, data1, data2; \n  wire [31:0] s0 = `S0(rx_data[`IDX(1)]); \n  wire [31:0] s1 = `S1(rx_data[`IDX(14)]); \n  wire [31:0] sum, carry, w16; \n compressor4_2 compress (.rx_a (s0),.rx_b (s1),.rx_c (rx_data[`IDX(0)]),.rx_d (rx_data[`IDX(9)]),.tx_sum (sum),.tx_carry (carry)); \n dsp48e1_adder dsp_w16 (.clk (clk),.rx_ab (sum),.rx_c ({carry[30:0], 1'b0}),.rx_pcin (),.tx_p (tx_data[`IDX(15)]),.tx_pcout ()); \n  always @ (posedge clk) \n  begin \n  data0 <= rx_data[511:32]; \n  data1 <= data0; \n  end \n  assign tx_data[479:0] = data1; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, premuat1_4, has four input signals and four output signals, each with 19-bit width. It simply reassigns the input signals to the output signals in a different order: i_0 to o_0, i_2 to o_1, i_1 to o_2, and i_3 to o_3.\n\n Module header:\n\nmodule premuat1_4(i_0,i_1,i_2,i_3,o_0,o_1,o_2,o_3);\n [/INST]\n", "output": "input signed [18:0] i_0; \n input signed [18:0] i_1; \n input signed [18:0] i_2; \n input signed [18:0] i_3; \n output signed [18:0] o_0; \n output signed [18:0] o_1; \n output signed [18:0] o_2; \n output signed [18:0] o_3; \n assign o_0=i_0; \n assign o_1=i_2; \n assign o_2=i_1; \n assign o_3=i_3; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a timing controller with inputs CLK, BPM, MODE, NOTE, START, and outputs EN, DONE. It uses a duration look-up table and a BPM prescaler to generate a timing signal, and a counter to control the timing of the EN signal based on the selected MODE. The DONE signal is asserted when the counter reaches the specified DURATION.\n\n Module header:\n\nmodule timing_controller (CLK, BPM, MODE, NOTE, START, EN, DONE);\n [/INST]\n", "output": "input CLK; \n  input [1:0] MODE; \n  input [3:0] NOTE; \n  input START; \n  input [7:0] BPM; \n  output reg EN; \n  wire [15:0] DURATION; \n  output reg DONE; \n  reg [15:0] counter; \n  parameter \n  NORMAL = 2'b00, \n  STACCATO = 2'b01, \n  SLURRED = 2'b10, \n  BPM_COMM = 2'b11; \n  duration_lut dur_lut_blk (NOTE[3:0], DURATION); \n  BPM_prescaler bpm_pre_blk (CLK, BPM, slowCLK); \n  initial begin \n  EN <= 1; \n  counter <= 0; \n  DONE <= 0; \n  end \n  always @ (posedge slowCLK) begin \n  if (START) begin \n  DONE <= 0; \n  counter <= counter + 1; \n  case (MODE) \n  NORMAL : begin if (counter <= DURATION/128*125) EN <= 1; else EN <= 0; end \n  STACCATO: begin if (counter <= DURATION/128*102) EN <= 1; else EN <= 0; end \n  SLURRED : begin if (counter <= DURATION) EN <= 1; end \n  endcase \n  if (counter == DURATION) begin \n  counter <= 0; \n  DONE <= 1; \n  end \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a clock divider and data receiver. It receives data through s_axis_tdata and s_axis_tvalid inputs and controls a digital-to-analog converter (DAC) by providing clock signals and serial data input. The clock divider divides the input clock signal to generate a slower clock for the DAC. The module also handles data reception and loading the received data into the DAC.\n\n Module header:\n\nmodule ad7390 # (parameter integer CLK_DIV = 250,parameter integer DAC_WIDTH = 12,parameter integer AXI_WIDTH = 16) (input wire aclk,input wire aresetn,output reg s_axis_tready,input wire [AXI_WIDTH-1:0] s_axis_tdata,input wire s_axis_tvalid,output reg dac_clk,output reg dac_sdi,output reg dac_ld,output reg dac_clr);\n [/INST]\n", "output": "reg [15:0] int_clk_div; \n reg int_clk; \n reg [DAC_WIDTH-1:0] data_reg; \n reg data_rx; \n reg [3:0] data_rx_bit; \n always @(posedge aclk) begin \n  if (~aresetn) begin \n  int_clk <= 1'b0; \n  int_clk_div <= 16'b0; \n  s_axis_tready <= 1'b0; \n  dac_clk <= 1'b0; \n  dac_sdi <= 1'b0; \n  dac_clr <= 1'b1; \n  dac_ld <= 1'b1; \n  data_rx <= 1'b0; \n  end else begin \n  if (~data_rx) begin \n  if (~s_axis_tready) begin \n  s_axis_tready <= 1'b1; \n  end else if (s_axis_tvalid) begin \n  s_axis_tready <= 1'b0; \n  data_reg <= s_axis_tdata[AXI_WIDTH-2:AXI_WIDTH-DAC_WIDTH-1]; \n  dac_sdi <= s_axis_tdata[AXI_WIDTH-1]; \n  data_rx <= 1'b1; \n  data_rx_bit <= DAC_WIDTH - 1; \n  dac_ld <= 1'b1; \n  int_clk_div <= 1'b0; \n  int_clk <= 1'b0; \n  end \n  end \n  if (int_clk_div == CLK_DIV && dac_clk == 1) begin \n  if (data_rx) begin \n  if (data_rx_bit > 0) begin \n  data_rx_bit <= data_rx_bit - 1; \n  {dac_sdi, data_reg} <= {data_reg, 1'b0}; \n  end else begin \n  dac_ld <= 1'b0; \n  dac_sdi <= 1'b0; \n  end \n  end \n  end \n  if (int_clk_div == CLK_DIV) begin \n  int_clk_div <= 0; \n  int_clk <= ~int_clk; \n  if (data_rx && dac_ld) begin \n  dac_clk <= int_clk; \n  end else if (~dac_ld) begin \n  dac_ld <= 1'b1; \n  data_rx <= 1'b0; \n  end \n  end else begin \n  int_clk_div <= int_clk_div + 1; \n  end \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a trigger synchronization block that synchronizes the trigger input to the sync_clock. If the input_clock and sync_clock are the same, it directly assigns trigger_out to trigger_in. Otherwise, it uses registers and logic to synchronize the trigger input and generates the trigger output. The module also incorporates reset logic to handle reset signals for proper synchronization.\n\n Module header:\n\nmodule alt_vipitc131_common_trigger_sync(input wire input_rst,input wire input_clock,input wire rst,input wire sync_clock,input wire trigger_in,input wire ack_in,output wire trigger_out);\n [/INST]\n", "output": "parameter CLOCKS_ARE_SAME = 0; \n generate \n  if(CLOCKS_ARE_SAME) \n  assign trigger_out = trigger_in; \n  else begin \n  reg trigger_in_reg; \n  reg toggle; \n  reg toggle_synched_reg; \n  wire toggle_synched; \n  always @ (posedge input_rst or posedge input_clock) begin \n  if(input_rst) begin \n  trigger_in_reg <= 1'b0; \n  toggle <= 1'b0; \n  end else begin \n  trigger_in_reg <= trigger_in; \n  toggle <= toggle ^ (trigger_in & (~trigger_in_reg | ack_in)); \n  end \n  end \n alt_vipitc131_common_sync #(CLOCKS_ARE_SAME) toggle_sync(.rst(rst),.sync_clock(sync_clock),.data_in(toggle),.data_out(toggle_synched)); \n  always @ (posedge rst or posedge sync_clock) begin \n  if(rst) begin \n  toggle_synched_reg <= 1'b0; \n  end else begin \n  toggle_synched_reg <= toggle_synched; \n  end \n  end \n  assign trigger_out = toggle_synched ^ toggle_synched_reg; \n  end \n endgenerate \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a sequential ROM. It takes an address input and provides the corresponding data output. The ROM is initialized with data from the \"seq_rom.dat\" file. The data at the specified address is output to q.\n\n Module header:\n\nmodule seq_rom (input [`SEQ_ADDR_WIDTH-1:0] addr,output [`SEQ_DATA_WIDTH-1:0] q);\n [/INST]\n", "output": "reg [`SEQ_DATA_WIDTH-1:0] rom[0:2**`SEQ_ADDR_WIDTH-1]; \n  assign q = rom[addr]; \n  initial $readmemb(\"seq_rom.dat\", rom); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a memory register that processes various control and data signals based on clock, reset, and enable inputs. It resets the output signals to 0 on reset, and updates the output signals based on the inputs when the enable signal is high. The module handles flushing, memory read and write enables, data inputs, and various control signals.\n\n Module header:\n\nmodule ex_mem_reg #(parameter PC_WIDTH = 20,parameter DATA_WIDTH = 32,parameter INSTRUCTION_WIDTH = 32,parameter REG_ADDR_WIDTH = 5) (input clk,input rst_n,input en,input flush_in,input mem_data_rd_en_in,input mem_data_wr_en_in,input [DATA_WIDTH-1:0] mem_data_in,input [DATA_WIDTH-1:0] alu_data_in,input [DATA_WIDTH-1:0] hi_data_in,input [REG_ADDR_WIDTH-1:0] reg_a_wr_addr_in,input [REG_ADDR_WIDTH-1:0] reg_b_wr_addr_in,input reg_a_wr_en_in,input reg_b_wr_en_in,input write_back_mux_sel_in,input select_new_pc_in,input [PC_WIDTH-1:0] new_pc_in,input [INSTRUCTION_WIDTH-1:0] instruction_in,output reg mem_data_rd_en_out,output reg mem_data_wr_en_out,output reg [DATA_WIDTH-1:0] mem_data_out,output reg [DATA_WIDTH-1:0] alu_data_out,output reg [DATA_WIDTH-1:0] hi_data_out,output reg [REG_ADDR_WIDTH-1:0] reg_a_wr_addr_out,output reg [REG_ADDR_WIDTH-1:0] reg_b_wr_addr_out,output reg reg_a_wr_en_out,output reg reg_b_wr_en_out,output reg write_back_mux_sel_out,output reg select_new_pc_out,output reg [PC_WIDTH-1:0] new_pc_out,output reg [INSTRUCTION_WIDTH-1:0] instruction_out);\n [/INST]\n", "output": "always@(posedge clk, negedge rst_n)begin \n  if(!rst_n)begin \n  mem_data_rd_en_out <= 0; \n  mem_data_wr_en_out <= 0; \n  mem_data_out <= 0; \n  alu_data_out <= 0; \n  hi_data_out <= 0; \n  reg_a_wr_addr_out <= 0; \n  reg_b_wr_addr_out <= 0; \n  reg_a_wr_en_out <= 0; \n  reg_b_wr_en_out <= 0; \n  write_back_mux_sel_out <= 0; \n  select_new_pc_out <= 0; \n  new_pc_out <= 0; \n  instruction_out <= 0; \n  end \n  else if(en) begin \n  if(flush_in)begin \n  mem_data_rd_en_out <= 0; \n  mem_data_wr_en_out <= 0; \n  mem_data_out <= 0; \n  alu_data_out <= 0; \n  hi_data_out <= 0; \n  reg_a_wr_addr_out <= 0; \n  reg_b_wr_addr_out <= 0; \n  reg_a_wr_en_out <= 0; \n  reg_b_wr_en_out <= 0; \n  write_back_mux_sel_out <= 0; \n  select_new_pc_out <= 0; \n  new_pc_out <= 0; \n  instruction_out <= 0; \n  end \n  else begin \n  mem_data_rd_en_out <= mem_data_rd_en_in; \n  mem_data_wr_en_out <= mem_data_wr_en_in; \n  mem_data_out <= mem_data_in; \n  alu_data_out <= alu_data_in; \n  hi_data_out <= hi_data_in; \n  reg_a_wr_addr_out <= reg_a_wr_addr_in; \n  reg_b_wr_addr_out <= reg_b_wr_addr_in; \n  reg_a_wr_en_out <= reg_a_wr_en_in; \n  reg_b_wr_en_out <= reg_b_wr_en_in; \n  write_back_mux_sel_out <= write_back_mux_sel_in; \n  select_new_pc_out <= select_new_pc_in; \n  new_pc_out <= new_pc_in; \n  instruction_out <= instruction_in; \n  end \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a register stage with the capability to reduce latency based on the LOW_LATENCY parameter. When LOW_LATENCY is set, the module uses a single register to store the input data and the output is directly connected to the input if the enable signal is asserted. When LOW_LATENCY is not set, the module uses two registers and a validation register to store the input data and selects the output based on the validation status and enable signal. The selection of the output is done through combinational logic based on the state of the validation register.\n\n Module header:\n\nmodule acl_mem_staging_reg #(parameter WIDTH = 32,parameter LOW_LATENCY = 0) (input wire clk,input wire resetn,input wire enable,input wire [WIDTH-1:0] rdata_in,output logic [WIDTH-1:0] rdata_out);\n [/INST]\n", "output": "generate \n  if (LOW_LATENCY) begin \n  reg [WIDTH-1:0] rdata_r; \n  reg enable_r; \n  always @(posedge clk or negedge resetn) begin \n  if (!resetn) begin \n  enable_r <= 1'b1; \n  end else begin \n  enable_r <= enable; \n  if (enable_r) begin \n  rdata_r <= rdata_in; \n  end \n  end \n  end \n  assign rdata_out = enable_r ? rdata_in : rdata_r; \n  end else begin \n  reg [WIDTH-1:0] rdata_r[0:1]; \n  reg [1:0] rdata_vld_r; \n  reg enable_r; \n  always @(posedge clk or negedge resetn) begin \n  if (!resetn) begin \n  rdata_vld_r <= 2'b00; \n  enable_r <= 1'b0; \n  end else begin \n  if (~rdata_vld_r[1] | enable) begin \n  enable_r <= enable; \n  rdata_vld_r[0] <= ~enable | (~rdata_vld_r[1] & ~enable_r & enable); \n  rdata_vld_r[1] <= rdata_vld_r[0] & (rdata_vld_r[1] | ~enable); \n  rdata_r[1] <= rdata_r[0]; \n  rdata_r[0] <= rdata_in; \n  end \n  end \n  end \n  always @(*) begin \n  case (rdata_vld_r) \n  2'b00: rdata_out = rdata_in; \n  2'b01: rdata_out = rdata_r[0]; \n  2'b10: rdata_out = rdata_r[1]; \n  2'b11: rdata_out = rdata_r[1]; \n  default: rdata_out = {WIDTH{1'bx}}; \n  endcase \n  end \n  end \n  endgenerate \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a display sequencer with a state machine. The sequencer processes input data and controls the display clear state. It defines various states and uses counters to manage the display process. The module also provides output signals indicating busy status, completion of processing, and the validity of the processed data.\n\n Module header:\n\nmodule gci_std_display_sequencer #(parameter P_AREA_H = 640,parameter P_AREA_V = 480,parameter P_AREAA_HV_N = 19,parameter P_MEM_ADDR_N = 23)(input wire iCLOCK,input wire inRESET,input wire iRESET_SYNC,input wire iIF_VALID,output wire oIF_BUSY,input wire [31:0] iIF_DATA,output wire oIF_FINISH,output wire oIF_VALID,input wire iIF_BUSY,output wire [P_MEM_ADDR_N-1:0] oIF_ADDR,output wire [23:0] oIF_DATA);\n [/INST]\n", "output": "localparam P_L_CLEAR_STT_IDLE = 2'h0; \n  localparam P_L_CLEAR_STT_CLEAR = 2'h1; \n  localparam P_L_CLEAR_STT_END = 2'h2; \n  reg [1:0] b_clear_state; \n  reg [7:0] b_clear_color_r; \n  reg [7:0] b_clear_color_g; \n  reg [7:0] b_clear_color_b; \n  reg [P_AREAA_HV_N-1:0] b_clear_counter; \n  always@(posedge iCLOCK or negedge inRESET)begin \n  if(!inRESET)begin \n  b_clear_state <= P_L_CLEAR_STT_IDLE; \n  b_clear_color_r <= 8'h0; \n  b_clear_color_g <= 8'h0; \n  b_clear_color_b <= 8'h0; \n  end \n  else if(iRESET_SYNC)begin \n  b_clear_state <= P_L_CLEAR_STT_IDLE; \n  b_clear_color_r <= 8'h0; \n  b_clear_color_g <= 8'h0; \n  b_clear_color_b <= 8'h0; \n  end \n  else begin \n  case(b_clear_state) \n  P_L_CLEAR_STT_IDLE: \n  begin \n  if(iIF_VALID)begin \n  b_clear_state <= P_L_CLEAR_STT_CLEAR; \n  {b_clear_color_r, \n  b_clear_color_g, \n  b_clear_color_b} <= iIF_DATA[23:0]; \n  end \n  end \n  P_L_CLEAR_STT_CLEAR: \n  begin \n  if(b_clear_counter == (P_AREA_H*P_AREA_V))begin \n  b_clear_state <= P_L_CLEAR_STT_END; \n  end \n  end \n  P_L_CLEAR_STT_END: \n  begin \n  b_clear_state <= P_L_CLEAR_STT_IDLE; \n  end \n  default: \n  begin \n  b_clear_state <= P_L_CLEAR_STT_IDLE; \n  end \n  endcase \n  end \n  end \n  always@(posedge iCLOCK or negedge inRESET)begin \n  if(!inRESET)begin \n  b_clear_counter <= {P_AREAA_HV_N{1'b0}}; \n  end \n  else if(iRESET_SYNC)begin \n  b_clear_counter <= {P_AREAA_HV_N{1'b0}}; \n  end \n  else begin \n  if(b_clear_state == P_L_CLEAR_STT_CLEAR)begin \n  if(!iIF_BUSY)begin \n  b_clear_counter <= b_clear_counter + {{P_AREAA_HV_N-1{1'b0}}, 1'b1}; \n  end \n  end \n  else begin \n  b_clear_counter <= {P_AREAA_HV_N{1'b0}}; \n  end \n  end \n  end \n  assign oIF_BUSY = b_clear_state != P_L_CLEAR_STT_IDLE; \n  assign oIF_FINISH = b_clear_state == P_L_CLEAR_STT_END; \n  assign oIF_VALID = !iIF_BUSY && (b_clear_state == P_L_CLEAR_STT_CLEAR); \n  assign oIF_ADDR = b_clear_counter; \n  assign oIF_DATA = {b_clear_color_r, b_clear_color_g, b_clear_color_b}; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a simple control logic for read and write requests. It has inputs for the reset signal, clock signal, write request, and read request, along with outputs for write status and read status. The module uses flip-flops to synchronize with the clock and handle the reset signal. The write status is directly driven by the write request, while the read status depends on the pending read request and the write status.\n\n Module header:\n\nmodule rw_ctrl(nrst, clk, wr_req, rd_req, wr_sta, rd_sta);\n [/INST]\n", "output": "input nrst; \n  input clk; \n  input wr_req; \n  input rd_req; \n  output wr_sta; \n  output rd_sta; \n  reg wr_sta; \n  reg rd_pend; \n  always @(posedge clk or negedge nrst) begin \n  if (~nrst) begin \n  wr_sta <= 1'b0; \n  end else begin \n  wr_sta <= wr_req; \n  end \n  end \n  always @(posedge clk or negedge nrst) begin \n  if (~nrst) begin \n  rd_pend <= 1'b0; \n  end else if (rd_req) begin \n  rd_pend <= 1'b1; \n  end else if (rd_sta) begin \n  rd_pend <= 1'b0; \n  end \n  end \n  assign rd_sta = rd_pend & ~wr_sta; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a time signal generator. It keeps track of the number of clock cycles and generates a signal `time_out` which indicates a second based on the clock input. When the reset signal is not asserted, both `clk_number` and `sec_kp` are set to 0. On each clock cycle, `clk_number` is incremented, and when it reaches 25 million, it resets back to 0 and `sec_kp` toggles between 0 and 1 based on the clock cycle count.\n\n Module header:\n\nmodule time_signal (input wire clk,input wire reset,output wire time_out);\n [/INST]\n", "output": "reg [24:0] clk_number; \n  reg [0:0] sec_kp; \n  assign time_out = sec_kp; \n  always @(posedge clk) \n  begin \n  if (!reset) \n  begin \n  clk_number <= 25'd0; \n  sec_kp <= 1'd0; \n  end \n  else \n  begin \n  if (clk_number <= 25'd25000000) \n  clk_number <= clk_number + 25'd1; \n  else \n  clk_number <= 25'd0; \n  if (clk_number > 25'd12500000) \n  sec_kp <= 1'd1; \n  else \n  sec_kp <= 1'd0; \n  end \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a Linear Feedback Shift Register (LFSR) with a length of 15 bits. The LFSR is driven by a clock input and a reset input. When the reset input is low, the output is set to 0, and the LFSR is initialized to the value 15'b111111111111111. On each clock edge, the LFSR is shifted left by one bit and the leftmost bit is replaced with the XOR of the two rightmost bits. If the LFSR reaches the value 15'b001000010001100, the output is set to 1.\n\n Module header:\n\nmodule LFSR25000(input Clock,input Reset,output reg Out);\n [/INST]\n", "output": "reg [14:0] LFSR; \n always @(posedge Clock, negedge Reset) begin \n  if(Reset==0) begin \n  Out <= 0; \n  LFSR <= 15'b111111111111111; \n  end \n  else begin \n  LFSR[0] <= LFSR[13] ^ LFSR[14]; \n  LFSR[14:1] <= LFSR[13:0]; \n  if(LFSR==15'b001000010001100) Out <= 1; \n  end \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is a D flip-flop with asynchronous reset. It takes in a clock signal, a reset signal, and a 18-bit data input. Upon the rising edge of the clock, if the reset signal is asserted, the output q is set to zero. Otherwise, the output q is updated with the input data d. If the `RANDOM_INIT` flag is set, the initial values of q are randomized. Additionally, the module includes error checks for the reset signal being asserted at the end of simulation.\n\n Module header:\n\nmodule dffc_18 ( clk, reset, d, q );\n [/INST]\n", "output": "input clk; \n  input reset; \n  input [17:0] d; \n  output [17:0] q; \n  reg [17:0] q; \n `ifdef RANDOM_INIT \n  initial \n  $random_init(\"q\"); \n `endif \n `ifdef CHK_RESET_EOS \n assert_quiescent_state #(0,1,0,\"***ERROR ASSERT: reset still asserted at end of simulation\") \n a0(.clk(clk),.reset_n(1'b1), .state_expr(reset),.check_value(1'b0), .sample_event(1'b0)); \n `endif \n  always @(posedge clk) begin \n  if (reset) \n  q <= 18'b0; \n  else \n  q <= d; \n  end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a bidirectional buffer, which controls the direction of the input/output signal based on the input enable signal (oe). The module features various parameters for controlling the driver's characteristics such as current strength, slew rate, and termination. It uses a case statement to determine the output value based on the input signal. The bidirectional input/output signal (bidirin) and the output signal (io) are assigned based on the input enable signal. When the enable signal is deasserted, the bidirectional signal takes the value stored in the temporary output register, and when the enable signal is asserted, the bidirectional signal becomes high impedance. Similarly, the output signal follows the behavior of the input enable signal.\n\n Module header:\n\nmodule alt_bidir_buf (oe, bidirin, io);\n [/INST]\n", "output": "input oe; \n  inout bidirin; \n  inout io; \n  parameter io_standard = \"NONE\"; \n  parameter current_strength = \"NONE\"; \n  parameter current_strength_new = \"NONE\"; \n  parameter slew_rate = -1; \n  parameter location = \"NONE\"; \n  parameter enable_bus_hold = \"NONE\"; \n  parameter weak_pull_up_resistor = \"NONE\"; \n  parameter termination = \"NONE\"; \n  parameter input_termination = \"NONE\"; \n  parameter output_termination = \"NONE\"; \n  parameter lpm_type = \"alt_bidir_diff\"; \n  reg out_tmp; \n  always @(io) \n  begin \n  casex(io) \n  1'b0: out_tmp = 1'b0; \n  1'b1: out_tmp = 1'b1; \n  default: out_tmp = 1'bx; \n  endcase \n  end \n  assign bidirin = (oe === 1'b0) ? out_tmp : (oe === 1'b1) ? 1'bz : 1'bx; \n  assign io = (oe === 1'b1) ? bidirin : (oe === 1'b0) ? 1'bz : 1'bx; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module, named Test, generates two instances of a counter, one for each bit of the input clkvec. Each counter increments its respective count value on the positive edge of its corresponding clkvec signal. The count values are stored in the output register count.\n\n Module header:\n\nmodule Test (input wire [1:0] clkvec,output reg [1:0] count);\n [/INST]\n", "output": "genvar igen; \n  generate \n  for (igen=0; igen<2; igen=igen+1) begin : code_gen \n  wire clk_tmp = clkvec[igen]; \n  initial count[igen] = 1'b0; \n  always @ (posedge clk_tmp) \n  count[igen] <= count[igen] + 1; \n  end \n  endgenerate \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module `foc_consts_32x32` implements a memory with 32-bit output, controlled by a 5-bit address input `addr`. It initializes the output `q` to zero and updates it based on the input address on the positive edge of the clock signal `c`. Depending on the value of the address, the module assigns specific 32-bit values to the output `q`.\n\n Module header:\n\nmodule foc_consts_32x32 (input c,input [ 4:0] addr,output reg [31:0] q);\n [/INST]\n", "output": "initial q = 32'h0; \n always @(posedge c) begin \n  case (addr) \n  5'h00: q = 32'hc680_0000; \n  5'h01: q = 32'h3bd5_5555; \n  5'h02: q = 32'h3f2a_aaab; \n  5'h03: q = 32'hbeaa_aaab; \n  5'h04: q = 32'h3f13_cd36; \n  5'h05: q = 32'hbf13_cd36; \n  5'h06: q = 32'hbf80_0000; \n  5'h07: q = 32'hbf00_0000; \n  5'h08: q = 32'h3f5d_ddde; \n  5'h09: q = 32'h451f_f000; \n  5'h0a: q = 32'h424c_b852; \n  5'h0b: q = 32'h459f_f800; \n  5'h0c: q = 32'h3856_bf95; \n  5'h0d: q = 32'h3f00_0000; \n  5'h0e: q = 32'h4680_0000; \n  5'h0f: q = 32'h40c9_0fdb; \n  5'h10: q = 32'h3fc9_0fdb; \n  5'h11: q = 32'h39c9_0fdb; \n  5'h12: q = 32'h0; \n  5'h13: q = 32'h0; \n  5'h14: q = 32'h0; \n  5'h15: q = 32'h0; \n  5'h16: q = 32'h0; \n  5'h17: q = 32'h0; \n  5'h18: q = 32'h0; \n  5'h19: q = 32'h0; \n  5'h1a: q = 32'h0; \n  5'h1b: q = 32'h0; \n  5'h1c: q = 32'h0; \n  5'h1d: q = 32'h0; \n  5'h1e: q = 32'h0; \n  5'h1f: q = 32'h0; \n  endcase \n end \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is designed to generate a timing signal using a D-type flip-flop and a rotate-shift register. The module takes an input clock signal, a clear signal, and generates a timing signal of length LEN. It uses D-type flip-flops and a rotate-shift register to manipulate the input signals and produce the desired timing signal. The flip-flop and rotate-shift register are instantiated inside the module to achieve this functionality.\n\n Module header:\n\nmodule timing_signal #(parameter LEN = 4) (input clk,input clr_n,output [(LEN-1):0] Tp);\n [/INST]\n", "output": "wire D_Q, D_Qbar; \n  wire [(LEN-1):0] Q, Qbar; \n  assign Tp = {Qbar[3], Q[1], Q[2]&Qbar[1], Q[3]&Qbar[2]}; \n D_ff #(.LEN(1)) D (.clk(~clk),.clr_n(clr_n),.D(Q[1]),.Q(D_Q),.Qbar(D_Qbar)); \n rotate_shift_register #(LEN) ROTATE (.clk(~(~clk&D_Qbar)),.clr(clk&D_Q),.D({1'b1, Q[3], Q[2],1'b0}),.Q(Q),.Qbar(Qbar)); \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module is designed for an FPGA (DE0 Nano) and controls the LED sequence based on the clock and switch inputs. The module uses a clock divider and case statements to set the clock frequency based on the switch input. Additionally, it implements a state machine to control the LED sequence, transitioning from one LED sequence to the next on each clock cycle. The output LED is driven by the current LED sequence.\n\n Module header:\n\nmodule DE0Nano_Switch(CLOCK_50,LED,SW);\n [/INST]\n", "output": "parameter LED_SEQUENCE_0 =11'b10000001_000; \n parameter LED_SEQUENCE_1 =11'b01000010_001; \n parameter LED_SEQUENCE_2 =11'b00100100_010; \n parameter LED_SEQUENCE_3 =11'b00011000_011; \n parameter LED_SEQUENCE_4 =11'b00100100_100; \n parameter LED_SEQUENCE_5 =11'b01000010_101; \n input CLOCK_50; \n output [7:0]LED; \n input [3:0]SW; \n wire Clock_Sequence; \n reg [10:0]LedsState; \n reg [10:0]LedsNextState; \n reg [27:0]ClockSetup; \n ClockDivider #(.Bits_counter (28)) unit8 \n ( .P_CLOCK(CLOCK_50),.P_TIMER_OUT(Clock_Sequence),.P_COMPARATOR(ClockSetup)); \n  always @(*) \n  begin \n  case (SW) \n  4'h0: ClockSetup = 28'd1000000; \n  4'h1: ClockSetup = 28'd2000000; \n  4'h2: ClockSetup = 28'd3000000; \n  4'h3: ClockSetup = 28'd4000000; \n  4'h4: ClockSetup = 28'd5000000; \n  4'h5: ClockSetup = 28'd6000000; \n  4'h6: ClockSetup = 28'd7000000; \n  4'h7: ClockSetup = 28'd8000000; \n  4'h8: ClockSetup = 28'd9000000; \n  4'h9: ClockSetup = 28'd10000000; \n  4'hA: ClockSetup = 28'd11000000; \n  4'hB: ClockSetup = 28'd12000000; \n  4'hC: ClockSetup = 28'd13000000; \n  4'hD: ClockSetup = 28'd14000000; \n  4'hE: ClockSetup = 28'd15000000; \n  4'hF: ClockSetup = 28'd16000000; \n  endcase \n  end \n  always @(*) \n  begin \n  case (LedsState) \n  LED_SEQUENCE_0: LedsNextState=LED_SEQUENCE_1; \n  LED_SEQUENCE_1: LedsNextState=LED_SEQUENCE_2; \n  LED_SEQUENCE_2: LedsNextState=LED_SEQUENCE_3; \n  LED_SEQUENCE_3: LedsNextState=LED_SEQUENCE_4; \n  LED_SEQUENCE_4: LedsNextState=LED_SEQUENCE_5; \n  LED_SEQUENCE_5: LedsNextState=LED_SEQUENCE_0; \n  endcase \n  end \n  always @ (posedge Clock_Sequence) \n  begin \n  LedsState<=LedsNextState; \n  end \n assign LED = LedsState[10:3]; \n endmodule"}
{"input": "\n    <s>[INST] <<SYS>>\n    \n\nThis Verilog module implements a three-input OAI3 gate, where the output Y is the negation of the AND operation of the logical OR of inputs A and B with input C.\n\n Module header:\n\nmodule \\$_OAI3_ (A, B, C, Y);\n [/INST]\n", "output": "input A, B, C; \n output Y; \n assign Y = ~((A | B) & C); \n endmodule"}
